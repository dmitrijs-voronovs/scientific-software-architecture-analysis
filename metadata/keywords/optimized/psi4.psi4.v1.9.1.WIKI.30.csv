quality_attribute,sentence,source,author,repo,version,id,keyword,matched_word,match_idx,filename,wiki,url,total_similar,target_keywords,target_matched_words
Energy Efficiency,"ization is invoked in sandwich mode,; all Cfour optimization keywords (e.g., CFOUR_GEO_MAXCYC) are; ineffective, as the Cfour optimizer is never invoked. PSI4; optimization keywords (e.g., GEOM_MAXITER) instead fill; these roles.; Specifying the computational method (through, for instance,; energy('c4-ccsd') instead of energy('cfour')) often; sets additional keywords consistent with best practices (e.g.,; CFOUR_CC_PROGRAM). Since those settings are implicit, any; explicit setting of those those keywords, whether contradicting or; concurring, takes priority (halts never generated). The following are; some concrete examples. For the moment, click the source button at; muster_modelchem for details of what keywords; get set. runs in vcc since that’s Cfour’s default for cc_program; set cfour_calc_level ccsd; energy('cfour'). runs in ecc since Cfour’s default overwritten by keyword; set cfour_calc_level ccsd; set cfour_cc_program ecc; energy('cfour'). runs in ecc since that’s best practice for the requested ccsd; energy('c4-ccsd'). runs in vcc since hidden default overwritten by keyword; set cfour_cc_program vcc; energy('c4-ccsd'). Specifying certain keywords that are nominally applicable for pure-PSI4 modules directs them to fulfil analogous roles; in the Cfour program (e.g., MAXITER is used to set; CFOUR_SCF_MAXCYC). This keyword translation only takes place; if the keywords are explicitly set in the input file (part of that; contract that you mean it), meaning that PSI4‘s defaults don’t; get imposed on Cfour. Also, in the case where a translatable pure-PSI4 keyword and its translation Cfour keyword are both set,; the value attached to the latter is always used. Below are a few; clarifying examples. uses \(10^{-7}\) SCF conv crit since that’s Cfour’s default; for CFOUR_SCF_CONV; energy('c4-scf'). uses \(10^{-6}\) SCF conv crit since default overwritten by; keyword; set cfour_scf_conv 6; energy('c4-scf'). uses \(10^{-5}\) SCF conv crit since default overwritten by; SCF m",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/cfour-1.html:32366,energy,energy,32366,psi4manual/1.4.0/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/cfour-1.html,9,['energy'],['energy']
Energy Efficiency,"ization potential/electron affinity (IP/EA) [Nooijen:1995:3629]; approaches.; The Psi4FockCI plugin allows one to perform spin-flip (SF), ionization; potential (IP), and electron affinity (EA) calculations, as well as; combined RAS-SF-IP/EA calculations, through the DETCI (CI: Configuration Interaction) module. Installation¶. Download the plugin from the GitHub repository:; >>> git clone https://github.com/shannonhouck/psi4fockci.git. Once downloaded, the plugin can be installed as follows:; >>> cd {top-level-psi4fockci-directory}; >>> python -m pip install . Sample Input¶; To run a CAS-nSF-IP/EA calculation, start with a molecule with the; correct charge and multiplicity for the reference state (i.e. some; state well-represented by a single reference). Then, run an energy; calculation, passing in the charge and multiplicity of the; desired state; the number of spin-flips and IP/EA will be automatically; determined based on this input. If additional excitations outside of the; RAS II space are desired, one can set the level of external; excitations using the conf_space keyword.; A sample input file for a RAS(h)-2SF-IP calculation is shown below:; molecule {; 0 7; N 0.0 0.0 0.0; N 0.0 0.0 1.3; symmetry c1; }. set {; basis cc-pVDZ; }. energy('psi4fockci', new_charge=1, new_multiplicity=1, conf_space=""h""). Note that for calculations involving IP/EA, inclusion of hole (for IP) and; particle (for EA) excitations is strongly recommended. Additional keywords; can be found in the documentation.; This input file can be run with Psi4:; >>> psi4 input.dat. table of contents. Psi4FockCI: A General Fock-Space CI For Spin-Flip And IP/EA; Installation; Sample Input. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Psi4FockCI: A General Fock-Space CI For Spin-Flip And IP/EA. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/plugin_psi4fockci.html:1866,energy,energy,1866,psi4manual/1.6.x/plugin_psi4fockci.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugin_psi4fockci.html,1,['energy'],['energy']
Energy Efficiency,"ization. The OSOs are rarely; encountered, as usually we go straight from USOs to MOs.; MO (Molecular Orbitals): The combination of OSOs that diagonalizes; the Fock Matrix, so each basis function is a Hartree-Fock (or Kohn-Sham); molecular orbital. The number of OSOs and MOs is always the same. MOs are; orthonormal.; LO (Localized Orbitals): Localized occupied orbitals, a different; combination of the occupied molecular orbitals which enhances spatial; locality. LOs do not diagonalize the occ-occ block of the Fock Matrix, but; remain orthonormal to each other and the virtual space. How to name orbital dimensions¶; There are a number of different names used to refer to the basis set size.; These may seem redundant, but they have subtly different meanings, as; detailed below.; A calculation can use either pure (5D, 7F, 9G, etc.) basis functions or; Cartesian (6D, 10F, 15G, etc.), as dictated by the input file / basis set; specification. Also, the basis can be represented in terms of atomic; orbitals (AO) or symmetry-adapted orbitals (SO). Further complications; come from the fact that a nearly linearly-dependent basis set will have; functions removed from it to prevent redundancies. With all of these; factors in mind, here are the conventions used internally:. nao — The number of atomic orbitals in Cartesian representation.; nso — The number of atomic orbitals but in the pure representation if the current basis uses pure functions, number of Cartesian AOs otherwise.; nbf — The number of basis functions, which is the same as nso.; nmo — The number of basis functions, after projecting out redundancies in the basis. When molecular symmetry is utilized, a small array of sizes per irrep is; usually allocated on the stack, and is named by augmenting the name above; with a pi (per-irrep), e.g. nmopi. Note that the number of irreps is; always the singular nirrep, and that the index variable h is always used; in a for-loop traverse of irreps. How to name orbital spaces (e.g., ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/prog_blas-1.html:11740,adapt,adapted,11740,psi4manual/1.4.0/prog_blas-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/prog_blas-1.html,9,['adapt'],['adapted']
Energy Efficiency,"ization. Type: integer; Default: 1000. PNO_CONVERGENCE¶. General convergence criteria for DLPNO methods. Type: string; Possible Values: LOOSE, NORMAL, TIGHT; Default: NORMAL. R_CONVERGENCE¶. Residual convergence criteria for local MP2 iterations. Type: conv double; Default: 1e-6. Expert Expert Options¶. F_CUT¶. Fock matrix threshold for treating ampltudes as coupled during local MP2 iterations. Type: double; Default: 1e-5. S_CUT¶. Overlap matrix threshold for removing linear dependencies. Type: double; Default: 1e-8. T_CUT_CLMO¶. Basis set coefficient threshold for including basis function (m) in domain of LMO (i). Type: double; Default: 1e-2. T_CUT_CPAO¶. Basis set coefficient threshold for including basis function (n) in domain of PAO (u). Type: double; Default: 1e-3. T_CUT_DO¶. DOI threshold for including PAO (u) in domain of LMO (i). Type: double; Default: 1e-2. T_CUT_DO_PRE¶. DOI threshold for including PAO (u) in domain of LMO (i) during pre-screening. Type: double; Default: 3e-2. T_CUT_DO_IJ¶. DOI threshold for treating LMOs (i,j) as interacting. Type: double; Default: 1e-5. T_CUT_MKN¶. Mulliken charge threshold for including aux BFs on atom (a) in domain of LMO (i). Type: double; Default: 1e-3. T_CUT_PNO¶. Occupation number threshold for removing PNOs. Type: double; Default: 1e-8. T_CUT_PRE¶. Pair energy threshold (dipole approximation) for treating LMOs (i, j) as interacting. Type: double; Default: 1e-6. table of contents. DLPNO; General Options; DF_BASIS_MP2; DLPNO_LOCAL_ORBITALS; DLPNO_MAXITER; E_CONVERGENCE; LOCAL_CONVERGENCE; LOCAL_MAXITER; PNO_CONVERGENCE; R_CONVERGENCE. Expert Expert Options; F_CUT; S_CUT; T_CUT_CLMO; T_CUT_CPAO; T_CUT_DO; T_CUT_DO_PRE; T_CUT_DO_IJ; T_CUT_MKN; T_CUT_PNO; T_CUT_PRE. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Appendices; Keywords by Module; DLPNO. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodir_options_c/module__dlpno.html:1983,charge,charge,1983,psi4manual/1.6.x/autodir_options_c/module__dlpno.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodir_options_c/module__dlpno.html,4,"['charge', 'energy']","['charge', 'energy']"
Energy Efficiency,"ize a geometry (HOOH) at a frozen dihedral angle of 90 degrees.; molecule {; H; O 1 0.90; O 2 1.40 1 100.0; H 3 0.90 2 100.0 1 90.0; }. set optking {; frozen_dihedral = (""; 1 2 3 4; ""); }; optimize('scf'). To instead freeze the two O-H bond distances; set optking {; frozen_distance = (""; 1 2; 3 4; ""); }. For bends, the corresponding keyword is “frozen_bend”. To freeze the cartesian coordinates of atom 2. freeze_list = """"""; 2 xyz; """"""; set optking frozen_cartesian $freeze_list. To freeze only the y coordinates of atoms 2 and 3. freeze_list = """"""; 2 y; 3 y; """"""; set optking frozen_cartesian $freeze_list. To optimize toward a value of 0.95 Angstroms for the distance between; atoms 1 and 3, as well as that between 2 and 4. set optking {; fixed_distance = (""; 1 3 0.95; 2 4 0.95; ""); }. Note that the effect of the frozen and fixed keywords is independent of; how the geometry of the molecule was input (whether Z-matrix or cartesian, etc.).. To scan the potential energy surface by optimizing at several fixed values; of the dihedral angle of HOOH. molecule hooh {; 0 1; H 0.850718 0.772960 0.563468; O 0.120432 0.684669 -0.035503; O -0.120432 -0.684669 -0.035503; H -0.850718 -0.772960 0.563468; }. set {; basis cc-pvdz; intrafrag_step_limit 0.1; }. dihedrals = [100,110,120,130,140,150]; PES = []. for phi in dihedrals:; my_string = ""1 2 3 4 "" + str(phi); set optking fixed_dihedral = $my_string; E = optimize('scf'); PES.append((phi, E)). print ""\n\tcc-pVDZ SCF energy as a function of phi\n""; for point in PES:; print ""\t%5.1f%20.10f"" % (point[0], point[1]). Dealing with problematic optimizations¶; Although optking is continuously improved with robustness in mind, some; attempted optimizations will inevitably fail to converge to the desired minima.; For difficult cases, the following suggestions are made. As for any optimizer, computing the Hessian and limiting the step size will; successfully converge a higher percentage of cases. The default settings have; been chosen because they",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/optking-1.html:7154,energy,energy,7154,psi4manual/1.4.0/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/optking-1.html,5,['energy'],['energy']
Energy Efficiency,"ize a geometry (HOOH) at a frozen dihedral angle of 90 degrees.; molecule {; H; O 1 0.90; O 2 1.40 1 100.0; H 3 0.90 2 100.0 1 90.0; }. set optking {; frozen_dihedral = (""; 1 2 3 4; ""); }; optimize('scf'). To instead freeze the two O-H bond distances; set optking {; frozen_distance = (""; 1 2; 3 4; ""); }. For bends, the corresponding keyword is “frozen_bend”. To freeze the cartesian coordinates of atom 2; freeze_list = """"""; 2 xyz; """"""; set optking frozen_cartesian $freeze_list. To freeze only the y coordinates of atoms 2 and 3; freeze_list = """"""; 2 y; 3 y; """"""; set optking frozen_cartesian $freeze_list. To optimize toward a value of 0.95 Angstroms for the distance between; atoms 1 and 3, as well as that between 2 and 4; set optking {; fixed_distance = (""; 1 3 0.95; 2 4 0.95; ""); }. Note that the effect of the frozen and fixed keywords is independent of; how the geometry of the molecule was input (whether Z-matrix or cartesian, etc.).. To scan the potential energy surface by optimizing at several fixed values; of the dihedral angle of HOOH.; molecule hooh {; 0 1; H 0.850718 0.772960 0.563468; O 0.120432 0.684669 -0.035503; O -0.120432 -0.684669 -0.035503; H -0.850718 -0.772960 0.563468; }. set {; basis cc-pvdz; intrafrag_step_limit 0.1; }. dihedrals = [100,110,120,130,140,150]; PES = []. for phi in dihedrals:; my_string = ""1 2 3 4 "" + str(phi); set optking fixed_dihedral = $my_string; E = optimize('scf'); PES.append((phi, E)). print ""\n\tcc-pVDZ SCF energy as a function of phi\n""; for point in PES:; print ""\t%5.1f%20.10f"" % (point[0], point[1]). Dealing with problematic optimizations¶; Although optking is continuously improved with robustness in mind, some; attempted optimizations will inevitably fail to converge to the desired minima.; For difficult cases, the following suggestions are made. As for any optimizer, computing the Hessian and limiting the step size will; successfully converge a higher percentage of cases. The default settings have; been chosen because the",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/optking-1.html:7166,energy,energy,7166,psi4manual/1.0.0/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/optking-1.html,2,['energy'],['energy']
Energy Efficiency,"ize the active occupied orbitals via IBO2. matrices(self); Return the interally computed matrices (not copied). molecule(self); Returns the FISAPT's molecule. nuclear(self); Build the nuclear potentials V and interaction energies. overlap(self); Build the overlap integrals S. partition(self); Partition the nuclei and electrons. plot(); Filesystem wrapper for FISAPT::plot. print_header(self); Print header, bases, sizes, etc. print_trailer(self); Print SAPT results. raw_plot(self, arg0); Plot some analysis files. scalars(self); Return the interally computed scalars (not copied). scf(self); Solve the relaxed SCF equations for A0 and B0. sinf_disp(self, arg0, arg1, arg2); Computes the MP2-based DispE20 and Exch-DispE20 energy without S^2. unify(self); Produce unified matrices for A', B', and C'. unify_part2(self); Finish producing unified matrices for A', B', and C'. vectors(self); Return the interally computed vectors (not copied). Methods Documentation. compute_energy(external_potentials=None)¶; Computes the FSAPT energy. FISAPT::compute_energy. coulomb(self: psi4.core.FISAPT) → None¶; Build the J/K potentials for C, D, and E. dHF(self: psi4.core.FISAPT) → None¶; SAPT0 delta HF. disp(self: psi4.core.FISAPT, arg0: Dict[str, psi4.core.Matrix], arg1: Dict[str, psi4.core.Vector], arg2: bool) → None¶; Computes the MP2-based DispE20 and Exch-DispE20 energy. do_cubes(self: psi4.core.FISAPT) → None¶; Prepare cube files for orbital/density pictures. elst(self: psi4.core.FISAPT) → None¶; SAPT0 electrostatics. exch(self: psi4.core.FISAPT) → None¶; SAPT0 exchange. fdisp(self: psi4.core.FISAPT) → None¶; F-SAPT0 dispersion. fdrop(external_potentials=None)¶; Drop output files from FSAPT calculation. FISAPT::fdrop. felst(self: psi4.core.FISAPT) → None¶; F-SAPT0 electrostatics. fexch(self: psi4.core.FISAPT) → None¶; F-SAPT0 exchange. find(self: psi4.core.FISAPT) → None¶; F-SAPT0 induction. flocalize(self: psi4.core.FISAPT) → None¶; F-SAPT0 localize. freeze_core(self: psi4.core.FISAPT)",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/api/psi4.core.FISAPT.html:1998,energy,energy,1998,psi4manual/1.8.x/api/psi4.core.FISAPT.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.FISAPT.html,2,['energy'],['energy']
Energy Efficiency,"ize-extensive and size-consistent. Furthermore, the N-representability; problem is now greatly simplified, because the idempotent part of \(\boldsymbol{\gamma_1}\) is; N-representable by construction. One only needs to worry about the; N-representability of the density cumulant, which is a relatively small part of; \(\boldsymbol{\gamma_2}\).; In order to obtain the DCFT energy, two conditions must be satisfied:. The energy must be stationary with respect to a set of orbitals. This can be done by; diagonalizing the generalized Fock operator (as in the DC-06 and DC-12 methods, see below),; which introduces partial orbital relaxation, or by fully relaxing the orbitals and minimizing the entire energy expression; (as in the ODC-06 and ODC-12 methods).; The energy must be stationary with respect to the variation of the density; cumulant \(\boldsymbol{\lambda_2}\), constrained to N-representability conditions. Making the energy stationary requires solution of two sets of coupled; equations for orbitals and density cumulant, respectively (also known as; residual equations). At the present moment, three different algorithms for the; solution of the system of coupled equations are available (see; Iterative Algorithms for details).; Publications resulting from the use of the DCFT code should cite contributions; listed here. Methods¶; Currently five DCFT methods (functionals) are available: DC-06, DC-12, ODC-06, ODC-12, and ODC-13. The first four; methods use approximate N-representability conditions derived from; second-order perturbation theory and differ in the description of the; correlated (non-idempotent) part \(\boldsymbol{\tau}\) of the one-particle density; matrix and orbital optimization. While in the DC-06 and ODC-06 methods \(\boldsymbol{\tau}\) is derived from the density cumulant; in an approximate way (labelled by ‘06’), the DC-12 and ODC-12 methods derive this contribution exactly, and; take full advantage of the N-representability conditions (which is denoted ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/dcft-1.html:4225,energy,energy,4225,psi4manual/1.2.1/dcft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/dcft-1.html,6,['energy'],['energy']
Energy Efficiency,"jatom + 1. # Set a lattice of point charges; def set_lattice_field(self):; """""" Set a field of lattice point charges using information received through MDI; """"""; arr = []; for ilat in range(self.nlattice):; arr.append(self.lattice[ilat]); arr.append(self.clattice[3 * ilat + 0]); arr.append(self.clattice[3 * ilat + 1]); arr.append(self.clattice[3 * ilat + 2]); self.kwargs[""external_potentials""] = np.array(arr).reshape((-1, 4)); self.set_lattice = True. # Respond to the >NLATTICE command; def recv_nlattice(self, nlattice=None):; """""" Receive the number of lattice point charges through MDI. Arguments:; nlattice: New number of point charges. If None, receive through MDI.; """"""; if nlattice is None:; self.nlattice = MDI_Recv(1, MDI_INT, self.comm); else:; self.nlattice = nlattice; self.clattice = [0.0 for ilat in range(3 * self.nlattice)]; self.lattice = [0.0 for ilat in range(self.nlattice)]; self.set_lattice_field(). # Respond to the >CLATTICE command; def recv_clattice(self, clattice=None):; """""" Receive the coordinates of a set of lattice point charges through MDI. Arguments:; clattice: New coordinates of the lattice of point charges. If None, receive through MDI.; """"""; if clattice is None:; self.clattice = MDI_Recv(3 * self.nlattice, MDI_DOUBLE, self.comm); else:; self.clattice = clattice; self.set_lattice_field(). # Respond to the >LATTICE command; def recv_lattice(self, lattice=None):; """""" Receive the charges of a set of lattice point charges through MDI. Arguments:; lattice: New charges of the lattice of point charges. If None, receive through MDI.; """"""; if lattice is None:; self.lattice = MDI_Recv(self.nlattice, MDI_DOUBLE, self.comm); else:; self.lattice = lattice; self.set_lattice_field(). # Respond to the SCF command; def run_scf(self):; """""" Run an energy calculation; """"""; self.energy = psi4.energy(self.scf_method, **self.kwargs). # Respond to the <DIMENSIONS command; def send_dimensions(self):; """""" Send the dimensionality of the system through MDI. :returns: *di",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/mdi_engine.html:9495,charge,charges,9495,psi4manual/1.6.x/_modules/psi4/driver/mdi_engine.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/mdi_engine.html,10,['charge'],['charges']
Energy Efficiency,"ject at 0x12d884fc0>; >>> psi4.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). """"""; key = _qcvar_warnings(key). if core.has_scalar_variable(key):; return core.scalar_variable(key); elif core.has_array_variable(key):; return _qcvar_reshape_get(key, core.array_variable(key)); else:; raise KeyError(f""psi4.core.variable: Requested variable '{key}' was not set!\n""). def _core_wavefunction_variable(self: core.Wavefunction, key: str) -> Union[float, core.Matrix, np.ndarray]:; """"""Return copy of scalar or array :ref:`QCVariable <sec:appendices:qcvars>`; *key* from *self*. Parameters; ----------; self; Wavefunction instance.; key; Case-insensitive key to instance's double or :py:class:`~psi4.core.Matrix`; storage maps. Returns; -------; float or ~numpy.ndarray or Matrix; Requested QCVariable from `self`. - Scalar variables are returned as floats.; - Array variables not naturally 2D (like multipoles or per-atom charges); are returned as :class:`~numpy.ndarray` of natural dimensionality.; - Other array variables are returned as :py:class:`~psi4.core.Matrix` and; may have an extra dimension with symmetry information. Raises; ------; KeyError; If `key` not set on `self`. Example; -------; >>> g, wfn = psi4.gradient(""hf/cc-pvdz"", return_wfn=True); >>> wfn.variable(""CURRENT ENERGY""); -100.00985995185668; >>> wfn.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> wfn.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> wfn.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). """"""; key = _qcvar_warnings(key). if self.has_scalar_variable(key):; return self.scalar_variable(key); elif self.has_array_variable(key):; return _qcvar_reshape_get(key, self.array_variable(key)); else:; raise KeyError(f""psi4.core.Wavefunction.variable: Requested variable '{key}' was not ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html:35140,charge,charges,35140,psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html,8,['charge'],['charges']
Energy Efficiency,"jection from small into; >>> # requested basis, with specified projection fitting basis; >>> set basis_guess true; >>> set df_basis_guess jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). >>> # [3] Arbitrary-order MPn calculation; >>> energy('mp7'). >>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> # Note that the integral transformation is not done automatically when detci is run in a separate step.; >>> molecule H2 {\n0 1\nH\nH 1 0.74\n}; >>> set global basis cc-pVDZ; >>> set global reference rohf; >>> scf_e, scf_wfn = energy('scf', return_wfn = True); >>> H2.set_multiplicity(3); >>> psi4.MintsHelper(scf_wfn.basisset()).integrals(); >>> energy('detci', ref_wfn=scf_wfn). >>> # [5] Run two CI calculations, keeping the integrals generated in the first one.; >>> molecule ne {\nNe\n}; >>> set globals basis cc-pVDZ; >>> cisd_e, cisd_wfn = energy('cisd', return_wfn = True); >>> energy('fci', ref_wfn=cisd_wfn). >>> # [6] Can automatically perform complete basis set extrapolations; >>> energy(""MP2/cc-pV[DT]Z""). """"""; kwargs = p4util.kwargs_lower(kwargs). # Bounce if name is function; if hasattr(name, '__call__'):; return name(energy, kwargs.pop('label', 'custom function'), ptype='energy', **kwargs). # Allow specification of methods to arbitrary order; lowername = name.lower(); lowername, level = driver_util.parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. # Bounce to CP if bsse kwarg; if kwargs.get('bsse_type', None) is not None:; return driver_nbody._nbody_gufunc(energy, name, ptype='energy', **kwargs). # Bounce to CBS if ""method/basis"" name; if ""/"" in lowername:; return driver_cbs._cbs_gufunc(energy, name, ptype='energy', **kwargs). # Commit to procedures['energy'] call hereafter; return_wfn = kwargs.pop('return_wfn', False); psi4.clean_variables(). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', psi4.get_active_molecule()); molecule.update_geometry(). for precallback in ho",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver.html:28490,energy,energy,28490,psi4manual/1.0.0/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver.html,1,['energy'],['energy']
Energy Efficiency,"jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). >>> # [3] Arbitrary-order MPn calculation; >>> energy('mp7'). >>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> # Note that the integral transformation is not done automatically when detci is run in a separate step.; >>> molecule H2 {\n0 1\nH\nH 1 0.74\n}; >>> set global basis cc-pVDZ; >>> set global reference rohf; >>> scf_e, scf_wfn = energy('scf', return_wfn = True); >>> H2.set_multiplicity(3); >>> psi4.MintsHelper(scf_wfn.basisset()).integrals(); >>> energy('detci', ref_wfn=scf_wfn). >>> # [5] Run two CI calculations, keeping the integrals generated in the first one.; >>> molecule ne {\nNe\n}; >>> set globals basis cc-pVDZ; >>> cisd_e, cisd_wfn = energy('cisd', return_wfn = True); >>> energy('fci', ref_wfn=cisd_wfn). >>> # [6] Can automatically perform complete basis set extrapolations; >>> energy(""MP2/cc-pV[DT]Z""). """"""; kwargs = p4util.kwargs_lower(kwargs). # Bounce if name is function; if hasattr(name, '__call__'):; return name(energy, kwargs.pop('label', 'custom function'), ptype='energy', **kwargs). # Allow specification of methods to arbitrary order; lowername = name.lower(); lowername, level = driver_util.parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. # Bounce to CP if bsse kwarg; if kwargs.get('bsse_type', None) is not None:; return driver_nbody._nbody_gufunc(energy, name, ptype='energy', **kwargs). # Bounce to CBS if ""method/basis"" name; if ""/"" in lowername:; return driver_cbs._cbs_gufunc(energy, name, ptype='energy', **kwargs). # Commit to procedures['energy'] call hereafter; return_wfn = kwargs.pop('return_wfn', False); psi4.clean_variables(). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', psi4.get_active_molecule()); molecule.update_geometry(). for precallback in hooks['energy']['pre']:; precallback(lowername, **kwargs). optstash = driver_util._set_convergence_criterion('energy', lowername, 6, 8, 6, 8",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver.html:28632,energy,energy,28632,psi4manual/1.0.0/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver.html,1,['energy'],['energy']
Energy Efficiency,"jun-cc-pvdz; scf_type df; guess sad; freeze_core true; fisapt_do_plot true # For extra analysis; }. energy('fisapt0'). This is essentially the same input as for F-SAPT, except that the molecular; system is now divided into three moieties – subsystems A and B whose; intramolecular interaction we wish to compute, and a linking unit C. This file; runs a DF-HF computation on the full system using PSI4‘s existing SCF code.; At the start of the FISAPT code, the occupied orbitals are localized and divided; by charge considerations into A, B, C, and link sets. By default, linking sigma; bonds are assigned to C (this can be changed by the FISAPT_LINK_ASSIGNMENT; options). Then, non-interacting Hartree–Fock solutions for A and B are optimized; in the embedding field of the linking moiety C. At this point, A and B are not; interacting with each other, but have any potential covalent links or other; interactions with C built in by the embedding. A standard F-SAPT0 computation; is then performed between A and B, yielding the I-SAPT interaction energy. Any; F-SAPT considerations are also possible when I-SAPT is performed – F and I are; completely direct-product-separable considerations. Cube File Visualization with PyMol¶; Setting FISAPT_DO_PLOT true above generates a set of .cube files; containing the densities and ESPs of the various subsystems in the I-SAPT; embedding procedure. These can be used to gain a detailed understanding of the; intermolecular partition and the polarization between non-interacting and; Hartree–Fock-interacting moieties. We have developed a set of template; .pymol scripts to help with this process. These can be obtained by running:; 1>>> copy_pymol2.py. and then in PyMol:; 1>>> @run.pymol. This last command runs all of the individual .pymol files (e.g.,; DA.pymol), which in turn load in the molecule and cube file data; (contained in the .cube file), set up the visualization, and render a; .png image of the scene. Generally the view orientation and some s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/fisapt-1.html:10849,energy,energy,10849,psi4manual/1.1.0/fisapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/fisapt-1.html,2,['energy'],['energy']
Energy Efficiency,"jun-cc-pvdz; scf_type df; guess sad; freeze_core true; fisapt_do_plot true # For extra analysis; }. energy('fisapt0'). This is essentially the same input as for F-SAPT, except that the molecular; system is now divided into three moieties – subsystems A and B whose; intramolecular interaction we wish to compute, and a linking unit C. This file; runs a DF-HF computation on the full system using PSI4‘s existing SCF code.; At the start of the FISAPT code, the occupied orbitals are localized and divided; by charge considerations into A, B, C, and link sets. By default, linking sigma; bonds are assigned to C (this can be changed by the FISAPT_LINK_ASSIGNMENT; options). Then, non-interacting Hartree–Fock solutions for A and B are optimized; in the embedding field of the linking moiety C. At this point, A and B are not; interacting with each other, but have any potential covalent links or other; interactions with C built in by the embedding. A standard F-SAPT0 computation; is then performed between A and B, yielding the I-SAPT interaction energy. Any; F-SAPT considerations are also possible when I-SAPT is performed – F and I are; completely direct-product-separable considerations. Cube File Visualization with PyMol¶; Setting FISAPT_DO_PLOT true above generates a set of .cube files; containing the densities and ESPs of the various subsystems in the I-SAPT; embedding procedure. These can be used to gain a detailed understanding of the; intermolecular partition and the polarization between non-interacting and; Hartree–Fock-interacting moieties. We have developed a set of template; .pymol scripts to help with this process. These can be obtained by running:; >>> copy_pymol2.py. and then in PyMol:; >>> @run.pymol. This last command runs all of the individual .pymol files (e.g.,; DA.pymol), which in turn load in the molecule and cube file data; (contained in the .cube file), set up the visualization, and render a; .png image of the scene. Generally the view orientation and some spe",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/fisapt-1.html:10900,energy,energy,10900,psi4manual/1.4.0/fisapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/fisapt-1.html,9,['energy'],['energy']
Energy Efficiency,"jun-cc-pvdz; scf_type df; guess sad; freeze_core true; fisapt_do_plot true # For extra analysis; }. energy('fisapt0'). This is essentially the same input as for F-SAPT, except that the molecular; system is now divided into three moieties – subsystems A and B whose; intramolecular interaction we wish to compute, and a linking unit C. This file; runs a DF-HF computation on the full system using PSI4’s existing SCF code.; At the start of the FISAPT code, the occupied orbitals are localized and divided; by charge considerations into A, B, C, and link sets. By default, linking sigma; bonds are assigned to C (this can be changed by the FISAPT_LINK_ASSIGNMENT; options). Then, non-interacting Hartree–Fock solutions for A and B are optimized; in the embedding field of the linking moiety C. At this point, A and B are not; interacting with each other, but have any potential covalent links or other; interactions with C built in by the embedding. A standard F-SAPT0 computation; is then performed between A and B, yielding the I-SAPT interaction energy. Any; F-SAPT considerations are also possible when I-SAPT is performed – F and I are; completely direct-product-separable considerations. Cube File Visualization with PyMol¶; Setting FISAPT_DO_PLOT true above generates a set of .cube files; containing the densities and ESPs of the various subsystems in the I-SAPT; embedding procedure. These can be used to gain a detailed understanding of the; intermolecular partition and the polarization between non-interacting and; Hartree–Fock-interacting moieties. We have developed a set of template; .pymol scripts to help with this process. These can be obtained by running:; 1>>> copy_pymol2.py. and then in PyMol:; 1>>> @run.pymol. This last command runs all of the individual .pymol files (e.g.,; DA.pymol), which in turn load in the molecule and cube file data; (contained in the .cube file), set up the visualization, and render a; .png image of the scene. Generally the view orientation and some s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/fisapt-1.html:11218,energy,energy,11218,psi4manual/1.2.1/fisapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/fisapt-1.html,4,['energy'],['energy']
Energy Efficiency,"k I/O in the formation of the DF integrals? Use may speed up the computation slightly at the cost of spawning an additional thread. Type: boolean; Default: false. NO_RESPONSE¶. Don’t solve the CPHF equations? Evaluate and instead of their response-including coupterparts. Only turn on this option if the induction energy is not going to be used. Type: boolean; Default: false. EXCH_SCALE_ALPHA¶. Whether or not to perform exchange scaling for SAPT exchange components. Default is false, i.e. no scaling. If set to true, performs scaling with . If set to a value , performs scaling with . Type: string; Default: FALSE. INTS_TOLERANCE¶. Minimum absolute value below which all three-index DF integrals and those contributing to four-index integrals are neglected. The default is conservative, but there isn’t much to be gained from loosening it, especially for higher-order SAPT. Type: conv double; Default: 1.0e-12. DENOMINATOR_DELTA¶. Maximum error allowed (Max error norm in Delta tensor) in the approximate energy denominators employed for most of the and evaluation. Type: double; Default: 1.0e-6. DENOMINATOR_ALGORITHM¶. Denominator algorithm for PT methods. Laplace transformations are slightly more efficient. Type: string; Possible Values: LAPLACE, CHOLESKY; Default: LAPLACE. DEBUG¶. The amount of information to print to the output file. Type: integer; Default: 0. Higher-Order SAPT¶; For smaller systems (up to the size of a nucleic acid base pair), more; accurate interaction energies can be obtained through higher-order SAPT; computations. The SAPT module can perform density-fitted evaluations; of SAPT2, SAPT2+, SAPT2+(3), and SAPT2+3 energies. Publications resulting; from the use of the higher-order SAPT code should cite the following:; [Hohenstein:2010:014101].; For methods SAPT2+ and above, one can replace the many-body treatment of; dispersion by an improved method based on coupled-cluster doubles (CCD).; This approach tends to give good improvements when dispersion effects; a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/sapt-1.html:11111,energy,energy,11111,psi4manual/1.0.0/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/sapt-1.html,2,['energy'],['energy']
Energy Efficiency,"k Matrix. H(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the ‘Core’ Matrix (Potential + Kinetic) Integrals. S(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the One-electron Overlap Matrix. V_potential(self: psi4.core.HF) → psi4.core.VBase; Returns the internal DFT V object. Va(self: psi4.core.HF) → psi4.core.Matrix; Returns the Alpha Kohn-Shame Potential Matrix. Vb(self: psi4.core.HF) → psi4.core.Matrix; Returns the Alpha Kohn-Shame Potential Matrix. X(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Lagrangian Matrix. alpha_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. aotoso(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Atomic Orbital to Symmetry Orbital transformer. arrays(self: psi4.core.Wavefunction) → Dict[str, psi4.core.Matrix]¶; Returns the map of all internal arrays. atomic_point_charges(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the set atomic point charges. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. build(mol, basis=None)¶. compute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Deep copies the internal data. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of d",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/api/psi4.core.hf.html:5670,charge,charges,5670,psi4manual/1.1.0/api/psi4.core.hf.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.hf.html,1,['charge'],['charges']
Energy Efficiency,"k Matrix. H(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the ‘Core’ Matrix (Potential + Kinetic) Integrals. S(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the One-electron Overlap Matrix. V_potential(self: psi4.core.HF) → psi4.core.VBase; Returns the internal DFT V object. Va(self: psi4.core.HF) → psi4.core.Matrix; Returns the Alpha Kohn-Shame Potential Matrix. Vb(self: psi4.core.HF) → psi4.core.Matrix; Returns the Alpha Kohn-Shame Potential Matrix. X(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Lagrangian Matrix. alpha_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. aotoso(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Atomic Orbital to Symmetry Orbital transformer. arrays(self: psi4.core.Wavefunction) → Dict[str, psi4.core.Matrix]¶; Returns the map of all internal arrays. atomic_point_charges(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the set atomic point charges. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.Wavefunction, basis: psi4.core.BasisSet) → psi4.core.Wavefunction¶; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet *basis. compute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hess",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/api/psi4.core.hf.html:6748,charge,charges,6748,psi4manual/1.2.1/api/psi4.core.hf.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/api/psi4.core.hf.html,1,['charge'],['charges']
Energy Efficiency,"k includes only one member of a pair of determinants related by time reversal symmetry. For very small block sizes, this could conceivably eliminate the entire H0 block; the program should print warnings if this occurs. Type: integer; Default: 400. H0_GUESS_SIZE (DETCI); DETCI (Expert) — size of H0 block for initial guess. Type: integer; Default: 400. H_BOND_CONNECT (OPTKING); OPTKING — For now, this is a general maximum distance for the definition of H-bonds. Type: double; Default: 4.3. HD_AVG (DETCI); DETCI (Expert) — How to average H diag energies over spin coupling sets. HD_EXACT uses the exact diagonal energies which results in expansion vectors which break spin symmetry. HD_KAVE averages the diagonal energies over a spin-coupling set yielding spin pure expansion vectors. ORB_ENER employs the sum of orbital energy approximation giving spin pure expansion vectors but usually doubles the number of Davidson iterations. EVANGELISTI uses the sums and differences of orbital energies with the SCF reference energy to produce spin pure expansion vectors. LEININGER approximation which subtracts the one-electron contribution from the orbital energies, multiplies by 0.5, and adds the one-electron contribution back in, producing spin pure expansion vectors and developed by Matt Leininger and works as well as EVANGELISTI. Type: string; Possible Values: EVANGELISTI, HD_EXACT, HD_KAVE, ORB_ENER, LEININGER, Z_KAVE; Default: EVANGELISTI. HD_OTF (DETCI); DETCI (Expert) — Do compute the diagonal elements of the Hamiltonian matrix on-the-fly? Otherwise, a diagonal element vector is written to a separate file on disk. Type: boolean; Default: true. HEFF4 (PSIMRCC); PSIMRCC — Do include the fourth-order contributions to the effective Hamiltonian?. Type: boolean; Default: true. HEFF_PRINT (PSIMRCC); PSIMRCC — Do print the effective Hamiltonian?. Type: boolean; Default: false. HESS_TYPE (OMP2); OMP2 — Type Hessian matrix will be used in orbital optimization procedure. Type: string; Poss",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html:51128,energy,energy,51128,psi4manual/4.0b3/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html,2,['energy'],['energy']
Energy Efficiency,"k includes only one member of a pair of determinants related by time reversal symmetry. For very small block sizes, this could conceivably eliminate the entire H0 block; the program should print warnings if this occurs. Type: integer; Default: 400. H0_GUESS_SIZE (DETCI); DETCI (Expert) — size of H0 block for initial guess. Type: integer; Default: 400. H_BOND_CONNECT (OPTKING); OPTKING — For now, this is a general maximum distance for the definition of H-bonds. Type: double; Default: 4.3. HD_AVG (DETCI); DETCI (Expert) — How to average H diag energies over spin coupling sets. HD_EXACT uses the exact diagonal energies which results in expansion vectors which break spin symmetry. HD_KAVE averages the diagonal energies over a spin-coupling set yielding spin pure expansion vectors. ORB_ENER employs the sum of orbital energy approximation giving spin pure expansion vectors but usually doubles the number of Davidson iterations. EVANGELISTI uses the sums and differences of orbital energies with the SCF reference energy to produce spin pure expansion vectors. LEININGER approximation which subtracts the one-electron contribution from the orbital energies, multiplies by 0.5, and adds the one-electron contribution back in, producing spin pure expansion vectors and developed by Matt Leininger and works as well as EVANGELISTI. Type: string; Possible Values: EVANGELISTI, HD_EXACT, HD_KAVE, ORB_ENER, LEININGER, Z_KAVE; Default: EVANGELISTI. HD_OTF (DETCI); DETCI (Expert) — Do compute the diagonal elements of the Hamiltonian matrix on-the-fly? Otherwise, a diagonal element vector is written to a separate file on disk. Type: boolean; Default: true. HEFF4 (PSIMRCC); PSIMRCC — Do include the fourth-order contributions to the effective Hamiltonian?. Type: boolean; Default: true. HEFF_PRINT (PSIMRCC); PSIMRCC — Do print the effective Hamiltonian?. Type: boolean; Default: false. HESS_TYPE (OMP2); OMP2 —. Type: string; Possible Values: NONE; Default: NONE. HESS_UPDATE (OPTKING); OPTKING — ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodoc_glossary_options_c-1.html:42154,energy,energy,42154,psi4manual/4.0b2/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodoc_glossary_options_c-1.html,2,['energy'],['energy']
Energy Efficiency,"k includes only one member of a pair of determinants related by time reversal symmetry. For very small block sizes, this could conceivably eliminate the entire H0 block; the program should print warnings if this occurs. Type: integer; Default: 400. H0_GUESS_SIZE (DETCI); DETCI (Expert) — size of H0 block for initial guess. Type: integer; Default: 400. H_BOND_CONNECT (OPTKING); OPTKING — For now, this is a general maximum distance for the definition of H-bonds. Type: double; Default: 4.3. HD_AVG (DETCI); DETCI (Expert) — How to average H diag energies over spin coupling sets. HD_EXACT uses the exact diagonal energies which results in expansion vectors which break spin symmetry. HD_KAVE averages the diagonal energies over a spin-coupling set yielding spin pure expansion vectors. ORB_ENER employs the sum of orbital energy approximation giving spin pure expansion vectors but usually doubles the number of Davidson iterations. EVANGELISTI uses the sums and differences of orbital energies with the SCF reference energy to produce spin pure expansion vectors. LEININGER approximation which subtracts the one-electron contribution from the orbital energies, multiplies by 0.5, and adds the one-electron contribution back in, producing spin pure expansion vectors and developed by Matt Leininger and works as well as EVANGELISTI. Type: string; Possible Values: EVANGELISTI, HD_EXACT, HD_KAVE, ORB_ENER, LEININGER, Z_KAVE; Default: EVANGELISTI. HD_OTF (DETCI); DETCI (Expert) — Do compute the diagonal elements of the Hamiltonian matrix on-the-fly? Otherwise, a diagonal element vector is written to a separate file on disk. Type: boolean; Default: true. HEFF4 (PSIMRCC); PSIMRCC — Do include the fourth-order contributions to the effective Hamiltonian?. Type: boolean; Default: true. HEFF_PRINT (PSIMRCC); PSIMRCC — Do print the effective Hamiltonian?. Type: boolean; Default: false. HESS_UPDATE (OPTKING); OPTKING — Hessian update scheme. Type: string; Possible Values: NONE, BFGS, MS, POWELL, ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodoc_glossary_options_c-1.html:54753,energy,energy,54753,psi4manual/4.0b4/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodoc_glossary_options_c-1.html,4,['energy'],['energy']
Energy Efficiency,"k sanity check. Only *should* be able to be None or int, but hey, kids today...; if not isinstance(user_dertype, int):; raise ValidationError(""_find_derivative_type: user_dertype should only be None or int!""); dertype = user_dertype. # Summary validation; if (dertype == 2) and (method_name in procedures['hessian']):; pass; elif (dertype == 1) and (method_name in procedures['gradient']):; pass; elif (dertype == 0) and (method_name in procedures['energy']):; pass; else:; alternatives = ''; alt_method_name = p4util.text.find_approximate_string_matches(method_name, procedures['energy'].keys(), 2); if len(alt_method_name) > 0:; alternatives = """""" Did you mean? %s"""""" % (' '.join(alt_method_name)). raise ValidationError(""""""Derivative method 'name' %s and derivative level 'dertype' %s are not available.%s""""""; % (method_name, str(dertype), alternatives)). return dertype. [docs]def energy(name, **kwargs):; r""""""Function to compute the single-point electronic energy. :returns: *float* |w--w| Total electronic energy in Hartrees. SAPT & EFP return interaction energy. :returns: (*float*, :ref:`Wavefunction<sec:psimod_Wavefunction>`) |w--w| energy and wavefunction when **return_wfn** specified. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY <CURRENTENERGY>`; * :psivar:`CURRENT REFERENCE ENERGY <CURRENTREFERENCEENERGY>`; * :psivar:`CURRENT CORRELATION ENERGY <CURRENTCORRELATIONENERGY>`. :type name: string; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :ref:`Wavefunction<sec:psimod_Wavefunction>`; calculation result as the second element (after *float* energy) of a tuple. :type resta",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver.html:3684,energy,energy,3684,psi4manual/1.0.0/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver.html,1,['energy'],['energy']
Energy Efficiency,"k(wfn, filename, *, debug=False, strict_label=True)[source]¶; Function to write wavefunction information in wfn to filename in; Gaussian FCHK format. New in version 0.6. Returns:; None. Parameters:. wfn (Wavefunction) – set of molecule, basis, orbitals from which to generate fchk file; filename (str) – destination file name for FCHK file; debug (bool) – returns a dictionary to aid with debugging; strict_label (bool) – If true set a density label compliant with what Gaussian would write. A warning will be printed if this is not possible.; Otherwise set the density label according to the method name. Notes. A description of the FCHK format is http://wild.life.nctu.edu.tw/~jsyu/compchem/g09/g09ur/f_formchk.htm; The allowed headers for methods are general and limited, i.e., “Total SCF|MP2|CI|CC Density”,; PSI4 will try to find the right one for the current calculation. If strict_label=False the PSI4 method name will be used as label.; Not all theory modules in PSI4 are compatible with the FCHK writer.; A warning will be printed if a theory module is not supported.; Caution! For orbital-optimized correlated methods (e.g. DCT, OMP2) the ‘Orbital Energy’ field contains ambiguous data. Examples:. Parameters:. wfn (Wavefunction) – ; filename (str) – ; debug (bool) – ; strict_label (bool) – . >>> # [1] FCHK file for DFT calculation; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> fchk(wfn, 'mycalc.fchk'). >>> # [2] FCHK file for correlated densities; >>> E, wfn = gradient('ccsd', return_wfn=True); >>> fchk(wfn, 'mycalc.fchk'). >>> # [2] Write FCHK file with non-standard label.; >>> E, wfn = gradient('mp2.5', return_wfn=True); >>> fchk(wfn, 'mycalc.fchk', strict_label=False). table of contents. fchk; fchk(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; fchk. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.fchk.html:1499,energy,energy,1499,psi4manual/1.8.x/api/psi4.driver.fchk.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.fchk.html,3,"['Energy', 'energy']","['Energy', 'energy']"
Energy Efficiency,"k(wfn, filename, *, debug=False, strict_label=True)[source]¶; Function to write wavefunction information in wfn to filename in; Gaussian FCHK format. New in version 0.6. Returns:; None. Parameters:. wfn (Wavefunction) – set of molecule, basis, orbitals from which to generate fchk file; filename (str) – destination file name for FCHK file; debug (bool) – returns a dictionary to aid with debugging; strict_label (bool) – If true set a density label compliant with what Gaussian would write. A warning will be printed if this is not possible.; Otherwise set the density label according to the method name. Notes. A description of the FCHK format is http://wild.life.nctu.edu.tw/~jsyu/compchem/g09/g09ur/f_formchk.htm; The allowed headers for methods are general and limited, i.e., “Total SCF|MP2|CI|CC Density”,; PSI4 will try to find the right one for the current calculation. If strict_label=False the PSI4 method name will be used as label.; Not all theory modules in PSI4 are compatible with the FCHK writer.; A warning will be printed if a theory module is not supported.; Caution! For orbital-optimized correlated methods (e.g. DCT, OMP2) the ‘Orbital Energy’ field contains ambiguous data. Examples:. Parameters:. wfn (Wavefunction) – ; filename (str) – ; debug (bool) – ; strict_label (bool) – . >>> # [1] FCHK file for DFT calculation; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> fchk(wfn, 'mycalc.fchk'). >>> # [2] FCHK file for correlated densities; >>> E, wfn = gradient('ccsd', return_wfn=True); >>> fchk(wfn, 'mycalc.fchk'). >>> # [2] Write FCHK file with non-standard label.; >>> E, wfn = gradient('mp2.5', return_wfn=True); >>> fchk(wfn, 'mycalc.fchk', strict_label=False). table of contents. fchk; fchk(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. PSI4 API: Linking C++ and Python; fchk. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/api/psi4.driver.fchk.html:1499,energy,energy,1499,psi4manual/1.9.x/api/psi4.driver.fchk.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.driver.fchk.html,3,"['Energy', 'energy']","['Energy', 'energy']"
Energy Efficiency,"k, specifically. Classes¶. AtomicComputer; Computer for analytic single-geometry computations. ConvergenceError(eqn_description, iteration); Error called for problems with converging an iterative method. EmpiricalDispersion(*[, name_hint, ...]); Lightweight unification of empirical dispersion calculation modes. ManagedMethodError(circs); Error called when a requested level of theory and derivative level are nominally available but not for the particular conditions (e.g., reference, algorithm, active orbitals, QC module, etc.) requested. MissingMethodError(msg); Error called when requested level or theory or derivative level are not available. OptimizationConvergenceError(...); Error called for problems with geometry optimizer. ParsingError(msg); Error called for problems parsing a text file. PastureRequiredError(option); Error called when the specified value of option requires some module(s) from Psi4Pasture, but could not be imported. PsiException; Error class for PSI4. QMMM(); Hold charges and psi4.core.ExternalPotential. QMMMbohr(); Hold charges and psi4.core.ExternalPotential. SCFConvergenceError(eqn_description, ...); Error called for problems with SCF iterations. TDSCFConvergenceError(iteration, wfn, what, ...); Error called for problems with TDSCF iterations. TestComparisonError(msg); Error called when a compare_values() or other comparison function fails. UpgradeHelper(old, new, version, elaboration); Error called on previously valid syntax that now isn't and a simple syntax transition is possible. ValidationError(msg); Input specification has problems. Class Inheritance Diagram¶. psi4.driver.p4util Package¶; Miscellaneous tools for driver and users. Functions¶. OptionsStateCM(osd); Return a context manager that will collect the state (value and changed :rtype: Iterator[None]. all_casings(input_string); Return a generator of all lettercase permutations of input_string. array_to_matrix(self, arr[, name, dim1, dim2]); Converts a NumPy array or list of NumPy arr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/psi4api.html:21799,charge,charges,21799,psi4manual/1.9.x/psi4api.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/psi4api.html,1,['charge'],['charges']
Energy Efficiency,"k, specifically. Classes¶. AtomicComputer; Computer for analytic single-geometry computations. ConvergenceError(eqn_description, iteration); Error called for problems with converging an iterative method. EmpiricalDispersion(*[, name_hint, ...]); Lightweight unification of empirical dispersion calculation modes. ManagedMethodError(circs); Error called when a requested level of theory and derivative level are nominally available but not for the particular conditions (e.g., reference, algorithm, active orbitals, QC module, etc.) requested. MissingMethodError(msg); Error called when requested level or theory or derivative level are not available. OptimizationConvergenceError(...); Error called for problems with geometry optimizer. ParsingError(msg); Error called for problems parsing a text file. PastureRequiredError(option); Error called when the specified value of option requires some module(s) from Psi4Pasture, but could not be imported. PsiException; Error class for PSI4. QMMM(); Hold charges and psi4.core.ExternalPotential. QMMMbohr(); Hold charges and psi4.core.ExternalPotential. SCFConvergenceError(eqn_description, ...); Error called for problems with SCF iterations. TDSCFConvergenceError(iteration, wfn, what, ...); Error called for problems with TDSCF iterations. TestComparisonError(msg); Error called when a compare_values() or other comparison function fails. UpgradeHelper(old, new, version, elaboration); Error called on previously valid syntax that now isn't and a simple syntax transition is possible. ValidationError(msg); Input specification has problems. Class Inheritance Diagram¶. psi4.driver.p4util Package¶; Miscellaneous tools for driver and users. Functions¶. OptionsStateCM(osd); Return a context manager that will collect the state (value and changed status) of a list of keywords osd that can initialize OptionsState on entry to the with-statement and restore the collected state when exiting the with-statement. all_casings(input_string); Return a generator ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/psi4api.html:21794,charge,charges,21794,psi4manual/1.7.x/psi4api.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/psi4api.html,3,['charge'],['charges']
Energy Efficiency,"k:2019:2278].; This approach handles systems with both spin and spatial degeneracies; by combining the spin-flip (SF) [Krylov:2001:522]; and ionization potential/electron affinity (IP/EA) [Nooijen:1995:3629]; approaches.; The Psi4FockCI plugin allows one to perform spin-flip (SF), ionization; potential (IP), and electron affinity (EA) calculations, as well as; combined RAS-SF-IP/EA calculations, through the DETCI (CI: Configuration Interaction) module. Installation¶. Download the plugin from the GitHub repository:; >>> git clone https://github.com/shannonhouck/psi4fockci.git. Once downloaded, the plugin can be installed as follows:; >>> cd {top-level-psi4fockci-directory}; >>> python -m pip install . Sample Input¶; To run a CAS-nSF-IP/EA calculation, start with a molecule with the; correct charge and multiplicity for the reference state (i.e. some; state well-represented by a single reference). Then, run an energy; calculation, passing in the charge and multiplicity of the; desired state; the number of spin-flips and IP/EA will be automatically; determined based on this input. If additional excitations outside of the; RAS II space are desired, one can set the level of external; excitations using the conf_space keyword.; A sample input file for a RAS(h)-2SF-IP calculation is shown below:; molecule {; 0 7; N 0.0 0.0 0.0; N 0.0 0.0 1.3; symmetry c1; }. set {; basis cc-pVDZ; }. energy('psi4fockci', new_charge=1, new_multiplicity=1, conf_space=""h""). Note that for calculations involving IP/EA, inclusion of hole (for IP) and; particle (for EA) excitations is strongly recommended. Additional keywords; can be found in the documentation.; This input file can be run with Psi4:; >>> psi4 input.dat. table of contents. Psi4FockCI: A General Fock-Space CI For Spin-Flip And IP/EA; Installation; Sample Input. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Psi4FockCI: A General Fo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/plugin_psi4fockci.html:1399,energy,energy,1399,psi4manual/master/plugin_psi4fockci.html,https://psicode.org,https://psicode.org/psi4manual/master/plugin_psi4fockci.html,2,"['charge', 'energy']","['charge', 'energy']"
Energy Efficiency,"k:2019:2278].; This approach handles systems with both spin and spatial degeneracies; by combining the spin-flip (SF) [Krylov:2001:522]; and ionization potential/electron affinity (IP/EA) [Nooijen:1995:3629]; approaches.; The Psi4FockCI plugin allows one to perform spin-flip (SF), ionization; potential (IP), and electron affinity (EA) calculations, as well as; combined RAS-SF-IP/EA calculations, through the DETCI (CI: Configuration Interaction) module. Installation¶. Download the plugin from the GitHub repository:; >>> git clone https://github.com/shannonhouck/psi4fockci.git. Once downloaded, the plugin can be installed as follows:; >>> cd {top-level-psi4fockci-directory}; >>> python -m pip install . Sample Input¶; To run a CAS-nSF-IP/EA calculation, start with a molecule with the; correct charge and multiplicity for the reference state (i.e. some; state well-represented by a single reference). Then, run an energy; calculation, passing in the charge and multiplicity of the; desired state; the number of spin-flips and IP/EA will be automatically; determined based on this input. If additional excitations outside of the; RAS II space are desired, one can set the level of external; excitations using the conf_space keyword.; A sample input file for a RAS(h)-2SF-IP calculation is shown below:; molecule {; 0 7; N 0.0 0.0 0.0; N 0.0 0.0 1.3; symmetry c1; }. set {; basis cc-pVDZ; }. energy('psi4fockci', new_charge=1, new_multiplicity=1, conf_space=""h""). Note that for calculations involving IP/EA, inclusion of hole (for IP) and; particle (for EA) excitations is strongly recommended. Additional keywords; can be found in the documentation.; This input file can be run with Psi4:; >>> psi4 input.dat. table of contents. Psi4FockCI: A General Fock-Space CI For Spin-Flip And IP/EA; Installation; Sample Input. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Psi4FockCI: A General Fock-Space ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/plugin_psi4fockci-1.html:1390,energy,energy,1390,psi4manual/1.4.0/plugin_psi4fockci-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/plugin_psi4fockci-1.html,4,"['charge', 'energy']","['charge', 'energy']"
Energy Efficiency,"k:2019:2278].; This approach handles systems with both spin and spatial degeneracies; by combining the spin-flip (SF) [Krylov:2001:522]; and ionization potential/electron affinity (IP/EA) [Nooijen:1995:3629]; approaches.; The Psi4FockCI plugin allows one to perform spin-flip (SF), ionization; potential (IP), and electron affinity (EA) calculations, as well as; combined RAS-SF-IP/EA calculations, through the DETCI (CI: Configuration Interaction) module. Installation¶. Download the plugin from the GitHub repository:; >>> git clone https://github.com/shannonhouck/psi4fockci.git. Once downloaded, the plugin can be installed as follows:; >>> cd {top-level-psi4fockci-directory}; >>> python -m pip install . Sample Input¶; To run a CAS-nSF-IP/EA calculation, start with a molecule with the; correct charge and multiplicity for the reference state (i.e. some; state well-represented by a single reference). Then, run an energy; calculation, passing in the charge and multiplicity of the; desired state; the number of spin-flips and IP/EA will be automatically; determined based on this input. If additional excitations outside of the; RAS II space are desired, one can set the level of external; excitations using the conf_space keyword.; A sample input file for a RAS(h)-2SF-IP calculation is shown below:; molecule {; 0 7; N 0.0 0.0 0.0; N 0.0 0.0 1.3; symmetry c1; }. set {; basis cc-pVDZ; }. energy('psi4fockci', new_charge=1, new_multiplicity=1, conf_space=""h""). Note that for calculations involving IP/EA, inclusion of hole (for IP) and; particle (for EA) excitations is strongly recommended. Additional keywords; can be found in the documentation.; This input file can be run with Psi4:; >>> psi4 input.dat. table of contents. Psi4FockCI: A General Fock-Space CI For Spin-Flip And IP/EA; Installation; Sample Input. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Psi4FockCI: A General Fock-Space ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/plugin_psi4fockci-1.html:1390,energy,energy,1390,psi4manual/1.5.0/plugin_psi4fockci-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/plugin_psi4fockci-1.html,4,"['charge', 'energy']","['charge', 'energy']"
Energy Efficiency,"k:2019:2278].; This approach handles systems with both spin and spatial degeneracies; by combining the spin-flip (SF) [Krylov:2001:522]; and ionization potential/electron affinity (IP/EA) [Nooijen:1995:3629]; approaches.; The Psi4FockCI plugin allows one to perform spin-flip (SF), ionization; potential (IP), and electron affinity (EA) calculations, as well as; combined RAS-SF-IP/EA calculations, through the DETCI (CI: Configuration Interaction) module. Installation¶. Download the plugin from the GitHub repository:; >>> git clone https://github.com/shannonhouck/psi4fockci.git. Once downloaded, the plugin can be installed as follows:; >>> cd {top-level-psi4fockci-directory}; >>> python -m pip install . Sample Input¶; To run a CAS-nSF-IP/EA calculation, start with a molecule with the; correct charge and multiplicity for the reference state (i.e. some; state well-represented by a single reference). Then, run an energy; calculation, passing in the charge and multiplicity of the; desired state; the number of spin-flips and IP/EA will be automatically; determined based on this input. If additional excitations outside of the; RAS II space are desired, one can set the level of external; excitations using the conf_space keyword.; A sample input file for a RAS(h)-2SF-IP calculation is shown below:; molecule {; 0 7; N 0.0 0.0 0.0; N 0.0 0.0 1.3; symmetry c1; }. set {; basis cc-pVDZ; }. energy('psi4fockci', new_charge=1, new_multiplicity=1, conf_space=""h""). Note that for calculations involving IP/EA, inclusion of hole (for IP) and; particle (for EA) excitations is strongly recommended. Additional keywords; can be found in the documentation.; This input file can be run with Psi4:; >>> psi4 input.dat. table of contents. Psi4FockCI: A General Fock-Space CI For Spin-Flip And IP/EA; Installation; Sample Input. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Psi4FockCI: A General Fock-Space ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/plugin_psi4fockci.html:1390,energy,energy,1390,psi4manual/1.6.x/plugin_psi4fockci.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugin_psi4fockci.html,2,"['charge', 'energy']","['charge', 'energy']"
Energy Efficiency,"k:2019:2278].; This approach handles systems with both spin and spatial degeneracies; by combining the spin-flip (SF) [Krylov:2001:522]; and ionization potential/electron affinity (IP/EA) [Nooijen:1995:3629]; approaches.; The Psi4FockCI plugin allows one to perform spin-flip (SF), ionization; potential (IP), and electron affinity (EA) calculations, as well as; combined RAS-SF-IP/EA calculations, through the DETCI (CI: Configuration Interaction) module. Installation¶. Download the plugin from the GitHub repository:; >>> git clone https://github.com/shannonhouck/psi4fockci.git. Once downloaded, the plugin can be installed as follows:; >>> cd {top-level-psi4fockci-directory}; >>> python -m pip install . Sample Input¶; To run a CAS-nSF-IP/EA calculation, start with a molecule with the; correct charge and multiplicity for the reference state (i.e. some; state well-represented by a single reference). Then, run an energy; calculation, passing in the charge and multiplicity of the; desired state; the number of spin-flips and IP/EA will be automatically; determined based on this input. If additional excitations outside of the; RAS II space are desired, one can set the level of external; excitations using the conf_space keyword.; A sample input file for a RAS(h)-2SF-IP calculation is shown below:; molecule {; 0 7; N 0.0 0.0 0.0; N 0.0 0.0 1.3; symmetry c1; }. set {; basis cc-pVDZ; }. energy('psi4fockci', new_charge=1, new_multiplicity=1, conf_space=""h""). Note that for calculations involving IP/EA, inclusion of hole (for IP) and; particle (for EA) excitations is strongly recommended. Additional keywords; can be found in the documentation.; This input file can be run with Psi4:; >>> psi4 input.dat. table of contents. Psi4FockCI: A General Fock-Space CI For Spin-Flip And IP/EA; Installation; Sample Input. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Psi4FockCI: A General Fock-Space ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/plugin_psi4fockci.html:1390,energy,energy,1390,psi4manual/1.7.x/plugin_psi4fockci.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/plugin_psi4fockci.html,2,"['charge', 'energy']","['charge', 'energy']"
Energy Efficiency,"k:2019:2278].; This approach handles systems with both spin and spatial degeneracies; by combining the spin-flip (SF) [Krylov:2001:522]; and ionization potential/electron affinity (IP/EA) [Nooijen:1995:3629]; approaches.; The Psi4FockCI plugin allows one to perform spin-flip (SF), ionization; potential (IP), and electron affinity (EA) calculations, as well as; combined RAS-SF-IP/EA calculations, through the DETCI (CI: Configuration Interaction) module. Installation¶. Download the plugin from the GitHub repository:; >>> git clone https://github.com/shannonhouck/psi4fockci.git. Once downloaded, the plugin can be installed as follows:; >>> cd {top-level-psi4fockci-directory}; >>> python -m pip install . Sample Input¶; To run a CAS-nSF-IP/EA calculation, start with a molecule with the; correct charge and multiplicity for the reference state (i.e. some; state well-represented by a single reference). Then, run an energy; calculation, passing in the charge and multiplicity of the; desired state; the number of spin-flips and IP/EA will be automatically; determined based on this input. If additional excitations outside of the; RAS II space are desired, one can set the level of external; excitations using the conf_space keyword.; A sample input file for a RAS(h)-2SF-IP calculation is shown below:; molecule {; 0 7; N 0.0 0.0 0.0; N 0.0 0.0 1.3; symmetry c1; }. set {; basis cc-pVDZ; }. energy('psi4fockci', new_charge=1, new_multiplicity=1, conf_space=""h""). Note that for calculations involving IP/EA, inclusion of hole (for IP) and; particle (for EA) excitations is strongly recommended. Additional keywords; can be found in the documentation.; This input file can be run with Psi4:; >>> psi4 input.dat. table of contents. Psi4FockCI: A General Fock-Space CI For Spin-Flip And IP/EA; Installation; Sample Input. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Psi4FockCI: A General Fock-Spac",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/plugin_psi4fockci.html:1392,energy,energy,1392,psi4manual/1.8.x/plugin_psi4fockci.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/plugin_psi4fockci.html,2,"['charge', 'energy']","['charge', 'energy']"
Energy Efficiency,"k:2019:2278].; This approach handles systems with both spin and spatial degeneracies; by combining the spin-flip (SF) [Krylov:2001:522]; and ionization potential/electron affinity (IP/EA) [Nooijen:1995:3629]; approaches.; The Psi4FockCI plugin allows one to perform spin-flip (SF), ionization; potential (IP), and electron affinity (EA) calculations, as well as; combined RAS-SF-IP/EA calculations, through the DETCI (CI: Configuration Interaction) module. Installation¶. Download the plugin from the GitHub repository:; >>> git clone https://github.com/shannonhouck/psi4fockci.git. Once downloaded, the plugin can be installed as follows:; >>> cd {top-level-psi4fockci-directory}; >>> python -m pip install . Sample Input¶; To run a CAS-nSF-IP/EA calculation, start with a molecule with the; correct charge and multiplicity for the reference state (i.e. some; state well-represented by a single reference). Then, run an energy; calculation, passing in the charge and multiplicity of the; desired state; the number of spin-flips and IP/EA will be automatically; determined based on this input. If additional excitations outside of the; RAS II space are desired, one can set the level of external; excitations using the conf_space keyword.; A sample input file for a RAS(h)-2SF-IP calculation is shown below:; molecule {; 0 7; N 0.0 0.0 0.0; N 0.0 0.0 1.3; symmetry c1; }. set {; basis cc-pVDZ; }. energy('psi4fockci', new_charge=1, new_multiplicity=1, conf_space=""h""). Note that for calculations involving IP/EA, inclusion of hole (for IP) and; particle (for EA) excitations is strongly recommended. Additional keywords; can be found in the documentation.; This input file can be run with Psi4:; >>> psi4 input.dat. table of contents. Psi4FockCI: A General Fock-Space CI For Spin-Flip And IP/EA; Installation; Sample Input. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Psi4FockCI: A General Fock-Spac",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/plugin_psi4fockci.html:1392,energy,energy,1392,psi4manual/1.9.x/plugin_psi4fockci.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/plugin_psi4fockci.html,2,"['charge', 'energy']","['charge', 'energy']"
Energy Efficiency,"kage = kwargs['linkage']; else:; raise ValidationError('Frequency execution mode \'reap\' requires a linkage option.'); else:; raise ValidationError('Frequency execution mode \'%s\' not valid.' % (freq_mode)). # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); if not psi4.has_option_changed('SCF', 'E_CONVERGENCE'):; if procedures['energy'][lowername] == run_scf or procedures['energy'][lowername] == run_dft:; psi4.set_local_option('SCF', 'E_CONVERGENCE', 8); else:; psi4.set_local_option('SCF', 'E_CONVERGENCE', 10); if not psi4.has_option_changed('SCF', 'D_CONVERGENCE'):; if procedures['energy'][lowername] == run_scf or procedures['energy'][lowername] == run_dft:; psi4.set_local_option('SCF', 'D_CONVERGENCE', 8); else:; psi4.set_local_option('SCF', 'D_CONVERGENCE', 10). # Set post-scf convergence criteria (global will cover all correlated modules); if not psi4.has_global_option_changed('E_CONVERGENCE'):; if not procedures['energy'][lowername] == run_scf and not procedures['energy'][lowername] == run_dft:; psi4.set_global_option('E_CONVERGENCE', 8). # Select certain irreps; if 'irrep' in kwargs:; irrep = parse_cotton_irreps(kwargs['irrep']) - 1 # externally, A1 irrep is 1, internally 0; else:; irrep = -1 # -1 implies do all irreps. # Does an analytic procedure exist for the requested method?; if (dertype == 2):; # We have the desired method. Do it.; procedures['hessian'][lowername](lowername, **kwargs); optstash.restore(). if 'mode' in kwargs and kwargs['mode'].lower() == 'sow':; raise ValidationError('Frequency execution mode \'sow\' not valid for analytic frequency calculation.'). # TODO: check that current energy's being set to the right figure when this code is actually used; psi4.set_variable('CURRENT ENERGY', psi4.wavefunction().energy()). # TODO: return hessian matrix. elif (dertype == 1):; # Ok, we're doing frequencies by gradients; print('Performing finite difference by gradient calculations'). func = procedu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/driver.html:61663,energy,energy,61663,psi4manual/4.0b5/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/driver.html,4,['energy'],['energy']
Energy Efficiency,"kage for Linux and macOS (and Windows, through the Ubuntu shell).; If using the PSI4 binary, dkh has already been installed alongside.; If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; dkh can be obtained through conda install dkh -c psi4.; Then enable it as a feature with ENABLE_dkh,; hint its location with CMAKE_PREFIX_PATH,; and rebuild PSI4 to detect dkh and activate dependent code. To remove a conda installation, conda remove dkh. Source. If using PSI4 built from source and you want dkh built from; from source also,; enable it as a feature with ENABLE_dkh,; and let the build system fetch and build it and activate dependent code. Input¶; For all electron calculations one can use the Douglas-Kroll-Hess (DKH); Hamiltonian to take into account scalar relativistic effects.; Minimal input for DKH single-point computation looks like this:; molecule {; Mg; }. set basis aug-cc-pvdz-dk; set relativistic dkh. energy('scf'). By default a 2nd-order DKH calculation is performed. To change the default; order use the DKH_ORDER option. The version of the code found in; PSI4 is capable of up to 4th-order DKH calculations. Keywords¶. RELATIVISTIC¶. Relativistic Hamiltonian type. Type: string; Possible Values: NO, X2C; Default: NO. DKH_ORDER¶. Order of Douglas-Kroll-Hess. Type: integer; Default: 2. Reference¶; When using this code please make reference to the appropriate following paper:. “The Generalized Douglas-Kroll Transformation,” A. Wolf,; M. Reiher, and B. A. Hess, J. Chem. Phys. 117, 9215 (2002).; (doi: 10.1063/1.1515314). How to configure dkh for building Psi4¶; Role and Dependencies. Role — In PSI4, DKH is a library that provides additional; quantum chemical capabilities (relativistic effects).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) dkh; Upstream Dependencies — dkh \(\Leftarrow\) Fortran. CMake Variables. ENABLE_dkh — CMake variable toggling whether Psi4 builds with dkh; CMAKE_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/dkh-1.html:1421,energy,energy,1421,psi4manual/1.4.0/dkh-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/dkh-1.html,9,['energy'],['energy']
Energy Efficiency,"ken to converge the SCF equations. iteration_energies = []¶. reset_occ_¶; Do reset the occupation after the guess to the inital occupation. sad_¶; Do assume a non-idempotent density matrix and no orbitals after the guess. Methods Documentation. V_potential(self: psi4.core.HF) → psi4.core.VBase¶; Returns the internal DFT V object. Va(self: psi4.core.HF) → psi4.core.Matrix¶; Returns the Alpha Kohn-Sham Potential Matrix. Vb(self: psi4.core.HF) → psi4.core.Matrix¶; Returns the Beta Kohn-Sham Potential Matrix. check_phases(self: psi4.core.HF) → None¶; docstring. clear_external_cpscf_perturbations(self: psi4.core.HF) → None¶; Clear private external_cpscf_perturbations map. clear_external_potentials(self: psi4.core.HF) → None¶; Clear private external_potentials list. compute_E(self: psi4.core.HF) → float¶; docstring. compute_energy()¶; Base class Wavefunction requires this function. Here it is; simply a wrapper around initialize(), iterations(), finalize_energy(). It; returns the SCF energy computed by finalize_energy(). compute_fvpi(self: psi4.core.HF) → None¶; Update number of frozen virtuals. compute_initial_E(self: psi4.core.HF) → float¶; docstring. compute_orbital_gradient(self: psi4.core.HF, arg0: bool, arg1: int) → float¶; docstring. compute_spin_contamination(self: psi4.core.HF) → None¶; docstring. cphf_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix]) → List[psi4.core.Matrix]¶; CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self: psi4.core.HF) → bool¶; Adds occupied guess alpha orbitals. cphf_solve(self: psi4.core.HF, x_vec: List[psi4.core.Matrix], conv_tol: float, max_iter: int, print_lvl: int = 2) → List[psi4.core.Matrix]¶; Solves the CPHF equations for a given set of x vectors. damping_update(self: psi4.core.HF, arg0: float) → None¶; docstring. diis(self: psi4.core.HF, arg0: float) → bool¶; docstring. finalize(self: psi4.core.HF) → None¶; Cleans up the the Wavefunction’s temporary data. finalize_energy()¶; Performs stability analysis and call",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/api/psi4.core.HF.html:6056,energy,energy,6056,psi4manual/1.9.x/api/psi4.core.HF.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.HF.html,2,['energy'],['energy']
Energy Efficiency,"ken to converge the SCF equations. iteration_energies = []¶. reset_occ_¶; Do reset the occupation after the guess to the inital occupation. sad_¶; Do assume a non-idempotent density matrix and no orbitals after the guess. Methods Documentation. V_potential(self: psi4.core.HF) → psi4.core.VBase¶; Returns the internal DFT V object. Va(self: psi4.core.HF) → psi4.core.Matrix¶; Returns the Alpha Kohn-Sham Potential Matrix. Vb(self: psi4.core.HF) → psi4.core.Matrix¶; Returns the Beta Kohn-Sham Potential Matrix. check_phases(self: psi4.core.HF) → None¶; docstring. clear_external_cpscf_perturbations(self: psi4.core.HF) → None¶; Clear private external_cpscf_perturbations map. clear_external_potentials(self: psi4.core.HF) → None¶; Clear private external_potentials list. compute_E(self: psi4.core.HF) → float¶; docstring. compute_energy()¶; Base class Wavefunction requires this function. Here it is; simply a wrapper around initialize(), iterations(), finalize_energy(). It; returns the SCF energy computed by finalize_energy(). compute_fvpi(self: psi4.core.HF) → None¶; Update number of frozen virtuals. compute_initial_E(self: psi4.core.HF) → float¶; docstring. compute_orbital_gradient(self: psi4.core.HF, arg0: bool, arg1: int) → float¶; docstring. compute_spin_contamination(self: psi4.core.HF) → None¶; docstring. cphf_Hx(self: psi4.core.HF, arg0: list[psi4.core.Matrix]) → list[psi4.core.Matrix]¶; CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self: psi4.core.HF) → bool¶; Adds occupied guess alpha orbitals. cphf_solve(self: psi4.core.HF, x_vec: list[psi4.core.Matrix], conv_tol: float, max_iter: int, print_lvl: int = 2) → list[psi4.core.Matrix]¶; Solves the CPHF equations for a given set of x vectors. damping_update(self: psi4.core.HF, arg0: float) → None¶; docstring. diis(self: psi4.core.HF, arg0: float) → bool¶; docstring. finalize(self: psi4.core.HF) → None¶; Cleans up the the Wavefunction’s temporary data. finalize_energy()¶; Performs stability analysis and call",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/api/psi4.core.HF.html:6063,energy,energy,6063,psi4manual/master/api/psi4.core.HF.html,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.HF.html,2,['energy'],['energy']
Energy Efficiency,"ker_2` if two valid basis sets; present in ``delta4_basis`` and :py:func:`~xtpl_highest_1` otherwise. :type delta5_scheme: function; :param delta5_scheme: |dl| ``xtpl_highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the fifth delta correction; to the correlation energy.; Defaults to :py:func:`~corl_xtpl_helgaker_2` if two valid basis sets; present in ``delta5_basis`` and :py:func:`~xtpl_highest_1` otherwise. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> cbs(name='scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> cbs(name='mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> cbs(name='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> cbs(corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> cbs(corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> cbs(energy, wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs(name='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, de",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:28233,energy,energy,28233,psi4manual/1.0.0/_modules/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html,2,['energy'],['energy']
Energy Efficiency,"key.upper()]) + "" to recompose the quantity.""). return key. [docs]; def plump_qcvar(; key: str,; val: Union[float, str, List]) -> Union[float, np.ndarray]:; """"""Prepare serialized QCVariables for QCSchema AtomicResult.extras[""qcvars""] by; converting flat arrays into numpy, shaped ones and floating strings.; Unlike _qcvar_reshape_get/set, multipoles aren't compressed or plumped, only reshaped. Parameters; ----------; key; Shape clue (usually QCVariable key) that includes (case insensitive) an identifier like; 'gradient' as a clue to the array's natural dimensions.; val; flat (?, ) list or scalar or string, probably from JSON storage. Returns; -------; float or numpy.ndarray; Reshaped array of `val` with natural dimensions of `key`. """"""; if isinstance(val, (np.ndarray, core.Matrix)):; raise TypeError; elif isinstance(val, list):; tgt = np.asarray(val); else:; # presumably scalar. may be string; return float(val). if key.upper().startswith(""MBIS""):; if key.upper().endswith(""CHARGES""):; reshaper = (-1, ); elif key.upper().endswith(""DIPOLES""):; reshaper = (-1, 3); elif key.upper().endswith(""QUADRUPOLES""):; reshaper = (-1, 3, 3); elif key.upper().endswith(""OCTUPOLES""):; reshaper = (-1, 3, 3, 3); elif key.upper().endswith(""DIPOLE"") or ""DIPOLE -"" in key.upper():; reshaper = (3, ); elif ""QUADRUPOLE POLARIZABILITY TENSOR"" in key.upper():; reshaper = (3, 3, 3); elif any((key.upper().endswith(p) or f""{p} -"" in key.upper()) for p in _multipole_order):; p = [p for p in _multipole_order if (key.upper().endswith(p) or f""{p} -"" in key.upper())]; reshaper = tuple([3] * _multipole_order.index(p[0])); elif key.upper() in [""MULLIKEN_CHARGES"", ""LOWDIN_CHARGES"", ""MULLIKEN CHARGES"", ""LOWDIN CHARGES"", ""SCF TOTAL ENERGIES""]:; reshaper = (-1, ); elif ""GRADIENT"" in key.upper():; reshaper = (-1, 3); elif ""HESSIAN"" in key.upper():; ndof = int(math.sqrt(len(tgt))); reshaper = (ndof, ndof); else:; raise ValidationError(f'Uncertain how to reshape array: {key}'). return tgt.reshape(reshaper). _multip",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html:28712,CHARGE,CHARGES,28712,psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html,2,['CHARGE'],['CHARGES']
Energy Efficiency,"key.upper()]) + "" to recompose the quantity.""). return key. [docs]; def plump_qcvar(; key: str,; val: Union[float, str, List]) -> Union[float, np.ndarray]:; """"""Prepare serialized QCVariables for QCSchema AtomicResult.extras[""qcvars""] by; converting flat arrays into numpy, shaped ones and floating strings.; Unlike _qcvar_reshape_get/set, multipoles aren't compressed or plumped, only reshaped. Parameters; ----------; key; Shape clue (usually QCVariable key) that includes (case insensitive) an identifier like; 'gradient' as a clue to the array's natural dimensions.; val; flat (?, ) list or scalar or string, probably from JSON storage. Returns; -------; float or numpy.ndarray; Reshaped array of `val` with natural dimensions of `key`. """"""; if isinstance(val, (np.ndarray, core.Matrix)):; raise TypeError; elif isinstance(val, list):; tgt = np.asarray(val); else:; # presumably scalar. may be string; return float(val). if key.upper().startswith(""MBIS""):; if key.upper().endswith(""CHARGES""):; reshaper = (-1, ); elif key.upper().endswith(""DIPOLES""):; reshaper = (-1, 3); elif key.upper().endswith(""QUADRUPOLES""):; reshaper = (-1, 3, 3); elif key.upper().endswith(""OCTUPOLES""):; reshaper = (-1, 3, 3, 3); elif key.upper().endswith(""DIPOLE"") or ""DIPOLE -"" in key.upper():; reshaper = (3, ); elif ""QUADRUPOLE POLARIZABILITY TENSOR"" in key.upper():; reshaper = (3, 3, 3); elif any((key.upper().endswith(p) or f""{p} -"" in key.upper()) for p in _multipole_order):; p = [p for p in _multipole_order if (key.upper().endswith(p) or f""{p} -"" in key.upper())]; reshaper = tuple([3] * _multipole_order.index(p[0])); elif key.upper() in [""MULLIKEN_CHARGES"", ""LOWDIN_CHARGES"", ""MULLIKEN CHARGES"", ""LOWDIN CHARGES""]:; reshaper = (-1, ); elif ""GRADIENT"" in key.upper():; reshaper = (-1, 3); elif ""HESSIAN"" in key.upper():; ndof = int(math.sqrt(len(tgt))); reshaper = (ndof, ndof); else:; raise ValidationError(f'Uncertain how to reshape array: {key}'). return tgt.reshape(reshaper). _multipole_order = [""dummy"", ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html:28848,CHARGE,CHARGES,28848,psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html,1,['CHARGE'],['CHARGES']
Energy Efficiency,"key; Case-insensitive key to instance's double or; :py:class:`~psi4.core.Matrix` storage maps. """"""; return self.has_scalar_variable(key) or self.has_array_variable(key). def _core_variable(key: str) -> Union[float, core.Matrix, np.ndarray]:; """"""Return copy of scalar or array :ref:`QCVariable <sec:appendices:qcvars>`; *key* from global memory. Parameters; ----------; key; Case-insensitive key to global double or :py:class:`~psi4.core.Matrix`; storage maps. Returns; -------; float or ~numpy.ndarray or Matrix; Requested QCVariable from global memory. - Scalar variables are returned as floats.; - Array variables not naturally 2D (like multipoles or per-atom charges); are returned as :class:`~numpy.ndarray` of natural dimensionality.; - Other array variables are returned as :py:class:`~psi4.core.Matrix` and; may have an extra dimension with symmetry information. Raises; ------; KeyError; If `key` not set on `self`. Example; -------; >>> psi4.gradient(""hf/cc-pvdz""); >>> psi4.variable(""CURRENT ENERGY""); -100.00985995185668; >>> psi4.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> psi4.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> psi4.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). """"""; key = _qcvar_warnings(key). if core.has_scalar_variable(key):; return core.scalar_variable(key); elif core.has_array_variable(key):; return _qcvar_reshape_get(key, core.array_variable(key)); else:; raise KeyError(f""psi4.core.variable: Requested variable '{key}' was not set!\n""). def _core_wavefunction_variable(self: core.Wavefunction, key: str) -> Union[float, core.Matrix, np.ndarray]:; """"""Return copy of scalar or array :ref:`QCVariable <sec:appendices:qcvars>`; *key* from *self*. Parameters; ----------; self; Wavefunction instance.; key; Case-insensitive key to instance's double or :py:class:`~psi4.core.Matrix`; storage maps. Returns; -------; flo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html:33967,ENERGY,ENERGY,33967,psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html,4,['ENERGY'],['ENERGY']
Energy Efficiency,"keyword key under handle name. cbs(func, label, **kwargs); Function to define a multistage energy method from combinations of basis set extrapolations and delta corrections and condense the components into a minimum number of calculations. check_iwl_file_from_scf_type(scf_type, wfn); Ensures that a IWL file has been written based on input SCF type. compare_fchkfiles(expected, computed, ...). compare_fcidumps(expected, computed, label); Function to compare two FCIDUMP files. copy_file_from_scratch(filename, prefix, ...); Function to move file out of scratch with correct naming convention. copy_file_to_scratch(filename, prefix, ...); Function to move file into scratch with correct naming convention. create_plugin(name, template). rtype; None. cubeprop(wfn, **kwargs); Evaluate properties on a grid and generate cube files. dynamic_variable_bind(cls); Function to dynamically add extra members to the core.Molecule class. energies_from_fcidump(intdump). energy(name, **kwargs); Function to compute the single-point electronic energy. fchk(wfn, filename, *[, debug, strict_label]); Function to write wavefunction information in wfn to filename in Gaussian FCHK format. fchkfile_to_string(fname); Load FCHK file into a string. fcidump(wfn[, fname, oe_ints]); Save integrals to file in FCIDUMP format as defined in Comp. fcidump_from_file(fname); Function to read in a FCIDUMP file. find_approximate_string_matches(seq1, ...); Find list of approximate (within max_distance) matches to string seq1 among options. free_atom_volumes(wfn, **kwargs); Computes free-atom volumes using MBIS density partitioning. freq(name, **kwargs); Function to compute harmonic vibrational frequencies. frequencies(name, **kwargs); Function to compute harmonic vibrational frequencies. frequency(name, **kwargs); Function to compute harmonic vibrational frequencies. gdma(wfn[, datafile]); Function to use wavefunction information in wfn and, if specified, additional commands in filename to run GDMA analysis. geomet",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/psi4api-1.html:17763,energy,energy,17763,psi4manual/1.5.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/psi4api-1.html,4,['energy'],['energy']
Energy Efficiency,"keywords just like Psi4 keywords. The names of keywords; are unchanged beyond a prepended “cfour_”. (Though be aware that common; abbreviations like CALC and REF must be fully spelled out as; CFOUR_CALC_LEVEL and CFOUR_REFERENCE when used in; Psi4.); In limited trial cases, keywords nominally directed at non-Cfour modules; are translated into their Cfour counterparts. For example, setting; REFERENCE will appropriately set CFOUR_REFERENCE. For a; list of applicable keywords, see source of; qcdb.cfour.muster_psi4options().; Consult Functionality for information on what Cfour; functionality is accessible through Psi4. Psi4 for Cfour Users¶; In the simplest use of the Psi4/Cfour interface, a Psi4 input file; can simply “wrap” a ZMAT file and execute xcfour. This is; illustrated in the following example:; cfour {; UHF-SCF energy calculation; N; H 1 R; H 1 R 2 A. R=1.008; A=105.0. *ACES2(CALC=HF,BASIS=qz2p; MULT=2,REF=UHF; OCCUPATION=3-1-1-0/3-0-1-0; SCF_CONV=12; MEMORY=20000000); }. energy('cfour'). Here, the contents of the cfour {...} block are written directly to a; ZMAT file. This is joined by a default GENBAS file; (psi4/share/basis/GENBAS). To preferentially use your own GENBAS,; place it in PATH or PSIPATH. The line calling; energy() with argument 'cfour' invokes; xcfour.; After execution of the energy('cfour') line completes, Cfour results; are read back into Psi4 format and are thereafter accessible for; further processing in the input file. See Output for; details. This storage of results in variables and arrays in memory for; the duration of the Psi4 instance (as opposed to solely in files); is the only advantage thus far incurred by the P4C4 interface. We’ll call; this mode of basic utility the “sandwich” mode.; Molecule specification in Psi4 allows Cartesians, Z-matrices, mixed; Cartesian/Z-matrix, negation of variables, delayed specification of; variables, specification of fragments, etc., all in a whitespace-tolerant; format. See Molecule and Geometry Speci",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/cfour-1.html:3271,energy,energy,3271,psi4manual/1.0.0/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/cfour-1.html,2,['energy'],['energy']
Energy Efficiency,"keywords to be set as c-side keywords; options = collections.defaultdict(lambda: collections.defaultdict(dict)); #options['QCHEM'['QCHEM_CHARGE']['value'] = self.molecular_charge(); #options['QCHEM'['QCHEM_MULTIPLICITY']['value'] = self.multiplicity(); options['QCHEM']['QCHEM_INPUT_BOHR']['value'] = False; #options['QCHEM']['QCHEM_COORDINATES']['value'] = 'CARTESIAN'; #SYM_IGNORE equiv to no_reorient, no_com, symmetry c1. options['QCHEM']['QCHEM_INPUT_BOHR']['clobber'] = True. return text, options. def format_molecule_for_psi4_xyz(self):; """"""not much examined. """"""; text = """"; if self.nallatom():. factor = 1.0 if self.PYunits == 'Angstrom' else psi_bohr2angstroms; # append units and any other non-default molecule keywords; text += ""units Angstrom\n""; #text += "" units %-s\n"" % (""Angstrom"" if self.units() == 'Angstrom' else ""Bohr""); if not self.PYmove_to_com:; text += ""no_com\n""; if self.PYfix_orientation:; text += ""no_reorient\n"". # append atoms and coordentries and fragment separators with charge and multiplicity; Pfr = 0; for fr in range(self.nfragments()):; if self.fragment_types[fr] == 'Absent' and not self.has_zmatrix():; continue; text += ""%s%s%d %d\n"" % (; """" if Pfr == 0 else ""--\n"",; ""#"" if self.fragment_types[fr] == 'Ghost' or self.fragment_types[fr] == 'Absent' else """",; self.fragment_charges[fr], self.fragment_multiplicities[fr]); Pfr += 1; for at in range(self.fragments[fr][0], self.fragments[fr][1] + 1):; if self.fragment_types[fr] == 'Absent' or self.fsymbol(at) == ""X"":; pass; else:; if self.fZ(at):; text += ""%-8s"" % (self.flabel(at)); else:; text += ""%-8s"" % (""Gh("" + self.flabel(at) + "")""); [x, y, z] = self.full_atoms[at].compute(); text += '%17.12f %17.12f %17.12f\n' % \; (x * factor, y * factor, z * factor); text += ""\n"". wtext = 'molecule mol {\n'; for line in text.splitlines():; wtext += ' ' + line + '\n'; wtext += '}\n'; return wtext. def format_molecule_for_molpro(self):; """""". """"""; factor = 1.0 if self.PYunits == 'Angstrom' else psi_bohr2angstroms;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/qcdb/molecule.html:18103,charge,charge,18103,psi4manual/1.2.1/_modules/psi4/driver/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/qcdb/molecule.html,1,['charge'],['charge']
Energy Efficiency,"kinetic (\(T=\hat{p}^2/2\)) energy and nuclear-electron interaction potential (\(V\)), coupling matrix ( \(X\)) and renormalization matrix ( \(R\)). \[T_{\rm X2C} = R^{\dagger} (TX + {X}^{\dagger}T - {X}^{\dagger}TX ) R\]. \[V_{\rm X2C} = R^{\dagger}(V + \frac{1}{4c^2} X^{\dagger}W^{\text{SF}}X) R\]; The coupling matrix ( \({X} = C^{S} (C^{L})^{-1}\) ) is obtained from the large (\(C^{\rm L}\)) and small (\(C^{\rm S}\)) components of the \(N\) positive energy solutions of the Dirac equation.; The renormalization matrix; \({R}=S^{-1/2}(S^{-1/2}\tilde{S}S^{-1/2})^{-1/2}S^{1/2}\),; depends on the modified overlap matrix; \(\tilde{S}=S+\frac{1}{2c^2}X^{\dagger}TX\). The integrals \(W^{\rm SF}_{\mu\nu} = \langle {\chi_\mu} | \hat{p}\cdot (\hat{V}\hat{p}) |{\chi_\nu}\rangle\) can be easily computed as derivatives of the nuclear-electron attraction integrals with respect to nuclear coordinates.; Existing nonrelativistic electronic structure code can be extended to include scalar relativistic effects; treated with the X2C method by replacing nonrelativistic kinetic and potential energy with the corresponding; X2C operators \(T_{X2C}\) and \(V_{X2C}\). It is important to note that fully uncontracted basis in needed for the construction of X2C Hamiltonian as Foldy-Wouthuysen (FW [FW:1950]) transformation is obtained in kinetically balance basis. Keywords¶. RELATIVISTIC¶. Relativistic Hamiltonian type. Type: string; Possible Values: NO, X2C; Default: NO. BASIS_RELATIVISTIC¶. Auxiliary basis set for solving Dirac equation in X2C and DKH calculations. Defaults to decontracted orbital basis. Type: string; Default: No Default. table of contents. Scalar relativistic Hamiltonians; A First Example; Basis sets options; Theory; Keywords; RELATIVISTIC; BASIS_RELATIVISTIC. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Theoretical Methods: SCF to FCI. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/relativistic-1.html:4940,energy,energy,4940,psi4manual/1.1.0/relativistic-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/relativistic-1.html,2,['energy'],['energy']
Energy Efficiency,"known conditions are not easily imposed. In addition, the lack; of separability of the density matrices may result in the loss of; size-consistency and size-extensivity. In DCFT, one takes a different route and; replaces in favor of its two-particle density cumulant:. The one-particle density matrix is separated into its idempotent part; and a correction :. The idempotent part of corresponds to a mean-field Hartree-Fock-like density,; while the non-idempotent correction ; depends on the density cumulant and describes the electron correlation effects.; Inserting the above two equations into the energy expression, we obtain:. where the antisymmetrized two-electron integrals and the generalized Fock operator; matrix elements were defined as follows:. Energy functional has several important properties. First,; the energy is now a function of two sets of independent parameters, the; idempotent part of () and the density cumulant; (). As a result, the energy functional is Hermitian,; which is important for the evaluation of the molecular properties. The additive; separability of the density cumulant guarantees that all of the DCFT methods; are size-extensive and size-consistent. Furthermore, the N-representability; problem is now greatly simplified, because the idempotent part of is; N-representable by construction. One only needs to worry about the; N-representability of the density cumulant, which is a relatively small part of; .; In order to obtain the DCFT energy, two conditions must be satisfied:; 1) The energy must be stationary with respect to a set of orbitals. This can be done by; diagonalizing the generalized Fock operator (as in the DC-06 and DC-12 methods, see below),; which introduces partial orbital relaxation, or by fully relaxing the orbitals and minimizing the entire energy expression; (as in the ODC-06 and ODC-12 methods).; 2) The energy must be stationary with respect to the variation of the density; cumulant , constrained to N-representability condition",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/dcft-1.html:2318,energy,energy,2318,psi4manual/1.0.0/dcft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/dcft-1.html,2,['energy'],['energy']
Energy Efficiency,"krun-convcrit; Advanced python example sets different sets of scf/post-scf conv crit and check to be sure computation has actually converged to the expected accuracy. dfrasscf-sp; 6-31G** H2O Test RASSCF Energy Point will default to only singles and doubles in the active space. frac-traverse; Scan fractional occupation of electrons. ao-casscf-sp; CASSCF/6-31G** energy point. tu2-ch2-energy; Sample UHF/6-31G** CH2 computation. opt13; B3LYP cc-pVDZ geometry optimzation of phenylacetylene, starting from not quite linear structure. dft-bench-ionization; functionals ionization energies vs. other programs. dft-b3lyp; Check flavors of B3LYP (b3lyp3/b3lyp5) against other programs. dfomp2-grad1; DF-OMP2 cc-pVDZ gradients for the H2O molecule. psimrcc-fd-freq1; Mk-MRCCSD single point. \(^3 \Sigma ^-\) O2 state described using the Ms = 0 component of the triplet. Uses ROHF triplet orbitals. cbs-xtpl-energy; Extrapolated water energies. mints6; Patch of a glycine with a methyl group, to make alanine, then DF-SCF energy calculation with the cc-pVDZ basis set. isapt2; This is a shorter version if isapt1 - does not do cube plots. See isapt1 for full details. casscf-sa-sp; Example of state-averaged CASSCF for the C2 molecule see C. D. Sherrill and P. Piecuch, J. Chem. Phys. 122, 124104 (2005). cbs-xtpl-wrapper; RHF aug-cc-pVQZ energy for the BH molecule, with Cartesian input. Various gradients for a strained helium dimer and water molecule. pywrap-align; apply linear fragmentation algorithm to a water cluster. dfccsd1; DF-CCSD cc-pVDZ energy for the H2O molecule. cc13b; Tests RHF CCSD(T)gradients. x2c1; Test of SFX2C-1e on water uncontracted cc-pVDZ-DK The reference numbers are from Lan Cheng’s implementation in Cfour. scf-property; UFH and B3LYP cc-pVQZ properties for the CH2 molecule. dfomp2p5-2; DF-OMP2.5 cc-pVDZ energy for the H2O+ cation. soscf-dft; Triple and Singlet Oxygen energy SOSCF, also tests non-symmetric density matrices. opt14; 6-31G(d) optimization of SF4 starting f",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html:14203,energy,energy,14203,psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"kwargs). #def run_mp2_5(name, **kwargs):; # r""""""Function that computes MP2.5 energy from results of a FNOCC; # MP3 calculation.; #; # .. math:: E_{total}^{\text{MP2.5}} = E_{total,\; \text{SCF}} \; + E_{corl,\; \text{MP2}} + E_{corl, \; \text{MP3}}; #; # :PSI variables: ; #; # .. hlist:: ; # :columns: 1 ; # ; # * :psivar:`MP2.5 TOTAL ENERGY <MP2.5TOTALENERGY>` ; # * :psivar:`MP2.5 CORRELATION ENERGY <MP2.5CORRELATIONENERGY>` ; #; # >>> energy('mp2.5'); #; # """"""; # lowername = name.lower(); # kwargs = kwargs_lower(kwargs); #; # # Run detci calculation and collect conventional quantities; # energy('mp3', **kwargs); # e_scf = PsiMod.get_variable('SCF TOTAL ENERGY'); # ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); # ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'); # e_mp2 = e_scf + ce_mp2; # e_mp3 = e_scf + ce_mp3; #; # # Compute quantities particular to MP2.5; # ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); # e_mp25 = e_scf + ce_mp25; # PsiMod.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25); # PsiMod.set_variable('MP2.5 TOTAL ENERGY', e_mp25); # PsiMod.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); # PsiMod.set_variable('CURRENT ENERGY', e_mp25); #; # # build string of title banner and print results; # banners = ''; # banners += """"""PsiMod.print_out('\\n')\n""""""; # banners += """"""banner(' MP2.5 ')\n""""""; # banners += """"""PsiMod.print_out('\\n')\n\n""""""; # exec(banners); #; # tables = ''; # tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); # tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); # tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); # tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); # tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); # tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); # tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); # PsiMod.print_out(tables); #; # return e_mp25. # A direct translation of a plugin input file into a function call. Function calls are the only; # way to ca",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/aliases.html:3135,ENERGY,ENERGY,3135,psi4manual/4.0b4/_modules/aliases.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/aliases.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"kwargs). PsiMod.print_out('\n'); banner('DFMP2'); PsiMod.print_out('\n'). # if the df_basis_mp2 basis is not set, pick a sensible one.; if PsiMod.get_global_option('DF_BASIS_MP2') == '':; ribasis = corresponding_rifit(PsiMod.get_global_option('BASIS')); if ribasis:; PsiMod.set_global_option('DF_BASIS_MP2', ribasis); PsiMod.print_out('No DF_BASIS_MP2 auxiliary basis selected, defaulting to %s\n' % (ribasis)); else:; raise ValidationError('Keyword DF_BASIS_MP2 is required.'). e_dfmp2 = PsiMod.dfmp2(); e_scs_dfmp2 = PsiMod.get_variable('SCS-DF-MP2 ENERGY'). optstash.restore(). if (name.upper() == 'SCS-DFMP2') or (name.upper() == 'SCS-DF-MP2'):; return e_scs_dfmp2; elif (name.upper() == 'DF-MP2') or (name.upper() == 'DFMP2'):; return e_dfmp2. [docs]def run_psimrcc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for a PSIMRCC computation; using a reference from the MCSCF module. """"""; run_mcscf(name, **kwargs); PsiMod.psimrcc(); e_psimrcc = PsiMod.get_variable(""Current Energy""); return e_psimrcc. [docs]def run_psimrcc_scf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for a PSIMRCC computation; using a reference from the SCF module. """""". run_scf(name, **kwargs); PsiMod.psimrcc(); e_psimrcc = PsiMod.get_variable(""Current Energy""); return e_psimrcc. [docs]def run_mp2c(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a coupled MP2 calculation. """"""; optstash = OptionsState(; ['DF_BASIS_MP2']). molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); monomerA = molecule.extract_subsets(1, 2); monomerA.set_name('monomerA'); monomerB = molecule.extract_subsets(2, 1); monomerB.set_name('monomerB'). # if the df_basis_mp2 basis is not set, pick a sensible one.; if PsiMod.get_global_option('DF_BASIS_MP2') == '':; ribasis = corresponding_rifit(PsiMod.get_global_option('BASIS')); if ribasis:; PsiMod.set_global_option('DF_BASIS_MP2', ribasis); PsiMod.print_out('No DF_BASIS_MP2 auxiliary basis selected, defaulti",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/proc.html:29292,Energy,Energy,29292,psi4manual/4.0b3/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/proc.html,1,['Energy'],['Energy']
Energy Efficiency,"kwargs):; cbs_scf_scheme = scf_xtpl_helgaker_2; elif (len(BSTR) == 1) and ('scf_basis' in kwargs):; cbs_scf_scheme = xtpl_highest_1; elif 'scf_basis' in kwargs:; raise ValidationError(""""""SCF basis sets of number %d cannot be handled."""""" % (len(BSTR))); elif do_corl:; cbs_scf_scheme = xtpl_highest_1; BSTR = [BSTC[-1]]; ZETR = [ZETC[-1]]; if 'scf_scheme' in kwargs:; cbs_scf_scheme = kwargs['scf_scheme']. # Establish treatment for correlation energy; if do_corl:; if len(BSTC) == 2:; cbs_corl_scheme = corl_xtpl_helgaker_2; else:; cbs_corl_scheme = xtpl_highest_1; if 'corl_scheme' in kwargs:; cbs_corl_scheme = kwargs['corl_scheme']. # Establish treatment for delta correction energy; if do_delta:; if len(BSTD) == 2:; cbs_delta_scheme = corl_xtpl_helgaker_2; else:; cbs_delta_scheme = xtpl_highest_1; if 'delta_scheme' in kwargs:; cbs_delta_scheme = kwargs['delta_scheme']. # Establish treatment for delta2 correction energy; if do_delta2:; if len(BSTD2) == 2:; cbs_delta2_scheme = corl_xtpl_helgaker_2; else:; cbs_delta2_scheme = xtpl_highest_1; if 'delta2_scheme' in kwargs:; cbs_delta2_scheme = kwargs['delta2_scheme']. # # Establish treatment for delta3 correction energy; # if do_delta3:; # if len(BSTD3) == 2:; # cbs_delta3_scheme = corl_xtpl_helgaker_2; # else:; # cbs_delta3_scheme = xtpl_highest_1; # if 'delta3_scheme' in kwargs:; # cbs_delta3_scheme = kwargs['delta3_scheme']; #; # # Establish treatment for delta4 correction energy; # if do_delta4:; # if len(BSTD4) == 2:; # cbs_delta4_scheme = corl_xtpl_helgaker_2; # else:; # cbs_delta4_scheme = xtpl_highest_1; # if 'delta4_scheme' in kwargs:; # cbs_delta4_scheme = kwargs['delta4_scheme']; #; # # Establish treatment for delta5 correction energy; # if do_delta5:; # if len(BSTD5) == 2:; # cbs_delta5_scheme = corl_xtpl_helgaker_2; # else:; # cbs_delta5_scheme = xtpl_highest_1; # if 'delta5_scheme' in kwargs:; # cbs_delta5_scheme = kwargs['delta5_scheme']. # Build string of title banner; cbsbanners = ''; cbsbanners += """"""core.pri",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver_cbs.html:39566,energy,energy,39566,psi4manual/1.1.0/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver_cbs.html,1,['energy'],['energy']
Energy Efficiency,"kwargs):; cbs_scf_scheme = scf_xtpl_helgaker_2; elif (len(BSTR) == 1) and ('scf_basis' in kwargs):; cbs_scf_scheme = xtpl_highest_1; elif 'scf_basis' in kwargs:; raise ValidationError(""""""SCF basis sets of number %d cannot be handled."""""" % (len(BSTR))); elif do_corl:; cbs_scf_scheme = xtpl_highest_1; BSTR = [BSTC[-1]]; ZETR = [ZETC[-1]]; if 'scf_scheme' in kwargs:; cbs_scf_scheme = kwargs['scf_scheme']. # Establish treatment for correlation energy; if do_corl:; if len(BSTC) == 2:; cbs_corl_scheme = corl_xtpl_helgaker_2; else:; cbs_corl_scheme = xtpl_highest_1; if 'corl_scheme' in kwargs:; cbs_corl_scheme = kwargs['corl_scheme']. # Establish treatment for delta correction energy; if do_delta:; if len(BSTD) == 2:; cbs_delta_scheme = corl_xtpl_helgaker_2; else:; cbs_delta_scheme = xtpl_highest_1; if 'delta_scheme' in kwargs:; cbs_delta_scheme = kwargs['delta_scheme']. # Establish treatment for delta2 correction energy; if do_delta2:; if len(BSTD2) == 2:; cbs_delta2_scheme = corl_xtpl_helgaker_2; else:; cbs_delta2_scheme = xtpl_highest_1; if 'delta2_scheme' in kwargs:; cbs_delta2_scheme = kwargs['delta2_scheme']. # # Establish treatment for delta3 correction energy; # if do_delta3:; # if len(BSTD3) == 2:; # cbs_delta3_scheme = corl_xtpl_helgaker_2; # else:; # cbs_delta3_scheme = xtpl_highest_1; # if 'delta3_scheme' in kwargs:; # cbs_delta3_scheme = kwargs['delta3_scheme']; #; # # Establish treatment for delta4 correction energy; # if do_delta4:; # if len(BSTD4) == 2:; # cbs_delta4_scheme = corl_xtpl_helgaker_2; # else:; # cbs_delta4_scheme = xtpl_highest_1; # if 'delta4_scheme' in kwargs:; # cbs_delta4_scheme = kwargs['delta4_scheme']; #; # # Establish treatment for delta5 correction energy; # if do_delta5:; # if len(BSTD5) == 2:; # cbs_delta5_scheme = corl_xtpl_helgaker_2; # else:; # cbs_delta5_scheme = xtpl_highest_1; # if 'delta5_scheme' in kwargs:; # cbs_delta5_scheme = kwargs['delta5_scheme']. # Build string of title banner; cbsbanners = ''; cbsbanners += """"""psi4.pri",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:39213,energy,energy,39213,psi4manual/1.0.0/_modules/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html,1,['energy'],['energy']
Energy Efficiency,"kwargs):; r""""""Function to compute harmonic vibrational frequencies. :aliases: frequencies(), freq(). :returns: *float* |w--w| Total electronic energy in Hartrees. :returns: (*float*, :ref:`Wavefunction<sec:psimod_Wavefunction>`) |w--w| energy and wavefunction when **return_wfn** specified. :type name: string; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :ref:`Wavefunction<sec:psimod_Wavefunction>`; calculation result as the second element (after *float* energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``freq_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. For a finite difference of energies or gradients frequency, indicates; whether the calculations required to complete the frequency are to be run; in one file (``'continuous'``) or are to be farmed out in an; embarrassingly parallel fashion (``'sow'``/``'reap'``)/ For the latter,; run an initial job with ``'sow'`` and follow instructions in its output file.; For maximum flexibility, ``return_wfn`` is always on in ``'reap'`` mode. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: |dl| ``'hessian'`` |dr| || ``'gra",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver.html:79716,energy,energy,79716,psi4manual/1.0.0/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver.html,1,['energy'],['energy']
Energy Efficiency,"kwargs); Overloaded function. extract_subsets(self: psi4.core.Molecule, arg0: List[int], arg1: List[int]) -> psi4.core.Molecule. Returns copy of arg1 with arg2 fragments Real and arg3 fragments Ghost. extract_subsets(self: psi4.core.Molecule, arg0: List[int], arg1: int) -> psi4.core.Molecule. Returns copy of arg1 with arg2 fragments Real and arg3 fragment Ghost. extract_subsets(self: psi4.core.Molecule, arg0: int, arg1: List[int]) -> psi4.core.Molecule. Returns copy of arg1 with arg2 fragment Real and arg3 fragments Ghost. extract_subsets(self: psi4.core.Molecule, arg0: int, arg1: int) -> psi4.core.Molecule. Returns copy of arg1 with arg2 fragment Real and arg3 fragment Ghost. extract_subsets(self: psi4.core.Molecule, arg0: List[int]) -> psi4.core.Molecule. Returns copy of arg1 with arg2 fragments Real. extract_subsets(self: psi4.core.Molecule, arg0: int) -> psi4.core.Molecule. Returns copy of arg1 with arg2 fragment Real. fZ(self: psi4.core.Molecule, arg0: int) → float; Nuclear charge of atom arg1 (0-indexed including dummies). find_point_group(self: psi4.core.Molecule, arg0: float) → psi4.core.PointGroup; Finds computational molecular point group, user can override this with the symmetry keyword. fix_com(self: psi4.core.Molecule, arg0: bool) → None; Whether to fix the Cartesian position, or to translate to the C.O.M. fix_orientation(self: psi4.core.Molecule, arg0: bool) → None; Fix the orientation at its current frame. form_symmetry_information(self: psi4.core.Molecule, arg0: float) → None; Uses the point group object obtain by calling point_group(). classmethod from_arrays(geom=None, elea=None, elez=None, elem=None, mass=None, real=None, elbl=None, name=None, units='Angstrom', input_units_to_au=None, fix_com=None, fix_orientation=None, fix_symmetry=None, fragment_separators=None, fragment_charges=None, fragment_multiplicities=None, molecular_charge=None, molecular_multiplicity=None, missing_enabled_return='error', tooclose=0.1, zero_ghost_fragments=False, nonphys",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/api/psi4.core.molecule.html:39913,charge,charge,39913,psi4manual/1.2.1/api/psi4.core.molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/api/psi4.core.molecule.html,1,['charge'],['charge']
Energy Efficiency,"kwargs); Overloaded function. extract_subsets(self: psi4.core.Molecule, arg0: List[int], arg1: List[int]) -> psi4.core.Molecule. Returns copy of self with arg0 fragments Real and arg1 fragments Ghost. extract_subsets(self: psi4.core.Molecule, arg0: List[int], arg1: int) -> psi4.core.Molecule. Returns copy of self with arg0 fragments Real and arg1 fragment Ghost. extract_subsets(self: psi4.core.Molecule, arg0: int, arg1: List[int]) -> psi4.core.Molecule. Returns copy of self with arg0 fragment Real and arg1 fragments Ghost. extract_subsets(self: psi4.core.Molecule, arg0: int, arg1: int) -> psi4.core.Molecule. Returns copy of self with arg0 fragment Real and arg1 fragment Ghost. extract_subsets(self: psi4.core.Molecule, arg0: List[int]) -> psi4.core.Molecule. Returns copy of self with arg0 fragments Real. extract_subsets(self: psi4.core.Molecule, arg0: int) -> psi4.core.Molecule. Returns copy of self with arg0 fragment Real. fZ(self: psi4.core.Molecule, arg0: int) → float; Nuclear charge of atom arg1 (0-indexed including dummies). fcharge(self: psi4.core.Molecule, atom: int) → float; Gets charge of atom (0-indexed including dummies). find_highest_point_group(self: psi4.core.Molecule, tolerance: float=1e-08) → psi4.core.PointGroup; Finds highest possible computational molecular point group. find_point_group(self: psi4.core.Molecule, tolerance: float=1e-08) → psi4.core.PointGroup; Finds computational molecular point group, user can override this with the symmetry keyword. fix_com(self: psi4.core.Molecule, arg0: bool) → None; Sets whether to fix the Cartesian position, or to translate to the C.O.M. fix_orientation(self: psi4.core.Molecule, arg0: bool) → None; Fix the orientation at its current frame. flabel(self: psi4.core.Molecule, atom: int) → str; Gets the original label of the atom arg0 as given in the input file (C2, H4)(0-indexed including dummies). fmass(self: psi4.core.Molecule, atom: int) → float; Gets mass of atom (0-indexed including dummies). form_symmetry_in",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.molecule.html:44155,charge,charge,44155,psi4manual/1.3.2/api/psi4.core.molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.molecule.html,1,['charge'],['charge']
Energy Efficiency,"kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(). # Allow specification of methods to arbitrary order; lowername, level = parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. try:; return procedures['energy'][lowername](lowername, **kwargs); except KeyError:; raise ValidationError('Energy method %s not available.' % (lowername)). [docs]def gradient(name, **kwargs):; r""""""Function complementary to optimize(). Carries out one gradient pass,; deciding analytic or finite difference. """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs); dertype = 1. # Order of precedence:; # 1. Default for wavefunction; # 2. Value obtained from kwargs, if user changed it; # 3. If user provides a custom 'func' use that. # Allow specification of methods to arbitrary order; lowername, level = parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. # 1. set the default to that of the provided name; if lowername in procedures['gradient']:; dertype = 1; elif lowername in procedures['energy']:; dertype = 0; func = energy. # 2. Check if the user passes dertype into this function; if 'dertype' in kwargs:; opt_dertype = kwargs['dertype']. if der0th.match(str(opt_dertype)):; dertype = 0; func = energy; elif der1st.match(str(opt_dertype)):; dertype = 1; else:; raise ValidationError('Requested derivative level \'dertype\' %s not valid for helper function optimize.' % (opt_dertype)). # 3. if the user provides a custom function THAT takes precendence; if ('opt_func' in kwargs) or ('func' in kwargs):; if ('func' in kwargs):; kwargs['opt_func'] = kwargs['func']; del kwargs['func']; dertype = 0; func = kwargs['opt_func']. # Summary validation; if (dertype == 1) and (lowername in procedures['gradient']):; pass; elif (dertype == 0) and (func is energy) and (lowername in procedures['energy']):; pass; elif (dertype == 0) and not(func is energy):; pass; else:; raise ValidationError('Requested method \'name\' %s and derivative level \'d",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/driver.html:23641,energy,energy,23641,psi4manual/4.0b3/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/driver.html,4,['energy'],['energy']
Energy Efficiency,"kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(). # Allow specification of methods to arbitrary order; lowername, level = parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. try:; return procedures['energy'][lowername](lowername, **kwargs); except KeyError:; raise ValidationError('Energy method %s not available.' % (lowername)). [docs]def gradient(name, **kwargs):; r""""""Function complementary to optimize(). Carries out one gradient pass,; deciding analytic or finite difference. """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs); dertype = 1. # Order of precedence:; # 1. Default for wavefunction; # 2. Value obtained from kwargs, if user changed it; # 3. If user provides a custom 'func' use that. # Allow specification of methods to arbitrary order; lowername, level = parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. # 1. set the default to that of the provided name; if lowername in procedures['gradient']:; dertype = 1; elif lowername in procedures['energy']:; dertype = 0; func = energy. if (PsiMod.get_global_option('REFERENCE').lower() == 'rks') or (PsiMod.get_global_option('REFERENCE').lower() == 'uks'):; dertype = 0; func = energy. # 2. Check if the user passes dertype into this function; if 'dertype' in kwargs:; opt_dertype = kwargs['dertype']. if input.der0th.match(str(opt_dertype)):; dertype = 0; func = energy; elif input.der1st.match(str(opt_dertype)):; dertype = 1; else:; raise ValidationError('Requested derivative level \'dertype\' %s not valid for helper function optimize.' % (opt_dertype)). # 3. if the user provides a custom function THAT takes precendence; if ('opt_func' in kwargs) or ('func' in kwargs):; if ('func' in kwargs):; kwargs['opt_func'] = kwargs['func']; del kwargs['func']; dertype = 0; func = kwargs['opt_func']. # Summary validation; if (dertype == 1) and (lowername in procedures['gradient']):; pass; elif (dertype == 0) and (func is energy) and (lowername in pro",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/driver.html:21010,energy,energy,21010,psi4manual/4.0b2/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/driver.html,4,['energy'],['energy']
Energy Efficiency,"kwargs['scf_basis'] = 'aug-cc-pVQZ'; if not ('scf_scheme' in kwargs):; kwargs['scf_scheme'] = highest_1. if not ('corl_wfn' in kwargs):; kwargs['corl_wfn'] = 'mp2'; if not ('corl_basis' in kwargs):; kwargs['corl_basis'] = 'aug-cc-pV[TQ]Z'; if not ('corl_scheme' in kwargs):; kwargs['corl_scheme'] = corl_xtpl_helgaker_2. if not ('delta_wfn' in kwargs):; kwargs['delta_wfn'] = 'ccsd(t)'; if not ('delta_wfn_lesser' in kwargs):; kwargs['delta_wfn_lesser'] = 'mp2'; if not ('delta_basis' in kwargs):; kwargs['delta_basis'] = 'aug-cc-pVTZ'; if not ('delta_scheme' in kwargs):; kwargs['delta_scheme'] = highest_1. return cbs(name, **kwargs). [docs]def run_mp2_5(name, **kwargs):; r""""""Function that computes MP2.5 energy from results of a DETCI; MP3 calculation. .. math:: E_{total}^{\text{MP2.5}} = E_{total,\; \text{SCF}} \; + E_{corl,\; \text{MP2}} + E_{corl, \; \text{MP3}}. :PSI variables: . .. hlist:: ; :columns: 1 ; ; * :psivar:`MP2.5 TOTAL ENERGY <MP2.5TOTALENERGY>` ; * :psivar:`MP2.5 CORRELATION ENERGY <MP2.5CORRELATIONENERGY>` . >>> energy('mp2.5'). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Run detci calculation and collect conventional quantities; energy('mp3', **kwargs); e_scf = PsiMod.get_variable('SCF TOTAL ENERGY'); ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; PsiMod.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25); PsiMod.set_variable('MP2.5 TOTAL ENERGY', e_mp25); PsiMod.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); PsiMod.set_variable('CURRENT ENERGY', e_mp25). # build string of title banner and print results; banners = ''; banners += """"""PsiMod.print_out('\\n')\n""""""; banners += """"""banner(' MP2.5 ')\n""""""; banners += """"""PsiMod.print_out('\\n')\n\n""""""; exec banners. tables = ''; tables += """""" SCF total energy: %16.8f\n"""""" % (e",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/aliases.html:2519,ENERGY,ENERGY,2519,psi4manual/4.0b2/_modules/aliases.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/aliases.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"kwargs['scf_basis'] = 'aug-cc-pVQZ'; if not ('scf_scheme' in kwargs):; kwargs['scf_scheme'] = highest_1. if not ('corl_wfn' in kwargs):; kwargs['corl_wfn'] = 'mp2'; if not ('corl_basis' in kwargs):; kwargs['corl_basis'] = 'aug-cc-pV[TQ]Z'; if not ('corl_scheme' in kwargs):; kwargs['corl_scheme'] = corl_xtpl_helgaker_2. if not ('delta_wfn' in kwargs):; kwargs['delta_wfn'] = 'ccsd(t)'; if not ('delta_wfn_lesser' in kwargs):; kwargs['delta_wfn_lesser'] = 'mp2'; if not ('delta_basis' in kwargs):; kwargs['delta_basis'] = 'aug-cc-pVTZ'; if not ('delta_scheme' in kwargs):; kwargs['delta_scheme'] = highest_1. return cbs(name, **kwargs). [docs]def run_mp2_5(name, **kwargs):; r""""""Function that computes MP2.5 energy from results of a DETCI; MP3 calculation. .. math:: E_{total}^{\text{MP2.5}} = E_{total,\; \text{SCF}} \; + E_{corl,\; \text{MP2}} + E_{corl, \; \text{MP3}}. :PSI variables: . .. hlist:: ; :columns: 1 ; ; * :psivar:`MP2.5 TOTAL ENERGY <MP2.5TOTALENERGY>` ; * :psivar:`MP2.5 CORRELATION ENERGY <MP2.5CORRELATIONENERGY>` . >>> energy('mp2.5'). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Run detci calculation and collect conventional quantities; energy('mp3', **kwargs); e_scf = PsiMod.get_variable('SCF TOTAL ENERGY'); ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; PsiMod.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25); PsiMod.set_variable('MP2.5 TOTAL ENERGY', e_mp25); PsiMod.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); PsiMod.set_variable('CURRENT ENERGY', e_mp25). # build string of title banner and print results; banners = ''; banners += """"""PsiMod.print_out('\\n')\n""""""; banners += """"""banner(' MP2.5 ')\n""""""; banners += """"""PsiMod.print_out('\\n')\n\n""""""; exec(banners). tables = ''; tables += """""" SCF total energy: %16.8f\n"""""" % (",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/aliases.html:2516,ENERGY,ENERGY,2516,psi4manual/4.0b3/_modules/aliases.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/aliases.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"l = kwargs['omega_tolerance']. # By default, do up to twenty iterations; maxiter = 20;; if (kwargs.has_key('maxiter')): ; maxiter = kwargs['maxiter']. # By default, do not read previous 180 orbitals file; read = False;; read180 = ''; if (kwargs.has_key('read')):; read = True;; read180 = kwargs['read']. # The molecule is required, and should be the neutral species; mol.update_geometry(); activate(mol); charge0 = mol.molecular_charge(); mult0 = mol.multiplicity() . # How many electrons are there?; N = 0;; for A in range(mol.natom()):; N += mol.Z(A); N -= charge0; N = int(N); Nb = int((N - mult0 + 1)/2); Na = int(N - Nb). # Work in the ot namespace for this procedure; PsiMod.IO.set_default_namespace(""ot""). # Burn in to determine orbital eigenvalues; if (read):; PsiMod.set_global_option(""GUESS"", ""READ""); copy_file_to_scratch(read180, 'psi', 'ot', 180); old_guess = PsiMod.get_global_option(""GUESS""); PsiMod.set_global_option(""DF_INTS_IO"", ""SAVE""); PsiMod.print_out('\n\t==> IP Fitting SCF: Burn-in <==\n'); energy('scf'); PsiMod.set_global_option(""DF_INTS_IO"", ""LOAD""). # Determine HOMO, to determine mult1; ref = PsiMod.reference_wavefunction(); eps_a = ref.epsilon_a(); eps_b = ref.epsilon_b(); if (Na == Nb):; HOMO = -Nb; elif (Nb == 0):; HOMO = Na; else:; E_a = eps_a[int(Na - 1)] ; E_b = eps_b[int(Nb - 1)] ; if (E_a >= E_b):; HOMO = Na; else: ; HOMO = -Nb. Na1 = Na;; Nb1 = Nb;; if (HOMO > 0):; Na1 = Na1-1;; else:; Nb1 = Nb1-1;; ; charge1 = charge0 + 1; ; mult1 = Na1 - Nb1 + 1. omegas = [];; E0s = [];; E1s = [];; kIPs = [];; IPs = [];; types = [];; ; # Right endpoint; PsiMod.set_global_option('DFT_OMEGA',omega_r). # Neutral; if (read):; PsiMod.set_global_option(""GUESS"", ""READ""); copy_file_to_scratch(read180, 'psi', 'ot', 180). mol.set_molecular_charge(charge0); mol.set_multiplicity(mult0); PsiMod.print_out('\n\t==> IP Fitting SCF: Neutral, Right Endpoint <==\n'); E0r = energy('scf'); ref = PsiMod.reference_wavefunction(); eps_a = ref.epsilon_a(); eps_b = ref.epsilon_b(); E_H",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/frac.html:12154,energy,energy,12154,psi4manual/4.0b2/_modules/frac.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/frac.html,4,['energy'],['energy']
Energy Efficiency,"l = kwargs['omega_tolerance']. # By default, do up to twenty iterations; maxiter = 20;; if (kwargs.has_key('maxiter')): ; maxiter = kwargs['maxiter']. # By default, do not read previous 180 orbitals file; read = False;; read180 = ''; if (kwargs.has_key('read')):; read = True;; read180 = kwargs['read']. # The molecule is required, and should be the neutral species; mol.update_geometry(); activate(mol); charge0 = mol.molecular_charge(); mult0 = mol.multiplicity() . # How many electrons are there?; N = 0;; for A in range(mol.natom()):; N += mol.Z(A); N -= charge0; N = int(N); Nb = int((N - mult0 + 1)/2); Na = int(N - Nb). # Work in the ot namespace for this procedure; PsiMod.IO.set_default_namespace(""ot""). # Burn in to determine orbital eigenvalues; if (read):; PsiMod.set_global_option(""GUESS"", ""READ""); copy_file_to_scratch(read180, 'psi', 'ot', 180); old_guess = PsiMod.get_global_option(""GUESS""); PsiMod.set_global_option(""DF_INTS_IO"", ""SAVE""); PsiMod.print_out('\n\t==> IP Fitting SCF: Burn-in <==\n'); energy('scf'); PsiMod.set_global_option(""DF_INTS_IO"", ""LOAD""). # Determine HOMO, to determine mult1; ref = PsiMod.wavefunction(); eps_a = ref.epsilon_a(); eps_b = ref.epsilon_b(); if (Na == Nb):; HOMO = -Nb; elif (Nb == 0):; HOMO = Na; else:; E_a = eps_a[int(Na - 1)] ; E_b = eps_b[int(Nb - 1)] ; if (E_a >= E_b):; HOMO = Na; else: ; HOMO = -Nb. Na1 = Na;; Nb1 = Nb;; if (HOMO > 0):; Na1 = Na1-1;; else:; Nb1 = Nb1-1;; ; charge1 = charge0 + 1; ; mult1 = Na1 - Nb1 + 1. omegas = [];; E0s = [];; E1s = [];; kIPs = [];; IPs = [];; types = [];; ; # Right endpoint; PsiMod.set_global_option('DFT_OMEGA',omega_r). # Neutral; if (read):; PsiMod.set_global_option(""GUESS"", ""READ""); copy_file_to_scratch(read180, 'psi', 'ot', 180). mol.set_molecular_charge(charge0); mol.set_multiplicity(mult0); PsiMod.print_out('\n\t==> IP Fitting SCF: Neutral, Right Endpoint <==\n'); E0r = energy('scf'); ref = PsiMod.wavefunction(); eps_a = ref.epsilon_a(); eps_b = ref.epsilon_b(); E_HOMO = 0.0;; if (Nb =",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/frac.html:12071,energy,energy,12071,psi4manual/4.0b4/_modules/frac.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/frac.html,2,['energy'],['energy']
Energy Efficiency,"l = list(mc_level_labels)[0]; nbodies = metadata['nbodies_per_mc_level'][mc_level_lbl - 1]; if nbodies[0] == 'supersystem':; # range for supersystem sub-components; nbodies = metadata['nbodies_per_mc_level'][mc_level_lbl]; metadata['bsse_type'] = ['nocp']. # regenerate per-bsse required calcs list; compute_dict = build_nbody_compute_list(; metadata['bsse_type'], nbodies, metadata['nfragments'], metadata[""return_total_data""], verbose=0; ). # Build size and slices dictionaries; fragment_size_dict = {}; fragment_slice_dict = {}; iat = 0; for ifr in range(1, metadata[""nfragments""] + 1):; nat = metadata[""molecule""].extract_subsets(ifr).natom(); fragment_size_dict[ifr] = nat; fragment_slice_dict[ifr] = slice(iat, iat + nat); iat += nat. def shaped_zero(der: DriverEnum):; if der == ""energy"":; return 0.0; elif der == ""gradient"":; arr_shape = (nat, 3); return np.zeros(arr_shape); elif der == 'hessian':; arr_shape = (nat * 3, nat * 3); return np.zeros(arr_shape). # Final dictionaries; if ptype == ""energy"":; cp_by_level = {n: 0.0 for n in range(1, nbodies[-1] + 1)}; nocp_by_level = {n: 0.0 for n in range(1, nbodies[-1] + 1)}; vmfc_by_level = {n: 0.0 for n in range(1, nbodies[-1] + 1)}. cp_body_dict = {n: 0.0 for n in range(1, nbodies[-1] + 1)}; nocp_body_dict = {n: 0.0 for n in range(1, nbodies[-1] + 1)}; vmfc_body_dict = {n: 0.0 for n in range(1, nbodies[-1] + 1)}. else:; nat = sum(fragment_size_dict.values()); if ptype == 'gradient':; arr_shape = (nat, 3); elif ptype == 'hessian':; arr_shape = (nat * 3, nat * 3). cp_by_level = {n: np.zeros(arr_shape) for n in range(1, nbodies[-1] + 1)}; nocp_by_level = {n: np.zeros(arr_shape) for n in range(1, nbodies[-1] + 1)}; vmfc_by_level = {n: np.zeros(arr_shape) for n in range(1, nbodies[-1] + 1)}. cp_body_dict = {n: np.zeros(arr_shape) for n in range(1, nbodies[-1] + 1)}; nocp_body_dict = {n: np.zeros(arr_shape) for n in range(1, nbodies[-1] + 1)}; vmfc_body_dict = {n: np.zeros(arr_shape) for n in range(1, nbodies[-1] + 1)}. # Sum up ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html:23629,energy,energy,23629,psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html,10,['energy'],['energy']
Energy Efficiency,"l BLAS and OpenMP. Note that this algorithm should use the -JKFIT series; of auxiliary bases, not the -RI or -MP2FIT bases. The default guess for; auxiliary basis set should work for all Dunning bases, otherwise the; DF_BASIS_SCF keyword can be used to manually specify the auxiliary basis.; This algorithm is preferred unless either absolute accuracy is required; [CCSD(T)] or a -JKFIT auxiliary basis is unavailable for the; primary basis/atoms involved. For some of these algorithms, Schwarz and/or density sieving can be used to; identify negligible integral contributions in extended systems. To activate; sieving, set the INTS_TOLERANCE keyword to your desired cutoff; (1.0E-12 is recommended for most applications). Convergence and Algorithm Defaults¶. SCF algorithm and convergence criteria defaults by calculation type [1]. Ab Initio Method; Calculation Type; E_CONVERGENCE; D_CONVERGENCE; SCF_TYPE. SCF of HF or DFT; energy; 6; 5; DF. optimization; 8; 6. frequency; 8; 6. SCF of post-HF; energy; 8; 6; PK [3]. optimization; 10; 7. frequency; 10; 7. CC property [2]; 10; 7. Footnotes. [1]Note that this table applies only the SCF module,; not to the final convergence criteria for post-HF methods or to methods; that use an alternate starting point, like MCSCF. [2]This applies to properties computed through the property() function. [3]Post-HF methods that do not rely upon the usual 4-index AO integrals use a density-; fitted SCF reference. That is, for DF-MP2 and SAPT, the default SCF_TYPE is DF. Recommendations¶; The SCF code is already quite flexible and powerful, with new features being; added weekly. We have tried as much as possible to keep the number of options to; a minimum, and to allow all options to be used in the presence of all other; options. Below are some rough words of advice about using the SCF code for; practical calculations:. For GUESS, the SAD guess is usually your; friend, even for open-shell systems (at the very least, it gets the right; number of electr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/scf-1.html:19726,energy,energy,19726,psi4manual/4.0b3/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/scf-1.html,2,['energy'],['energy']
Energy Efficiency,"l Dipole Moment : 0.50533 0.65198 -0.00000; # -----------------------------------------; #Magnitude (a.u.) : 0.82489; #Magnitude (Debye) : 2.09670; #; #. dipole_start = find_start(lines, 'DIPOLE MOMENT'). if dipole_start != -1:; # Dipole x, y, z are the last items 6 lines down in the dipole block; dipole_str_list = lines[dipole_start + 6].split()[-3:]; # Convert the dipole to debye; dipole = [float(i)*psi_dipmom_au2debye for i in dipole_str_list]; psivar['CURRENT DIPOLE X'] = dipole[0]; psivar['CURRENT DIPOLE Y'] = dipole[1]; psivar['CURRENT DIPOLE Z'] = dipole[2]. # Dipole magnitude is 8 line down in the dipole block; magnitude = float(lines[dipole_start + 8][-1]). [docs]def harvest_mp2(lines, psivar):; """"""Harvest the MP2 results""""""; """"""Sample MP2 energy line (works for both MP2 and RI-MP2)""""""; #---------------------------------------; #MP2 TOTAL ENERGY: -76.226803665 Eh; #---------------------------------------. """"""Sample MP2 correlation energy line (yes there is a space)""""""; #-----------------------------------------------; # MP2 CORRELATION ENERGY : -0.125436532 Eh; #-----------------------------------------------. """"""Sample RI-MP2 Correlation energy line (yes there is a space)""""""; #-----------------------------------------------; # RI-MP2 CORRELATION ENERGY: -0.125496692 Eh; #-----------------------------------------------. for line in reversed(lines):; if line[:16] == 'MP2 TOTAL ENERGY':; psivar['MP2 TOTAL ENERGY'] = line.split()[-2]; break; for line in reversed(lines):; if line[:23] == ' MP2 CORRELATION ENERGY' or\; line[:26] == ' RI-MP2 CORRELATION ENERGY':; psivar['MP2 CORRELATION ENERGY'] = line.split()[-2]; break. [docs]def harvest_coupled_cluster(lines, psivar):; """"""Harvest coupled cluster results; WARNING: Canonical and DLPNO print the coupled cluster results differently; """"""; """"""Sample (canonical) CCSD results block""""""; #----------------------; #COUPLED CLUSTER ENERGY; #----------------------; #; #E(0) ... -76.063720080; #E(CORR) ... -0.288938791; #E(T",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/orca.html:6830,energy,energy,6830,psi4manual/1.0.0/_modules/qcdb/orca.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/orca.html,1,['energy'],['energy']
Energy Efficiency,"l Energy [Eh] I.E. [kcal/mol] Delta [kcal/mol]\n""""""); previous_e = energy_body_dict[1]; nbody_range = list(energy_body_dict); nbody_range.sort(); for n in nbody_range:; delta_e = (energy_body_dict[n] - previous_e); delta_e_kcal = delta_e * constants.hartree2kcalmol; int_e_kcal = (energy_body_dict[n] - energy_body_dict[1]) * constants.hartree2kcalmol; core.print_out("""""" %4s %20.12f %20.12f %20.12f\n"""""" %; (n, energy_body_dict[n], int_e_kcal, delta_e_kcal)); previous_e = energy_body_dict[n]; core.print_out(""\n""). [docs]def nbody_gufunc(func, method_string, **kwargs):; """"""; Computes the nbody interaction energy, gradient, or Hessian depending on input.; This is a generalized univeral function for computing interaction quantities. :returns: *return type of func* |w--w| The interaction data. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| interaction data and wavefunction with energy/gradient/hessian set appropriately when **return_wfn** specified. :type func: function; :param func: ``energy`` || etc. Python function that accepts method_string and a molecule. Returns a; energy, gradient, or Hessian as requested. :type method_string: string; :param method_string: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, lowercase and usually unlabeled. Indicates the computational; method to be passed to func. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element of a tuple. :type bsse_type: string or list; :param bsse_type: ``'cp'`` || ``['nocp', 'vmfc']`` || |dl| ``None`` |dr| || etc. Type of BSSE correction to compute: CP, NoCP, or VMFC. The first in this; list is returned by this function. By default, this function is not called. :type max_nbody: int; :para",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver_nbody.html:4022,energy,energy,4022,psi4manual/1.1.0/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver_nbody.html,2,['energy'],['energy']
Energy Efficiency,"l Smoke Test. dfmp2-grad4; DF-MP2 cc-pVDZ gradient for the NO molecule. soscf-ref; Triple and Singlet Oxygen energy SOSCF, also tests non-symmetric density matrices. dfomp2-grad2; OMP2 cc-pVDZ energy for the NO molecule. linK-1; RHF Linear Exchange Algorithm test for water. mbis-3; MBIS calculation on OH radical. sapt6; checks that all SAPT physical components (elst, exch, indc, disp) and total IE are being computed correctly for SAPT2+3(CCD)dMP2/aug-cc-pvdz and all lesser methods thereof. dft-grad-lr1; wB97X-D cc-pVDZ gradient of S22 HCN update df/pk_ref values due to new BraggSlater radii. dft2; DFT Functional Test. soscf-large; Second-order SCF convergnece: Benzene. cbs-xtpl-alpha; Extrapolated water energies. cc17; Single point energies of multiple excited states with EOM-CCSD. fd-gradient; SCF STO-3G finite-difference tests. mbis-6; MBIS calculation on H2O. cc14; ROHF-CCSD/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. sapt-dft-lrc; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. dft-ghost; DFT Functional Test for Range-Seperated Hybrids and Ghost atoms. scf-hess1; RHF STO-3G (Cartesian) and cc-pVDZ (spherical) water Hessian test, against Psi3 reference values. cbs-delta-energy; Extrapolated energies with delta correction. frac-ip-fitting; Omega optimization for LRC functional wB97 on water. frac-sym; Fractional occupation with symmetry. cc23; ROHF-EOM-CCSD/DZ analytic gradient lowest \(^{2}B_1\) state of H2O+ (A1 excitation). cc32; CC3/cc-pVDZ H2O \(R_e\) geom from Olsen et al., JCP 104, 8007 (1996). cc25; Single point gradient of 1-2B2 state of H2O+ with EOM-CCSD. freq-isotope1; Vibrational and thermo analysis of several water isotopologs. Demonstrates Hessian reuse for different temperatures and pressures but not for different isotopologs. opt7; Various constrained energy minimizations of HOOH with cc-pvdz RHF. For “fixed” coordinates, the final value is provided by the user. sapt-ecp; sapt0 of charged system in ECP b",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html:32604,energy,energy,32604,psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"l and dMP2. dfmp2-4; conventional and density-fitting mp2 test of mp2 itself and setting scs-mp2. opt-freeze-coords; SCF/cc-pVDZ optimization example with frozen cartesian. cc44; Test case for some of the PSI4 out-of-core codes. The code is given only 2.0 MB of memory, which is insufficient to hold either the A1 or B2 blocks of an ovvv quantity in-core, but is sufficient to hold at least two copies of an oovv quantity in-core. opt2; SCF DZ allene geometry optimization, with Cartesian input, first in c2v symmetry, then in Cs symmetry from a starting point with a non-linear central bond angle. mbis-2; MBIS calculation on OH- (Expanded Arrays). phi-ao; Test computing values of basis functions (puream and non-puream) at points. dct6; DCT calculation for the triplet O2 using DC-06 and DC-12. Only two-step algorithm is tested. cc28; CCSD/cc-pVDZ optical rotation calculation (length gauge only) on Z-mat H2O2. dfep2-2; Compute three IP and 2 EA’s for the PH3 molecule. tu2-ch2-energy; Sample UHF/6-31G** CH2 computation. rasci-ne; Ne atom RASCI/cc-pVQZ Example of split-virtual CISD[TQ] from Sherrill and Schaefer, J. Phys. Chem. XXX This uses a “primary” virtual space 3s3p (RAS 2), a “secondary” virtual space 3d4s4p4d4f (RAS 3), and a “tertiary” virtual space consisting of the remaining virtuals. First, an initial CISD computation is run to get the natural orbitals; this allows a meaningful partitioning of the virtual orbitals into groups of different importance. Next, the RASCI is run. The split-virtual CISD[TQ] takes all singles and doubles, and all triples and quadruples with no more than 2 electrons in the secondary virtual subspace (RAS 3). If any electrons are present in the tertiary virtual subspace (RAS 4), then that excitation is only allowed if it is a single or double. mbis-1; MBIS calculation on H2O. x2c2; Test of SFX2C-1e on Water cc-pVDZ-DK. In this test the Dirac equation is solved in the uncontracted cc-pVDZ-DK basis. The reference numbers are from Lan Cheng’s ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html:2754,energy,energy,2754,psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"l and m compute a pure function offset.; #define INT_IPURE(l, m) ((l)+(m)). """"""; return l + m. # Lookup array that when you index the angular momentum it returns the corresponding letter; PrimitiveType = ['Normalized', 'Unnormalized']; GaussianType = ['Cartesian', 'Pure'] # Cartesian = 0, Pure = 1. [docs]class ShellInfo(object):; """"""This class has the same behavior as GaussianShell, but implements everything using; slower data structures, which are easier to construct. These are used to build the; basis set, which builds more efficient pointer-based GaussianShell objects.; @param e An array of exponent values.; @param am Angular momentum.; @param pure Pure spherical harmonics, or Cartesian.; @param c An array of contraction coefficients.; @param nc The atomic center that this shell is located on. Must map; back to the correct atom in the owning BasisSet molecule. Used; in integral derivatives for indexing.; @param center The x, y, z position of the shell. This is passed to; reduce the number of calls to the molecule.; @param start The starting index of the first function this shell; provides. Used to provide starting positions in matrices.; @param pt Is the shell already normalized?. """""". def __init__(self, am, c, e, pure, nc, center, start, pt='Normalized'):; # Angular momentum; self.l = am; # Flag for pure angular momentum (Cartesian = 0, Pure = 1); self.puream = pure; # Exponents (of length nprimitives_); self.PYexp = e; # Contraction coefficients (of length nprimitives_); self.PYcoef = c; # ERD normalized contraction coefficients (of length nprimitives_); self.PYerd_coef = []; # Original (un-normalized) contraction coefficients (of length nprimitives); self.PYoriginal_coef = [c[n] for n in range(len(c))]; # Atom number this shell goes to. Needed when indexing integral derivatives.; self.nc = nc; # Atomic center number in the Molecule; self.center = center; #; self.start = start; # How many cartesian functions? (1=s, 3=p, 6=d, ...); self.PYncartesian = INT_NCART(s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsgshell.html:3382,reduce,reduce,3382,psi4manual/1.0.0/_modules/qcdb/libmintsgshell.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsgshell.html,1,['reduce'],['reduce']
Energy Efficiency,"l as asyncronous I/O while forming the DF integrals and CPHF coefficients. fsapt-d; Tests SAPT0-D corrections, with a variety of damping functions/parameters. matrix1; An example of using BLAS and LAPACK calls directly from the Psi input file, demonstrating matrix multiplication, eigendecomposition, Cholesky decomposition and LU decomposition. These operations are performed on vectors and matrices provided from the Psi library. omp2-3; OMP2 cc-pVDZ energy for the NO radical. cc21; ROHF-EOM-CCSD/DZ analytic gradient lowest \(^{2}A_1\) excited state of H2O+ (B1 excitation). opt1-fd; SCF STO-3G geometry optimzation, with Z-matrix input, by finite-differences. casscf-semi; CASSCF/6-31G** energy point. Check energy with frozen core/virtual orbs. after semicanonicalization. opt12; SCF cc-pVDZ geometry optimzation of ketene, starting from bent structure. scf-coverage; Lithium test for coverage. cc27; Single point gradient of 1-1B2 state of H2O with EOM-CCSD. omp2p5-1; OMP2.5 cc-pVDZ energy for the H2O molecule. dft1-alt; DFT Functional Test. x2c-perturb-h; Test SFX2C-1e with a static electric field on He aug-cc-pVTZ. dfcasscf-fzc-sp; CASSCF/6-31G** energy point. nbody-intermediates; HF/cc-pVDZ many body energies of an arbitrary noble gas trimer complex Size vs cost tradeoff is rough here. fd-freq-gradient-large; SCF DZ finite difference frequencies by gradients for C4NH4. dft-jk; DFT JK on-disk test. dct1; DC-06, DC-12, ODC-06 and ODC-12 calculation for the He dimer. This performs a simultaneous update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the MO Basis. dft-b2plyp; Double-hybrid density functional B2PYLP. Reproduces portion of Table I in S. Grimme’s J. Chem. Phys 124 034108 (2006) paper defining the functional. cc38; RHF-CC2-LR/cc-pVDZ static polarizabilities of HOF molecule. oremp-grad2; integral conventional OO-REMP/cc-pVDZ engrad single points for the H2O molecule. single point energies were independently checked u",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html:8651,energy,energy,8651,psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"l bases.; Used by complete_basis_set(). scf_xtpl_helgaker_3(**largs)[source]¶; Extrapolation scheme for reference energies with three adjacent zeta-level bases.; Used by complete_basis_set(). corl_xtpl_helgaker_2(**largs)[source]¶; Extrapolation scheme for correlation energies with two adjacent zeta-level bases.; Used by complete_basis_set(). Aliases¶; When a particular composite method or its functional form is going to be; reused often, it is convenient to define an alias to it. A convenient; place for such Python code to reside is in psi4/lib/python/aliases.py; (source location) or psi4/share/psi/python/aliases.py (installed; location). No recompilation is necessary after defining an alias. Some; existing examples are below. sherrill_gold_standard(name='mp2', **kwargs)[source]¶; Function to call the quantum chemical method known as ‘Gold Standard’; in the Sherrill group. Uses complete_basis_set() to evaluate; the following expression. Two-point extrapolation of the correlation energy; performed according to corl_xtpl_helgaker_2(). >>> # [1] single-point energy by this composite method; >>> energy('sherrill_gold_standard'). >>> # [2] finite-difference geometry optimization; >>> optimize('sherrill_gold_standard'). >>> # [3] finite-difference geometry optimization, overwriting some pre-defined sherrill_gold_standard options; >>> optimize('sherrill_gold_standard', corl_basis='cc-pV[DT]Z', delta_basis='3-21g'). allen_focal_point(name='mp2', **kwargs)[source]¶; Function to call Wes Allen-style Focal; Point Analysis. JCP 127 014306. Uses; complete_basis_set() to evaluate the following; expression. SCF employs a three-point extrapolation according; to scf_xtpl_helgaker_3(). MP2, CCSD, and; CCSD(T) employ two-point extrapolation performed according to; corl_xtpl_helgaker_2(). CCSDT and CCSDT(Q); are plain deltas. This wrapper requires Kallay’s MRCC code. >>> # [1] single-point energy by this composite method; >>> energy('allen_focal_point'). >>> # [2] finite-difference ge",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/cbs-1.html:14903,energy,energy,14903,psi4manual/4.0b5/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/cbs-1.html,2,['energy'],['energy']
Energy Efficiency,"l conversion factors, LAB II.11; uconv_K = (constants.h * constants.na * 1.0e21) / (8 * np.pi * np.pi * constants.c); uconv_S = np.sqrt((constants.c * (2 * np.pi * constants.bohr2angstroms)**2) /; (constants.h * constants.na * 1.0e21)). # normco & reduced mass, LAB II.14 & II.15; wL = np.einsum('i,ij->ij', sqrtmmminv, qL); vibinfo['w'] = Datum('normal mode', 'a0', wL, comment='un-mass-weighted'). reduced_mass_u = np.divide(1.0, np.linalg.norm(wL, axis=0)**2); vibinfo['mu'] = Datum('reduced mass', 'u', reduced_mass_u). xL = np.sqrt(reduced_mass_u) * wL; vibinfo['x'] = Datum('normal mode', 'a0', xL, comment='normalized un-mass-weighted'). # IR intensities, CCQC Proj. Eqns. 15-16; uconv_kmmol = (constants.get(""Avogadro constant"") * np.pi * 1.e-3 * constants.get(""electron mass in u"") *; constants.get(""fine-structure constant"")**2 * constants.get(""atomic unit of length"") / 3); uconv_D2A2u = (constants.get('atomic unit of electric dipole mom.') * 1.e11 /; constants.get('hertz-inverse meter relationship') /; constants.get('atomic unit of length'))**2; if not (dipder is None or np.array(dipder).size == 0):; qDD = dipder.dot(wL); ir_intensity = np.zeros(qDD.shape[1]); for i in range(qDD.shape[1]):; ir_intensity[i] = qDD[:, i].dot(qDD[:, i]); # working but not needed; #vibinfo['IR_intensity'] = Datum('infrared intensity', 'Eh a0/u', ir_intensity); #ir_intensity_D2A2u = ir_intensity * uconv_D2A2u; #vibinfo['IR_intensity'] = Datum('infrared intensity', '(D/AA)^2/u', ir_intens_D2A2u); ir_intensity_kmmol = ir_intensity * uconv_kmmol; vibinfo['IR_intensity'] = Datum('infrared intensity', 'km/mol', ir_intensity_kmmol). # force constants, LAB II.16 (real compensates for earlier sqrt); uconv_mdyne_a = (0.1 * (2 * np.pi * constants.c)**2) / constants.na; force_constant_mdyne_a = reduced_mass_u * (frequency_cm_1 * frequency_cm_1).real * uconv_mdyne_a; vibinfo['k'] = Datum('force constant', 'mDyne/A', force_constant_mdyne_a). force_constant_cm_1_bb = reduced_mass_u * (frequency_cm_1 * fr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/qcdb/vib.html:22072,meter,meter,22072,psi4manual/1.9.x/_modules/qcdb/vib.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/qcdb/vib.html,8,['meter'],['meter']
Energy Efficiency,"l data. del_array_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) Matrix QC variable. Prefer del_variable(). del_potential_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) ExternalPotential QC variable. (This function is provisional and might be removed in the future.). del_scalar_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) double QC variable. Prefer del_variable(). del_variable(key)¶; Removes scalar or array QCVariable key from self if present. Parameters:. self (Wavefunction) – Wavefunction instance.; key (str) – Case-insensitive key to instance’s double or; Matrix storage maps. Return type:; None. doccpi(self: psi4.core.Wavefunction, assume_socc_alpha: bool = True) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. efzc(self: psi4.core.Wavefunction) → float¶; Returns the frozen-core energy. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunction’s energy. epsilon_a(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, basis: str, subset: str) → psi4.core.Vector¶; Returns the requested Alpha orbital energies subset. Parameters:. basis – {‘AO’, ‘SO’, ‘MO’}; MO or SO select for Pitzer-ordering the return vector in the full computational point group symmetry.; AO selects for Pitzer-ordering the return vector without point group symmetry.; subset – {‘ALL’, ‘ACTIVE’, ‘FROZEN’, ‘OCC’, ‘VIR’, ‘FROZEN_OCC’, ‘ACTIVE_OCC’, ‘ACTIVE_VIR’, ‘FROZEN_VIR’}; Which subspace of orbital energies should be returned?. Returns:; A Pitzer-ordered vector of the orbitals. Return type:; Vector. epsilon_b(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, basis: str, subset: str) → psi4.core.Vector¶; Returns the requested Beta orbital energies ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/api/psi4.core.Wavefunction.html:14164,energy,energy,14164,psi4manual/master/api/psi4.core.Wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.Wavefunction.html,2,['energy'],['energy']
Energy Efficiency,"l details. sapt5; SAPT0 aug-cc-pVTZ computation of the charge transfer energy of the water dimer. omp2p5-grad2; OMP2.5 cc-pVDZ gradient for the NO radical. cc9; UHF-CCSD(T) cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Z-matrix input. mcscf1; ROHF 6-31G** energy of the \(^{3}B_1\) state of CH2, with Z-matrix input. The occupations are specified explicitly. dfcasscf-fzc-sp; CASSCF/6-31G** energy point. mp2p5-grad2; MP2.5 cc-pVDZ gradient for the NO radical. pywrap-basis; SAPT calculation on bimolecular complex where monomers are unspecified so driver auto-fragments it. Basis set and auxiliary basis sets are assigned by atom type. cepa1; cc-pvdz H2O Test CEPA(1) Energy. dft-psivar; HF and DFT variants single-points on zmat methane, mostly to test that PSI variables are set and computed correctly. Now also testing that CSX harvesting PSI variables correctly update ref_dft_2e/xc due to new BraggSlater radii. ghosts; Density fitted MP2 cc-PVDZ/cc-pVDZ-RI computation of formic acid dimer binding energy using explicit specification of ghost atoms. This is equivalent to the dfmp2_1 sample but uses both (equivalent) specifications of ghost atoms in a manual counterpoise correction. nbody-hessian; Computation of VMFC-corrected HF dimer Hessian. castup3; SCF with various combinations of pk/density-fitting, castup/no-castup, and spherical/cartesian settings. Demonstrates that puream setting is getting set by orbital basis for all df/castup parts of calc. Demonstrates that answer doesn’t depend on presence/absence of castup. Demonstrates (by comparison to castup2) that output file doesn’t depend on options (scf_type) being set global or local. This input uses local. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Appendices; Test Suite and Sample Inputs; <no title>. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html:48073,energy,energy,48073,psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,1,['energy'],['energy']
Energy Efficiency,"l domains for local-CC calculations. See J. Broughton and P. Pulay, J. Comp. Chem. 14, 736-740 (1993) and C. Hampel and H.-J. Werner, J. Chem. Phys. 104, 6286-6297 (1996). Type: double; Default: 0.01. LOCAL_DO_SINGLES (CCEOM)¶CCEOM —. Type: boolean; Default: true. LOCAL_FILTER_SINGLES (CCEOM)¶CCEOM — Do apply local filtering to singles amplitudes?. Type: boolean; Default: true. LOCAL_FILTER_SINGLES (CCLAMBDA)¶CCLAMBDA — Do apply local filtering to single de-excitation (\(\lambda 1\) amplitudes?. Type: boolean; Default: true. LOCAL_FILTER_SINGLES (CCRESPONSE)¶CCRESPONSE — Do apply local filtering to single excitation amplitudes?. Type: boolean; Default: false. LOCAL_GHOST (CCEOM)¶CCEOM — Permit ghost atoms to hold projected atomic orbitals to include in the virtual space in local-EOM-CCSD calculations. Type: integer; Default: -1. LOCAL_IBO_CONDITION (FISAPT)¶FISAPT (Expert) — Condition number to use in IBO metric inversions. Type: double; Default: 1.0e-7. LOCAL_IBO_POWER (FISAPT)¶FISAPT — IBO localization metric power. Type: integer; Default: 4. LOCAL_IBO_STARS (FISAPT)¶FISAPT — IBO Centers for Pi Degeneracy. Type: array; Default: No Default. LOCAL_IBO_STARS_COMPLETENESS (FISAPT)¶FISAPT — IBO Charge metric for classification as Pi. Type: double; Default: 0.90. LOCAL_IBO_USE_STARS (FISAPT)¶FISAPT — IBO Stars procedure. Type: boolean; Default: false. LOCAL_MAXITER (DLPNO)¶DLPNO — Maximum iterations in Foster-Boys localization. Type: integer; Default: 1000. LOCAL_MAXITER (FISAPT)¶FISAPT — Maximum iterations in localization. Type: integer; Default: 1000. LOCAL_MAXITER (SCF)¶SCF — The maxiter on the orbital localization procedure. Type: integer; Default: 200. LOCAL_METHOD (CCENERGY)¶CCENERGY — Type of local-CCSD scheme to be simulated. WERNER selects the method developed by H.-J. Werner and co-workers, and AOBASIS selects the method developed by G.E. Scuseria and co-workers (currently inoperative). Type: string; Possible Values: WERNER, AOBASIS; Default: WERNER. LOCAL_METH",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodoc_glossary_options_c-1.html:155543,power,power,155543,psi4manual/1.5.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodoc_glossary_options_c-1.html,2,['power'],['power']
Energy Efficiency,"l domains for local-CC calculations. See J. Broughton and P. Pulay, J. Comp. Chem. 14, 736-740 (1993) and C. Hampel and H.-J. Werner, J. Chem. Phys. 104, 6286-6297 (1996). Type: double; Default: 0.01. LOCAL_DO_SINGLES (CCEOM)¶CCEOM —. Type: boolean; Default: true. LOCAL_FILTER_SINGLES (CCEOM)¶CCEOM — Do apply local filtering to singles amplitudes?. Type: boolean; Default: true. LOCAL_FILTER_SINGLES (CCLAMBDA)¶CCLAMBDA — Do apply local filtering to single de-excitation (\(\lambda 1\) amplitudes?. Type: boolean; Default: true. LOCAL_FILTER_SINGLES (CCRESPONSE)¶CCRESPONSE — Do apply local filtering to single excitation amplitudes?. Type: boolean; Default: false. LOCAL_GHOST (CCEOM)¶CCEOM — Permit ghost atoms to hold projected atomic orbitals to include in the virtual space in local-EOM-CCSD calculations. Type: integer; Default: -1. LOCAL_IBO_CONDITION (FISAPT)¶FISAPT (Expert) — Condition number to use in IBO metric inversions. Type: double; Default: 1.0e-7. LOCAL_IBO_POWER (FISAPT)¶FISAPT — IBO localization metric power. Type: integer; Default: 4. LOCAL_IBO_STARS (FISAPT)¶FISAPT — IBO Centers for Pi Degeneracy. Type: array; Default: No Default. LOCAL_IBO_STARS_COMPLETENESS (FISAPT)¶FISAPT — IBO Charge metric for classification as Pi. Type: double; Default: 0.90. LOCAL_IBO_USE_STARS (FISAPT)¶FISAPT — IBO Stars procedure. Type: boolean; Default: false. LOCAL_MAXITER (FISAPT)¶FISAPT — Maximum iterations in localization. Type: integer; Default: 1000. LOCAL_MAXITER (SCF)¶SCF — The maxiter on the orbital localization procedure. Type: integer; Default: 200. LOCAL_METHOD (CCENERGY)¶CCENERGY — Type of local-CCSD scheme to be simulated. WERNER selects the method developed by H.-J. Werner and co-workers, and AOBASIS selects the method developed by G.E. Scuseria and co-workers (currently inoperative). Type: string; Possible Values: WERNER, AOBASIS; Default: WERNER. LOCAL_METHOD (CCEOM)¶CCEOM — Type of local-CCSD scheme to be simulated. WERNER selects the method developed by H.-J. W",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html:154648,power,power,154648,psi4manual/1.4.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html,2,['power'],['power']
Energy Efficiency,"l function to boost fitting basis size for all calculations. - No way to extrapolate def2 family basis sets. - Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in several; sequential stages (scf, corl, delta, delta2, delta3, delta4, delta5) covering treatment; of the reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction, etc.. Each is activated by its; stage_wfn keyword and is only allowed if all preceding stages are active. .. include:: cbs_eqn.rst. * Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy. The cbs() function requires, at a minimum, ``name='scf'`` and ``scf_basis``; keywords to be specified for reference-step only jobs and ``name`` and; ``corl_basis`` keywords for correlated jobs. The following energy methods have been set up for cbs(). .. hlist::; :columns: 5. * scf; * mp2; * mp2.5; * mp3; * mp4(sdq); * mp4; * mp\ *n*; * omp2; * omp2.5; * omp3; * olccd; * lccd; * lccsd; * cepa(0); * cepa(1); * cepa(3); * acpf; * aqcc; * qcisd; * cc2; * ccsd; * fno-ccsd; * bccd; * cc3; * qcisd(t); * ccsd(t); * fno-ccsd(t); * bccd(t); * cisd; * cisdt; * cisdtq; * ci\ *n*; * fci; * mrccsd; * mrccsd(t); * mrccsdt; * mrccsdt(q). :type name: string; :param name: ``'scf'`` || ``'ccsd'`` || etc. First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be ``'scf'``. Overruled if stage_wfn keywords supplied. :type scf_wfn: string; :param scf_wfn: |dl| ``'scf'`` |dr| || ``'c4-scf'`` || etc. Indicates the energy method for which the reference energy is to be; obtained. Generally unnecessary, as 'scf' is *the* scf in |PSIfour| but; can be used to direct lone scf components to run in |PSIfour| or Cfour; in a mixe",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:19394,energy,energy,19394,psi4manual/1.0.0/_modules/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html,1,['energy'],['energy']
Energy Efficiency,"l function to boost fitting basis size for all calculations. - No way to extrapolate def2 family basis sets. - Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in several; sequential stages (scf, corl, delta, delta2, delta3, delta4, delta5) covering treatment; of the reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction, etc.. Each is activated by its; stage_wfn keyword and is only allowed if all preceding stages are active. .. include:: cbs_eqn.rst. * Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy. The cbs() function requires, at a minimum, ``name='scf'`` and ``scf_basis``; keywords to be specified for reference-step only jobs and ``name`` and; ``corl_basis`` keywords for correlated jobs. The following energy methods have been set up for cbs(). .. hlist::; :columns: 5. * scf; * mp2; * mp2.5; * mp3; * mp4(sdq); * mp4; * omp2; * omp3; * ocepa; * cepa0; * cepa(0); * cepa(1); * cepa(3); * acpf; * aqcc; * qcisd; * cc2; * ccsd; * fno-df-ccsd; * bccd; * cc3; * qcisd(t); * ccsd(t); * fno-df-ccsd(t); * bccd(t); * cisd; * cisdt; * cisdtq; * ci\ *n*; * fci; * mrccsd; * mrccsd(t); * mrccsdt; * mrccsdt(q). :type name: string; :param name: ``'scf'`` || ``'ccsd'`` || etc. First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be ``'scf'``. Overruled if stage_wfn keywords supplied. :type corl_wfn: string; :param corl_wfn: ``'mp2'`` || ``'ccsd(t)'`` || etc. Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with ``name`` or as the unlabeled; first argument to the function. :type delta_wfn: string; :param delta_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:54822,energy,energy,54822,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,2,['energy'],['energy']
Energy Efficiency,"l group, and; define the orientation in terms of the existing glycine Cartesian coordinates; which is much easier to visualize than the corresponding Cartesian-only; approach. Multiple Molecules¶; To facilitate more elaborate computations, it is possible to provide a name for; each molecule, and tell PSI4 which one should be used in a given; calculation. For example, consider the following input file:; molecule h2{; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; energy('scf'). molecule h{; H; }. set basis cc-pvdz; set reference uhf; energy('scf'). Here, two separate jobs are performed on two different molecules; the first is; performed on H2, while the second is for H atom. The last molecule to be; specified is the “active” molecule by default. To explicitly activate a named; molecule, the activate keyword is provided. Using this keyword, the above input; file can be equivalently written as follows:; molecule h2{; H; H 1 0.9; }. molecule h{; H; }. activate(h2); set basis cc-pvdz; set reference rhf; energy('scf'). activate(h); set basis cc-pvdz; set reference uhf; energy('scf'). Note that whenever the molecule is changed, the basis set must be specified; again. The following section provides more details about the job control; keywords used in the above examples. Molecule Keywords¶; In addition to specifying the geometry, additional information can be; provided in the molecule optional_molecule_name {...} block.; If two integers charge multiplicity are encountered on any; line of the molecule block, they are interpreted as the molecular charge; and multiplicity (), respectively. The symmetry; can be specified by a line reading symmetry symbol, where; symbol is the Schönflies symbol of the; (Abelian) point group to use for the computation. This need not be; specified, as the molecular symmetry is automatically detected by; PSI4. Certain computations require that the molecule is not; reoriented; this can be achieved by adding either no_reorient or; noreorient. By ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:7219,energy,energy,7219,psi4manual/4.0b4/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html,4,['energy'],['energy']
Energy Efficiency,"l indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CC_MAXITER¶. Maximum number of iterations to determine the amplitudes. Type: integer; Default: 50. CUTOFF¶. Cutoff value for numerical procedures. Type: integer; Default: 14. DIIS_MAX_VECS¶. Number of vectors used in DIIS. Type: integer; Default: 4. DO_LEVEL_SHIFT¶. Do apply level shifting?. Type: boolean; Default: false. DO_SCS¶. Do perform spin-component-scaled OMP2 (SCS-OMP2)? In all computation, SCS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SCS-OMP2, one needs to set ‘DO_SCS’ to true. Type: boolean; Default: false. DO_SOS¶. Do perform spin-opposite-scaled OMP2 (SOS-OMP2)? In all computation, SOS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SOS-OMP2, one needs to set ‘DO_SOS’ to true. Type: boolean; Default: false. E_CONVERGENCE¶. Convergence criterion for energy. Type: conv double; Default: 1e-8. HESS_TYPE¶. Type Hessian matrix will be used in orbital optimization procedure. Type: string; Possible Values: NONE; Default: NONE. LEVEL_SHIFT¶. Level shift to aid convergence. Type: double; Default: 0.02. LINEQ_SOLVER¶. The solver will be used for simultaneous linear equations. Type: string; Possible Values: CDGESV, FLIN, POPLE; Default: CDGESV. MAX_MOGRAD_CONVERGENCE¶. Convergence criterion for maximum orbital gradient. Type: conv double; Default: 1e-4. MO_MAXITER¶. Maximum number of iterations to determine the orbitals. Type: integer; Default: 50. MO_READ¶. Do read coefficient matrices from external files of a previous OMP2 or OMP3 computation?. Type: boolean; Default: false. MO_STEP_MAX¶. Maximum step size in orbital-optimization procedure. Type: double; Default: 0.5. MO_WRITE¶. Do write coefficient matrices to external files for direct reading MOs in a subsequent job?. Type: boolean; Default: false. MP2_OS_SCALE¶. MP2 opposite-s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodir_options_c/module__omp2-1.html:1648,energy,energy,1648,psi4manual/4.0b3/autodir_options_c/module__omp2-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/module__omp2-1.html,4,['energy'],['energy']
Energy Efficiency,"l occupancy of the reference function in terms of the occupation numbers of the orbitals and their irreducible representations. The occupancy is specified by either NIRREP or 2*NIRREP integers specifying the number of occupied orbitals of each symmetry type, where NIRREP is the number of irreducible representations in the computational point group. If there are no orbitals of a particular symmetry type a zero must be entered. If the reference function is for an open-shell system, two strings of NIRREP occupation numbers separated by a slash are input for the \(\alpha\) and \(\beta\) sets of orbitals. An example of the use of the OCCUPATION keyword for the water molecule would be OCCUPATION=3-1-1-0. For the \(^2A_1\) water cation, an open-shell system, the keyword would be specified by OCCUPATION=3-1-1-0/2-1-1-0. It should be noted that the xvmol integral program orders the irreducible representations in a strange way, which most users do not perceive to be a logical order. Hence, it is usually advisable initially to run just a single point integral and HF-SCF calculation in order to determine the number and ordering of the irreducible representations. The occupation keyword may be omitted, in which case an initial orbital occupancy is determined by diagonalization of the core Hamiltonian. In many cases, HF-SCF calculations run with the core Hamiltonian guess will usually converge to the lowest energy HF-SCF solution, but this should not be blindly assumed. (Default: The occupation is given by the core Hamiltonian initial guess). Psi4 Interface: The arrays above are specified in PSI as (white space tolerant) [3,1,1,0] and [[3,1,1,0],[3,0,1,0]]. Type: array; Default: No Default. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; CFOUR; CFOUR_OCCUPATION. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodir_options_c/cfour__cfour_occupation.html:1611,energy,energy,1611,psi4manual/master/autodir_options_c/cfour__cfour_occupation.html,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/cfour__cfour_occupation.html,2,['energy'],['energy']
Energy Efficiency,"l of the above parameters are available, with only the ```wfn``` and ```basis``` keywords required. Other supported parameters are:. * ```wfn_lo```: the lower method from which the delta correction is to be calculated. By default, it is set to ```wfn``` from the previous field in the ```cbs_metadata``` array.; * ```basis_lo```: basis set to be used for the delta correction. By default, it is the same as the ```basis``` specified above. * Others. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> energy(cbs, scf_wfn='scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> energy(cbs, corl_wfn='mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> energy(cbs, scf_wfn='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> energy(cbs, corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> energy(cbs, corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> energy(cbs, corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> energy(cbs, corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z',",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:45712,energy,energy,45712,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,8,['energy'],['energy']
Energy Efficiency,"l of theory. cisd-h2o+-2; 6-31G** H2O+ Test CISD Energy Point. cc10; ROHF-CCSD cc-pVDZ energy for the \(^2\Sigma^+\) state of the CN radical. tdscf-2; td-uhf test on triplet states of methylene (tda), wfn passing. dft-pruning; Tests all grid pruning options available and screening of small weights. Check against grid size. dfccd1; DF-CCD cc-pVDZ energy for the H2O molecule. cc15; RHF-B-CCD(T)/6-31G** H2O single-point energy (fzc, MO-basis \(\langle ab|cd \rangle\)). omp2p5-grad2; OMP2.5 cc-pVDZ gradient for the NO radical. sapt5; SAPT0 aug-cc-pVTZ computation of the charge transfer energy of the water dimer. dfccsdt1; DF-CCSD(T) cc-pVDZ energy for the H2O molecule. pywrap-checkrun-uhf; This checks that all energy methods can run with a minimal input and set symmetry. scf2; RI-SCF cc-pVTZ energy of water, with Z-matrix input and cc-pVTZ-RI auxilliary basis. mcscf3; RHF 6-31G** energy of water, using the MCSCF module and Z-matrix input. pywrap-checkrun-rohf; This checks that all energy methods can run with a minimal input and set symmetry. cc41; RHF-CC2-LR/cc-pVDZ optical rotation of H2O2. gauge = both, omega = (589 355 nm). pywrap-db1; Database calculation, so no molecule section in input file. Portions of the full databases, restricted by subset keyword, are computed by sapt0 and dfmp2 methods. cisd-sp-2; 6-31G** H2O Test CISD Energy Point. olccd3; OLCCD cc-pVDZ energy with ROHF initial guess for the NO radical. cc19; CCSD/cc-pVDZ dipole polarizability at two frequencies. cc4; RHF-CCSD(T) cc-pVQZ frozen-core energy of the BH molecule, with Cartesian input. After the computation, the checkpoint file is renamed, using the PSIO handler. casscf-sp; CASSCF/6-31G** energy point. dfccsd-grad2; DF-CCSD cc-pVDZ gradient for the NH molecule. opt15; 6-31G(d) optimization of SF4 starting from linear bond angle that is not linear in the optimized structure but is in a symmetry plane of the molecule. sapt-dft1; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. cbs-",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html:5526,energy,energy,5526,psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"l orbitals for CCSD(T), QCISD(T), CEPA, and MP4. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Theoretical Methods: SCF to FCI; FNOCC: Frozen natural orbitals for CCSD(T), QCISD(T), CEPA, and MP4. FNOCC: Frozen natural orbitals for CCSD(T), QCISD(T), CEPA, and MP4¶; Code author: A. Eugene DePrince; Section author: A. Eugene DePrince; Module: Keywords, PSI Variables, FNOCC. Warning; There is a known bug concerning the i7-5930 series combined; with the Intel 15 compilers and MKL 11.2.3. When PSI4 is compiled; under these conditions, parallel runs of the FNOCC code have experienced; nonsensical CCSD correlation energies (often several Hartrees lower; than the starting guess). At the moment, the only confirmed solutions; are running serially, using a different BLAS implementation, or upgrading; to Intel 16.0.2 and MKL 11.3.2. Frozen natural orbitals (FNO)¶; The computational cost of the CCSD [Purvis:1982], CCSD(T); [Raghavachari:1989], and related methods be reduced by constructing a; compact representation of the virtual space based on the natural orbitals; of second-order perturbation theory [Sosa:1989:148]. The most demanding; steps in the CCSD and (T) algorithms scale as \({\cal{O}}(o^2v^4)\); and \({\cal{O}}(o^3v^4)\), where \(o\) and \(v\) represent the; number of oribitals that are occupied and unoccupied (virtual) in the; reference function, respectively. By reducing the the size of the virtual; space, the cost of evaluating these terms reduces by a factor of \((v; / v_{FNO})^4\), where \(v_{FNO}\) represents the number of virtual; orbitals retained after the FNO truncation.; The general outline for the FNO procedure in PSI4 is:. construct the virtual-virtual block of the unrelaxed MP2 one-particle density matrix (OPDM); diagonalize this block of the OPDM to obtain a set of natural virtual orbitals; based on some occupancy threshold, determine which orbitals are unimportant and may be discarded; project the virtual-virtual block of the Fock",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/fnocc-1.html:1014,reduce,reduced,1014,psi4manual/1.4.0/fnocc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/fnocc-1.html,2,['reduce'],['reduced']
Energy Efficiency,"l orbitals for CCSD(T), QCISD(T), CEPA, and MP4. Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Theoretical Methods: SCF to FCI; FNOCC: Frozen natural orbitals for CCSD(T), QCISD(T), CEPA, and MP4. FNOCC: Frozen natural orbitals for CCSD(T), QCISD(T), CEPA, and MP4¶; Code author: A. Eugene DePrince; Section author: A. Eugene DePrince; Module: Keywords, PSI Variables, FNOCC. Warning; There is a known bug concerning the i7-5930 series combined; with the Intel 15 compilers and MKL 11.2.3. When PSI4 is compiled; under these conditions, parallel runs of the FNOCC code have experienced; nonsensical CCSD correlation energies (often several Hartrees lower; than the starting guess). At the moment, the only confirmed solutions; are running serially, using a different BLAS implementation, or upgrading; to Intel 16.0.2 and MKL 11.3.2. Frozen natural orbitals (FNO)¶; The computational cost of the CCSD [Purvis:1982], CCSD(T); [Raghavachari:1989], and related methods be reduced by constructing a; compact representation of the virtual space based on the natural orbitals; of second-order perturbation theory [Sosa:1989:148]. The most demanding; steps in the CCSD and (T) algorithms scale as \({\cal{O}}(o^2v^4)\); and \({\cal{O}}(o^3v^4)\), where \(o\) and \(v\) represent the; number of oribitals that are occupied and unoccupied (virtual) in the; reference function, respectively. By reducing the the size of the virtual; space, the cost of evaluating these terms reduces by a factor of \((v; / v_{FNO})^4\), where \(v_{FNO}\) represents the number of virtual; orbitals retained after the FNO truncation.; The general outline for the FNO procedure in PSI4 is:. construct the virtual-virtual block of the unrelaxed MP2 one-particle density matrix (OPDM); diagonalize this block of the OPDM to obtain a set of natural virtual orbitals; based on some occupancy threshold, determine which orbitals are unimportant and may be discarded; project the virtual-virtual block of the Fock",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/fnocc-1.html:1014,reduce,reduced,1014,psi4manual/1.5.0/fnocc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/fnocc-1.html,2,['reduce'],['reduced']
Energy Efficiency,"l orbitals for CCSD(T), QCISD(T), CEPA, and MP4. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Theoretical Methods: SCF to FCI; FNOCC: Frozen natural orbitals for CCSD(T), QCISD(T), CEPA, and MP4. FNOCC: Frozen natural orbitals for CCSD(T), QCISD(T), CEPA, and MP4¶; Code author: A. Eugene DePrince; Section author: A. Eugene DePrince; Module: Keywords, PSI Variables, FNOCC. Warning; There is a known bug concerning the i7-5930 series combined; with the Intel 15 compilers and MKL 11.2.3. When PSI4 is compiled; under these conditions, parallel runs of the FNOCC code have experienced; nonsensical CCSD correlation energies (often several Hartrees lower; than the starting guess). At the moment, the only confirmed solutions; are running serially, using a different BLAS implementation, or upgrading; to Intel 16.0.2 and MKL 11.3.2. Frozen natural orbitals (FNO)¶; The computational cost of the CCSD [Purvis:1982], CCSD(T); [Raghavachari:1989], and related methods be reduced by constructing a; compact representation of the virtual space based on the natural orbitals; of second-order perturbation theory [Sosa:1989:148]. The most demanding; steps in the CCSD and (T) algorithms scale as \({\cal{O}}(o^2v^4)\); and \({\cal{O}}(o^3v^4)\), where \(o\) and \(v\) represent the; number of oribitals that are occupied and unoccupied (virtual) in the; reference function, respectively. By reducing the the size of the virtual; space, the cost of evaluating these terms reduces by a factor of \((v; / v_{FNO})^4\), where \(v_{FNO}\) represents the number of virtual; orbitals retained after the FNO truncation.; The general outline for the FNO procedure in PSI4 is:. construct the virtual-virtual block of the unrelaxed MP2 one-particle density matrix (OPDM); diagonalize this block of the OPDM to obtain a set of natural virtual orbitals; based on some occupancy threshold, determine which orbitals are unimportant and may be discarded; project the virtual-virtual block of the Fock",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/fnocc.html:1014,reduce,reduced,1014,psi4manual/1.6.x/fnocc.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/fnocc.html,1,['reduce'],['reduced']
Energy Efficiency,"l orbitals for CCSD(T), QCISD(T), CEPA, and MP4. Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Theoretical Methods: SCF to FCI; FNOCC: Frozen natural orbitals for CCSD(T), QCISD(T), CEPA, and MP4. FNOCC: Frozen natural orbitals for CCSD(T), QCISD(T), CEPA, and MP4¶; Code author: A. Eugene DePrince; Section author: A. Eugene DePrince; Module: Keywords, PSI Variables, FNOCC. Warning; There is a known bug concerning the i7-5930 series combined; with the Intel 15 compilers and MKL 11.2.3. When PSI4 is compiled; under these conditions, parallel runs of the FNOCC code have experienced; nonsensical CCSD correlation energies (often several Hartrees lower; than the starting guess). At the moment, the only confirmed solutions; are running serially, using a different BLAS implementation, or upgrading; to Intel 16.0.2 and MKL 11.3.2. Frozen natural orbitals (FNO)¶; The computational cost of the CCSD [Purvis:1982], CCSD(T); [Raghavachari:1989], and related methods be reduced by constructing a; compact representation of the virtual space based on the natural orbitals; of second-order perturbation theory [Sosa:1989:148]. The most demanding; steps in the CCSD and (T) algorithms scale as \({\cal{O}}(o^2v^4)\); and \({\cal{O}}(o^3v^4)\), where \(o\) and \(v\) represent the; number of oribitals that are occupied and unoccupied (virtual) in the; reference function, respectively. By reducing the the size of the virtual; space, the cost of evaluating these terms reduces by a factor of \((v; / v_{FNO})^4\), where \(v_{FNO}\) represents the number of virtual; orbitals retained after the FNO truncation.; The general outline for the FNO procedure in PSI4 is:. construct the virtual-virtual block of the unrelaxed MP2 one-particle density matrix (OPDM); diagonalize this block of the OPDM to obtain a set of natural virtual orbitals; based on some occupancy threshold, determine which orbitals are unimportant and may be discarded; project the virtual-virtual block of the Fock",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/fnocc.html:1014,reduce,reduced,1014,psi4manual/1.7.x/fnocc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/fnocc.html,1,['reduce'],['reduced']
Energy Efficiency,"l orbitals; this allows a meaningful partitioning of the virtual orbitals into groups of different importance. Next, the RASCI is run. The split-virtual CISD[TQ] takes all singles and doubles, and all triples and quadruples with no more than 2 electrons in the secondary virtual subspace (RAS 3). If any electrons are present in the tertiary virtual subspace (RAS 4), then that excitation is only allowed if it is a single or double. cc5a; RHF CCSD(T) STO-3G frozen-core energy of C4NH4 Anion. pywrap_cbs1; Various basis set extrapolation tests. mcscf3; RHF 6-31G** energy of water, using the MCSCF module and Z-matrix input. frac; Carbon/UHF Fractionally-Occupied SCF Test Case. psimrcc-sp1; Mk-MRCCSD single point. O2 state described using the Ms = 0 component of the triplet. Uses ROHF triplet orbitals. fd-freq-gradient; STO-3G frequencies for H2O by finite-differences of gradients. cc13; UHF-CCSD/cc-pVDZ CH2 geometry optimization via analytic gradients. cc34; RHF-CCSD/cc-pVDZ energy of H2O partitioned into pair energy contributions. cisd-opt-fd; H2O CISD/6-31G** Optimize Geometry by Energies. mrcc1; CCSDT cc-pVDZ energy for the H2O molecule using MRCC. cc49; EOM-CC3(UHF) on CH radical with user-specified basis and properties for particular root. cc41; RHF-CC2-LR/cc-pVDZ optical rotation of H2O2. gauge = both, omega = (589 355 nm). sapt1; SAPT0 cc-pVDZ computation of the ethene-ethyne interaction energy, using the cc-pVDZ-JKFIT RI basis for SCF and cc-pVDZ-RI for SAPT. Monomer geometries are specified using Cartesian coordinates. cc39; RHF-CC2-LR/cc-pVDZ dynamic polarizabilities of HOF molecule. cisd-h2o+-2; 6-31G** H2O+ Test CISD Energy Point. mints2; A test of the basis specification. A benzene atom is defined using a ZMatrix containing dummy atoms and various basis sets are assigned to different atoms. The symmetry of the molecule is automatically lowered to account for the different basis sets. pywrap_db1; Database calculation, so no molecule section in input file. Porti",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodoc_testsuite-1.html:4324,energy,energy,4324,psi4manual/4.0b2/autodoc_testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodoc_testsuite-1.html,8,['energy'],['energy']
Energy Efficiency,"l other; options. Below are some rough words of advice about using the SCF code for; practical calculations:. For GUESS, the SAD guess is usually your; friend, even for open-shell systems (at the very least, it gets the right; number of electrons, unlike some other programs). For instance, we have found; that a simple SAD guess is often as good as doing a full SCF in a 3-21G basis; and then performing a cast-up, at a fraction of the cost. However, SAD and; DOCC/SOCC arrays do not play very well together at the moment.; For wall time, DF may be a factor of ten or more faster than the exact; integral technologies available in PSI4.; Use DF unless you need absolute accuracy or do not; have a -JKFIT auxiliary set for your orbital basis/atom type. Then use; DIRECT.; Don’t mess with the DIIS convergence options unless convergence is a problem.; We have optimized the parameters for efficiency over a wide array of system; types.; Buy a developer a beer!. The “best-practice” input file for HF is:; memory 1 GB # As much as you've got, the DF algorithm can use. molecule {; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; basis cc-pvdz; scf_type df; guess sad; ints_tolerance 1.0E-10 # Even this is epically tight, 1.0E-8 is OK; }. energy('scf'). table of contents. HF: Hartree–Fock Theory; Introduction; Theory; Minimal Input; Spin/Symmetry Treatment; Broken Symmetry; Orthogonalization; Initial Guess; Restarting the SCF; Convergence Stabilization; ERI Algorithms; Integral-Direct Density-Fitted Coulomb Construction; COSX Exchange; Linear Exchange; Second-order Convergence; Stability Analysis; Effective core potentials (ECPs); External potentials and QM/MM; Convergence and Algorithm Defaults; Recommendations. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Theoretical Methods: SCF to FCI; HF: Hartree–Fock Theory. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/scf.html:54410,energy,energy,54410,psi4manual/1.8.x/scf.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/scf.html,1,['energy'],['energy']
Energy Efficiency,"l other; options. Below are some rough words of advice about using the SCF code for; practical calculations:. For GUESS, the SAD guess is usually your; friend, even for open-shell systems (at the very least, it gets the right; number of electrons, unlike some other programs). For instance, we have found; that a simple SAD guess is often as good as doing a full SCF in a 3-21G basis; and then performing a cast-up, at a fraction of the cost. However, SAD and; DOCC/SOCC arrays do not play very well together at the moment.; For wall time, DF may be a factor of ten or more faster than the exact; integral technologies available in PSI4.; Use DF unless you need absolute accuracy or do not; have a -JKFIT auxiliary set for your orbital basis/atom type. Then use; DIRECT.; Don’t mess with the DIIS convergence options unless convergence is a problem.; We have optimized the parameters for efficiency over a wide array of system; types.; Buy a developer a beer!. The “best-practice” input file for HF is:; memory 1 GB # As much as you've got, the DF algorithm can use. molecule {; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; basis cc-pvdz; scf_type df; guess sad; ints_tolerance 1.0E-10 # Even this is epically tight, 1.0E-8 is OK; }. energy('scf'). table of contents. HF: Hartree–Fock Theory; Introduction; Theory; Minimal Input; Spin/Symmetry Treatment; Broken Symmetry; Orthogonalization; Initial Guess; Restarting the SCF; Convergence Stabilization; ERI Algorithms; Integral-Direct Density-Fitted Coulomb Construction; COSX Exchange; Linear Exchange; Second-order Convergence; Stability Analysis; Effective core potentials (ECPs); External potentials and QM/MM; Convergence and Algorithm Defaults; Recommendations. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Theoretical Methods: SCF to FCI; HF: Hartree–Fock Theory. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/scf.html:55428,energy,energy,55428,psi4manual/1.9.x/scf.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/scf.html,1,['energy'],['energy']
Energy Efficiency,"l pair domains, default is BP, Boughton-Pulay. Type: string; Possible Values: BP, RESPONSE; Default: BP. LOCAL_PAIRDEF (CCLAMBDA); CCLAMBDA — Definition of local pair domains. Type: string; Default: No Default. LOCAL_PAIRDEF (CCRESPONSE); CCRESPONSE — Definition of local pair domains. Type: string; Default: NONE. LOCAL_PAIRDEF (CCSORT); CCSORT — Definition of local pair domains, unique avaliable option is BP, Boughton-Pulay. Type: string; Default: BP. LOCAL_PRECONDITIONER (CCEOM); CCEOM — Preconditioner will be used in local CC computations. Type: string; Possible Values: HBAR, FOCK; Default: HBAR. LOCAL_USE_GHOSTS (FISAPT); FISAPT (Expert) — Use ghost atoms in Pipek-Mezey or IBO metric. Type: boolean; Default: false. LOCAL_WEAKP (CCENERGY); CCENERGY — Desired treatment of “weak pairs” in the local-CCSD method. A value of NEGLECT ignores weak pairs entirely. A value of NONE treats weak pairs in the same manner as strong pairs. A value of MP2 uses second-order perturbation theory to correct the local-CCSD energy computed with weak pairs ignored. Type: string; Possible Values: NONE, NEGLECT, MP2; Default: NONE. LOCAL_WEAKP (CCEOM); CCEOM — Desired treatment of “weak pairs” in the local-CCSD method. A value of NEGLECT ignores weak pairs entirely. A value of NONE treats weak pairs in the same manner as strong pairs. A value of MP2 uses second-order perturbation theory to correct the local-CCSD energy computed with weak pairs ignored. Type: string; Possible Values: NONE, MP2, NEGLECT; Default: NONE. LOCAL_WEAKP (CCLAMBDA); CCLAMBDA — Desired treatment of “weak pairs” in the local-CCSD method. The value of NONE (unique avaliable option) treats weak pairs in the same manner as strong pairs. Type: string; Default: NONE. LOCAL_WEAKP (CCRESPONSE); CCRESPONSE — Desired treatment of “weak pairs” in the local-CCSD method. The value of NONE (unique avaliable option) treats weak pairs in the same manner as strong pairs. Type: string; Default: NONE. LOCAL_WEAKP (CCSORT); CCSORT — D",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html:153327,energy,energy,153327,psi4manual/1.0.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html,2,['energy'],['energy']
Energy Efficiency,"l related “local correlation” methods.; The DLPNO-MP2 code is a linear-scaling alternative to the DF-MP2; code, and is intended for use with large systems for which DF-MP2 is intractable.; When running DLPNO-MP2 with default settings, approximately 99.9% of the DF-MP2; correlation energy is recovered. The general outline of the method is as follows:. Localize the active occupied MOs (with the Foster-Boys method); Construct projected AOs (PAOs) from the virtual MOs; Calculate three-index integrals in the (sparse) LMO/PAO basis; Perform local density fitting to construct (sparse) exchange integrals; Transform local virtuals from PAOs to pair natural orbitals (PNOs), and truncate; Solve the iterative local MP2 equations in the LMO/PNO basis. An example input file is:; molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; symmetry c1; }. set basis cc-pvdz; set scf_type df; set freeze_core True; set pno_convergence normal. energy('dlpno-mp2'). The main difference between this input and a DF-MP2 input is the energy('dlpno-mp2'); call to energy(). The only other addition is the PNO_CONVERGENCE; keyword, which determines the accuracy of the local approximations underlying; the DLPNO-MP2 method. Note that the water molecule in this example is not large; enough for DLPNO-MP2 to be of any benefit relative to DF-MP2.; The theory of the DLPNO-MP2 method and practical recommendations for using the; code are presented below. Theory¶; See DF-MP2 for background on the theory of (non-local); density-fitted MP2. PSI4‘s DLPNO-MP2 implementation is based on the; manuscript by Pinski et al. [Pinski:2015:034108].; In DLPNO-MP2, as in all local MP2 methods, the second-order MBPT energy is determined; variationally via the Hylleraas functional [Hylleraas:1930:209]:. (1)¶\[E^{(2)} = 2 \langle \Psi_{0}^{(0)} | \hat{H} - E_{0}^{(0)} | \Psi_{0}^{(1)} \rangle - \langle \Psi_{0}^{(1)} | \hat{H}^{(0)} - E_{0}^{(0)} | \Psi_{0}^{(1)} \rangle = \min_{| \Psi_{0}^{(1)} \rangle}.\]; Determining the optimal ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/dlpnomp2-1.html:2351,energy,energy,2351,psi4manual/1.5.0/dlpnomp2-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/dlpnomp2-1.html,14,['energy'],['energy']
Energy Efficiency,"l relatives in psi4/psi4/driver/p4util/testing.py for comparing strings, matrices, etc.) checks that the computed values match these reference values to suitable precision. This function prints an error message and signals that the test failed to the make system, if the values don’t match. Any lines of the input associated with the validation process should be flagged with #TEST at the end of each line, so that they can be removed when copying from the tests to the samples directory.; Finally, add the directory name to the list of tests in psi4/tests/CMakeLists.txt.; In preparing the test case, turn energy, density, amplitude, and; geometry convergence criteria to very tight levels, and use these; results for reference energies, reference geometries, reference cube; files, etc.. Then, either remove or relax the convergence settings,; if these are not a vital part of the test. In choosing the number of; digits for compare_values() and other compare_* functions,; select a number looser than the convergence set in the test or the; default convergence for the calculation type (energy, gradient, etc.). Adding PsiAPI Test Cases¶; Sometimes you want to add tests that check several variations of a; template job or that test error handling or that are PsiAPI rather than; PSIthon focused. In these cases, you’ll want to add to the second test; suite that lives at psi4/tests/pytests. Presently, the “normal”; (everything in the tests/ directory that isn’t in tests/pytests/); are run through ctest, while the pytests are run through pytest. In; future, all will be run through Pytest, but the former will still be; run as PSIthon (psi4 input.dat) while the latter will still be; run as PsiAPI (import psi4). In other words, in designing a test,; choose its mode based on whether PSIthon or PsiAPI suits it better and; whether it’s a simple model for users (probably PSIthon) or for expert; users (probably PsiAPI). Both will continue to work in future.; In developing a Pytest test, you pr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/add_tests-1.html:3333,energy,energy,3333,psi4manual/1.4.0/add_tests-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/add_tests-1.html,4,['energy'],['energy']
Energy Efficiency,"l rotations after convergence, irrep (1-based, Cotton order) of the orbitals to rotate. Type: integer; Default: 1. ROTATE_MO_P (MCSCF); MCSCF (Expert) — For orbital rotations after convergence, number of the first orbital (1-based) to rotate. Type: integer; Default: 1. ROTATE_MO_Q (MCSCF); MCSCF (Expert) — For orbital rotations after convergence, number of the second orbital (1-based) to rotate. Type: integer; Default: 2. ROTATION_SCHEME (STABILITY); STABILITY — Method for following eigenvectors, either 0 by angles or 1 by antisymmetric matrix. Type: integer; Default: 0. RUN_CCSD (FNOCC); FNOCC (Expert) — do ccsd rather than qcisd?. Type: boolean; Default: false. RUN_CEPA (FNOCC); FNOCC (Expert) — Is this a CEPA job? This parameter is used internally by the pythond driver. Changing its value won’t have any effect on the procedure. Type: boolean; Default: false. RUN_MP2 (FNOCC); FNOCC (Expert) — do only evaluate mp2 energy?. Type: boolean; Default: false. RUN_MP3 (FNOCC); FNOCC (Expert) — do only evaluate mp3 energy?. Type: boolean; Default: false. RUN_MP4 (FNOCC); FNOCC (Expert) — do only evaluate mp4 energy?. Type: boolean; Default: false. S (DETCI); DETCI — The value of the spin quantum number is given by this option. The default is determined by the value of the multiplicity. This is used for two things: (1) determining the phase of the redundant half of the CI vector when the component is used (i.e., MS0 = TRUE), and (2) making sure the guess vector has the desired value of (if S_SQUARED is TRUE and ICORE = 1). Type: double; Default: 0.0. S_ORTHOGONALIZATION (SCF); SCF — SO orthogonalization: symmetric or canonical?. Type: string; Possible Values: SYMMETRIC, CANONICAL; Default: SYMMETRIC. S_SQUARED (DETCI); DETCI — Do calculate the value of for each root? Only supported for ICORE = 1. Type: boolean; Default: false. S_TOLERANCE (SCF); SCF — Minimum S matrix eigenvalue to be used before compensating for linear dependencies. Type: conv double; Default: 1e-7. SAD_CH",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodoc_glossary_options_c-1.html:114212,energy,energy,114212,psi4manual/4.0b4/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodoc_glossary_options_c-1.html,4,['energy'],['energy']
Energy Efficiency,"l structures, any of which can be used within PSI4; input files. For example, to loop over three basis sets, the following code can; be used:; 1; 2; 3; 4basis_sets = [""cc-pVDZ"", ""cc-pVTZ"", ""cc-pVQZ""]; for basis_set in basis_sets:; set basis = $basis_set; energy('scf'). The declaration of basis_sets is completely standard Python, as is the next; line, which iterates over the list. However, because the Psithon preprocessor; wraps strings in quotes by default, we have to tell it that basis_set is a; Python variable, not a string, by prefixing it with a dollar sign.; The geometry specification supports delayed initialization of variable,; which permits potential energy scans. As an example, we can scan both the; angle and bond length in water:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16molecule h2o{; O; H 1 R; H 1 R 2 A; }. Rvals = [0.9, 1.0, 1.1]; Avals = range(102, 106, 2). set basis cc-pvdz; set scf e_convergence=11; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('scf'). The declarations of Rvals and Avals are both completely standard Python syntax.; Having named our molecule h2o we can then set the values of R and A within; the loops. Note that we do not need the dollar sign to access the Python; variable in this example; that is required only when using Python variables; with the set keyword.; Cartesian geometries, because of details of the geometry update process,; need to be specified within the loop(s) along with their basis set when; geometry scans are performed. See scf4 for analogous Z-matrix; and Cartiesian scans. Tables of Results¶; The results of computations can be compactly tabulated with the Table() Psithon; function. For example, in the following potential energy surface scan for water; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27molecule h2o {; O; H 1 R; H 1 R 2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(100,102,2). table=Table(rows=[""R"",""A""], cols=[""E(SCF)"",""E(SCS)"",""E(DFMP2)""",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psithoninput-1.html:12754,energy,energy,12754,psi4manual/1.1.0/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psithoninput-1.html,6,['energy'],['energy']
Energy Efficiency,"l to the geometry projection module. optimize(name[, molecule, return_wfn, func, mode, dertype, hessian_with])[source]¶; Function to perform a geometry optimization. Aliases:opt(). Returns:float – Total electronic energy of optimized structure in Hartrees. Returns:(float, Wavefunction) – energy and wavefunction when return_wfn specified. PSI variables:. CURRENT ENERGY. Parameters:; name (string) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || 'off' ; Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. For maximum; flexibility, return_wfn is always on in 'reap' mode. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (string) – 'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/opt-1.html:1695,energy,energy,1695,psi4manual/1.0.0/opt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/opt-1.html,2,['energy'],['energy']
Energy Efficiency,"l use a print level of 3. In this example a full CCSD computation is; performed by running the SCF code first, then the coupled cluster modules;; the energy() Python helper function ensures that this is performed correctly.; Note that the Python interpreter executes commands in the order they appear in; the input file, so if the last four commands in the above example were to read; set basis cc-pVDZ; energy('ccsd'); set ccenergy print 3; set scf print 1. the commands that set the print level would be ineffective, as they would be; processed after the CCSD computation completes. Basis Sets¶. Basis Sets; Built-In Basis Sets; Mixing Basis Sets; Decontracted Basis Sets; User-Defined Basis Sets. PSI Variables¶; To harness the power of Python, Psi4 makes the most pertinent results; of each computation available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of; H2 and H atom:; molecule h2 {; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h {; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol * (2*h_energy - h2_energy); print ""De=%f"" % D_e. The energy() function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation.; Generally, there are multiple quantities of interest. Appendix; PSI Variables by Module lists PSI variables variables set by each; module, and PSI Variables by Alpha defines them. These can be; accessed through the get_variable() function. For example, after; performing a density fitted MP2 computation, both the spin component; scaled energy and the unscaled MP2 energy are made available:; e_mp2 = get_variable('MP2 TOTAL ENERGY'); e_scs_mp2 = get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variable",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/psithoninput-1.html:8088,energy,energy,8088,psi4manual/1.0.0/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/psithoninput-1.html,2,['energy'],['energy']
Energy Efficiency,"l"":; raise ValidationError(""Hessian: Does not yet support custom functions.""); else:; lowername = name.lower(). _filter_renamed_methods(""frequency"", lowername); ; return_wfn = kwargs.pop('return_wfn', False); core.clean_variables(); dertype = 2. # Prevent methods that do not have associated energies; if lowername in energy_only_methods:; raise ValidationError(""hessian('%s') does not have an associated hessian"" % name). optstash = p4util.OptionsState(; ['FINDIF', 'HESSIAN_WRITE'],; ['FINDIF', 'FD_PROJECT'],; ). # Allow specification of methods to arbitrary order; lowername, level = driver_util.parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. dertype = _find_derivative_type('hessian', lowername, kwargs.pop('freq_dertype', kwargs.get('dertype', None))). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash_conv = driver_util._set_convergence_criterion('energy', lowername, 8, 10, 8, 10, 8). # Select certain irreps; irrep = kwargs.get('irrep', -1); if irrep == -1:; pass # do all irreps; else:; irrep = driver_util.parse_cotton_irreps(irrep, molecule.schoenflies_symbol()); irrep -= 1 # A1 irrep is externally 1, internally 0; if dertype == 2:; core.print_out(; """"""hessian() switching to finite difference by gradients for partial Hessian calculation.\n""""""); dertype = 1. # At stationary point?; if 'ref_gradient' in kwargs:; core.print_out(""""""hessian() using ref_gradient to assess stationary point.\n""""""); G0 = kwargs['ref_gradient']; else:; G0 = gradient(lowername, molecule=molecule, **kwargs); translations_projection_sound, rotations_projection_sound = _energy_is_invariant(G0); core.print_out(; '\n Based on options and gradient (rms={:.2E}), recommend {}projecting translations and {}projecting rotations.\n'; .format(G0.rms(), '' if translations_proj",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:76868,energy,energy,76868,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,4,['energy'],['energy']
Energy Efficiency,"l': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'fno-df-ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['qcisd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY',; 'qcisd(t)corl': 'QCISD(T) CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['bccd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'bccd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['cisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdcorl': 'CISD CORRELATION ENERGY'}; VARH['cisdt'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdtcorl': 'CISDT CORRELATION ENERGY'}; VARH['cisdtq'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdtqcorl': 'CISDTQ CORRELATION ENERGY'}; VARH['fci'] = { 'scftot': 'SCF TOTAL ENERGY',; 'fcicorl': 'FCI CORRELATION ENERGY'}; VARH['mrccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['mrccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdcorl': 'CCSD CORRELATION ENERGY',; 'mrccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['mrccsdt'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdtcorl': 'CCSDT CORRELATION ENERGY'}; VARH['mrccsdt(q)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdtcorl': 'CCSDT CORRELATION ENERGY',; 'mrccsdt(q)corl': 'CCSDT(Q) CORRELATION ENERGY'}. for cilevel in range(2, 99):; VARH['ci%s' % (str(cilevel))] = {; 'scftot': 'SCF TOTAL ENERGY',; 'ci%scorl' % (str(cilevel)): 'CI CORRELATION ENERGY'}. finalenergy = 0.0; do_scf = 1; do_corl = 0; do_delta = 0; do_delta2 = 0; do_delt",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:67741,ENERGY,ENERGY,67741,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,35,['ENERGY'],['ENERGY']
Energy Efficiency,"l(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('DSD-PBEP86'); # Tab in, trailing newlines; sup.set_description(' DSD-PBEP86 Dispersion-corrected SCS Double Hybrid XC Functional (opt. for -D2)\n'); # Tab in, trailing newlines; sup.set_citation(' S. Kozuch, Phys. Chem. Chem. Phys., 13, 20104, 2011\n'). # Add member functionals; X = build_functional('PBE_X'); X.set_alpha(1.0); sup.add_x_functional(X); C = build_functional('P86_C'); C.set_alpha(0.45); sup.add_c_functional(C). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.68); sup.set_c_alpha(1.0); sup.set_c_ss_alpha(0.23); sup.set_c_os_alpha(0.51). # => -D2 <=. sup.set_dispersion(psi4.Dispersion.build(*dash_server('dsd-pbep86', 'd2p4'))). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_dsd_pbepbe_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('DSD-PBEPBE'); # Tab in, trailing newlines; sup.set_description(' DSD-PBEPBE Dispersion-corrected SCS Double Hybrid XC Functional\n'); # Tab in, trailing newlines; sup.set_citation(' S. Kozuch, Phys. Chem. Chem. Phys., 13, 20104, 2011\n'). # Add member functionals; X = build_functional('PBE_X'); X.set_alpha(1.0); sup.add_x_functional(X); C = build_functional('PBE_C'); C.set_alpha(0.51); sup.add_c_functional(C). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.66); sup.set_c_alpha(1.0); sup.set_c_ss_alpha(0.12); sup.set_c_os_alpha(0.53). # => -D2 <=. sup.set_dispersion(psi4.Dispersion.build(*dash_server('dsd-pbepbe', 'd2p4'))). # => End User-Customization <",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/functional.html:76853,allocate,allocate,76853,psi4manual/4.0b5/_modules/functional.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/functional.html,3,['allocate'],['allocate']
Energy Efficiency,"l) / (delta_r - delta_l) * delta_l + omega_l; core.set_local_option('SCF', 'DFT_OMEGA', omega). # Neutral; core.IO.change_file_namespace(180, ""neutral"", ""ot""); molecule.set_molecular_charge(charge0); molecule.set_multiplicity(mult0); core.set_global_option(""DOCC"", [Nb]); core.set_global_option(""SOCC"", [Na - Nb]); E0, wfn = driver.energy('scf', dft_functional=name, return_wfn=True, molecule=molecule,; banner='IP Fitting SCF: Neutral, Omega = {:11.3E}'.format(omega), **kwargs); eps_a = wfn.epsilon_a(); eps_b = wfn.epsilon_b(); if Nb == 0:; E_HOMO = eps_a.np[int(Na - 1)]; else:; E_a = eps_a.np[int(Na - 1)]; E_b = eps_b.np[int(Nb - 1)]; E_HOMO = max(E_a, E_b); core.IO.change_file_namespace(180, ""ot"", ""neutral""). # Cation; core.IO.change_file_namespace(180, ""cation"", ""ot""); molecule.set_molecular_charge(charge1); molecule.set_multiplicity(mult1); core.set_global_option(""DOCC"", [Nb1]); core.set_global_option(""SOCC"", [Na1 - Nb1]); E1 = driver.energy('scf', dft_functional=name, molecule=molecule,; banner='IP Fitting SCF: Cation, Omega = {:11.3E}'.format(omega), **kwargs); core.IO.change_file_namespace(180, ""ot"", ""cation""). IP = E1 - E0; kIP = -E_HOMO; delta = IP - kIP. if kIP > IP:; omega_r = omega; E0r = E0; E1r = E1; IPr = IP; kIPr = kIP; delta_r = delta; repeat_r = 0; repeat_l += 1; else:; omega_l = omega; E0l = E0; E1l = E1; IPl = IP; kIPl = kIP; delta_l = delta; repeat_l = 0; repeat_r += 1. omegas.append(omega); types.append('Regula-Falsi'); E0s.append(E0); E1s.append(E1); IPs.append(IP); kIPs.append(kIP). # Termination; if abs(omega_l - omega_r) < omega_convergence:; converged = True; break. core.IO.set_default_namespace(""""); core.print_out(""""""\n ==> IP Fitting Results <==\n\n""""""). core.print_out("""""" => Occupation Determination <= \n\n""""""); core.print_out("""""" %6s %6s %6s %6s %6s %6s\n"""""" % ('N', 'Na', 'Nb', 'Charge', 'Mult', 'HOMO')); core.print_out("""""" Neutral: %6d %6d %6d %6d %6d %6d\n"""""" % (N, Na, Nb, charge0, mult0, HOMO)); core.print_out("""""" Cation: %6d %6d %6d %",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/frac.html:21601,energy,energy,21601,psi4manual/1.7.x/_modules/psi4/driver/frac.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/frac.html,8,['energy'],['energy']
Energy Efficiency,"l); Stop timer with label. timer_on(label); Start timer with label. triplet(A, B, C[, transA, transB, transC]); Returns the multiplication of three matrices, with options to transpose each beforehand. tstart(); Start module-level timer. tstop(); Stop module-level timer. variable(key); Return copy of scalar or array QCVariable key from global memory. variables([include_deprecated_keys]); Return all scalar or array QCVariables from global memory. version(). Deprecated since version 1.4. Classes¶. AOShellCombinationsIterator. AngularMomentumInt; Computes angular momentum integrals. BSVec. BasisExtents; docstring. BasisFunctions; docstring. BasisSet; Contains basis set information. BlockOPoints; docstring. BoysLocalizer; Performs Boys orbital localization. CCWavefunction; Specialized Wavefunction used by the ccenergy, cceom, ccgradient, etc. CIVector; docstring. CIWavefunction; docstring. CUHF; docstring. CdSalc; Cartesian displacement SALC. CdSalcList; Class for generating symmetry adapted linear combinations of Cartesian displacements. CharacterTable; Contains the character table of the point group. CompositeJK; docstring. CorrelationFactor; docstring. CorrelationTable; Provides a correlation table between two point groups. CubeProperties; docstring. DFEP2Wavefunction; A density-fitted second-order Electron Propagator Wavefunction. DFHelper; docstring. DFSOMCSCF; docstring. DFTGrid; docstring. DFTensor; docstring. Deriv; Computes gradients of wavefunctions. DerivCalcType; Members:. DiagonalizeOrder; Defines ordering of eigenvalues after diagonalization. Dimension; Initializes and defines Dimension Objects. DipoleInt; Computes dipole integrals. DirectJK; docstring. DiskSOMCSCF; docstring. Dispersion; docstring. ERI; Computes normal two electron repulsion integrals. ERISieve; docstring. ESPPropCalc; ESPPropCalc gives access to routines calculating the ESP on a grid. ElectricFieldInt; Computes electric field integrals. ElectrostaticInt; Computes electrostatic integrals. ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/psi4api.html:10900,adapt,adapted,10900,psi4manual/1.8.x/psi4api.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/psi4api.html,2,['adapt'],['adapted']
Energy Efficiency,"l); Stop timer with label. timer_on(label); Start timer with label. triplet(A, B, C[, transA, transB, transC]); Returns the multiplication of three matrices, with options to transpose each beforehand. tstart(); Start module-level timer. tstop(); Stop module-level timer. variable(key); Return copy of scalar or array QCVariable key from global memory. variables([include_deprecated_keys]); Return all scalar or array QCVariables from global memory. version(). Deprecated since version 1.4. Classes¶. AOShellCombinationsIterator. AngularMomentumInt; Computes angular momentum integrals. BSVec. BasisExtents; docstring. BasisFunctions; docstring. BasisSet; Contains basis set information. BlockOPoints; docstring. BoysLocalizer; Performs Boys orbital localization. CCWavefunction; Specialized Wavefunction used by the ccenergy, cceom, ccgradient, etc. CIVector; docstring. CIWavefunction; docstring. CUHF; docstring. CdSalc; Cartesian displacement SALC. CdSalcList; Class for generating symmetry adapted linear combinations of Cartesian displacements. CharacterTable; Contains the character table of the point group. CorrelationFactor; docstring. CorrelationTable; Provides a correlation table between two point groups. CubeProperties; docstring. DFEP2Wavefunction; A density-fitted second-order Electron Propagator Wavefunction. DFHelper; docstring. DFJCOSK; docstring. DFJLinK; docstring. DFSOMCSCF; docstring. DFTGrid; docstring. DFTensor; docstring. Deriv; Computes gradients of wavefunctions. DerivCalcType; Members:. DiagonalizeOrder; Defines ordering of eigenvalues after diagonalization. Dimension; Initializes and defines Dimension Objects. DipoleInt; Computes dipole integrals. DirectJK; docstring. DiskSOMCSCF; docstring. Dispersion; docstring. ERI; Computes normal two electron repulsion integrals. ERISieve; docstring. ESPPropCalc; ESPPropCalc gives access to routines calculating the ESP on a grid. ElectricFieldInt; Computes electric field integrals. ElectrostaticInt; Computes electrost",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/psi4api.html:10892,adapt,adapted,10892,psi4manual/1.7.x/psi4api.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/psi4api.html,1,['adapt'],['adapted']
Energy Efficiency,"l); Stop timer with label. timer_on(label); Start timer with label. triplet(A, B, C[, transA, transB, transC]); Returns the multiplication of three matrices, with options to transpose each beforehand. tstart(); Start module-level timer. tstop(); Stop module-level timer. variable(key); Return copy of scalar or array QCVariable key from global memory. variables([include_deprecated_keys]); Return all scalar or array QCVariables from global memory. version(). Deprecated since version 1.4. Classes¶. AOShellCombinationsIterator. AngularMomentumInt; Computes angular momentum integrals. BSVec. BasisExtents; docstring. BasisFunctions; docstring. BasisSet; Contains basis set information. BlockOPoints; docstring. BoysLocalizer; Performs Boys orbital localization. CCWavefunction; Specialized Wavefunction used by the ccenergy, cceom, ccgradient, etc. CIVector; docstring. CIWavefunction; docstring. CUHF; docstring. CdSalc; Cartesian displacement SALC. CdSalcList; Class for generating symmetry adapted linear combinations of Cartesian displacements. CharacterTable; Contains the character table of the point group. CorrelationFactor; docstring. CorrelationTable; Provides a correlation table between two point groups. CubeProperties; docstring. DFEP2Wavefunction; A density-fitted second-order Electron Propagator Wavefunction. DFHelper; docstring. DFJCOSK; docstring. DFSOMCSCF; docstring. DFTGrid; docstring. DFTensor; docstring. Deriv; Computes gradients of wavefunctions. DerivCalcType; Members:. DiagonalizeOrder; Defines ordering of eigenvalues after diagonalization. Dimension; Initializes and defines Dimension Objects. DipoleInt; Computes dipole integrals. DirectJK; docstring. DiskSOMCSCF; docstring. Dispersion; docstring. ERI; Computes normal two electron repulsion integrals. ERISieve; docstring. ESPPropCalc; ESPPropCalc gives access to routines calculating the ESP on a grid. ElectricFieldInt; Computes electric field integrals. ElectrostaticInt; Computes electrostatic integrals. Exte",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/psi4api.html:11762,adapt,adapted,11762,psi4manual/1.6.x/psi4api.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psi4api.html,1,['adapt'],['adapted']
Energy Efficiency,"l); Stop timer with label. timer_on(label); Start timer with label. triplet(A, B, C[, transA, transB, transC]); Returns the multiplication of three matrices, with options to transpose each beforehand. tstart(); Start module-level timer. tstop(); Stop module-level timer. variable(key); Return copy of scalar or array QCVariable key from global memory. variables([include_deprecated_keys]); Return all scalar or array QCVariables from global memory. version(). Deprecated since version 1.4. Classes¶. AOShellCombinationsIterator. AngularMomentumInt; Computes angular momentum integrals. BSVec. BasisExtents; docstring. BasisFunctions; docstring. BasisSet; Contains basis set information. BlockOPoints; docstring. BoysLocalizer; Performs Boys orbital localization. CCWavefunction; Specialized Wavefunction used by the ccenergy, cceom, ccgradient, etc. CIVector; docstring. CIWavefunction; docstring. CUHF; docstring. CdSalc; Cartesian displacement SALC. CdSalcList; Class for generating symmetry adapted linear combinations of Cartesian displacements. CharacterTable; Contains the character table of the point group. CorrelationFactor; docstring. CorrelationTable; Provides a correlation table between two point groups. CubeProperties; docstring. DFEP2Wavefunction; A density-fitted second-order Electron Propagator Wavefunction. DFHelper; docstring. DFSOMCSCF; docstring. DFTGrid; docstring. DFTensor; docstring. DIISEntry; docstring. DIISManager; docstring. Deriv; Computes gradients of wavefunctions. DerivCalcType; Members:. DiagonalizeOrder; Defines ordering of eigenvalues after diagonalization. Dimension; Initializes and defines Dimension Objects. DipoleInt; Computes dipole integrals. DirectJK; docstring. DiskSOMCSCF; docstring. Dispersion; docstring. ERI; Computes normal two electron repulsion integrals. ERISieve; docstring. ESPPropCalc; ESPPropCalc gives access to routines calculating the ESP on a grid. ElectricFieldInt; Computes electric field integrals. ElectrostaticInt; Computes ele",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/psi4api-1.html:11762,adapt,adapted,11762,psi4manual/1.5.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/psi4api-1.html,2,['adapt'],['adapted']
Energy Efficiency,"l, max_holes_I, max_parts_IV, max_I+IV], [ex_lvl, max_holes_I, max_parts_IV, max_I+IV], … ] Optional additional restrictions on allowed excitations in coupled-cluster computations, based on macroconfiguration selection. For each sub-array, [ex_lvl, max_holes_I, max_parts_IV, max_I+IV], eliminate cluster amplitudes in which: [the excitation level (holes in I + II) is equal to ex_lvl] AND [there are more than max_holes_I holes in RAS I, there are more than max_parts_IV particles in RAS IV, OR there are more than max_I+IV quasiparticles in RAS I + RAS IV]. Type: array; Default: No Default. CC_MIXED¶. Do ignore block if num holes in RAS I and II is \(>\) cc_ex_lvl and if any indices correspond to RAS I or IV (i.e., include only all-active higher excitations)?. Type: boolean; Default: true. CC_UPDATE_EPS¶. Do update T amplitudes with orbital eigenvalues? (Usually would do this). Not doing this is experimental. Type: boolean; Default: true. CC_VARIATIONAL¶. Do use variational energy expression in CC computation? Experimental. Type: boolean; Default: false. Expert Alternative Algorithms¶. BENDAZZOLI¶. Do use some routines based on the papers of Bendazzoli et al. to calculate sigma? Seems to be slower and not worthwhile; may disappear eventually. Works only for full CI and I don’t remember if I could see how their clever scheme might be extended to RAS in general. Type: boolean; Default: false. FCI_STRINGS¶. Do store strings specifically for FCI? (Defaults to TRUE for FCI.). Type: boolean; Default: false. REPL_OTF¶. Do string replacements on the fly in DETCI? Can save a gigantic amount of memory (especially for truncated CI’s) but is somewhat flaky and hasn’t been tested for a while. It may work only works for certain classes of RAS calculations. The current code is very slow with this option turned on. Type: boolean; Default: false. table of contents. DETCI; General Options; AVG_STATES; AVG_WEIGHTS; A_RAS3_MAX; B_RAS3_MAX; CALC_S_SQUARED; CIBLKS_PRINT; CI_MAXITER; DETCI_FR",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__detci-1.html:21394,energy,energy,21394,psi4manual/1.3.2/autodir_options_c/module__detci-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__detci-1.html,22,['energy'],['energy']
Energy Efficiency,"l-Optimized MP capabilities of OCC/DFOCC modules¶. name; calls method; Energy; Gradient. scs-omp3; Spin-Component Scaled Orbital-Optimized MP3; RHF/UHF/ROHF/RKS/UKS; —. sos-omp3; Spin-Opposite Scaled Orbital-Optimized MP3; RHF/UHF/ROHF/RKS/UKS; —. scs(n)-omp3; A special version of SCS-OMP3 for nucleobase interactions; RHF/UHF/ROHF/RKS/UKS; —. scs-omp3-vdw; A special version of SCS-OMP3 (from ethene dimers); RHF/UHF/ROHF/RKS/UKS; —. sos-pi-omp3; A special version of SOS-OMP3 for -systems; RHF/UHF/ROHF/RKS/UKS; —. scs-omp2; Spin-Component Scaled Orbital-Optimized MP2; RHF/UHF/ROHF/RKS/UKS; —. sos-omp2; Spin-Opposite Scaled Orbital-Optimized MP2; RHF/UHF/ROHF/RKS/UKS; —. scs(n)-omp2; A special version of SCS-OMP2 for nucleobase interactions; RHF/UHF/ROHF/RKS/UKS; —. scs-omp2-vdw; A special version of SCS-OMP2 (from ethene dimers); RHF/UHF/ROHF/RKS/UKS; —. sos-pi-omp2; A special version of SOS-OMP2 for -systems; RHF/UHF/ROHF/RKS/UKS; —. Basic OCC Keywords¶. E_CONVERGENCE¶. Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. R_CONVERGENCE¶. Convergence criterion for amplitudes (residuals). Type: conv double; Default: 1e-5. RMS_MOGRAD_CONVERGENCE¶. Convergence criterion for RMS orbital gradient. Default adjusts depending on E_CONVERGENCE. Type: conv double; Default: 1e-6. MAX_MOGRAD_CONVERGENCE¶. Convergence criterion for maximum orbital gradient. Type: conv double; Default: 1e-3. MO_MAXITER¶. Maximum number of iterations to determine the orbitals. Type: integer; Default: 50. WFN_TYPE¶. Type of the wavefunction. Type: string; Possible Values: OMP2, OMP3, OCEPA, OMP2.5; Default: OMP2. ORB_OPT¶. Do optimize the orbitals?. Type: boolean; Default: true. Advanced OCC Keywords¶. OPT_METHOD¶. The optimization algorithm. Modified Steepest-Descent (MSD) takes a Newton-Raphson (NR) step with a crude approximation to diagonal elements of the MO Hessian. The ORB_RESP optio",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/occ-1.html:8850,energy,energy,8850,psi4manual/1.0.0/occ-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/occ-1.html,2,['energy'],['energy']
Energy Efficiency,"l-advised. Type: boolean; Default: true. SAPT_MEM_SAFETY¶. Memory safety. Type: double; Default: 0.9. SAPT(DFT)¶. SAPT_DFT_DO_DHF¶. Compute the Delta-HF correction?. Type: boolean; Default: true. SAPT_DFT_EXCH_DISP_SCALE_SCHEME¶. Scheme for approximating exchange-dispersion for SAPT-DFT. NONE Use unscaled Exch-Disp2,u . FIXED Use a fixed factor SAPT_DFT_EXCH_DISP_FIXED_SCALE to scale Exch-Disp2,u . DISP Use the ratio of Disp2,r and Disp2,u to scale Exch-Disp2,u . Type: string; Possible Values: NONE, FIXED, DISP; Default: DISP. SAPT_DFT_GRAC_SHIFT_A¶. Monomer A GRAC shift in Hartree. Type: double; Default: 0.0. SAPT_DFT_GRAC_SHIFT_B¶. Monomer B GRAC shift in Hartree. Type: double; Default: 0.0. Expert SAPT(HF)¶. COUPLED_INDUCTION¶. Solve the CPHF equations to compute coupled induction and exchange-induction. These are not available for ROHF, and the option is automatically false in this case. In all other cases, coupled induction is strongly recommended. Only turn it off if the induction energy is not going to be used. Type: boolean; Default: true. DO_CCD_DISP¶. Do CCD dispersion correction in SAPT2+, SAPT2+(3) or SAPT2+3?. Type: boolean; Default: false. DO_DISP_EXCH_SINF¶. For SAPT(DFT) computes the \(S^{inf}\) Exchange-Dispersion terms. Type: boolean; Default: false. DO_IND_EXCH_SINF¶. For SAPT(DFT) computes the \(S^{inf}\) Exchange-Induction terms. Type: boolean; Default: false. DO_MBPT_DISP¶. Do MBPT dispersion correction in SAPT2+, SAPT2+(3) or SAPT2+3, if also doing CCD?. Type: boolean; Default: true. DO_THIRD_ORDER¶. Do compute third-order corrections?. Type: boolean; Default: false. SAPT0_E10¶. For SAPT0 only, compute only first-order electrostatics and exchange. The integrals are computed before any terms, so all integrals will be computed even if they are not needed for the requested term. Type: boolean; Default: false. SAPT0_E20DISP¶. For SAPT0 only, compute only second-order induction The integrals are computed before any terms, so all integrals will be c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodir_options_c/module__sapt-1.html:5627,energy,energy,5627,psi4manual/1.5.0/autodir_options_c/module__sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodir_options_c/module__sapt-1.html,4,['energy'],['energy']
Energy Efficiency,"l-advised. Type: boolean; Default: true. SAPT_MEM_SAFETY¶. Memory safety. Type: double; Default: 0.9. SAPT(DFT)¶. SAPT_DFT_DO_DHF¶. Compute the Delta-HF correction?. Type: boolean; Default: true. SAPT_DFT_EXCH_DISP_SCALE_SCHEME¶. Scheme for approximating exchange-dispersion for SAPT-DFT. NONE Use unscaled Exch-Disp2,u . FIXED Use a fixed factor SAPT_DFT_EXCH_DISP_FIXED_SCALE to scale Exch-Disp2,u . DISP Use the ratio of Disp2,r and Disp2,u to scale Exch-Disp2,u . Type: string; Possible Values: NONE, FIXED, DISP; Default: DISP. SAPT_DFT_GRAC_SHIFT_A¶. Monomer A GRAC shift in Hartree. Type: double; Default: 0.0. SAPT_DFT_GRAC_SHIFT_B¶. Monomer B GRAC shift in Hartree. Type: double; Default: 0.0. Expert SAPT(HF)¶. COUPLED_INDUCTION¶. Solve the CPHF equations to compute coupled induction and exchange-induction. These are not available for ROHF, and the option is automatically false in this case. In all other cases, coupled induction is strongly recommended. Only turn it off if the induction energy is not going to be used. Type: boolean; Default: true. DO_CCD_DISP¶. Do CCD dispersion correction in SAPT2+, SAPT2+(3) or SAPT2+3?. Type: boolean; Default: false. DO_DISP_EXCH_SINF¶. For SAPT0 or SAPT(DFT), compute the non-approximated second-order exchange-dispersion term. Type: boolean; Default: false. DO_IND30_EXCH_SINF¶. For SAPT2+3, compute the non-approximated third-order exchange-induction term. Type: boolean; Default: false. DO_IND_EXCH_SINF¶. For SAPT0 or SAPT(DFT), compute the non-approximated second-order exchange-induction term. Type: boolean; Default: false. DO_MBPT_DISP¶. Do MBPT dispersion correction in SAPT2+, SAPT2+(3) or SAPT2+3, if also doing CCD?. Type: boolean; Default: true. DO_THIRD_ORDER¶. Do compute third-order corrections?. Type: boolean; Default: false. SAPT0_E10¶. For SAPT0 only, compute only first-order electrostatics and exchange. The integrals are computed before any terms, so all integrals will be computed even if they are not needed for the req",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodir_options_c/module__sapt.html:5692,energy,energy,5692,psi4manual/1.6.x/autodir_options_c/module__sapt.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodir_options_c/module__sapt.html,2,['energy'],['energy']
Energy Efficiency,"l. levels (dict) – {1: 'ccsd(t)', 2: 'mp2', 'supersystem': 'scf'} || {1: 2, 2: 'ccsd(t)', 3: 'mp2'} || etc; Dictionary of different levels of theory for different levels of expansion; Note that method_string is not used in this case. supersystem computes; all higher order n-body effects up to the number of fragments. embedding_charges (dict) – {1: [-0.834, 0.417, 0.417], ..}; Dictionary of atom-centered point charges. keys: 1-based index of fragment, values: list of charges for each fragment.; Add atom-centered point charges for fragments whose basis sets are not included in the computation. The nbody function computes counterpoise-corrected (CP), non-CP (noCP), and Valiron-Mayer Function Counterpoise (VMFC) interaction energies for complexes composed of arbitrary numbers of monomers.; Examples :; # Counterpoise corrected CCSD(T) energies for the Helium dimer; molecule mol {; He; --; He 1 3; }; # Calculate interaction energies only (skips monomers in monomer basis):; energy('CCSD(T)', bsse_type='cp'); # Calculate interaction and total energies, return interaction energies:; energy('CCSD(T)', bsse_type=['cp','nocp']); # Calculate and return counterpoise-corrected gradient; # Useful for e.g. CP-corrected geometry optimization; gradient('CCSD(T)', bsse_type='cp', return_total_data=True). # noCP, VMFC, and CP energy for a helium cluster, limited at 3 bodies; molecule mol {; He 0 0 0; --; He 0 0 4; --; He 0 4 0; --; He 4 0 0; }. # Returns the nocp energy as its first in the list; energy('CCSD(T)', bsse_type=['nocp', 'cp', 'vmfc'], max_nbody=3). API¶. class psi4.driver.driver_nbody.BsseEnum(value)[source]¶; Available basis-set superposition error (BSSE) treatments. cp = 'cp'¶. nocp = 'nocp'¶. vmfc = 'vmfc'¶. pydantic model psi4.driver.driver_nbody.ManyBodyComputer[source]¶. Show JSON schema{; ""title"": ""ManyBodyComputer"",; ""description"": ""Base class for \""computers\"" that plan, run, and process QC tasks."",; ""type"": ""object"",; ""properties"": {; ""molecule"": {; ""title"": ""Molecu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/nbody.html:3138,energy,energy,3138,psi4manual/1.7.x/nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/nbody.html,4,['energy'],['energy']
Energy Efficiency,"l. levels (dict) – {1: 'ccsd(t)', 2: 'mp2', 'supersystem': 'scf'} || {1: 2, 2: 'ccsd(t)', 3: 'mp2'} || etc; Dictionary of different levels of theory for different levels of expansion; Note that method_string is not used in this case. supersystem computes; all higher order n-body effects up to the number of fragments. embedding_charges (dict) – {1: [-0.834, 0.417, 0.417], ..}; Dictionary of atom-centered point charges. keys: 1-based index of fragment, values: list of charges for each fragment.; Add atom-centered point charges for fragments whose basis sets are not included in the computation. The nbody function computes counterpoise-corrected (CP), non-CP (noCP), and Valiron-Mayer Function Counterpoise (VMFC) interaction energies for complexes composed of arbitrary numbers of monomers.; Examples :; # Counterpoise corrected CCSD(T) energies for the Helium dimer; molecule mol {; He; --; He 1 3; }; # Calculate interaction energies only (skips monomers in monomer basis):; energy('CCSD(T)', bsse_type='cp'); # Calculate interaction and total energies, return interaction energies:; energy('CCSD(T)', bsse_type=['cp','nocp']); # Calculate and return counterpoise-corrected gradient; # Useful for e.g. CP-corrected geometry optimization; gradient('CCSD(T)', bsse_type='cp', return_total_data=True). # noCP, VMFC, and CP energy for a helium cluster, limited at 3 bodies; molecule mol {; He 0 0 0; --; He 0 0 4; --; He 0 4 0; --; He 4 0 0; }. # Returns the nocp energy as its first in the list; energy('CCSD(T)', bsse_type=['nocp', 'cp', 'vmfc'], max_nbody=3). API¶. class psi4.driver.driver_nbody.BsseEnum(value, names=None, *, module=None, qualname=None, type=None, start=1, boundary=None)[source]¶; Available basis-set superposition error (BSSE) treatments. cp = 'cp'¶. nocp = 'nocp'¶. vmfc = 'vmfc'¶. pydantic model psi4.driver.driver_nbody.ManyBodyComputer[source]¶. Show JSON schema{; ""title"": ""ManyBodyComputer"",; ""description"": ""Base class for \""computers\"" that plan, run, and process QC",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/nbody.html:3140,energy,energy,3140,psi4manual/1.8.x/nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/nbody.html,2,['energy'],['energy']
Energy Efficiency,"l. levels (dict) – {1: 'ccsd(t)', 2: 'mp2', 'supersystem': 'scf'} || {1: 2, 2: 'ccsd(t)', 3: 'mp2'} || etc; Dictionary of different levels of theory for different levels of expansion; Note that method_string is not used in this case. supersystem computes; all higher order n-body effects up to the number of fragments. embedding_charges (dict) – {1: [-0.834, 0.417, 0.417], ..}; Dictionary of atom-centered point charges. keys: 1-based index of fragment, values: list of charges for each fragment.; Add atom-centered point charges for fragments whose basis sets are not included in the computation. The nbody function computes counterpoise-corrected (CP), non-CP (noCP), and Valiron-Mayer Function Counterpoise (VMFC) interaction energies for complexes composed of arbitrary numbers of monomers.; Examples :; # Counterpoise corrected CCSD(T) energies for the Helium dimer; molecule mol {; He; --; He 1 3; }; # Calculate interaction energies only (skips monomers in monomer basis):; energy('CCSD(T)', bsse_type='cp'); # Calculate interaction and total energies, return interaction energies:; energy('CCSD(T)', bsse_type=['cp','nocp']); # Calculate and return counterpoise-corrected gradient; # Useful for e.g. CP-corrected geometry optimization; gradient('CCSD(T)', bsse_type='cp', return_total_data=True). # noCP, VMFC, and CP energy for a helium cluster, limited at 3 bodies; molecule mol {; He 0 0 0; --; He 0 0 4; --; He 0 4 0; --; He 4 0 0; }. # Returns the nocp energy as its first in the list; energy('CCSD(T)', bsse_type=['nocp', 'cp', 'vmfc'], max_nbody=3). class psi4.driver.driver_nbody.ManyBodyComputer(**data)[source]¶. Parameters. molecule (Any) – The target molecule, if not the last molecule defined.; basis (str, Default: (auto)) – ; method (str, Default: (auto)) – ; driver ({energy,gradient,hessian,properties}) – The computation driver; i.e., energy, gradient, hessian.; keywords (Dict[Any], Default: {}) – The computation keywords/options.; bsse_type ({nocp,cp,vmfc}, Default: [<Bs",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/nbody.html:3135,energy,energy,3135,psi4manual/1.6.x/nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/nbody.html,2,['energy'],['energy']
Energy Efficiency,"l._set_convergence_criterion('property', lowername, 6, 10, 6, 10, 8); wfn = procedures['property'][lowername](lowername, **kwargs). optstash.restore(). if return_wfn:; return (core.get_variable('CURRENT ENERGY'), wfn); else:; return core.get_variable('CURRENT ENERGY'). [docs]def optimize(name, **kwargs):; r""""""Function to perform a geometry optimization. :aliases: opt(). :returns: *float* |w--w| Total electronic energy of optimized structure in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :raises: psi4.ConvergenceError if |optking__geom_maxiter| exceeded without reaching geometry convergence. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY <CURRENTENERGY>`. :type name: string; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`~driver.energy`. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. For a finite difference of energies optimization, indicates whether; the calculatio",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html:49817,energy,energy,49817,psi4manual/1.1.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html,1,['energy'],['energy']
Energy Efficiency,"l.kwargs_lower(kwargs); return_wfn = kwargs.pop('return_wfn', False); verbose = kwargs.pop('verbose', 0); ptype = kwargs.pop('ptype'). # Establish function to call (only energy makes sense for cbs); if ptype not in ['energy', 'gradient', 'hessian']:; raise ValidationError(""""""Wrapper complete_basis_set is unhappy to be calling function '%s' instead of 'energy'."""""" % ptype). optstash = p4util.OptionsState(; ['BASIS'],; ['WFN'],; ['WRITER_FILE_LABEL']). # Define some quantum chemical knowledge, namely what methods are subsumed in others. do_scf = True; do_corl = False; do_delta = False; do_delta2 = False; do_delta3 = False; do_delta4 = False; do_delta5 = False. user_writer_file_label = core.get_global_option('WRITER_FILE_LABEL'). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(); molstr = molecule.create_psi4_string_from_molecule(); natom = molecule.natom(). # Establish method for reference energy; cbs_scf_wfn = kwargs.pop('scf_wfn', 'hf').lower(). if do_scf:; if cbs_scf_wfn not in VARH.keys():; raise ValidationError(""""""Requested SCF method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_scf_wfn)). # Establish method for correlation energy; cbs_corl_wfn = kwargs.pop('corl_wfn', '').lower(); if cbs_corl_wfn:; do_corl = True. if do_corl:; if cbs_corl_wfn not in VARH.keys():; raise ValidationError(""""""Requested CORL method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_corl_wfn)). cbs_corl_wfn_lesser = kwargs.get('corl_wfn_lesser', cbs_scf_wfn).lower(); if cbs_corl_wfn_lesser not in VARH.keys():; raise ValidationError(""""""Requested CORL method lesser '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta_wfn_lesser)). # Establish method for delta correction energy; if 'delta_wfn' in kwargs:; do_delta = True; cbs_delta_wfn = kwargs['delta_wfn'].lower(); if cbs_delta_wfn not in VARH.keys():; raise",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver_cbs.html:31059,energy,energy,31059,psi4manual/1.1.0/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver_cbs.html,1,['energy'],['energy']
Energy Efficiency,"l.kwargs_lower(kwargs); return_wfn = kwargs.pop('return_wfn', False); verbose = kwargs.pop('verbose', 0); ptype = kwargs.pop('ptype'). # Establish function to call (only energy makes sense for cbs); if ptype not in ['energy', 'gradient', 'hessian']:; raise ValidationError(""""""Wrapper complete_basis_set is unhappy to be calling function '%s' instead of 'energy'."""""" % ptype). optstash = p4util.OptionsState(; ['BASIS'],; ['WFN'],; ['WRITER_FILE_LABEL']). # Define some quantum chemical knowledge, namely what methods are subsumed in others. do_scf = True; do_corl = False; do_delta = False; do_delta2 = False; do_delta3 = False; do_delta4 = False; do_delta5 = False. user_writer_file_label = psi4.get_global_option('WRITER_FILE_LABEL'). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', psi4.get_active_molecule()); molecule.update_geometry(); molstr = molecule.create_psi4_string_from_molecule(); natom = molecule.natom(). # Establish method for reference energy; cbs_scf_wfn = kwargs.pop('scf_wfn', 'hf').lower(). if do_scf:; if cbs_scf_wfn not in VARH.keys():; raise ValidationError(""""""Requested SCF method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_scf_wfn)). # Establish method for correlation energy; cbs_corl_wfn = kwargs.pop('corl_wfn', '').lower(); if cbs_corl_wfn:; do_corl = True. if do_corl:; if cbs_corl_wfn not in VARH.keys():; raise ValidationError(""""""Requested CORL method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_corl_wfn)). cbs_corl_wfn_lesser = kwargs.get('corl_wfn_lesser', cbs_scf_wfn).lower(); if cbs_corl_wfn_lesser not in VARH.keys():; raise ValidationError(""""""Requested CORL method lesser '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta_wfn_lesser)). # Establish method for delta correction energy; if 'delta_wfn' in kwargs:; do_delta = True; cbs_delta_wfn = kwargs['delta_wfn'].lower(); if cbs_delta_wfn not in VARH.keys():; raise",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:30706,energy,energy,30706,psi4manual/1.0.0/_modules/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html,1,['energy'],['energy']
Energy Efficiency,"l.set_multiplicity(mult1); psi4.print_out('\n\t==> IP Fitting SCF: Cation, Left Endpoint <==\n'); E1l = energy('scf'); psi4.IO.change_file_namespace(180,""ot"",""cation""). IPl = E1l - E0l;; kIPl = -E_HOMOl;; delta_l = IPl - kIPl;. if (IPl < kIPl):; psi4.print_out('\n***IP Fitting Error: Left Omega limit should have kIP < IP'); sys.exit(1). omegas.append(omega_l); types.append('Left Limit'); E0s.append(E0l); E1s.append(E1l); IPs.append(IPl); kIPs.append(kIPl). converged = False; repeat_l = 0;; repeat_r = 0;; step = 0;; while True:. step = step + 1;. # Regula Falsi (modified); if (repeat_l > 1):; delta_l = delta_l / 2.0;; if (repeat_r > 1):; delta_r = delta_r / 2.0;; omega = - (omega_r - omega_l) / (delta_r - delta_l) * delta_l + omega_l;; psi4.set_global_option('DFT_OMEGA',omega). # Neutral; psi4.IO.change_file_namespace(180,""neutral"",""ot""); mol.set_molecular_charge(charge0); mol.set_multiplicity(mult0); psi4.print_out('\n\t==> IP Fitting SCF: Neutral, Omega = %11.3E <==\n' % omega); E0 = energy('scf'); ref = psi4.wavefunction(); eps_a = ref.epsilon_a(); eps_b = ref.epsilon_b(); E_HOMO = 0.0;; if (Nb == 0):; E_HOMO = eps_a[int(Na-1)]; else:; E_a = eps_a[int(Na - 1)]; E_b = eps_b[int(Nb - 1)]; if (E_a >= E_b):; E_HOMO = E_a;; else:; E_HOMO = E_b;; psi4.IO.change_file_namespace(180,""ot"",""neutral""). # Cation; psi4.IO.change_file_namespace(180,""cation"",""ot""); mol.set_molecular_charge(charge1); mol.set_multiplicity(mult1); psi4.print_out('\n\t==> IP Fitting SCF: Cation, Omega = %11.3E <==\n' % omega); E1 = energy('scf'); psi4.IO.change_file_namespace(180,""ot"",""cation""). IP = E1 - E0;; kIP = -E_HOMO;; delta = IP - kIP;. if (kIP > IP):; omega_r = omega; E0r = E0; E1r = E1; IPr = IP; kIPr = kIP; delta_r = delta; repeat_r = 0;; repeat_l = repeat_l + 1;; else:; omega_l = omega; E0l = E0; E1l = E1; IPl = IP; kIPl = kIP; delta_l = delta; repeat_l = 0;; repeat_r = repeat_r + 1;. omegas.append(omega); types.append('Regula-Falsi'); E0s.append(E0); E1s.append(E1); IPs.append(IP); kIPs.a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/frac.html:16264,energy,energy,16264,psi4manual/4.0b5/_modules/frac.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/frac.html,2,['energy'],['energy']
Energy Efficiency,"l.upgrade_interventions(name). _filter_renamed_methods(""energy"", lowername). # * Avert pydantic anger at incomplete modelchem spec; userbas = core.get_global_option('BASIS') or kwargs.get('basis'); if lowername in integrated_basis_methods and userbas is None:; kwargs['basis'] = '(auto)'. # Are we planning?; plan = task_planner.task_planner(""energy"", lowername, molecule, **kwargs); logger.debug('ENERGY PLAN'); logger.debug(pp.pformat(plan.dict())). if kwargs.get(""return_plan"", False):; # Plan-only requested; return plan. elif not isinstance(plan, AtomicComputer):; # Advanced ""Computer"" active; plan.compute(); return plan.get_psi_results(return_wfn=return_wfn). else:; # We have unpacked to an AtomicInput; lowername = plan.method; basis = plan.basis; core.set_global_option(""BASIS"", basis). ## Second half of this fn -- entry means program running exactly analytic 0th derivative. # Commit to procedures['energy'] call hereafter; core.clean_variables(). #for precallback in hooks['energy']['pre']:; # precallback(lowername, **kwargs). # needed (+restore below) so long as AtomicComputer-s aren't run through json (where convcrit also lives); optstash = driver_util.negotiate_convergence_criterion((0, 0), lowername, return_optstash=True); optstash2 = p4util.OptionsState(['SCF', 'GUESS']). # Before invoking the procedure, we rename any file that should be read.; # This is a workaround to do restarts with the current PSI4 capabilities; # before actual, clean restarts are put in there; # Restartfile is always converted to a single-element list if; # it contains a single string; # DGAS Note: This is hacked together at this point and should be revamped.; if 'restart_file' in kwargs:; restartfile = kwargs['restart_file'] # Option still available for procedure-specific action; if not isinstance(restartfile, (list, tuple)):; restartfile = (restartfile, ); # Rename the files to be read to be consistent with psi4's file system; for item in restartfile:; is_numpy_file = (os.path.isfile(item",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html:38188,energy,energy,38188,psi4manual/1.7.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html,8,['energy'],['energy']
Energy Efficiency,"l2'),; 			 'Carbon Tetrachloride': ('Carbon Tetrachloride', 'carbon tetrachloride', 'CCl4'),; 			 'Benzene': ('Benzene', 'benzene', 'C6H6'),; 			 'Toluene': ('Toluene', 'toluene', 'C6H5CH3'),; 			 'Chlorobenzene': ('Chlorobenzene', 'chlorobenzene', 'C6H5Cl'),; 			 'Nitromethane': ('Nitromethane', 'nitromethane', 'CH3NO2'),; 			 'N-heptane': ('N-heptane', 'n-heptane', 'C7H16'),; 			 'Cyclohexane': ('Cyclohexane', 'cyclohexane', 'C6H12'),; 			 'Aniline': ('Aniline', 'aniline', 'C6H5NH2'),; 			 'Acetone': ('Acetone', 'acetone', 'C2H6CO'),; 			 'Tetrahydrofurane': ('Tetrahydrofurane', 'tetrahydrofurane', 'THF'),; 			 'Dimethylsulfoxide': ('Dimethylsulfoxide', 'dimethylsulfoxide', 'DMSO'),; 			 'Acetonitrile': ('Acetonitrile', 'acetonitrile', 'CH3CN'),; 			 'Explicit': ('Explicit', 'explicit')}; 	solvent = section.get('Solvent'); 	explicitSolvent = solvent.get() in allowedSolvents['Explicit']; 	if(explicitSolvent):; 		PRF = section.is_set('ProbeRadius'); 		GIF = section.is_set('Green<inside>'); 		GOF = section.is_set('Green<outside>'); 		if (not PRF):; 			print ""Error: Explicit solvent chosen but ProbeRadius not specified""; 		if (not GIF):; 			print ""Error: Explicit solvent chosen but Green<inside> not specified""; 		if (not GOF):; 			print ""Error: Explicit solvent chosen but Green<outside> not specified""; 		if (not GIF or not GOF or not PRF):; 			sys.exit(1); 	solventFound = False; 	for i, v in allowedSolvents.iteritems():; 		if (solvent.get() in v):; 			solventName = i; 			solventFound = True; 			break; 	if (not solventFound):; 		print ""Unknown solvent""; 		print ""Choose a solvent from the following list: ""; 		print allowedSolvents.keys(); 		print ""or specify the solvent data explicitly.""; 		sys.exit(1). correction = section.get('Correction'); 	if (correction.get() < 0.0):; 		print ""Correction for CPCM solver must be greater than 0.0""; 		sys.exit(1). 	convert_length_scalar(section.get('ProbeRadius')); 	radius = section.get('ProbeRadius'); 	if (radius.get() < 0.1 or radius",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/pcmpreprocess.html:4699,Green,Green,4699,psi4manual/4.0b5/_modules/pcmpreprocess.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/pcmpreprocess.html,1,['Green'],['Green']
Energy Efficiency,"l=None, dashparam=None, dertype=None, verbose=1)¶; Compute dispersion correction via Grimme’s DFTD3 program. Parameters:. func (Optional[str]) – Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Any or all parameters initialized; from dashcoeff[dashlvl][func] can be overwritten via; dashparam.; dashlvl (Optional[str]) – Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or “alias” or; “formal” to run.; dashparam (Optional[Dict]) – Values for the same keys as dashcoeff[dashlvl][‘default’]; used to override any or all values initialized by func.; Extra parameters will error.; dertype (Union[int, str, None]) – Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int) – Amount of printing. Returns:. energy (float) – When dertype=0, energy [Eh].; gradient (~numpy.ndarray) – When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ~numpy.ndarray) – When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. qcdb.Molecule.run_dftd4(self, func=None, dashlvl=None, dashparam=None, dertype=None, verbose=1)¶; Compute dispersion correction via Grimme’s DFTD4 program. Parameters:. func (Optional[str]) – Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Unlike run_dftd3, func overwrites any; parameter initialized via dashparam.; dashlvl (Optional[str]) – Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or “alias” or; “formal” to run.; dashparam (Optional[Dict]) – Values for the same keys as dashcoeff[dashlvl][‘default’]; used to provide custom values. Unlike run_dftd3, will not have; effect if func given. Must provide all parameters.; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/dftd3.html:14493,energy,energy,14493,psi4manual/1.7.x/dftd3.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/dftd3.html,8,['energy'],['energy']
Energy Efficiency,"l[""supersystem""]]]] = Field([], description=""Distribution of active n-body levels among model chemistry levels. All bodies in range [1, self.max_nbody] must be present exactly once. Number of items in outer list is how many different modelchems. Each inner list specifies what n-bodies to be run at the corresponding modelchem (e.g., `[[1, 2]]` has max_nbody=2 and 1-body and 2-body contributions computed at the same level of theory; `[[1], [2]]` has max_nbody=2 and 1-body and 2-body contributions computed at different levels of theory. An entry 'supersystem' means all higher order n-body effects up to the number of fragments. The n-body levels are effectively sorted in the outer list, and any 'supersystem' element is at the end."") # formerly nbody_list. embedding_charges: Dict[int, List[float]] = Field({}, description=""Atom-centered point charges to be used on molecule fragments whose basis sets are not included in the computation. Keys: 1-based index of fragment. Values: list of atom charges for that fragment.""). return_total_data: Optional[bool] = Field(None, description=""When True, returns the total data (energy/gradient/Hessian) of the system, otherwise returns interaction data. Default is False for energies, True for gradients and Hessians. Note that the calculation of total counterpoise corrected energies implies the calculation of the energies of monomers in the monomer basis, hence specifying ``return_total_data = True`` may carry out more computations than ``return_total_data = False``.""); quiet: bool = Field(False, description=""Whether to print/log formatted n-body energy analysis. Presently used by multi to suppress output. Candidate for removal from class once in-class/out-of-class functions sorted.""). task_list: Dict[str, SubTaskComputers] = {}. # Note that validation of user fields happens through typing and validator functions, so no class __init__ needed. @validator(""bsse_type"", pre=True); def set_bsse_type(cls, v):; if not isinstance(v, list):; v = [v",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html:33593,charge,charges,33593,psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html,2,['charge'],['charges']
Energy Efficiency,"l[""supersystem""]]]] = Field([], description=""Distribution of active n-body levels among model chemistry levels. All bodies in range [1, self.max_nbody] must be present exactly once. Number of items in outer list is how many different modelchems. Each inner list specifies what n-bodies to be run at the corresponding modelchem (e.g., `[[1, 2]]` has max_nbody=2 and 1-body and 2-body contributions computed at the same level of theory; `[[1], [2]]` has max_nbody=2 and 1-body and 2-body contributions computed at different levels of theory. An entry 'supersystem' means all higher order n-body effects up to the number of fragments. The n-body levels are effectively sorted in the outer list, and any 'supersystem' element is at the end."") # formerly nbody_list. embedding_charges: Dict[int, List[float]] = Field({}, description=""Atom-centered point charges to be used on molecule fragments whose basis sets are not included in the computation. Keys: 1-based index of fragment. Values: list of atom charges for that fragment.""). return_total_data: Optional[bool] = Field(None, description=""When True, returns the total data (energy/gradient/Hessian) of the system, otherwise returns interaction data. Default is False for energies, True for gradients and Hessians. Note that the calculation of total counterpoise corrected energies implies the calculation of the energies of monomers in the monomer basis, hence specifying ``return_total_data = True`` may carry out more computations than ``return_total_data = False``.""); quiet: bool = Field(False, description=""Whether to print/log formatted n-body energy analysis. Presently used by multi to suppress output. Candidate for removal from class once in-class/out-of-class functions sorted.""). task_list: Dict[str, SubTaskComputers] = {}. # Note that validation of user fields happens through typing and validator functions, so no class __init__ needed. [docs] @validator(""bsse_type"", pre=True); def set_bsse_type(cls, v):; if not isinstance(v, list):;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_nbody.html:33801,charge,charges,33801,psi4manual/1.7.x/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_nbody.html,2,['charge'],['charges']
Energy Efficiency,"l[""supersystem""]]]] = Field([], description=""Distribution of active n-body levels among model chemistry levels. All bodies in range [1, self.max_nbody] must be present exactly once. Number of items in outer list is how many different modelchems. Each inner list specifies what n-bodies to be run at the corresponding modelchem (e.g., `[[1, 2]]` has max_nbody=2 and 1-body and 2-body contributions computed at the same level of theory; `[[1], [2]]` has max_nbody=2 and 1-body and 2-body contributions computed at different levels of theory. An entry 'supersystem' means all higher order n-body effects up to the number of fragments. The n-body levels are effectively sorted in the outer list, and any 'supersystem' element is at the end."") # formerly nbody_list. embedding_charges: Dict[int, List[float]] = Field({}, description=""Atom-centered point charges to be used on molecule fragments whose basis sets are not included in the computation. Keys: 1-based index of fragment. Values: list of atom charges for that fragment.""). return_total_data: Optional[bool] = Field(None, description=""When True, returns the total data (energy/gradient/Hessian) of the system, otherwise returns interaction data. Default is False for energies, True for gradients and Hessians. Note that the calculation of total counterpoise corrected energies implies the calculation of the energies of monomers in the monomer basis, hence specifying ``return_total_data = True`` may carry out more computations than ``return_total_data = False``.""); quiet: bool = Field(False, description=""Whether to print/log formatted n-body energy analysis. Presently used by multi to suppress output. Candidate for removal from class once in-class/out-of-class functions sorted.""). task_list: Dict[str, SubTaskComputers] = {}. # Note that validation of user fields happens through typing and validator functions, so no class __init__ needed. [docs]; @validator(""bsse_type"", pre=True); def set_bsse_type(cls, v):; if not isinstance(v, list):",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:33878,charge,charges,33878,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,6,['charge'],['charges']
Energy Efficiency,"l[Dict] = None, dertype: Union[int, str, None] = None, verbose: int = 1):; """"""Compute dispersion correction via Grimme's DFTD4 program. Parameters; ----------; func; Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Unlike run_dftd3, ``func`` overwrites any; parameter initialized via `dashparam`.; dashlvl; Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in `dashcoeff` or ""alias"" or; ""formal"" to run.; dashparam; Values for the same keys as `dashcoeff[dashlvl]['default']`; used to provide custom values. Unlike run_dftd3, will not have; effect if `func` given. Must provide all parameters.; Extra parameters will error.; dertype; Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose; Amount of printing. Returns; -------; energy : float; When `dertype=0`, energy [Eh].; gradient : ndarray; When `dertype=1`, (nat, 3) gradient [Eh/a0].; (energy, gradient) : tuple of float and ndarray; When `dertype=None`, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; -----; This function wraps the QCEngine dftd4 harness which wraps the internal DFTD4 Python API.; As such, the upstream convention of `func` trumping `dashparam` holds, rather than the; :py:func:`run_dftd3` behavior of `dashparam` extending or overriding `func`. """"""; import qcengine as qcng. if dertype is None:; derint, derdriver = -1, 'gradient'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). resinp = {; 'molecule': self.to_schema(dtype=2),; 'driver': derdriver,; 'model': {; 'method': func,; 'basis': '(auto)',; },; 'keywords': {; 'verbose': verbose,; },; }; if dashlvl:; resinp['keywords']['level_hint'] = dashlvl; if dashparam:; resinp['keywords']['params_tweaks'] = dashparam. jobrec = qcng.compute(resinp, 'dftd4', raise_error=True); jobrec = ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:43365,energy,energy,43365,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,16,['energy'],['energy']
Energy Efficiency,"l[n]; continue. for k in range(1, n + 1):; take_nk = nCr(metadata['max_frag'] - k - 1, n - k); sign = ((-1)**(n - k)); value = nocp_energy_by_level[k]; nocp_energy_body_dict[n] += take_nk * sign * value. if metadata['ptype'] != 'energy':; value = nocp_ptype_by_level[k]; nocp_ptype_body_dict[n] += take_nk * sign * value. _print_nbody_energy(nocp_energy_body_dict, ""Non-Counterpoise Corrected (NoCP)"", metadata['embedding_charges']); nocp_interaction_energy = nocp_energy_body_dict[metadata['max_nbody']] - nocp_energy_body_dict[1]; nbody_dict['Non-Counterpoise Corrected Total Energy'] = nocp_energy_body_dict[metadata['max_nbody']]; nbody_dict['Non-Counterpoise Corrected Interaction Energy'] = nocp_interaction_energy. for n in nbody_range[1:]:; var_key = 'NOCP-CORRECTED %d-BODY INTERACTION ENERGY' % n; nbody_dict[var_key] = nocp_energy_body_dict[n] - nocp_energy_body_dict[1]. # Compute vmfc ptype; if 'vmfc' in metadata['bsse_type_list']:; if metadata['ptype'] != 'energy':; for n in nbody_range:; if n > 1:; vmfc_ptype_body_dict[n] = vmfc_ptype_by_level[n-1]; vmfc_ptype_body_dict[n] += vmfc_ptype_by_level[n]. _print_nbody_energy(vmfc_energy_body_dict, ""Valiron-Mayer Function Couterpoise (VMFC)"",; metadata['embedding_charges']); vmfc_interaction_energy = vmfc_energy_body_dict[metadata['max_nbody']] - vmfc_energy_body_dict[1]; nbody_dict['Valiron-Mayer Function Couterpoise Total Energy'] = vmfc_energy_body_dict[metadata['max_nbody']]; nbody_dict['Valiron-Mayer Function Couterpoise Interaction Energy'] = vmfc_interaction_energy. for n in nbody_range[1:]:; var_key = 'VMFC-CORRECTED %d-BODY INTERACTION ENERGY' % n; nbody_dict[var_key] = vmfc_energy_body_dict[n] - vmfc_energy_body_dict[1]. # Returns; results = {}; results['nbody'] = nbody_dict; for b in ['cp', 'nocp', 'vmfc']:; results['%s_energy_body_dict' % b] = eval('%s_energy_body_dict' % b); results['%s_energy_body_dict' % b] = {str(i) + b: j for i, j in results['%s_energy_body_dict' % b].items()}. # Figure out and build ret",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_nbody.html:26915,energy,energy,26915,psi4manual/1.3.2/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_nbody.html,1,['energy'],['energy']
Energy Efficiency,"l]):; row = beta_mo_idx(il[0][index] + offset); col = beta_mo_idx(il[1][index] + offset); if (abs(x) > ints_tolerance):; intdump.write('{:29.20E} {:4d} {:4d} {:4d} {:4d}\n'.format(x, row, col, 0, 0)); offset += block.shape[0]; # Additional one-electron integrals as requested in oe_ints; # Orbital energies; core.print_out('Writing orbital energies in FCIDUMP format to ' + fname + '\n'); if 'EIGENVALUES' in oe_ints:; alpha_eigs_dump = write_eigenvalues(wfn.epsilon_a().get_block(mo_slice).to_array(), alpha_mo_idx); beta_eigs_dump = write_eigenvalues(wfn.epsilon_b().get_block(mo_slice).to_array(), beta_mo_idx); intdump.write(alpha_eigs_dump + beta_eigs_dump); # Dipole integrals; #core.print_out('Writing dipole moment OEI in FCIDUMP format to ' + fname + '\n'); # Traceless quadrupole integrals; #core.print_out('Writing traceless quadrupole moment OEI in FCIDUMP format to ' + fname + '\n'); # Frozen core + nuclear repulsion energy; core.print_out('Writing frozen core + nuclear repulsion energy in FCIDUMP format to ' + fname + '\n'); e_fzc = ints.get_frozen_core_energy(); e_nuc = molecule.nuclear_repulsion_energy(wfn.get_dipole_field_strength()); intdump.write('{: 29.20E} {:4d} {:4d} {:4d} {:4d}\n'.format(e_fzc + e_nuc, 0, 0, 0, 0)); core.print_out('Done generating {} with integrals in FCIDUMP format.\n'.format(fname)). [docs]def write_eigenvalues(eigs, mo_idx):; """"""Prepare multi-line string with one-particle eigenvalues to be written to the FCIDUMP file.; """"""; eigs_dump = ''; iorb = 0; for h, block in enumerate(eigs):; for idx, x in np.ndenumerate(block):; eigs_dump += '{: 29.20E} {:4d} {:4d} {:4d} {:4d}\n'.format(x, mo_idx(iorb), 0, 0, 0); iorb += 1; return eigs_dump. [docs]def fcidump_from_file(fname):; """"""Function to read in a FCIDUMP file. :returns: a dictionary with FCIDUMP header and integrals; The key-value pairs are:; - 'norb' : number of basis functions; - 'nelec' : number of electrons; - 'ms2' : spin polarization of the system; - 'isym' : symmetry of state (if pr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/p4util/fcidump.html:7883,energy,energy,7883,psi4manual/1.2.1/_modules/psi4/driver/p4util/fcidump.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/p4util/fcidump.html,1,['energy'],['energy']
Energy Efficiency,"l]):; row = beta_mo_idx(il[0][index] + offset); col = beta_mo_idx(il[1][index] + offset); if (abs(x) > ints_tolerance):; intdump.write('{:29.20E} {:4d} {:4d} {:4d} {:4d}\n'.format(x, row, col, 0, 0)); offset += block.shape[0]; # Additional one-electron integrals as requested in oe_ints; # Orbital energies; core.print_out('Writing orbital energies in FCIDUMP format to ' + fname + '\n'); if 'EIGENVALUES' in oe_ints:; alpha_eigs_dump = write_eigenvalues(wfn.epsilon_a().get_block(mo_slice).to_array(), alpha_mo_idx); beta_eigs_dump = write_eigenvalues(wfn.epsilon_b().get_block(mo_slice).to_array(), beta_mo_idx); intdump.write(alpha_eigs_dump + beta_eigs_dump); # Dipole integrals; #core.print_out('Writing dipole moment OEI in FCIDUMP format to ' + fname + '\n'); # Traceless quadrupole integrals; #core.print_out('Writing traceless quadrupole moment OEI in FCIDUMP format to ' + fname + '\n'); # Frozen core + nuclear repulsion energy; core.print_out('Writing frozen core + nuclear repulsion energy in FCIDUMP format to ' + fname + '\n'); e_fzc = ints.get_frozen_core_energy(); e_nuc = molecule.nuclear_repulsion_energy(wfn.get_dipole_field_strength()); intdump.write('{: 29.20E} {:4d} {:4d} {:4d} {:4d}\n'.format(e_fzc + e_nuc, 0, 0, 0, 0)); core.print_out('Done generating {} with integrals in FCIDUMP format.\n'.format(fname)). [docs]def write_eigenvalues(eigs, mo_idx):; """"""Prepare multi-line string with one-particle eigenvalues to be written to the FCIDUMP file.; """"""; eigs_dump = ''; iorb = 0; for h, block in enumerate(eigs):; for idx, x in np.ndenumerate(block):; eigs_dump += '{: 29.20E} {:4d} {:4d} {:4d} {:4d}\n'.format(x, mo_idx(iorb), 0, 0, 0); iorb += 1; return eigs_dump. def _irrep_map(wfn):; """"""Returns an array of irrep indices that maps from Psi4's ordering convention to the standard FCIDUMP convention.; """"""; symm = wfn.molecule().point_group().symbol(); psi2dump = {'c1' : [1], # A; 'ci' : [1,2], # Ag Au; 'c2' : [1,2], # A B; 'cs' : [1,2], # A' A""; 'd2' : [1,4,3,2], # A B1",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/fcidump.html:8092,energy,energy,8092,psi4manual/1.3.2/_modules/psi4/driver/p4util/fcidump.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/fcidump.html,3,['energy'],['energy']
Energy Efficiency,"l_atoms[rTo].symbol() == 'X':; rval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; self.full_atoms[rTo], rval)). # handle third line of Zmat; elif len(entries) == 5:; zmatrix = True; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); aTo = self.get_anchor_atom(entries[3], line); if aTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[3])); if aTo == rTo:; raise ValidationError(""Atom used multiple times on line %s."" % (line)); rval = self.get_coord_value(entries[2]); aval = self.get_coord_value(entries[4]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True); if self.full_atoms[aTo].symbol() == 'X':; aval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; self.full_atoms[rTo], rval, \; self.full_atoms[aTo], aval)). # handle fourth line of Zmat; elif len(entries) == 7:; zmatrix = True; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); aTo = self.get_anchor_atom(entries[3], line); if aTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[3])); dTo = self.get_anchor_atom(entries[5], line); if dTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[5])); if aTo == rTo or rTo == dTo or aTo == dTo: # for you star wars fans; raise ValidationError(""Atom used multiple times on line %s"" % (line)). rval = self.get_coord_value(entries[2]); aval = self.get_coord_value(entries[4]); dval = self.get_coord_value(entries[6]). ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:19892,charge,charge,19892,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,2,['charge'],['charge']
Energy Efficiency,"l_basis='cc-pV[DT]Z', corl_scheme='corl_xtpl_helgaker_2'). """"""; if type(valueLO) != type(valueHI):; raise ValidationError(; f""corl_xtpl_helgaker_2: Inputs must be of the same datatype! ({type(valueLO)}, {type(valueHI)})""). if alpha is None:; alpha = 3.0. if isinstance(valueLO, float):; value = (valueHI * zHI**alpha - valueLO * zLO**alpha) / (zHI**alpha - zLO**alpha); beta = (valueHI - valueLO) / (zHI**(-alpha) - zLO**(-alpha)). final = value; if verbose:; # Output string with extrapolation parameters; cbsscheme = f""""""\n\n ==> Helgaker 2-point correlated extrapolation for method: {functionname.upper()} <==\n\n""""""; cbsscheme += """""" LO-zeta (%s) Energy: % 16.12f\n"""""" % (str(zLO), valueLO); cbsscheme += """""" HI-zeta (%s) Energy: % 16.12f\n"""""" % (str(zHI), valueHI); cbsscheme += """""" Alpha (exponent) Value: % 16.12f\n"""""" % alpha; cbsscheme += f"""""" Beta (coefficient) Value: {beta: 16.12f}\n\n""""""; cbsscheme += """""" Extrapolated Energy: % 16.12f\n\n"""""" % value; # Note that in energy-only days, this used to print SCF and Correlation, not Total, Energy. name_str = ""%s/(%s,%s)"" % (functionname.upper(), _zeta_val2sym[zLO].upper(), _zeta_val2sym[zHI].upper()); cbsscheme += """""" @Extrapolated """"""; cbsscheme += name_str + ':'; cbsscheme += "" "" * (19 - len(name_str)); cbsscheme += """"""% 16.12f\n\n"""""" % final; core.print_out(cbsscheme); logger.debug(cbsscheme). return final. elif isinstance(valueLO, np.ndarray):. value = (valueHI * zHI**alpha - valueLO * zLO**alpha) / (zHI**alpha - zLO**alpha); beta = (valueHI - valueLO) / (zHI**(-alpha) - zLO**(-alpha)). if verbose > 2:; cbsscheme = f""""""\n ==> Helgaker 2-point correlated extrapolation for method: {functionname.upper()} <==\n""""""; cbsscheme += f""""""\n LO-zeta ({zLO}) Data\n""""""; cbsscheme += nppp(valueLO); cbsscheme += f""""""\n HI-zeta ({zHI}) Data\n""""""; cbsscheme += nppp(valueHI). cbsscheme += f""""""\n Alpha (exponent) Value: {alpha:16.8f}""""""; cbsscheme += f""""""\n Beta Data\n""""""; cbsscheme += nppp(beta); cbsscheme += f""""""\n Extrapolated Data\n""""",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs_helper.html:19820,energy,energy-only,19820,psi4manual/1.6.x/_modules/psi4/driver/driver_cbs_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs_helper.html,15,"['Energy', 'energy']","['Energy', 'energy-only']"
Energy Efficiency,"l_data = True``; may carry out more computations than ``return_total_data = False``.; For gradients and Hessians, ``return_total_data = False`` is rarely useful. :type levels: dict; :param levels: ``{1: 'ccsd(t)', 2: 'mp2', 'supersystem': 'scf'}`` || ``{1: 2, 2: 'ccsd(t)', 3: 'mp2'}`` || etc. Dictionary of different levels of theory for different levels of expansion; Note that method_string is not used in this case. ``supersystem`` computes; all higher order n-body effects up to the number of fragments. :type embedding_charges: dict; :param embedding_charges: ``{1: [-0.834, 0.417, 0.417], ..}``. Dictionary of atom-centered point charges. keys: 1-based index of fragment, values: list of charges for each fragment.; Add atom-centered point charges for fragments whose basis sets are not included in the computation. """"""; pass. class BsseEnum(str, Enum):; """"""Available basis-set superposition error (BSSE) treatments."""""". nocp = ""nocp"" # plain supramolecular interaction energy; cp = ""cp"" # counterpoise correction; vmfc = ""vmfc"" # Valiron-Mayer function counterpoise. def _sum_cluster_ptype_data(; ptype: DriverEnum,; ptype_dict: Dict,; compute_list: Set[FragBasIndex],; fragment_slice_dict: Dict[int, Sequence],; fragment_size_dict: Dict[int, int],; mc_level_lbl: int,; vmfc: bool = False,; nb: int = 0,; ) -> Union[float, np.ndarray]:; """"""; Sum arrays from n-body computations to obtain the BSSE corrected or uncorrected scalar or array. Parameters; ----------; ptype; Hint to shape of array data to sum.; ptype_dict; Dictionary containing computed energy, gradient, or Hessian obtained from each subsystem computation; compute_list; A list of (frag, bas) tuples notating all the required computations.; fragment_slice_dict; Dictionary containing slices that index the gradient or Hessian matrix for each of the 1-indexed fragments.; For He--HOOH--Me cluster, `{1: slice(0, 1, None), 2: slice(1, 5, None), 3: slice(5, 10, None)}`.; fragment_size_dict; Dictionary containing the number of atom",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html:10781,energy,energy,10781,psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html,2,['energy'],['energy']
Energy Efficiency,"l_data: :ref:`boolean <op_py_boolean>`; :param return_total_data: ``'on'`` || |dl| ``'off'`` |dr|. If True returns the total data (energy/gradient/Hessian) of the system,; otherwise returns interaction data. Default is ``'off'`` for energies,; ``'on'`` for gradients and Hessians. Note that the calculation of total; counterpoise corrected energies implies the calculation of the energies of; monomers in the monomer basis, hence specifying ``return_total_data = True``; may carry out more computations than ``return_total_data = False``. :type levels: dict; :param levels: ``{1: 'ccsd(t)', 2: 'mp2', 'supersystem': 'scf'}`` || ``{1: 2, 2: 'ccsd(t)', 3: 'mp2'}`` || etc. Dictionary of different levels of theory for different levels of expansion; Note that method_string is not used in this case. ``supersystem`` computes; all higher order n-body effects up to the number of fragments. :type embedding_charges: dict; :param embedding_charges: ``{1: [-0.834, 0.417, 0.417], ..}``. Dictionary of atom-centered point charges. keys: 1-based index of fragment, values: list of charges for each fragment. :type charge_method: str; :param charge_method: ``scf/6-31g`` || ``b3lyp/6-31g*`` || etc. Method to compute point charges for monomers. Overridden by ``embedding_charges``; if both are provided. :type charge_type: str; :param charge_type: ``MULLIKEN_CHARGES`` || ``LOWDIN_CHARGES``. Default is ``MULLIKEN_CHARGES``; """""". # Initialize dictionaries for easy data passing; metadata, component_results, nbody_results = {}, {}, {}. # Parse some kwargs; kwargs = p4util.kwargs_lower(kwargs); if kwargs.get('levels', False):; return driver_nbody_helper.multi_level(func, **kwargs); metadata['ptype'] = kwargs.pop('ptype', None); metadata['return_wfn'] = kwargs.pop('return_wfn', False); metadata['return_total_data'] = kwargs.pop('return_total_data', None); metadata['molecule'] = kwargs.pop('molecule', core.get_active_molecule()); metadata['molecule'].update_geometry(); metadata['molecule'].fix_com(True); ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html:6715,charge,charges,6715,psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html,4,['charge'],['charges']
Energy Efficiency,"l_file_from_scf_type. from .exceptions import *. [docs]def fcidump(wfn, fname='INTDUMP', oe_ints=None):; """"""Save integrals to file in FCIDUMP format as defined in Comp. Phys. Commun. 54 75 (1989); Additional one-electron integrals, including orbital energies, can also be saved.; This latter format can be used with the HANDE QMC code but is not standard. :returns: None. :raises: ValidationError when SCF wavefunction is not RHF. :type wfn: :py:class:`~psi4.core.Wavefunction`; :param wfn: set of molecule, basis, orbitals from which to generate cube files; :param fname: name of the integrals file, defaults to INTDUMP; :param oe_ints: list of additional one-electron integrals to save to file.; So far only EIGENVALUES is a valid option. :examples:. >>> # [1] Save one- and two-electron integrals to standard FCIDUMP format; >>> E, wfn = energy('scf', return_wfn=True); >>> fcidump(wfn). >>> # [2] Save orbital energies, one- and two-electron integrals.; >>> E, wfn = energy('scf', return_wfn=True); >>> fcidump(wfn, oe_ints=['EIGENVALUES']). """"""; # Get some options; reference = core.get_option('SCF', 'REFERENCE'); ints_tolerance = core.get_global_option('INTS_TOLERANCE'); # Some sanity checks; if reference not in ['RHF', 'UHF']:; raise ValidationError('FCIDUMP not implemented for {} references\n'.format(reference)); if oe_ints is None:; oe_ints = []. molecule = wfn.molecule(); docc = wfn.doccpi(); frzcpi = wfn.frzcpi(); frzvpi = wfn.frzvpi(); active_docc = docc - frzcpi; active_socc = wfn.soccpi(); active_mopi = wfn.nmopi() - frzcpi - frzvpi. nbf = active_mopi.sum() if wfn.same_a_b_orbs() else 2 * active_mopi.sum(); nirrep = wfn.nirrep(); nelectron = 2 * active_docc.sum() + active_socc.sum(). core.print_out('Writing integrals in FCIDUMP format to ' + fname + '\n'); # Generate FCIDUMP header; header = '&FCI\n'; header += 'NORB={:d},\n'.format(nbf); header += 'NELEC={:d},\n'.format(nelectron); header += 'MS2={:d},\n'.format(wfn.nalpha() - wfn.nbeta()); header += 'UHF=.{}.,\n'.form",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/p4util/fcidump.html:2383,energy,energy,2383,psi4manual/1.2.1/_modules/psi4/driver/p4util/fcidump.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/p4util/fcidump.html,1,['energy'],['energy']
Energy Efficiency,"l_gradient(save_fock, ...); docstring. compute_spin_contamination(self); docstring. cphf_Hx(self, arg0); CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self); Adds occupied guess alpha orbitals. cphf_solve(self, x_vec, conv_tol, max_iter); Solves the CPHF equations for a given set of x vectors. damping_update(self, arg0); docstring. deep_copy(self, arg0); Deep copies the internal data. del_array_variable(self, arg0); Removes the requested (case-insensitive) Matrix QC variable. del_potential_variable(self, arg0); Removes the requested (case-insensitive) ExternalPotential QC variable. del_scalar_variable(self, arg0); Removes the requested (case-insensitive) double QC variable. del_variable(key); Removes scalar or array QCVariable key from cls if present. density_fitted(self); Returns whether this wavefunction was obtained using density fitting or not. diis(self, arg0); docstring. doccpi(self); Returns the number of doubly occupied orbitals per irrep. efzc(self); Returns the frozen-core energy. energy(self); Returns the Wavefunction's energy. epsilon_a(self); Returns the Alpha Eigenvalues. epsilon_a_subset(self, basis, subset); Returns the requested Alpha orbital energies subset. epsilon_b(self); Returns the Beta Eigenvalues. epsilon_b_subset(self, basis, subset); Returns the requested Beta orbital energies subset. esp_at_nuclei(self); returns electrostatic potentials at nuclei. external_pot(self); Gets the requested external potential. finalize(self); Cleans up the the Wavefunction's temporary data. finalize_energy(); Performs stability analysis and calls back SCF with new guess if needed, Returns the SCF energy. find_occupation(self); docstring. force_doccpi(self, arg0); Specialized expert use only. force_soccpi(self, arg0); Specialized expert use only. form_C(self[, shift]); Forms the Orbital Matrices from the current Fock Matrices. form_D(self); Forms the Density Matrices from the current Orbitals Matrices. form_F(self); Forms the F matrix. form_FDS",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.CUHF.html:4217,energy,energy,4217,psi4manual/1.6.x/api/psi4.core.CUHF.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.CUHF.html,8,['energy'],['energy']
Energy Efficiency,"l_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the delta correction; to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in delta_basis and xtpl_highest_1() otherwise. delta2_scheme (function) – xtpl_highest_1 || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the second delta correction; to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in delta2_basis and xtpl_highest_1() otherwise. delta3_scheme (function) – xtpl_highest_1 || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the third delta correction; to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in delta3_basis and xtpl_highest_1() otherwise. delta4_scheme (function) – xtpl_highest_1 || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the fourth delta correction; to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in delta4_basis and xtpl_highest_1() otherwise. delta5_scheme (function) – xtpl_highest_1 || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the fifth delta correction; to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in delta5_basis and xtpl_highest_1() otherwise. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> cbs(name='scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> cbs(name='mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> cbs(name='scf', scf_basis='cc-pV[DTQ]Z', scf_sch",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/cbs-1.html:8906,energy,energy,8906,psi4manual/1.0.0/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/cbs-1.html,2,['energy'],['energy']
Energy Efficiency,"l_invert(self); Computes the inverse of any nonsingular matrix using LU factorization. get(*args, **kwargs); Overloaded function. get_block(self, rows, cols); Get a matrix block. hermitivitize(self); Average off-diagonal element in-place. hermitize(self); Makes a real matrix symmetric by averaging the matrix and its transpose. identity(self); Sets the matrix to the identity. invert(self); Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs); Overloaded function. load_mpqc(self, filename); Loads a matrix from an ASCII file in MPQC format. nirrep(self); Returns the number of irreps. np_read(filename[, prefix]); Reads the data from a NumPy compress file. np_write([filename, prefix]); Writes the irreped matrix to a NumPy zipped file. partial_cholesky_factorize(self, delta, …); Computes the fully pivoted partial Cholesky factorization of a real symmetric positive semidefinite matrix, to numerical precision delta. power(self, alpha, cutoff); Takes the matrix to the alpha power with precision cutoff. print_atom_vector(self, RMRoutfile); Print the matrix with atom labels, assuming it is an natom X 3 tensor. print_out(self); Prints the matrix to the output file. pseudoinverse(self, condition, nremoved); Computes the matrix which is the conditioned pseudoinverse of this matrix. remove_symmetry(self, a, transformer); Remove symmetry from a matrix A with PetiteList::sotoao(). rms(self); Returns the rms of this matrix. rotate_columns(self, h, i, j, theta); Rotates columns i and j in irrep h by angle theta. rowdim(self); Returns the rows per irrep array. rows(self, h); Returns the rows in irrep h. save(self, filename, append, …); Saves the matrix in ASCII format to filename, as symmetry blocks or full matrix. scale(self, a); Scales the matrix by the floating point value a. scale_column(self, h, n, a); Scales column n of irrep h by a. scale_row(self, h, m, a); Scales row m of irrep h by a. schmidt(self); Calls the libqt schmidt function. set(*arg",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.matrix.html:3222,power,power,3222,psi4manual/1.3.2/api/psi4.core.matrix.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.matrix.html,6,['power'],['power']
Energy Efficiency,"l_option(""PARENT_SYMMETRY"", """"); optstash.restore(); optstash_conv.restore(). _hessian_write(wfn). if return_wfn:; return (wfn.hessian(), wfn); else:; return wfn.hessian(). [docs]def frequency(name, **kwargs):; r""""""Function to compute harmonic vibrational frequencies. :aliases: frequencies(), freq(). :returns: *float* |w--w| Total electronic energy in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``freq_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: |dl| ``'hessian'`` |dr| || ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available- they're not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. :type irrep: int or str; :param irrep: |dl| ``-1`` |dr| || ``1`` || ``'b2'`` || ``'App'`` || etc. Indicates which symmetry block (:ref:`Cotton <table:irrepOrd",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:82726,energy,energy,82726,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,4,['energy'],['energy']
Energy Efficiency,"l_option('SCF_TYPE', 'DISK_DF'); core.print_out("""""" Method '%s' requires SCF_TYPE = DISK_DF, setting.\n"""""" % name); elif core.get_global_option('SCF_TYPE') == ""DF"":; core.set_global_option('SCF_TYPE', 'DISK_DF'); core.print_out("""""" Method '%s' requires SCF_TYPE = DISK_DF, setting.\n"""""" % name); else:; if core.get_global_option('SCF_TYPE') != ""DISK_DF"":; raise ValidationError("" %s requires SCF_TYPE = DISK_DF, please use SCF_TYPE = DF to automatically choose the correct DFJK implementation."" % name). def print_ci_results(ciwfn, rname, scf_e, ci_e, print_opdm_no=False):; """"""; Printing for all CI Wavefunctions; """""". # Print out energetics; core.print_out(""\n ==> Energetics <==\n\n""); core.print_out("" SCF energy = %20.15f\n"" % scf_e); if ""CI"" in rname:; core.print_out("" Total CI energy = %20.15f\n"" % ci_e); elif ""MP"" in rname:; core.print_out("" Total MP energy = %20.15f\n"" % ci_e); elif ""ZAPT"" in rname:; core.print_out("" Total ZAPT energy = %20.15f\n"" % ci_e); else:; core.print_out("" Total MCSCF energy = %20.15f\n"" % ci_e). # Nothing to be done for ZAPT or MP; if (""MP"" in rname) or (""ZAPT"" in rname):; core.print_out(""\n""); return. # Initial info; ci_nroots = core.get_option(""DETCI"", ""NUM_ROOTS""); irrep_labels = ciwfn.molecule().irrep_labels(). # Grab the D-vector; dvec = ciwfn.D_vector(); dvec.init_io_files(True). for root in range(ci_nroots):; core.print_out(""\n ==> %s root %d information <==\n\n"" % (rname, root)). # Print total energy; root_e = core.get_variable(""CI ROOT %d TOTAL ENERGY"" % (root)); core.print_out("" %s Root %d energy = %20.15f\n"" % (rname, root, root_e)). # Print natural occupations; if print_opdm_no:; core.print_out(""\n Active Space Natural occupation numbers:\n\n""). occs_list = []; r_opdm = ciwfn.get_opdm(root, root, ""SUM"", False); for h in range(len(r_opdm.nph)):; if 0 in r_opdm.nph[h].shape:; continue; nocc, rot = np.linalg.eigh(r_opdm.nph[h]); for e in nocc:; occs_list.append((e, irrep_labels[h])). occs_list.sort(key=lambda x: -x[0]). cnt = 0; for v",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc_util.html:5265,energy,energy,5265,psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc_util.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc_util.html,1,['energy'],['energy']
Energy Efficiency,"l_option('SCF_TYPE', 'DISK_DF'); core.print_out("""""" Method '%s' requires SCF_TYPE = DISK_DF, setting.\n"""""" % name); elif core.get_global_option('SCF_TYPE') == ""DF"":; core.set_global_option('SCF_TYPE', 'DISK_DF'); core.print_out("""""" Method '%s' requires SCF_TYPE = DISK_DF, setting.\n"""""" % name); else:; if core.get_global_option('SCF_TYPE') != ""DISK_DF"":; raise ValidationError("" %s requires SCF_TYPE = DISK_DF, please use SCF_TYPE = DF to automatically choose the correct DFJK implementation."" % name). def print_ci_results(ciwfn, rname, scf_e, ci_e, print_opdm_no=False):; """"""; Printing for all CI Wavefunctions; """""". # Print out energetics; core.print_out(""\n ==> Energetics <==\n\n""); core.print_out("" SCF energy = %20.15f\n"" % scf_e); if ""CI"" in rname:; core.print_out("" Total CI energy = %20.15f\n"" % ci_e); elif ""MP"" in rname:; core.print_out("" Total MP energy = %20.15f\n"" % ci_e); elif ""ZAPT"" in rname:; core.print_out("" Total ZAPT energy = %20.15f\n"" % ci_e); else:; core.print_out("" Total MCSCF energy = %20.15f\n"" % ci_e). # Nothing to be done for ZAPT or MP; if (""MP"" in rname) or (""ZAPT"" in rname):; core.print_out(""\n""); return. # Initial info; ci_nroots = core.get_option(""DETCI"", ""NUM_ROOTS""); irrep_labels = ciwfn.molecule().irrep_labels(). # Grab the D-vector; dvec = ciwfn.D_vector(); dvec.init_io_files(True). for root in range(ci_nroots):; core.print_out(""\n ==> %s root %d information <==\n\n"" % (rname, root)). # Print total energy; root_e = core.variable(""CI ROOT %d TOTAL ENERGY"" % (root)); core.print_out("" %s Root %d energy = %20.15f\n"" % (rname, root, root_e)). # Print natural occupations; if print_opdm_no:; core.print_out(""\n Active Space Natural occupation numbers:\n\n""). occs_list = []; r_opdm = ciwfn.get_opdm(root, root, ""SUM"", False); for h in range(len(r_opdm.nph)):; if 0 in r_opdm.nph[h].shape:; continue; nocc, rot = np.linalg.eigh(r_opdm.nph[h]); for e in nocc:; occs_list.append((e, irrep_labels[h])). occs_list.sort(key=lambda x: -x[0]). cnt = 0; for value",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc_util.html:5134,energy,energy,5134,psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc_util.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc_util.html,1,['energy'],['energy']
Energy Efficiency,"labels. is_variable(self, arg0); Checks if variable arg0 is in the structural variables list. label(self, atom); Gets the original label of the atom as given in the input file (C2, H4)(0-indexed without dummies). mass(self, atom); Returns mass of atom (0-indexed). mass_number(self, arg0); Mass number (A) of atom if known, else -1. molecular_charge(self); Gets the molecular charge. move_to_com(self); Moves molecule to center of mass. multiplicity(self); Gets the multiplicity (defined as 2Ms + 1). nallatom(self); Number of real and dummy atoms. name(self); Gets molecule name. natom(self); Number of real atoms. nfragments(self); Gets the number of fragments in the molecule. nuclear_dipole(*args, **kwargs); Overloaded function. nuclear_repulsion_energy(self, dipole_field, …); Computes nuclear repulsion energy. nuclear_repulsion_energy_deriv1(self, …); Returns first derivative of nuclear repulsion energy as a matrix (natom, 3). nuclear_repulsion_energy_deriv2(self); Returns second derivative of nuclear repulsion energy as a matrix (natom X 3, natom X 3). orientation_fixed(self); Get whether or not orientation is fixed. point_group(self); Returns the current point group object. print_bond_angles(self); Print the bond angle geometrical parameters. print_cluster(self); Prints the molecule in Cartesians in input units adding fragment separators. print_distances(self); Print the interatomic distance geometrical parameters. print_in_input_format(self); Prints the molecule as Cartesian or ZMatrix entries, just as inputted. print_out(self); Prints the molecule in Cartesians in input units to output file. print_out_in_angstrom(self); Prints the molecule in Cartesians in Angstroms to output file. print_out_in_bohr(self); Prints the molecule in Cartesians in Bohr to output file. print_out_of_planes(self); Print the out-of-plane angle geometrical parameters to output file. print_rotational_constants(self); Print the rotational constants to output file. provenance(self); Gets molecule",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.molecule.html:5660,energy,energy,5660,psi4manual/1.3.2/api/psi4.core.molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.molecule.html,3,['energy'],['energy']
Energy Efficiency,"lable errors. This is the; defining insight of DLPNO-MP2 and all related “local correlation” methods.; The DLPNO-MP2 code is a linear-scaling alternative to the DF-MP2; code, and is intended for use with large systems for which DF-MP2 is intractable.; When running DLPNO-MP2 with default settings, approximately 99.9% of the DF-MP2; correlation energy is recovered. The general outline of the method is as follows:. Localize the active occupied MOs (with the Foster-Boys method); Construct projected AOs (PAOs) from the virtual MOs; Calculate three-index integrals in the (sparse) LMO/PAO basis; Perform local density fitting to construct (sparse) exchange integrals; Transform local virtuals from PAOs to pair natural orbitals (PNOs), and truncate; Solve the iterative local MP2 equations in the LMO/PNO basis. An example input file is:; molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; symmetry c1; }. set basis cc-pvdz; set scf_type df; set freeze_core True; set pno_convergence normal. energy('dlpno-mp2'). The main difference between this input and a DF-MP2 input is the energy('dlpno-mp2'); call to energy(). The only other addition is the PNO_CONVERGENCE; keyword, which determines the accuracy of the local approximations underlying; the DLPNO-MP2 method. Note that the water molecule in this example is not large; enough for DLPNO-MP2 to be of any benefit relative to DF-MP2.; The theory of the DLPNO-MP2 method and practical recommendations for using the; code are presented below. Theory¶; See DF-MP2 for background on the theory of (non-local); density-fitted MP2. PSI4‘s DLPNO-MP2 implementation is based on the; manuscript by Pinski et al. [Pinski:2015:034108].; In DLPNO-MP2, as in all local MP2 methods, the second-order MBPT energy is determined; variationally via the Hylleraas functional [Hylleraas:1930:209]:. (1)¶\[E^{(2)} = 2 \langle \Psi_{0}^{(0)} | \hat{H} - E_{0}^{(0)} | \Psi_{0}^{(1)} \rangle - \langle \Psi_{0}^{(1)} | \hat{H}^{(0)} - E_{0}^{(0)} | \Psi_{0}^{(1)} \rangle ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/dlpnomp2-1.html:2265,energy,energy,2265,psi4manual/1.5.0/dlpnomp2-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/dlpnomp2-1.html,7,['energy'],['energy']
Energy Efficiency,"laced ozone, with Z-matrix input. omp2-2; OMP2 cc-pVDZ energy with ROHF initial guess orbitals for the NO radical. cc33; CC3(UHF)/cc-pVDZ H2O \(R_e\) geom from Olsen et al., JCP 104, 8007 (1996). pywrap-freq-e-sowreap; Finite difference of energies frequency, run in sow/reap mode. cc51; EOM-CC3/cc-pVTZ on H2O. opt12; SCF cc-pVDZ geometry optimzation of ketene, starting from bent structure. molden1; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. psimrcc-ccsd_t-3; Mk-MRCCSD(T) single point. \(^1A_1\) CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. cc5; RHF CCSD(T) aug-cc-pvtz frozen-core energy of C4NH4 Anion. mints8; Patch of a glycine with a methyl group, to make alanine, then DF-SCF energy calculation with the cc-pVDZ basis set. psimrcc-fd-freq2; Mk-MRCCSD frequencies. \(^1A_1\) O$_3` state described using the Ms = 0 component of the singlet. Uses TCSCF orbitals. cepa0-grad2; CEPA cc-pVDZ gradient for the NO radical. tu6-cp-ne2; Example potential energy surface scan and CP-correction for Ne2. sapt7; SAPT0 open-shell computation of H2O-HO2 interaction energy First with cc-pVDZ and density fitted integrals with UHF Then with 6-31g and direct integrals, except for dispersion that is computed with cc-pVDZ-ri density fitting with UHF. scf-bs; UHF and broken-symmetry UHF energy for molecular hydrogen. fci-tdm; He2+ FCI/cc-pVDZ Transition Dipole Moment. omp2p5-grad2; OMP2.5 cc-pVDZ gradient for the NO radical. fci-h2o-fzcv; 6-31G H2O Test FCI Energy Point. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Test Suite and Sample Inputs. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Create",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodoc_testsuite_corepsi4-1.html:34421,energy,energy,34421,psi4manual/1.1.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodoc_testsuite_corepsi4-1.html,2,['energy'],['energy']
Energy Efficiency,"laced with 'dct'.""). [docs]def energy(name, **kwargs):; r""""""Function to compute the single-point electronic energy. :returns: *float* |w--w| Total electronic energy in Hartrees. SAPT & EFP return interaction energy. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY`; * :psivar:`CURRENT REFERENCE ENERGY`; * :psivar:`CURRENT CORRELATION ENERGY`. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple. :type write_orbitals: str, :ref:`boolean <op_py_boolean>`; :param write_orbitals: ``filename`` || |dl| ``'on'`` |dr| || ``'off'`` . (str) Save wfn containing current orbitals to the given file name after each SCF iteration; and retain after |PSIfour| finishes. (:ref:`boolean <op_py_boolean>`) Turns writing the orbitals after the converged SCF on/off.; Orbital file will be deleted unless |PSIfour| is called with `-m` flag. :type restart_file: str; :param restart_file: ``['file.1, file.32]`` || ``./file`` || etc. Existing files to be renamed and copied for calculation restart, e.g. a serialized wfn or module-specific binary data. .. _`table:energy_gen`:. +-------------------------+---------------------------------------------------------------------------------------------------------------+; | name | calls method |; +=========================+====================================================================================================",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:8519,energy,energy,8519,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,6,['energy'],['energy']
Energy Efficiency,"laced with 'dct'.""). [docs]def energy(name, **kwargs):; r""""""Function to compute the single-point electronic energy. :returns: *float* |w--w| Total electronic energy in Hartrees. SAPT & EFP return interaction energy. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY`; * :psivar:`CURRENT REFERENCE ENERGY`; * :psivar:`CURRENT CORRELATION ENERGY`. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple. :type write_orbitals: str, :ref:`boolean <op_py_boolean>`; :param write_orbitals: ``filename`` || |dl| ``'on'`` |dr| || ``'off'`` . (str) Save wfn containing current orbitals to the given file name after each SCF iteration; and retain after |PSIfour| finishes. (:ref:`boolean <op_py_boolean>`) Turns writing the orbitals after the converged SCF on/off.; Orbital file will be deleted unless |PSIfour| is called with `-m` flag. :type restart_file: str; :param restart_file: ``['file.1, file.32]`` || ``./file`` || etc. Existing files to be renamed and copied for calculation restart, e.g. a serialized wfn or module-specific binary data. .. _`table:energy_gen`:. +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | name | calls method |; +=========================+============================================================================",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html:3981,energy,energy,3981,psi4manual/1.7.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html,2,['energy'],['energy']
Energy Efficiency,"lacing any “.in” or “.dat” extension by “.out”). Sample Input Files¶; Below, we will provide a few simple input files as examples. A large; number of sample input files, covering everything from single-point energies; using density-functional theory to response properties from coupled-cluster; theory, can be found in the psi4/samples directory. Running a Basic Hartree–Fock Calculation¶; In our first example, we will consider a Hartree–Fock SCF computation; for the water molecule using a cc-pVDZ basis set. We will specify the; geometry of our water molecule using a standard Z-matrix.; # Any line starting with the # character is a comment line; #! Sample HF/cc-pVDZ H2O computation. memory 600 mb. molecule h2o {; O ; H 1 0.96; H 1 0.96 2 104.5; }. set basis cc-pVDZ; energy('scf'). Note; The memory and basis set specifications are placed before the; energy function is called. Any user options need to; be set before the procedure they are meant to affect. For your convenience, the above example can be found in; tu1-h2o-energy.; You can run it if you wish.; Once PSI4 is in your path (see the; User Configuration; section of the installation instructions), you can run this computation by typing; 1>>> psi4 input.dat output.dat. If everything goes well, the computation should complete and should report; a final restricted Hartree–Fock energy in a section like this:; 1; 2; 3Energy converged. @RHF Final Energy: -76.02663273410671. By default, the energy should be converged to about \(1.0 \times 10^{-6}\), so agreement; is only expected for about the first 6 digits after the decimal. If the; computation does not complete, there is probably a problem with the; compilation or installation of the program (see the installation; instructions in Sec. Compiling and Installing from Source).; This very simple input is sufficient to run the requested information.; Notice that we didn’t tell the program some otherwise useful information; like the charge on the molecule (0, it’s neutral), th",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/tutorial-1.html:2445,energy,energy,2445,psi4manual/1.2.1/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/tutorial-1.html,2,['energy'],['energy']
Energy Efficiency,"lacing any “.in” or “.dat” extension by “.out”). Sample Input Files¶; Below, we will provide a few simple input files as examples. A large; number of sample input files, covering everything from single-point energies; using density-functional theory to response properties from coupled-cluster; theory, can be found in the psi4/samples directory. Running a Basic Hartree–Fock Calculation¶; In our first example, we will consider a Hartree–Fock SCF computation; for the water molecule using a cc-pVDZ basis set. We will specify the; geometry of our water molecule using a standard Z-matrix.; # Any line starting with the # character is a comment line; #! Sample HF/cc-pVDZ H2O computation. memory 600 mb. molecule h2o {; O ; H 1 0.96; H 1 0.96 2 104.5; }. set basis cc-pVDZ; energy('scf'). Note; The memory and basis set specifications are placed before the; energy function is called. Any user options need to; be set before the procedure they are meant to affect. For your convenience, the above example can be found in; tu1-h2o-energy.; You can run it if you wish.; Once PSI4 is in your path (see the; User Configuration; section of the installation instructions), you can run this computation by typing; >>> psi4 input.dat output.dat. If everything goes well, the computation should complete and should report; a final restricted Hartree–Fock energy in a section like this:; 1; 2; 3Energy converged. @RHF Final Energy: -76.02663273410671. By default, the energy should be converged to about \(1.0 \times 10^{-6}\), so agreement; is only expected for about the first 6 digits after the decimal. If the; computation does not complete, there is probably a problem with the; compilation or installation of the program (see the installation; instructions in Sec. Compiling and Installing from Source).; This very simple input is sufficient to run the requested information.; Notice that we didn’t tell the program some otherwise useful information; like the charge on the molecule (0, it’s neutral), the",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/tutorial-1.html:2444,energy,energy,2444,psi4manual/1.3.2/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/tutorial-1.html,2,['energy'],['energy']
Energy Efficiency,"lacing any “.in” or “.dat” extension by “.out”). Sample Input Files¶; Below, we will provide a few simple input files as examples. A large; number of sample input files, covering everything from single-point energies; using density-functional theory to response properties from coupled-cluster; theory, can be found in the psi4/samples directory. Running a Basic Hartree–Fock Calculation¶; In our first example, we will consider a Hartree–Fock SCF computation; for the water molecule using a cc-pVDZ basis set. We will specify the; geometry of our water molecule using a standard Z-matrix.; # Any line starting with the # character is a comment line; #! Sample HF/cc-pVDZ H2O computation. memory 600 mb. molecule h2o {; O ; H 1 0.96; H 1 0.96 2 104.5; }. set basis cc-pVDZ; energy('scf'). Note; The memory and basis set specifications are placed before the; energy function is called. Any user options need to; be set before the procedure they are meant to affect. For your convenience, the above example can be found in; tu1-h2o-energy.; You can run it if you wish.; Once PSI4 is in your path (see the; User Configuration; section of the installation instructions), you can run this computation by typing; >>> psi4 input.dat output.dat. If everything goes well, the computation should complete and should report; a final restricted Hartree–Fock energy in a section like this:; Energy converged. @RHF Final Energy: -76.02663273410671. By default, the energy should be converged to about \(1.0 \times 10^{-6}\), so agreement; is only expected for about the first 6 digits after the decimal. If the; computation does not complete, there is probably a problem with the; compilation or installation of the program (see the installation; instructions in Sec. Compiling and Installing from Source).; This very simple input is sufficient to run the requested information.; Notice that we didn’t tell the program some otherwise useful information; like the charge on the molecule (0, it’s neutral), the spin m",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/tutorial-1.html:2489,energy,energy,2489,psi4manual/1.4.0/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/tutorial-1.html,9,['energy'],['energy']
Energy Efficiency,"lacing any ”.in” or ”.dat” extension by ”.out”). Sample Input Files¶; Below, we will provide a few simple input files as examples. A large; number of sample input files, covering everything from single-point energies; using density-functional theory to response properties from coupled-cluster; theory, can be found in the psi4/samples directory. Running a Basic Hartree–Fock Calculation¶; In our first example, we will consider a Hartree–Fock SCF computation; for the water molecule using a cc-pVDZ basis set. We will specify the; geometry of our water molecule using a standard Z-matrix.; # Any line starting with the # character is a comment line; #! Sample HF/cc-pVDZ H2O computation. memory 600 mb. molecule h2o {; O ; H 1 0.96; H 1 0.96 2 104.5; }. set basis cc-pVDZ; energy('scf'). Note; The memory and basis set specifications are placed before the; energy function is called. Any user options need to; be set before the procedure they are meant to affect. For your convenience, the above example can be found in; tu1-h2o-energy.; You can run it if you wish.; Once PSI4 is in your path (see the; User Configuration; section of the installation instructions), you can run this computation by typing; 1>>> psi4 input.dat output.dat. If everything goes well, the computation should complete and should report; a final restricted Hartree–Fock energy in a section like this:; 1; 2; 3Energy converged. @RHF Final Energy: -76.02663273410671. By default, the energy should be converged to about \(1.0 \times 10^{-6}\), so agreement; is only expected for about the first 6 digits after the decimal. If the; computation does not complete, there is probably a problem with the; compilation or installation of the program (see the installation; instructions in Sec. Compiling and Installing from Source).; This very simple input is sufficient to run the requested information.; Notice that we didn’t tell the program some otherwise useful information; like the charge on the molecule (0, it’s neutral), th",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/tutorial-1.html:2443,energy,energy,2443,psi4manual/1.1.0/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/tutorial-1.html,2,['energy'],['energy']
Energy Efficiency,"lack of quotes around cc-pVDZ, even though it is a string. The; Psithon preprocessor automatically wraps any string values in set commands in; strings. The last three examples provide a more convenient way for specifying; multiple keywords:; 1; 2; 3; 4; 5set {; basis = cc-pVDZ; print = 1; reference = rhf; }. For arguments that require an array input, standard Python list syntax should; be used, viz.:; 1; 2; 3set {; docc = [3, 0, 1, 1]; }. List/matrix inputs may span multiple lines, as long as the opening [ is; on the same line as the name of the keyword.; Any of the above keyword specifications can be scoped to individual modules,; by adding the name of the module after the set keyword. Omitting the module; name, or using the name global or globals will result in the keyword being; applied to all modules. For example, in the following input; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13molecule{; o; h 1 roh; h 1 roh 2 ahoh. roh = 0.957; ahoh = 104.5; }. set basis cc-pVDZ; set ccenergy print 3; set scf print 1; energy('ccsd'). the basis set is set to cc-pVDZ throughout, the SCF code will have a print; level of 1 and the ccenergy code, which performs coupled cluster computations,; will use a print level of 3. In this example a full CCSD computation is; performed by running the SCF code first, then the coupled cluster modules;; the energy() Python helper function ensures that this is performed correctly.; Note that the Python interpreter executes commands in the order they appear in; the input file, so if the last four commands in the above example were to read; 1; 2; 3; 4set basis cc-pVDZ; energy('ccsd'); set ccenergy print 3; set scf print 1. the commands that set the print level would be ineffective, as they would be; processed after the CCSD computation completes.; In PsiAPI mode, one can use commands set_options() and; set_module_options() like below. Note that these values; should be of correct type, strings for strings, floats for floats like; convergences. The func",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psithoninput-1.html:7036,energy,energy,7036,psi4manual/1.1.0/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psithoninput-1.html,6,['energy'],['energy']
Energy Efficiency,"larger basis set in 2-point; extrapolation.; verbose; Controls volume of printing.; alpha; Overrides the default :math:`\alpha = 3.4`. Returns; -------; float or ~numpy.ndarray; Eponymous function applied to input zetas and values; type from `valueLO`. Notes; -----; The extrapolation is calculated according to [2]_:; :math:`E_{total}^X = E_{total}^{\infty} + \beta X^{-\alpha}, \alpha = 3.4`. References; ----------. .. [2] Truhlar, Chem. Phys. Lett. 294 (1998) 45-48,; DOI: 10.1016/S0009-2614(98)00866-5. """""". if type(valueLO) != type(valueHI):; raise ValidationError(; f""scf_xtpl_truhlar_2: Inputs must be of the same datatype! ({type(valueLO)}, {type(valueHI)})""). if alpha is None:; alpha = 3.40. beta_division = 1 / (zHI**(-1 * alpha) - zLO**(-1 * alpha)); beta_mult = zHI**(-1 * alpha). if isinstance(valueLO, float):; beta = (valueHI - valueLO) * beta_division; value = valueHI - beta * beta_mult. if verbose:; # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> Truhlar 2-point power form SCF extrapolation for method: %s <==\n\n"""""" % (; functionname.upper()); cbsscheme += """""" LO-zeta (%s) Energy: % 16.12f\n"""""" % (str(zLO), valueLO); cbsscheme += """""" HI-zeta (%s) Energy: % 16.12f\n"""""" % (str(zHI), valueHI); cbsscheme += """""" Alpha (exponent) Value: % 16.12f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: % 16.12f\n\n"""""" % (beta). name_str = ""%s/(%s,%s)"" % (functionname.upper(), _zeta_val2sym[zLO].upper(), _zeta_val2sym[zHI].upper()); cbsscheme += """""" @Extrapolated """"""; cbsscheme += name_str + ':'; cbsscheme += "" "" * (18 - len(name_str)); cbsscheme += """"""% 16.12f\n\n"""""" % value; core.print_out(cbsscheme); logger.debug(cbsscheme). return value. elif isinstance(valueLO, np.ndarray):. beta = (valueHI - valueLO) * beta_division; value = valueHI - beta * beta_mult. if verbose > 2:; cbsscheme = f""""""\n ==> Truhlar 2-point power SCF extrapolation for method: {functionname.upper()} <==\n""""""; cbsscheme += f""""""\n LO-zeta ({zLO}) Data\n""""""; c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_cbs_helper.html:8409,power,power,8409,psi4manual/1.7.x/_modules/psi4/driver/driver_cbs_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_cbs_helper.html,8,['power'],['power']
Energy Efficiency,"larly when using diffuse basis functions.; The COSX_OVERLAP_FITTING keyword (defaults to true) reduces numerical; integration errors using the method described in [Izsak:2011:144105] and is; always recommended. LinK Exchange¶. Warning; The LinK code is currently under development and should not be used. Large SCF calculations can benefit from specialized screening procedures that further reduce the scaling of the ERI contribution to the Fock matrix.; LinK, the linear-scaling exchange method described in [Ochsenfeld:1998:1663], is available with the direct SCF algorithm (SCF_TYPE set to DIRECT).; LinK achieves linear-scaling by exploiting shell pair sparsity in the density matrix and overlap sparsity between shell pairs.; This method is most competitive when used with non-diffuse orbital basis sets, since orbital and density overlaps decay slower with diffuse functions.; LinK is especially powerful when combined with density-matrix based ERI screening (set SCREENING to DENSITY) and incremental Fock builds (set INCFOCK to TRUE), which decrease the number of significant two-electron integrals to calculate.; NOTE: Turning on LinK is currently only recommended for research and development purposes, and not for performance,; since a fast J matrix build compatible to use with LinK has not been developed yet.; To turn on and control the LinK algorithm, here are the list of options provided. DO_LINK: Defaults to false. If turned on, the K matrix will be built using the algorithm described in [Ochsenfeld:1998:1663].; LINK_INTS_TOLERANCE: The integral screening tolerance used for sparsity-prep in the LinK algorithm. Defaults to the INTS_TOLERANCE option. Second-order Convergence¶; Second-order convergence takes into account both the gradient and Hessian to; take a full Newton step with respect to the orbital parameters. This results in; quadratic convergence with respect to density for SCF methods. For cases where; normal acceleration methods either fail or take many iterations",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/scf.html:33290,power,powerful,33290,psi4manual/1.6.x/scf.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/scf.html,1,['power'],['powerful']
Energy Efficiency,"lassified SAPT term energy [E_h] implemented for SAPT0. SAPT DISP20 ENERGY¶. SAPT EXCH-DISP20 ENERGY¶; A dispersion-classified SAPT term energy [E_h] implemented for SAPT0. SAPT EXCH-DISP20(S^INF) ENERGY¶; A dispersion-classified SAPT term energy [E_h] implemented for SAPT0. See Higher-Order Exchange Terms without Single-Exchange Approximation. SAPT SAME-SPIN DISP20 ENERGY¶. SAPT SAME-SPIN EXCH-DISP20 ENERGY¶; The portion of SAPT DISP20 ENERGY or; SAPT EXCH-DISP20 ENERGY resulting from; from same-spin or triplet doubles correlations. SAPT HF(2) ENERGY ABC(HF)¶; The total Hartree–Fock energy [E_h] of the supersystem implemented for F/I-SAPT. SAPT HF(2) ENERGY AC(0)¶; The Hartree–Fock energy [E_h] of subsystems A and C implemented for F/I-SAPT. SAPT HF(2) ENERGY BC(0)¶; The Hartree–Fock energy [E_h] of subsystems B and C implemented for F/I-SAPT. SAPT HF(2) ENERGY A(0)¶; The Hartree–Fock energy [E_h] of subsystem A implemented for F/I-SAPT. SAPT HF(2) ENERGY B(0)¶; The Hartree–Fock energy [E_h] of subsystem B implemented for F/I-SAPT. SAPT HF(2) ENERGY AC(HF)¶; The Hartree–Fock localized energy [E_h] of subsystems A and C implemented for F/I-SAPT. SAPT HF(2) ENERGY BC(HF)¶; The Hartree–Fock localized energy [E_h] of subsystems B and C implemented for F/I-SAPT. SAPT HF(2) ENERGY AB(HF)¶; The Hartree–Fock localized energy [E_h] of subsystems A and B implemented for F/I-SAPT. SAPT HF(2) ENERGY A(HF)¶; The Hartree–Fock localized energy [E_h] of subsystem A implemented for F/I-SAPT. SAPT HF(2) ENERGY B(HF)¶; The Hartree–Fock localized energy [E_h] of subsystem B implemented for F/I-SAPT. SAPT HF(2) ENERGY C¶; The Hartree–Fock energy [E_h] of subsystem C implemented for F/I-SAPT. SAPT HF(2) ENERGY HF¶; The FI-SAPT Hartree–Fock interaction energy [E_h] implemented for F/I-SAPT. SAPT ELST12,R ENERGY¶; An electrostatics-classified SAPT term energy [E_h] implemented for SAPT2. SAPT EXCH11(S^2) ENERGY¶. SAPT EXCH12(S^2) ENERGY¶; An exchange-classified SAPT term energy [E_h] impl",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html:47159,energy,energy,47159,psi4manual/1.7.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html,4,['energy'],['energy']
Energy Efficiency,"lassified SAPT term energy [E_h] implemented for SAPT0. See Higher-Order Exchange Terms without Single-Exchange Approximation. SAPT SAME-SPIN DISP20 ENERGY¶. SAPT SAME-SPIN EXCH-DISP20 ENERGY¶; The portion of SAPT DISP20 ENERGY or; SAPT EXCH-DISP20 ENERGY resulting from; from same-spin or triplet doubles correlations. SAPT HF(2) ENERGY ABC(HF)¶; The total Hartree–Fock energy [E_h] of the supersystem implemented for F/I-SAPT. SAPT HF(2) ENERGY AC(0)¶; The Hartree–Fock energy [E_h] of subsystems A and C implemented for F/I-SAPT. SAPT HF(2) ENERGY BC(0)¶; The Hartree–Fock energy [E_h] of subsystems B and C implemented for F/I-SAPT. SAPT HF(2) ENERGY A(0)¶; The Hartree–Fock energy [E_h] of subsystem A implemented for F/I-SAPT. SAPT HF(2) ENERGY B(0)¶; The Hartree–Fock energy [E_h] of subsystem B implemented for F/I-SAPT. SAPT HF(2) ENERGY AC(HF)¶; The Hartree–Fock localized energy [E_h] of subsystems A and C implemented for F/I-SAPT. SAPT HF(2) ENERGY BC(HF)¶; The Hartree–Fock localized energy [E_h] of subsystems B and C implemented for F/I-SAPT. SAPT HF(2) ENERGY AB(HF)¶; The Hartree–Fock localized energy [E_h] of subsystems A and B implemented for F/I-SAPT. SAPT HF(2) ENERGY A(HF)¶; The Hartree–Fock localized energy [E_h] of subsystem A implemented for F/I-SAPT. SAPT HF(2) ENERGY B(HF)¶; The Hartree–Fock localized energy [E_h] of subsystem B implemented for F/I-SAPT. SAPT HF(2) ENERGY C¶; The Hartree–Fock energy [E_h] of subsystem C implemented for F/I-SAPT. SAPT HF(2) ENERGY HF¶; The FI-SAPT Hartree–Fock interaction energy [E_h] implemented for F/I-SAPT. SAPT ELST12,R ENERGY¶; An electrostatics-classified SAPT term energy [E_h] implemented for SAPT2. SAPT EXCH11(S^2) ENERGY¶. SAPT EXCH12(S^2) ENERGY¶; An exchange-classified SAPT term energy [E_h] implemented for SAPT2. SAPT IND22 ENERGY¶. SAPT EXCH-IND22 ENERGY¶; An induction-classified SAPT term energy [E_h] implemented for SAPT2. SAPT DISP21 ENERGY¶; A dispersion-classified SAPT term energy [E_h] implemented for SAP",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html:47382,energy,energy,47382,psi4manual/1.7.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html,4,['energy'],['energy']
Energy Efficiency,"last four commands in the above example were to read; 1; 2; 3; 4set basis cc-pVDZ; energy('ccsd'); set ccenergy print 3; set scf print 1. the commands that set the print level would be ineffective, as they would be; processed after the CCSD computation completes.; In PsiAPI mode, one can use commands set_options() and; set_module_options() like below. Note that these values; should be of correct type, strings for strings, floats for floats like; convergences. The function ~psi4.core.clean_options that reinitializes; all options may also be useful to separate calculations in a PsiAPI; session.; 1; 2; 3; 4; 5; 6; 7; 8; 9psi4.set_options({; 'scf_type': 'pk',; 'e_convergence': 1.e-5,; 'soscf': True; }). psi4.set_module_options({; 'geom_maxiter': 50; }). Basis Sets¶. Basis Sets; Built-In Basis Sets; Mixing Basis Sets; Decontracted Basis Sets; User-Defined Basis Sets; Inputting effective core potentials (ECPs). PSI Variables¶; To harness the power of Python, PSI4 makes the most pertinent results; of each computation available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of; H2 and H atom:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19molecule h2 {; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h {; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol * (2*h_energy - h2_energy); print ""De=%f"" % D_e. The energy() function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation.; Generally, there are multiple quantities of interest. Appendix; PSI Variables by Module lists PSI variables variables set by each; module, and PSI Variables by Alpha defines them. These can be; accessed through the get_variable() function. For example",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html:9300,power,power,9300,psi4manual/1.2.1/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html,4,['power'],['power']
Energy Efficiency,"late; parameter will then be deduced. Using nullptr also makes the code more; readable, especially if auto is used consistently throughout.; Reference: Item 8 in [Effective Modern C++]. Prefer std::make_shared to direct use of new¶; Using std::make_shared:. Reduces code verbosity, especially when coupled with auto:. // Type information given 3 TIMES!!!; std::shared_ptr<Matrix> F = std::shared_ptr<Matrix>(new Matrix(""Fock matrix"", nso, nso));. // So much typing...; std::shared_ptr<Matrix> F = std::make_shared<Matrix>(""Fock matrix"", nso, nso);. // Much better!!!!; auto F = std::make_shared<Matrix>(""Fock matrix"", nso, nso);. Ensures exception safety and prevents resource leaks.; Improves efficiency:. // Performs TWO allocations; std::shared_ptr<Matrix> F = std::shared_ptr<Matrix>(new Matrix(""Fock matrix"", nso, nso));. // Performs ONE allocation; auto F = std::make_shared<Matrix>(""Fock matrix"", nso, nso);. Reference: Item 21 in [Effective Modern C++]. Prefer auto to explicit type declarations¶; Using auto reduces and/or avoids:. Verbosity in variable declarations:. std::shared_ptr<Matrix> F = std::make_shared<Matrix>(""Fock matrix"", nso, nso); // So much typing...; auto F = std::make_shared<Matrix>(""Fock matrix"", nso, nso); // Much better!. Problems with uninitialized variables. auto works like template type; deduction, hence the right-hand side of the declaration needs to have an; initializer:. int x1; // fine, but uninitialized :(; auto x2; // WON'T COMPILE!!!; auto x3 = 1; // fine and initialized. Problems with unintended type casts and type mismatches that are hard; to impossible to catch:. std::vector<int> v;; // !!! The size of a vector is of type std::vector<int>::size_type and is compiler- AND architecture-DEPENDENT; unsigned sz = v.size(); // might not be correct on some compiler/machines; auto size = v.size(); // size is ALWAYS of the correct type. Reference: Items 2 and 5 in [Effective Modern C++]. Mark virtual functions in derived classes with override¶; The o",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/prog_style_c-1.html:1451,reduce,reduces,1451,psi4manual/1.4.0/prog_style_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/prog_style_c-1.html,9,['reduce'],['reduces']
Energy Efficiency,"lation energy component [H]; for the requested full coupled-cluster (CCSD, CCSDT, up to CCn); level of theory. CCSD(T) TOTAL ENERGY¶. CCSD(T) CORRELATION ENERGY¶. CCSDT(Q) TOTAL ENERGY¶. CCSDT(Q) CORRELATION ENERGY¶. CC(n-1)(n) TOTAL ENERGY¶. CC(n-1)(n) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the perturbatively corrected coupled-cluster (CCSD(T), CCSDT(Q),; up to CC(n-1)(n) level of theory. CCSDT-1a TOTAL ENERGY¶. CCSDT-1a CORRELATION ENERGY¶. CCSDTQ-1a TOTAL ENERGY¶. CCSDTQ-1a CORRELATION ENERGY¶. CCn-1a TOTAL ENERGY¶. CCn-1a CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the approximate coupled-cluster (CCSD(T)-1a, CCSDT(Q)-1a,; up to CCn-1a) level of theory. CCSDT-1b TOTAL ENERGY¶. CCSDT-1b CORRELATION ENERGY¶. CCSDTQ-1b TOTAL ENERGY¶. CCSDTQ-1b CORRELATION ENERGY¶. CCn-1b TOTAL ENERGY¶. CCn-1b CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the approximate coupled-cluster (CCSD(T)-1b, CCSDT(Q)-1b,; up to CCn-1b) level of theory. CCSDT-3 TOTAL ENERGY¶. CCSDT-3 CORRELATION ENERGY¶. CCSDTQ-3 TOTAL ENERGY¶. CCSDTQ-3 CORRELATION ENERGY¶. CCn-3 TOTAL ENERGY¶. CCn-3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the approximate coupled-cluster (CCSD(T)-3, CCSDT(Q)-3,; up to CCn-3) level of theory. CCSD(T)_L TOTAL ENERGY¶. CCSD(T)_L CORRELATION ENERGY¶. CCSDT(Q)_L TOTAL ENERGY¶. CCSDT(Q)_L CORRELATION ENERGY¶. CC(n-1)(n)_L TOTAL ENERGY¶. CC(n-1)(n)_L CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the approximate coupled-cluster (CCSD(T)_L, CCSDT(Q)_L,; up to CC(n-1)(n)L level of theory. CEPA(0) DIPOLE X¶. CEPA(0) DIPOLE Y¶. CEPA(0) DIPOLE Z¶; The three components of the dipole [Debye] for the; coupled electron pair approximation variant 0 level of theory. CEPA(0) QUADRUPOLE XX¶. CEPA(0) QUADRUPOLE XY¶. CEPA(0) QUADRUPOLE XZ¶. CE",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html:4145,energy,energy,4145,psi4manual/4.0b3/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html,8,['energy'],['energy']
Energy Efficiency,"lation, not; just exchange-type correlation).; In practice, the first few generations of KS-DFT functionals were chosen to be; local, meaning that the form of the exchange correlation energy is an integral; over all of space of a function depending only on local information in the; density, such as the density value or derivatives. The simplest variants are; Local Spin-Density Approximations (LSDA), which depend only on the spin density; or ,. The most popular variants are Generalized Gradient Approximation (GGA); functionals which use the norm of the density gradient; , or; to build an inhomogeneity; parameter. where,. GGA functionals are essentially the same cost as LSDA functionals, and are often; considerably more accurate.; Another local variant which has gained some popularity (though perhaps not as; much as GGA functionals) is the meta approximation, in which information about; the second derivative of the density is incorporated. The most canonical variant; of these functionals rely on the spin kinetic energy density ; and ,. A generic local meta-GGA functional may then be written as,. The potential corresponding to this energy functional is,. This potential is used to build the Kohn-Sham matrix,. which is diagonalized to form the Kohn-Sham orbitals in the same manner as in; Hartree-Fock.; In practice the local functional kernel and its required; partial derivatives are exceedingly complex, and are not analytically; integrable. In this case, atom-centered numerical quadratures are used to; evaluate the Kohn-Sham potentials and energies to a high degree of accuracy. The; evaluation of these numerical integrals can be made to be linear scaling with a; reasonable amount of cleverness (mostly related to the fact that the basis; functions decay exponentially), meaning that the Coulomb and diagonalization; steps become rate limiting. This enormous potential speed gain over Hartree-Fock; with potentially exact treatment of electron correlation for “free” was one of",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/dft-1.html:2970,energy,energy,2970,psi4manual/1.0.0/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/dft-1.html,10,['energy'],['energy']
Energy Efficiency,"lation, simply adjust its; position in the path environment variables. Running gCP¶; At present there is a limited interface to gCP that is used; only to implement the “HF-3c” [Sure:2013:1672] and “PBEh-3c”; [Grimme:2015:054107] methods (both energy and gradient). The interface; can use classic or mctc-gcp executables interchangeably and will prefer the latter.; A DFTD3 executable, classic or simple-dftd3,; must also be available for these methods to; run. Unlike every other method in PSI4, if a basis set has not been; set, these will default to their intended basis sets: MINIX for HF-3c; and def2-mSVP for PBEh-3c. If a basis has previously been set, but you; want to use the default basis, use the slash syntax to “empty” the basis; option for the scope of the current calculation, energy(""hf3c/"").; A few practical examples:. HF-3c single point with default minix basis; energy('hf3c'). PBEh-3c optimization with default def2-mSVP basis; optimize('pbeh3c'). HF-3c with non-standard basis; set basis cc-pvdz; energy('hf3c'). PBEh-3c with default basis after basis set; set basis cc-pvdz; energy('pbeh3c/'). If only BSSE/basis set corrections (rather than total energies) are of; interest, the gcp program can be run independently of the scf; through the python function run_gcp(). (This function; is the same PSI4/gcp interface that is called during an scf job.); This route is much faster than running a HF or DFT energy.; molecule nene {; Ne; Ne 1 2.0; }. nene.update_geometry(). >>> E, G = nene.run_gcp('hf3c'). >>> E, G = nene.run_gcp(func='HF3c', verbose=True). qcdb.Molecule.run_gcp(self, func=None, dertype=None, verbose=1)¶; Compute geometrical BSSE correction via Grimme’s GCP program.; Function to call Grimme’s GCP program; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp; to compute an a posteriori geometrical BSSE correction to self for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, func. Returns energy if dertype is",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/gcp.html:2793,energy,energy,2793,psi4manual/1.7.x/gcp.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/gcp.html,2,['energy'],['energy']
Energy Efficiency,"lation. :type scf_basis: :ref:`basis string <apdx:basisElement>`; :param scf_basis: |dl| ``corl_basis`` |dr| || ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, ``scf_basis`` can default; to ``corl_basis``. :type corl_basis: :ref:`basis string <apdx:basisElement>`; :param corl_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the correlation energy. :type delta_basis: :ref:`basis string <apdx:basisElement>`; :param delta_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. :type delta2_basis: :ref:`basis string <apdx:basisElement>`; :param delta2_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. * Schemes; Transformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, ``'highest_1'``, which uses the best basis; set available. See `Extrapolation Schemes`_ for all available schemes. :type scf_scheme: function; :param scf_scheme: |dl| ``highest_1`` |dr| || ``scf_xtpl_helgaker_3`` || etc. Indicates the basis set extrapolation scheme to be applied to the reference energy. :type corl_scheme: function; :param corl_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the correlation energy. :type delta_scheme: function; :param delta_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the delta c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:55632,energy,energy,55632,psi4manual/4.0b2/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html,6,['energy'],['energy']
Energy Efficiency,"lation. :type scf_basis: :ref:`basis string <apdx:basisElement>`; :param scf_basis: |dl| ``corl_basis`` |dr| || ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, ``scf_basis`` can default; to ``corl_basis``. :type corl_basis: :ref:`basis string <apdx:basisElement>`; :param corl_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the correlation energy. :type delta_basis: :ref:`basis string <apdx:basisElement>`; :param delta_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. :type delta2_basis: :ref:`basis string <apdx:basisElement>`; :param delta2_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. * Schemes; Transformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, ``'xtpl_highest_1'``, which uses the best basis; set available. See :ref:`sec:cbs_xtpl` for all available schemes. :type scf_scheme: Callable; :param scf_scheme: |dl| ``xtpl_highest_1`` |dr| || ``scf_xtpl_helgaker_3`` || etc. Indicates the basis set extrapolation scheme to be applied to the reference energy.; Defaults to :py:func:`~psi4.driver.driver_cbs.scf_xtpl_helgaker_3` if three valid basis sets; present in ``psi4.driver.driver_cbs.scf_basis``, :py:func:`~psi4.driver.driver_cbs.scf_xtpl_helgaker_2` if two valid basis; sets present in ``scf_basis``, and :py:func:`~psi4.driver.driver_cbs.xtpl_highest_1` otherwise. .. hlist::; :columns: 1. * :py:func:`~psi4.driver.driver_cb",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:38911,energy,energy,38911,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,4,['energy'],['energy']
Energy Efficiency,"lation. :type scf_basis: :ref:`basis string <apdx:basisElement>`; :param scf_basis: |dl| ``corl_basis`` |dr| || ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, ``scf_basis`` can default; to ``corl_basis``. :type corl_basis: :ref:`basis string <apdx:basisElement>`; :param corl_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the correlation energy. :type delta_basis: :ref:`basis string <apdx:basisElement>`; :param delta_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. :type delta2_basis: :ref:`basis string <apdx:basisElement>`; :param delta2_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. * Schemes; Transformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, ``'xtpl_highest_1'``, which uses the best basis; set available. See :ref:`sec:cbs_xtpl` for all available schemes. :type scf_scheme: function; :param scf_scheme: |dl| ``xtpl_highest_1`` |dr| || ``scf_xtpl_helgaker_3`` || etc. Indicates the basis set extrapolation scheme to be applied to the reference energy.; Defaults to :py:func:`~scf_xtpl_helgaker_3` if three valid basis sets; present in ``scf_basis``, :py:func:`~scf_xtpl_helgaker_2` if two valid basis; sets present in ``scf_basis``, and :py:func:`~xtpl_highest_1` otherwise. .. hlist::; :columns: 1. * xtpl_highest_1; * scf_xtpl_helgaker_3; * scf_xtpl_helgaker_2; * scf_xtpl_truhlar_2; * scf_xtpl_karton_2. :type corl_scheme: ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html:38656,energy,energy,38656,psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html,1,['energy'],['energy']
Energy Efficiency,"lation. :type scf_basis: :ref:`basis string <apdx:basisElement>`; :param scf_basis: |dl| ``corl_basis`` |dr| || ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, ``scf_basis`` can default; to ``corl_basis``. :type corl_basis: :ref:`basis string <apdx:basisElement>`; :param corl_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the correlation energy. :type delta_basis: :ref:`basis string <apdx:basisElement>`; :param delta_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. :type delta2_basis: :ref:`basis string <apdx:basisElement>`; :param delta2_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. * Schemes; Transformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, ``'xtpl_highest_1'``, which uses the best basis; set available. See :ref:`sec:cbs_xtpl` for all available schemes. :type scf_scheme: str; :param scf_scheme: |dl| ``'xtpl_highest_1'`` |dr| || ``'scf_xtpl_helgaker_3'`` || etc. Indicates the basis set extrapolation scheme to be applied to the reference energy.; Defaults to :py:func:`~psi4.driver.driver_cbs_helper.scf_xtpl_helgaker_3` if three valid basis sets; present in ``psi4.driver.driver_cbs.scf_basis``, :py:func:`~psi4.driver.driver_cbs_helper.scf_xtpl_helgaker_2` if two valid basis; sets present in ``scf_basis``, and :py:func:`~psi4.driver.driver_cbs_helper.xtpl_highest_1` otherwise. .. hlist::; :columns: 1. * :py:func:`~p",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_cbs.html:26695,energy,energy,26695,psi4manual/1.7.x/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_cbs.html,8,['energy'],['energy']
Energy Efficiency,"lation. :type scf_basis: :ref:`basis string <apdx:basisElement>`; :param scf_basis: |dl| ``corl_basis`` |dr| || ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, ``scf_basis`` can default; to ``corl_basis``. :type corl_basis: :ref:`basis string <apdx:basisElement>`; :param corl_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the correlation energy. :type delta_basis: :ref:`basis string <apdx:basisElement>`; :param delta_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. :type delta2_basis: :ref:`basis string <apdx:basisElement>`; :param delta2_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. * Schemes; Transformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, ``'xtpl_highest_1'``, which uses the best basis; set available. See :ref:`sec:cbs_xtpl` for all available schemes. :type scf_scheme: string; :param scf_scheme: |dl| ``'xtpl_highest_1'`` |dr| || ``'scf_xtpl_helgaker_3'`` || etc. Indicates the basis set extrapolation scheme to be applied to the reference energy.; Defaults to :py:func:`~psi4.driver.driver_cbs.scf_xtpl_helgaker_3` if three valid basis sets; present in ``psi4.driver.driver_cbs.scf_basis``, :py:func:`~psi4.driver.driver_cbs.scf_xtpl_helgaker_2` if two valid basis; sets present in ``scf_basis``, and :py:func:`~psi4.driver.driver_cbs.xtpl_highest_1` otherwise. .. hlist::; :columns: 1. * :py:func:`~psi4.driver.driver_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html:26694,energy,energy,26694,psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html,2,['energy'],['energy']
Energy Efficiency,"lation. :type scf_basis: :ref:`basis string <apdx:basisElement>`; :param scf_basis: |dl| ``corl_basis`` |dr| || ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, ``scf_basis`` can default; to ``corl_basis``. :type corl_basis: :ref:`basis string <apdx:basisElement>`; :param corl_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the correlation energy. :type delta_basis: :ref:`basis string <apdx:basisElement>`; :param delta_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. :type delta2_basis: :ref:`basis string <apdx:basisElement>`; :param delta2_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. :type delta3_basis: :ref:`basis string <apdx:basisElement>`; :param delta3_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the third delta correction; to the correlation energy. :type delta4_basis: :ref:`basis string <apdx:basisElement>`; :param delta4_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the fourth delta correction; to the correlation energy. :type delta5_basis: :ref:`basis string <apdx:basisElement>`; :param delta5_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the fifth delta correction; to the correlation energy. * Schemes; Transformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:59000,energy,energy,59000,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,5,['energy'],['energy']
Energy Efficiency,"lattice is None:; self.clattice = MDI_Recv(3 * self.nlattice, MDI_DOUBLE, self.comm); else:; self.clattice = clattice; self.set_lattice_field(). # Respond to the >LATTICE command; def recv_lattice(self, lattice=None):; """""" Receive the charges of a set of lattice point charges through MDI. Arguments:; lattice: New charges of the lattice of point charges. If None, receive through MDI.; """"""; if lattice is None:; self.lattice = MDI_Recv(self.nlattice, MDI_DOUBLE, self.comm); else:; self.lattice = lattice; self.set_lattice_field(). # Respond to the SCF command; def run_scf(self):; """""" Run an energy calculation; """"""; self.energy = psi4.energy(self.scf_method, **self.kwargs). # Respond to the <DIMENSIONS command; def send_dimensions(self):; """""" Send the dimensionality of the system through MDI. :returns: *dimensions* Dimensionality of the system; """"""; dimensions = [1, 1, 1]; MDI_Send(dimensions, 3, MDI_INT, self.comm); return dimensions. # Respond to the <TOTCHARGE command; def send_total_charge(self):; """""" Send the total system charge through MDI. :returns: *charge* Total charge of the system; """"""; charge = self.molecule.molecular_charge(); MDI_Send(charge, 1, MDI_DOUBLE, self.comm); return charge. # Respond to the >TOTCHARGE command; def recv_total_charge(self, charge=None):; """""" Receive the total system charge through MDI. Arguments:; charge: New charge of the system. If None, receive through MDI.; """"""; if charge is None:; charge = MDI_Recv(1, MDI_DOUBLE, self.comm); self.molecule.set_molecular_charge(int(round(charge))). # Respond to the <ELEC_MULT command; def send_multiplicity(self):; """""" Send the electronic multiplicity through MDI. :returns: *multiplicity* Multiplicity of the system; """"""; multiplicity = self.molecule.multiplicity(); MDI_Send(multiplicity, 1, MDI_INT, self.comm); return multiplicity. # Respond to the >ELEC_MULT command; def recv_multiplicity(self, multiplicity=None):; """""" Receive the electronic multiplicity through MDI. Arguments:; multiplicity: New ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html:10791,charge,charge,10791,psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html,14,['charge'],['charge']
Energy Efficiency,"lback=verify_top); 	top.set_status(True); 	top.add_kw('Units', 'STR', 'AU'). 	cavity=getkw.Section('Cavity', callback=verify_cavity); 	cavity.add_kw('Type','STR'); 	cavity.add_kw('PatchLevel', 'INT', 2); 	cavity.add_kw('Coarsity', 'DBL', 0.5); 	cavity.add_kw('Area','DBL', 0.3); 	cavity.add_kw('Scaling', 'STR', 'Yes'); 	cavity.add_kw('AddSpheres', 'STR', 'Yes'); cavity.add_kw('Mode','STR','Explicit'); cavity.add_kw('Atoms','INT_ARRAY'); cavity.add_kw('Radii','DBL_ARRAY'); 	cavity.add_kw('RadiiSet', 'STR', 'Bondi'); 	cavity.add_kw('Spheres','DBL_ARRAY', callback=verify_spheres); 	top.add_sect(cavity); ; 	medium=getkw.Section('Medium', callback=verify_medium); 	medium.add_kw('Solvent', 'STR', 'Water'); 	medium.add_kw('SolverType', 'STR', 'IEFPCM'); 	medium.add_kw('EquationType','STR', 'SecondKind'); 	medium.add_kw('Correction', 'DBL', 0.0); 	medium.add_kw('ProbeRadius', 'DBL', 1.0); 	top.add_sect(medium); 	; 	green=getkw.Section('Green', callback=verify_green); 	green.add_kw('Type', 'STR', 'Vacuum'); 	green.add_kw('Der', 'STR', 'Derivative'); 	green.add_kw('Eps', 'DBL', 1.0); 	green.add_kw('EpsRe', 'DBL', 1.0); 	green.add_kw('EpsImg', 'DBL', 1.0); 	green.add_kw('SphereRadius', 'DBL', 1.0); 	green.add_kw('SpherePosition', 'DBL_ARRAY'); 	medium.add_sect(green). 	green_part = deepcopy(green); 	green.add_sect(green_part). 	return top. [docs]def verify_top(section):; 	global isAngstrom; 	allowed_units = ('AU', 'Angstrom'); 	key = section.get('Units'); 	val = key.get(); 	if (val not in allowed_units):; 	 	print ""Allowed units are: "", allowed_units; 		sys.exit(1); 	if (val == 'Angstrom'):; 		isAngstrom = True. [docs]def verify_cavity(section):; 	allowed = ('GePol', 'Wavelet'); type = section.get('Type'); if (type.get() not in allowed):; 	print ""Allowed types are: "", allowed; 	sys.exit(1). 	if section['Area'].is_set(): convert_area_scalar(section['Area']); 	if (type.get() == 'GePol'):; 	area=section.get('Area'); 	a=area.get(); 	if (a < 0.01):; 		print ""Area value is too small""",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/pcmpreprocess.html:1301,green,green,1301,psi4manual/4.0b5/_modules/pcmpreprocess.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/pcmpreprocess.html,2,['green'],['green']
Energy Efficiency,lcComponent; sapt; SaveType; scalar_variable; scalar_variables; scatter; scfgrad; scfhess; set_active_molecule; set_array_variable; set_datadir; set_global_option; set_global_option_python; set_gradient; set_legacy_gradient; set_legacy_molecule; set_legacy_wavefunction; set_local_option; set_local_option_python; set_memory_bytes; set_num_threads; set_output_file; set_psi_file_prefix; set_scalar_variable; set_variable; ShellInfo; Slice; SOBasisSet; SOMCSCF; SuperFunctional; SymmetryOperation; ThreeCenterOverlapInt; timer_off; timer_on; TracelessQuadrupoleInt; triplet; tstart; tstop; TwoBodyAOInt; TwoElectronInt; UHF; UKSFunctions; variable; variables; VBase; Vector; Vector3; version; Wavefunction; activate; ancestor; AtomicComputer; banner; basis_helper; cbs; check_iwl_file_from_scf_type; compare_fchkfiles; compare_fcidumps; compare_moldenfiles; ConvergenceError; copy_file_from_scratch; copy_file_to_scratch; create_plugin; CSXError; cubeprop; Dftd3Error; dynamic_variable_bind; EmpiricalDispersion; energies_from_fcidump; energy; fchk; fchkfile_to_string; fcidump; fcidump_from_file; find_approximate_string_matches; free_atom_volumes; freq; frequencies; frequency; gdma; geometry; get_memory; gradient; hessian; ipi_broker; join_path; levenshtein; ManagedMethodError; mdi_run; message_box; MissingMethodError; molden; molecule_get_attr; molecule_set_attr; oeprop; opt; OptimizationConvergenceError; optimize; optimize_geometric; ParsingError; PastureRequiredError; pcm_helper; print_stderr; print_stdout; process_input; prop; properties; PsiException; PsiImportError; compare_vibinfos; filter_nonvib; filter_omega_to_real; harmonic_analysis; hessian_symmetrize; print_molden_vibs; print_vibs; thermo; QMMM; QMMMbohr; sanitize_name; scf_helper; scf_wavefunction_factory; SCFConvergenceError; set_memory; set_module_options; set_options; Table; tdscf; TDSCFConvergenceError; temp_circular_import_blocker; TestComparisonError; UpgradeHelper; ValidationError; vibanal_wfn; write_eigenvalues.,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/index-wcopy.html:763667,energy,energy,763667,index-wcopy.html,https://psicode.org,https://psicode.org/index-wcopy.html,1,['energy'],['energy']
Energy Efficiency,"lccd; * lccd; * lccsd; * cepa(0); * cepa(1); * cepa(3); * acpf; * aqcc; * qcisd; * cc2; * ccsd; * fno-ccsd; * bccd; * cc3; * qcisd(t); * ccsd(t); * fno-ccsd(t); * bccd(t); * cisd; * cisdt; * cisdtq; * ci\ *n*; * fci; * mrccsd; * mrccsd(t); * mrccsdt; * mrccsdt(q). :type name: string; :param name: ``'scf'`` || ``'ccsd'`` || etc. First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be ``'scf'``. Overruled if stage_wfn keywords supplied. :type scf_wfn: string; :param scf_wfn: |dl| ``'scf'`` |dr| || ``'c4-scf'`` || etc. Indicates the energy method for which the reference energy is to be; obtained. Generally unnecessary, as 'scf' is *the* scf in |PSIfour| but; can be used to direct lone scf components to run in |PSIfour| or Cfour; in a mixed-program composite method. :type corl_wfn: string; :param corl_wfn: ``'mp2'`` || ``'ccsd(t)'`` || etc. Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with ``name`` or as the unlabeled; first argument to the function. :type delta_wfn: string; :param delta_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. :type delta_wfn_lesser: string; :param delta_wfn_lesser: |dl| ``corl_wfn`` |dr| || ``'mp2'`` || etc. Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. :type delta2_wfn: string; :param delta2_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta2_wfn_lesser: string; :param delta2_wfn_lesser: |dl| ``delta_wfn`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta3_wfn: string; :param de",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:20526,energy,energy,20526,psi4manual/1.0.0/_modules/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html,6,['energy'],['energy']
Energy Efficiency,"lculation (length gauge only) at two frequencies on methyloxirane. dfccd1; DF-CCD cc-pVDZ energy for the H2O molecule. sad1; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. cc47; EOM-CCSD/cc-pVDZ on H2O2 with two excited states in each irrep. scf-bs; UHF and broken-symmetry UHF energy for molecular hydrogen. dft-grad-lr3; wB97X-D test for a large UKS molecule update ref gradient due to new BraggSlater radii. dft-grad1; DF-BP86-D2 cc-pVDZ frozen core gradient of S22 HCN update ref gradient due to new BraggSlater radii. mbis-5; MBIS calculation on ZnO. lccd-grad1; LCCD cc-pVDZ gradient for the H2O molecule. omp2-2; OMP2 cc-pVDZ energy with ROHF initial guess orbitals for the NO radical. dfomp2-grad2; OMP2 cc-pVDZ energy for the NO molecule. ci-property; CI/MCSCF cc-pvDZ properties for Potassium nitrate (rocket fuel!). fd-freq-gradient-large; SCF DZ finite difference frequencies by gradients for C4NH4. pywrap-db2; Database calculation, run in sow/reap mode. psimrcc-pt2; Mk-MRPT2 single point. \(^1A_1\) F2 state described using the Ms = 0 component of the singlet. Uses TCSCF singlet orbitals. x2c-perturb-h; Test SFX2C-1e with a static electric field on He aug-cc-pVTZ. cepa-module; routing check on lccd, lccsd, cepa(0). cc34; RHF-CCSD/cc-pVDZ energy of H2O partitioned into pair energy contributions. mints15; check SP basis Fortran exponent parsing. cc19; CCSD/cc-pVDZ dipole polarizability at two frequencies. opt10; 6-31G MP2 transition-state optimization with initial, computed Hessian. mp2-grad2; MP2 cc-pVDZ gradient for the NO radical. cubeprop-frontier; ROHF frontier orbitals of CH2(s) and CH2(t). sapt6; checks that all SAPT physical components (elst, exch, indc, disp) and total IE are being com",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html:32856,energy,energy,32856,psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"lculation for the triplet O2 using ODC-06 and ODC-12 functionals. Only simultaneous algorithm is tested. cc48; reproduces dipole moments in J.F. Stanton’s “biorthogonal” JCP paper. pywrap-checkrun-rohf; This checks that all energy methods can run with a minimal input and set symmetry. ci-property; CI/MCSCF cc-pvDZ properties for Potassium nitrate (rocket fuel!). tu4-h2o-freq; Optimization followed by frequencies H2O HF/cc-pVDZ. dcft2; DC-06 calculation for the He dimer. This performs a two-step update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the MO Basis. x2c3; Test of SFX2C-1e on Water uncontracted cc-pVDZ The reference numbers are from Lan Cheng’s implementation in Cfour. scf11-freq-from-energies; Test frequencies by finite differences of energies for planar C4NH4 TS. tu3-h2o-opt; Optimize H2O HF/cc-pVDZ. sapt2; SAPT0 aug-cc-pVDZ computation of the benzene-methane interaction energy, using the aug-pVDZ-JKFIT DF basis for SCF, the aug-cc-pVDZ-RI DF basis for SAPT0 induction and dispersion, and the aug-pVDZ-JKFIT DF basis for SAPT0 electrostatics and induction. This example uses frozen core as well as asyncronous I/O while forming the DF integrals and CPHF coefficients. mcscf1; ROHF 6-31G** energy of the state of CH2, with Z-matrix input. The occupations are specified explicitly. scf-property; UFH and B3LYP cc-pVQZ properties for the CH2 molecule. cc1; RHF-CCSD 6-31G** all-electron optimization of the H2O molecule. dfomp2-4; OMP2 cc-pVDZ energy for the NO molecule. dft3; DFT integral algorithms test, performing w-B97 RKS and UKS computations on water and its cation, using all of the different integral algorithms. This tests both the ERI and ERF integrals. cisd-h2o+-1; 6-31G** H2O+ Test CISD Energy Point. dft-grad; DF-BP86-D2 cc-pVDZ frozen core gradient of S22 HCN. mp2p5-grad1; MP2.5 cc-pVDZ gradient for the H2O molecule. mints1; Symmetry tests for a range of molecules. This doesn’t actually compute any energies, b",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html:23890,energy,energy,23890,psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"lculation of the energies of monomers in the monomer basis, hence specifying ``return_total_data = True`` may carry out more computations than ``return_total_data = False``."",; ""type"": ""boolean""; },; ""quiet"": {; ""title"": ""Quiet"",; ""description"": ""Whether to print/log formatted n-body energy analysis. Presently used by multi to suppress output. Candidate for removal from class once in-class/out-of-class functions sorted."",; ""default"": false,; ""type"": ""boolean""; },; ""task_list"": {; ""title"": ""Task List"",; ""default"": {},; ""type"": ""object"",; ""additionalProperties"": {; ""anyOf"": [; {; ""$ref"": ""#/definitions/AtomicComputer""; },; {; ""$ref"": ""#/definitions/CompositeComputer""; },; {; ""$ref"": ""#/definitions/FiniteDifferenceComputer""; }; ]; }; }; },; ""required"": [; ""molecule"",; ""driver""; ],; ""definitions"": {; ""DriverEnum"": {; ""title"": ""DriverEnum"",; ""description"": ""Allowed computation driver values."",; ""enum"": [; ""energy"",; ""gradient"",; ""hessian"",; ""properties""; ],; ""type"": ""string""; },; ""BsseEnum"": {; ""title"": ""BsseEnum"",; ""description"": ""Available basis-set superposition error (BSSE) treatments."",; ""enum"": [; ""nocp"",; ""cp"",; ""vmfc""; ],; ""type"": ""string""; },; ""AtomicComputer"": {; ""title"": ""AtomicComputer"",; ""description"": ""Computer for analytic single-geometry computations."",; ""type"": ""object"",; ""properties"": {; ""molecule"": {; ""title"": ""Molecule"",; ""description"": ""The molecule to use in the computation.""; },; ""basis"": {; ""title"": ""Basis"",; ""description"": ""The quantum chemistry basis set to evaluate (e.g., 6-31g, cc-pVDZ, ...)."",; ""type"": ""string""; },; ""method"": {; ""title"": ""Method"",; ""description"": ""The quantum chemistry method to evaluate (e.g., B3LYP, MP2, ...)."",; ""type"": ""string""; },; ""driver"": {; ""description"": ""The resulting type of computation: energy, gradient, hessian, properties.Note for finite difference that this should be the target driver, not the means driver."",; ""allOf"": [; {; ""$ref"": ""#/definitions/DriverEnum""; }; ]; },; ""keywords"": {; ""title"": ""Keywords"",; ""de",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/nbody.html:7894,energy,energy,7894,psi4manual/1.7.x/nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/nbody.html,1,['energy'],['energy']
Energy Efficiency,"lculation of the energies of monomers in the monomer basis, hence specifying ``return_total_data = True`` may carry out more computations than ``return_total_data = False``."",; ""type"": ""boolean""; },; ""quiet"": {; ""title"": ""Quiet"",; ""description"": ""Whether to print/log formatted n-body energy analysis. Presently used by multi to suppress output. Candidate for removal from class once in-class/out-of-class functions sorted."",; ""default"": false,; ""type"": ""boolean""; },; ""task_list"": {; ""title"": ""Task List"",; ""default"": {},; ""type"": ""object"",; ""additionalProperties"": {; ""anyOf"": [; {; ""$ref"": ""#/definitions/AtomicComputer""; },; {; ""$ref"": ""#/definitions/CompositeComputer""; },; {; ""$ref"": ""#/definitions/FiniteDifferenceComputer""; }; ]; }; }; },; ""required"": [; ""molecule"",; ""driver""; ],; ""definitions"": {; ""DriverEnum"": {; ""title"": ""DriverEnum"",; ""description"": ""Allowed computation driver values."",; ""enum"": [; ""energy"",; ""gradient"",; ""hessian"",; ""properties""; ],; ""type"": ""string""; },; ""BsseEnum"": {; ""title"": ""BsseEnum"",; ""description"": ""Available basis-set superposition error (BSSE) treatments."",; ""enum"": [; ""nocp"",; ""cp"",; ""vmfc""; ],; ""type"": ""string""; },; ""WavefunctionProtocolEnum"": {; ""title"": ""WavefunctionProtocolEnum"",; ""description"": ""Wavefunction to keep from a computation."",; ""enum"": [; ""all"",; ""orbitals_and_eigenvalues"",; ""occupations_and_eigenvalues"",; ""return_results"",; ""none""; ],; ""type"": ""string""; },; ""ErrorCorrectionProtocol"": {; ""title"": ""ErrorCorrectionProtocol"",; ""description"": ""Configuration for how QCEngine handles error correction\n\nWARNING: These protocols are currently experimental and only supported by NWChem tasks"",; ""type"": ""object"",; ""properties"": {; ""default_policy"": {; ""title"": ""Default Policy"",; ""description"": ""Whether to allow error corrections to be used if not directly specified in `policies`"",; ""default"": true,; ""type"": ""boolean""; },; ""policies"": {; ""title"": ""Policies"",; ""description"": ""Settings that define whether specific error corrections ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/nbody.html:7896,energy,energy,7896,psi4manual/1.9.x/nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/nbody.html,2,['energy'],['energy']
Energy Efficiency,"lculation of the energies of monomers in the monomer basis, hence specifying ``return_total_data = True`` may carry out more computations than ``return_total_data = False``."",; ""type"": ""boolean""; },; ""quiet"": {; ""title"": ""Quiet"",; ""description"": ""Whether to print/log formatted n-body energy analysis. Presently used by multi to suppress output. Candidate for removal from class once in-class/out-of-class functions sorted."",; ""default"": false,; ""type"": ""boolean""; },; ""task_list"": {; ""title"": ""Task List"",; ""default"": {},; ""type"": ""object"",; ""additionalProperties"": {; ""anyOf"": [; {; ""$ref"": ""#/definitions/AtomicComputer""; },; {; ""$ref"": ""#/definitions/CompositeComputer""; },; {; ""$ref"": ""#/definitions/FiniteDifferenceComputer""; }; ]; }; }; },; ""required"": [; ""molecule"",; ""driver""; ],; ""definitions"": {; ""DriverEnum"": {; ""title"": ""DriverEnum"",; ""description"": ""Allowed computation driver values."",; ""enum"": [; ""energy"",; ""gradient"",; ""hessian"",; ""properties""; ],; ""type"": ""string""; },; ""BsseEnum"": {; ""title"": ""BsseEnum"",; ""description"": ""Available basis-set superposition error (BSSE) treatments."",; ""enum"": [; ""nocp"",; ""cp"",; ""vmfc""; ],; ""type"": ""string""; },; ""WavefunctionProtocolEnum"": {; ""title"": ""WavefunctionProtocolEnum"",; ""description"": ""Wavefunction to keep from a computation."",; ""enum"": [; ""all"",; ""orbitals_and_eigenvalues"",; ""return_results"",; ""none""; ],; ""type"": ""string""; },; ""ErrorCorrectionProtocol"": {; ""title"": ""ErrorCorrectionProtocol"",; ""description"": ""Configuration for how QCEngine handles error correction\n\nWARNING: These protocols are currently experimental and only supported by NWChem tasks"",; ""type"": ""object"",; ""properties"": {; ""default_policy"": {; ""title"": ""Default Policy"",; ""description"": ""Whether to allow error corrections to be used if not directly specified in `policies`"",; ""default"": true,; ""type"": ""boolean""; },; ""policies"": {; ""title"": ""Policies"",; ""description"": ""Settings that define whether specific error corrections are allowed. Keys are the name o",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/nbody.html:7974,energy,energy,7974,psi4manual/1.8.x/nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/nbody.html,1,['energy'],['energy']
Energy Efficiency,"ld be used in a given; calculation. For example, consider the following input file:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18molecule h2 {; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; energy('scf') # on H2. clean(). molecule h {; H; }. set basis cc-pvdz; set reference uhf; energy('scf') # on H. Here, two separate jobs are performed on two different molecules; the first is; performed on H2, while the second is for H atom. The last molecule to be; specified is the “active” molecule by default. To explicitly activate a named; molecule, the activate command is provided. With it, the above input file can be; equivalently written as follows. Alternatively, the molecule can be specified; directly to the computing function. Below, the third calculation is the same as; the first.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28molecule h2 {; H; H 1 0.9; }. molecule h {; H; }. activate(h2); set basis cc-pvdz; set reference rhf; energy('scf') # on H2. clean(). activate(h); set basis cc-pvdz; set reference uhf; energy('scf') # on H. # --------------------------------------; # equivalent to previous input ends here. clean(). set reference rhf; energy('scf', molecule=h2) # on H2. Job Control Keywords provides more details about the job control; and calculation keywords used in the above examples. Ghost Atoms¶; While many common computations, particularly SAPT and counterpoise corrections, can; be greatly simplified using the notation described in Non-Covalently Bonded Molecule Fragments,; manual specification of ghost atoms is sometimes required. Either; 1; 2; 3; 4molecule he2 {; He; Gh(He) 1 2.0; }. or; 1; 2; 3; 4molecule he2 {; He; @He 1 2.0; }. will generate a helium dimer with the second atom ghosted, i.e., possessing; basis functions but no electrons or nuclear charge. See dfmp2_1; and ghosts for a demonstration of both mechanisms for specifying; ghost atoms. Isotopic Substitution¶. Caution; U",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psithonmol-1.html:5816,energy,energy,5816,psi4manual/1.1.0/psithonmol-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psithonmol-1.html,6,['energy'],['energy']
Energy Efficiency,"ld_comm, MDI_Accept_Communicator, \; MDI_Send, MDI_Recv, MDI_Recv_Command, MDI_INT, MDI_DOUBLE, \; MDI_Register_Node, MDI_Register_Command; _have_mdi = True; except ImportError:; pass. try:; from mpi4py import MPI; use_mpi4py = True; except ImportError:; use_mpi4py = False. class MDIEngine():; def __init__(self, scf_method, **kwargs):; """""" Initialize an MDIEngine object for communication with MDI. Arguments:; scf_method: Method used when calculating energies or gradients; """""". # Method used when the SCF command is received; self.scf_method = scf_method. # Additional arguments for energy, gradient, or optimization calculations; self.kwargs = kwargs. # Molecule all MDI operations are performed on; input_molecule = kwargs.pop('molecule', psi4.core.get_active_molecule()); self.molecule = input_molecule.clone(); psi4.core.set_active_molecule(self.molecule). # Most recent SCF energy; self.energy = 0.0. # Variables used when MDI sets a lattice of point charges; self.nlattice = 0 # number of lattice point charges; self.clattice = [] # list of lattice coordinates; self.lattice = [] # list of lattice charges; self.lattice_field = psi4.QMMM() # Psi4 chargefield. # MPI variables; self.mpi_world = None; self.world_rank = 0. # Flag for if a lattice of point charges has been set; self.set_lattice = False. # Get correct intra-code MPI communicator; if use_mpi4py:; self.mpi_world = MDI_MPI_get_world_comm(); self.world_rank = self.mpi_world.Get_rank(). # Psi4 does not currently support multiple MPI ranks; if self.mpi_world.Get_size() != 1:; MPI.COMM_WORLD.Abort(). # Accept a communicator to the driver code; self.comm = MDI_Accept_Communicator(). # Ensure that the molecule is using c1 symmetry; self.molecule.reset_point_group('c1'); self.molecule.fix_orientation(True); self.molecule.fix_com(True); self.molecule.reinterpret_coordentry(False); self.molecule.update_geometry(). # Flag to stop listening for MDI commands; self.stop_listening = False. # Dictionary of all supported MDI command",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html:2376,charge,charges,2376,psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html,4,['charge'],['charges']
Energy Efficiency,"ld_comm, MDI_Accept_Communicator, \; MDI_Send, MDI_Recv, MDI_Recv_Command, MDI_INT, MDI_DOUBLE, \; MDI_Register_Node, MDI_Register_Command; _have_mdi = True; except ImportError:; pass. try:; from mpi4py import MPI; use_mpi4py = True; except ImportError:; use_mpi4py = False. class MDIEngine():; def __init__(self, scf_method, **kwargs):; """""" Initialize an MDIEngine object for communication with MDI. Arguments:; scf_method: Method used when calculating energies or gradients; """""". # Method used when the SCF command is received; self.scf_method = scf_method. # Additional arguments for energy, gradient, or optimization calculations; self.kwargs = kwargs. # Molecule all MDI operations are performed on; input_molecule = kwargs.pop('molecule', psi4.core.get_active_molecule()); self.molecule = input_molecule.clone(); psi4.core.set_active_molecule(self.molecule). # Most recent SCF energy; self.energy = 0.0. # Variables used when MDI sets a lattice of point charges; self.nlattice = 0 # number of lattice point charges; self.clattice = [] # list of lattice coordinates; self.lattice = [] # list of lattice charges; self.lattice_field = psi4.QMMMbohr() # Psi4 chargefield. # MPI variables; self.mpi_world = None; self.world_rank = 0. # Flag for if a lattice of point charges has been set; self.set_lattice = False. # Get correct intra-code MPI communicator; if use_mpi4py:; self.mpi_world = MDI_MPI_get_world_comm(); self.world_rank = self.mpi_world.Get_rank(). # Psi4 does not currently support multiple MPI ranks; if self.mpi_world.Get_size() != 1:; MPI.COMM_WORLD.Abort(). # Accept a communicator to the driver code; self.comm = MDI_Accept_Communicator(). # Ensure that the molecule is using c1 symmetry; self.molecule.reset_point_group('c1'); self.molecule.fix_orientation(True); self.molecule.fix_com(True); self.molecule.reinterpret_coordentry(False); self.molecule.update_geometry(). # Flag to stop listening for MDI commands; self.stop_listening = False. # Dictionary of all supported MDI com",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/mdi_engine.html:2376,charge,charges,2376,psi4manual/1.6.x/_modules/psi4/driver/mdi_engine.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/mdi_engine.html,2,['charge'],['charges']
Energy Efficiency,"lden/. Molden can; plot atomic orbitals, densities, electrostatic potentials (ESP’s), etc.; PSI4 can create a file containing; atomic coordinates, basis set, and SCF orbital coefficients in the; so-called Molden format. This file is; written by the SCF module (see Section SCF); if the user sets the MOLDEN_WRITE keyword to true. This Molden file is; also used to pass information between PSI4 and WebMO, if PSI4; computations are invoked using the WebMO GUI. The filename of the; Molden file ends in ”.molden”, and the prefix is determined by; WRITER_FILE_LABEL (if set), or else by the name of the output; file plus the name of the current molecule. If |scf__molden_with_virtual|; is set to false, the unoccupied orbitals are not written to the Molden; file. psi4.molden(wfn, filename)[source]¶; Function to write wavefunction information in wfn to filename in; molden format. Will write natural orbitals from density (MO basis) if supplied.; Warning! Most post-SCF Wavefunctions do not build the density as this is often; much more costly than the energy. In addition, the Wavefunction density attributes; (Da and Db) return the SO density and must be transformed to the MO basis; to use with this function. New in version 0.5: wfn parameter passed explicitly. Returns:None. Parameters:; wfn (Wavefunction) – set of molecule, basis, orbitals from which to generate cube files; filename (string) – destination file name for MOLDEN file (optional); density_a (Matrix) – density in the MO basis to build alpha NO’s from (optional); density_b (Matrix) – density in the MO basis to build beta NO’s from, assumes restricted if not supplied (optional); dovirtual (bool) – do write all the MOs to the MOLDEN file (true) or discard the unoccupied MOs, not valid for NO’s (false) (optional). Examples:. 1; 2; 3>>> # [1] Molden file for DFT calculation; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> molden(wfn, 'mycalc.molden'). 1; 2; 3>>> # [2] Molden file for CI/MCSCF computation using NO roots; >>> ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/molden-1.html:1526,energy,energy,1526,psi4manual/1.1.0/molden-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/molden-1.html,2,['energy'],['energy']
Energy Efficiency,"le = kwargs.pop('restart_file'); # Rename the checkpoint file to be consistent with psi4's file system; psioh = PsiMod.IOManager.shared_object(); psio = PsiMod.IO.shared_object(); filepath = psioh.get_file_path(32); namespace = psio.get_default_namespace(); pid = str(os.getpid()); prefix = 'psi'; targetfile = filepath + prefix + '.' + pid + '.' + namespace + '.32'; if(PsiMod.me() == 0):; shutil.copy(restartfile, targetfile); else:; scf_helper(name, **kwargs). PsiMod.print_out('\n'); banner('DFMP2'); PsiMod.print_out('\n'). # if the df_basis_mp2 basis is not set, pick a sensible one.; if PsiMod.get_global_option('DF_BASIS_MP2') == '':; ribasis = corresponding_rifit(PsiMod.get_global_option('BASIS')); if ribasis:; PsiMod.set_global_option('DF_BASIS_MP2', ribasis); PsiMod.print_out(' No DF_BASIS_MP2 auxiliary basis selected, defaulting to %s\n' % (ribasis)); else:; raise ValidationError('Keyword DF_BASIS_MP2 is required.'). e_dfmp2 = PsiMod.dfmp2(); e_scs_dfmp2 = PsiMod.get_variable('SCS-MP2 TOTAL ENERGY'). optstash.restore(). if (name.upper() == 'SCS-DFMP2') or (name.upper() == 'SCS-DF-MP2'):; return e_scs_dfmp2; elif (name.upper() == 'DF-MP2') or (name.upper() == 'DFMP2') or (name.upper() == 'MP2'):; return e_dfmp2. [docs]def run_psimrcc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for a PSIMRCC computation; using a reference from the MCSCF module. """"""; run_mcscf(name, **kwargs); PsiMod.psimrcc(); return PsiMod.get_variable(""CURRENT ENERGY""). [docs]def run_psimrcc_scf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for a PSIMRCC computation; using a reference from the SCF module. """"""; # Bypass routine scf if user did something special to get it to converge; if not (('bypass_scf' in kwargs) and yes.match(str(kwargs['bypass_scf']))):; scf_helper(name, **kwargs). PsiMod.psimrcc(); return PsiMod.get_variable(""CURRENT ENERGY""). [docs]def run_mp2c(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a coupled MP",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/proc.html:42196,ENERGY,ENERGY,42196,psi4manual/4.0b4/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/proc.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"le SAPT0-D can be used with any of the -D; variants using default parameters optimized for Hartee–Fock interaction energies,; we recommend using the refit parameters with Becke-Johnson damping, as described in; [Schriber:2021:234107]. Again, use of SAPT0-D with a basis set other than; jun-cc-pVDZ is not tested and not guaranteed to give meaningful results without; refitting the dispersion parameters.; A simple water dimer computation using SAPT0-D may look like:; molecule water_dimer {; 0 1; O -1.551007 -0.114520 0.000000; H -1.934259 0.762503 0.000000; H -0.599677 0.040712 0.000000; --; 0 1; O 1.350625 0.111469 0.000000; H 1.680398 -0.373741 -0.758561; H 1.680398 -0.373741 0.758561. units angstrom; no_reorient; symmetry c1; }. set basis jun-cc-pvdz. energy('sapt0-d3mbj') # runs the recommended dispersion correction; energy('sapt0-d3') # tests an alternative damping scheme/parameterization. Given the naturally pairwise-atomic nature of these empirical dispersion corrections,; integration with existing FSAPT functionality is also available simply by calling; energy(""fsapt0-d3mbj""). See FSAPT documentation for more details on using FSAPT; for functional group analyses. table of contents. SAPT: Symmetry-Adapted Perturbation Theory; The S2 approximation and scaling; A First Example; Advanced example; SAPT0; Basic SAPT0 Keywords; SAPT_LEVEL; BASIS; DF_BASIS_SAPT; DF_BASIS_ELST; FREEZE_CORE; CPHF_R_CONVERGENCE; MAXITER; PRINT. Advanced SAPT0 Keywords; AIO_CPHF; AIO_DF_INTS; COUPLED_INDUCTION; EXCH_SCALE_ALPHA; INTS_TOLERANCE; DENOMINATOR_DELTA; DENOMINATOR_ALGORITHM; DEBUG. Specific open-shell SAPT0 keywords; SAPT_MEM_SAFETY; COUPLED_INDUCTION. SAPT(DFT); Basic Keywords for SAPT(DFT); SAPT_DFT_GRAC_SHIFT_A; SAPT_DFT_GRAC_SHIFT_B; SAPT_DFT_DO_DHF; SAPT_DFT_EXCH_DISP_SCALE_SCHEME. Advanced Keywords for SAPT(DFT); SAPT_DFT_FUNCTIONAL; SAPT_DFT_DO_HYBRID; SAPT_DFT_EXCH_DISP_FIXED_SCALE; SAPT_DFT_MP2_DISP_ALG; SAPT_QUIET. Higher-Order SAPT; Basic Keywords for Higher-order SAPT",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/sapt.html:50347,energy,energy,50347,psi4manual/master/sapt.html,https://psicode.org,https://psicode.org/psi4manual/master/sapt.html,1,['energy'],['energy']
Energy Efficiency,"le SAPT0-D can be used with any of the -D; variants using default parameters optimized for Hartee–Fock interaction energies,; we recommend using the refit parameters with Becke-Johnson damping, as described in; [Schriber:2021:234107]. Again, use of SAPT0-D with a basis set other than; jun-cc-pVDZ is not tested and not guaranteed to give meaningful results without; refitting the dispersion parameters.; A simple water dimer computation using SAPT0-D may look like:; molecule water_dimer {; 0 1; O -1.551007 -0.114520 0.000000; H -1.934259 0.762503 0.000000; H -0.599677 0.040712 0.000000; --; 0 1; O 1.350625 0.111469 0.000000; H 1.680398 -0.373741 -0.758561; H 1.680398 -0.373741 0.758561. units angstrom; no_reorient; symmetry c1; }. set basis jun-cc-pvdz. energy('sapt0-d3mbj') # runs the recommended dispersion correction; energy('sapt0-d3') # tests an alternative damping scheme/parameterization. Given the naturally pairwise-atomic nature of these empirical dispersion corrections,; integration with existing FSAPT functionality is also available simply by calling; energy(""fsapt0-d3mbj""). See FSAPT documentation for more details on using FSAPT; for functional group analyses. table of contents. SAPT: Symmetry-Adapted Perturbation Theory; The S2 approximation and scaling; A First Example; Advanced example; SAPT0; Basic SAPT0 Keywords; SAPT_LEVEL; BASIS; DF_BASIS_SAPT; DF_BASIS_ELST; FREEZE_CORE; D_CONVERGENCE; E_CONVERGENCE; MAXITER; PRINT. Advanced SAPT0 Keywords; AIO_CPHF; AIO_DF_INTS; COUPLED_INDUCTION; EXCH_SCALE_ALPHA; INTS_TOLERANCE; DENOMINATOR_DELTA; DENOMINATOR_ALGORITHM; DEBUG. Specific open-shell SAPT0 keywords; SAPT_MEM_SAFETY; COUPLED_INDUCTION. SAPT(DFT); Basic Keywords for SAPT(DFT); SAPT_DFT_GRAC_SHIFT_A; SAPT_DFT_GRAC_SHIFT_B; SAPT_DFT_DO_DHF; SAPT_DFT_EXCH_DISP_SCALE_SCHEME. Advanced Keywords for SAPT(DFT); SAPT_DFT_FUNCTIONAL; SAPT_DFT_DO_HYBRID; SAPT_DFT_EXCH_DISP_FIXED_SCALE; SAPT_DFT_MP2_DISP_ALG; SAPT_QUIET. Higher-Order SAPT; Basic Keywords for Higher-",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/sapt.html:49854,energy,energy,49854,psi4manual/1.7.x/sapt.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/sapt.html,3,['energy'],['energy']
Energy Efficiency,"le SAPT0-D can be used with any of the -D; variants using default parameters optimized for Hartee–Fock interaction energies,; we recommend using the refit parameters with Becke-Johnson damping, as described in; [Schriber:2021:234107]. Again, use of SAPT0-D with a basis set other than; jun-cc-pVDZ is not tested and not guaranteed to give meaningful results without; refitting the dispersion parameters.; A simple water dimer computation using SAPT0-D may look like:; molecule water_dimer {; 0 1; O -1.551007 -0.114520 0.000000; H -1.934259 0.762503 0.000000; H -0.599677 0.040712 0.000000; --; 0 1; O 1.350625 0.111469 0.000000; H 1.680398 -0.373741 -0.758561; H 1.680398 -0.373741 0.758561. units angstrom; no_reorient; symmetry c1; }. set basis jun-cc-pvdz. energy('sapt0-d3mbj') # runs the recommended dispersion correction; energy('sapt0-d3') # tests an alternative damping scheme/parameterization. Given the naturally pairwise-atomic nature of these empirical dispersion corrections,; integration with existing FSAPT functionality is also available simply by calling; energy(“fsapt0-d3mbj”). See FSAPT <fisapt> documentation for more details on using FSAPT; for functional group analyses. table of contents. SAPT: Symmetry-Adapted Perturbation Theory; The S2 approximation and scaling; A First Example; Advanced example; SAPT0; Basic SAPT0 Keywords; SAPT_LEVEL; BASIS; DF_BASIS_SAPT; DF_BASIS_ELST; FREEZE_CORE; D_CONVERGENCE; E_CONVERGENCE; MAXITER; PRINT. Advanced SAPT0 Keywords; AIO_CPHF; AIO_DF_INTS; COUPLED_INDUCTION; EXCH_SCALE_ALPHA; INTS_TOLERANCE; DENOMINATOR_DELTA; DENOMINATOR_ALGORITHM; DEBUG. Specific open-shell SAPT0 keywords; SAPT_MEM_SAFETY; COUPLED_INDUCTION. SAPT(DFT); Basic Keywords for SAPT(DFT); SAPT_DFT_GRAC_SHIFT_A; SAPT_DFT_GRAC_SHIFT_B; SAPT_DFT_DO_DHF; SAPT_DFT_EXCH_DISP_SCALE_SCHEME. Advanced Keywords for SAPT(DFT); SAPT_DFT_FUNCTIONAL; SAPT_DFT_DO_HYBRID; SAPT_DFT_EXCH_DISP_FIXED_SCALE; SAPT_DFT_MP2_DISP_ALG; SAPT_QUIET. Higher-Order SAPT; Basic Keywords fo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/sapt-1.html:46557,energy,energy,46557,psi4manual/1.4.0/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/sapt-1.html,5,['energy'],['energy']
Energy Efficiency,"le ab|cd \rangle\) ). frac-sym; Fractional occupation with symmetry. scf-ecp2; Water-Argon complex with ECP present; check of RHF Hessian. cc8a; ROHF-CCSD(T) cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Cartesian input. scf2; RI-SCF cc-pVTZ energy of water, with Z-matrix input and cc-pVTZ-RI auxilliary basis. pywrap-checkrun-convcrit; Advanced python example sets different sets of scf/post-scf conv crit and check to be sure computation has actually converged to the expected accuracy. dfomp3-grad2; DF-OMP3 cc-pVDZ gradients for the H2O+ cation. mbis-6; MBIS calculation on H2O. omp2-3; OMP2 cc-pVDZ energy for the NO radical. castup1; Test of SAD/Cast-up (mainly not dying due to file weirdness). mp2p5-grad2; MP2.5 cc-pVDZ gradient for the NO radical. cbs-xtpl-gradient; Various gradients for a strained helium dimer and water molecule. psithon1; Spectroscopic constants of H2, and the full ci cc-pVTZ level of theory. cdoremp-energy1; Cholesky decomposed OO-REMP/cc-pVDZ energy for the H2O molecule. density-screen-1; RHF Density Matrix based-Integral Screening Test for water. numpy-array-interface; Numpy interface testing. mints1; Symmetry tests for a range of molecules. This doesn’t actually compute any energies, but serves as an example of the many ways to specify geometries in Psi4. dfomp2-grad2; OMP2 cc-pVDZ energy for the NO molecule. linK-3; UHF and ROHF Linear Exchange Algorithm test for benzyl cation. cc13d; Tests analytic CC2 gradients. cc49; EOM-CC3(UHF) on CH radical with user-specified basis and properties for particular root. cc13a; UHF-CCSD(T)/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. scf3; File retention, docc, socc, and bond distances specified explicitly. phi-ao; Test computing values of basis functions (puream and non-puream) at points. fsaptd-terms; F-SAPT0/jun-cc-pvdz procedure for methane dimer. omp3-4; SCS-OMP3 cc-pVDZ geometry optimization for the H2O molecule. scf-hess5; DF SCF 6-31G anal",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html:41185,energy,energy,41185,psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"le arg0 in the structural variables list. inertia_tensor(self); Returns intertial tensor. input_units_to_au(self); Returns unit conversion to [a0] for geometry. irrep_labels(self); Returns Irreducible Representation symmetry labels. is_variable(self, arg0); Checks if variable arg0 is in the structural variables list. label(self, atom); Gets the original label of the atom as given in the input file (C2, H4)(0-indexed without dummies). mass(self, atom); Returns mass of atom (0-indexed). mass_number(self, arg0); Mass number (A) of atom if known, else -1. molecular_charge(self); Gets the molecular charge. move_to_com(self); Moves molecule to center of mass. multiplicity(self); Gets the multiplicity (defined as 2Ms + 1). nallatom(self); Number of real and dummy atoms. name(self); Gets molecule name. natom(self); Number of real atoms. nfragments(self); Gets the number of fragments in the molecule. nuclear_dipole(*args, **kwargs); Overloaded function. nuclear_repulsion_energy(self, dipole_field, …); Computes nuclear repulsion energy. nuclear_repulsion_energy_deriv1(self, …); Returns first derivative of nuclear repulsion energy as a matrix (natom, 3). nuclear_repulsion_energy_deriv2(self); Returns second derivative of nuclear repulsion energy as a matrix (natom X 3, natom X 3). orientation_fixed(self); Get whether or not orientation is fixed. point_group(self); Returns the current point group object. print_bond_angles(self); Print the bond angle geometrical parameters. print_cluster(self); Prints the molecule in Cartesians in input units adding fragment separators. print_distances(self); Print the interatomic distance geometrical parameters. print_in_input_format(self); Prints the molecule as Cartesian or ZMatrix entries, just as inputted. print_out(self); Prints the molecule in Cartesians in input units to output file. print_out_in_angstrom(self); Prints the molecule in Cartesians in Angstroms to output file. print_out_in_bohr(self); Prints the molecule in Cartesians in Bo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.molecule.html:5447,energy,energy,5447,psi4manual/1.3.2/api/psi4.core.molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.molecule.html,3,['energy'],['energy']
Energy Efficiency,"le array [e a0] for the averaged quadratic coupled-cluster level of theory, (3,). AQCC QUADRUPOLE¶; Redundant quadrupole array [e a0^2] for the averaged quadratic coupled-cluster level of theory, (3, 3). AQCC TOTAL ENERGY¶. AQCC CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the averaged quadratic coupled-cluster level of theory. BRUECKNER CONVERGED¶; Value 1 (0) when the Brueckner orbitals have (have not) converged. CBS NUMBER¶. NBODY NUMBER¶. FINDIF NUMBER¶; Number of tasks [] the named procedure performs. These are immediate; tasks, so if procedures are nested, the total number of tasks is; the product. CBS TOTAL ENERGY¶. CBS CORRELATION ENERGY¶. CBS REFERENCE ENERGY¶; The total electronic energy [E_h] and its breakdown into reference total; energy [E_h] and correlation correction components [E_h] for the compound; method requested through cbs(). CCname ROOT n TOTAL ENERGY¶. TD-fctl ROOT n TOTAL ENERGY¶; The total electronic energy [E_h] for the requested theory and root n (n starts at 0).; DFT functional labeled if canonical. CCname ROOT n (IN h) TOTAL ENERGY¶. TD-fctl ROOT n (IN h) TOTAL ENERGY¶; The total electronic energy [E_h] for the requested theory and root n within irrep h (n starts at 0).; DFT functional labeled if canonical. CCname ROOT n (h) TOTAL ENERGY¶. TD-fctl ROOT n (h) TOTAL ENERGY¶; The total electronic energy [E_h] for the requested theory and root n, which is of irrep h (n starts at 0).; DFT functional labeled if canonical. CCname ROOT n TOTAL ENERGY - h TRANSITION¶. TD-fctl ROOT n TOTAL ENERGY - h TRANSITION¶; The total electronic energy [E_h] for the requested theory and root n, and the transition is of irrep h, (n starts at 0). CCname ROOT n CORRELATION ENERGY¶; The correlation energy [E_h] for the requested coupled cluster level of theory and root n (n starts at 0).; DFT functional labeled if canonical. CCname ROOT n (IN h) CORRELATION ENERGY¶; The correlation energy [E_h] for the request",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html:8174,energy,energy,8174,psi4manual/1.7.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html,4,['energy'],['energy']
Energy Efficiency,"le command print_variables(). Note that PSI variables; are cleared at the start of each energy(), etc. in an input; file by clean_variables().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the; last will include SCF TOTAL ENERGY but not; FCI TOTAL ENERGY.; The entire dictionary of PSI variables can be obtained through; get_variables(). Return Values¶; Most of the usual user computation functions (i.e.,; energy(), optimize(), and; frequency()) return simply the current total energy.; Consult the descriptions of other functions in Psithon Functions: Invoking a Calculation for; what quantities they return and for what data structures they make; available for post-processing. Many users need only deal with the simple return; form for the computation functions. PSIthonPsiAPI# E is total energy float; # G is gradient array; # H is hessian array; # wfn is class instance with many computational details. # simple returns; E = energy(...); E = optimize(...); E = frequency(...); G = gradient(...) # used by optimize(); H = hessian(...) # used by frequency(). # E is total energy float; # G is gradient array; # H is hessian array; # wfn is class instance with many computational details. # simple returns; E = psi4.energy(...); E = psi4.optimize(...); E = psi4.frequency(...); G = psi4.gradient(...) # used by optimize(); H = psi4.hessian(...) # used by frequency(). For more elaborate post-processing of computations, adding; return_wfn=True keyword argument additionally returns; Wavefunction. PSIthonPsiAPI# power user returns; E, wfn = energy(..., return_wfn=True); E, wfn = optimize(..., return_wfn=True); E, wfn = frequency(..., return_wfn=True); G, wfn = gradient(..., return_wfn=True) # used by optimize(); H, wfn = hessian(..., return_wfn=True) # used by frequency(). # print gradient array and its rms; wfn.gradient.print_out(); print wfn.gradient().rms(). # format output for other programs; molden(wfn, 'myca",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/psithoninput.html:10479,energy,energy,10479,psi4manual/master/psithoninput.html,https://psicode.org,https://psicode.org/psi4manual/master/psithoninput.html,1,['energy'],['energy']
Energy Efficiency,"le corrections, especially those of asymmetrics, provide significantly better potential energy curves than; CCSD based triples corrections. Theory¶; What follows is a very basic description of orbital-optimized Møller–Plesset perturbation; theory as implemented in PSI4. We will follow our previous presentations ([Bozkaya:2011:omp2],; [Bozkaya:2011:omp3], and [Bozkaya:2012:odtl]); The orbital variations may be expressed by means of an exponential unitary operator. where is the orbital rotation operator. The effect of the orbital rotations on the MO coefficients can be written as. where is the initial MO coefficient matrix and is the new; MO coefficient matrix as a function of .; Now, let us define a variational energy functional (Lagrangian) as a function of . OMP2. OMP3. OCEPA. where subscript c means only connected diagrams are allowed, and; , , and defined as. where , and are the one- and two-electron components of normal-ordered Hamiltonian. Then,; first and second derivatives of the energy with respect to the parameter at . Then the energy can be expanded up to second-order as follows. where is the MO gradient vector, is the MO rotation vector,; and is the MO Hessian matrix. Therefore, minimizing the energy with respect to ; yields. This final equation corresponds to the usual Newton-Raphson step.; Publications resulting from the use of the OMP2 code should cite the following publication(s):; [Bozkaya:2011:omp2].; Publications resulting from the use of the OMP3 code should cite the following publications:; [Bozkaya:2011:omp3] and [Bozkaya:2013:omp3].; Publications resulting from the use of the OMP2.5 code should cite the following publications:; [Bozkaya:2011:omp3] and [Bozkaya:2013:omp3].; Publications resulting from the use of the OCEPA code should cite the following publication(s):; [Bozkaya:2011:omp2].; Publications resulting from the use of the MP2 code should cite the following publication(s):; [Bozkaya:2011:omp2].; Publications resulting from the use of th",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/occ-1.html:3812,energy,energy,3812,psi4manual/4.0b4/occ-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/occ-1.html,2,['energy'],['energy']
Energy Efficiency,"le corrections, especially those of asymmetrics, provide significantly better potential energy curves than; CCSD based triples corrections. Theory¶; What follows is a very basic description of orbital-optimized Møller–Plesset perturbation; theory as implemented in PSI4. We will follow our previous presentations ([Bozkaya:2011:omp2],; [Bozkaya:2011:omp3], and [Bozkaya:2012:odtl]); The orbital variations may be expressed by means of an exponential unitary operator. where is the orbital rotation operator. The effect of the orbital rotations on the MO coefficients can be written as. where is the initial MO coefficient matrix and is the new; MO coefficient matrix as a function of .; Now, let us define a variational energy functional (Lagrangian) as a function of . OMP2. OMP3. OCEPA. where subscript c means only connected diagrams are allowed, and; , , and defined as. where , and are the one- and two-electron components of normal-ordered Hamiltonian. Then,; first and second derivatives of the energy with respect to the parameter at . Then the energy can be expanded up to second-order as follows. where is the MO gradient vector, is the MO rotation vector,; and is the MO Hessian matrix. Therefore, minimizing the energy with respect to ; yields. This final equation corresponds to the usual Newton-Raphson step.; Publications resulting from the use of the OMP2 code should cite the following publications:; [Bozkaya:2011:omp2] and [Bozkaya:2013:omp2grad].; Publications resulting from the use of the OMP3 code should cite the following publications:; [Bozkaya:2011:omp3] and [Bozkaya:2013:omp3].; Publications resulting from the use of the OMP2.5 code should cite the following publications:; [Bozkaya:2011:omp3] and [Bozkaya:2013:omp3].; Publications resulting from the use of the OCEPA code should cite the following publication(s):; [Bozkaya:2011:omp2].; Publications resulting from the use of the MP2 code should cite the following publication(s):; [Bozkaya:2011:omp2].; Publications re",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/occ-1.html:3837,energy,energy,3837,psi4manual/4.0b5/occ-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/occ-1.html,2,['energy'],['energy']
Energy Efficiency,"le doesn’t depend on options (scf_type) being set global or local. This input uses global. gibbs; Test Gibbs free energies at 298 K of N2, H2O, and CH4. dfmp2-fc; Kr–Kr nocp energies with all-electron basis set to check frozen core. mp2p5-grad1; MP2.5 cc-pVDZ gradient for the H2O molecule. dfmp2-4; conventional and density-fitting mp2 test of mp2 itself and setting scs-mp2. scf-ecp3; Water-Argon complex with ECP present; check of UHF Hessian. cdoremp-energy2; density fitted OO-REMP/cc-pVDZ engrad single points for the H2O+ molecule. psimrcc-ccsd_t-4; Mk-MRCCSD(T) single point. \(^1A_1\) O$_3` state described using the Ms = 0 component of the singlet. Uses TCSCF orbitals. fnocc5; Test FNO-DF-CCSD(T) energy. mints-benchmark; run some BLAS benchmarks. dfmp2-3; DF-MP2 cc-pVDZ frozen core gradient of benzene, computed at the DF-SCF cc-pVDZ geometry. mbis-1; MBIS calculation on H2O. cisd-sp-2; 6-31G** H2O Test CISD Energy Point. casscf-semi; CASSCF/6-31G** energy point. Check energy with frozen core/virtual orbs. after semicanonicalization. fsapt-ext; Quick test of external potential in F-SAPT (see fsapt1 for a real example). stability2; ROHF stability analysis check for CN with cc-pVDZ. This test corresponds to the rohf-stab test from Psi3. dft-reference; MP2 with a PBE0 reference computation. scf-guess; Test initial SCF guesses on FH and FH+ in cc-pVTZ basis. cubeprop-esp; RHF orbitals and density for water. fd-freq-energy; SCF STO-3G finite-difference frequencies from energies for H2O. linK-2; RKS Linear Exchange Algorithm test for benzene. opt15; 6-31G(d) optimization of SF4 starting from linear bond angle that is not linear in the optimized structure but is in a symmetry plane of the molecule. freq-isotope1; Vibrational and thermo analysis of several water isotopologs. Demonstrates Hessian reuse for different temperatures and pressures but not for different isotopologs. tdscf-1; td-uhf test on triplet states of methylene (rpa). dct6; DCT calculation for the triplet O",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html:30425,energy,energy,30425,psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"le field of magnitude 0.05 a.u. in the y direction and; 0.1 a.u. in the z direction, we can use the following keywords:; set perturb_h true; set perturb_with dipole; set perturb_dipole [ 0, 0.05, 0.1 ]. Note that if any specified fields do not fall along a symmetry axis, the; symmetry of the calculation should be reduced accordingly; if in doubt run the; calculation in C1 symmetry. For examples of SCF and MP2 calculations in an; external field, see scf7 and dfmp2-grad5. Convergence and Algorithm Defaults¶. SCF algorithm and convergence criteria defaults by calculation type [1]¶. Ab Initio Method; Calculation Type; E_CONVERGENCE; D_CONVERGENCE; SCF_TYPE. SCF of HF or DFT; energy; 6; 6; DF. optimization; 8; 8. frequency [7]; 8; 8. SCF of post-HF; energy; 8; 8; PK [3]. optimization; 10; 10. frequency [7]; 10; 10. CC property [2]; 10; 10. Post-SCF convergence criteria defaults by calculation type [4]¶. Ab Initio Method; Calculation Type; E_CONVERGENCE [5]; R_CONVERGENCE [6]. post-HF of post-HF; energy; 6. optimization; 8. frequency [7]; 8. CC property [2]; 8. Footnotes. [1]; Note that this table applies only the SCF module,; not to the final convergence criteria for post-HF methods or to methods; that use an alternate starting point, like MCSCF. SAPT computations, too,; set tighter values. [2]; (1,2); This applies to properties computed through the properties() function. [3]; Post-HF methods that do not rely upon the usual 4-index AO integrals use a; density-fitted SCF reference. That is, for DF-MP2 and SAPT, the default SCF_TYPE is DF. [4]; Note that this table applies to the final convergence criteria for; all the post-SCF modules that define a E_CONVERGENCE keyword. [5]; The E_CONVERGENCE keyword is implemented for most post-SCF modules.; See a list beginning at E_CONVERGENCE. [6]; The R_CONVERGENCE keyword places a convergence check on an internal; residual error measure and is implemented for several post-SCF; modules (see list beginning at R_CONVERGENCE). It is def",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/scf.html:47045,energy,energy,47045,psi4manual/1.7.x/scf.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/scf.html,4,['energy'],['energy']
Energy Efficiency,"le field. cisd-sp-2; 6-31G** H2O Test CISD Energy Point. dfep2-1; Compute three IP and 2 EA’s for the PH3 molecule. opt1; SCF STO-3G geometry optimzation, with Z-matrix input. sapt-compare; SAPT0 cc-pVDZ computation of the ethene-ethyne interaction energy, using the cc-pVDZ-JKFIT RI basis for SCF and cc-pVDZ-RI for SAPT. Monomer geometries are specified using Cartesian coordinates. adc1; ADC/6-31G** on H2O. mp2-grad2; MP2 cc-pVDZ gradient for the NO radical. dfccsd-grad1; DF-CCSD cc-pVDZ gradients for the H2O molecule. dft-omega; Test omega is setable. dft3; DFT integral algorithms test, performing w-B97 RKS and UKS computations on water and its cation, using all of the different integral algorithms. This tests both the ERI and ERF integrals. cc8; UHF-CCSD(T) cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Z-matrix input. mp3-grad2; MP3 cc-pVDZ gradient for the NO radical. scf6; Tests RHF/ROHF/UHF SCF gradients. cc4; RHF-CCSD(T) cc-pVQZ frozen-core energy of the BH molecule, with Cartesian input. After the computation, the checkpoint file is renamed, using the PSIO handler. pywrap-opt-sowreap; Finite difference optimization, run in sow/reap mode. dfccsd-t-grad1; DF-CCSD(T) cc-pVDZ gradients for the H2O molecule. cc47; EOM-CCSD/cc-pVDZ on H2O2 with two excited states in each irrep. dcft-grad2; RHF-ODC-12 analytic gradient computations for H2O use AO_BASIS=DISK and AO_BASIS=NONE, respectively. RHF-ODC-06 analytic gradient computations for H2O use AO_BASIS=DISK and AO_BASIS=NONE, respectively. dft-grad-lr3; wB97X-D test for a large UKS molecule. fsapt2; A very quick correctness test of F-SAPT (see fsapt1 for a real example). cepa3; cc-pvdz H2O Test coupled-pair CISD against DETCI CISD. cc32; CC3/cc-pVDZ H2O \(R_e\) geom from Olsen et al., JCP 104, 8007 (1996). scf-hess1; RHF STO-3G (Cartesian) and cc-pVDZ (spherical) water Hessian test, against Psi3 reference values. ocepa-freq1; OCEPA cc-pVDZ freqs for C2H2. dfccsdt1; DF-CCSD(T) cc-pVDZ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html:9197,energy,energy,9197,psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"le field. cisd-sp-2; 6-31G** H2O Test CISD Energy Point. dfep2-1; Compute three IP and 2 EA’s for the PH3 molecule. opt1; SCF STO-3G geometry optimzation, with Z-matrix input. sapt-compare; SAPT0 cc-pVDZ computation of the ethene-ethyne interaction energy, using the cc-pVDZ-JKFIT RI basis for SCF and cc-pVDZ-RI for SAPT. Monomer geometries are specified using Cartesian coordinates. adc1; ADC/6-31G** on H2O. mp2-grad2; MP2 cc-pVDZ gradient for the NO radical. dfccsd-grad1; DF-CCSD cc-pVDZ gradients for the H2O molecule. dft-omega; Test omega is setable. dft3; DFT integral algorithms test, performing w-B97 RKS and UKS computations on water and its cation, using all of the different integral algorithms. This tests both the ERI and ERF integrals. cc8; UHF-CCSD(T) cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Z-matrix input. mp3-grad2; MP3 cc-pVDZ gradient for the NO radical. scf6; Tests RHF/ROHF/UHF SCF gradients. cc4; RHF-CCSD(T) cc-pVQZ frozen-core energy of the BH molecule, with Cartesian input. After the computation, the checkpoint file is renamed, using the PSIO handler. pywrap-opt-sowreap; Finite difference optimization, run in sow/reap mode. opt-full-hess-every; SCF/sto-3g optimization with a hessian every step. dfccsd-t-grad1; DF-CCSD(T) cc-pVDZ gradients for the H2O molecule. cc47; EOM-CCSD/cc-pVDZ on H2O2 with two excited states in each irrep. dcft-grad2; RHF-ODC-12 analytic gradient computations for H2O use AO_BASIS=DISK and AO_BASIS=NONE, respectively. RHF-ODC-06 analytic gradient computations for H2O use AO_BASIS=DISK and AO_BASIS=NONE, respectively. dft-grad-lr3; wB97X-D test for a large UKS molecule. fsapt2; A very quick correctness test of F-SAPT (see fsapt1 for a real example). cepa3; cc-pvdz H2O Test coupled-pair CISD against DETCI CISD. cc32; CC3/cc-pVDZ H2O \(R_e\) geom from Olsen et al., JCP 104, 8007 (1996). scf-hess1; RHF STO-3G (Cartesian) and cc-pVDZ (spherical) water Hessian test, against Psi3 reference values.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html:9815,energy,energy,9815,psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"le is capable of computing energies for arbitrary; order Møller–Plesset perturbation theory (MPn, for closed-shell; systems with an RHF reference) and for Z-averaged perturbation theory; (ZAPTn, open-shell systems with a ROHF reference). However, please; note that these computations are essentially doing high-order CI (up to; full CI) computations to obtain these results, and hence they will only; be possible for very small systems (generally a dozen electrons or less).; The simplest way to run high-order perturbation theory computations is to; call, e.g., energy('mp10') to invoke a MP10 computation or; energy('zapt25') to invoke a ZAPT25 computation. This will; automatically set several additional user options to their appropriate; values. The program uses the Wigner (2n+1) rule to obtain higher-order; energies from lower-order wavefunctions.; For the interested reader, the additional user options that are; automatically set up by the calls above are as follows. A call like; energy('mp10') sets MPN to TRUE.; The program uses the Wigner (2n+1) rule by default; (MPN_WIGNER = TRUE); and figures out what order of wavefunction is; necessary to reach the desired order in the energy. The program then; sets MAX_NUM_VECS to the required order in the; wavefunction.; By default, the requested n-th order energy is saved as the current; energy to the process environment. ZAPTN works essentially the same; way for an ROHF reference. Arbitrary Order Coupled-Cluster Theory¶; This DETCI-based version of this feature is not yet released. However,; the current version of the code does include an interface to; Kallay’s MRCC code.; The DETCI module is also capable of computing arbitrary-order; coupled-cluster energies, using an approach similar to that of Hirata; and Bartlett [Hirata:2000:216], or of Olsen [Olsen:2000:7140].; Notably, the approach in DETCI also allows arbitrary-order; active space coupled-cluster procedures. The general algorithm; for doing this in DETCI is inefficient ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/detci-1.html:11086,energy,energy,11086,psi4manual/1.2.1/detci-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/detci-1.html,15,['energy'],['energy']
Energy Efficiency,"le specification. EFP_DISP (EFP). EFP_DISP_DAMPING (EFP). EFP_ELST (EFP). EFP_ELST_DAMPING (EFP). EFP_EXCH (EFP). EFP_IND (EFP). EFP_IND_DAMPING (EFP). EFP_QM_ELST (EFP). EFP_QM_IND (EFP). efzc() psi4.core.CCWavefunction method, [1]. psi4.core.CIWavefunction method, [1]. psi4.core.CUHF method, [1]. psi4.core.DFEP2Wavefunction method, [1]. psi4.core.HF method, [1]. psi4.core.RHF method, [1]. psi4.core.ROHF method, [1]. psi4.core.UHF method, [1]. psi4.core.Wavefunction method, [1], [2]. EKT_EA (OCC). EKT_IP (DFOCC). (OCC). electric_field() psi4.core.IntegralFactory method, [1], [2]. psi4.core.MintsHelper method, [1], [2]. ElectricFieldInt class in psi4.core, [1]. electrostatic() psi4.core.IntegralFactory method, [1], [2]. ElectrostaticInt class in psi4.core, [1]. elst() psi4.core.FISAPT method, [1], [2]. EmpiricalDispersion class in psi4.driver. end() psi4.core.Slice method, [1], [2]. EndLoop psi4.core.PsiReturnType attribute, [1], [2]. energies_from_fcidump() in module psi4.driver. energy(). setting keywords. energy() in module psi4. in module psi4.driver. psi4.core.CCWavefunction method, [1]. psi4.core.CIWavefunction method, [1]. psi4.core.CUHF method, [1]. psi4.core.DFEP2Wavefunction method, [1]. psi4.core.HF method, [1]. psi4.core.RHF method, [1]. psi4.core.ROHF method, [1]. psi4.core.UHF method, [1]. psi4.core.Wavefunction method, [1], [2]. ENERGY_LEVEL_SHIFT (DCFT). engine psi4.driver.EmpiricalDispersion attribute. ENSURE_BT_CONVERGENCE (OPTKING). environment variable. ; CONDA_PREFIX, [1]. CRAYPE_LINK_TYPE. CRAY_ADD_RPATH. HOST, [1]. MATH_ROOT. MKL_NUM_THREADS, [1]. MKL_ROOT. MONTAGE. OMP_NESTED, [1], [2]. OMP_NUM_THREADS, [1], [2], [3], [4], [5], [6], [7], [8], [9]. PATH, [1], [2], [3], [4], [5], [6], [7], [8], [9], [10], [11], [12], [13], [14], [15], [16], [17], [18], [19], [20], [21], [22], [23], [24], [25], [26], [27], [28], [29], [30], [31], [32], [33], [34]. PSIDATADIR, [1], [2], [3], [4], [5]. PSIPATH, [1], [2], [3], [4], [5], [6], [7], [8], [9], [10], [1",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/genindex-1.html:51396,energy,energy,51396,psi4manual/1.3.2/genindex-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/genindex-1.html,2,['energy'],['energy']
Energy Efficiency,"le truncation of the very popular aug-cc-pVDZ basis set); that PSI4 correctly guesses that we want the jun-cc-pVDZ-JKFIT; auxiliary basis for the Hartree–Fock, and the jun-cc-pVDZ-RI basis set; for the SAPT procedure.; To speed up the computation a little, we also tell the SAPT procedure to; freeze the core electrons with freeze_core True. The SAPT; procedure is invoked with the simple call, energy('sapt0')}. This; call knows to automatically run two monomer computations and a dimer; computation and then use these results to perform the SAPT analysis. The; various energy components are printed at the end of the output, in addition; to the total SAPT0 interaction energy. An explanation of the various; energy components can be found in the review by Jeziorski, Moszynski, and; Szalewicz [Jeziorski:1994:1887], and this is discussed in more detail; in the SAPT section later in this manual. For now, we’ll note that most of; the SAPT energy components are negative; this means those are attractive; contributions (the zero of energy in a SAPT computation is defined as; non-interacting monomers). The exchange contributions are positive; (repulsive). In this example, the most attractive contribution between; ethylene and acetylene is an electrostatic term of -2.12 kcal mol-1; (Elst10,r where the 1 indicates the first-order; perturbation theory result with respect to the intermolecular interaction,; and the 0 indicates zeroth-order with respect to intramolecular electron; correlation). The next most attractive contribution is the Disp20; term (2nd order intermolecular dispersion, which looks like an MP2 in which; one excitation is placed on each monomer), contributing an attraction of; -1.21 kcal mol-1. It is not surprising that the electrostatic; contribution is dominant, because the geometry chosen for this example has the; acetylene perpendicular to the ethylene, with the acetylene hydrogen; pointing directly at the double bond in ethylene; this will be attractive; because t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/tutorial-1.html:12294,energy,energy,12294,psi4manual/4.0b2/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/tutorial-1.html,4,['energy'],['energy']
Energy Efficiency,"le were to read; set basis cc-pVDZ; energy('ccsd'); set ccenergy print 3; set scf print 1. the commands that set the print level would be ineffective, as they would be; processed after the CCSD computation completes.; In PsiAPI mode, one can use the command set_options(); like below for general and module-specific options. Note that these values; should be of correct type, strings for strings, floats for floats like; convergences. The function clean_options() that reinitializes; all options may also be useful to separate calculations in a PsiAPI; session. PSIthonPsiAPIset {; scf_type = pk; e_convergence = 1.e-5; soscf = True; geom_maxiter = 50; }. psi4.set_options({; 'scf_type': 'pk',; 'e_convergence': 1.e-5,; 'soscf': True,; 'geom_maxiter': 50; }). Basis Sets¶. Basis Sets; Built-In Basis Sets; Mixing Basis Sets; Decontracted Basis Sets; User-Defined Basis Sets; Inputting effective core potentials (ECPs). PSI Variables¶; To harness the power of Python, PSI4 makes the most pertinent results; of each computation available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of; H2 and H atom. PSIthonPsiAPImolecule h2 {; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h {; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol * (2*h_energy - h2_energy); print (""De = %f"" % D_e). h2 = psi4.geometry(""""""; H; H 1 0.9; """"""). psi4.set_options({""basis"": ""cc-pvdz"",; ""reference"": ""rhf""}); h2_energy = psi4.energy('scf'). h = psi4.geometry(""""""; H; """"""). psi4.set_options({""basis"": ""cc-pvdz"",; ""reference"": ""uhf""}); h_energy = psi4.energy('scf'). D_e = psi4.constants.hartree2kcalmol * (2*h_energy - h2_energy); print(""De = %f"" % D_e). The energy() function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/psithoninput.html:7635,power,power,7635,psi4manual/master/psithoninput.html,https://psicode.org,https://psicode.org/psi4manual/master/psithoninput.html,1,['power'],['power']
Energy Efficiency,"le(""CURRENT ENERGY""); gradients_dict[pair] = wfn.gradient(); var_key = ""N-BODY (%s)@(%s) TOTAL ENERGY"" % (', '.join([str(i) for i in pair[0]]), ', '.join(; [str(i) for i in pair[1]])); intermediates_dict[var_key] = core.variable(""CURRENT ENERGY""); core.print_out(""\n N-Body: Complex Energy (fragments = %s, basis = %s: %20.14f)\n"" % (str(; pair[0]), str(pair[1]), energies_dict[pair])); # Flip this off for now, needs more testing; #if 'cp' in bsse_type_list and (len(bsse_type_list) == 1):; # core.set_global_option('DF_INTS_IO', 'LOAD'). core.clean(). return {; 'energies': energies_dict,; 'gradients': gradients_dict,; 'ptype': ptype_dict,; 'intermediates': intermediates_dict; }. def assemble_nbody_components(metadata, component_results):; """"""Assembles N-body components into interaction quantities according to requested BSSE procedure(s). Parameters; -----------; metadata : dict of str; Dictionary of N-body metadata. Required ``'key': value`` pairs:; ``'ptype'``: {'energy', 'gradient', 'hessian'}; Procedure which has generated the N-body components to be combined.; ``'bsse_type_list'``: list of str; List of requested BSSE treatments. Possible values include lowercase ``'cp'``, ``'nocp'``,; and ``'vmfc'``.; ``'max_nbody'``: int; Maximum number of bodies to include in the N-Body treatment.; Possible: `max_nbody` <= `max_frag`; Default: `max_nbody` = `max_frag`; ``'max_frag'``: int; Number of distinct fragments comprising full molecular supersystem.; ``'energies_dict'``: dict of set: float64; Dictionary containing all energy components required for given N-body procedure.; ``'ptype_dict'``: dict of set: float64 or dict of set: psi4.Matrix; Dictionary of returned quantities from calls of function `func` during N-body computations; ``'compute_dict'``: dict of str: dict; Dictionary containing {int: set} subdicts enumerating compute lists for each possible; BSSE treatment.; ``'kwargs'``: dict; Arbitrary keyword arguments.; component_results : dict of str: dict; Dictionary conta",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_nbody.html:17891,energy,energy,17891,psi4manual/1.3.2/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_nbody.html,5,['energy'],['energy']
Energy Efficiency,"le('BRUECKNER CONVERGED'))); if core.variable('BRUECKNER CONVERGED'):; break. if bcc_iter_cnt >= core.get_option('CCENERGY', 'BCCD_MAXITER'):; core.print_out(""\n\nWarning! BCCD did not converge within the maximum number of iterations.""); core.print_out(""You can increase the number of BCCD iterations by changing BCCD_MAXITER.\n\n""); break; bcc_iter_cnt += 1. if bcc_iter_cnt == 1:; for pv in hold_qcvars:; hold_qcvars[pv] = ref_wfn.variable(pv). ref_wfn.set_variable(""BCCD TOTAL ENERGY"", ref_wfn.variable(""CCSD TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD CORRELATION ENERGY"", ref_wfn.variable(""BCCD TOTAL ENERGY"") - ref_wfn.variable(""SCF TOTAL ENERGY"")); ref_wfn.set_variable(""CURRENT CORRELATION ENERGY"", ref_wfn.variable(""BCCD CORRELATION ENERGY"")). # copy back canonical MP2 and CCSD from initial iteration; for pv, v in hold_qcvars.items():; if v is not None:; ref_wfn.set_variable(pv, v); core.set_variable(pv, v). if name == 'bccd(t)':; core.cctriples(ref_wfn); ref_wfn.set_variable(""B(T) CORRECTION ENERGY"", ref_wfn.variable(""(T) CORRECTION ENERGY"")); ref_wfn.set_variable(""BCCD(T) TOTAL ENERGY"", ref_wfn.variable(""CCSD(T) TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD(T) CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) TOTAL ENERGY"") - ref_wfn.variable(""SCF TOTAL ENERGY"")) # note != CCSD(T) CORRELATION ENERGY; ref_wfn.set_variable(""CURRENT CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) CORRELATION ENERGY"")). for pv in [""(T) CORRECTION ENERGY"", ""CCSD(T) TOTAL ENERGY"", ""CCSD(T) CORRELATION ENERGY""]:; ref_wfn.del_variable(pv); core.del_variable(pv). for pv in [; ""BCCD TOTAL ENERGY"",; ""BCCD CORRELATION ENERGY"",; ""B(T) CORRECTION ENERGY"",; ""BCCD(T) TOTAL ENERGY"",; ""BCCD(T) CORRELATION ENERGY"",; ""CURRENT CORRELATION ENERGY"",; ]:; if ref_wfn.has_variable(pv):; core.set_variable(pv, ref_wfn.variable(pv)). # Notes; # * BCCD or BCCD(T) correlation energy is total energy of last Brueckner iteration minus HF energy of first Brueckner iteration. optstash.restore(); return ref_wfn. def run_tdsc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:97707,ENERGY,ENERGY,97707,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,4,['ENERGY'],['ENERGY']
Energy Efficiency,"le('CURRENT ENERGY', e_mp25). Once your python function is fairly stable on its own, it’s potential for interoperability with energy()/opt()/cp()/db()/cbs()/etc. should be evaluated. If it makes physical sense that it should work, you should strive to make that interoperability a reality. Some steps:. If any interoperability is possible, define an argument xx_func, where xx is a short name for your function. Add near the top of your function code like the below (less the final two lines). The net result of this code is that if the user specifies no *_func arguments, then energy() gets called. If the user defines xx_func, then its value gets called. If the user defines func, then its value gets reassigned to xx_func, func itself is deleted, and xx_func() gets called. Whatever is getting called is stored in func within the function.; # Establish function to call; if not('xx_func' in kwargs):; if ('func' in kwargs):; kwargs['xx_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['xx_func'] = energy; func = kwargs['xx_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper counterpoise_correct.' % (func.__name__)); if (func is db):; raise ValidationError('Wrapper xx is unhappy to be calling function \'%s\'.' % (func.__name__)). If specific interoperabilities are known, code them in. For example, if xx shouldn’t call db, add the last two lines above to the xx function. If db shouldn’t call xx, add the following two lines below to the db function.; if (func is xx):; raise ValidationError('Wrapper database is unhappy to be calling function \'%s\'.' % (func.__name__)). Create a multipart test case that runs some intercalls between your function and others (akin to pywrap_all). In trials, permute the order of calls a few times to expose any calls that don’t clean up after themselves and need further attention. When all is validated, add your findings to the great Permitted nesting of Psithon functions table in the documentat",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/bestpractices_py-1.html:5398,energy,energy,5398,psi4manual/1.0.0/bestpractices_py-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/bestpractices_py-1.html,10,['energy'],['energy']
Energy Efficiency,"le('SCF ITERATION ENERGY'); C = 0. if (HOMO > 0):; ref = PsiMod.reference_wavefunction(); eps = ref.epsilon_a(); potentials.append(eps[HOMO-1]); else:; ref = PsiMod.reference_wavefunction(); eps = ref.epsilon_b(); potentials.append(eps[-HOMO-1]). Ns.append(Nintegral + occ - 1.0); energies.append(E); convs.append(C). PsiMod.set_global_option(""FRAC_START"", 2); PsiMod.set_global_option(""FRAC_LOAD"", True); PsiMod.set_global_option(""FRAC_DIIS"", frac_diis); PsiMod.set_global_option(""GUESS"", ""READ""). # Set the next charge/mult; mol.set_molecular_charge(charge) ; mol.set_multiplicity(mult). # Determine HOMO; ref = PsiMod.reference_wavefunction(); eps_a = ref.epsilon_a(); eps_b = ref.epsilon_b(); if (Na == Nb):; HOMO = -Nb; elif (Nb == 0):; HOMO = Na; else:; E_a = eps_a[int(Na - 1)] ; E_b = eps_b[int(Nb - 1)] ; if (E_a >= E_b):; HOMO = Na; else: ; HOMO = -Nb. stats.append('\t%6d %6d %6d %6d %6d %6d\n' %(Nintegral-1, Na, Nb, charge, mult, HOMO)). if (HOMO > 0):; Na = Na - 1; else:; Nb = Nb - 1; charge = charge + 1; mult = Na - Nb + 1; ; PsiMod.set_global_option(""DF_INTS_IO"", ""NONE""). # => Print the results out <= #; E = {}; PsiMod.print_out('\n ==> Fractional Occupation Nuke Results <==\n\n'); PsiMod.print_out('\t%-11s %-24s %-24s %11s\n' %('N', 'Energy', 'HOMO Energy', 'Converged')); for k in range(len(Ns)):; PsiMod.print_out('\t%11.3E %24.16E %24.16E %11d\n' % (Ns[k], energies[k], potentials[k], convs[k])); E[Ns[k]] = energies[k]. PsiMod.print_out('\n'); PsiMod.print_out('\t%6s %6s %6s %6s %6s %6s\n' %('N', 'Na', 'Nb', 'Charge', 'Mult', 'HOMO')); for line in stats: ; PsiMod.print_out(line). PsiMod.print_out('\n\t""You shoot a nuke down a bug hole, you got a lot of dead bugs""\n'); PsiMod.print_out('\t\t\t-Starship Troopers\n'). # Drop the files out; fh = open(traverse_filename, 'w'); fh.write('\t%-11s %-24s %-24s %11s\n' %('N', 'Energy', 'HOMO Energy', 'Converged')); for k in range(len(Ns)):; fh.write('\t%11.3E %24.16E %24.16E %11d\n' % (Ns[k], energies[k], potentials[k], con",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/frac.html:9740,charge,charge,9740,psi4manual/4.0b2/_modules/frac.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/frac.html,8,['charge'],['charge']
Energy Efficiency,"le, except for those without a module in; OptionsState.; # include if necessary as globals; psi4.set_global_option('BASIS', guessbasis); psi4.set_global_option('DF_BASIS_SCF', guessbasisdf). # include if necessary as locals; psi4.set_local_option('TRANSQT2', 'WFN', 'MP2'); psi4.set_local_option('CCSORT', 'WFN', 'MP2'); psi4.set_local_option('MP2', 'WFN', 'MP2'). If the regular scf module is to be run, run it through; scf_helper() so that cast-up can be used. Also, add the; option to bypass it by pre-running scf, then running the module with this; bypass_scf kwarg. Also, if the full two-electron integrals are; necessary for the post-scf, compute them if only the df integrals were run; previously.; # include if scf module is to be run. # Bypass routine scf if user did something special to get it to converge; if not (('bypass_scf' in kwargs) and yes.match(str(kwargs['bypass_scf']))):; scf_helper(name, **kwargs). # include if TEI are needed beyond scf. # If the scf type is DF, then the AO integrals were never generated; if psi4.get_option('SCF', 'SCF_TYPE') == 'DF':; mints = psi4.MintsHelper(); mints.integrals(). Direct any post-scf modules to be run.; # include if further post-scf modules are needed; psi4.transqt2(); psi4.ccsort(); psi4.mp2(). If an OptionsState object was set up, those options; need to be returned to the original user state with the following.; # include if optstash = OptionsState( was set up previously; optstash.restore(). No function should return anything. CURRENT ENERGY will be set by; energy(), etc.; # never include; return returnvalue. Previous topic; LibOptions: globals, locals, has_changed and all that; Next topic; Python Driver; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta5] » ; Programming: Using the Core Libraries ». © Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/proc_py-1.html:3638,energy,energy,3638,psi4manual/4.0b5/proc_py-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/proc_py-1.html,2,['energy'],['energy']
Energy Efficiency,"le, returning an array of atom indices of fragments.; Relies upon van der Waals radii and so faulty for close; (esp. hydrogen-bonded) fragments. Original code from; Michael S. Marshall. Z(self: psi4.core.Molecule, arg0: int) → float; Nuclear charge of atom arg1 (0-indexed). activate_all_fragments(self: psi4.core.Molecule) → None; Sets all fragments in the molecule to be active. add_atom(self: psi4.core.Molecule, arg0: int, arg1: float, arg2: float, arg3: float, arg4: str, arg5: float, arg6: float, arg7: int) → None; Adds to Molecule arg0 an atom with atomic number arg1, Cartesian coordinates in Bohr (arg2, arg3, arg4), atomic symbol arg5, mass arg6, charge arg7 (optional), and lineno arg8 (optional). atom_at_position(self: psi4.core.Molecule, arg0: float, arg1: float) → int; Tests to see if an atom is at the position arg2 with a given tolerance arg3. center_of_mass(self: psi4.core.Molecule) → psi4.core.Vector3; Computes center of mass of molecule (does not translate molecule). charge(self: psi4.core.Molecule, arg0: int) → float; Gets charge of atom arg1 (0-indexed). clone(self: psi4.core.Molecule) → psi4.core.Molecule; Returns a new Molecule identical to arg0. create_molecule_from_string(arg0: str) → psi4.core.Molecule; Returns a new Molecule with member data from the geometry string arg0 in Psi4 format. create_psi4_string_from_molecule(self: psi4.core.Molecule) → str; Gets a string reexpressing in input format the current states of the molecule. deactivate_all_fragments(self: psi4.core.Molecule) → None; Sets all fragments in the molecule to be inactive. distance_matrix(self: psi4.core.Molecule) → psi4.core.Matrix; Returns Matrix of interatom distances. extract_subsets(*args, **kwargs); Overloaded function. extract_subsets(self: psi4.core.Molecule, arg0: list, arg1: list) -> psi4.core.Molecule. Returns copy of arg1 with arg2 fragments Real and arg3 fragments Ghost. extract_subsets(self: psi4.core.Molecule, arg0: list, arg1: int) -> psi4.core.Molecule. Returns copy of",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html:21444,charge,charge,21444,psi4manual/1.1.0/api/psi4.core.molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html,1,['charge'],['charge']
Energy Efficiency,"le- and quadruple-zeta 2-point; Helgaker-extrapolated MP2 correlation energy appended to a SCF/aug-cc-pVQZ; reference energy. Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy.; The cbs() function requires, at a minimum, name='scf' and scf_basis; keywords to be specified for reference-step only jobs and name and; corl_basis keywords for correlated jobs.; The following energy methods have been set up for cbs(). scf; df-scf; mp2. df-mp2; cc2; ccsd. bccd; cc3; ccsd(t). cisd; cisdt; cisdtq. cin; fci. Parameters:; name (string) – 'scf' || 'ccsd' || etc.; First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be 'scf'. Overruled if stage_wfn keywords supplied. corl_wfn (string) – 'mp2' || 'ccsd(t)' || etc.; Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with name or as the unlabeled; first argument to the function. delta_wfn (string) – 'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. delta_wfn_lesser (string) – 'mp2' || 'ccsd' || etc.; Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. delta2_wfn (string) – 'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. delta2_wfn_lesser (string) – 'mp2' || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. Basis Sets; Currently, the basis set set through set commands have no influence; on a cbs calculation. Parameters:; scf_basis (basis string) – corl_basis || 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/cbs-1.html:3085,energy,energy,3085,psi4manual/4.0b3/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/cbs-1.html,4,['energy'],['energy']
Energy Efficiency,"le-dftd3,; must also be available for these methods to; run. Unlike every other method in PSI4, if a basis set has not been; set, these will default to their intended basis sets: MINIX for HF-3c; and def2-mSVP for PBEh-3c. If a basis has previously been set, but you; want to use the default basis, use the slash syntax to “empty” the basis; option for the scope of the current calculation, energy(""hf3c/"").; A few practical examples:. HF-3c single point with default minix basis; energy('hf3c'). PBEh-3c optimization with default def2-mSVP basis; optimize('pbeh3c'). HF-3c with non-standard basis; set basis cc-pvdz; energy('hf3c'). PBEh-3c with default basis after basis set; set basis cc-pvdz; energy('pbeh3c/'). If only BSSE/basis set corrections (rather than total energies) are of; interest, the gcp program can be run independently of the scf; through the python function run_gcp(). (This function; is the same PSI4/gcp interface that is called during an scf job.); This route is much faster than running a HF or DFT energy.; molecule nene {; Ne; Ne 1 2.0; }. nene.update_geometry(). >>> E, G = nene.run_gcp('hf3c'). >>> E, G = nene.run_gcp(func='HF3c', verbose=True). qcdb.Molecule.run_gcp(self, func=None, dertype=None, verbose=1)¶; Compute geometrical BSSE correction via Grimme’s GCP program.; Function to call Grimme’s GCP program; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp; to compute an a posteriori geometrical BSSE correction to self for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, func. Returns energy if dertype is 0, gradient; if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The gcp executable must be independently compiled and; found in PATH or PSIPATH. self may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended by this method py-side and only public interface; fns used) or a string that can be instantiated into a qcdb.Molecule. P",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/gcp.html:3199,energy,energy,3199,psi4manual/1.7.x/gcp.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/gcp.html,2,['energy'],['energy']
Energy Efficiency,"le. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. For maximum; flexibility, ``return_wfn`` is always on in ``'reap'`` mode. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available) or finite difference; optimization is to be performed. :type hessian_with: string; :param hessian_with: ``'scf'`` || ``'mp2'`` || etc. Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. .. warning:: Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. .. note:: Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. .. _`table:grad_gen`:. +-------------------------+---------------------------------------------------------------------------------------------------------------+; | name | calls method |; +=========================+=============================================================================================================",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver.html:49825,energy,energy,49825,psi4manual/1.0.0/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver.html,2,['energy'],['energy']
Energy Efficiency,"le. :type ptype: string; :param ptype: ``'energy'`` || ``'gradient'`` || ``'hessian'``. Type of the procedure passed in. :type return_total_data: :ref:`boolean <op_py_boolean>`; :param return_total_data: ``'on'`` || |dl| ``'off'`` |dr|. If True returns the total data (energy/gradient/etc) of the system,; otherwise returns interaction data. :type levels: dict; :param levels: ``{1: 'ccsd(t)', 2: 'mp2', 'supersystem': 'scf'}`` || ``{1: 2, 2: 'ccsd(t)', 3: 'mp2'}`` || etc. Dictionary of different levels of theory for different levels of expansion; Note that method_string is not used in this case.; supersystem computes all higher order n-body effects up to nfragments. :type embedding_charges: dict; :param embedding_charges: ``{1: [-0.834, 0.417, 0.417], ..}``. Dictionary of atom-centered point charges. keys: 1-based index of fragment, values: list of charges for each fragment. :type charge_method: string; :param charge_method: ``scf/6-31g`` || ``b3lyp/6-31g*`` || etc. Method to compute point charges for monomers. Overridden by embedding_charges if both are provided. :type charge_type: string; :param charge_type: ``MULLIKEN_CHARGES`` || ``LOWDIN_CHARGES`` . Default is ``MULLIKEN_CHARGES``; """""". # Initialize dictionaries for easy data passing; metadata, component_results, nbody_results = {}, {}, {}. # Parse some kwargs; kwargs = p4util.kwargs_lower(kwargs); if kwargs.get('levels', False):; return driver_nbody_helper.multi_level(func, **kwargs); metadata['ptype'] = kwargs.pop('ptype', None); metadata['return_wfn'] = kwargs.pop('return_wfn', False); metadata['return_total_data'] = kwargs.pop('return_total_data', False); metadata['molecule'] = kwargs.pop('molecule', core.get_active_molecule()); metadata['molecule'].update_geometry(); metadata['molecule'].fix_com(True); metadata['molecule'].fix_orientation(True); metadata['embedding_charges'] = kwargs.get('embedding_charges', False); metadata['kwargs'] = kwargs; core.clean_variables(). if metadata['ptype'] not in ['energy', 'g",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_nbody.html:6097,charge,charges,6097,psi4manual/1.3.2/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_nbody.html,1,['charge'],['charges']
Energy Efficiency,"le. :type wfn: :py:class:`~psi4.core.Wavefunction`; :param wfn: set of molecule, gradient from which to generate file11. :examples:. >>> # [1] file11 for CISD calculation; >>> G, wfn = gradient('cisd', return_wfn=True); >>> fake_file11(wfn, 'mycalc.11'). """"""; molecule = wfn.molecule(); molecule.update_geometry(); gradient = wfn.gradient(). with open(filename, 'w') as handle:; handle.write('%d\n' % (molecule.natom())). for at in range(molecule.natom()):; handle.write('%6s %16.8f %16.8f %16.8f\n' % (molecule.symbol(; at), molecule.x(at), molecule.y(at), molecule.z(at))). for at in range(molecule.natom()):; handle.write('%6s %16.8f %16.8f %16.8f\n' % (; '', gradient.get(at, 0), gradient.get(at, 1), gradient.get(at, 2))). [docs]def sherrill_gold_standard(func, label, **kwargs):; r""""""Function to call the quantum chemical method known as 'Gold Standard'; in the Sherrill group. Uses :py:func:`~psi4.driver.cbs` to evaluate; the following expression. Two-point extrapolation of the correlation energy; performed according to :py:func:`~psi4.driver.driver_cbs.corl_xtpl_helgaker_2`. .. math:: E_{total}^{\text{Au\_std}} = E_{total,\; \text{SCF}}^{\text{aug-cc-pVQZ}} \; + E_{corl,\; \text{MP2}}^{\text{aug-cc-pV[TQ]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD(T)}}\big\vert_{\text{aug-cc-pVTZ}}. >>> # [1] single-point energy by this composite method; >>> energy('sherrill_gold_standard'). >>> # [2] finite-difference geometry optimization; >>> optimize('sherrill_gold_standard'). >>> # [3] finite-difference geometry optimization, overwriting some pre-defined sherrill_gold_standard options; >>> optimize('sherrill_gold_standard', corl_basis='cc-pV[DT]Z', delta_basis='3-21g'). """"""; kwargs['scf_basis'] = kwargs.get('scf_basis', 'aug-cc-pVQZ'); kwargs['scf_scheme'] = kwargs.get('scf_scheme', driver_cbs.xtpl_highest_1). kwargs['corl_wfn'] = kwargs.get('corl_wfn', 'mp2'); kwargs['corl_basis'] = kwargs.get('corl_basis', 'aug-cc-pV[TQ]Z'); kwargs['corl_scheme'] = kwargs.get('corl_scheme', driver_cbs",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/aliases.html:2918,energy,energy,2918,psi4manual/1.4.0/_modules/psi4/driver/aliases.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/aliases.html,4,['energy'],['energy']
Energy Efficiency,"le.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies or gradients frequency, indicates; whether the calculations required to complete the frequency are to be run; in one file ('continuous') or are to be farmed out in an; embarrassingly parallel fashion ('sow'/'reap')/ For the latter,; run an initial job with 'sow' and follow instructions in its output file.; For maximum flexibility, return_wfn is always on in 'reap' mode. dertype (dertype) – 'hessian' || 'gradient' || 'energy'; Indicates whether analytic (if available- they’re not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or string) – -1 || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; , requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are not available. Frequencies will proceed through; finite differences according to availability of gradients or energies. Examples:. >>> # [1] Frequency calculation for all modes through highest available derivatives; >>> frequency('ccsd'). >>> # [2] Frequency calculation for b2 modes through finite difference of gradients; >>> # printing lowest mode frequency to screen and Hessian to output; >>> E, wfn = frequencies('scf', dertype=1, irrep=4, return_wfn=True); >>> print wfn.frequencies().get(0, 0); >>> wfn.hessian().print_out(). >>> # [3] Frequency calculation at default conditions and He",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/freq-1.html:2327,energy,energy,2327,psi4manual/1.0.0/freq-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/freq-1.html,2,['energy'],['energy']
Energy Efficiency,"le.mass(0); m2 = molecule.mass(1). # Find rval of the minimum of energies, check number of points left and right; min_index = np.argmin(energies); if min_index < 3 :; core.print_out(""\nWarning: fewer than 3 points provided with a r < r(min(E))!\n""); if min_index >= len(energies) - 3:; core.print_out(""\nWarning: fewer than 3 points provided with a r > r(min(E))!\n""). # Optimize the geometry, refitting the surface around each new geometry; core.print_out(""\nOptimizing geometry based on current surface:\n\n""); re = rvals[min_index]; maxit = 30; thres = 1.0e-9; for i in range(maxit):; derivs = least_squares_fit_polynomial(rvals,energies,localization_point=re); e,g,H = derivs[0:3]; core.print_out("" E = %20.14f, x = %14.7f, grad = %20.14f\n"" % (e, re, g)); if abs(g) < thres:; break; re -= g/H;; if i == maxit-1:; raise ConvergenceError(""diatomic geometry optimization"", maxit); core.print_out("" Final E = %20.14f, x = %14.7f, grad = %20.14f\n"" % (e, re, g)); if re < min(rvals):; raise Exception(""Minimum energy point is outside range of points provided. Use a lower range of r values.""); if re > max(rvals):; raise Exception(""Minimum energy point is outside range of points provided. Use a higher range of r values.""). # Convert to convenient units, and compute spectroscopic constants; d0,d1,d2,d3,d4 = derivs*constants.hartree2aJ; core.print_out(""\nEquilibrium Energy %20.14f Hartrees\n"" % e); core.print_out(""Gradient %20.14f\n"" % g); core.print_out(""Quadratic Force Constant %14.7f MDYNE/A\n"" % d2); core.print_out(""Cubic Force Constant %14.7f MDYNE/A**2\n"" % d3); core.print_out(""Quartic Force Constant %14.7f MDYNE/A**3\n"" % d4). hbar = constants.h / (2.0 * np.pi); mu = ((m1*m2)/(m1+m2))*constants.amu2kg; we = 5.3088375e-11 * np.sqrt(d2/mu); wexe = (1.2415491e-6)*(we/d2)**2 * ((5.0*d3*d3)/(3.0*d2)-d4). # Rotational constant: Be; I = ((m1*m2)/(m1+m2)) * constants.amu2kg * (re * angstrom_to_meter)**2; B = constants.h / (8.0 * np.pi**2 * constants.c * I). # alpha_e and quartic centrifu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/diatomic.html:5494,energy,energy,5494,psi4manual/1.4.0/_modules/psi4/driver/diatomic.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/diatomic.html,4,['energy'],['energy']
Energy Efficiency,"le; Default: 1.27. CEPA_SOS_SCALE (OCC); OCC — CEPA Spin-opposite scaling (SOS) value. Type: double; Default: 1.3. CEPA_SS_SCALE (OCC); OCC — CEPA same-spin scaling value from SCS-CCSD. Type: double; Default: 1.13. CEPA_TYPE (OCC); OCC — CEPA type such as CEPA0, CEPA1 etc. currently we have only CEPA0. Type: string; Possible Values: CEPA0; Default: CEPA0. CFOUR_ABCDTYPE (CFOUR); CFOUR — Specifies the way the \(\langle ab||cd \rangle\) molecular orbital integrals are handled in post-MP2 calculations. STANDARD (= 0) uses directly the corresponding MO integrals and thus results in an algorithm which in particular for large-scale calculations results in excessive use of disk space (storage of all \(\langle ab||cd\rangle\) integrals. AOBASIS (=2) uses an AO-based algorithm to evaluate all terms involving the \(\langle ab||cd\rangle\) integrals and significantly reduces the amount of disk storage. The use of ABCDTYPE=AOBASIS is strongly recommended for all CC calculations up to CCSD(T) and has been implemented for energy, gradient, second-derivative, and excitation energy calculations. Type: string; Possible Values: STANDARD, AOBASIS; Default: STANDARD. CFOUR_ACTIVE_ORBI (CFOUR); CFOUR — Specifies the active orbitals used in a TCSCF calculation and has to be used in combination with the keyword CFOUR_CORE_ORBITALS. The active orbitals are specified by either NIRREP or 2*NIRREP integers specifying the number of active orbitals of each symmetry type, where NIRREP is the number of irreducible representations in the computational point group. If there are no orbitals of a particular symmetry type a zero must be entered. For more information and an example see CFOUR_OCCUPATION . Type: array; Default: No Default. CFOUR_ANH_ALGORITHM (CFOUR); CFOUR — Specifies which algorithm is used for CFOUR_ANHARMONIC =VIBROT, VPT2, and FULLQUARTIC calculations. If STANDARD (=0) is chosen, then simply invoking xcfour will cause a complete job to be run with all second-derivative calculations ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html:17587,energy,energy,17587,psi4manual/1.2.1/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html,12,['energy'],['energy']
Energy Efficiency,"le; Default: 1.27. CEPA_SOS_SCALE (OCC)¶OCC — Removed in 1.4. Will raise an error in 1.5. Type: double; Default: 1.3. CEPA_SS_SCALE (OCC)¶OCC — Removed in 1.4. Will raise an error in 1.5. Type: double; Default: 1.13. CEPA_TYPE (OCC)¶OCC — CEPA type such as CEPA0, CEPA1 etc. currently we have only CEPA0. Type: string; Possible Values: CEPA0; Default: CEPA0. CFOUR_ABCDTYPE (CFOUR)¶CFOUR — Specifies the way the \(\langle ab||cd \rangle\) molecular orbital integrals are handled in post-MP2 calculations. STANDARD (= 0) uses directly the corresponding MO integrals and thus results in an algorithm which in particular for large-scale calculations results in excessive use of disk space (storage of all \(\langle ab||cd\rangle\) integrals. AOBASIS (=2) uses an AO-based algorithm to evaluate all terms involving the \(\langle ab||cd\rangle\) integrals and significantly reduces the amount of disk storage. The use of ABCDTYPE=AOBASIS is strongly recommended for all CC calculations up to CCSD(T) and has been implemented for energy, gradient, second-derivative, and excitation energy calculations. Type: string; Possible Values: STANDARD, AOBASIS; Default: STANDARD. CFOUR_ACTIVE_ORBI (CFOUR)¶CFOUR — Specifies the active orbitals used in a TCSCF calculation and has to be used in combination with the keyword CFOUR_CORE_ORBITALS. The active orbitals are specified by either NIRREP or 2*NIRREP integers specifying the number of active orbitals of each symmetry type, where NIRREP is the number of irreducible representations in the computational point group. If there are no orbitals of a particular symmetry type a zero must be entered. For more information and an example see CFOUR_OCCUPATION . Type: array; Default: No Default. CFOUR_ANH_ALGORITHM (CFOUR)¶CFOUR — Specifies which algorithm is used for CFOUR_ANHARMONIC =VIBROT, VPT2, and FULLQUARTIC calculations. If STANDARD (=0) is chosen, then simply invoking xcfour will cause a complete job to be run with all second-derivative calculations be",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html:18767,energy,energy,18767,psi4manual/1.4.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html,18,['energy'],['energy']
Energy Efficiency,"le; Default: 1e-3. MAX_NUM_VECS (DETCI); DETCI — Maximum number of Davidson subspace vectors which can be held on disk for the CI coefficient and sigma vectors. (There is one H(diag) vector and the number of D vectors is equal to the number of roots). When the number of vectors on disk reaches the value of MAX_NUM_VECS, the Davidson subspace will be collapsed to COLLAPSE_SIZE vectors for each root. This is very helpful for saving disk space. Defaults to CI_MAXITER * NUM_ROOTS + NUM_INIT_VECS. Type: integer; Default: 0. MAXITER (CCENERGY); CCENERGY — Maximum number of iterations to solve the CC equations. Type: integer; Default: 50. MAXITER (CCEOM); CCEOM — Maximum number of iterations. Type: integer; Default: 80. MAXITER (CCLAMBDA); CCLAMBDA — Maximum number of iterations. Type: integer; Default: 50. MAXITER (CCRESPONSE); CCRESPONSE — Maximum number of iterations to converge perturbed amplitude equations. Type: integer; Default: 50. MAXITER (DCFT); DCFT — Maximum number of macro- or micro-iterations for both energy and response equations. Type: integer; Default: 40. MAXITER (FISAPT); FISAPT — Maximum number of iterations for CPHF. Type: integer; Default: 50. MAXITER (FNOCC); FNOCC — Maximum number of CC iterations. Type: integer; Default: 100. MAXITER (MCSCF); MCSCF — Maximum number of iterations. Type: integer; Default: 100. MAXITER (PSIMRCC); PSIMRCC — Maximum number of iterations to determine the amplitudes. Type: integer; Default: 100. MAXITER (SAPT); SAPT — Maximum number of CPHF iterations. Type: integer; Default: 50. MAXITER (SCF); SCF — Maximum number of iterations. Cfour Interface: Keyword translates into CFOUR_SCF_MAXCYC. Type: integer; Default: 100. MCSCF_ALGORITHM (DETCI); DETCI — Convergence algorithm to utilize. Two-Step, Augmented Hessian, or One-Step. Defaults to TS for RASSCF. Type: string; Possible Values: TS, AH; Default: TS. MCSCF_CI_CLEANUP (DETCI); DETCI — Cleanup the CI info at the end of a run?. Type: boolean; Default: true. MCSCF_DIIS_ERROR_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodoc_glossary_options_c-1.html:158131,energy,energy,158131,psi4manual/1.3.2/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodoc_glossary_options_c-1.html,2,['energy'],['energy']
Energy Efficiency,"le; Default: 1e-3. MAX_NUM_VECS (DETCI); DETCI — Maximum number of Davidson subspace vectors which can be held on disk for the CI coefficient and sigma vectors. (There is one H(diag) vector and the number of D vectors is equal to the number of roots). When the number of vectors on disk reaches the value of MAX_NUM_VECS, the Davidson subspace will be collapsed to COLLAPSE_SIZE vectors for each root. This is very helpful for saving disk space. Defaults to CI_MAXITER * NUM_ROOTS + NUM_INIT_VECS. Type: integer; Default: 0. MAXITER (CCENERGY); CCENERGY — Maximum number of iterations to solve the CC equations. Type: integer; Default: 50. MAXITER (CCEOM); CCEOM — Maximum number of iterations. Type: integer; Default: 80. MAXITER (CCLAMBDA); CCLAMBDA — Maximum number of iterations. Type: integer; Default: 50. MAXITER (CCRESPONSE); CCRESPONSE — Maximum number of iterations to converge perturbed amplitude equations. Type: integer; Default: 50. MAXITER (DCFT); DCFT — Maximum number of macro- or micro-iterations for both energy and response equations. Type: integer; Default: 40. MAXITER (FISAPT); FISAPT — Maximum number of iterations for CPHF. Type: integer; Default: 50. MAXITER (FNOCC); FNOCC — Maximum number of CC iterations. Type: integer; Default: 100. MAXITER (MCSCF); MCSCF — Maximum number of iterations. Type: integer; Default: 100. MAXITER (PSIMRCC); PSIMRCC — Maximum number of iterations to determine the amplitudes. Type: integer; Default: 100. MAXITER (SAPT); SAPT — Maximum number of CPHF iterations. Type: integer; Default: 50. MAXITER (SCF); SCF — Maximum number of iterations. Cfour Interface: Keyword translates into CFOUR_SCF_MAXCYC. Type: integer; Default: 100. MCSCF_ALGORITHM (DETCI); DETCI — Convergence algorithm to utilize. Two-Step, Augmented Hessian, or One-Step. Defaults to TS for RASSCF. Type: string; Possible Values: TS, AH; Default: TS. MCSCF_DIIS_ERROR_TYPE (DETCI); DETCI — DIIS error vector type either, the AO orbital gradient or the orbital rotation updat",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html:159028,energy,energy,159028,psi4manual/1.2.1/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html,4,['energy'],['energy']
Energy Efficiency,"le; Default: 1e-3. MAX_NUM_VECS (DETCI); DETCI — Maximum number of Davidson subspace vectors which can be held on disk for the CI coefficient and sigma vectors. (There is one H(diag) vector and the number of D vectors is equal to the number of roots). When the number of vectors on disk reaches the value of MAX_NUM_VECS, the Davidson subspace will be collapsed to COLLAPSE_SIZE vectors for each root. This is very helpful for saving disk space. Defaults to CI_MAXITER * NUM_ROOTS + NUM_INIT_VECS. Type: integer; Default: 0. MAXITER (CCENERGY); CCENERGY — Maximum number of iterations to solve the CC equations. Type: integer; Default: 50. MAXITER (CCEOM); CCEOM — Maximum number of iterations. Type: integer; Default: 80. MAXITER (CCLAMBDA); CCLAMBDA — Maximum number of iterations. Type: integer; Default: 50. MAXITER (CCRESPONSE); CCRESPONSE — Maximum number of iterations to converge perturbed amplitude equations. Type: integer; Default: 50. MAXITER (DCFT); DCFT — Maximum number of macro- or micro-iterations for both energy and response equations. Type: integer; Default: 40. MAXITER (FISAPT); FISAPT — Maximum number of iterations for CPHF. Type: integer; Default: 50. MAXITER (FNOCC); FNOCC — Maximum number of CC iterations. Type: integer; Default: 100. MAXITER (MCSCF); MCSCF — Maximum number of iterations. Type: integer; Default: 100. MAXITER (PSIMRCC); PSIMRCC — Maximum number of iterations to determine the amplitudes. Type: integer; Default: 100. MAXITER (SAPT); SAPT — Maxmum number of CPHF iterations. Type: integer; Default: 50. MAXITER (SCF); SCF — Maximum number of iterations. Cfour Interface: Keyword translates into CFOUR_SCF_MAXCYC. Type: integer; Default: 100. MCSCF_ALGORITHM (DETCI); DETCI (Expert) — Convergence algorithm to utilize. This is a flag for the future. Type: string; Possible Values: ONE_STEP, TWO_STEP; Default: TWO_STEP. MCSCF_DIIS_FREQ (DETCI); DETCI — How often to do a DIIS extrapolation. Type: integer; Default: 1. MCSCF_DIIS_MAX_VECS (DETCI); DETCI — ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html:157403,energy,energy,157403,psi4manual/1.0.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html,2,['energy'],['energy']
Energy Efficiency,"le\)). dfomp3-1; DF-OMP3 cc-pVDZ energy for the H2O molecule. ddd-function-kwargs; check distributed driver is correctly passing function kwargs. dct2; DC-06 calculation for the He dimer. This performs a two-step update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the MO Basis. cc13b; Tests RHF CCSD(T)gradients. cc17; Single point energies of multiple excited states with EOM-CCSD. ghosts; Density fitted MP2 cc-PVDZ/cc-pVDZ-RI computation of formic acid dimer binding energy using explicit specification of ghost atoms. This is equivalent to the dfmp2_1 sample but uses both (equivalent) specifications of ghost atoms in a manual counterpoise correction. dft-grad-lr3; wB97X-D test for a large UKS molecule update ref gradient due to new BraggSlater radii. decontract; RHF/cc-pvdz-decontract HCl single-point energy Testing the in line -decontract option for basis sets. cepa2; cc-pvdz H2O Test ACPF Energy/Properties. dct9; UHF-ODC-12 and RHF-ODC-12 single-point energy for H2O. This performs a simultaneous update of orbitals and cumulants, using DIIS extrapolation. Four-virtual integrals are handled in the AO basis, where integral transformation is avoided. In the next RHF-ODC-12 computation, AO_BASIS=NONE is used, where four-virtual integrals are transformed into MO basis. dft-freq; Frequencies for H2O B3LYP/6-31G* at optimized geometry. fsapt-terms; F-SAPT0/jun-cc-pvdz procedure for methane dimer. cc46; EOM-CC2/cc-pVDZ on H2O2 with two excited states in each irrep. scf-ecp3; Water-Argon complex with ECP present; check of UHF Hessian. mcscf1; ROHF 6-31G** energy of the \(^{3}B_1\) state of CH2, with Z-matrix input. The occupations are specified explicitly. fci-tdm-2; BH-H2+ FCI/cc-pVDZ Transition Dipole Moment. dfomp2p5-2; DF-OMP2.5 cc-pVDZ energy for the H2O+ cation. pywrap-all; Intercalls among python wrappers- database, cbs, optimize, energy, etc. Though each call below functions individually, running them all in sequence or",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html:10890,energy,energy,10890,psi4manual/master/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"le_namespace(97, 'dimer', 'monomerA'). core.IO.set_default_namespace('monomerA'); core.print_out('\n'); p4util.banner('Monomer A HF'); core.print_out('\n'). core.timer_on(""SAPT: Monomer A SCF""); monomerA_wfn = scf_helper('RHF', molecule=monomerA, **kwargs); core.timer_off(""SAPT: Monomer A SCF""). if do_delta_mp2:; select_mp2(""mp2"", ref_wfn=monomerA_wfn, **kwargs); mp2_corl_interaction_e -= core.variable('MP2 CORRELATION ENERGY'). # Compute Monomer B wavefunction; if share_df_ints:; core.IO.change_file_namespace(97, 'monomerA', 'monomerB'); core.IO.set_default_namespace('monomerB'); core.print_out('\n'); p4util.banner('Monomer B HF'); core.print_out('\n'). core.timer_on(""SAPT: Monomer B SCF""); monomerB_wfn = scf_helper('RHF', molecule=monomerB, **kwargs); core.timer_off(""SAPT: Monomer B SCF""). # Delta MP2; if do_delta_mp2:; select_mp2(""mp2"", ref_wfn=monomerB_wfn, **kwargs); mp2_corl_interaction_e -= core.variable('MP2 CORRELATION ENERGY'); core.set_variable(""SAPT MP2 CORRELATION ENERGY"", mp2_corl_interaction_e) # P::e SAPT; core.set_global_option('DF_INTS_IO', df_ints_io). if core.get_option('SCF', 'REFERENCE') == 'RHF':; core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERA, 'monomerA', 'dimer'); core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERB, 'monomerB', 'dimer'). core.IO.set_default_namespace('dimer'); # core.set_local_option('SAPT', 'CPHF_R_CONVERGENCE', 10e-10); if name in ['sapt0', 'ssapt0']:; core.set_local_option('SAPT', 'SAPT_LEVEL', 'SAPT0'); elif name == 'sapt2':; core.set_local_option('SAPT', 'SAPT_LEVEL', 'SAPT2'); elif name in ['sapt2+', 'sapt2+dmp2']:; core.set_local_option('SAPT', 'SAPT_LEVEL', 'SAPT2+'); core.set_local_option('SAPT', 'DO_CCD_DISP', False); elif name in ['sapt2+(3)', 'sapt2+(3)dmp2']:; core.set_local_option('SAPT', 'SAPT_LEVEL', 'SAPT2+3'); core.set_local_option('SAPT', 'DO_THIRD_ORDER', False); core.set_local_option('SAPT', 'DO_CCD_DISP', False); elif name in ['sapt2+3', 'sapt2+3dmp2']:; core.set_local_option('SAPT', 'SAPT_LEVE",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/_modules/psi4/driver/procrouting/proc.html:149904,ENERGY,ENERGY,149904,psi4manual/master/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/procrouting/proc.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"le_namespace(97, 'dimer', 'monomerA'). core.IO.set_default_namespace('monomerA'); core.print_out('\n'); p4util.banner('Monomer A HF'); core.print_out('\n'). core.timer_on(""SAPT: Monomer A SCF""); monomerA_wfn = scf_helper('RHF', molecule=monomerA, **kwargs); core.timer_off(""SAPT: Monomer A SCF""). if do_delta_mp2:; select_mp2(""mp2"", ref_wfn=monomerA_wfn, **kwargs); mp2_corl_interaction_e -= core.variable('MP2 CORRELATION ENERGY'). # Compute Monomer B wavefunction; if share_df_ints:; core.IO.change_file_namespace(97, 'monomerA', 'monomerB'); core.IO.set_default_namespace('monomerB'); core.print_out('\n'); p4util.banner('Monomer B HF'); core.print_out('\n'). core.timer_on(""SAPT: Monomer B SCF""); monomerB_wfn = scf_helper('RHF', molecule=monomerB, **kwargs); core.timer_off(""SAPT: Monomer B SCF""). # Delta MP2; if do_delta_mp2:; select_mp2(""mp2"", ref_wfn=monomerB_wfn, **kwargs); mp2_corl_interaction_e -= core.variable('MP2 CORRELATION ENERGY'); core.set_variable(""SAPT MP2 CORRELATION ENERGY"", mp2_corl_interaction_e) # P::e SAPT; core.set_global_option('DF_INTS_IO', df_ints_io). if core.get_option('SCF', 'REFERENCE') == 'RHF':; core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERA, 'monomerA', 'dimer'); core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERB, 'monomerB', 'dimer'). core.IO.set_default_namespace('dimer'); core.set_local_option('SAPT', 'E_CONVERGENCE', 10e-10); core.set_local_option('SAPT', 'D_CONVERGENCE', 10e-10); if name in ['sapt0', 'ssapt0']:; core.set_local_option('SAPT', 'SAPT_LEVEL', 'SAPT0'); elif name == 'sapt2':; core.set_local_option('SAPT', 'SAPT_LEVEL', 'SAPT2'); elif name in ['sapt2+', 'sapt2+dmp2']:; core.set_local_option('SAPT', 'SAPT_LEVEL', 'SAPT2+'); core.set_local_option('SAPT', 'DO_CCD_DISP', False); elif name in ['sapt2+(3)', 'sapt2+(3)dmp2']:; core.set_local_option('SAPT', 'SAPT_LEVEL', 'SAPT2+3'); core.set_local_option('SAPT', 'DO_THIRD_ORDER', False); core.set_local_option('SAPT', 'DO_CCD_DISP', False); elif name in ['sapt2+3', 'sapt2+3",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/procrouting/proc.html:149897,ENERGY,ENERGY,149897,psi4manual/1.9.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/procrouting/proc.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"leading MP2 psivars computed with DFT, not HF, reference; for var in dfmp2_wfn.variables():; if var.startswith('MP2 ') and ssuper.name() not in ['MP2D']:; scf_wfn.del_variable(var). scf_wfn.set_variable(""DOUBLE-HYBRID CORRECTION ENERGY"", vdh) # P::e SCF; scf_wfn.set_variable(""{} DOUBLE-HYBRID CORRECTION ENERGY"".format(ssuper.name()), vdh); returnvalue += vdh; scf_wfn.set_variable(""DFT TOTAL ENERGY"", returnvalue) # P::e SCF; for pv, pvv in scf_wfn.variables().items():; if pv.endswith('DISPERSION CORRECTION ENERGY') and pv.startswith(ssuper.name()):; fctl_plus_disp_name = pv.split()[0]; scf_wfn.set_variable(fctl_plus_disp_name + ' TOTAL ENERGY', returnvalue); break; else:; scf_wfn.set_variable('{} TOTAL ENERGY'.format(ssuper.name()), returnvalue). scf_wfn.set_variable('CURRENT ENERGY', returnvalue); scf_wfn.set_energy(returnvalue); core.print_out('\n\n'); core.print_out(' %s Energy Summary\n' % (name.upper())); core.print_out(' ' + '-' * (15 + len(name)) + '\n'); core.print_out(' DFT Reference Energy = %22.16lf\n' % (returnvalue - vdh)); core.print_out(' Scaled MP2 Correlation = %22.16lf\n' % (vdh)); core.print_out(' @Final double-hybrid DFT total energy = %22.16lf\n\n' % (returnvalue)); core.tstop(). if ssuper.name() == 'MP2D':; for pv, pvv in dfmp2_wfn.variables().items():; scf_wfn.set_variable(pv, pvv). # Conversely, remove DFT qcvars from MP2D; for var in scf_wfn.variables():; if 'DFT ' in var or 'DOUBLE-HYBRID ' in var:; scf_wfn.del_variable(var). # DFT groups dispersion with SCF. Reshuffle so dispersion with MP2 for MP2D.; for pv in ['SCF TOTAL ENERGY', 'SCF ITERATION ENERGY', 'MP2 TOTAL ENERGY']:; scf_wfn.set_variable(pv, scf_wfn.variable(pv) - scf_wfn.variable('DISPERSION CORRECTION ENERGY')). scf_wfn.set_variable('MP2D CORRELATION ENERGY', scf_wfn.variable('MP2 CORRELATION ENERGY') + scf_wfn.variable('DISPERSION CORRECTION ENERGY')); scf_wfn.set_variable('MP2D TOTAL ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY') + scf_wfn.variable('HF TOTAL ENERGY')); sc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:77633,Energy,Energy,77633,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,7,['Energy'],['Energy']
Energy Efficiency,"lean; Default: false. DO_MBPT_DISP (SAPT)¶SAPT (Expert) — Do MBPT dispersion correction in SAPT2+, SAPT2+(3) or SAPT2+3, if also doing CCD?. Type: boolean; Default: true. DO_SCS (DFOCC)¶DFOCC — Do perform spin-component-scaled OMP2 (SCS-OMP2)? In all computation, SCS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SCS-OMP2, one needs to set ‘DO_SCS’ to true. Type: boolean; Default: false. DO_SCS (OCC)¶OCC — Removed in 1.4. Will raise an error in 1.5. Pass the method name, like scs-mp2, to energy instead. Type: boolean; Default: false. DO_SOS (DFOCC)¶DFOCC — Do perform spin-opposite-scaled OMP2 (SOS-OMP2)? In all computation, SOS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SOS-OMP2, one needs to set ‘DO_SOS’ to true. Type: boolean; Default: false. DO_SOS (OCC)¶OCC — Removed in 1.4. Will raise an error in 1.5. Pass the method name, like scs-mp2, to energy instead. Type: boolean; Default: false. DO_THIRD_ORDER (SAPT)¶SAPT (Expert) — Do compute third-order corrections?. Type: boolean; Default: false. DOCC (GLOBALS)¶GLOBALS — An array containing the number of doubly-occupied orbitals per irrep (in Cotton order). Type: array; Default: No Default. DOCC (MCSCF)¶MCSCF — The number of doubly occupied orbitals, per irrep. Type: array; Default: No Default. DYNAMIC_LEVEL (OPTKING)¶OPTKING — Starting level for dynamic optimization (0=nondynamic, higher=>more conservative). Type: integer; Default: 0. E3_SCALE (DFOCC)¶DFOCC — CEPA opposite-spin scaling value from SCS-CCSD. Type: double; Default: 0.25. E3_SCALE (OCC)¶OCC — Scaling value for 3rd order energy correction (S. Grimme, Vol. 24, pp. 1529, J. Comput. Chem.). Type: double; Default: 0.25. E_CONVERGENCE (CCENERGY)¶CCENERGY — Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Defa",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodoc_glossary_options_c.html:117582,energy,energy,117582,psi4manual/1.6.x/autodoc_glossary_options_c.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodoc_glossary_options_c.html,1,['energy'],['energy']
Energy Efficiency,"lean; Default: false. S (DETCI); DETCI — The value of the spin quantum number is given by this option. The default is determined by the value of the multiplicity. This is used for two things: (1) determining the phase of the redundant half of the CI vector when the component is used (i.e., MS0 = TRUE), and (2) making sure the guess vector has the desired value of (if CALC_S_SQUARED is TRUE and ICORE = 1). Type: double; Default: 0.0. S_ORTHOGONALIZATION (SCF); SCF — SO orthogonalization: symmetric or canonical?. Type: string; Possible Values: SYMMETRIC, CANONICAL; Default: SYMMETRIC. S_TOLERANCE (SCF); SCF — Minimum S matrix eigenvalue to be used before compensating for linear dependencies. Type: conv double; Default: 1e-7. SAD_CHOL_TOLERANCE (SCF); SCF (Expert) — Auxiliary basis for the SAD guess. Type: conv double; Default: 1e-7. SAD_D_CONVERGENCE (SCF); SCF — Convergence criterion for SCF density in SAD Guess. Type: conv double; Default: 1e-5. SAD_E_CONVERGENCE (SCF); SCF — Convergence criterion for SCF energy in SAD Guess. Type: conv double; Default: 1e-5. SAD_FRAC_OCC (SCF); SCF (Expert) — Auxiliary basis for the SAD guess. Type: boolean; Default: false. SAD_MAXITER (SCF); SCF (Expert) — Maximum number of SAD guess iterations. Type: integer; Default: 50. SAD_PRINT (SCF); SCF (Expert) — The amount of SAD information to print to the output. Type: integer; Default: 0. SAD_SCF_TYPE (SCF); SCF (Expert) — SCF type of SAD guess. Type: string; Possible Values: DIRECT, DF; Default: DF. SAPT (SCF); SCF (Expert) — Are going to do SAPT? If so, what part?. Type: string; Possible Values: FALSE, 2-DIMER, 2-MONOMER_A, 2-MONOMER_B, 3-TRIMER, 3-DIMER_AB, 3-DIMER_BC, 3-DIMER_AC, 3-MONOMER_A, 3-MONOMER_B, 3-MONOMER_C; Default: FALSE. SAPT0_E10 (SAPT); SAPT (Expert) — For SAPT0 only, compute only first-order electrostatics and exchange. The integrals are computed before any terms, so all integrals will be computed even if they are not needed for the requested term. Type: boolean; De",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html:200995,energy,energy,200995,psi4manual/1.0.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html,2,['energy'],['energy']
Energy Efficiency,"lect conventional quantities; energy('mp3', **kwargs); e_scf = psi4.get_variable('SCF TOTAL ENERGY'); ce_mp2 = psi4.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = psi4.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; psi4.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; psi4.set_variable('MP2.5 TOTAL ENERGY', e_mp25) # to PSI variable repository; psi4.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); psi4.set_variable('CURRENT ENERGY', e_mp25) # geometry optimizer tracks this variable, permits; # MP2.5 finite difference optimizations; # build string of title banner and print results; banners = ''; banners += """"""psi4.print_out('\\n')\n""""""; banners += """"""banner(' MP2.5 ')\n""""""; banners += """"""psi4.print_out('\\n')\n\n""""""; exec banners. tables = ''; tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); psi4.print_out(tables) # prints nice header and table of all involved quantities to output file. return e_mp25. One final step is necessary. At the end of the aliases.py file, add; the following line.; 1procedures['energy']['mp2.5'] = run_mp2_5. This permits the newly defined MP2.5 method to be called in the input file; with the following command.; 1energy('mp2.5'). Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Customization: Adding Simple Extensions. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/quickaddalias-1.html:3032,energy,energy,3032,psi4manual/1.1.0/quickaddalias-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/quickaddalias-1.html,16,['energy'],['energy']
Energy Efficiency,"lecting the algorithm for a CCSD gradient call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('CC_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ/ccenergy. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy_gradient; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy_gradient. if func is None:; raise ManagedMethodError(['select_ccsd_gradient', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_fnoccsd_t_(name, **kwargs):; """"""Function selecting the algorithm for a FNO-CCSD(T) energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('CC_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only fnocc. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in ['', 'FNOCC']:; func = run_fnocc; elif mtd_type == 'DF':; if module in ['', 'FNOCC']:; func = run_fnodfcc; elif mtd_type == 'CD':; if module in ['', 'FNOCC']:; func = run_fnodfcc. if func is None:; raise ManagedMethodError(['select_fnoccsd_t_', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_ccsd_t_(name, **kwargs):; """"""Function selecting the algorithm for a CCSD(T) energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('CC_TYPE'); module = psi4.get_global_o",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:21144,energy,energy,21144,psi4manual/1.0.0/_modules/procedures/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html,1,['energy'],['energy']
Energy Efficiency,"lectron affinity (IP/EA) [Nooijen:1995:3629]; approaches.; The Psi4FockCI plugin allows one to perform spin-flip (SF), ionization; potential (IP), and electron affinity (EA) calculations, as well as; combined RAS-SF-IP/EA calculations, through the DETCI (CI: Configuration Interaction) module. Installation¶. Download the plugin from the GitHub repository:; >>> git clone https://github.com/shannonhouck/psi4fockci.git. Once downloaded, the plugin can be installed as follows:; >>> cd {top-level-psi4fockci-directory}; >>> python -m pip install . Sample Input¶; To run a CAS-nSF-IP/EA calculation, start with a molecule with the; correct charge and multiplicity for the reference state (i.e. some; state well-represented by a single reference). Then, run an energy; calculation, passing in the charge and multiplicity of the; desired state; the number of spin-flips and IP/EA will be automatically; determined based on this input. If additional excitations outside of the; RAS II space are desired, one can set the level of external; excitations using the conf_space keyword.; A sample input file for a RAS(h)-2SF-IP calculation is shown below:; molecule {; 0 7; N 0.0 0.0 0.0; N 0.0 0.0 1.3; symmetry c1; }. set {; basis cc-pVDZ; }. energy('psi4fockci', new_charge=1, new_multiplicity=1, conf_space=""h""). Note that for calculations involving IP/EA, inclusion of hole (for IP) and; particle (for EA) excitations is strongly recommended. Additional keywords; can be found in the documentation.; This input file can be run with Psi4:; >>> psi4 input.dat. table of contents. Psi4FockCI: A General Fock-Space CI For Spin-Flip And IP/EA; Installation; Sample Input. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Psi4FockCI: A General Fock-Space CI For Spin-Flip And IP/EA. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/plugin_psi4fockci.html:1875,energy,energy,1875,psi4manual/master/plugin_psi4fockci.html,https://psicode.org,https://psicode.org/psi4manual/master/plugin_psi4fockci.html,1,['energy'],['energy']
Energy Efficiency,"lectron energy; - 'TWO-ELECTRON ENERGY' : SCF two-electron energy; - 'SCF TOTAL ENERGY' : SCF total energy; - 'MP2 CORRELATION ENERGY' : MP2 correlation energy. :param expected: Reference FCIDUMP file against which `computed` is compared.; :param computed: Input FCIDUMP file to compare against `expected`.; :param label: string labeling the test; """""". # Grab expected header and integrals; ref_intdump = fcidump_from_file(expected); intdump = fcidump_from_file(computed). # Compare headers; compare_recursive(; ref_intdump,; intdump,; 'FCIDUMP header',; forgive=['enuc', 'hcore', 'eri', 'epsilon']). ref_energies = energies_from_fcidump(ref_intdump); energies = energies_from_fcidump(intdump). pass_1el = compare_values(ref_energies['ONE-ELECTRON ENERGY'], energies['ONE-ELECTRON ENERGY'], 7,; label + '. 1-electron energy'); pass_2el = compare_values(ref_energies['TWO-ELECTRON ENERGY'], energies['TWO-ELECTRON ENERGY'], 7,; label + '. 2-electron energy'); pass_scf = compare_values(ref_energies['SCF TOTAL ENERGY'], energies['SCF TOTAL ENERGY'], 10,; label + '. SCF total energy'); pass_mp2 = compare_values(ref_energies['MP2 CORRELATION ENERGY'], energies['MP2 CORRELATION ENERGY'], 10,; label + '. MP2 correlation energy'). compare_integers(True, (pass_1el and pass_2el and pass_scf and pass_mp2), label). [docs]; def energies_from_fcidump(intdump) -> Dict[str, float]:; """"""From integrals dictionary generated from :py:func:`fcidump_from_file`,; compute energies. :returns: a dictionary with energies. - 'NUCLEAR REPULSION ENERGY'; - 'ONE-ELECTRON ENERGY'; - 'TWO-ELECTRON ENERGY'; - 'SCF TOTAL ENERGY'; - 'MP2 CORRELATION ENERGY'. """"""; energies = {}; energies['NUCLEAR REPULSION ENERGY'] = intdump['enuc']; epsilon = intdump['epsilon']; Hcore = intdump['hcore']; eri = intdump['eri']. # Compute SCF energy; energies['ONE-ELECTRON ENERGY'], energies['TWO-ELECTRON ENERGY'] = _scf_energy(Hcore, eri,; np.where(epsilon < 0)[0],; intdump['uhf']); # yapf: disable; energies['SCF TOTAL ENERGY'] = ener",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fcidump.html:13601,energy,energy,13601,psi4manual/1.8.x/_modules/psi4/driver/p4util/fcidump.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fcidump.html,12,"['ENERGY', 'energy']","['ENERGY', 'energy']"
Energy Efficiency,"lectron energy; - 'TWO-ELECTRON ENERGY' : SCF two-electron energy; - 'SCF TOTAL ENERGY' : SCF total energy; - 'MP2 CORRELATION ENERGY' : MP2 correlation energy. :param expected: Reference FCIDUMP file against which `computed` is compared.; :param computed: Input FCIDUMP file to compare against `expected`.; :param label: string labeling the test; """""". # Grab expected header and integrals; ref_intdump = fcidump_from_file(expected); intdump = fcidump_from_file(computed). # Compare headers; compare_recursive(; ref_intdump,; intdump,; 'FCIDUMP header',; forgive=['enuc', 'hcore', 'eri', 'epsilon']). ref_energies = energies_from_fcidump(ref_intdump); energies = energies_from_fcidump(intdump). pass_1el = compare_values(ref_energies['ONE-ELECTRON ENERGY'], energies['ONE-ELECTRON ENERGY'], 7,; label + '. 1-electron energy'); pass_2el = compare_values(ref_energies['TWO-ELECTRON ENERGY'], energies['TWO-ELECTRON ENERGY'], 7,; label + '. 2-electron energy'); pass_scf = compare_values(ref_energies['SCF TOTAL ENERGY'], energies['SCF TOTAL ENERGY'], 10,; label + '. SCF total energy'); pass_mp2 = compare_values(ref_energies['MP2 CORRELATION ENERGY'], energies['MP2 CORRELATION ENERGY'], 10,; label + '. MP2 correlation energy'). compare_integers(True, (pass_1el and pass_2el and pass_scf and pass_mp2), label). [docs]def energies_from_fcidump(intdump) -> Dict[str, float]:; """"""From integrals dictionary generated from :py:func:`fcidump_from_file`,; compute energies. :returns: a dictionary with energies. - 'NUCLEAR REPULSION ENERGY'; - 'ONE-ELECTRON ENERGY'; - 'TWO-ELECTRON ENERGY'; - 'SCF TOTAL ENERGY'; - 'MP2 CORRELATION ENERGY'. """"""; energies = {}; energies['NUCLEAR REPULSION ENERGY'] = intdump['enuc']; epsilon = intdump['epsilon']; Hcore = intdump['hcore']; eri = intdump['eri']. # Compute SCF energy; energies['ONE-ELECTRON ENERGY'], energies['TWO-ELECTRON ENERGY'] = _scf_energy(Hcore, eri,; np.where(epsilon < 0)[0],; intdump['uhf']); # yapf: disable; energies['SCF TOTAL ENERGY'] = energi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/fcidump.html:13593,energy,energy,13593,psi4manual/1.7.x/_modules/psi4/driver/p4util/fcidump.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/fcidump.html,4,"['ENERGY', 'energy']","['ENERGY', 'energy']"
Energy Efficiency,"lectron energy; - 'TWO-ELECTRON ENERGY' : SCF two-electron energy; - 'SCF TOTAL ENERGY' : SCF total energy; - 'MP2 CORRELATION ENERGY' : MP2 correlation energy. :param expected: Reference FCIDUMP file against which `computed` is compared.; :param computed: Input FCIDUMP file to compare against `expected`.; :param label: string labeling the test; """""". # Grab expected header and integrals; ref_intdump = fcidump_from_file(expected); intdump = fcidump_from_file(computed). # Compare headers; compare_recursive(; ref_intdump,; intdump,; 'FCIDUMP header',; forgive=['enuc', 'hcore', 'eri', 'epsilon']). ref_energies = energies_from_fcidump(ref_intdump); energies = energies_from_fcidump(intdump). pass_1el = compare_values(ref_energies['ONE-ELECTRON ENERGY'], energies['ONE-ELECTRON ENERGY'], 7,; label + '. 1-electron energy'); pass_2el = compare_values(ref_energies['TWO-ELECTRON ENERGY'], energies['TWO-ELECTRON ENERGY'], 7,; label + '. 2-electron energy'); pass_scf = compare_values(ref_energies['SCF TOTAL ENERGY'], energies['SCF TOTAL ENERGY'], 10,; label + '. SCF total energy'); pass_mp2 = compare_values(ref_energies['MP2 CORRELATION ENERGY'], energies['MP2 CORRELATION ENERGY'], 10,; label + '. MP2 correlation energy'). compare_integers(True, (pass_1el and pass_2el and pass_scf and pass_mp2), label). [docs]def energies_from_fcidump(intdump):; energies = {}; energies['NUCLEAR REPULSION ENERGY'] = intdump['enuc']; epsilon = intdump['epsilon']; Hcore = intdump['hcore']; eri = intdump['eri']. # Compute SCF energy; energies['ONE-ELECTRON ENERGY'], energies['TWO-ELECTRON ENERGY'] = _scf_energy(Hcore, eri,; np.where(epsilon < 0)[0],; intdump['uhf']); # yapf: disable; energies['SCF TOTAL ENERGY'] = energies['ONE-ELECTRON ENERGY'] + energies['TWO-ELECTRON ENERGY'] + energies['NUCLEAR REPULSION ENERGY']; # yapf: enable. # Compute MP2 energy; energies['MP2 CORRELATION ENERGY'] = _mp2_energy(eri, epsilon, intdump['uhf']). return energies. def _scf_energy(Hcore, ERI, occ_sl, unrestricted):;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/p4util/fcidump.html:13365,energy,energy,13365,psi4manual/1.6.x/_modules/psi4/driver/p4util/fcidump.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/p4util/fcidump.html,4,"['ENERGY', 'energy']","['ENERGY', 'energy']"
Energy Efficiency,"lectron property capabilities of PSI4¶. Feature; Keyword; Notes. Electric dipole moment; DIPOLE. Electric quadrupole moment; QUADRUPOLE; Raw (traced) moments and traceless multipoles. All moments up order N; MULTIPOLE(N); Only raw (traced) moments. Sets global variables e.g. “DIPOLE X”, “32-POLE XYYZZ”. Electrostatic potential, at nuclei; ESP_AT_NUCLEI; Sets global variables “ESP AT CENTER n”, n = 1 to natoms. Electrostatic potential, on grid; GRID_ESP; Generates V at each point in grid_esp.dat. See Properties evaluated on a grid. Electric field, on grid; GRID_FIELD; Generates {Ex,Ey,Ez} at each point grid_field.dat. See Properties evaluated on a grid. Molecular orbital extents; MO_EXTENTS. Mulliken atomic charges; MULLIKEN_CHARGES. Löwdin atomic charges; LOWDIN_CHARGES. Wiberg bond indices; WIBERG_LOWDIN_INDICES; Uses (Löwdin) symmetrically orthogonalized orbitals. Mayer bond indices; MAYER_INDICES. Natural orbital occupations; NO_OCCUPATIONS. Stockholder Atomic Multipoles; MBIS_CHARGES; Generates atomic charges, dipoles, etc. See Minimal Basis Iterative Stockholder. There are two ways the computation of one-electron properties can be requested.; Firstly, the properties can be evaluated from the last; computed one-particle density, using the following syntax:; oeprop(""MO_EXTENTS"", ""MULTIPOLE(4)"", title = ""hello!""). Note that it is the user’s responsibility to ensure that the relaxed density; matrix is computed using the method of interest, which may require setting; additional keywords (see the method’s manual section for details). The named; argument, title, is completely optional and is prepended to any; globals variables set during the computation. The unnamed arguments are the; properties to be computed. These can appear in any order, and multiple; properties may be requested, as in the example above. Note that, due to Python; syntax restrictions, the title argument must appear after the list of; properties to compute. The available properties are shown in the t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/oeprop-1.html:1983,charge,charges,1983,psi4manual/1.4.0/oeprop-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/oeprop-1.html,4,['charge'],['charges']
Energy Efficiency,"lecular systems. The choices for this; keyword are case sensitive and must match the database python file. [1,2,5] || ['1','2','5'] || ['BzMe-3.5', 'MeMe-5.0'] || etc.; Specify a list of database members to run. Consult the; database python files for available molecular systems. The; choices for this keyword are case sensitive and must match the; database python file. Examples :. >>> # [1] Two-stage SCF calculation on short, equilibrium, and long helium dimer; >>> db('scf','RGC10',cast_up='sto-3g',subset=['HeHe-0.85','HeHe-1.0','HeHe-1.5'], tabulate=['scf total energy','natom']). >>> # [2] Counterpoise-corrected interaction energies for three complexes in S22; >>> # Error statistics computed wrt an old benchmark, S22A; >>> database('dfmp2','S22',cp=1,subset=[16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). Output¶; At the beginning of a database job is printed a listing of the individual system; calculations which will be performed. The output snippet below is from the example job [1]; above. It shows each reagent required for the subset of database reactions requested.; Note that this is an un-counterpoise-corrected example, and the wrapper is smart enough; to compute only once the monomer whose energy will be subtracted from each of the three dimers.; RGC1-HeHe-0.85-dimer; RGC1-He-mono-unCP; RGC1-HeHe-1.0-dimer; RGC1-HeHe-1.5-dimer. At the end of the job, the Requested Energy table is printed that gives the total; energies for the requested model chemistry for each reagent and each reaction, as; well as the stoichoimetric we",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/db-1.html:5366,energy,energy,5366,psi4manual/4.0b2/db-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/db-1.html,6,['energy'],['energy']
Energy Efficiency,"lecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element of a tuple. :type bsse_type: str or list; :param bsse_type: ``'cp'`` || ``['nocp', 'vmfc']`` || |dl| ``None`` |dr| || etc. Type of BSSE correction to compute: CP for counterpoise correction, NoCP; for plain supramolecular interaction energy, or VMFC for Valiron-Mayer; Function Counterpoise correction. If a list is provided, the first string in; the list determines which interaction or total energies/gradients/Hessians are; returned by this function. By default, this function is not called. :type max_nbody: int; :param max_nbody: ``3`` || etc. Maximum n-body to compute, cannot exceed the number of fragments in the molecule. :type ptype: str; :param ptype: ``'energy'`` || ``'gradient'`` || ``'hessian'``. Type of the procedure passed in. :type return_total_data: :ref:`boolean <op_py_boolean>`; :param return_total_data: ``'on'`` || |dl| ``'off'`` |dr|. If True returns the total data (energy/gradient/Hessian) of the system,; otherwise returns interaction data. Default is ``'off'`` for energies,; ``'on'`` for gradients and Hessians. Note that the calculation of total; counterpoise corrected energies implies the calculation of the energies of; monomers in the monomer basis, hence specifying ``return_total_data = True``; may carry out more computations than ``return_total_data = False``. :type levels: dict; :param levels: ``{1: 'ccsd(t)', 2: 'mp2', 'supersystem': 'scf'}`` || ``{1: 2, 2: 'ccsd(t)', 3: 'mp2'}`` || etc. Dictionary of different levels of theory for different levels of expansion; Note that method_string is not used in this case. ``supersystem`` computes; all higher order n-body effects up to the number of fragments. :type embedding_charges",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html:5605,energy,energy,5605,psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html,4,['energy'],['energy']
Energy Efficiency,"lecule and cube file data; (contained in the .cube file), set up the visualization, and render a; .png image of the scene. Generally the view orientation and some specific; details of the .pymol files require some small tweaks to permit; publication-quality renderings. Adding Point Charges to F/I-SAPT Computations¶; Point charges can be added to the interacting subsystems A and B as well; as to the linking fragment C. Briefly, the interaction between the point charges in A(B); and fragment B(A) enters the SAPT0 interaction energy. It explicitly affects the electrostatics; and induction components, and implicitly affects other SAPT0 components by polarizing the orbitals.; If point charges are present in both subsystems A and B, an additional charge-charge interaction; term is also added to the electrostatic energy. When point charges are assigned to subsystem C, the point; charges in C only polarize the orbitals in both fragment A and B. However, the presence of charges in C does not; directly contribute to the SAPT0 interaction energy.; Examples fsapt-ext-abc and fsapt-ext-abc2; illustrate the use of point charges in F/I-SAPT procedure. Link Orbital Partitioning in I-SAPT¶; The assignment of the A-C and B-C linking electron pairs is controlled by the FISAPT_LINK_ASSIGNMENT; keyword. The default setting fisapt_link_assignment c assigns the entire pair to the linker C together with; a +1 nuclear charge from the connecting atoms of A/B to preserve the electrical neutrality of each fragment.; However, as already noticed in [Parrish:2015:051103], such a partitioning might result in unphysical dipole; moments at the interfragment boundaries. Imagine, for example, that I-SAPT is used to examine the interaction; of two methyl groups connected by some linker fragment. When the linking bonds are assigned to C, the carbon atoms; of the methyl groups are missing electrons on one of their sp^3 hybrid orbitals and a dipole moment appears.; These dipole moments have been observed t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/fisapt.html:12832,charge,charges,12832,psi4manual/1.8.x/fisapt.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/fisapt.html,6,"['charge', 'energy']","['charges', 'energy']"
Energy Efficiency,"lecule from unvalidated arrays and variables. from_dict(arg0); Returns a new Molecule constructed from python dictionary. from_schema(molschema[, return_dict, ...]); Construct Molecule from non-Psi4 schema. from_string(molstr[, dtype, name, fix_com, ...]). fsymbol(self, atom); Gets the cleaned up label of atom (C2 => C, H4 = H) (0-indexed including dummies). ftrue_atomic_number(self, atom); Gets atomic number of atom from element (0-indexed including dummies). full_geometry(self); Gets the geometry [Bohr] as a (Natom X 3) matrix of coordinates (including dummies). full_pg_n(self); Gets n in Cnv, etc.; If there is no n (e.g. fx(self, arg0); x position of atom arg0 (0-indexed including dummies in Bohr). fy(self, arg0); y position of atom arg0 (0-indexed including dummies in Bohr). fz(self, arg0); z position of atom arg0 (0-indexed including dummies in Bohr). geometry(self); Gets the geometry [Bohr] as a (Natom X 3) matrix of coordinates (excluding dummies). get_fragment_charges(self); Gets the charge of each fragment. get_fragment_multiplicities(self); Gets the multiplicity of each fragment. get_fragment_types(self); Returns a list describing how to handle each fragment {Real, Ghost, Absent}. get_fragments(self); Returns list of pairs of atom ranges defining each fragment from parent molecule(fragments[frag_ind] = <Afirst,Alast+1>). get_full_point_group(self); Gets point group name such as C3v or S8. get_full_point_group_with_n(self); Gets point group name such as Cnv or Sn. get_variable(self, arg0); Returns the value of variable arg0 in the structural variables list. has_zmatrix(self); Get whether or not this molecule has at least one zmatrix entry. inertia_tensor(self); Returns intertial tensor. input_units_to_au(self); Returns unit conversion to [a0] for geometry. irrep_labels(self); Returns Irreducible Representation symmetry labels. is_variable(self, arg0); Checks if variable arg0 is in the structural variables list. label(self, atom); Gets the original label of ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html:3868,charge,charge,3868,psi4manual/1.7.x/api/psi4.core.Molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html,2,['charge'],['charge']
Energy Efficiency,"lecule from unvalidated arrays and variables. from_dict(arg0); Returns a new Molecule constructed from python dictionary. from_schema(molschema[, return_dict, ...]); Construct Molecule from non-Psi4 schema. from_string(molstr[, dtype, name, fix_com, ...]). fsymbol(self, atom); Gets the cleaned up label of atom (C2 => C, H4 = H) (0-indexed including dummies). ftrue_atomic_number(self, atom); Gets atomic number of atom from element (0-indexed including dummies). full_geometry(self); Gets the geometry [Bohr] as a (Natom X 3) matrix of coordinates (including dummies). full_pg_n(self); Gets n in Cnv, etc.; If there is no n (e.g. fx(self, arg0); x position of atom arg0 (0-indexed including dummies in Bohr). fy(self, arg0); y position of atom arg0 (0-indexed including dummies in Bohr). fz(self, arg0); z position of atom arg0 (0-indexed including dummies in Bohr). geometry(self); Gets the geometry [Bohr] as a (Natom X 3) matrix of coordinates (excluding dummies). get_fragment_charges(self); Gets the charge of each fragment. get_fragment_multiplicities(self); Gets the multiplicity of each fragment. get_fragment_types(self); Returns a list describing how to handle each fragment {Real, Ghost, Absent}. get_fragments(self); Returns list of pairs of atom ranges defining each fragment from parent molecule(fragments[frag_ind] = <Afirst,Alast+1>). get_full_point_group(self); Gets point group name such as C3v or S8. get_full_point_group_with_n(self); Gets point group name such as Cnv or Sn. get_variable(self, arg0); Returns the value of variable arg0 in the structural variables list. inertia_tensor(self); Returns intertial tensor. input_units_to_au(self); Returns unit conversion to [a0] for geometry. irrep_labels(self); Returns Irreducible Representation symmetry labels. is_variable(self, arg0); Checks if variable arg0 is in the structural variables list. label(self, atom); Gets the original label of the atom as given in the input file (C2, H4)(0-indexed without dummies). mass(self, ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.core.molecule.html:3886,charge,charge,3886,psi4manual/1.5.0/api/psi4.core.molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.core.molecule.html,4,['charge'],['charge']
Energy Efficiency,"lecule input strings identically. psimrcc-ccsd_t-3; Mk-MRCCSD(T) single point. CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. cc46; EOM-CC2/cc-pVDZ on H2O2 with two excited states in each irrep. omp3-grad1; OMP3 cc-pVDZ gradient for the H2O molecule. cc21; ROHF-EOM-CCSD/DZ analytic gradient lowest excited state of H2O+ (B1 excitation). opt11; Transition-state optimizations of HOOH to both torsional transition states. x2c2; Test of SFX2C-1e on Water cc-pVDZ-DK. In this test the Dirac equation is solved in the uncontracted cc-pVDZ-DK basis. The reference numbers are from Lan Cheng’s implementation in Cfour. scf-bs; UHF and broken-symmetry UHF energy for molecular hydrogen. pywrap-opt-sowreap; Finite difference optimization, run in sow/reap mode. dft-b2plyp; Double-hybrid density functional B2PYLP. Reproduces portion of Table I in S. Grimme’s J. Chem. Phys 124 034108 (2006) paper defining the functional. sapt5; SAPT0 aug-cc-pVTZ computation of the charge transfer energy of the water dimer. cisd-opt-fd; H2O CISD/6-31G** Optimize Geometry by Energies. castup2; SCF with various combinations of pk/density-fitting, castup/no-castup, and spherical/cartesian settings. Demonstrates that puream setting is getting set by orbital basis for all df/castup parts of calc. Demonstrates that answer doesn’t depend on presence/absence of castup. Demonstrates (by comparison to castup3) that output file doesn’t depend on options (scf_type) being set global or local. This input uses global. mints3; Test individual integral objects for correctness. fci-tdm; He2+ FCI/cc-pVDZ Transition Dipole Moment. cc38; RHF-CC2-LR/cc-pVDZ static polarizabilities of HOF molecule. pywrap-db2; Database calculation, run in sow/reap mode. cbs-xtpl-func; optimization with method defined via cbs. cisd-h2o+-0; 6-31G** H2O+ Test CISD Energy Point. opt13; B3LYP cc-pVDZ geometry optimzation of phenylacetylene, starting from not quite linear structure. tu5-sapt; Example SAPT c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html:27939,charge,charge,27939,psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html,8,"['charge', 'energy']","['charge', 'energy']"
Energy Efficiency,"lecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(). # Allow specification of methods to arbitrary order; lowername, level = parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. try:; # Set method-dependent scf convergence criteria; if not PsiMod.has_option_changed('SCF', 'E_CONVERGENCE'):; if procedures['energy'][lowername] == run_scf or procedures['energy'][lowername] == run_dft:; PsiMod.set_local_option('SCF', 'E_CONVERGENCE', 6); else:; PsiMod.set_local_option('SCF', 'E_CONVERGENCE', 8); if not PsiMod.has_option_changed('SCF', 'D_CONVERGENCE'):; if procedures['energy'][lowername] == run_scf or procedures['energy'][lowername] == run_dft:; PsiMod.set_local_option('SCF', 'D_CONVERGENCE', 6); else:; PsiMod.set_local_option('SCF', 'D_CONVERGENCE', 8). # Set post-scf convergence criteria (global will cover all correlated modules); if not PsiMod.has_global_option_changed('E_CONVERGENCE'):; if not procedures['energy'][lowername] == run_scf and not procedures['energy'][lowername] == run_dft:; PsiMod.set_global_option('E_CONVERGENCE', 6). procedures['energy'][lowername](lowername, **kwargs). except KeyError:; raise ValidationError('Energy method %s not available.' % (lowername)). optstash.restore(); return PsiMod.get_variable('CURRENT ENERGY'). [docs]def gradient(name, **kwargs):; r""""""Function complementary to optimize(). Carries out one gradient pass,; deciding analytic or finite difference. """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs); dertype = 1. optstash = OptionsState(; ['SCF', 'E_CONVERGENCE'],; ['SCF', 'D_CONVERGENCE'],; ['E_CONVERGENCE']). # Order of precedence:; # 1. Default for wavefunction; # 2. Value obtained from kwargs, if user changed it; # 3. If user provides a custom 'func' use that. # Allow specification of methods to arbitrary order; lowername, level = parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. # 1. set the default to that of the provided name;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/driver.html:30053,energy,energy,30053,psi4manual/4.0b4/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/driver.html,4,['energy'],['energy']
Energy Efficiency,"lecule().set_geometry(displacement). # Perform the energy calculation; #E = func(lowername, **kwargs); func(lowername, **kwargs); E = psi4.get_variable('CURRENT ENERGY'); #E = func(**kwargs). # Save the energy; energies.append(E). # S/R: Write each displaced geometry to an input file; elif (opt_mode.lower() == 'sow'):; psi4.get_active_molecule().set_geometry(displacement). # S/R: Prepare molecule, options, and kwargs; freagent = open('%s.in' % (rfile), 'w'); freagent.write('# This is a psi4 input file auto-generated from the gradient() wrapper.\n\n'); freagent.write(p4util.format_molecule_for_input(molecule)); freagent.write(p4util.format_options_for_input()); p4util.format_kwargs_for_input(freagent, **kwargs). # S/R: Prepare function call and energy save; freagent.write(""""""electronic_energy = %s('%s', **kwargs)\n\n"""""" % (func.__name__, lowername)); freagent.write(""""""psi4.print_out('\\nGRADIENT RESULT: computation %d for item %d """""" % (os.getpid(), n + 1)); freagent.write(""""""yields electronic energy %20.12f\\n' % (electronic_energy))\n\n""""""); freagent.close(). # S/R: Read energy from each displaced geometry output file and save in energies array; elif (opt_mode.lower() == 'reap'):; exec(banners); psi4.set_variable('NUCLEAR REPULSION ENERGY', molecule.nuclear_repulsion_energy()); energies.append(p4util.extract_sowreap_from_output(rfile, 'GRADIENT', n, opt_linkage, True)). # S/R: Quit sow after writing files; if (opt_mode.lower() == 'sow'):; optstash.restore(); return 0.0. if (opt_mode.lower() == 'reap'):; psi4.set_variable('CURRENT ENERGY', energies[-1]). # Obtain the gradient; psi4.fd_1_0(energies); # The last item in the list is the reference energy, return it; optstash.restore(); return energies[-1]. [docs]def property(name, **kwargs):; r""""""Function to compute various properties. :aliases: prop(). :returns: none. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - This function at present handles property functions only for CC methods.;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/driver.html:40445,energy,energy,40445,psi4manual/4.0b5/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/driver.html,2,['energy'],['energy']
Energy Efficiency,"lecule(); efp_present = hasattr(mol, 'EFP'). translations_projection_sound = (not core.get_option('SCF', 'EXTERN') and not core.get_option('SCF', 'PERTURB_H'); and not efp_present); rotations_projection_sound = (translations_projection_sound and stationary_point). return translations_projection_sound, rotations_projection_sound. def _filter_renamed_methods(compute, method):; r""""""Raises UpgradeHelper when a method has been renamed.""""""; if method == ""dcft"":; raise UpgradeHelper(compute + ""('dcft')"", compute + ""('dct')"", 1.4,; "" All instances of 'dcft' should be replaced with 'dct'.""). [docs]; def energy(name, **kwargs):; r""""""Function to compute the single-point electronic energy. :returns: *float* |w--w| Total electronic energy in Hartrees. SAPT & EFP return interaction energy. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY`; * :psivar:`CURRENT REFERENCE ENERGY`; * :psivar:`CURRENT CORRELATION ENERGY`. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple. :type write_orbitals: str, :ref:`boolean <op_py_boolean>`; :param write_orbitals: ``filename`` || |dl| ``'on'`` |dr| || ``'off'`` . (str) Save wfn containing current orbitals to the given file name after each SCF iteration; and retain after |PSIfour| finishes. (:ref:`boolean <op_py_boolean>`) Turns writing the orbitals after the converged SCF on/off.; Orbital file will be deleted ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:3355,ENERGY,ENERGY,3355,psi4manual/1.8.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html,9,['ENERGY'],['ENERGY']
Energy Efficiency,"lecule)); fmaster.write(format_options_for_input()); format_kwargs_for_input(fmaster, 2, **kwargs); fmaster.write(""""""%s('%s', **kwargs)\n\n"""""" % (optimize.__name__, lowername)); fmaster.write(instructionsM); fmaster.close(). for n, displacement in enumerate(displacements):; rfile = 'OPT-%s-%s' % (opt_iter, n + 1); #rfile = 'OPT-fd-%s' % (n + 1). # Build string of title banner; banners = ''; banners += """"""PsiMod.print_out('\\n')\n""""""; banners += """"""banner(' Gradient %d Computation: Displacement %d')\n"""""" % (opt_iter, n + 1); banners += """"""PsiMod.print_out('\\n')\n\n"""""". if (opt_mode.lower() == 'continuous'):; # Print information to output.dat; PsiMod.print_out('\n'); banner('Loading displacement %d of %d' % (n + 1, ndisp)). # Print information to the screen; print(' %d' % (n + 1), end=""""); if (n + 1) == ndisp:; print('\n', end=""""). # Load in displacement into the active molecule; PsiMod.get_active_molecule().set_geometry(displacement). # Perform the energy calculation; #E = func(lowername, **kwargs); func(lowername, **kwargs); E = PsiMod.get_variable('CURRENT ENERGY'); #E = func(**kwargs). # Save the energy; energies.append(E). # S/R: Write each displaced geometry to an input file; elif (opt_mode.lower() == 'sow'):; PsiMod.get_active_molecule().set_geometry(displacement). # S/R: Prepare molecule, options, and kwargs; freagent = open('%s.in' % (rfile), 'w'); freagent.write('# This is a psi4 input file auto-generated from the gradient() wrapper.\n\n'); freagent.write(format_molecule_for_input(molecule)); freagent.write(format_options_for_input()); format_kwargs_for_input(freagent, **kwargs). # S/R: Prepare function call and energy save; freagent.write(""""""electronic_energy = %s('%s', **kwargs)\n\n"""""" % (func.__name__, lowername)); freagent.write(""""""PsiMod.print_out('\\nGRADIENT RESULT: computation %d for item %d """""" % (os.getpid(), n + 1)); freagent.write(""""""yields electronic energy %20.12f\\n' % (electronic_energy))\n\n""""""); freagent.close(). # S/R: Read energy from eac",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/driver.html:30028,energy,energy,30028,psi4manual/4.0b3/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/driver.html,4,['energy'],['energy']
Energy Efficiency,"lecule. soscf-large; Second-order SCF convergnece: Benzene. dft-grad1; DF-BP86-D2 cc-pVDZ frozen core gradient of S22 HCN update ref gradient due to new BraggSlater radii. scf-hess5; DF SCF 6-31G analytical vs finite-difference tests Tests DF UHF hessian code for Ca != Cb. pywrap-db1; Database calculation, so no molecule section in input file. Portions of the full databases, restricted by subset keyword, are computed by sapt0 and dfmp2 methods. stability1; UHF->UHF stability analysis test for BH with cc-pVDZ Test direct SCF with and without symmetry, test PK without symmetry. psimrcc-ccsd_t-2; Mk-MRCCSD(T) single point. \(^1A_1\) CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. omp3-grad1; OMP3 cc-pVDZ gradient for the H2O molecule. psimrcc-ccsd_t-3; Mk-MRCCSD(T) single point. \(^1A_1\) CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. mom-h2o-3; MOM excitation from LUMO HOMO+3. dfccsdt2; DF-CCSD(T) cc-pVDZ energy for the NH molecule. dfmp2-ecp; Ne-Xe dimer MP2 energies with ECP, with electrons correlated then frozen. explicit-am-basis; Check that basis sets can be input with explicit angular momentum format. pywrap-cbs1; Various basis set extrapolation tests. fnocc2; Test G2 method for H2O. cbs-xtpl-dict; Extrapolated water energies. cc26; Single-point gradient, analytic and via finite-differences of 2-1A1 state of H2O with EOM-CCSD. mpn-bh; MP(n)/aug-cc-pVDZ BH Energy Point, with n=2-19. Compare against M. L. Leininger et al., J. Chem. Phys. 112, 9213 (2000). mints15; check SP basis Fortran exponent parsing. dfmp2-freq2; DF-MP2 frequency by difference of energies for H2O. omp3-2; OMP3 cc-pCVDZ energy with ROHF initial guess for the NO radical. cc45; RHF-EOM-CC2/cc-pVDZ lowest two states of each symmetry of H2O. dfomp2-grad3; Tests OMP2 gradient in the presence of a dipole field. omp2p5-grad1; OMP2.5 cc-pVDZ gradient for the H2O molecule. opt-freeze-coords; SCF/cc-pVDZ optimization exam",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html:19756,energy,energy,19756,psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"lecule.set_multiplicity(mult1); core.set_global_option(""DOCC"", [Nb1]); core.set_global_option(""SOCC"", [Na1 - Nb1]); E1 = driver.energy('scf', dft_functional=name, molecule=molecule,; banner='IP Fitting SCF: Cation, Omega = {:11.3E}'.format(omega), **kwargs); core.IO.change_file_namespace(180, ""ot"", ""cation""). IP = E1 - E0; kIP = -E_HOMO; delta = IP - kIP. if kIP > IP:; omega_r = omega; E0r = E0; E1r = E1; IPr = IP; kIPr = kIP; delta_r = delta; repeat_r = 0; repeat_l += 1; else:; omega_l = omega; E0l = E0; E1l = E1; IPl = IP; kIPl = kIP; delta_l = delta; repeat_l = 0; repeat_r += 1. omegas.append(omega); types.append('Regula-Falsi'); E0s.append(E0); E1s.append(E1); IPs.append(IP); kIPs.append(kIP). # Termination; if abs(omega_l - omega_r) < omega_convergence:; converged = True; break. core.IO.set_default_namespace(""""); core.print_out(""""""\n ==> IP Fitting Results <==\n\n""""""). core.print_out("""""" => Occupation Determination <= \n\n""""""); core.print_out("""""" %6s %6s %6s %6s %6s %6s\n"""""" % ('N', 'Na', 'Nb', 'Charge', 'Mult', 'HOMO')); core.print_out("""""" Neutral: %6d %6d %6d %6d %6d %6d\n"""""" % (N, Na, Nb, charge0, mult0, HOMO)); core.print_out("""""" Cation: %6d %6d %6d %6d %6d\n\n"""""" % (N - 1, Na1, Nb1, charge1, mult1)). core.print_out("""""" => Regula Falsi Iterations <=\n\n""""""); core.print_out("""""" %3s %11s %14s %14s %14s %s\n"""""" % ('N','Omega','IP','kIP','Delta','Type')); for k in range(len(omegas)):; core.print_out("""""" %3d %11.3E %14.6E %14.6E %14.6E %s\n"""""" %; (k + 1, omegas[k], IPs[k], kIPs[k], IPs[k] - kIPs[k], types[k])). optstash.restore(); if converged:; core.print_out(""""""\n IP Fitting Converged\n""""""); core.print_out("""""" Final omega = %14.6E\n"""""" % ((omega_l + omega_r) / 2)); core.print_out(""""""\n ""M,I. does the dying. Fleet just does the flying.""\n""""""); core.print_out("""""" -Starship Troopers\n""""""). else:; raise ConvergenceError(""""""IP Fitting """""", step + 1). return ((omega_l + omega_r) / 2). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.10a1",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/_modules/psi4/driver/frac.html:22459,Charge,Charge,22459,psi4manual/master/_modules/psi4/driver/frac.html,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/frac.html,1,['Charge'],['Charge']
Energy Efficiency,"lecule.set_multiplicity(mult1); core.set_global_option(""DOCC"", [Nb1]); core.set_global_option(""SOCC"", [Na1 - Nb1]); E1 = driver.energy('scf', dft_functional=name, molecule=molecule,; banner='IP Fitting SCF: Cation, Omega = {:11.3E}'.format(omega), **kwargs); core.IO.change_file_namespace(180, ""ot"", ""cation""). IP = E1 - E0; kIP = -E_HOMO; delta = IP - kIP. if kIP > IP:; omega_r = omega; E0r = E0; E1r = E1; IPr = IP; kIPr = kIP; delta_r = delta; repeat_r = 0; repeat_l += 1; else:; omega_l = omega; E0l = E0; E1l = E1; IPl = IP; kIPl = kIP; delta_l = delta; repeat_l = 0; repeat_r += 1. omegas.append(omega); types.append('Regula-Falsi'); E0s.append(E0); E1s.append(E1); IPs.append(IP); kIPs.append(kIP). # Termination; if abs(omega_l - omega_r) < omega_convergence:; converged = True; break. core.IO.set_default_namespace(""""); core.print_out(""""""\n ==> IP Fitting Results <==\n\n""""""). core.print_out("""""" => Occupation Determination <= \n\n""""""); core.print_out("""""" %6s %6s %6s %6s %6s %6s\n"""""" % ('N', 'Na', 'Nb', 'Charge', 'Mult', 'HOMO')); core.print_out("""""" Neutral: %6d %6d %6d %6d %6d %6d\n"""""" % (N, Na, Nb, charge0, mult0, HOMO)); core.print_out("""""" Cation: %6d %6d %6d %6d %6d\n\n"""""" % (N - 1, Na1, Nb1, charge1, mult1)). core.print_out("""""" => Regula Falsi Iterations <=\n\n""""""); core.print_out("""""" %3s %11s %14s %14s %14s %s\n"""""" % ('N','Omega','IP','kIP','Delta','Type')); for k in range(len(omegas)):; core.print_out("""""" %3d %11.3E %14.6E %14.6E %14.6E %s\n"""""" %; (k + 1, omegas[k], IPs[k], kIPs[k], IPs[k] - kIPs[k], types[k])). optstash.restore(); if converged:; core.print_out(""""""\n IP Fitting Converged\n""""""); core.print_out("""""" Final omega = %14.6E\n"""""" % ((omega_l + omega_r) / 2)); core.print_out(""""""\n ""M,I. does the dying. Fleet just does the flying.""\n""""""); core.print_out("""""" -Starship Troopers\n""""""). else:; raise ConvergenceError(""""""IP Fitting """""", step + 1). return ((omega_l + omega_r) / 2). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.7;  ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/frac.html:22489,Charge,Charge,22489,psi4manual/1.7.x/_modules/psi4/driver/frac.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/frac.html,1,['Charge'],['Charge']
Energy Efficiency,"lecule.set_multiplicity(mult1); core.set_global_option(""DOCC"", [Nb1]); core.set_global_option(""SOCC"", [Na1 - Nb1]); E1 = driver.energy('scf', dft_functional=name, molecule=molecule,; banner='IP Fitting SCF: Cation, Omega = {:11.3E}'.format(omega), **kwargs); core.IO.change_file_namespace(180, ""ot"", ""cation""). IP = E1 - E0; kIP = -E_HOMO; delta = IP - kIP. if kIP > IP:; omega_r = omega; E0r = E0; E1r = E1; IPr = IP; kIPr = kIP; delta_r = delta; repeat_r = 0; repeat_l += 1; else:; omega_l = omega; E0l = E0; E1l = E1; IPl = IP; kIPl = kIP; delta_l = delta; repeat_l = 0; repeat_r += 1. omegas.append(omega); types.append('Regula-Falsi'); E0s.append(E0); E1s.append(E1); IPs.append(IP); kIPs.append(kIP). # Termination; if abs(omega_l - omega_r) < omega_convergence:; converged = True; break. core.IO.set_default_namespace(""""); core.print_out(""""""\n ==> IP Fitting Results <==\n\n""""""). core.print_out("""""" => Occupation Determination <= \n\n""""""); core.print_out("""""" %6s %6s %6s %6s %6s %6s\n"""""" % ('N', 'Na', 'Nb', 'Charge', 'Mult', 'HOMO')); core.print_out("""""" Neutral: %6d %6d %6d %6d %6d %6d\n"""""" % (N, Na, Nb, charge0, mult0, HOMO)); core.print_out("""""" Cation: %6d %6d %6d %6d %6d\n\n"""""" % (N - 1, Na1, Nb1, charge1, mult1)). core.print_out("""""" => Regula Falsi Iterations <=\n\n""""""); core.print_out("""""" %3s %11s %14s %14s %14s %s\n"""""" % ('N','Omega','IP','kIP','Delta','Type')); for k in range(len(omegas)):; core.print_out("""""" %3d %11.3E %14.6E %14.6E %14.6E %s\n"""""" %; (k + 1, omegas[k], IPs[k], kIPs[k], IPs[k] - kIPs[k], types[k])). optstash.restore(); if converged:; core.print_out(""""""\n IP Fitting Converged\n""""""); core.print_out("""""" Final omega = %14.6E\n"""""" % ((omega_l + omega_r) / 2)); core.print_out(""""""\n ""M,I. does the dying. Fleet just does the flying.""\n""""""); core.print_out("""""" -Starship Troopers\n""""""). else:; raise ConvergenceError(""""""IP Fitting """""", step + 1). return ((omega_l + omega_r) / 2). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.8.2;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/frac.html:22497,Charge,Charge,22497,psi4manual/1.8.x/_modules/psi4/driver/frac.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/frac.html,1,['Charge'],['Charge']
Energy Efficiency,"lecule.set_multiplicity(mult1); core.set_global_option(""DOCC"", [Nb1]); core.set_global_option(""SOCC"", [Na1 - Nb1]); E1 = driver.energy('scf', dft_functional=name, molecule=molecule,; banner='IP Fitting SCF: Cation, Omega = {:11.3E}'.format(omega), **kwargs); core.IO.change_file_namespace(180, ""ot"", ""cation""). IP = E1 - E0; kIP = -E_HOMO; delta = IP - kIP. if kIP > IP:; omega_r = omega; E0r = E0; E1r = E1; IPr = IP; kIPr = kIP; delta_r = delta; repeat_r = 0; repeat_l += 1; else:; omega_l = omega; E0l = E0; E1l = E1; IPl = IP; kIPl = kIP; delta_l = delta; repeat_l = 0; repeat_r += 1. omegas.append(omega); types.append('Regula-Falsi'); E0s.append(E0); E1s.append(E1); IPs.append(IP); kIPs.append(kIP). # Termination; if abs(omega_l - omega_r) < omega_convergence:; converged = True; break. core.IO.set_default_namespace(""""); core.print_out(""""""\n ==> IP Fitting Results <==\n\n""""""). core.print_out("""""" => Occupation Determination <= \n\n""""""); core.print_out("""""" %6s %6s %6s %6s %6s %6s\n"""""" % ('N', 'Na', 'Nb', 'Charge', 'Mult', 'HOMO')); core.print_out("""""" Neutral: %6d %6d %6d %6d %6d %6d\n"""""" % (N, Na, Nb, charge0, mult0, HOMO)); core.print_out("""""" Cation: %6d %6d %6d %6d %6d\n\n"""""" % (N - 1, Na1, Nb1, charge1, mult1)). core.print_out("""""" => Regula Falsi Iterations <=\n\n""""""); core.print_out("""""" %3s %11s %14s %14s %14s %s\n"""""" % ('N','Omega','IP','kIP','Delta','Type')); for k in range(len(omegas)):; core.print_out("""""" %3d %11.3E %14.6E %14.6E %14.6E %s\n"""""" %; (k + 1, omegas[k], IPs[k], kIPs[k], IPs[k] - kIPs[k], types[k])). optstash.restore(); if converged:; core.print_out(""""""\n IP Fitting Converged\n""""""); core.print_out("""""" Final omega = %14.6E\n"""""" % ((omega_l + omega_r) / 2)); core.print_out(""""""\n ""M,I. does the dying. Fleet just does the flying.""\n""""""); core.print_out("""""" -Starship Troopers\n""""""). else:; raise ConvergenceError(""""""IP Fitting """""", step + 1). return ((omega_l + omega_r) / 2). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.9.1;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/frac.html:22452,Charge,Charge,22452,psi4manual/1.9.x/_modules/psi4/driver/frac.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/frac.html,1,['Charge'],['Charge']
Energy Efficiency,"lecule.to_schema(dtype=2),; 'properties': properties,; 'provenance': p4util.provenance_stamp(__name__, module=assembled_results[""module""]),; 'extras': {; 'qcvars': qcvars,; 'cbs_record': copy.deepcopy(self.cbsrec),; },; 'return_result': assembled_results['ret_ptype'],; 'success': True,; }). logger.debug('CBS QCSchema:\n' + pp.pformat(cbs_model.dict())). return cbs_model. [docs]; def get_psi_results(; self,; client: Optional[""qcportal.FractalClient""] = None,; *,; return_wfn: bool = False) -> EnergyGradientHessianWfnReturn:; """"""Called by driver to assemble results into Composite-flavored QCSchema,; then reshape and return them in the customary Psi4 driver interface: ``(e/g/h, wfn)``. Parameters; ----------; return_wfn; Whether to additionally return the dummy :py:class:`~psi4.core.Wavefunction`; calculation result as the second element of a tuple. Contents are:. - molecule; - dummy basis, def2-svp; - e/g/h member data; - QCVariables; - module if simple. Returns; -------; ret; Energy, gradient, or Hessian according to self.driver.; wfn; Wavefunction described above when *return_wfn* specified. """"""; cbs_model = self.get_results(client=client). if cbs_model.driver == 'energy':; ret_ptype = cbs_model.return_result; else:; ret_ptype = core.Matrix.from_array(cbs_model.return_result); wfn = _cbs_schema_to_wfn(cbs_model). if return_wfn:; return (ret_ptype, wfn); else:; return ret_ptype. def _cbs_schema_to_wfn(cbs_model):; """"""Helper function to produce Wavefunction from a Composite-flavored AtomicResult."""""". mol = core.Molecule.from_schema(cbs_model.molecule.dict()); basis = core.BasisSet.build(mol, ""ORBITAL"", 'def2-svp', quiet=True); wfn = core.Wavefunction(mol, basis); if hasattr(cbs_model.provenance, ""module""):; wfn.set_module(cbs_model.provenance.module). # wfn.set_energy(cbs_model['extras'['qcvars'].get('CBS TOTAL ENERGY')) # catches Wfn.energy_; for qcv, val in cbs_model.extras['qcvars'].items():; for obj in [core, wfn]:; obj.set_variable(qcv, val). return wfn. «; hide me",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:61331,Energy,Energy,61331,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,3,['Energy'],['Energy']
Energy Efficiency,"lecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] Optical rotation calculation; >>> property('cc2', properties=['rotation']). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Make sure the molecule the user provided is the active one; if ('molecule' in kwargs):; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); #PsiMod.set_global_option('BASIS', PsiMod.get_global_option('BASIS')). # Allow specification of methods to arbitrary order; lowername, level = parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. try:; return procedures['property'][lowername](lowername, **kwargs); except KeyError:; raise ValidationError('Property method %s not available.' % (lowername)). ## Aliases ##; prop = property. [docs]def optimize(name, **kwargs):; r""""""Function to perform a geometry optimization. :aliases: opt(). :returns: (*float*) Total electronic energy of optimized structure in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY <CURRENTENERGY>`. .. note:: Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. .. _`table:grad_gen`:. +-------------------------+---------------------------------------------------------------------------------------+; | name | calls method |; +=========================+=======================================================================================+; | scf | Hartree--Fock (HF) or density functional theory (DFT) |; +-------------------------+---------------------------------------------------------------------------------------+; | dcft | density cumulant functional theory |; +-------------------------+---------------------------------------------------------------------------------------+; | mp2 | 2nd-order Moller-Plesset perturbation theory (MP2) |; +----------------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/driver.html:35295,energy,energy,35295,psi4manual/4.0b3/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/driver.html,2,['energy'],['energy']
Energy Efficiency,"lecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :ref:`Wavefunction<sec:psimod_Wavefunction>`; calculation result as the second element of a tuple. :type bsse_type: string or list; :param bsse_type: ``'cp'`` || ``['nocp', 'vmfc']`` || |dl| ``None`` |dr| || etc. Type of BSSE correction to compute: CP, NoCP, or VMFC. The first in this; list is returned by this function. By default, this function is not called. :type max_nbody: int; :param max_nbody: ``3`` || etc. Maximum n-body to compute, cannot exceed the number of fragments in the moleucle. :type ptype: string; :param ptype: ``'energy'`` || ``'gradient'`` || ``'hessian'``. Type of the procedure passed in. :type return_total_data: :ref:`boolean <op_py_boolean>`; :param return_total_data: ``'on'`` || |dl| ``'off'`` |dr|. If True returns the total data (energy/gradient/etc) of the system,; otherwise returns interaction data.; """""". ### ==> Parse some kwargs <==; kwargs = p4util.kwargs_lower(kwargs); return_wfn = kwargs.pop('return_wfn', False); ptype = kwargs.pop('ptype', None); return_total_data = kwargs.pop('return_total_data', False); molecule = kwargs.pop('molecule', psi4.get_active_molecule()); molecule.update_geometry(); psi4.clean_variables(). if ptype not in ['energy', 'gradient', 'hessian']:; raise ValidationError(""""""N-Body driver: The ptype '%s' is not regonized."""""" % ptype). # Figure out BSSE types; do_cp = False; do_nocp = False; do_vmfc = False; return_method = False. # Must be passed bsse_type; bsse_type_list = kwargs.pop('bsse_type'); if bsse_type_list is None:; raise ValidationError(""N-Body GUFunc: Must pass a bsse_type""); if not isinstance(bsse_type_list, list):; bsse_type_list = [bsse_type_list]. for num, btype in enumerate(bsse_type_list):; if btype.lower() == 'cp':; do_cp = True; if (num == 0): return_method = 'cp'; elif btype.lower() ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver_nbody.html:5252,energy,energy,5252,psi4manual/1.0.0/_modules/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_nbody.html,1,['energy'],['energy']
Energy Efficiency,"lecule; orientation by Cfour. Return qcdb.Molecule and gradient array. """"""; grd = grd.splitlines(); Nat = int(grd[0].split()[0]); molxyz = '%d bohr\n\n' % (Nat). grad = []; for at in range(Nat):; mline = grd[at + 1].split(); el = 'GH' if int(float(mline[0])) == 0 else z2el[int(float(mline[0]))]; molxyz += '%s %16s %16s %16s\n' % (el, mline[-3], mline[-2], mline[-1]); lline = grd[at + 1 + Nat].split(); grad.append([float(lline[-3]), float(lline[-2]), float(lline[-1])]); mol = Molecule.init_with_xyz(molxyz, no_com=True, no_reorient=True, contentsNotFilename=True). return mol, grad. [docs]def harvest_zmat(zmat):; """"""Parses the contents of the Cfour ZMAT file into array and; coordinate information. The coordinate info is converted into a; rather dinky Molecule (no fragment, but does read charge, mult,; unit). Return qcdb.Molecule. Written for findif zmat* where; geometry always Cartesian and Bohr. """"""; zmat = zmat.splitlines()[1:] # skip comment line; Nat = 0; readCoord = True; isBohr = ''; charge = 0; mult = 1; molxyz = ''; cgeom = []; for line in zmat:; if line.strip() == '':; readCoord = False; elif readCoord:; lline = line.split(); molxyz += line + '\n'; Nat += 1; else:; if line.find('CHARGE') > -1:; idx = line.find('CHARGE'); charge = line[idx + 7:]; idxc = charge.find(','); if idxc > -1:; charge = charge[:idxc]; charge = int(charge); if line.find('MULTIPLICITY') > -1:; idx = line.find('MULTIPLICITY'); mult = line[idx + 13:]; idxc = mult.find(','); if idxc > -1:; mult = mult[:idxc]; mult = int(mult); if line.find('UNITS=BOHR') > -1:; isBohr = ' bohr'. molxyz = '%d%s\n%d %d\n' % (Nat, isBohr, charge, mult) + molxyz; mol = Molecule.init_with_xyz(molxyz, no_com=True, no_reorient=True, contentsNotFilename=True). return mol. [docs]def harvest_FCM(fcm):; """"""Parses the contents *fcm* of the Cfour FCMFINAL file into a hessian array. """"""; fcm = fcm.splitlines(); Nat = int(fcm[0].split()[0]); Ndof = int(fcm[0].split()[1]). empty = True; hess = []; for df in range(Ndof):; for",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/cfour.html:25134,charge,charge,25134,psi4manual/1.0.0/_modules/qcdb/cfour.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/cfour.html,1,['charge'],['charge']
Energy Efficiency,"led cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. 1; 2>>> # [1] Coupled-cluster singles and doubles calculation with psi code; >>> energy('ccsd'). 1; 2; 3; 4; 5>>> # [2] Charge-transfer SAPT calculation with scf projection from small into; >>> # requested basis, with specified projection fitting basis; >>> set basis_guess true; >>> set df_basis_guess jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). 1; 2>>> # [3] Arbitrary-order MPn calculation; >>> energy('mp7'). 1; 2; 3; 4; 5; 6; 7; 8; 9>>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> # Note that the integral transformation is not done automatically when detci is run in a separate step.; >>> molecule H2 {\n0 1\nH\nH 1 0.74\n}; >>> set basis cc-pVDZ; >>> set reference rohf; >>> scf_e, scf_wfn = energy('scf', return_wfn=True); >>> H2.set_multiplicity(3); >>> core.MintsHelper(scf_wfn.basisset()).integrals(); >>> energy('detci', ref_wfn=scf_wfn). 1; 2; 3; 4; 5>>> # [5] Run two CI calculations, keeping the integrals generated in the first one.; >>> molecule ne {\nNe\n}; >>> set basis cc-pVDZ; >>> cisd_e, cisd_wfn = energy('cisd', return_wfn=True); >>> energy('fci', ref_wfn=cisd_wfn). 1; 2>>> # [6] Can automatically perform complete basis set extrapolations; >>> energy(""CCSD/cc-pV[DT]Z""). 1; 2; 3; 4>>> # [7] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> energy(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). Navigation. Index. modules    .    .  · ; 1.1;  · . PSI4. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.energy.html:14181,energy,energy,14181,psi4manual/1.1.0/api/psi4.driver.energy.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.energy.html,5,['energy'],['energy']
Energy Efficiency,"led-cluster theory. ThreeCenterOverlapInt; Three center overlap integrals. TracelessQuadrupoleInt; Computes traceless quadrupole integrals. TwoBodyAOInt; Two body integral base class. TwoElectronInt; Computes two-electron repulsion integrals. UHF; docstring. UKSFunctions; docstring. VBase; docstring. Vector; Class for creating and manipulating vectors. Vector3; Class for vectors of length three, often Cartesian coordinate vectors, and their common operations. Wavefunction; docstring. dpdbuf4; docstring. dpdfile2; docstring. psio_entry; docstring. Class Inheritance Diagram¶. psi4.driver Package¶. Functions¶. activate(mol); Function to set molecule object mol as the current active molecule. banner(text[, type, width, strNotOutfile]); Format text into a banner style and print or return it. basis_helper(block[, name, key, set_option]); Helper to specify a custom basis set in PsiAPI mode. cbs(func, label, **kwargs); Function to define a multistage energy method from combinations of basis set extrapolations and delta corrections and condense the components into a minimum number of calculations. compare_fchkfiles(expected, computed, ...); Comparison function for output data in FCHK (formatted checkpoint) file format. compare_fcidumps(expected, computed, label); Comparison function for FCIDUMP files. compare_moldenfiles(expected, computed[, ...]); Comparison function for output data in Molden file format. copy_file_from_scratch(filename, prefix, ...); Move a file out of scratch following the naming convention. copy_file_to_scratch(filename, prefix, ...); Move a file into scratch following the naming convention. create_plugin(name, template). cubeprop(wfn, **kwargs); Evaluate properties on a grid and generate cube files. docs_table_link(name, mode); Compose a link to mode documentation table. dynamic_variable_bind(cls); Function to dynamically add extra members to the core.Molecule class. energies_from_fcidump(intdump); From integrals dictionary generated from fcidump_from_fi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/psi4api.html:16084,energy,energy,16084,psi4manual/master/psi4api.html,https://psicode.org,https://psicode.org/psi4manual/master/psi4api.html,1,['energy'],['energy']
Energy Efficiency,"led-cluster theory. ThreeCenterOverlapInt; Three center overlap integrals. TracelessQuadrupoleInt; Computes traceless quadrupole integrals. TwoBodyAOInt; Two body integral base class. TwoElectronInt; Computes two-electron repulsion integrals. UHF; docstring. UKSFunctions; docstring. VBase; docstring. Vector; Class for creating and manipulating vectors. Vector3; Class for vectors of length three, often Cartesian coordinate vectors, and their common operations. Wavefunction; docstring. dpdbuf4; docstring. dpdfile2; docstring. psio_entry; docstring. Class Inheritance Diagram¶. psi4.driver Package¶. Functions¶. activate(mol); Function to set molecule object mol as the current active molecule. banner(text[, type, width, strNotOutfile]); Format text into a banner style and print or return it. basis_helper(block[, name, key, set_option]); Helper to specify a custom basis set in PsiAPI mode. cbs(func, label, **kwargs); Function to define a multistage energy method from combinations of basis set extrapolations and delta corrections and condense the components into a minimum number of calculations. compare_fchkfiles(expected, computed, ...); Comparison function for output data in FCHK (formatted checkpoint) file format. compare_fcidumps(expected, computed, label); Comparison function for FCIDUMP files. compare_moldenfiles(expected, computed[, ...]); Comparison function for output data in Molden file format. copy_file_from_scratch(filename, prefix, ...); Move a file out of scratch following the naming convention. copy_file_to_scratch(filename, prefix, ...); Move a file into scratch following the naming convention. create_plugin(name, template). rtype:; None. cubeprop(wfn, **kwargs); Evaluate properties on a grid and generate cube files. docs_table_link(name, mode); Compose a link to mode documentation table. dynamic_variable_bind(cls); Function to dynamically add extra members to the core.Molecule class. energies_from_fcidump(intdump); From integrals dictionary generated from f",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/psi4api.html:16073,energy,energy,16073,psi4manual/1.7.x/psi4api.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/psi4api.html,3,['energy'],['energy']
Energy Efficiency,"left-hand term in Eq. (2). (2)¶\[E_{\text{MP4}} = E_{\text{MP4(SDQ)}} + E_{\text{MP4(T)}}\]. MPn TOTAL ENERGY¶. MPn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled Møller–Plesset perturbation theory level.; n is MP perturbation order. NUCLEAR REPULSION ENERGY¶; The nuclear repulsion energy contribution [H] to the total SCF energy.; Quantity \(E_{NN}\) in Eq. (4). (3)¶\[E_{NN} = \sum_{i, j<i}^{N_{atom}}\frac{Z_i Z_j}{|\mathbf{R}_i - \mathbf{R}_j|}\]. NBODY (i, j, ..., k)@(a, b, ..., c) TOTAL ENERGY¶; The total energy [Eh] of a component of the requested N-Body energy.; The first parenthetical list over i, j, …, k enumerates; molecular fragments included in the computation in 1-indexed,; input-file order, while the second enumerates list over a, b,; …, c enumerates which fragments contribute basis functions to the; computation. For example, (1, 2)@(1, 2, 3, 4) indicates that the; fragments 1 and 2 are explicitly included in the energy computation,; with basis functions from each of fragments 1, 2, 3, & 4 included in; the basis set. Therefore, the basis functions from fragments 3 and 4; are included as ghost functions within the energy computation. OCEPA(0) TOTAL ENERGY¶. OCEPA(0) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the orbital-optimized CEPA(0) level of theory. OMP2 TOTAL ENERGY¶. OMP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the orbital-optimized MP2 level of theory. OMP3 TOTAL ENERGY¶. OMP3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the orbital-optimized MP3 level of theory. ONE-ELECTRON ENERGY¶; The one-electron energy contribution [H] to the total SCF energy.; Quantity \(E_{1e^-}\) in Eq. (4). QCISD TOTAL ENERGY¶. QCISD CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the quadratic configuration int",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/glossary_psivariables-1.html:16698,energy,energy,16698,psi4manual/1.2.1/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/glossary_psivariables-1.html,4,['energy'],['energy']
Energy Efficiency,"len(atoms)). def calculate_force(self, pos=None, **kwargs):; """"""Fetch force, energy of PSI. Arguments:; - pos: positions of the atoms as array. If None, the positions of the current active; molecule is used.; """"""; if pos is None:; molecule = psi4.core.get_active_molecule(); pos = np.array(molecule.geometry()). self._force, self._potential = self.callback(pos, **kwargs); return self._force, self._potential. def callback(self, pos, **kwargs):; """"""Initialize psi with new positions and calculate force. Arguments:; - pos: positions of the atoms as array.; """""". self.initial_molecule.set_geometry(psi4.core.Matrix.from_array(pos)). self.calculate_gradient(self.LOT, pos=pos, **kwargs). self._potential = psi4.variable('CURRENT ENERGY'); self._force = -np.array(self.grd); self._vir = np.array([[0.0,0.0,0.0],[0.0,0.0,0.0],[0.0,0.0,0.0]]). return self._force, np.float64(self._potential). def calculate_gradient(self, LOT, bypass_scf=False, **kwargs):; """"""Calculate the gradient with @LOT. When bypass_scf=True a hf energy calculation has been done before.; """"""; start = time.time(); self.grd = psi4.gradient(LOT, bypass_scf=bypass_scf, **kwargs); time_needed = time.time() - start; self.timing[LOT] = self.timing.get(LOT, []) + [time_needed]. [docs]def ipi_broker(LOT, molecule=None, serverdata=False, options=None):; """""" Run IPIBroker to connect to i-pi. Arguments:; molecule: Initial molecule; serverdata: Configuration where to connect to ipi; options: any additional Psi4 options; """"""; b = IPIBroker(LOT, molecule=molecule, serverdata=serverdata, options=options). try:; if b.serverdata:; b.run(); else:; return b. except KeyboardInterrupt:; psi4.core.print_out(""Killing IPIBroker\n""); b.__del__() # lgtm [py/explicit-call-to-delete]; sys.exit(1). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.4;  · . PSI4. Module code; psi4.driver.ipi_broker. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/ipi_broker.html:3856,energy,energy,3856,psi4manual/1.4.0/_modules/psi4/driver/ipi_broker.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/ipi_broker.html,2,['energy'],['energy']
Energy Efficiency,"len(atoms)). def calculate_force(self, pos=None, **kwargs):; """"""Fetch force, energy of PSI. Arguments:; - pos: positions of the atoms as array. If None, the positions of the current active; molecule is used.; """"""; if pos is None:; molecule = psi4.core.get_active_molecule(); pos = np.array(molecule.geometry()). self._force, self._potential = self.callback(pos, **kwargs); return self._force, self._potential. def callback(self, pos, **kwargs):; """"""Initialize psi with new positions and calculate force. Arguments:; - pos: positions of the atoms as array.; """""". self.initial_molecule.set_geometry(psi4.core.Matrix.from_array(pos)). self.calculate_gradient(self.LOT, pos=pos, **kwargs). self._potential = psi4.variable('CURRENT ENERGY'); self._force = -np.array(self.grd); self._vir = np.array([[0.0,0.0,0.0],[0.0,0.0,0.0],[0.0,0.0,0.0]]). return self._force, np.float64(self._potential). def calculate_gradient(self, LOT, bypass_scf=False, **kwargs):; """"""Calculate the gradient with @LOT. When bypass_scf=True a hf energy calculation has been done before.; """"""; start = time.time(); self.grd = psi4.gradient(LOT, bypass_scf=bypass_scf, **kwargs); time_needed = time.time() - start; self.timing[LOT] = self.timing.get(LOT, []) + [time_needed]. [docs]def ipi_broker(LOT, molecule=None, serverdata=False, options=None):; """""" Run IPIBroker to connect to i-pi. Arguments:; molecule: Initial molecule; serverdata: Configuration where to connect to ipi; options: any additional Psi4 options; """"""; b = IPIBroker(LOT, molecule=molecule, serverdata=serverdata, options=options). try:; if b.serverdata:; b.run(); else:; return b. except KeyboardInterrupt:; psi4.core.print_out(""Killing IPIBroker\n""); b.__del__() # lgtm [py/explicit-call-to-delete]; sys.exit(1). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.5;  · . PSI4. Module code; psi4.driver.ipi_broker. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2021 02:41AM.; Created using Sphinx 4.3.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/ipi_broker.html:3856,energy,energy,3856,psi4manual/1.5.0/_modules/psi4/driver/ipi_broker.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/ipi_broker.html,2,['energy'],['energy']
Energy Efficiency,"len-style Focal; Point Analysis. JCP 127 014306, https://doi.org/10.1063/1.2747241 .; Uses the composite wrapper to evaluate the following; expression. SCF employs a three-point extrapolation according; to scf_xtpl_helgaker_3(). MP2, CCSD, and; CCSD(T) employ two-point extrapolation performed according to; corl_xtpl_helgaker_2(). CCSDT and CCSDT(Q); are plain deltas. This wrapper requires Kallay’s MRCC code.; :rtype: List[Dict[str, Any]]. \[E_{total}^{\text{FPA}} = E_{total,\; \text{SCF}}^{\text{cc-pV[Q56]Z}} \; + E_{corl,\; \text{MP2}}^{\text{cc-pV[56]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD}}\big\vert_{\text{cc-pV[56]Z}} \; + \delta_{\text{CCSD}}^{\text{CCSD(T)}}\big\vert_{\text{cc-pV[56]Z}} \; + \delta_{\text{CCSD(T)}}^{\text{CCSDT}}\big\vert_{\text{cc-pVTZ}} \; + \delta_{\text{CCSDT}}^{\text{CCSDT(Q)}}\big\vert_{\text{cc-pVDZ}}\]; >>> # [1] single-point energy by this composite method; >>> energy('allen_focal_point'). >>> # [2] single-point energy reducing the Hartree-Fock basis sets size; >>> energy('allen_focal_point', scf_basis='cc-pV[TQ5]Z'). Return type:; List[Dict[str, Any]]. Additional composite aliases are easy to define by the; user. Follow models in psi4/psi4/driver/aliases.py; and cbs-xtpl-nbody and use the; psi4.driver.driver_cbs_helper.register_composite_function(); to make user-defined functions known to PSI4. psi4.driver.driver_cbs_helper.register_composite_function(func)[source]¶; Register a user-defined composite method function to use like a built-in one. Parameters:; func (Callable) – A Python function that defines a configuration of the psi4.driver.cbs() wrapper.; See psi4/psi4/driver/aliases.py and cbs-xtpl-nbody for examples. API¶. pydantic model psi4.driver.driver_cbs.CompositeComputer[source]¶. Show JSON schema{; ""title"": ""CompositeComputer"",; ""description"": ""Base class for \""computers\"" that plan, run, and process QC tasks."",; ""type"": ""object"",; ""properties"": {; ""molecule"": {; ""title"": ""Molecule""; },; ""basis"": {; ""title"": ""Basis"",; ""defau",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/cbs.html:32368,energy,energy,32368,psi4manual/1.8.x/cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/cbs.html,6,['energy'],['energy']
Energy Efficiency,"lene*acetylene).; # Test case 16 from S22 Database. dimer = psi4.geometry(""""""; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.923621 1.232253 -2.126185; --; 0 1; C 0.000000 0.000000 2.900503; C 0.000000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; units angstrom; """"""). Here’s the second half of the input, where we specify the computation; options:. In [8]:. psi4.set_options({'scf_type': 'df',; 'freeze_core': 'true'}). psi4.energy('sapt0/jun-cc-pvdz', molecule=dimer). Out[8]:. -0.0022355825227244703. All of the options we have currently set using psi4.set_options(); API; are “global” options (meaning that they are visible to all parts of the; program). Most common Psi4 options can be set like this. If an option; needs to be visible only to one part of the program (e.g., we only; want to increase the energy convergence in the SCF code, but not the; rest of the code), it can be set by with the; psi4.set_module_options(); API; function, psi4.set_module_options('scf', {'e_convergence': '1e-8'}).; Note: The arguments to the functions we’ve used so far, like; psi4.set_options(); API,; psi4.set_module_options(); API,; psi4.energy(); API,; psi4.optimize(); API,; psi4.frequency(); API,; etc., are case-insensitive.; Back to our SAPT example, we have found that for basic-level SAPT; computations (i.e., SAPT0), a good error cancellation is found; (Hohenstein:2012:WIREs); with the jun-cc-pVDZ basis (this is the usual aug-cc-pVDZ basis, but; without diffuse functions on hydrogen and without diffuse \(d\); functions on heavy atoms); (Papajak:2011:10).; So, we’ll use that as our standard basis set. The SAPT code is designed; to use density fitting techniques, because they introduce minimal errors; while providing much faster computations; (Hohenstein:2010:184111,Hohenstein:2010:014101).; Since we’re using density fitting for the ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psiapi-1.html:13030,energy,energy,13030,psi4manual/1.1.0/psiapi-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psiapi-1.html,4,['energy'],['energy']
Energy Efficiency,"length restriction). I’m aiming for files to pass the line below, unless for good reason. The second line is for database Python files.; >>> pep8.py -r --ignore=E501 pythonfile.py; >>> pep8.py -r --ignore=E501,E221,E222,E241,E201,E202 databasefile.py. Your python function should not prevent any test case (make tests, NOT make longtests) from passing. A test case(s) should be written and checked in for any major python function, so that others do not break your code. If most of your work was on the python (as opposed to c++) side, the test case prefix pywrap_ is suggested. Be sure to set any new PSI variables through lines like those below. Especially if the function returns an energy, set the ‘current energy’ variable. This last is needed to communicate with the optimizer.; psi4.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25); psi4.set_variable('MP2.5 TOTAL ENERGY', e_mp25); psi4.set_variable('CURRENT ENERGY', e_mp25). Once your python function is fairly stable on its own, it’s potential for interoperability with energy()/opt()/cp()/db()/cbs()/etc. should be evaluated. If it makes physical sense that it should work, you should strive to make that interoperability a reality. Some steps:. If any interoperability is possible, define an argument xx_func, where xx is a short name for your function. Add near the top of your function code like the below (less the final two lines). The net result of this code is that if the user specifies no *_func arguments, then energy() gets called. If the user defines xx_func, then its value gets called. If the user defines func, then its value gets reassigned to xx_func, func itself is deleted, and xx_func() gets called. Whatever is getting called is stored in func within the function.; # Establish function to call; if not('xx_func' in kwargs):; if ('func' in kwargs):; kwargs['xx_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['xx_func'] = energy; func = kwargs['xx_func']; if not func:; raise ValidationError('Function \'%s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/bestpractices_py-1.html:4589,energy,energy,4589,psi4manual/4.0b5/bestpractices_py-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/bestpractices_py-1.html,2,['energy'],['energy']
Energy Efficiency,length_displacement_law_constant; 0.0028977729; Wien wavelength displacement law constant [m K] uncertainty=0.000 0017 e-3. calorie_joule_relationship; 4.184; calorie-joule relationship [J] uncertainty=(exact). h; 6.626070040E-34; h [J] The Planck constant (Js). c; 299792458; c [Hz] Speed of light (ms$^{-1}$). kb; 1.38064852E-23; kb [J] The Boltzmann constant (JK$^{-1}$). R; 8.3144598; R [J mol^-1 K^-1] Universal gas constant (JK$^{-1}$mol$^{-1}$). bohr2angstroms; 0.52917721067; bohr2angstroms [AA] Bohr to Angstroms conversion factor. bohr2m; 5.2917721067E-11; bohr2m [m] Bohr to meters conversion factor. bohr2cm; 5.291772106700E-9; bohr2cm [cm] Bohr to centimeters conversion factor. amu2g; 1.660539040000E-24; amu2g [g] Atomic mass units to grams conversion factor. amu2kg; 1.660539040E-27; amu2kg [kg] Atomic mass units to kg conversion factor. au2amu; 0.000548579909070; au2amu [u] Atomic units (m$@@e$) to atomic mass units conversion factor. hartree2J; 4.359744650E-18; hartree2J [J] Hartree to joule conversion factor. hartree2aJ; 4.359744650; hartree2aJ [aJ] Hartree to attojoule (10$^{-18}$J) conversion factor. cal2J; 4.184; cal2J [J] Calorie to joule conversion factor. dipmom_au2si; 8.478353552E-30; dipmom_au2si [C m] Atomic units to SI units (Cm) conversion factor for dipoles. dipmom_au2debye; 2.541746451895025916414946904; dipmom_au2debye [???] Atomic units to Debye conversion factor for dipoles. dipmom_debye2si; 3.335640951E-30; dipmom_debye2si [???] Debye to SI units (Cm) conversion factor for dipoles. c_au; 137.035999139; c_au [] Speed of light in atomic units. hartree2ev; 27.21138602; hartree2ev [eV] Hartree to eV conversion factor. hartree2wavenumbers; 219474.6313702; hartree2wavenumbers [cm^-1] Hartree to cm$^{-1}$ conversion factor. hartree2kcalmol; 627.5094737775374055927342256; hartree2kcalmol [kcal mol^-1] Hartree to kcal mol$^{-1}$ conversion factor. hartree2kJmol; 2625.4996382852165050; hartree2kJmol [kJ mol^-1] Hartree to kilojoule mol$^{-1}$ conversi,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodoc_physconst-1.html:37735,joule,joule,37735,psi4manual/1.3.2/autodoc_physconst-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodoc_physconst-1.html,11,['joule'],['joule']
Energy Efficiency,"lenum = int(filenum); except ValueError:; filenum = 32 # Default file number is the checkpoint one; psioh = core.IOManager.shared_object(); psio = core.IO.shared_object(); filepath = psioh.get_file_path(filenum); namespace = psio.get_default_namespace(); pid = str(os.getpid()); prefix = 'psi'; targetfile = filepath + prefix + '.' + pid + '.' + namespace + '.' + str(filenum); core.print_out(f"" \n Copying restart file <{item}> to <{targetfile}> for internal processing\n""); shutil.copy(item, targetfile). logger.info(f""Compute energy(): method={lowername}, basis={core.get_global_option('BASIS').lower()}, molecule={molecule.name()}, nre={'w/EFP' if hasattr(molecule, 'EFP') else molecule.nuclear_repulsion_energy()}""); logger.debug(""w/EFP"" if hasattr(molecule, ""EFP"") else pp.pformat(molecule.to_dict())); wfn = procedures['energy'][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return energy(): {core.variable('CURRENT ENERGY')}""). for postcallback in hooks['energy']['post']:; postcallback(lowername, wfn=wfn, **kwargs). basisstash.restore(); optstash.restore(); optstash2.restore(). if return_wfn: # TODO current energy safer than wfn.energy() for now, but should be revisited. # TODO place this with the associated call, very awkward to call this in other areas at the moment; if lowername in ['efp', 'mrcc', 'dmrg']:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the incoming reference wavefunction.\n\n""); elif 'sapt' in lowername:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the dimer SCF wavefunction.\n\n""). return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]; def gradient(name, **kwargs):; r""""""Function complementary to :py:func:`~psi4.driver.optimize()`. Carries out one gradient pass,; deciding analytic or finite difference. :re",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:40818,energy,energy,40818,psi4manual/1.8.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html,6,['energy'],['energy']
Energy Efficiency,"lenum = int(filenum); except ValueError:; filenum = 32 # Default file number is the checkpoint one; psioh = core.IOManager.shared_object(); psio = core.IO.shared_object(); filepath = psioh.get_file_path(filenum); namespace = psio.get_default_namespace(); pid = str(os.getpid()); prefix = 'psi'; targetfile = filepath + prefix + '.' + pid + '.' + namespace + '.' + str(filenum); core.print_out(f"" \n Copying restart file <{item}> to <{targetfile}> for internal processing\n""); shutil.copy(item, targetfile). logger.info(f""Compute energy(): method={lowername}, basis={core.get_global_option('BASIS').lower()}, molecule={molecule.name()}, nre={'w/EFP' if hasattr(molecule, 'EFP') else molecule.nuclear_repulsion_energy()}""); logger.debug(""w/EFP"" if hasattr(molecule, ""EFP"") else pp.pformat(molecule.to_dict())); wfn = procedures['energy'][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return energy(): {core.variable('CURRENT ENERGY')}""). for postcallback in hooks['energy']['post']:; postcallback(lowername, wfn=wfn, **kwargs). basisstash.restore(); optstash.restore(); optstash2.restore(). if return_wfn: # TODO current energy safer than wfn.energy() for now, but should be revisited. # TODO place this with the associated call, very awkward to call this in other areas at the moment; if lowername in ['efp', 'mrcc', 'dmrg']:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the incoming reference wavefunction.\n\n""); elif 'sapt' in lowername:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the dimer SCF wavefunction.\n\n""). return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]def gradient(name, **kwargs):; r""""""Function complementary to :py:func:`~psi4.driver.optimize()`. Carries out one gradient pass,; deciding analytic or finite difference. :retu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html:40814,energy,energy,40814,psi4manual/1.7.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html,2,['energy'],['energy']
Energy Efficiency,"lenum = int(filenum); except ValueError:; filenum = 32 # Default file number is the checkpoint one; psioh = core.IOManager.shared_object(); psio = core.IO.shared_object(); filepath = psioh.get_file_path(filenum); namespace = psio.get_default_namespace(); pid = str(os.getpid()); prefix = 'psi'; targetfile = filepath + prefix + '.' + pid + '.' + namespace + '.' + str(filenum); core.print_out(f"" \n Copying restart file <{item}> to <{targetfile}> for internal processing\n""); shutil.copy(item, targetfile). logger.info(f""Compute energy(): method={lowername}, basis={core.get_global_option('BASIS').lower()}, molecule={molecule.name()}, nre={'w/EFP' if hasattr(molecule, 'EFP') else molecule.nuclear_repulsion_energy()}""); logger.debug(""w/EFP"" if hasattr(molecule, ""EFP"") else pp.pformat(molecule.to_dict())); wfn = procedures['energy'][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return energy(): {core.variable('CURRENT ENERGY')}""). for postcallback in hooks['energy']['post']:; postcallback(lowername, wfn=wfn, **kwargs). basisstash.restore(); optstash.restore(); optstash2.restore(). if return_wfn: # TODO current energy safer than wfn.energy() for now, but should be revisited. # TODO place this with the associated call, very awkward to call this in other areas at the moment; if lowername in ['efp', 'mrcc', 'dmrg']:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the incoming reference wavefunction.\n\n""); elif 'sapt' in lowername:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the dimer SCF wavefunction.\n\n""). return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]def gradient(name, **kwargs):; r""""""Function complementary to :py:func:`~psi4.optimize()`. Carries out one gradient pass,; deciding analytic or finite difference. :returns: :p",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html:33984,energy,energy,33984,psi4manual/1.6.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html,2,['energy'],['energy']
Energy Efficiency,"ler than this value DIIS starts. Type: double; Default: 1e-2. DMRG_SCF_GRAD_THR¶. The density RMS convergence to stop an instruction during successive DMRG instructions. Type: double; Default: 1.e-6. DMRG_SCF_MAX_ITER¶. Maximum number of DMRG iterations. Type: integer; Default: 100. DMRG_SCF_STATE_AVG¶. Whether or not to use state-averaging for roots >=2 with DMRG-SCF. Type: boolean; Default: true. DMRG_SWEEP_DVDSON_RTOL¶. The residual tolerances for the Davidson diagonalization during DMRG instructions. Type: array; Default: No Default. DMRG_SWEEP_ENERGY_CONV¶. The energy convergence to stop an instruction during successive DMRG instructions. Type: array; Default: No Default. DMRG_SWEEP_MAX_SWEEPS¶. The maximum number of sweeps to stop an instruction during successive DMRG instructions. Type: array; Default: No Default. DMRG_SWEEP_NOISE_PREFAC¶. The noise prefactors for successive DMRG instructions. Type: array; Default: No Default. DMRG_SWEEP_STATES¶. The number of reduced renormalized basis states to be retained during successive DMRG instructions. Type: array; Default: No Default. DMRG_UNITARY_WRITE¶. Whether or not to store the unitary on disk (convenient for restarting). Type: boolean; Default: true. table of contents. DMRG; General; DMRG_CASPT2_CALC; DMRG_CASPT2_IMAG; DMRG_CASPT2_IPEA; DMRG_CASPT2_ORBS; DMRG_DIIS; DMRG_DIIS_WRITE; DMRG_EXCITATION; DMRG_IRREP; DMRG_LOCAL_INIT; DMRG_MOLDEN_WRITE; DMRG_MPS_WRITE; DMRG_MULTIPLICITY; DMRG_OPDM_AO_PRINT; DMRG_PRINT_CORR; DMRG_SCF_ACTIVE_SPACE; DMRG_SCF_DIIS_THR; DMRG_SCF_GRAD_THR; DMRG_SCF_MAX_ITER; DMRG_SCF_STATE_AVG; DMRG_SWEEP_DVDSON_RTOL; DMRG_SWEEP_ENERGY_CONV; DMRG_SWEEP_MAX_SWEEPS; DMRG_SWEEP_NOISE_PREFAC; DMRG_SWEEP_STATES; DMRG_UNITARY_WRITE. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Appendices; Keywords by Module; DMRG. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodir_options_c/module__dmrg.html:3430,reduce,reduced,3430,psi4manual/1.8.x/autodir_options_c/module__dmrg.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodir_options_c/module__dmrg.html,2,['reduce'],['reduced']
Energy Efficiency,"ler than this value DIIS starts. Type: double; Default: 1e-2. DMRG_SCF_GRAD_THR¶. The density RMS convergence to stop an instruction during successive DMRG instructions. Type: double; Default: 1.e-6. DMRG_SCF_MAX_ITER¶. Maximum number of DMRG iterations. Type: integer; Default: 100. DMRG_SCF_STATE_AVG¶. Whether or not to use state-averaging for roots >=2 with DMRG-SCF. Type: boolean; Default: true. DMRG_SWEEP_DVDSON_RTOL¶. The residual tolerances for the Davidson diagonalization during DMRG instructions. Type: array; Default: No Default. DMRG_SWEEP_ENERGY_CONV¶. The energy convergence to stop an instruction during successive DMRG instructions. Type: array; Default: No Default. DMRG_SWEEP_MAX_SWEEPS¶. The maximum number of sweeps to stop an instruction during successive DMRG instructions. Type: array; Default: No Default. DMRG_SWEEP_NOISE_PREFAC¶. The noise prefactors for successive DMRG instructions. Type: array; Default: No Default. DMRG_SWEEP_STATES¶. The number of reduced renormalized basis states to be retained during successive DMRG instructions. Type: array; Default: No Default. DMRG_UNITARY_WRITE¶. Whether or not to store the unitary on disk (convenient for restarting). Type: boolean; Default: true. table of contents. DMRG; General; DMRG_CASPT2_CALC; DMRG_CASPT2_IMAG; DMRG_CASPT2_IPEA; DMRG_CASPT2_ORBS; DMRG_DIIS; DMRG_DIIS_WRITE; DMRG_EXCITATION; DMRG_IRREP; DMRG_LOCAL_INIT; DMRG_MOLDEN_WRITE; DMRG_MPS_WRITE; DMRG_MULTIPLICITY; DMRG_OPDM_AO_PRINT; DMRG_PRINT_CORR; DMRG_SCF_ACTIVE_SPACE; DMRG_SCF_DIIS_THR; DMRG_SCF_GRAD_THR; DMRG_SCF_MAX_ITER; DMRG_SCF_STATE_AVG; DMRG_SWEEP_DVDSON_RTOL; DMRG_SWEEP_ENERGY_CONV; DMRG_SWEEP_MAX_SWEEPS; DMRG_SWEEP_NOISE_PREFAC; DMRG_SWEEP_STATES; DMRG_UNITARY_WRITE. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Appendices; Keywords by Module; DMRG. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/autodir_options_c/module__dmrg.html:3430,reduce,reduced,3430,psi4manual/1.9.x/autodir_options_c/module__dmrg.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/autodir_options_c/module__dmrg.html,2,['reduce'],['reduced']
Energy Efficiency,"ler–Plesset Perturbation Theory) interaction energies for dimer molecules.; The plugin is distributed under the 2-clause BSD license. Installation¶; Binary. snsmp2 is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell).; If using the Psi4conda installer, snsmp2 has already been installed alongside.; If using the PSI4 conda package, the snsmp2 conda package can; be obtained through conda install snsmp2 -c psi4 or conda install; psi4-rt -c psi4.; If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; snsmp2 can be obtained through conda install snsmp2 -c psi4.; Then, hint its location with PYTHONPATH.; To remove a conda installation, conda remove snsmp2. Source. Download the plugin from the GitHub repository:; >>> git clone https://github.com/DEShawResearch/sns-mp2. Once dowloaded, the plugin can be installed as outlined in the documentation:; >>> cd {top-level-sns-mp2-directory}; >>> PSI4_PYTHON=$(head $(which psi4) -n 1 | sed -r 's/^.{2}//'); >>> $PSI4_PYTHON -m pip install . Sample Input¶; A sample input file, adapted from the documentation, is shown below:; # Sample SNS-MP2 calculation for two helium atoms. molecule dimer {; He 0 0 0; --; He 2 0 0; }. energy('sns-mp2'). Note that the two monomers are separated by double dashes, indicating that; they should be treated as separate molecules. (See; Analysis of Intermolecular Interactions for more details on; setting up dimer molecules.) This input file can be run in the usual fashion:; >>> psi4 input.dat. table of contents. Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw; Installation; Sample Input. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/plugin_snsmp2.html:1687,adapt,adapted,1687,psi4manual/1.7.x/plugin_snsmp2.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/plugin_snsmp2.html,2,"['adapt', 'energy']","['adapted', 'energy']"
Energy Efficiency,"les (bool, optional) – If True, also return fragments as list of Molecules.; return_molecule (bool, optional) – If True, also return one big Molecule with fragmentation encoded. Returns:; bfs_map (list of lists) – Array of atom indices (0-indexed) of detected fragments.; bfs_arrays (tuple of lists of ndarray, optional) – geom, mass, elem info per-fragment.; Only provided if return_arrays is True.; bfs_molecules (list of qcdb.Molecule or psi4.core.Molecule, optional) – List of molecules, each built from one fragment. Center and; orientation of fragments is fixed so orientation info from self is; not lost. Loses chgmult and ghost/dummy info from self and contains; default chgmult.; Only provided if return_molecules is True.; Returned are of same type as self.; bfs_molecule (qcdb.Molecule or psi4.core.Molecule, optional) – Single molecule with same number of real atoms as self with atoms; reordered into adjacent fragments and fragment markers inserted.; Loses ghost/dummy info from self; keeps total charge but not total mult.; Only provided if return_molecule is True.; Returned is of same type as self. Notes. Relies upon van der Waals radii and so faulty for close (especially; hydrogen-bonded) fragments. See seed_atoms. Any existing fragmentation info/chgmult encoded in self is lost.; Original code from Michael S. Marshall, linear-scaling algorithm from; Trent M. Parker, revamped by Lori A. Burns. Z(self: psi4.core.Molecule, arg0: int) → float; Nuclear charge of atom arg0 (0-indexed without dummies). activate_all_fragments(self: psi4.core.Molecule) → None; Sets all fragments in the molecule to be active. add_atom(self: psi4.core.Molecule, Z: float, x: float, y: float, z: float, symbol: str, mass: float, charge: float, label: str, A: int) → None; Adds to self Molecule an atom with atomic number Z, Cartesian coordinates in Bohr (x, y, z), atomic symbol, mass, and charge, extended atomic label, and mass number A. atom_at_position(*args, **kwargs); Overloaded function. atom",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.molecule.html:40676,charge,charge,40676,psi4manual/1.3.2/api/psi4.core.molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.molecule.html,1,['charge'],['charge']
Energy Efficiency,"les (bool, optional) – If True, also return fragments as list of Molecules.; return_molecule (bool, optional) – If True, also return one big Molecule with fragmentation encoded. Returns:; bfs_map (list of lists) – Array of atom indices (0-indexed) of detected fragments.; bfs_arrays (tuple of lists of ndarray, optional) – geom, mass, elem info per-fragment.; Only provided if return_arrays is True.; bfs_molecules (list of qcdb.Molecule or psi4.core.Molecule, optional) – List of molecules, each built from one fragment. Center and; orientation of fragments is fixed so orientation info from self is; not lost. Loses chgmult and ghost/dummy info from self and contains; default chgmult.; Only provided if return_molecules is True.; Returned are of same type as self.; bfs_molecule (qcdb.Molecule or psi4.core.Molecule, optional) – Single molecule with same number of real atoms as self with atoms; reordered into adjacent fragments and fragment markers inserted.; Loses ghost/dummy info from self; keeps total charge but not total mult.; Only provided if return_molecule is True.; Returned is of same type as self. Notes. Relies upon van der Waals radii and so faulty for close (especially; hydrogen-bonded) fragments. See seed_atoms. Any existing fragmentation info/chgmult encoded in self is lost.; Original code from Michael S. Marshall, linear-scaling algorithm from; Trent M. Parker, revamped by Lori A. Burns. Z(self: psi4.core.Molecule, arg0: int) → float; Nuclear charge of atom. activate_all_fragments(self: psi4.core.Molecule) → None; Sets all fragments in the molecule to be active. add_atom(self: psi4.core.Molecule, arg0: float, arg1: float, arg2: float, arg3: float, arg4: str, arg5: float, arg6: float, arg7: str, arg8: int) → None; Adds to Molecule arg1 an atom with atomic number arg2, Cartesian coordinates in Bohr (arg3, arg4, arg5), atomic symbol arg6, mass arg7, charge arg8 (optional), and lineno arg9 (optional). atom_at_position(self: psi4.core.Molecule, arg0: float, arg1: f",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/api/psi4.core.molecule.html:36821,charge,charge,36821,psi4manual/1.2.1/api/psi4.core.molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/api/psi4.core.molecule.html,1,['charge'],['charge']
Energy Efficiency,"les (bool, optional) – If True, also return fragments as list of Molecules.; return_molecule (bool, optional) – If True, also return one big Molecule with fragmentation encoded. Returns:; bfs_map (list of lists) – Array of atom indices (0-indexed) of detected fragments.; bfs_arrays (tuple of lists of ndarray, optional) – geom, mass, elem info per-fragment.; Only provided if return_arrays is True.; bfs_molecules (list of qcdb.Molecule or psi4.core.Molecule, optional) – List of molecules, each built from one fragment. Center and; orientation of fragments is fixed so orientation info from self is; not lost. Loses chgmult and ghost/dummy info from self and contains; default chgmult.; Only provided if return_molecules is True.; Returned are of same type as self.; bfs_molecule (qcdb.Molecule or psi4.core.Molecule, optional) – Single molecule with same number of real atoms as self with atoms; reordered into adjacent fragments and fragment markers inserted.; Loses ghost/dummy info from self; keeps total charge but not total mult.; Only provided if return_molecule is True.; Returned is of same type as self. Notes. Relies upon van der Waals radii and so faulty for close (especially; hydrogen-bonded) fragments. See seed_atoms. Any existing fragmentation info/chgmult encoded in self is lost.; Original code from Michael S. Marshall, linear-scaling algorithm from; Trent M. Parker, revamped by Lori A. Burns. Z(self: psi4.core.Molecule, arg0: int) → float¶; Nuclear charge of atom arg0 (0-indexed without dummies). activate_all_fragments(self: psi4.core.Molecule) → None¶; Sets all fragments in the molecule to be active. add_atom(self: psi4.core.Molecule, Z: float, x: float, y: float, z: float, symbol: str, mass: float, charge: float, label: str, A: int) → None¶; Adds to self Molecule an atom with atomic number Z, Cartesian coordinates in Bohr (x, y, z), atomic symbol, mass, and charge, extended atomic label, and mass number A. atom_at_position(*args, **kwargs)¶; Overloaded function. ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.molecule.html:14922,charge,charge,14922,psi4manual/1.3.2/api/psi4.core.molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.molecule.html,3,['charge'],['charge']
Energy Efficiency,"les (bool, optional) – If True, also return fragments as list of Molecules.; return_molecule (bool, optional) – If True, also return one big Molecule with fragmentation encoded. Returns:; bfs_map (list of lists) – Array of atom indices (0-indexed) of detected fragments.; bfs_arrays (tuple of lists of ndarray, optional) – geom, mass, elem info per-fragment.; Only provided if return_arrays is True.; bfs_molecules (list of qcdb.Molecule or psi4.core.Molecule, optional) – List of molecules, each built from one fragment. Center and; orientation of fragments is fixed so orientation info from self is; not lost. Loses chgmult and ghost/dummy info from self and contains; default chgmult.; Only provided if return_molecules is True.; Returned are of same type as self.; bfs_molecule (qcdb.Molecule or psi4.core.Molecule, optional) – Single molecule with same number of real atoms as self with atoms; reordered into adjacent fragments and fragment markers inserted.; Loses ghost/dummy info from self; keeps total charge but not total mult.; Only provided if return_molecule is True.; Returned is of same type as self. Notes. Relies upon van der Waals radii and so faulty for close (especially; hydrogen-bonded) fragments. See seed_atoms. Any existing fragmentation info/chgmult encoded in self is lost.; Original code from Michael S. Marshall, linear-scaling algorithm from; Trent M. Parker, revamped by Lori A. Burns. Z(self: psi4.core.Molecule, arg0: int) → float¶; Nuclear charge of atom. activate_all_fragments(self: psi4.core.Molecule) → None¶; Sets all fragments in the molecule to be active. add_atom(self: psi4.core.Molecule, arg0: float, arg1: float, arg2: float, arg3: float, arg4: str, arg5: float, arg6: float, arg7: str, arg8: int) → None¶; Adds to Molecule arg1 an atom with atomic number arg2, Cartesian coordinates in Bohr (arg3, arg4, arg5), atomic symbol arg6, mass arg7, charge arg8 (optional), and lineno arg9 (optional). atom_at_position(self: psi4.core.Molecule, arg0: float, arg1",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/psi4api-1.html:127749,charge,charge,127749,psi4manual/1.2.1/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html,3,['charge'],['charge']
Energy Efficiency,"les (cheapest terms). mrccsdtqp-1a; CC through quadruples with iterative quintuples (cheapest terms). mrccsdtqph-1a; CC through quintuples with iterative sextuples (cheapest terms). mrccsdt-1b; CC through doubles with iterative triples (cheaper terms). mrccsdtq-1b; CC through triples with iterative quadruples (cheaper terms). mrccsdtqp-1b; CC through quadruples with iterative quintuples (cheaper terms). mrccsdtqph-1b; CC through quintuples with iterative sextuples (cheaper terms). mrcc2; approximate CC through doubles. mrcc3; approximate CC through triples. mrcc4; approximate CC through quadruples. mrcc5; approximate CC through quintuples. mrcc6; approximate CC through sextuples. mrccsdt-3; CC through doubles with iterative triples (all but the most expensive terms). mrccsdtq-3; CC through triples with iterative quadruples (all but the most expensive terms). mrccsdtqp-3; CC through quadruples with iterative quintuples (all but the most expensive terms). mrccsdtqph-3; CC through quintuples with iterative sextuples (all but the most expensive terms). Frozen-core approximation is also supported in the MRCC interface.; To optimize CH4 with CCSDT freezing the 1s on carbon, run:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14molecule H2O {; O; H 1 r; H 1 r 2 104.5. r = 1.0; }. set {; basis cc-pVDZ; freeze_core true; }. optimize('mrccsdt'). Interface Details¶. MRCC methods¶. MRCC_METHOD; Method; Description. 1; CC;  . 2; CC(n-1)[n];  . 3; CC(n-1)(n); (CC(n-1)[n] energy is also calculated). 4; CC(n-1)(n)_L; (CC(n-1)[n] and CC(n-1)(n) energies are also calculated). 5; CC(n)-1a;  . 6; CC(n)-1b;  . 7; CCn;  . 8; CC(n)-3;  . table of contents. Interface to MRCC by M. Kállay; Installation; Running MRCC; Interface Details. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. © Copyright 2019, The Psi4 Project.; Last updated on Wednesday, 15 May 2019 08:49PM.; Created using Sphinx 1.8.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/mrcc-1.html:4269,energy,energy,4269,psi4manual/1.3.2/mrcc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/mrcc-1.html,2,['energy'],['energy']
Energy Efficiency,"les and doubles level; of theory. QCISD(T) TOTAL ENERGY¶. QCISD(T) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the quadratic configuration interaction singles and doubles with; perturbative triples correction level of theory. SAPT DISP ENERGY¶. SAPT ELST ENERGY¶. SAPT EXCH ENERGY¶. SAPT IND ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total electronic interaction energy [H] for the the; requested SAPT level of theory. The sum of these four components yields; SAPT ENERGY. SAPT ENERGY¶; The total electronic interaction energy [H] for the requested SAPT; level of theory. SAPT SAPT0 ENERGY¶. SAPT SAPT2 ENERGY¶. SAPT SAPT2+ ENERGY¶. SAPT SAPT2+(3) ENERGY¶. SAPT SAPT2+3 ENERGY¶; The total electronic interaction energy [H] for the labeled SAPT level; of theory. SAPT SAPT2+(CCD) ENERGY¶. SAPT SAPT2+(3)(CCD) ENERGY¶. SAPT SAPT2+3(CCD) ENERGY¶; The total electronic interaction energy [H] for the labeled SAPT level; of theory that incorporates coupled-cluster dispersion. SCF DIPOLE X¶. SCF DIPOLE Y¶. SCF DIPOLE Z¶; The three components of the SCF dipole [Debye]. SCF QUADRUPOLE XX¶. SCF QUADRUPOLE XY¶. SCF QUADRUPOLE XZ¶. SCF QUADRUPOLE YY¶. SCF QUADRUPOLE YZ¶. SCF QUADRUPOLE ZZ¶; The six components of the SCF quadrupole [Debye Ang]. SCF TOTAL ENERGY¶; The total electronic energy [H] of the SCF stage of the calculation.; The CORRELATION ENERGY variables from subsequent stages of a; calculation are often the corresponding TOTAL ENERGY; variables less this quantity. Constructed from Eq. (4),; where this quantity is . (4); Unless the method includes a dispersion correction, this quantity is; equal to HF TOTAL ENERGY (for HF) or; DFT FUNCTIONAL TOTAL ENERGY (for; DFT). Unless the method is a DFT double-hybrid, this quantity is equal; to DFT TOTAL ENERGY. TWO-ELECTRON ENERGY¶; The two-electron energy contribution [H] to the total SCF energy.; Quantity in Eq. (4). UNCP-CORRECTED 2-B",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/glossary_psivariables-1.html:14821,energy,energy,14821,psi4manual/4.0b4/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/glossary_psivariables-1.html,4,['energy'],['energy']
Energy Efficiency,"les and doubles with; perturbative triples correction level of theory. QCISD(T) CORRECTION ENERGY¶; The quadratic configuration interaction singles and doubles perturbative; triples correction [E_h]. REMP2 TOTAL ENERGY¶. REMP2 CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the retaining-the-excitation-degree Møller–Plesset hybrid perturbation; theory level. SAPT DISP ENERGY¶. SAPT ELST ENERGY¶. SAPT EXCH ENERGY¶. SAPT IND ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total electronic interaction energy [E_h] for the; requested SAPT level of theory. The sum of these four components yields; SAPT TOTAL ENERGY. SAPT TOTAL ENERGY¶. SAPT ENERGY¶; The total electronic interaction energy [E_h] for the requested SAPT; level of theory. SAPT ELST10,R ENERGY¶; An electrostatics-classified SAPT term energy [E_h] implemented for SAPT0. SAPT ELST EXTERN-EXTERN ENERGY¶; Electrostatic interaction [E_h] between the point charges in fragments; A and B in F/I-SAPT. SAPT EXCH10 ENERGY¶; An exchange-classified SAPT term energy [E_h] implemented for SAPT0. SAPT EXCH10(S^2) ENERGY¶; An exchange-classified SAPT term energy [E_h] implemented for SAPT0. SAPT IND20,R ENERGY¶. SAPT EXCH-IND20,R ENERGY¶. SAPT IND20,U ENERGY¶. SAPT EXCH-IND20,U ENERGY¶; An induction-classified SAPT term energy [E_h] implemented for SAPT0. SAPT DISP20 ENERGY¶. SAPT EXCH-DISP20 ENERGY¶; A dispersion-classified SAPT term energy [E_h] implemented for SAPT0. SAPT EXCH-DISP20(S^INF) ENERGY¶; A dispersion-classified SAPT term energy [E_h] implemented for SAPT0. See Higher-Order Exchange Terms without Single-Exchange Approximation. SAPT SAME-SPIN DISP20 ENERGY¶. SAPT SAME-SPIN EXCH-DISP20 ENERGY¶; The portion of SAPT DISP20 ENERGY or; SAPT EXCH-DISP20 ENERGY resulting from; from same-spin or triplet doubles correlations. SAPT HF(2) ENERGY ABC(HF)¶; The total Hartree–Fock energy [E_h] of the supersystem implemented for ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html:45824,charge,charges,45824,psi4manual/1.7.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html,4,['charge'],['charges']
Energy Efficiency,"les, doubles, quadruples level of theory. Quantity; MP4(SDQ) CORRELATION ENERGY is; first right-hand term in Eq. (2). MP4 TOTAL ENERGY¶. MP4 CORRELATION ENERGY¶. MP4(SDTQ) TOTAL ENERGY¶. MP4(SDTQ) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the full MP4 level of theory. Quantity MP4 CORRELATION; ENERGY / MP4(SDTQ) CORRELATION ENERGY is left-hand term in Eq. (2). (2)¶\[E_{\text{MP4}} = E_{\text{MP4(SDQ)}} + E_{\text{MP4(T)}}\]. MPn TOTAL ENERGY¶. MPn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled Møller–Plesset perturbation theory level.; n is MP perturbation order. NUCLEAR REPULSION ENERGY¶; The nuclear repulsion energy contribution [H] to the total SCF energy.; Quantity \(E_{NN}\) in Eq. (4). (3)¶\[E_{NN} = \sum_{i, j<i}^{N_{atom}}\frac{Z_i Z_j}{|\mathbf{R}_i - \mathbf{R}_j|}\]. OCEPA(0) TOTAL ENERGY¶. OCEPA(0) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the orbital-optimized CEPA(0) level of theory. OMP2 TOTAL ENERGY¶. OMP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the orbital-optimized MP2 level of theory. OMP3 TOTAL ENERGY¶. OMP3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the orbital-optimized MP3 level of theory. ONE-ELECTRON ENERGY¶; The one-electron energy contribution [H] to the total SCF energy.; Quantity \(E_{1e^-}\) in Eq. (4). QCISD TOTAL ENERGY¶. QCISD CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the quadratic configuration interaction singles and doubles level; of theory. QCISD(T) TOTAL ENERGY¶. QCISD(T) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the quadratic configuration interaction singles and doubles with; perturbative triples correction level of theory. SAPT DISP ENERGY¶. SAPT ELST ENE",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/glossary_psivariables-1.html:14701,energy,energy,14701,psi4manual/1.1.0/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/glossary_psivariables-1.html,4,['energy'],['energy']
Energy Efficiency,"les.; To circumvent difficulties with running multiple jobs in the same scratch, the; process ID (PID) of the PSI4 instance is incorporated into the full file; name; therefore, it is safe to use the same scratch directory for calculations; running simultaneously. This also means that if the user wants PSI4 to use; information from a previous file, like molecular orbitals, he needs to provide the; name of the file. This can be done through the restart_file option; 1energy('scf',restart_file='./psi.PID.name.filenumber'). where by default, PID is the process number, name the name of the molecule,; and filenumber is listed in content. Only the filenumber; is necessary for the driver to appropriately rename the file for the next PSI4; job, and if none is found it defaults to 32, a checkpoint file. If two or more files; are to be read, they need to be provided as a Python list; 1energy('scf',restart_file=['./file1.filenumber','./file2.filenumber']). Note that the restart_file options is only available for energy procedures as of now.; Executing PSI4 with the psi4 -m (for; messy) flag will prevent files being deleted at the end of the run:; 1psi4 -m. ~/.psi4rc File¶. Caution; It is very easy to forget about the ~/.psi4rc file you once; created, leading to great confusion over why all your jobs are using; the wrong memory or are suddenly not density-fit. Also be aware that; ~/.psi4rc contents count as part of your input file (invoked after; e.g. from psi4 import * and before your Psithon–>Python parsed; input commands), so these settings take priority over command-line; arguments to the psi4 executable.; Please use the ~/.psi4rc file conscientiously. If using the environment variable PSI_SCRATCH is inconvenient,; or if some psi4_io commands must be present in all input files,; the ~/.psi4rc resource file can be used (example psi4/samples/example_psi4rc_file).; All the commands mentioned in section Scratch Files and Elementary Restart can be used in this file.; To set up the",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/external-1.html:7996,energy,energy,7996,psi4manual/1.3.2/external-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/external-1.html,2,['energy'],['energy']
Energy Efficiency,"les.; To circumvent difficulties with running multiple jobs in the same scratch, the; process ID (PID) of the PSI4 instance is incorporated into the full file; name; therefore, it is safe to use the same scratch directory for calculations; running simultaneously. This also means that if the user wants PSI4 to use; information from a previous file, like molecular orbitals, he needs to provide the; name of the file. This can be done through the restart_file option; 1energy('scf',restart_file='./psi.PID.name.filenumber'). where by default, PID is the process number, name the name of the molecule,; and filenumber is listed in content. Only the filenumber; is necessary for the driver to appropriately rename the file for the next PSI4; job, and if none is found it defaults to 32, a checkpoint file. If two or more files; are to be read, they need to be provided as a Python list; 1energy('scf',restart_file=['./file1.filenumber','./file2.filenumber']). Note that the restart_file options is only available for energy procedures as of now.; Executing PSI4 with the psi4 -m (for; messy) flag will prevent files being deleted at the end of the run:; 1psi4 -m. ~/.psi4rc File¶; If using the environment variable PSI_SCRATCH is inconvenient,; or if some psi4_io commands must be present in all input files,; the ~/.psi4rc resource file can be used (example psi4/samples/example_psi4rc_file).; All the commands mentioned in section Scratch Files and Elementary Restart can be used in this file.; To set up the scratch path:; 1psi4_io.set_default_path('/scratch/user'). To set up the scratch path from a variable $MYSCRATCH:; 1; 2; 3; 4import os; scratch_dir = os.environ.get('MYSCRATCH'); if scratch_dir:; psi4_io.set_default_path(scratch_dir + '/'). To set up a specific path for the checkpoint file and instruct PSI4 not to delete it:; 1; 2; 3; 4; 5; 6psi4_io.set_specific_path(32, './'); psi4_io.set_specific_retention(32, True). # equivalent to above; psi4_io.set_specific_path(PSIF_CHKPT, './'); ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/external-1.html:7798,energy,energy,7798,psi4manual/1.1.0/external-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/external-1.html,4,['energy'],['energy']
Energy Efficiency,"les; --------; >>> # [1] CISD extrapolation; >>> energy('cbs', corl_wfn='cisd', corl_basis='cc-pV[DT]Z', corl_scheme='corl_xtpl_helgaker_2'). """"""; if type(valueLO) != type(valueHI):; raise ValidationError(; f""corl_xtpl_helgaker_2: Inputs must be of the same datatype! ({type(valueLO)}, {type(valueHI)})""). if alpha is None:; alpha = 3.0. if isinstance(valueLO, float):; value = (valueHI * zHI**alpha - valueLO * zLO**alpha) / (zHI**alpha - zLO**alpha); beta = (valueHI - valueLO) / (zHI**(-alpha) - zLO**(-alpha)). final = value; if verbose:; # Output string with extrapolation parameters; cbsscheme = f""""""\n\n ==> Helgaker 2-point correlated extrapolation for method: {functionname.upper()} <==\n\n""""""; cbsscheme += """""" LO-zeta (%s) Energy: % 16.12f\n"""""" % (str(zLO), valueLO); cbsscheme += """""" HI-zeta (%s) Energy: % 16.12f\n"""""" % (str(zHI), valueHI); cbsscheme += """""" Alpha (exponent) Value: % 16.12f\n"""""" % alpha; cbsscheme += f"""""" Beta (coefficient) Value: {beta: 16.12f}\n\n""""""; cbsscheme += """""" Extrapolated Energy: % 16.12f\n\n"""""" % value; # Note that in energy-only days, this used to print SCF and Correlation, not Total, Energy. name_str = ""%s/(%s,%s)"" % (functionname.upper(), _zeta_val2sym[zLO].upper(), _zeta_val2sym[zHI].upper()); cbsscheme += """""" @Extrapolated """"""; cbsscheme += name_str + ':'; cbsscheme += "" "" * (19 - len(name_str)); cbsscheme += """"""% 16.12f\n\n"""""" % final; core.print_out(cbsscheme); logger.debug(cbsscheme). return final. elif isinstance(valueLO, np.ndarray):. value = (valueHI * zHI**alpha - valueLO * zLO**alpha) / (zHI**alpha - zLO**alpha); beta = (valueHI - valueLO) / (zHI**(-alpha) - zLO**(-alpha)). if verbose > 2:; cbsscheme = f""""""\n ==> Helgaker 2-point correlated extrapolation for method: {functionname.upper()} <==\n""""""; cbsscheme += f""""""\n LO-zeta ({zLO}) Data\n""""""; cbsscheme += nppp(valueLO); cbsscheme += f""""""\n HI-zeta ({zHI}) Data\n""""""; cbsscheme += nppp(valueHI). cbsscheme += f""""""\n Alpha (exponent) Value: {alpha:16.8f}""""""; cbsscheme += f""""""\",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs_helper.html:19772,Energy,Energy,19772,psi4manual/1.6.x/_modules/psi4/driver/driver_cbs_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs_helper.html,5,['Energy'],['Energy']
Energy Efficiency,"les; is available in NIST Chemistry Webbook. Alternatively, one can estimate the; ionization potential of molecule by computing the energy difference between; the molecule as given, and the molecule after one electron has been removed; (e.g., the energy difference between a neutral molecule and its cation).; The values of GRAC shifts should be given in Hartree. For the example above,; the GRAC shift value of both molecules are calculated to be 0.1307, and the; user would specify them using the following keywords:; set globals {; sapt_dft_grac_shift_a 0.1307; sapt_dft_grac_shift_b 0.1307; }. A complete, minimal example of a SAPT(DFT) computation is given below.; molecule {; 0 1; O -1.551007 -0.114520 0.000000; H -1.934259 0.762503 0.000000; H -0.599677 0.040712 0.000000; --; 0 1; O 1.350625 0.111469 0.000000; H 1.680398 -0.373741 -0.758561; H 1.680398 -0.373741 0.758561. units angstrom; }. set {; basis aug-cc-pVDZ; sapt_dft_grac_shift_a 0.1307; sapt_dft_grac_shift_b 0.1307; }. energy('sapt(dft)'). As already mentioned above, the SAPT0 module for open-shell cases can also; use exact integrals for all terms except for dispersion. In practice,; density fitting is considerably faster and introduces negligible errors, thus; it is the preferred method for open-shell cases as well.; Below, you can find a minimum example of open-shell SAPT0 computation.; molecule {; 0 1; O 0.000000 0.000000 6.000000; H 0.000000 1.431500 4.890600; H 0.000000 -1.431500 4.890600; --; 0 2; O 0.000000 0.000000 0.000000; O 0.000000 2.503900 0.000000; H 0.000000 -0.424700 -1.839500; units bohr; symmetry c1; no_reorient; no_com; }. set {; reference uhf; scf_type df; basis aug-cc-pVDZ; }. energy('sapt0'). REFERENCE needs to be UHF or ROHF for the open-shell computation to proceed. Advanced example¶; Open-shell computations can be difficult to converge in certain cases, thus you may; want to have more control over the SCF procedure. You have the option of; doing the driver job in the input file, by per",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/sapt-1.html:12685,energy,energy,12685,psi4manual/1.4.0/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/sapt-1.html,5,['energy'],['energy']
Energy Efficiency,"less since python will catch it long before here); cbs_scf_scheme = highest_1; if 'scf_scheme' in kwargs:; cbs_scf_scheme = kwargs['scf_scheme']. # Establish treatment for correlation energy; cbs_corl_scheme = highest_1; if 'corl_scheme' in kwargs:; cbs_corl_scheme = kwargs['corl_scheme']. # Establish treatment for delta correction energy; cbs_delta_scheme = highest_1; if 'delta_scheme' in kwargs:; cbs_delta_scheme = kwargs['delta_scheme']. # Establish treatment for delta2 correction energy; cbs_delta2_scheme = highest_1; if 'delta2_scheme' in kwargs:; cbs_delta2_scheme = kwargs['delta2_scheme']. # Establish treatment for delta3 correction energy; cbs_delta3_scheme = highest_1; if 'delta3_scheme' in kwargs:; cbs_delta3_scheme = kwargs['delta3_scheme']. # Establish treatment for delta4 correction energy; cbs_delta4_scheme = highest_1; if 'delta4_scheme' in kwargs:; cbs_delta4_scheme = kwargs['delta4_scheme']. # Establish treatment for delta5 correction energy; cbs_delta5_scheme = highest_1; if 'delta5_scheme' in kwargs:; cbs_delta5_scheme = kwargs['delta5_scheme']. # Build string of title banner; cbsbanners = ''; cbsbanners += """"""psi4.print_out('\\n')\n""""""; cbsbanners += """"""p4util.banner(' CBS Setup ')\n""""""; cbsbanners += """"""psi4.print_out('\\n')\n\n""""""; exec(cbsbanners). # Call schemes for each portion of total energy to 'place orders' for calculations needed; d_fields = ['d_stage', 'd_scheme', 'd_basis', 'd_wfn', 'd_need', 'd_coef', 'd_energy']; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; GRAND_NEED = []; MODELCHEM = []; bstring = ''; if do_scf:; NEED = call_function_in_1st_argument(cbs_scf_scheme,; mode='requisition', basisname=BSTR, basiszeta=ZETR, wfnname='scf'); GRAND_NEED.append(dict(zip(d_fields, ['scf', cbs_scf_scheme, reconstitute_bracketed_basis(NEED), 'scf', NEED, +1, 0.0]))). if do_corl:; NEED = call_function_in_1st_argument(cbs_corl_scheme,; mode='requisition', basisname=BSTC, basiszeta=ZETC, wfnname=cbs_corl_wfn); GRAND_NEED.appe",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:78363,energy,energy,78363,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,2,['energy'],['energy']
Energy Efficiency,"level of theory and root n, and the transition is of irrep h, (n starts at 0), (3,3). CCname ROOT m -> ROOT n EINSTEIN A (LEN)¶; The Einstein A coefficient, the spontaneous emission ‘probability.’; Units are in [1/s].; Describes the transition between roots m and n. CCname ROOT m (IN h) -> ROOT n (IN i) EINSTEIN A (LEN)¶; The Einstein A coefficient, the spontaneous emission ‘probability.’; Units are in [1/s].; Describes the transition between root m within irrep h and root n which irrep i. CCname ROOT m (h) -> ROOT n (i) EINSTEIN A (LEN)¶; The Einstein A coefficient, the spontaneous emission ‘probability.’; Units are in [1/s].; Describes the transition between roots m and n, which are in irreps h and i, respectively.. CCname ROOT m -> ROOT n EINSTEIN A (LEN) - h TRANSITION¶; The Einstein A coefficient, the spontaneous emission ‘probability.’; Units are in [1/s].; Describes the irrep h transition between roots m and n. CCname ROOT m -> ROOT n EINSTEIN B (LEN)¶; The Einstein B coefficient, the stimulated emission ‘probability’; in terms of energy density. Units are in [m^3 / J / s^2].; Describes the transition between roots m and n. CCname ROOT m (IN h) -> ROOT n (IN i) EINSTEIN B (LEN)¶; The Einstein B coefficient, the stimulated emission ‘probability’; in terms of energy density. Units are in [m^3 / J / s^2].; Describes the transition between root m within irrep h and root n which irrep i. CCname ROOT m (h) -> ROOT n (i) EINSTEIN B (LEN)¶; The Einstein B coefficient, the stimulated emission ‘probability’; in terms of energy density. Units are in [m^3 / J / s^2].; Describes the transition between roots m and n, which are in irreps h and i, respectively.. CCname ROOT m -> ROOT n EINSTEIN B (LEN) - h TRANSITION¶; The Einstein B coefficient, the stimulated emission ‘probability’; in terms of energy density. Units are in [m^3 / J / s^2].; Describes the irrep h transition between roots m and n. CCname ROOT m -> ROOT n ROTATORY STRENGTH (LEN)¶. TD-fctl ROOT 0 -> ROOT n ROT",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/glossary_psivariables.html:12277,energy,energy,12277,psi4manual/1.6.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/glossary_psivariables.html,5,['energy'],['energy']
Energy Efficiency,"level shift on a UHF computation. frac; Carbon/UHF Fractionally-Occupied SCF Test Case. dft-custom-mgga; updated dldf reference to new BraggSlater radii Dispersionless density functional (dlDF+D) internal match to Psi4 Extensive testing has been done to match supplemental info of Szalewicz et. al., Phys. Rev. Lett., 103, 263201 (2009) and Szalewicz et. al., J. Phys. Chem. Lett., 1, 550-555 (2010). dft-grad-meta; meta-GGA gradients of water and ssh molecules reference gradients updated due to new BraggSlater radii. dfomp3-1; DF-OMP3 cc-pVDZ energy for the H2O molecule. omp2-3; OMP2 cc-pVDZ energy for the NO radical. isapt-siao1; This test case shows an example of running the I-SAPT0/jun-cc-pVDZ computation for 2,4-pentanediol (targeting the intramolecular hydrogen bond between the two hydroxyl groups) The SIAO1 link partitioning algorithm is used. isapt2; This is a shorter version if isapt1 - does not do cube plots. See isapt1 for full details. sapt5; SAPT0 aug-cc-pVTZ computation of the charge transfer energy of the water dimer. omp2p5-grad2; OMP2.5 cc-pVDZ gradient for the NO radical. cc9; UHF-CCSD(T) cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Z-matrix input. mcscf1; ROHF 6-31G** energy of the \(^{3}B_1\) state of CH2, with Z-matrix input. The occupations are specified explicitly. dfcasscf-fzc-sp; CASSCF/6-31G** energy point. mp2p5-grad2; MP2.5 cc-pVDZ gradient for the NO radical. pywrap-basis; SAPT calculation on bimolecular complex where monomers are unspecified so driver auto-fragments it. Basis set and auxiliary basis sets are assigned by atom type. cepa1; cc-pvdz H2O Test CEPA(1) Energy. dft-psivar; HF and DFT variants single-points on zmat methane, mostly to test that PSI variables are set and computed correctly. Now also testing that CSX harvesting PSI variables correctly update ref_dft_2e/xc due to new BraggSlater radii. ghosts; Density fitted MP2 cc-PVDZ/cc-pVDZ-RI computation of formic acid dimer binding energy using ex",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html:47089,charge,charge,47089,psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,4,"['charge', 'energy']","['charge', 'energy']"
Energy Efficiency,"levels': vmfc_level_list; }. return metadata. def compute_nbody_components(func, method_string, metadata):; """"""Computes requested N-body components. Performs requested computations for psi4::Molecule object `molecule` according to; `compute_list` with function `func` at `method_string` level of theory. Parameters; ----------; func : {'energy', 'gradient', 'hessian'}; Function object to be called within N-Body procedure.; method_string : str; Indicates level of theory to be passed to function `func`.; metadata : dict of str; Dictionary of N-body metadata. Required ``'key': value`` pairs:; ``'compute_list'``: dict of int: set; List of computations to perform. Keys indicate body-levels, e.g,. `compute_list[2]` is the; list of all 2-body computations required.; ``'kwargs'``: dict; Arbitrary keyword arguments to be passed to function `func`. Returns; -------; dict of str: dict; Dictionary containing computed N-body components. Contents:; ``'energies'``: dict of set: float64; Dictionary containing all energy components required for given N-body procedure.; ``'ptype'``: dict of set: float64 or dict of set: psi4.Matrix; Dictionary of returned quantities from calls of function `func` during N-body computations; ``'intermediates'``: dict of str: float64; Dictionary of psivars for intermediate N-body computations to be set at the end of the; N-body procedure.; """"""; # Get required metadata; kwargs = metadata['kwargs']; molecule = metadata['molecule']; #molecule = core.get_active_molecule(); compute_list = metadata['compute_dict']['all']. # Now compute the energies; energies_dict = {}; gradients_dict = {}; ptype_dict = {}; intermediates_dict = {}; if kwargs.get('charge_method', False) and not metadata['embedding_charges']:; metadata['embedding_charges'] = driver_nbody_helper.compute_charges(kwargs['charge_method'],; kwargs.get('charge_type', 'MULLIKEN_CHARGES').upper(), molecule); for count, n in enumerate(compute_list.keys()):; core.print_out(""\n ==> N-Body: Now computing %d-bo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_nbody.html:15195,energy,energy,15195,psi4manual/1.3.2/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_nbody.html,1,['energy'],['energy']
Energy Efficiency,"lf); Returns the Lagrangian Matrix. alpha_orbital_space(self, arg0, arg1, arg2); docstring. aotoso(self); Returns the Atomic Orbital to Symmetry Orbital transformer. arrays(self); Returns the map of all internal arrays. atomic_point_charges(self); Returns the set atomic point charges. basis_projection(self, arg0, arg1, arg2, arg3); Projects a orbital matrix from one basis to another. basisset(self); Returns the current orbital basis. beta_orbital_space(self, arg0, arg1, arg2); docstring. build(mol[, basis]). c1_deep_copy(self, basis); Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet *basis. compute_energy(self); Computes the energy of the Wavefunction. compute_gradient(self); Computes the gradient of the Wavefunction. compute_hessian(self); Computes the Hessian of the Wavefunction. deep_copy(self, arg0); Deep copies the internal data. doccpi(self); Returns the number of doubly occupied orbitals per irrep. energy(self); Returns the Wavefunctions energy. epsilon_a(self); Returns the Alpha Eigenvalues. epsilon_a_subset(self, arg0, arg1); Returns the requested Alpha Eigenvalues subset. epsilon_b(self); Returns the Beta Eigenvalues. epsilon_b_subset(self, arg0, arg1); Returns the requested Beta Eigenvalues subset. esp_at_nuclei(self); returns electrostatic potentials at nuclei. force_doccpi(self, arg0); Specialized expert use only. force_soccpi(self, arg0); Specialized expert use only. frequencies(self); Returns the frequencies of the Hessian. frzcpi(self); Returns the number of frozen core orbitals per irrep. frzvpi(self); Returns the number of frozen virtual orbitals per irrep. get_array(self, arg0); Sets the requested internal array. get_basisset(self, arg0); Returns the requested auxiliary basis. get_dipole_field_strength(self); Returns a vector of length 3, containing the x,y, and z dipole field strengths. get_print(self); Get the print level of the Wavefunction. get_variable(self, arg0); Returns the requeste",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/api/psi4.core.wavefunction.html:1857,energy,energy,1857,psi4manual/1.2.1/api/psi4.core.wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/api/psi4.core.wavefunction.html,2,['energy'],['energy']
Energy Efficiency,"lf); docstring. cleanup_dpd(self); docstring. compute_energy(self); Computes the energy of the Wavefunction. compute_gradient(self); Computes the gradient of the Wavefunction. compute_hessian(self); Computes the Hessian of the Wavefunction. compute_state_transfer(self, arg0, arg1, …); docstring. deep_copy(self, arg0); Deep copies the internal data. del_array_variable(self, arg0); Removes the requested (case-insensitive) Matrix QC variable. del_potential_variable(self, arg0); Removes the requested (case-insensitive) ExternalPotential QC variable. del_scalar_variable(self, arg0); Removes the requested (case-insensitive) double QC variable. del_variable(key); Removes scalar or array QCVariable key from cls if present. density_fitted(self); Returns whether this wavefunction was obtained using density fitting or not. diag_h(self, arg0, arg1); docstring. doccpi(self); Returns the number of doubly occupied orbitals per irrep. efzc(self); Returns the frozen-core energy. energy(self); Returns the Wavefunction’s energy. epsilon_a(self); Returns the Alpha Eigenvalues. epsilon_a_subset(self, arg0, arg1); Returns the requested Alpha Eigenvalues subset. epsilon_b(self); Returns the Beta Eigenvalues. epsilon_b_subset(self, arg0, arg1); Returns the requested Beta Eigenvalues subset. esp_at_nuclei(self); returns electrostatic potentials at nuclei. external_pot(self); Gets the requested external potential. force_doccpi(self, arg0); Specialized expert use only. force_soccpi(self, arg0); Specialized expert use only. form_opdm(self); docstring. form_tpdm(self); docstring. frequencies(). from_file(wfn_data); Build Wavefunction from data. frzcpi(self); Returns the number of frozen core orbitals per irrep. frzvpi(self); Returns the number of frozen virtual orbitals per irrep. get_array(key). Deprecated since version 1.4. get_basisset(self, arg0); Returns the requested auxiliary basis. get_dimension(self, arg0); Returns the dimension of requested orbital subspace. get_dipole_field_strength(s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ciwavefunction.html:3034,energy,energy,3034,psi4manual/1.4.0/api/psi4.core.ciwavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ciwavefunction.html,2,['energy'],['energy']
Energy Efficiency,"lf, molecule, basisname, ribasisname):. self.molecule = molecule; self.basisname = basisname; self.ribasisname = ribasisname; self.basis = None; self.ribasis = None; self.da = None; self.Da = None; self.wfn = None. def __str__(self):. s = ' => Diffuse <=\n\n'; s = s + ' ' + str(self.molecule) + '\n'; s = s + ' ' + self.basisname + '\n'; s = s + ' ' + self.ribasisname + '\n'; s = s + '\n'. return s. def fitScf(self):; """"""Function to run scf and fit a system of diffuse charges to; resulting density. """"""; basisChanged = core.has_option_changed(""BASIS""); ribasisChanged = core.has_option_changed(""DF_BASIS_SCF""); scftypeChanged = core.has_option_changed(""SCF_TYPE""). basis = core.get_option(""BASIS""); ribasis = core.get_option(""DF_BASIS_SCF""); scftype = core.get_option(""SCF_TYPE""). core.print_out("" => Diffuse SCF (Determines Da) <=\n\n""). core.set_global_option(""BASIS"", self.basisname); core.set_global_option(""DF_BASIS_SCF"", self.ribasisname); core.set_global_option(""SCF_TYPE"", ""DF""); E, ref = energy('scf', return_wfn=True, molecule=self.molecule); self.wfn = ref; core.print_out(""\n""). self.fitGeneral(). core.clean(). core.set_global_option(""BASIS"", basis); core.set_global_option(""DF_BASIS_SCF"", ribasis); core.set_global_option(""SCF_TYPE"", scftype). if not basisChanged:; core.revoke_option_changed(""BASIS""); if not ribasisChanged:; core.revoke_option_changed(""DF_BASIS_SCF""); if not scftypeChanged:; core.revoke_option_changed(""SCF_TYPE""). def fitGeneral(self):; """"""Function to perform a general fit of diffuse charges; to wavefunction density. """"""; core.print_out("" => Diffuse Charge Fitting (Determines da) <=\n\n""); self.Da = self.wfn.Da(); self.basis = self.wfn.basisset(); parser = core.Gaussian94BasisSetParser(); self.ribasis = core.BasisSet.construct(parser, self.molecule, ""DF_BASIS_SCF""). fitter = core.DFChargeFitter(); fitter.setPrimary(self.basis); fitter.setAuxiliary(self.ribasis); fitter.setD(self.Da); self.da = fitter.fit(); self.da.scale(2.0). def populateExtern(self, ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/qmmm.html:2283,energy,energy,2283,psi4manual/1.1.0/_modules/psi4/driver/qmmm.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/qmmm.html,1,['energy'],['energy']
Energy Efficiency,"lf.Da); self.da = fitter.fit(); self.da.scale(2.0). [docs] def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]class QMMM(object):. def __init__(self):; self.charges = []; self.diffuses = []; self.extern = psi4.ExternalPotential(). [docs] def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs] def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs] def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / p4const.psi_bohr2angstroms, y / p4const.psi_bohr2angstroms, z / p4const.psi_bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(0, len(self.diffuses)):; s = s + str(self.diffuses[k]). return s. [docs] def populateExtern(self):; """"""Function to define a charge field external to the; molecule through point and diffuse charges. """"""; # Charges; for charge in self.charges:; self.extern.addCharge(charge[0], charge[1], charge[2], charge[3]); # Diffuses; for diffuse in self.diffuses:; diffuse.populateExtern(self.extern). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; PSI4 [beta5] » ; Module code ». © Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/qmmm.html:4280,charge,charges,4280,psi4manual/4.0b5/_modules/qmmm.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qmmm.html,28,"['Charge', 'charge']","['Charges', 'charge', 'charges']"
Energy Efficiency,"lf.LOT = LOT; self.options = options if options else {}. if molecule is None:; molecule = psi4.core.get_active_molecule(); self.initial_molecule = molecule; assert self.initial_molecule.orientation_fixed() == True, ""Orientation must be fixed!""; assert self.initial_molecule.point_group().symbol() == ""c1"", ""Symmetry must be 'c1'!"". names = [self.initial_molecule.symbol(i) for i in range(self.initial_molecule.natom())]; psi4.core.print_out(""Initial atoms %s\n"" % names); self.atoms_list = names. psi4.core.print_out(""Psi4 options:\n""); for item, value in self.options.items():; psi4.core.print_out(""%s %s\n"" % (item, value)); psi4.core.set_global_option(item, value); psi4.core.IO.set_default_namespace(""xwrapper""). self.timing = {}. atoms = np.array(self.initial_molecule.geometry()); psi4.core.print_out(""Initial atoms %s\n"" % atoms); psi4.core.print_out(""Force:\n""); self._positions = atoms; self._callback = self.callback; self._nat = np.int32(len(atoms)). def calculate_force(self, pos=None, **kwargs):; """"""Fetch force, energy of PSI. Arguments:; - pos: positions of the atoms as array. If None, the positions of the current active; molecule is used.; """"""; if pos is None:; molecule = psi4.core.get_active_molecule(); pos = np.array(molecule.geometry()). self._force, self._potential = self.callback(pos, **kwargs); return self._force, self._potential. def callback(self, pos, **kwargs):; """"""Initialize psi with new positions and calculate force. Arguments:; - pos: positions of the atoms as array.; """""". self.initial_molecule.set_geometry(psi4.core.Matrix.from_array(pos)). self.calculate_gradient(self.LOT, pos=pos, **kwargs). self._potential = psi4.variable('CURRENT ENERGY'); self._force = -np.array(self.grd); self._vir = np.array([[0.0,0.0,0.0],[0.0,0.0,0.0],[0.0,0.0,0.0]]). return self._force, np.float64(self._potential). def calculate_gradient(self, LOT, bypass_scf=False, **kwargs):; """"""Calculate the gradient with @LOT. When bypass_scf=True a hf energy calculation has been done befo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/ipi_broker.html:2918,energy,energy,2918,psi4manual/1.4.0/_modules/psi4/driver/ipi_broker.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/ipi_broker.html,4,['energy'],['energy']
Energy Efficiency,"lf.PYcharge_specified. [docs] def multiplicity(self):; """"""Get the multiplicity (defined as 2Ms + 1). >>> print H2OH2O.multiplicity(). """"""; return self.PYmultiplicity. [docs] def set_multiplicity(self, mult):; """"""Sets the multiplicity (defined as 2Ms + 1). >>> H2OH2O.set_multiplicity(3). """"""; self.PYmultiplicity_specified = True; self.PYmultiplicity = mult. [docs] def multiplicity_specified(self):; """"""Whether the multiplicity was given by the user. >>> print H2OH2O.multiplicity_specified(); True. """"""; return self.PYmultiplicity_specified. [docs] def units(self):; """"""Gets the geometry units. >>> print H2OH2O.units(); Angstrom. """"""; return self.PYunits. [docs] def set_units(self, units):; """"""Sets the geometry units. >>> H2OH2O.set_units('Angstom'). """"""; if units == 'Angstrom' or units == 'Bohr':; self.PYunits = units; else:; raise ValidationError(""""""Argument to Molecule::set_units must be 'Angstrom' or 'Bohr'.""""""). # <<< Simple Methods for Coordinates >>>. [docs] def Z(self, atom):; """"""Nuclear charge of atom (0-indexed). >>> print H2OH2O.Z(4); 1. """"""; return self.atoms[atom].Z(). [docs] def x(self, atom):; """"""x position of atom (0-indexed) in Bohr. >>> print H2OH2O.x(4); 3.17549201425. """"""; return self.input_units_to_au * self.atoms[atom].compute()[0]. [docs] def y(self, atom):; """"""y position of atom (0-indexed) in Bohr. >>> print H2OH2O.y(4); -0.706268134631. """"""; return self.input_units_to_au * self.atoms[atom].compute()[1]. [docs] def z(self, atom):; """"""z position of atom (0-indexed) in Bohr. >>> print H2OH2O.z(4); -1.43347254509. """"""; return self.input_units_to_au * self.atoms[atom].compute()[2]. [docs] def xyz(self, atom, posn=None):; """"""Returns a Vector3 with x, y, z position of atom (0-indexed); in Bohr or coordinate at *posn*. >>> print H2OH2O.xyz(4); [3.175492014248769, -0.7062681346308132, -1.4334725450878665]. """"""; temp = scale(self.atoms[atom].compute(), self.input_units_to_au); if posn >= 0:; return temp[posn]; else:; return temp. [docs] def mass(self, ato",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html:5817,charge,charge,5817,psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html,4,['charge'],['charge']
Energy Efficiency,"lf.description); text.append(self.dashlevel_citation.rstrip()); if self.dashparams_citation:; text.append("" Parametrisation from:{}"".format(self.dashparams_citation.rstrip())); text.append(''); for op in self.ordered_params:; text.append("" %6s = %14.6f"" % (op, self.dashparams[op])); text.append('\n'). core.print_out('\n'.join(text)). [docs] def compute_energy(self, molecule: core.Molecule, wfn: core.Wavefunction = None) -> float:; """"""Compute dispersion energy based on engine, dispersion level, and parameters in `self`. Parameters; ----------; molecule; System for which to compute empirical dispersion correction.; wfn; Location to set QCVariables. Returns; -------; float; Dispersion energy [Eh]. Notes; -----; :psivar:`DISPERSION CORRECTION ENERGY`; Disp always set. Overridden in SCF finalization, but that only changes for ""-3C"" methods.; :psivar:`fctl DISPERSION CORRECTION ENERGY`; Set if :py:attr:`fctldash` nonempty. """"""; if self.engine in ['dftd3', 'mp2d', ""dftd4""]:; resi = AtomicInput(; **{; 'driver': 'energy',; 'model': {; 'method': self.fctldash,; 'basis': '(auto)',; },; 'keywords': {; 'level_hint': self.dashlevel,; 'params_tweaks': self.dashparams,; 'dashcoeff_supplement': self.dashcoeff_supplement,; 'pair_resolved': self.save_pairwise_disp,; 'verbose': 1,; },; 'molecule': molecule.to_schema(dtype=2),; 'provenance': p4util.provenance_stamp(__name__),; }); jobrec = qcng.compute(; resi,; self.engine,; raise_error=True,; local_options={""scratch_directory"": core.IOManager.shared_object().get_default_path(), ""ncores"": core.get_num_threads()}). dashd_part = float(jobrec.extras['qcvars']['DISPERSION CORRECTION ENERGY']); if wfn is not None:; for k, qca in jobrec.extras['qcvars'].items():; if (""CURRENT"" not in k) and (""PAIRWISE"" not in k):; wfn.set_variable(k, float(qca) if isinstance(qca, str) else qca). # Pass along the pairwise dispersion decomposition if we need it; if self.save_pairwise_disp is True:; wfn.set_variable(""PAIRWISE DISPERSION CORRECTION ANALYSIS"",; job",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/empirical_dispersion.html:7597,energy,energy,7597,psi4manual/1.6.x/_modules/psi4/driver/procrouting/empirical_dispersion.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/empirical_dispersion.html,2,['energy'],['energy']
Energy Efficiency,"lf.description); text.append(self.dashlevel_citation.rstrip()); if self.dashparams_citation:; text.append("" Parametrisation from:{}"".format(self.dashparams_citation.rstrip())); text.append(''); for op in self.ordered_params:; text.append("" %6s = %14.6f"" % (op, self.dashparams[op])); text.append('\n'). core.print_out('\n'.join(text)). [docs] def compute_energy(self, molecule: core.Molecule, wfn: core.Wavefunction = None) -> float:; """"""Compute dispersion energy based on engine, dispersion level, and parameters in `self`. Parameters; ----------; molecule; System for which to compute empirical dispersion correction.; wfn; Location to set QCVariables. Returns; -------; float; Dispersion energy [Eh]. Notes; -----; :psivar:`DISPERSION CORRECTION ENERGY`; Disp always set. Overridden in SCF finalization, but that only changes for ""-3C"" methods.; :psivar:`fctl DISPERSION CORRECTION ENERGY`; Set if :py:attr:`fctldash` nonempty. """"""; if self.engine in ['dftd3', 'mp2d', ""dftd4""]:; resi = AtomicInput(; **{; 'driver': 'energy',; 'model': {; 'method': self.fctldash,; 'basis': '(auto)',; },; 'keywords': {; 'level_hint': self.dashlevel,; 'params_tweaks': self.dashparams,; 'dashcoeff_supplement': self.dashcoeff_supplement,; 'pair_resolved': self.save_pairwise_disp,; 'verbose': 1,; },; 'molecule': molecule.to_schema(dtype=2),; 'provenance': p4util.provenance_stamp(__name__),; }); jobrec = qcng.compute(; resi,; self.engine,; raise_error=True,; local_options={""scratch_directory"": core.IOManager.shared_object().get_default_path()}). dashd_part = float(jobrec.extras['qcvars']['DISPERSION CORRECTION ENERGY']); if wfn is not None:; for k, qca in jobrec.extras['qcvars'].items():; if (""CURRENT"" not in k) and (""PAIRWISE"" not in k):; wfn.set_variable(k, float(qca) if isinstance(qca, str) else qca). # Pass along the pairwise dispersion decomposition if we need it; if self.save_pairwise_disp is True:; wfn.set_variable(""PAIRWISE DISPERSION CORRECTION ANALYSIS"",; jobrec.extras['qcvars'][""2-BODY PAIRW",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/procrouting/empirical_dispersion.html:7597,energy,energy,7597,psi4manual/1.5.0/_modules/psi4/driver/procrouting/empirical_dispersion.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/procrouting/empirical_dispersion.html,2,['energy'],['energy']
Energy Efficiency,"lf.lattice_field.extern); self.set_lattice = True. # Respond to the >NLATTICE command; def recv_nlattice(self, nlattice=None):; """""" Receive the number of lattice point charges through MDI. Arguments:; nlattice: New number of point charges. If None, receive through MDI.; """"""; if nlattice is None:; self.nlattice = MDI_Recv(1, MDI_INT, self.comm); else:; self.nlattice = nlattice; self.clattice = [0.0 for ilat in range(3 * self.nlattice)]; self.lattice = [0.0 for ilat in range(self.nlattice)]; self.set_lattice_field(). # Respond to the >CLATTICE command; def recv_clattice(self, clattice=None):; """""" Receive the coordinates of a set of lattice point charges through MDI. Arguments:; clattice: New coordinates of the lattice of point charges. If None, receive through MDI.; """"""; if clattice is None:; self.clattice = MDI_Recv(3 * self.nlattice, MDI_DOUBLE, self.comm); else:; self.clattice = clattice; self.set_lattice_field(). # Respond to the >LATTICE command; def recv_lattice(self, lattice=None):; """""" Receive the charges of a set of lattice point charges through MDI. Arguments:; lattice: New charges of the lattice of point charges. If None, receive through MDI.; """"""; if lattice is None:; self.lattice = MDI_Recv(self.nlattice, MDI_DOUBLE, self.comm); else:; self.lattice = lattice; self.set_lattice_field(). # Respond to the SCF command; def run_scf(self):; """""" Run an energy calculation; """"""; self.energy = psi4.energy(self.scf_method, **self.kwargs). # Respond to the <DIMENSIONS command; def send_dimensions(self):; """""" Send the dimensionality of the system through MDI. :returns: *dimensions* Dimensionality of the system; """"""; dimensions = [1, 1, 1]; MDI_Send(dimensions, 3, MDI_INT, self.comm); return dimensions. # Respond to the <TOTCHARGE command; def send_total_charge(self):; """""" Send the total system charge through MDI. :returns: *charge* Total charge of the system; """"""; charge = self.molecule.molecular_charge(); MDI_Send(charge, 1, MDI_DOUBLE, self.comm); return charge. # Res",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html:9988,charge,charges,9988,psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html,8,['charge'],['charges']
Energy Efficiency,"lf.molecule.fZ(jatom) == 0 and jatom < self.molecule.nallatom():; jatom = jatom + 1; if jatom >= self.molecule.nallatom():; raise Exception('Unexpected number of ghost atoms when receiving masses'); self.molecule.set_mass(iatom, masses[jatom]); jatom = jatom + 1. # Set a lattice of point charges; def set_lattice_field(self):; """""" Set a field of lattice point charges using information received through MDI; """"""; self.lattice_field = psi4.QMMM(); unit_conv = self.length_conversion(); for ilat in range(self.nlattice):; latx = self.clattice[3 * ilat + 0] * unit_conv; laty = self.clattice[3 * ilat + 1] * unit_conv; latz = self.clattice[3 * ilat + 2] * unit_conv; self.lattice_field.extern.addCharge(self.lattice[ilat], latx, laty, latz); psi4.core.set_global_option_python('EXTERN', self.lattice_field.extern); self.set_lattice = True. # Respond to the >NLATTICE command; def recv_nlattice(self, nlattice=None):; """""" Receive the number of lattice point charges through MDI. Arguments:; nlattice: New number of point charges. If None, receive through MDI.; """"""; if nlattice is None:; self.nlattice = MDI_Recv(1, MDI_INT, self.comm); else:; self.nlattice = nlattice; self.clattice = [0.0 for ilat in range(3 * self.nlattice)]; self.lattice = [0.0 for ilat in range(self.nlattice)]; self.set_lattice_field(). # Respond to the >CLATTICE command; def recv_clattice(self, clattice=None):; """""" Receive the coordinates of a set of lattice point charges through MDI. Arguments:; clattice: New coordinates of the lattice of point charges. If None, receive through MDI.; """"""; if clattice is None:; self.clattice = MDI_Recv(3 * self.nlattice, MDI_DOUBLE, self.comm); else:; self.clattice = clattice; self.set_lattice_field(). # Respond to the >LATTICE command; def recv_lattice(self, lattice=None):; """""" Receive the charges of a set of lattice point charges through MDI. Arguments:; lattice: New charges of the lattice of point charges. If None, receive through MDI.; """"""; if lattice is None:; self.lattice = MD",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html:9200,charge,charges,9200,psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html,4,['charge'],['charges']
Energy Efficiency,"lf.molecule.units(); if unit_name == ""Angstrom"":; # beware if MDI and psi4 choose different sets of constants; unit_conv = psi4.driver.constants.bohr2angstroms; elif unit_name == ""Bohr"":; unit_conv = 1.0; else:; raise Exception('Unrecognized unit type: ' + str(unit_name)). return unit_conv. # Respond to the <NATOMS command; def send_natoms(self):; """""" Send the number of atoms through MDI; """"""; natom = self.molecule.natom(); MDI_Send(natom, 1, MDI_INT, self.comm); return natom. # Respond to the <COORDS command; def send_coords(self):; """""" Send the nuclear coordinates through MDI; """"""; coords = self.molecule.geometry().np.ravel(); MDI_Send(coords, len(coords), MDI_DOUBLE, self.comm); return coords. # Respond to the <CHARGES command; def send_charges(self):; """""" Send the nuclear charges through MDI. :returns: *charges* Atomic charges; """"""; natom = self.molecule.natom(); charges = [self.molecule.charge(iatom) for iatom in range(natom)]; MDI_Send(charges, natom, MDI_DOUBLE, self.comm); return charges. # Respond to the <MASSES command; def send_masses(self):; """""" Send the nuclear masses through MDI. :returns: *masses* Atomic masses; """"""; natom = self.molecule.natom(); molecule_dict = self.molecule.to_dict(); masses = molecule_dict['mass']; MDI_Send(masses, natom, MDI_DOUBLE, self.comm); return masses. # Respond to the <ELEMENTS command; def send_elements(self):; """""" Send the atomic number of each nucleus through MDI. :returns: *elements* Element of each atom; """"""; natom = self.molecule.natom(); elements = [self.molecule.true_atomic_number(iatom) for iatom in range(natom)]; MDI_Send(elements, natom, MDI_INT, self.comm); return elements. # Respond to the <ENERGY command; def send_energy(self):; """""" Send the total energy through MDI. :returns: *energy* Energy of the system; """"""; self.run_scf(); MDI_Send(self.energy, 1, MDI_DOUBLE, self.comm); return self.energy. # Respond to the <FORCES command; def send_forces(self):; """""" Send the nuclear forces through MDI. :returns: *forc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/mdi_engine.html:5820,charge,charges,5820,psi4manual/1.9.x/_modules/psi4/driver/mdi_engine.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/mdi_engine.html,4,['charge'],['charges']
Energy Efficiency,"lf.tagl); text += """""" %20s"""""" % ('Reactions'); for ax in self.axis.keys():; text += """""" %8s"""""" % (ax); text += """"""\n""""""; for ix in range(len(self.hrxn)):; text += """""" %20s"""""" % (str(self.hrxn[ix])); for ax in self.axis.values():; text += """""" %8.3f"""""" % (ax[ix]); text += """"""\n""""""; text += """"""\n""""""; return text. [docs]class Reagent(object):; """"""Chemical entity only slightly dresed up from qcdb.Molecule. """""". def __init__(self, name, mol, tagl=None, comment=None):; # full name, e.g., 'S22-2-dimer' or 'NBC1-BzMe-8.0-monoA-CP' or 'HTBH-HCl-reagent'; self.name = name; # qcdb.Molecule; try:; self.NRE = mol.nuclear_repulsion_energy(); except AttributeError:; raise ValidationError(""""""Reagent must be instantiated with qcdb.Molecule object.""""""); else:; self.mol = mol.create_psi4_string_from_molecule(); # description line; self.tagl = tagl; # # addl comments; # self.comment = comment; # # fragmentation; # self.fragments = mol.fragments; # # frag activation; # self.frtype = mol.fragment_types; # # frag charge; # self.frchg = mol.fragment_charges; # # frag multiplicity; # self.frmult = mol.fragment_multiplicities; self.charge = mol.molecular_charge(). def __str__(self):; text = ''; text += """""" ==> %s Reagent <==\n\n"""""" % (self.name); text += """""" Tagline: %s\n"""""" % (self.tagl); # text += """""" Comment: %s\n"""""" % (self.comment); text += """""" NRE: %f\n"""""" % (self.NRE); # text += """""" Charge: %+d\n""""""; # text += """""" Fragments: %d\n"""""" % (len(self.fragments)); # text += """""" FrgNo Actv Chg Mult AtomRange\n""""""; # for fr in range(len(self.fragments)):; # text += """""" %-4d %1s %+2d %2d %s\n"""""" % (fr + 1,; # '*' if self.frtype[fr] == 'Real' else '',; # self.frchg[fr], self.frmult[fr], self.fragments[fr]); text += """""" Molecule: \n%s"""""" % (self.mol); text += """"""\n""""""; return text. [docs]class Reaction(object):; """""". """""". def __init__(self, name, dbse, indx, tagl=None, latex=None, color='black', comment=None):; # name, e.g., '2' or 'BzMe-8.0'; self.name = name; # database reaction name, e.g., 'S22",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:13300,charge,charge,13300,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html,1,['charge'],['charge']
Energy Efficiency,"lf: psi4.core.FISAPT) → Dict[str, psi4.core.Matrix]¶; Return the interally computed matrices (not copied). molecule(self: psi4.core.FISAPT) → psi4.core.Molecule¶; Returns the FISAPT’s molecule. nuclear(self: psi4.core.FISAPT) → None¶; Build the nuclear potentials V and interaction energies. overlap(self: psi4.core.FISAPT) → None¶; Build the overlap integrals S. partition(self: psi4.core.FISAPT) → None¶; Partition the nuclei and electrons. print_header(self: psi4.core.FISAPT) → None¶; Print header, bases, sizes, etc. print_trailer(self: psi4.core.FISAPT) → None¶; Print SAPT results. raw_plot(self: psi4.core.FISAPT, arg0: str) → None¶; Plot some analysis files. scalars(self: psi4.core.FISAPT) → Dict[str, float]¶; Return the interally computed scalars (not copied). scf(self: psi4.core.FISAPT) → None¶; Solve the relaxed SCF equations for A0 and B0. sinf_disp(self: psi4.core.FISAPT, arg0: Dict[str, psi4.core.Matrix], arg1: Dict[str, psi4.core.Vector], arg2: bool) → None¶; Computes the MP2-based DispE20 and Exch-DispE20 energy without S^2. unify(self: psi4.core.FISAPT) → None¶; Produce unified matrices for A’, B’, and C’. unify_part2(self: psi4.core.FISAPT) → None¶; Finish producing unified matrices for A’, B’, and C’. vectors(self: psi4.core.FISAPT) → Dict[str, psi4.core.Vector]¶; Return the interally computed vectors (not copied). table of contents. FISAPT; FISAPT; FISAPT.coulomb(); FISAPT.dHF(); FISAPT.disp(); FISAPT.do_cubes(); FISAPT.elst(); FISAPT.exch(); FISAPT.fdisp(); FISAPT.felst(); FISAPT.fexch(); FISAPT.find(); FISAPT.flocalize(); FISAPT.freeze_core(); FISAPT.ind(); FISAPT.kinetic(); FISAPT.localize(); FISAPT.matrices(); FISAPT.molecule(); FISAPT.nuclear(); FISAPT.overlap(); FISAPT.partition(); FISAPT.print_header(); FISAPT.print_trailer(); FISAPT.raw_plot(); FISAPT.scalars(); FISAPT.scf(); FISAPT.sinf_disp(); FISAPT.unify(); FISAPT.unify_part2(); FISAPT.vectors(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · .",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/api/psi4.core.FISAPT.html:3895,energy,energy,3895,psi4manual/1.9.x/api/psi4.core.FISAPT.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.FISAPT.html,2,['energy'],['energy']
Energy Efficiency,"lf: psi4.core.FISAPT) → dict[str, psi4.core.Matrix]¶; Return the interally computed matrices (not copied). molecule(self: psi4.core.FISAPT) → psi4.core.Molecule¶; Returns the FISAPT’s molecule. nuclear(self: psi4.core.FISAPT) → None¶; Build the nuclear potentials V and interaction energies. overlap(self: psi4.core.FISAPT) → None¶; Build the overlap integrals S. partition(self: psi4.core.FISAPT) → None¶; Partition the nuclei and electrons. print_header(self: psi4.core.FISAPT) → None¶; Print header, bases, sizes, etc. print_trailer(self: psi4.core.FISAPT) → None¶; Print SAPT results. raw_plot(self: psi4.core.FISAPT, arg0: str) → None¶; Plot some analysis files. scalars(self: psi4.core.FISAPT) → dict[str, float]¶; Return the interally computed scalars (not copied). scf(self: psi4.core.FISAPT) → None¶; Solve the relaxed SCF equations for A0 and B0. sinf_disp(self: psi4.core.FISAPT, arg0: dict[str, psi4.core.Matrix], arg1: dict[str, psi4.core.Vector], arg2: bool) → None¶; Computes the MP2-based DispE20 and Exch-DispE20 energy without S^2. unify(self: psi4.core.FISAPT) → None¶; Produce unified matrices for A’, B’, and C’. unify_part2(self: psi4.core.FISAPT) → None¶; Finish producing unified matrices for A’, B’, and C’. vectors(self: psi4.core.FISAPT) → dict[str, psi4.core.Vector]¶; Return the interally computed vectors (not copied). table of contents. FISAPT; FISAPT; FISAPT.coulomb(); FISAPT.dHF(); FISAPT.disp(); FISAPT.do_cubes(); FISAPT.elst(); FISAPT.exch(); FISAPT.fdisp(); FISAPT.felst(); FISAPT.fexch(); FISAPT.find(); FISAPT.flocalize(); FISAPT.freeze_core(); FISAPT.ind(); FISAPT.kinetic(); FISAPT.localize(); FISAPT.matrices(); FISAPT.molecule(); FISAPT.nuclear(); FISAPT.overlap(); FISAPT.partition(); FISAPT.print_header(); FISAPT.print_trailer(); FISAPT.raw_plot(); FISAPT.scalars(); FISAPT.scf(); FISAPT.sinf_disp(); FISAPT.unify(); FISAPT.unify_part2(); FISAPT.vectors(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev6",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/api/psi4.core.FISAPT.html:3902,energy,energy,3902,psi4manual/master/api/psi4.core.FISAPT.html,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.FISAPT.html,2,['energy'],['energy']
Energy Efficiency,"lf: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, savetype: psi4.core.SaveType=SaveType.LowerTriangle) -> None. Load a matrix from a PSIO object from fileno and with toc position of the name of the matrix. load_mpqc(self: psi4.core.Matrix, filename: str) → None; Loads a matrix from an ASCII file in MPQC format. name; The name of the Matrix. Used in printing. nirrep(self: psi4.core.Matrix) → int; Returns the number of irreps. np; View without only one irrep. classmethod np_read(filename, prefix=''); Reads the data from a NumPy compress file. np_write(filename=None, prefix=''); Writes the irreped matrix to a NumPy zipped file.; Can return the packed data for saving many matrices into the same file. nph; View with irreps. partial_cholesky_factorize(self: psi4.core.Matrix, delta: float=0.0, throw_if_negative: bool=False) → psi4.core.Matrix; Computes the fully pivoted partial Cholesky factorization of a real symmetric positive semidefinite matrix, to numerical precision delta. power(self: psi4.core.Matrix, alpha: float, cutoff: float=1e-12) → psi4.core.Dimension; Takes the matrix to the alpha power with precision cutoff. print_atom_vector(self: psi4.core.Matrix, RMRoutfile: str='outfile') → None; Print the matrix with atom labels, assuming it is an natom X 3 tensor. print_out(self: psi4.core.Matrix) → None; Prints the matrix to the output file. pseudoinverse(self: psi4.core.Matrix, condition: float, nremoved: int) → psi4.core.Matrix; Computes the matrix which is the conditioned pseudoinverse of this matrix. remove_symmetry(self: psi4.core.Matrix, a: psi4.core.Matrix, transformer: psi4.core.Matrix) → None; Remove symmetry from a matrix A with PetiteList::sotoao(). rms(self: psi4.core.Matrix) → float; Returns the rms of this matrix. rotate_columns(self: psi4.core.Matrix, h: int, i: int, j: int, theta: float) → None; Rotates columns i and j in irrep h by angle theta. rowdim(self: psi4.core.Matrix) → psi4.core.Dimension; Returns the rows per irrep array. rows(self: psi4",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.matrix.html:22668,power,power,22668,psi4manual/1.3.2/api/psi4.core.matrix.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.matrix.html,2,['power'],['power']
Energy Efficiency,"lf: psi4.core.Molecule) → int¶; Gets the molecular charge. move_to_com(self: psi4.core.Molecule) → None¶; Moves molecule to center of mass. multiplicity(self: psi4.core.Molecule) → int¶; Gets the multiplicity (defined as 2Ms + 1). nallatom(self: psi4.core.Molecule) → int¶; Number of real and dummy atoms. name(self: psi4.core.Molecule) → str¶; Gets molecule name. natom(self: psi4.core.Molecule) → int¶; Number of real atoms. nfragments(self: psi4.core.Molecule) → int¶; Gets the number of fragments in the molecule. nuclear_dipole(*args, **kwargs)¶; Overloaded function. nuclear_dipole(self: psi4.core.Molecule, arg0: psi4.core.Vector3) -> psi4.core.Vector3. Gets the nuclear contribution to the dipole, with respect to a specified origin atg0. nuclear_dipole(self: psi4.core.Molecule) -> psi4.core.Vector3. Gets the nuclear contribution to the dipole, with respect to the origin. nuclear_repulsion_energy(self: psi4.core.Molecule, dipole_field: List[float[3]]=[0.0, 0.0, 0.0]) → float¶; Computes nuclear repulsion energy. nuclear_repulsion_energy_deriv1(self: psi4.core.Molecule, dipole_field: List[float[3]]=[0.0, 0.0, 0.0]) → psi4.core.Matrix¶; Returns first derivative of nuclear repulsion energy as a matrix (natom, 3). nuclear_repulsion_energy_deriv2(self: psi4.core.Molecule) → psi4.core.Matrix¶; Returns second derivative of nuclear repulsion energy as a matrix (natom X 3, natom X 3). orientation_fixed(self: psi4.core.Molecule) → bool¶; Get whether or not orientation is fixed. point_group(self: psi4.core.Molecule) → psi4.core.PointGroup¶; Returns the current point group object. print_bond_angles(self: psi4.core.Molecule) → None¶; Print the bond angle geometrical parameters. print_cluster(self: psi4.core.Molecule) → None¶; Prints the molecule in Cartesians in input units adding fragment separators. print_distances(self: psi4.core.Molecule) → None¶; Print the interatomic distance geometrical parameters. print_in_input_format(self: psi4.core.Molecule) → None¶; Prints the molecule ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.molecule.html:25080,energy,energy,25080,psi4manual/1.3.2/api/psi4.core.molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.molecule.html,3,['energy'],['energy']
Energy Efficiency,"lf: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the set atomic point charges. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.Wavefunction, basis: psi4.core.BasisSet) → psi4.core.Wavefunction¶; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet *basis. compute(self: psi4.core.DFEP2Wavefunction, arg0: List[List[int]]) → List[List[Tuple[float, float]]]¶; Computes the density-fitted EP2 energy for the input orbitals. compute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Deep copies the internal data. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunctions energy. epsilon_a(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Alpha Eigenvalues subset. epsilon_b(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Beta",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/psi4api-1.html:37751,energy,energy,37751,psi4manual/1.2.1/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html,2,['energy'],['energy']
Energy Efficiency,"lf: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. build(mol, basis=None)¶. compute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Deep copies the internal data. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunctions energy. epsilon_a(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Alpha Eigenvalues subset. epsilon_b(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Beta Eigenvalues subset. finalize_E(self: psi4.core.HF) → float; Computes the final SCF energy. form_C(self: psi4.core.HF) → None; Forms the Orbital Matrices from the current Fock Matrices. form_D(self: psi4.core.HF) → None; Forms the Density Matrices from the current Orbitals Matrices. form_V(self: psi4.core.HF) → None; Form the Kohn-Sham Potential Matrices from the current Density Matrices. frequencies(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the frequencies of the Hessi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/api/psi4.core.hf.html:6690,energy,energy,6690,psi4manual/1.1.0/api/psi4.core.hf.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.hf.html,1,['energy'],['energy']
Energy Efficiency,"lf: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. build(mol, basis=None)¶. compute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Deep copies the internal data. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunctions energy. epsilon_a(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Alpha Eigenvalues subset. epsilon_b(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Beta Eigenvalues subset. finalize_E(self: psi4.core.HF) → float¶; Computes the final SCF energy. form_C(self: psi4.core.HF) → None¶; Forms the Orbital Matrices from the current Fock Matrices. form_D(self: psi4.core.HF) → None¶; Forms the Density Matrices from the current Orbitals Matrices. form_V(self: psi4.core.HF) → None¶; Form the Kohn-Sham Potential Matrices from the current Density Matrices. frequencies(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the frequencies of the H",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psi4api-1.html:19686,energy,energy,19686,psi4manual/1.1.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psi4api-1.html,14,['energy'],['energy']
Energy Efficiency,"lfonamide; 7505 benzonitrile; 78438 N-[anilino(phenyl)phosphoryl]aniline; 12581 3-phenylpropanenitrile; 517327 sodium benzenesulfonate; 637563 1-methoxy-4-[(E)-prop-1-enyl]benzene; 252325 [(E)-prop-1-enyl]benzene. Note that some of these results do not contain the string “benzene”; these; compounds have synonyms containing that text. We can now replace the; “benzene*” in the input file with one of the above compounds using either the; IUPAC name or the CID provided in the list, viz:; 1; 2; 3molecule benzene {; pubchem:637563; }. or; 1; 2; 3molecule benzene {; pubchem:1-methoxy-4-[(E)-prop-1-enyl]benzene; }. Some of the structures in the database are quite loosely optimized and do not; have the correct symmetry. Before starting the computation, PSI4 will; check to see if the molecule is close to having each of the possible; symmetries, and will adjust the structure accordingly so that the maximum; symmetry is utilized.; The standard keywords, described in Molecule Keywords, can be; used in conjunction to specify charge, multiplicity, symmetry to use, etc. . Symmetry¶; For efficiency, PSI4 can utilize the largest Abelian subgroup of the full; point group of the molecule. Concomitantly, a number of quantities, such as; SOCC and DOCC, are arrays whose entries pertain to irreducible; representations (irreps) of the molecular point group. Ordering of irreps; follows the convention used in Cotton’s Chemical Applications of Group; Theory, as detailed in Table Irreps. We refer to this; convention as “Cotton Ordering” hereafter. Ordering of irreducible representations (irreps) used in PSI4¶. Point Group; 1; 2; 3; 4; 5; 6; 7; 8. \(C_1\); \(A\);  ;  ;  ;  ;  ;  ;  . \(C_i\); \(A_g\); \(A_u\);  ;  ;  ;  ;  ;  . \(C_2\); \(A\); \(B\);  ;  ;  ;  ;  ;  . \(C_s\); \(A'\); \(A''\);  ;  ;  ;  ;  ;  . \(D_2\); \(A\); \(B_1\); \(B_2\); \(B_3\);  ;  ;  ;  . \(C_{2v}\); \(A_1\); \(A_2\); \(B_1\); \(B_2\);  ;  ;  ;  . \(C_{2h}\); \(A_g\); \(B_g\); \(A_u\); \(B_u\);  ;  ;  ;  . \(D_{2h}\); \",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psithonmol-1.html:10659,charge,charge,10659,psi4manual/1.1.0/psithonmol-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psithonmol-1.html,6,['charge'],['charge']
Energy Efficiency,"lgaker, J. Chem. Phys. 117, 9160 (2002). No reference energies defined. cp 'off'; rlxd 'off'. ACENES¶. Database of Ed and Rob’s favorite linear acene dimers.; Geometries from nowhere special, and reference energies undefined. cp 'off' || 'on'; rlxd 'off'; subset. 'small'; 'large'; 'FIRST3' benzene, napthalene, and anthracene dimers; 'FIRST5' benzene - pentacene dimers; 'FIRST10' benzene - decacene dimers. NCB31¶. Database (Truhlar) of several classes of noncovalent interactions.; Geometries from Truhlar and coworkers at site http://comp.chem.umn.edu/database_noncov/noncovalent.htm; Reference energies from Truhlar and coworkers at site http://comp.chem.umn.edu/database_noncov/noncovalent.htm; First comprehensive citation JPCA 109 5656 (2005). cp 'off' || 'on'; rlxd 'off' || 'on'; benchmark. '<benchmark_name>' <Reference>.; \(\Rightarrow\) '<default_benchmark_name>' \(\Leftarrow\) <Reference>. subset. 'small' 3: HF-HF, He-Ne, HCCH-HCCH; 'large' 1: BzBz_PD; 'HB6' hydrogen-bonded; 'CT7' charge-transfer; 'DI6' dipole-interacting; 'WI7' weakly interacting; 'PPS5' pi-pi stacking. BAKERJCC93¶. Database of molecules that are challenging to optimize.; Geometries from Baker J. Comput. Chem. 14 1085 (1993), as reported; in Bakken and Helgaker, J. Chem. Phys. 117, 9160 (2002), with a few; further corrections.; No reference energies defined. cp 'off'; rlxd 'off'; subset. 'small'; 'large'. BASIC¶. Database of simple molecules, mostly for testing.; Geometries from nowhere special, and no reference energies defined. cp 'off'; rlxd 'off'; subset ['h2o', 'nh3', 'ch4']. S22by5¶. Database (Hobza) of interaction energies for dissociation curves of bimolecular complexes.; Geometries and reference interaction energies from Grafova et al. JCTC 6 2365 (2010).; Note that the S22by5-N-1.0 members are essentially the same geometries as S22-N (there’s trivial round-off error) but the reference interaction energies for S22by5 are of lower quality than those of S22. cp 'off' || 'on'; rlxd 'off'; su",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_available_databases.html:8038,charge,charge-transfer,8038,psi4manual/master/autodoc_available_databases.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_available_databases.html,2,['charge'],['charge-transfer']
Energy Efficiency,"lgorithm (effective for ALGORITHM = QC). If set to TWOSTEP the Newton-Raphson equations are only solved for the orbital updates, the cumulant is updated using the standard Jacobi algorithm. If set to SIMULTANEOUS both cumulant and orbitals are updated in a single Newton-Raphson step. Type: string; Possible Values: TWOSTEP, SIMULTANEOUS; Default: SIMULTANEOUS. REFERENCE¶. Reference wavefunction type. Type: string; Possible Values: UHF, RHF, ROHF; Default: RHF. RESPONSE_ALGORITHM¶. Algorithm to use for the solution of DC-06 response equations in computation of analytic gradients and properties. Type: string; Possible Values: TWOSTEP, SIMULTANEOUS; Default: TWOSTEP. R_CONVERGENCE¶. Convergence criterion for the RMS of the residual vector in density cumulant updates, as well as the solution of the density cumulant and orbital response equations. In the orbital updates controls the RMS of the SCF error vector. Type: conv double; Default: 1e-10. THREE_PARTICLE¶. Whether to compute three-particle energy correction or not. Type: string; Possible Values: NONE, PERTURBATIVE; Default: NONE. Expert¶. CACHELEVEL¶. Controls how to cache quantities within the DPD library. Type: integer; Default: 2. DAMPING_PERCENTAGE¶. The amount (percentage) of damping to apply to the orbital update procedure: 0 will result in a full update, 100 will completely stall the update. A value around 20 (which corresponds to 20% of the previous iteration’s density being mixed into the current iteration) can help in cases where oscillatory convergence is observed. Type: double; Default: 0.0. DCFT_GUESS¶. Whether to read the orbitals from a previous computation, or to compute an MP2 guess. Type: string; Possible Values: CC, BCC, MP2, DCFT; Default: MP2. DIIS_MAX_VECS¶. Maximum number of error vectors stored for DIIS extrapolation. Type: integer; Default: 6. DIIS_MIN_VECS¶. Minimum number of error vectors stored for DIIS extrapolation. Type: integer; Default: 3. ENERGY_LEVEL_SHIFT¶. Level shift applied to ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__dcft-1.html:4073,energy,energy,4073,psi4manual/1.0.0/autodir_options_c/module__dcft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__dcft-1.html,6,['energy'],['energy']
Energy Efficiency,"lib/scripts/ixyz2database.pl.; See Creating a Database for details. Caution; Some features are not yet implemented. Buy a developer some coffee. In sow/reap mode, use only global options (e.g., the local option set by set scf scf_type df will not be respected). Note; To access a database that is not embedded in a PSI4 ; distribution, add the path to the directory containing the database ; to the environment variable PYTHONPATH. Parameters:; name (string) – 'scf' || 'sapt0' || 'ccsd(t)' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). db_name (string) – 'BASIC' || 'S22' || 'HTBH' || etc.; Second argument, usually unlabeled. Indicates the requested database; name, matching (case insensitive) the name of a python file in ; psi4/lib/databases or PYTHONPATH. Consult that ; directory for available databases and literature citations. func (function) – energy || optimize || cbs; Indicates the type of calculation to be performed on each database; member. The default performs a single-point energy('name'), while; optimize perfoms a geometry optimization on each reagent, and; cbs performs a compound single-point energy. If a nested series; of python functions is intended (see Function Intercalls), use; keyword db_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; Indicates whether the calculations required to complete the; database are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. cp (boolean) – 'on' || 'off' ; Indicates whether counterpoise correction is employed in computing; interaction energies. Use this option and NOT the cp(); function for BSSE correction in database(). Option available; (See Available Databases) only for databases of bimolecular complexes. rlxd (boolean) – 'on' || 'off' ; Ind",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/db-1.html:1777,energy,energy,1777,psi4manual/4.0b3/db-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/db-1.html,4,['energy'],['energy']
Energy Efficiency,"libxc_func() (psi4.core.SuperFunctional method). is_lrc() (psi4.core.Functional method). is_meta() (psi4.core.Functional method). (psi4.core.SuperFunctional method). is_poisson() (psi4.core.FittingMetric method). is_pure() (psi4.core.GaussianShell method). is_variable() (psi4.core.Molecule method). is_x_hybrid() (psi4.core.SuperFunctional method). is_x_lrc() (psi4.core.SuperFunctional method). ISA. ; MBIS. Isotopes. ISOTROPIC_POL (PE). ISTOP (DETCI). iteration (psi4.driver.ConvergenceError attribute). (psi4.driver.OptimizationConvergenceError attribute). (psi4.driver.SCFConvergenceError attribute). (psi4.driver.TDSCFConvergenceError attribute). iteration_ (psi4.core.HF attribute). iteration_energies (psi4.core.HF attribute). iterations() (psi4.core.HF method). J. J() (psi4.core.JK method). JK (class in psi4.core). jk() (psi4.core.HF method). JOBTYPE (CCLAMBDA). K. K() (psi4.core.JK method). keywords. ; anharmonicity(), setting. cbs(), setting. cp, setting. database(), setting. energy(), setting. frequency(), setting. general, setting. molecule, setting. optimize(), setting. properties(), setting. vmfc, setting. keywords (psi4.driver.AtomicComputer attribute). (psi4.driver.driver_cbs.CompositeComputer attribute). (psi4.driver.driver_nbody.ManyBodyComputer attribute). KIND (ADC). kinetic() (psi4.core.FISAPT method). kinetic_grad() (psi4.core.MintsHelper method). KineticInt (class in psi4.core). kwargs_lower() (in module psi4.driver.p4util). L. L (psi4.core.Localizer attribute). label() (psi4.core.Molecule method). (psi4.core.MOSpace method). lagrangian() (psi4.core.Wavefunction method). LaplaceDenominator (class in psi4.core). LCC2 (+LMP2) TOTAL ENERGY. LCCD CORRELATION ENERGY. LCCD DOUBLES ENERGY. LCCD OPPOSITE-SPIN CORRELATION ENERGY. LCCD SAME-SPIN CORRELATION ENERGY. LCCD SINGLES ENERGY. LCCD TOTAL ENERGY. LCCSD. (+LMP2). LCCSD CORRELATION ENERGY. LCCSD DOUBLES ENERGY. LCCSD OPPOSITE-SPIN CORRELATION ENERGY. LCCSD SAME-SPIN CORRELATION ENERGY. LCCSD SINGLES ENERGY.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/genindex.html:68776,energy,energy,68776,psi4manual/1.9.x/genindex.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/genindex.html,2,['energy'],['energy']
Energy Efficiency,"lic License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. import os; import hashlib; import collections; from typing import Dict, List, Optional, Tuple, Union. import numpy as np. import qcelemental as qcel. import psi4; from .util import parse_dertype; from .libmintsmolecule import *; from .testing import compare_values, compare_integers, compare_molrecs; from .bfs import BFS. qcdbmol = ""psi4.driver.qcdb.molecule.Molecule"". [docs]class Molecule(LibmintsMolecule):; """"""Class to store the elements, coordinates, fragmentation pattern,; charge, multiplicity of a molecule. Largely replicates psi4's libmints; Molecule class, developed by Justin M. Turney and Andy M. Simmonett; with incremental improvements by other psi4 developers. Major. This class extends `qcdb.LibmintsMolecule` and occasionally; `psi4.core.Molecule` itself. """""". def __init__(self,; molinit=None,; dtype=None,; geom=None,; elea=None,; elez=None,; elem=None,; mass=None,; real=None,; elbl=None,; name=None,; units='Angstrom',; input_units_to_au=None,; fix_com=None,; fix_orientation=None,; fix_symmetry=None,; fragment_separators=None,; fragment_charges=None,; fragment_multiplicities=None,; molecular_charge=None,; molecular_multiplicity=None,; comment=None,; provenance=None,; connectivity=None,; enable_qm=True,; enable_efp=True,; missing_enabled_return_qm='none',; missing_enabled_return_efp='none',; missing_enabled_return='error',; tooclose=0.1,; zero_ghost_fragments=False,; nonphysical=False,; mtol=1.e-3,; verbose=1):;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:1591,charge,charge,1591,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,2,['charge'],['charge']
Energy Efficiency,"lic License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. __all__ = [; ""AtomicComputer"",; ""BaseComputer"",; ""EnergyGradientHessianWfnReturn"",; ]. import abc; import copy; import logging; from typing import TYPE_CHECKING, Any, Dict, Optional, Tuple, Union. try:; from pydantic.v1 import Field, validator; except ImportError:; from pydantic import Field, validator. import qcelemental as qcel; from qcelemental.models import AtomicInput, AtomicResult, DriverEnum; from qcelemental.models.results import AtomicResultProtocols; qcel.models.molecule.GEOMETRY_NOISE = 13 # need more precision in geometries for high-res findif; import qcengine as qcng. from psi4 import core. from . import p4util. if TYPE_CHECKING:; import qcportal. logger = logging.getLogger(__name__). EnergyGradientHessianWfnReturn = Union[float, core.Matrix, Tuple[Union[float, core.Matrix], core.Wavefunction]]. [docs]; class BaseComputer(qcel.models.ProtoModel):; """"""Base class for ""computers"" that plan, run, and process QC tasks."""""". [docs]; @abc.abstractmethod; def compute(self):; pass. [docs]; @abc.abstractmethod; def plan(self):; pass. class Config(qcel.models.ProtoModel.Config):; extra = ""allow""; allow_mutation = True. [docs]; class AtomicComputer(BaseComputer):; """"""Computer for analytic single-geometry computations."""""". molecule: Any = Field(..., description=""The molecule to use in the computation.""); basis: str = Field(..., description=""The quantum chemistry basis set to evaluate (e.g., 6-31g, cc-pVDZ, ...).""); method: str = Field(..., description=""The quantum chemistry method to evaluate (e.g., B3LYP, MP2, ...).""); driver: DriverEnum = Field(..., description=""The resulting type of computation: energy, gradient, hessian, properties.""; ""Note for finite difference that this should be the target driver,",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/task_base.html:1807,Energy,EnergyGradientHessianWfnReturn,1807,psi4manual/1.9.x/_modules/psi4/driver/task_base.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/task_base.html,2,['Energy'],['EnergyGradientHessianWfnReturn']
Energy Efficiency,"licity through molecule; optional_molecule_name {...}), memory (through memory; value unit), computational method (through . If Cfour keywords; are specified with values that contradict the PSI4 input,; execution is halted.; As an example, the input below is set up to fail in four ways:; contradictory specification of memory, multiplicity, computational; method, and derivative level. Note, though, that the cfour_units; angstrom setting is permissible, since it concurs with the value; implied in the molecule block.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15memory 300 mb. molecule {; H; H 1 0.7; }. set basis 6-31g; set cfour_multiplicity 3 # clash with implicit singlet in molecule {} above; set cfour_units angstrom # no problem, consistent with molecule {} above; set cfour_memory_size 100000000 # clash with 300 mb above; set cfour_calc_level ccsd # clash with 'c4-scf' below; set cfour_deriv_level first # clash with energy() below (use gradient('c4-scf') to achieve this). energy('c4-scf'). Specifying anything in PSI4 format (molecule, basis, options,; method call) starts building a *CFOUR(...) directive for the; ZMAT file. Since the contents of the cfour {...} block are; blindly appended to any input interpreted from PSI4 format, mixing; of PSI4 and Cfour input formats likely will give rise to multiple; *CFOUR(...) directives in the prospective ZMAT, execution of; which will be trapped and halted. Proper uses for the cfour {...}; block are for the sandwich mode, where the entire ZMAT is enclosed,; or for extra directives like %excite*, which presently have no other; specification route. Specifying the basis is perhaps the regulated piece of input. Since; basis set names differ between PSI4 and Cfour and it’s not; practical to compare exponent-to-exponent, any input file with both; BASIS and CFOUR_BASIS keywords present will halt. Once; a basis set has been requested through BASIS, overriding the; default spherical/Cartesian setting must be done through; PUREAM ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/cfour-1.html:29211,energy,energy,29211,psi4manual/1.2.1/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/cfour-1.html,6,['energy'],['energy']
Energy Efficiency,"lid basis sets for second delta correction energy; if do_delta2:; if 'delta2_basis' in kwargs:; BSTD2, ZETD2 = _expand_bracketed_basis(kwargs['delta2_basis'].lower(), molecule=molstr); else:; raise ValidationError(""""""DELTA2 basis sets through keyword '%s' are required."""""" % ('delta2_basis')). # # Establish list of valid basis sets for third delta correction energy; # if do_delta3:; # if 'delta3_basis' in kwargs:; # BSTD3, ZETD3 = validate_bracketed_basis(kwargs['delta3_basis'].lower()); # else:; # raise ValidationError('DELTA3 basis sets through keyword \'%s\' are required.' % ('delta3_basis')); #; # # Establish list of valid basis sets for fourth delta correction energy; # if do_delta4:; # if 'delta4_basis' in kwargs:; # BSTD4, ZETD4 = validate_bracketed_basis(kwargs['delta4_basis'].lower()); # else:; # raise ValidationError('DELTA4 basis sets through keyword \'%s\' are required.' % ('delta4_basis')); #; # # Establish list of valid basis sets for fifth delta correction energy; # if do_delta5:; # if 'delta5_basis' in kwargs:; # BSTD5, ZETD5 = validate_bracketed_basis(kwargs['delta5_basis'].lower()); # else:; # raise ValidationError('DELTA5 basis sets through keyword \'%s\' are required.' % ('delta5_basis')). # Establish treatment for scf energy (validity check useless since python will catch it long before here); if (len(BSTR) == 3) and ('scf_basis' in kwargs):; cbs_scf_scheme = scf_xtpl_helgaker_3; elif (len(BSTR) == 2) and ('scf_basis' in kwargs):; cbs_scf_scheme = scf_xtpl_helgaker_2; elif (len(BSTR) == 1) and ('scf_basis' in kwargs):; cbs_scf_scheme = xtpl_highest_1; elif 'scf_basis' in kwargs:; raise ValidationError(""""""SCF basis sets of number %d cannot be handled."""""" % (len(BSTR))); elif do_corl:; cbs_scf_scheme = xtpl_highest_1; BSTR = [BSTC[-1]]; ZETR = [ZETC[-1]]; if 'scf_scheme' in kwargs:; cbs_scf_scheme = kwargs['scf_scheme']. # Establish treatment for correlation energy; if do_corl:; if len(BSTC) == 2:; cbs_corl_scheme = corl_xtpl_helgaker_2; elif len(B",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html:46313,energy,energy,46313,psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html,1,['energy'],['energy']
Energy Efficiency,"lid basis sets for second delta correction energy; if do_delta2:; if 'delta2_basis' in kwargs:; BSTD2, ZETD2 = _expand_bracketed_basis(kwargs['delta2_basis'].lower(), molecule=molstr); else:; raise ValidationError(""""""DELTA2 basis sets through keyword '%s' are required."""""" % ('delta2_basis')). # # Establish list of valid basis sets for third delta correction energy; # if do_delta3:; # if 'delta3_basis' in kwargs:; # BSTD3, ZETD3 = validate_bracketed_basis(kwargs['delta3_basis'].lower()); # else:; # raise ValidationError('DELTA3 basis sets through keyword \'%s\' are required.' % ('delta3_basis')); #; # # Establish list of valid basis sets for fourth delta correction energy; # if do_delta4:; # if 'delta4_basis' in kwargs:; # BSTD4, ZETD4 = validate_bracketed_basis(kwargs['delta4_basis'].lower()); # else:; # raise ValidationError('DELTA4 basis sets through keyword \'%s\' are required.' % ('delta4_basis')); #; # # Establish list of valid basis sets for fifth delta correction energy; # if do_delta5:; # if 'delta5_basis' in kwargs:; # BSTD5, ZETD5 = validate_bracketed_basis(kwargs['delta5_basis'].lower()); # else:; # raise ValidationError('DELTA5 basis sets through keyword \'%s\' are required.' % ('delta5_basis')). # Establish treatment for scf energy (validity check useless since python will catch it long before here); if (len(BSTR) == 3) and ('scf_basis' in kwargs):; cbs_scf_scheme = scf_xtpl_helgaker_3; elif (len(BSTR) == 2) and ('scf_basis' in kwargs):; cbs_scf_scheme = scf_xtpl_helgaker_2; elif (len(BSTR) == 1) and ('scf_basis' in kwargs):; cbs_scf_scheme = xtpl_highest_1; elif 'scf_basis' in kwargs:; raise ValidationError(""""""SCF basis sets of number %d cannot be handled."""""" % (len(BSTR))); elif do_corl:; cbs_scf_scheme = xtpl_highest_1; BSTR = [BSTC[-1]]; ZETR = [ZETC[-1]]; if 'scf_scheme' in kwargs:; cbs_scf_scheme = kwargs['scf_scheme']. # Establish treatment for correlation energy; if do_corl:; if len(BSTC) == 2:; cbs_corl_scheme = corl_xtpl_helgaker_2; else:; cbs",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:37812,energy,energy,37812,psi4manual/1.0.0/_modules/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html,2,['energy'],['energy']
Energy Efficiency,"line.; The syntax is:; 1>>> psi4 input-name output-name. If you give an input name but no output name, then the output name will; be the same as the input name (replacing any “.in” or “.dat” extension by “.out”). Sample Input Files¶; Below, we will provide a few simple input files as examples. A large; number of sample input files, covering everything from single-point energies; using density-functional theory to response properties from coupled-cluster; theory, can be found in the psi4/samples directory. Running a Basic Hartree–Fock Calculation¶; In our first example, we will consider a Hartree–Fock SCF computation; for the water molecule using a cc-pVDZ basis set. We will specify the; geometry of our water molecule using a standard Z-matrix.; # Any line starting with the # character is a comment line; #! Sample HF/cc-pVDZ H2O computation. memory 600 mb. molecule h2o {; O ; H 1 0.96; H 1 0.96 2 104.5; }. set basis cc-pVDZ; energy('scf'). Note; The memory and basis set specifications are placed before the; energy function is called. Any user options need to; be set before the procedure they are meant to affect. For your convenience, the above example can be found in; tu1-h2o-energy.; You can run it if you wish.; Once PSI4 is in your path (see the; User Configuration; section of the installation instructions), you can run this computation by typing; 1>>> psi4 input.dat output.dat. If everything goes well, the computation should complete and should report; a final restricted Hartree–Fock energy in a section like this:; 1; 2; 3Energy converged. @RHF Final Energy: -76.02663273410671. By default, the energy should be converged to about \(1.0 \times 10^{-6}\), so agreement; is only expected for about the first 6 digits after the decimal. If the; computation does not complete, there is probably a problem with the; compilation or installation of the program (see the installation; instructions in Sec. Compiling and Installing from Source).; This very simple input is sufficie",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/tutorial-1.html:2273,energy,energy,2273,psi4manual/1.2.1/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/tutorial-1.html,2,['energy'],['energy']
Energy Efficiency,"line.; The syntax is:; 1>>> psi4 input-name output-name. If you give an input name but no output name, then the output name will; be the same as the input name (replacing any ”.in” or ”.dat” extension by ”.out”). Sample Input Files¶; Below, we will provide a few simple input files as examples. A large; number of sample input files, covering everything from single-point energies; using density-functional theory to response properties from coupled-cluster; theory, can be found in the psi4/samples directory. Running a Basic Hartree–Fock Calculation¶; In our first example, we will consider a Hartree–Fock SCF computation; for the water molecule using a cc-pVDZ basis set. We will specify the; geometry of our water molecule using a standard Z-matrix.; # Any line starting with the # character is a comment line; #! Sample HF/cc-pVDZ H2O computation. memory 600 mb. molecule h2o {; O ; H 1 0.96; H 1 0.96 2 104.5; }. set basis cc-pVDZ; energy('scf'). Note; The memory and basis set specifications are placed before the; energy function is called. Any user options need to; be set before the procedure they are meant to affect. For your convenience, the above example can be found in; tu1-h2o-energy.; You can run it if you wish.; Once PSI4 is in your path (see the; User Configuration; section of the installation instructions), you can run this computation by typing; 1>>> psi4 input.dat output.dat. If everything goes well, the computation should complete and should report; a final restricted Hartree–Fock energy in a section like this:; 1; 2; 3Energy converged. @RHF Final Energy: -76.02663273410671. By default, the energy should be converged to about \(1.0 \times 10^{-6}\), so agreement; is only expected for about the first 6 digits after the decimal. If the; computation does not complete, there is probably a problem with the; compilation or installation of the program (see the installation; instructions in Sec. Compiling and Installing from Source).; This very simple input is sufficie",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/tutorial-1.html:2271,energy,energy,2271,psi4manual/1.1.0/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/tutorial-1.html,2,['energy'],['energy']
Energy Efficiency,"linear-scaling algorithm from; Trent M. Parker, revamped by Lori A. Burns. Z(self: psi4.core.Molecule, arg0: int) → float; Nuclear charge of atom. activate_all_fragments(self: psi4.core.Molecule) → None; Sets all fragments in the molecule to be active. add_atom(self: psi4.core.Molecule, arg0: float, arg1: float, arg2: float, arg3: float, arg4: str, arg5: float, arg6: float, arg7: str, arg8: int) → None; Adds to Molecule arg1 an atom with atomic number arg2, Cartesian coordinates in Bohr (arg3, arg4, arg5), atomic symbol arg6, mass arg7, charge arg8 (optional), and lineno arg9 (optional). atom_at_position(self: psi4.core.Molecule, arg0: float, arg1: float) → int; Tests to see if an atom is at the position arg2 with a given tolerance arg3. basis_on_atom(self: psi4.core.Molecule, arg0: int) → str; Gets the label of the orbital basis set on a given atom. center_of_mass(self: psi4.core.Molecule) → psi4.core.Vector3; Computes center of mass of molecule (does not translate molecule). charge(self: psi4.core.Molecule, arg0: int) → float; Gets charge of atom. clone(self: psi4.core.Molecule) → psi4.core.Molecule; Returns a new Molecule identical to arg1. com_fixed(self: psi4.core.Molecule) → bool; Get whether or not COM is fixed. create_molecule_from_string(arg0: str) → psi4.core.Molecule; Returns a new Molecule with member data from the geometry string arg1 in psi4 format. create_psi4_string_from_molecule(self: psi4.core.Molecule) → str; Gets a string reexpressing in input format the current states of the molecule. deactivate_all_fragments(self: psi4.core.Molecule) → None; Sets all fragments in the molecule to be inactive. distance_matrix(self: psi4.core.Molecule) → psi4.core.Matrix; Returns Matrix of interatom distances. extract_subsets(*args, **kwargs); Overloaded function. extract_subsets(self: psi4.core.Molecule, arg0: List[int], arg1: List[int]) -> psi4.core.Molecule. Returns copy of arg1 with arg2 fragments Real and arg3 fragments Ghost. extract_subsets(self: psi4.core.M",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/api/psi4.core.molecule.html:38144,charge,charge,38144,psi4manual/1.2.1/api/psi4.core.molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/api/psi4.core.molecule.html,1,['charge'],['charge']
Energy Efficiency,"lines define; two distance coordinates (bonds) and one bend coordinate. This file can be modified, and if present,; is used in subsequent optimizations. Since the multiple-fragment coordinates are still under; development, they are not documented here. However, if desired, one can change the value; of FRAG_MODE, generate the internal coordinates, and see how multiple; fragment systems are defined.; Coordinates may be frozen or fixed by adding an asterisk after the letter of the coordinate.; To optimize with the bond lengths fixed at their initial values, it is currently necessary to; generate and then modify the internal coordinate definitions as follows:; F 1 3; R* 1 2; R* 1 3; B 2 1 3. Convergence Criteria¶; Optking monitors five quantities to evaluate the progress of a geometry; optimization. These are (with their keywords) the change in energy; (MAX_ENERGY_G_CONVERGENCE), the maximum element of; the gradient (MAX_FORCE_G_CONVERGENCE), the root-mean-square; of the gradient (RMS_FORCE_G_CONVERGENCE), the maximum element; of displacement (MAX_DISP_G_CONVERGENCE), and the; root-mean-square of displacement (RMS_DISP_G_CONVERGENCE),; all in internal coordinates and atomic units. Usually, these options will not; be set directly. Primary control for geometry convergence lies with the keyword; G_CONVERGENCE which sets the aforementioned in accordance; with Table Geometry Convergence. Summary of sets of geometry optimization criteria available in PSI4. G_CONVERGENCE; Max Energy; Max Force; RMS Force; Max Disp; RMS Disp. NWCHEM_LOOSE [4];  . GAU_LOOSE [6];  . TURBOMOLE [4]. GAU [3] [6];  . CFOUR [4];  ;  .  ;  . QCHEM [1] [5].  .  . MOLPRO [2] [5].  .  . GAU_TIGHT [3] [6];  . GAU_VERYTIGHT [6];  . Footnotes. [1]Default. [2]Baker convergence criteria are the same. [3](1, 2) Counterpart NWCHEM convergence criteria are the same. [4](1, 2, 3) Convergence achieved when all active criteria are fulfilled. [5](1, 2, 3) Convergence achieved when Max Force and one of Max Energy or Ma",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/optking-1.html:7079,energy,energy,7079,psi4manual/4.0b2/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/optking-1.html,8,['energy'],['energy']
Energy Efficiency,"lines looking for fragment markers; ifrag = 0; iatom = 0; tempfrag = []; atomSym = """"; atomLabel = """"; zmatrix = False; for line in glines:. # handle fragment markers; if frag.match(line):; ifrag += 1; self.fragments.append([tempfrag[0], tempfrag[-1]]); self.fragment_types.append('Real'); tempfrag = []. # handle atom markers; else:; entries = re.split(r'\s+|\s*,\s*', line.strip()); atomm = atom.match(line.split()[0].strip().upper()); atomLabel = atomm.group('label'); atomSym = atomm.group('symbol'). # We don't know whether the @C or Gh(C) notation matched. Do a quick check.; ghostAtom = False if (atomm.group('gh1') is None and atomm.group('gh2') is None) else True. # Check that the atom symbol is valid; if not atomSym in el2z:; raise ValidationError('Molecule::create_molecule_from_string: Illegal atom symbol in geometry specification: %s' % (atomSym)). zVal = el2z[atomSym]; atomMass = el2mass[atomSym] if atomm.group('mass') is None else float(atomm.group('mass')); charge = float(zVal); if ghostAtom:; zVal = 0; charge = 0.0. # handle cartesians; if len(entries) == 4:; tempfrag.append(iatom); xval = self.get_coord_value(entries[1]); yval = self.get_coord_value(entries[2]); zval = self.get_coord_value(entries[3]); self.full_atoms.append(CartesianEntry(iatom, zVal, charge, \; atomMass, atomSym, atomLabel, \; xval, yval, zval)). # handle first line of Zmat; elif len(entries) == 1:; zmatrix = True; tempfrag.append(iatom); self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; atomMass, atomSym, atomLabel)). # handle second line of Zmat; elif len(entries) == 3:; zmatrix = True; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Molecule::create_molecule_from_string: Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); rval = self.get_coord_value(entries[2]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:18624,charge,charge,18624,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,2,['charge'],['charge']
Energy Efficiency,"linkage = kwargs['linkage']; else:; raise ValidationError('Optimize execution mode \'reap\' requires a linkage option.'); else:; raise ValidationError('Optimize execution mode \'%s\' not valid.' % (opt_mode)). # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); if not psi4.has_option_changed('SCF', 'E_CONVERGENCE'):; if procedures['energy'][lowername] == run_scf or procedures['energy'][lowername] == run_dft:; psi4.set_local_option('SCF', 'E_CONVERGENCE', 8); else:; psi4.set_local_option('SCF', 'E_CONVERGENCE', 10); if not psi4.has_option_changed('SCF', 'D_CONVERGENCE'):; if procedures['energy'][lowername] == run_scf or procedures['energy'][lowername] == run_dft:; psi4.set_local_option('SCF', 'D_CONVERGENCE', 8); else:; psi4.set_local_option('SCF', 'D_CONVERGENCE', 10). # Set post-scf convergence criteria (global will cover all correlated modules); if not psi4.has_global_option_changed('E_CONVERGENCE'):; if not procedures['energy'][lowername] == run_scf and not procedures['energy'][lowername] == run_dft:; psi4.set_global_option('E_CONVERGENCE', 8). # Does dertype indicate an analytic procedure both exists and is wanted?; if (dertype == 1):; # Nothing to it but to do it. Gradient information is saved; # into the current reference wavefunction; procedures['gradient'][lowername](lowername, **kwargs). if 'mode' in kwargs and kwargs['mode'].lower() == 'sow':; raise ValidationError('Optimize execution mode \'sow\' not valid for analytic gradient calculation.'); psi4.wavefunction().energy(). optstash.restore(); return psi4.get_variable('CURRENT ENERGY'). else:; # If not, perform finite difference of energies. opt_iter = 1; if ('opt_iter' in kwargs):; opt_iter = kwargs['opt_iter']. if opt_iter == 1:; print('Performing finite difference calculations'). # Obtain list of displacements; displacements = psi4.fd_geoms_1_0(); ndisp = len(displacements). # This version is pretty dependent on the reference geometry being last (as it ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/driver.html:34788,energy,energy,34788,psi4manual/4.0b5/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/driver.html,4,['energy'],['energy']
Energy Efficiency,"list, basis_list. def cbs_text_parser(total_method_name: str, **kwargs) -> Dict:; """"""; A text based parser of the CBS method string. Provided to handle ""method/basis""; specification of the requested calculations. Also handles ""simple"" (i.e.; one-method and one-basis) calls. Parameters; ----------; total_method_name; String in a ``""method/basis""`` syntax. Simple calls (e.g. ``""blyp/sto-3g""``) are; bounced out of CBS. More complex calls (e.g. ``""mp2/cc-pv[tq]z""`` or; ``""mp2/cc-pv[tq]z+D:ccsd(t)/cc-pvtz""``) are expanded by `_parse_cbs_gufunc_string()`; and pushed through :py:func:`~psi4.driver.cbs`. Returns; -------; dict of updated CBS keyword arguments; """""". ptype = kwargs.pop('ptype', None). # Sanitize total_method_name; total_method_name = total_method_name.lower(); total_method_name = total_method_name.replace(' ', ''). # Split into components; method_list, basis_list = _parse_cbs_gufunc_string(total_method_name). # Single energy call?; single_call = len(method_list) == 1; single_call &= '[' not in basis_list[0]; single_call &= ']' not in basis_list[0]. if single_call:; method_name = method_list[0]; basis = basis_list[0]. return {'method': method_name, 'basis': basis}. # Drop out for unsupported calls; if ptype is None:; raise ValidationError(""A CBS call was detected, but no ptype was passed in. Please alert a dev.""); elif ptype not in [""energy"", ""gradient"", ""hessian""]:; raise ValidationError(f""{ptype.title()}: Cannot extrapolate or delta correct {ptype} yet.""). # Catch kwarg issues for CBS methods only; user_dertype = kwargs.pop('dertype', None); cbs_verbose = kwargs.pop('cbs_verbose', False). # If we are not a single call, let CBS wrapper handle it!; cbs_kwargs = {}; cbs_kwargs['ptype'] = ptype; cbs_kwargs['verbose'] = cbs_verbose. if user_dertype is not None:; cbs_kwargs['dertype'] = user_dertype. # Find method and basis; metadata = []; if method_list[0] in ['scf', 'hf', 'c4-scf', 'c4-hf']:; stage = {}; stage['wfn'] = method_list[0]; stage['basis'] = basis_list",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_cbs.html:40809,energy,energy,40809,psi4manual/1.7.x/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_cbs.html,8,['energy'],['energy']
Energy Efficiency,"ll bodies in range [1, self.max_nbody] must be present exactly once. Number of items in outer list is how many different modelchems. Each inner list specifies what n-bodies to be run at the corresponding modelchem (e.g., `[[1, 2]]` has max_nbody=2 and 1-body and 2-body contributions computed at the same level of theory; `[[1], [2]]` has max_nbody=2 and 1-body and 2-body contributions computed at different levels of theory. An entry 'supersystem' means all higher order n-body effects up to the number of fragments. The n-body levels are effectively sorted in the outer list, and any 'supersystem' element is at the end."") # formerly nbody_list. embedding_charges: Dict[int, List[float]] = Field({}, description=""Atom-centered point charges to be used on molecule fragments whose basis sets are not included in the computation. Keys: 1-based index of fragment. Values: list of atom charges for that fragment.""). return_total_data: Optional[bool] = Field(None, description=""When True, returns the total data (energy/gradient/Hessian) of the system, otherwise returns interaction data. Default is False for energies, True for gradients and Hessians. Note that the calculation of total counterpoise corrected energies implies the calculation of the energies of monomers in the monomer basis, hence specifying ``return_total_data = True`` may carry out more computations than ``return_total_data = False``.""); quiet: bool = Field(False, description=""Whether to print/log formatted n-body energy analysis. Presently used by multi to suppress output. Candidate for removal from class once in-class/out-of-class functions sorted.""). task_list: Dict[str, SubTaskComputers] = {}. # Note that validation of user fields happens through typing and validator functions, so no class __init__ needed. @validator(""bsse_type"", pre=True); def set_bsse_type(cls, v):; if not isinstance(v, list):; v = [v]; # emulate ordered set; return list(dict.fromkeys([bt.lower() for bt in v])). @validator('molecule'); def set_m",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html:33719,energy,energy,33719,psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html,2,['energy'],['energy']
Energy Efficiency,"ll bodies in range [1, self.max_nbody] must be present exactly once. Number of items in outer list is how many different modelchems. Each inner list specifies what n-bodies to be run at the corresponding modelchem (e.g., `[[1, 2]]` has max_nbody=2 and 1-body and 2-body contributions computed at the same level of theory; `[[1], [2]]` has max_nbody=2 and 1-body and 2-body contributions computed at different levels of theory. An entry 'supersystem' means all higher order n-body effects up to the number of fragments. The n-body levels are effectively sorted in the outer list, and any 'supersystem' element is at the end."") # formerly nbody_list. embedding_charges: Dict[int, List[float]] = Field({}, description=""Atom-centered point charges to be used on molecule fragments whose basis sets are not included in the computation. Keys: 1-based index of fragment. Values: list of atom charges for that fragment.""). return_total_data: Optional[bool] = Field(None, description=""When True, returns the total data (energy/gradient/Hessian) of the system, otherwise returns interaction data. Default is False for energies, True for gradients and Hessians. Note that the calculation of total counterpoise corrected energies implies the calculation of the energies of monomers in the monomer basis, hence specifying ``return_total_data = True`` may carry out more computations than ``return_total_data = False``.""); quiet: bool = Field(False, description=""Whether to print/log formatted n-body energy analysis. Presently used by multi to suppress output. Candidate for removal from class once in-class/out-of-class functions sorted.""). task_list: Dict[str, SubTaskComputers] = {}. # Note that validation of user fields happens through typing and validator functions, so no class __init__ needed. [docs] @validator(""bsse_type"", pre=True); def set_bsse_type(cls, v):; if not isinstance(v, list):; v = [v]; # emulate ordered set; return list(dict.fromkeys([bt.lower() for bt in v])). [docs] @validator('molecul",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_nbody.html:33927,energy,energy,33927,psi4manual/1.7.x/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_nbody.html,2,['energy'],['energy']
Energy Efficiency,"ll bodies in range [1, self.max_nbody] must be present exactly once. Number of items in outer list is how many different modelchems. Each inner list specifies what n-bodies to be run at the corresponding modelchem (e.g., `[[1, 2]]` has max_nbody=2 and 1-body and 2-body contributions computed at the same level of theory; `[[1], [2]]` has max_nbody=2 and 1-body and 2-body contributions computed at different levels of theory. An entry 'supersystem' means all higher order n-body effects up to the number of fragments. The n-body levels are effectively sorted in the outer list, and any 'supersystem' element is at the end."") # formerly nbody_list. embedding_charges: Dict[int, List[float]] = Field({}, description=""Atom-centered point charges to be used on molecule fragments whose basis sets are not included in the computation. Keys: 1-based index of fragment. Values: list of atom charges for that fragment.""). return_total_data: Optional[bool] = Field(None, description=""When True, returns the total data (energy/gradient/Hessian) of the system, otherwise returns interaction data. Default is False for energies, True for gradients and Hessians. Note that the calculation of total counterpoise corrected energies implies the calculation of the energies of monomers in the monomer basis, hence specifying ``return_total_data = True`` may carry out more computations than ``return_total_data = False``.""); quiet: bool = Field(False, description=""Whether to print/log formatted n-body energy analysis. Presently used by multi to suppress output. Candidate for removal from class once in-class/out-of-class functions sorted.""). task_list: Dict[str, SubTaskComputers] = {}. # Note that validation of user fields happens through typing and validator functions, so no class __init__ needed. [docs]; @validator(""bsse_type"", pre=True); def set_bsse_type(cls, v):; if not isinstance(v, list):; v = [v]; # emulate ordered set; return list(dict.fromkeys([bt.lower() for bt in v])). [docs]; @validator('molec",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:34004,energy,energy,34004,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,6,['energy'],['energy']
Energy Efficiency,"ll correct, is so aged; as to be difficult to follow. Since quantum chemical methods in PSI4 are accessed through Python functions, and; most important quantities are available as PSI variables, it is straightforward; to create aliases to commonly run calculations or to define hybrid methods. The; psi4/psi4/driver/aliases.py file is intended for editing by the user for; this purpose.; As an example, the MP2.5 method; (which admittedly is already built in to PSI4); is the average of MP2 and MP3. The latter is; available through the arbitrary order MPn code and returns all lower energies; along with it in PSI variables. The following is basic code that will compute; and return the MP2.5 energy.; def run_mp2_5(name, **kwargs):. energy('mp3', **kwargs); e_scf = psi4.get_variable('SCF TOTAL ENERGY'); ce_mp2 = psi4.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = psi4.get_variable('MP3 CORRELATION ENERGY'). ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25. print """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); print """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25). return e_mp25. Compare the above to the method that resides in psi4/psi4/driver/aliases.py.; The rationale for the changes is indicated in the comments below.; def run_mp2_5(name, **kwargs):; lowername = name.lower() # handy variable with name keyword in lowercase; kwargs = kwargs_lower(kwargs) # removes case sensitivity in keyword names. # Run detci calculation and collect conventional quantities; energy('mp3', **kwargs); e_scf = psi4.get_variable('SCF TOTAL ENERGY'); ce_mp2 = psi4.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = psi4.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; psi4.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; psi4.set_variable('MP2.5 TOTAL ENE",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/quickaddalias-1.html:1391,energy,energy,1391,psi4manual/1.4.0/quickaddalias-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/quickaddalias-1.html,9,['energy'],['energy']
Energy Efficiency,"ll dmrcc, directing all screen output to the output file; try:; if PsiMod.outfile_name() == 'stdout':; retcode = subprocess.call('dmrcc', shell=True); else:; retcode = subprocess.call('dmrcc >> ' + current_directory + '/' + PsiMod.outfile_name(), shell=True). if retcode < 0:; print('MRCC was terminated by signal %d' % -retcode, file=sys.stderr); exit(1); elif retcode > 0:; print('MRCC errored %d' % retcode, file=sys.stderr); exit(1). except OSError as e:; print('Execution failed: %s' % e, file=sys.stderr); exit(1). # Restore the OMP_NUM_THREADS that the user set.; if omp_num_threads_found == True:; if PsiMod.has_option_changed('MRCC', 'MRCC_OMP_NUM_THREADS') == True:; os.environ['OMP_NUM_THREADS'] = omp_num_threads_user. # Scan iface file and grab the file energy.; e = 0.0; for line in file('iface'):; fields = line.split(); m = fields[1]; try:; e = float(fields[5]); if m == ""MP(2)"":; m = ""MP2""; PsiMod.set_variable(m + ' TOTAL ENERGY', e); PsiMod.set_variable(m + ' CORRELATION ENERGY', e - vscf); except ValueError:; continue. # The last 'e' in iface is the one the user requested.; PsiMod.set_variable('CURRENT ENERGY', e); PsiMod.set_variable('CURRENT CORRELATION ENERGY', e - vscf). # Load the iface file; iface = open('iface', 'r'); iface_contents = iface.read(). # Delete mrcc tempdir; os.chdir('..'); try:; # Delete unless we're told not to; if (keep == False and not('path' in kwargs)):; shutil.rmtree(mrcc_tmpdir); except OSError as e:; print('Unable to remove MRCC temporary directory %s' % e, file=sys.stderr); exit(1). # Revert to previous current directory location; os.chdir(current_directory). # Reopen output file; PsiMod.reopen_outfile(). # If we're told to keep the files or the user provided a path, do nothing.; if (keep != False or ('path' in kwargs)):; PsiMod.print_out('\nMRCC scratch files have been kept.\n'); PsiMod.print_out('They can be found in ' + mrcc_tmpdir). # Dump iface contents to output; PsiMod.print_out('\n'); banner('Full results from MRCC'); PsiM",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/proc.html:66902,ENERGY,ENERGY,66902,psi4manual/4.0b4/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/proc.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"ll previous levels.; (1) OpenMP/MKL Environment Variables. Deprecated since version 1.1: Environment variables OMP_NUM_THREADS and MKL_NUM_THREADS; do not affect threading in PSI4. (2) The -n Command Line Flag; To change the number of threads at runtime, the psi4 -n flag may be used. An; example is:; psi4 -i input.dat -o output.dat -n 4. which will run on four threads. Note that is is not available for PsiAPI mode of operation.; (3) Setting Thread Numbers in an Input; For more explicit control, the Process::environment class in PSI4 can; override the number of threads set by environment variables. This functionality; is accessed via the set_num_threads() function, which controls; both MKL and OpenMP thread numbers. The number of threads may be changed; multiple times in a PSI4 input file. An example input for this feature is:; # A bit small-ish, but you get the idea; molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 90.0; }. # Run from 1 to 4 threads, for instance, to record timings; for nthread in range(1, 5):; set_num_threads(nthread); energy(""scf/cc-pvdz""). In PsiAPI mode of operation, this syntax, psi4.set_num_threads(nthread), is; the primary way to control threading.; (4) Method-Specific Control; Even more control is possible in certain circumstances. For instance, the; threaded generation of AO density-fitted integrals involves a memory requirement; proportional to the number of threads. This requirement may exceed the total; memory of a small-memory node if all threads are involved in the generation of; these integrals. For general DF algorithms, the user may specify:; set MODULE_NAME df_ints_num_threads n. to explicitly control the number of threads used for integral formation. Setting; this variable to 0 (the default) uses the number of threads specified by the; set_num_threads() Psithon method or the default environmental variables. PBS job file¶; To run a PSI4 job on a PBS queueing system, you need to properly set up; all necessary variables in the PBS job file",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/external-1.html:13520,energy,energy,13520,psi4manual/1.4.0/external-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/external-1.html,9,['energy'],['energy']
Energy Efficiency,"ll reference; will be reset to UHF/UKS as needed.\n' % (db_name)). # Configuration based upon database keyword options; # Option symmetry- whether symmetry treated normally or turned off (currently req'd for dfmp2 & dft); db_symm = kwargs.get('symm', True). symmetry_override = 0; if db_symm is False:; symmetry_override = 1; elif db_symm is True:; pass; else:; raise ValidationError(""""""Symmetry mode '%s' not valid."""""" % (db_symm)). # Option mode of operation- whether db run in one job or files farmed out; db_mode = kwargs.pop('db_mode', kwargs.pop('mode', 'continuous')).lower(); kwargs['db_mode'] = db_mode. if db_mode == 'continuous':; pass; elif db_mode == 'sow':; pass; elif db_mode == 'reap':; db_linkage = kwargs.get('linkage', None); if db_linkage is None:; raise ValidationError(""""""Database execution mode 'reap' requires a linkage option.""""""); else:; raise ValidationError(""""""Database execution mode '%s' not valid."""""" % (db_mode)). # Option counterpoise- whether for interaction energy databases run in bsse-corrected or not; db_cp = kwargs.get('cp', False). if db_cp is True:; try:; database.ACTV_CP; except AttributeError:; raise ValidationError(""""""Counterpoise correction mode 'yes' invalid for database %s."""""" % (db_name)); else:; ACTV = database.ACTV_CP; elif db_cp is False:; pass; else:; raise ValidationError(""""""Counterpoise correction mode '%s' not valid."""""" % (db_cp)). # Option relaxed- whether for non-frozen-monomer interaction energy databases include deformation correction or not?; db_rlxd = kwargs.get('rlxd', False). if db_rlxd is True:; if db_cp is True:; try:; database.ACTV_CPRLX; database.RXNM_CPRLX; except AttributeError:; raise ValidationError('Deformation and counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CPRLX; RXNM = database.RXNM_CPRLX; elif db_cp is False:; try:; database.ACTV_RLX; except AttributeError:; raise ValidationError('Deformation correction mode \'yes\' invalid for database %s.' % (d",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/wrapper_database.html:11768,energy,energy,11768,psi4manual/1.3.2/_modules/psi4/driver/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/wrapper_database.html,18,['energy'],['energy']
Energy Efficiency,"ll this last; sup.allocate(); return sup. [docs]def build_b3lyp_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('B3LYP'); # Tab in, trailing newlines; sup.set_description(' B3LYP Hybrid-GGA Exchange-Correlation Functional\n'); # Tab in, trailing newlines; sup.set_citation(' P.J. Stephens et. al., J. Phys. Chem., 98, 11623-11627, 1994\n'). # Add member functionals; b3 = build_functional('B3_X'); b3.set_alpha(1.0); sup.add_x_functional(b3); lyp = build_functional('LYP_C'); lyp.set_alpha(0.81); vwn = build_functional('VWN3RPA_C'); vwn.set_alpha(0.19); sup.add_c_functional(vwn); sup.add_c_functional(lyp). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.2); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_b3lyp5_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('B3LYP5'); # Tab in, trailing newlines; sup.set_description(' B3LYP5 Hybrid-GGA Exchange-Correlation Functional\n'); # Tab in, trailing newlines; sup.set_citation(' P.J. Stephens et. al., J. Phys. Chem., 98, 11623-11627, 1994\n'). # Add member functionals; b3 = build_functional('B3_X'); b3.set_alpha(1.0); sup.add_x_functional(b3); lyp = build_functional('LYP_C'); lyp.set_alpha(0.81); vwn = build_functional('VWN5RPA_C'); vwn.set_alpha(0.19); sup.add_c_functional(lyp); sup.add_c_functional(vwn). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.2); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def buil",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/functional.html:30017,allocate,allocate,30017,psi4manual/4.0b5/_modules/functional.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/functional.html,2,['allocate'],['allocate']
Energy Efficiency,"ll-electron basis set to check frozen core. opt11; Transition-state optimizations of HOOH to both torsional transition states. cc9a; ROHF-CCSD(T) cc-pVDZ energy for the \(^2\Sigma^+\) state of the CN radical, with Z-matrix input. ci-multi; BH single points, checking that program can run multiple instances of DETCI in a single input, without an intervening clean() call. cc13d; Tests analytic CC2 gradients. mints10; H2 with tiny basis set, to test basis set parser’s handling of integers. fnocc6; Test method/basis with disk_df. dft-b3lyp; Check flavors of B3LYP (b3lyp3/b3lyp5) against other programs. pywrap-molecule; Check that C++ Molecule class and qcdb molecule class are reading molecule input strings identically. stability1; UHF->UHF stability analysis test for BH with cc-pVDZ Test direct SCF with and without symmetry, test PK without symmetry. mints6; Patch of a glycine with a methyl group, to make alanine, then DF-SCF energy calculation with the cc-pVDZ basis set. cc37; CC2(UHF)/cc-pVDZ energy of H2O+. cc36; CC2(RHF)/cc-pVDZ energy of H2O. cepa1; cc-pvdz H2O Test CEPA(1) Energy. scf-hess2; UHF STO-3G (Cartesian) and cc-pVDZ (spherical) water Hessian test, against Psi3 reference values. This test should match RHF values exactly. omp2-4; SCS-OMP2 cc-pVDZ geometry optimization for the H2O molecule. mom; Maximum Overlap Method (MOM) Test. MOM is designed to stabilize SCF convergence and to target excited Slater determinants directly. zaptn-nh2; ZAPT(n)/6-31G NH2 Energy Point, with n=2-25. scf-response2; Compute the dipole polarizability for water with custom basis set. tdscf-3; td-wb97x excitation energies of singlet states of h2o, wfn passing. cc52; CCSD Response for H2O2. omp3-3; OMP3 cc-pCVDZ energy with B3LYP initial guess for the NO radical. nbody-cp-gradient; Computation of CP-corrected water trimer gradient (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). mp2p5-grad1; MP2.5 cc-pVDZ gradient for the H2O molecule. dft-pbe0-2; Internal match to psi4, ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html:38749,energy,energy,38749,psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"llation),; PCMSolver can be obtained through conda install pcmsolver.; Then enable it as a feature with ENABLE_CheMPS2,; hint its location with CMAKE_PREFIX_PATH,; and rebuild PSI4 to detect PCMSolver and activate dependent code. To remove a conda installation, conda remove pcmsolver. Source. If using PSI4 built from source and you want PCMSolver built from; from source also,; enable it as a feature with ENABLE_CheMPS2,; and let the build system fetch and build it and activate dependent code. Using the polarizable continuum model¶; The inclusion of a PCM description of the solvent into your calculation; is achieved by setting PCM true in your input file.; PSI4 understands the additional option PCM_SCF_TYPE with possible values total; (the default) or separate.; The latter forces the separate handling of nuclear and electronic electrostatic potentials and; polarization charges. It is mainly useful for debugging. Note; At present PCM can only be used for energy calculations with SCF; wavefunctions and CC wavefunctions in the PTE approximation [Cammi:2009:164104]. Warning; The PCMSolver library cannot exploit molecular point group symmetry. The PCM model and molecular cavity are specified in a pcm section that has; to be explicitly typed in by the user. This additional section follows a syntax; that is slightly different from that of PSI4 and is fully documented; here; A typical input for a Hartree–Fock calculation with PCM would look like the following:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33molecule NH3 {; symmetry c1; N -0.0000000001 -0.1040380466 0.0000000000; H -0.9015844116 0.4818470201 -1.5615900098; H -0.9015844116 0.4818470201 1.5615900098; H 1.8031688251 0.4818470204 0.0000000000; units bohr; no_reorient; no_com; }. set {; basis STO-3G; scf_type pk; pcm true; pcm_scf_type total; }. pcm = {; Units = Angstrom; Medium {; SolverType = IEFPCM; Solvent = Water; }. Cavity {; RadiiSet =",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/pcmsolver-1.html:1959,energy,energy,1959,psi4manual/1.1.0/pcmsolver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/pcmsolver-1.html,2,['energy'],['energy']
Energy Efficiency,"llent efficiency and tractability; gains when using DF-MP2 in concert with a DF-SCF reference. An efficient,; threaded, disk-based DF-MP2 code is available in PSI4 for all single; reference types available in the SCF module.; MP2 defaults in PSI4 to the density-fitted code.; The support for MP2 by the DFMP2 module in PSI4 is detailed in; Table DFMP2 Capabilities. Even without; set qc_module dfmp2, methods will default to this module, but; alternate implementations and use of MP2_TYPE for performing; a MP2 with conventional integrals can be seen at other modules. Detailed capabilities of the DFMP2 module. “✓” runs analytically. Single underline “✓̲” is default module when QC_MODULE unspecified. Double underline “✓̳” is default algorithm type when type selector (e.g., CC_TYPE) unspecified.¶. ◻; ◻; name ↓ →; ◻; ◻. ◻; REFERENCE →; ◻; type[1] ↓ →; FREEZE_CORE[2]→. QC_MODULE=DFMP2 Capabilities. Restricted (RHF); Unrestricted (UHF); Restricted Open (ROHF). energy(); gradient()[3]; energy(); gradient()[3]; energy(); gradient()[3]. CV; DF; CD; CV; DF; CD; CV; DF; CD; CV; DF; CD; CV; DF; CD; CV; DF; CD. A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F. mp2[4]; MP2_TYPE. ✓̳; ✓̳. ✓̳; ✓̳. ✓̳; ✓̳. ✓̳; ✓̳. [1]; Algorithm type selection keyword below. Values to the right: conventional CV, density-fitted DF, and Cholesky-decomposed CD. [2]; Active orbital values to the right: all-electron A and frozen-core F. [3]; (1,2,3); Finite difference gradients are not marked explicitly by “∷”, but the capability can be gleaned from the energy availability. [4]; Also available for DFT references RKS/UKS. An example utilization of the code is:; molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; }. set basis cc-pvdz; set scf_type df; set freeze_core True. energy('mp2'). The energy('mp2') call to energy() executes; the predefined DF-MP2 procedure, first calling; the SCF module with a default RHF reference and DF algorithm for the; two-electr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/dfmp2.html:2509,energy,energy,2509,psi4manual/1.7.x/dfmp2.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/dfmp2.html,12,['energy'],['energy']
Energy Efficiency,"ller description. [T] CORRECTION ENERGY¶; The coupled-cluster bracket perturbative triples correction [E_h]. (T) CORRECTION ENERGY¶; The coupled-cluster perturbative triples correction [E_h]. (AT) CORRECTION ENERGY¶. A-(T) CORRECTION ENERGY¶; The coupled-cluster asymmetric perturbative triples correction [E_h]. AAA (T) CORRECTION ENERGY¶. AAB (T) CORRECTION ENERGY¶. ABB (T) CORRECTION ENERGY¶. BBB (T) CORRECTION ENERGY¶; Spin components of the UHF-based coupled-cluster perturbative triples correction [E_h]. ACPF DIPOLE¶; Dipole array [e a0] for the averaged coupled-pair functional level of theory, (3,). ACPF QUADRUPOLE¶; Redundant quadrupole array [e a0^2] for the averaged coupled-pair functional level of theory, (3, 3). ACPF TOTAL ENERGY¶. ACPF CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the averaged coupled-pair functional level of theory. ADC ROOT 0 -> ROOT n EXCITATION ENERGY¶. TD-fctl ROOT 0 -> ROOT n EXCITATION ENERGY¶; The excitation energy [E_h] from ground state to root n.; DFT functional labeled if canonical. ADC ROOT 0 (IN h) -> ROOT n (IN i) EXCITATION ENERGY¶. TD-fctl ROOT 0 (IN h) -> ROOT n (IN i) EXCITATION ENERGY¶; The excitation energy [E_h] from the ground state (which is of irrep h); to root n within irrep i.; DFT functional labeled if canonical. ADC ROOT 0 (h) -> ROOT n (i) EXCITATION ENERGY¶. TD-fctl ROOT 0 (h) -> ROOT n (i) EXCITATION ENERGY¶; The excitation energy [E_h] from the ground state (which is of irrep h); to root n (which is of irrep i).; DFT functional labeled if canonical. ADC ROOT 0 -> ROOT n EXCITATION ENERGY - h TRANSITION¶. TD-fctl ROOT 0 -> ROOT n EXCITATION ENERGY - h TRANSITION¶; The excitation energy [E_h] from the ground state to root n, and the; transition is of irrep h.; DFT functional labeled if canonical. ADC ROOT 0 -> ROOT n ELECTRIC TRANSITION DIPOLE MOMENT (LEN)¶. TD-fctl ROOT 0 -> ROOT n ELECTRIC TRANSITION DIPOLE MOMENT (LEN)¶; The electric transition dipole mo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html:1319,energy,energy,1319,psi4manual/1.7.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html,4,['energy'],['energy']
Energy Efficiency,"lls method in Stanton and Gauss’s CFOUR program [manual]. c4-scf; Hartree–Fock (HF). c4-mp2; 2nd-order Møller–Plesset perturbation theory (non-density-fitting) (MP2). c4-mp3; 3rd-order Møller–Plesset perturbation theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. PSI4 API: Linking C++ and Python; optimize. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.optimize.html:16431,energy,energy,16431,psi4manual/1.7.x/api/psi4.driver.optimize.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.optimize.html,4,['energy'],['energy']
Energy Efficiency,"lly displaced ozone, with Z-matrix input. dct6; DCT calculation for the triplet O2 using DC-06 and DC-12. Only two-step algorithm is tested. density-screen-2; RKS Density Matrix based-Integral Screening Test for benzene. psithon2; Accesses basis sets, databases, plugins, and executables in non-install locations. cc8a; ROHF-CCSD(T) cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Cartesian input. sapt-sf1; Tests the Psi4 SF-SAPT code. cbs-delta-energy; Extrapolated energies with delta correction. sapt-exch-ind-inf; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. dfmp2-freq2; DF-MP2 frequency by difference of energies for H2O. cc51; EOM-CC3/cc-pVTZ on H2O. dfccsdl1; DF-CCSDL cc-pVDZ energy for the H2O molecule. dfscf-bz2; Benzene Dimer DF-HF/cc-pVDZ. opt2; SCF DZ allene geometry optimization, with Cartesian input, first in c2v symmetry, then in Cs symmetry from a starting point with a non-linear central bond angle. olccd1; OLCCD cc-pVDZ energy for the H2O molecule. nbo; Generation of NBO file. cc50; EOM-CC3(ROHF) on CH radical with user-specified basis and properties for particular root. dfmp2-3; DF-MP2 cc-pVDZ frozen core gradient of benzene, computed at the DF-SCF cc-pVDZ geometry. pywrap-freq-e-sowreap; Finite difference of energies frequency, run in sow/reap mode. scf-guess-read3; Test if the the guess read in the same basis converges. dct2; DC-06 calculation for the He dimer. This performs a two-step update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the MO Basis. cubeprop; RHF orbitals and density for water. soscf-ref; Triple and Singlet Oxygen energy SOSCF, also tests non-symmetric density matrices. dfomp3-grad2; DF-OMP3 cc-pVDZ gradients for the H2O+ cation. dfmp2-fc; Kr–Kr nocp energies with all-electron basis set to check frozen core. opt11; Transition-state optimizations of HOOH to both torsional transition states. cc9a; ROHF-CCSD(T) cc-pVDZ energy for the \(^2",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html:36914,energy,energy,36914,psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"lly from the calling Psithon function. Type: string; Possible Values: DETCI, CI, ZAPTN, DETCAS, CASSCF, RASSCF; Default: DETCI. Expert Specifying the CI Space¶. EX_ALLOW¶. An array of length EX_LEVEL specifying whether each excitation type (S,D,T, etc.) is allowed (1 is allowed, 0 is disallowed). Used to specify non-standard CI spaces such as CIST. Type: array; Default: No Default. MIXED¶. Do allow “mixed” RAS II/RAS III excitations into the CI space? If FALSE, then if there are any electrons in RAS III, then the number of holes in RAS I cannot exceed the given excitation level EX_LEVEL. Type: boolean; Default: true. MIXED4¶. Do allow “mixed” excitations involving RAS IV into the CI space. Useful to specify a split-virtual CISD[TQ] computation. If FALSE, then if there are any electrons in RAS IV, then the number of holes in RAS I cannot exceed the given excitation level EX_LEVEL. Type: boolean; Default: true. R4S¶. Do restrict strings with in RAS IV? Useful to reduce the number of strings required if MIXED4=true, as in a split-virutal CISD[TQ] computation. If more than one electron is in RAS IV, then the holes in RAS I cannot exceed the number of particles in RAS III + RAS IV (i.e., EX_LEVEL , or else the string is discarded. Type: boolean; Default: false. RAS1¶. An array giving the number of orbitals per irrep for RAS1. Type: array; Default: No Default. RAS2¶. An array giving the number of orbitals per irrep for RAS2. Type: array; Default: No Default. RAS3¶. An array giving the number of orbitals per irrep for RAS3. Type: array; Default: No Default. RAS4¶. An array giving the number of orbitals per irrep for RAS4. Type: array; Default: No Default. SF_RESTRICT¶. Do eliminate determinants not valid for spin-complete spin-flip CI’s? [see J. S. Sears et al, J. Chem. Phys. 118, 9084-9094 (2003)]. Type: boolean; Default: false. Expert Diagonalization Methods¶. H0_BLOCKSIZE¶. This parameter specifies the size of the H0 block of the Hamiltonian which is solved exactly. The",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodir_options_c/module__detci-1.html:12471,reduce,reduce,12471,psi4manual/4.0b2/autodir_options_c/module__detci-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodir_options_c/module__detci-1.html,16,['reduce'],['reduce']
Energy Efficiency,"loat, z: float) → None¶; Add a charge Z at (x,y,z). appendCharges(self: psi4.core.ExternalPotential, arg0: List[Tuple[float, float, float, float]]) → None¶; Append a vector of charge tuples to a current ExternalPotential. clear(self: psi4.core.ExternalPotential) → None¶; Reset the field to zero (eliminates all entries). computeExternExternInteraction(self: psi4.core.ExternalPotential, arg0: psi4.core.ExternalPotential) → float¶; Compute the interaction between this potential and other external potential. computeNuclearEnergy(self: psi4.core.ExternalPotential, arg0: psi4.core.Molecule) → float¶; Compute the contribution to the nuclear repulsion energy for the given molecule. computePotentialMatrix(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet) → psi4.core.Matrix¶; Compute the external potential matrix in the given basis set. getCharges(self: psi4.core.ExternalPotential) → List[Tuple[float, float, float, float]]¶; Get the vector of charge tuples. gradient_on_charges(self: psi4.core.ExternalPotential) → psi4.core.Matrix¶; Get the gradient on the embedded charges. print_out(self: psi4.core.ExternalPotential) → None¶; Print python print helper to the outfile. setName(self: psi4.core.ExternalPotential, arg0: str) → None¶; Sets the name. table of contents. ExternalPotential; ExternalPotential; ExternalPotential.addBasis(); ExternalPotential.addCharge(); ExternalPotential.appendCharges(); ExternalPotential.clear(); ExternalPotential.computeExternExternInteraction(); ExternalPotential.computeNuclearEnergy(); ExternalPotential.computePotentialMatrix(); ExternalPotential.getCharges(); ExternalPotential.gradient_on_charges(); ExternalPotential.print_out(); ExternalPotential.setName(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. PSI4 API: Linking C++ and Python; ExternalPotential. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/api/psi4.core.ExternalPotential.html:2500,charge,charges,2500,psi4manual/1.9.x/api/psi4.core.ExternalPotential.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.ExternalPotential.html,2,['charge'],['charges']
Energy Efficiency,"loats like; convergences. The function ~psi4.core.clean_options that reinitializes; all options may also be useful to separate calculations in a PsiAPI; session.; psi4.set_options({; 'scf_type': 'pk',; 'e_convergence': 1.e-5,; 'soscf': True,; 'optking__geom_maxiter': 50; }). Basis Sets¶. Basis Sets; Built-In Basis Sets; Mixing Basis Sets; Decontracted Basis Sets; User-Defined Basis Sets; Inputting effective core potentials (ECPs). PSI Variables¶; To harness the power of Python, PSI4 makes the most pertinent results; of each computation available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of; H2 and H atom:; molecule h2 {; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h {; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol * (2*h_energy - h2_energy); print ""De=%f"" % D_e. The energy() function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation.; Generally, there are multiple quantities of interest. Appendix; PSI Variables by Module lists PSI variables variables set by each; module, and PSI Variables by Alpha defines them. These can be; accessed through the get_variable() function. For example, after; performing a density fitted MP2 computation, both the spin component; scaled energy and the unscaled MP2 energy are made available:; e_mp2 = get_variable('MP2 TOTAL ENERGY'); e_scs_mp2 = get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command print_variables(). Note that PSI variables; are cleared at the start of each energy(), etc. in an input; file by clean_variables().; So if you run",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/psithoninput-1.html:7698,energy,energy,7698,psi4manual/1.4.0/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/psithoninput-1.html,16,['energy'],['energy']
Energy Efficiency,"lobal options (e.g., the local option set by set scf scf_type df will not be respected). Note; To access a database that is not embedded in a PSI4; distribution, add the path to the directory containing the database; to the environment variable PYTHONPATH. Parameters:; name (string) – 'scf' || 'sapt0' || 'ccsd(t)' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). db_name (string) – 'BASIC' || 'S22' || 'HTBH' || etc.; Second argument, usually unlabeled. Indicates the requested database; name, matching (case insensitive) the name of a python file in; psi4/share/databases or PYTHONPATH. Consult that; directory for available databases and literature citations. func (function) – \(\Rightarrow\) energy \(\Leftarrow\) || optimize || cbs; Indicates the type of calculation to be performed on each database; member. The default performs a single-point energy('name'), while; optimize perfoms a geometry optimization on each reagent, and; cbs performs a compound single-point energy. If a nested series; of python functions is intended (see Function Intercalls), use; keyword db_func instead of func. mode (string) – \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; Indicates whether the calculations required to complete the; database are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. cp (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicates whether counterpoise correction is employed in computing; interaction energies. Use this option and NOT the cp(); function for BSSE correction in database(). Option available; (See Available Databases) only for databases of bimolecular complexes. rlxd (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicates whether correction for deformation energy is; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/db-1.html:1958,energy,energy,1958,psi4manual/1.2.1/db-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/db-1.html,12,['energy'],['energy']
Energy Efficiency,"lobal_option(""FRAC_OCC"", [LUMO]); PsiMod.set_global_option(""FRAC_VAL"", [occ]) . E = energy('scf'); C = 1; if (E == 0.0):; E = PsiMod.get_variable('SCF ITERATION ENERGY'); C = 0. if (LUMO > 0):; ref = PsiMod.reference_wavefunction(); eps = ref.epsilon_a(); potentials.append(eps[int(LUMO)-1]); else:; ref = PsiMod.reference_wavefunction(); eps = ref.epsilon_b(); potentials.append(eps[-int(LUMO)-1]). occs.append(occ); energies.append(E); convs.append(C). PsiMod.set_global_option(""FRAC_START"", 2); PsiMod.set_global_option(""FRAC_LOAD"", True); PsiMod.set_global_option(""GUESS"", ""READ""); PsiMod.set_global_option(""FRAC_DIIS"", frac_diis); PsiMod.set_global_option(""DF_INTS_IO"", ""LOAD""). # => Run the neutral next <= #. mol.set_molecular_charge(charge0); mol.set_multiplicity(mult0). # Burn the neutral in with hf, if requested <= #. if (not continuous_guess):; PsiMod.set_global_option(""GUESS"", old_guess); if (hf_guess):; PsiMod.set_global_option(""FRAC_START"", 0); PsiMod.set_global_option(""REFERENCE"",""UHF""); energy('scf'); PsiMod.set_global_option(""REFERENCE"",""UKS""); PsiMod.set_global_option(""GUESS"", ""READ""); PsiMod.set_global_option(""FRAC_LOAD"", False). PsiMod.set_global_option(""FRAC_START"", frac_start); PsiMod.set_global_option(""FRAC_RENORMALIZE"", True). for occ in HOMO_occs:; ; PsiMod.set_global_option(""FRAC_OCC"", [HOMO]); PsiMod.set_global_option(""FRAC_VAL"", [occ]) . E = energy('scf'); C = 1; if (E == 0.0):; E = PsiMod.get_variable('SCF ITERATION ENERGY'); C = 0. if (LUMO > 0):; ref = PsiMod.reference_wavefunction(); eps = ref.epsilon_a(); potentials.append(eps[int(HOMO)-1]); else:; ref = PsiMod.reference_wavefunction(); eps = ref.epsilon_b(); potentials.append(eps[-int(HOMO)-1]). occs.append(occ - 1.0); energies.append(E); convs.append(C). PsiMod.set_global_option(""FRAC_START"", 2); PsiMod.set_global_option(""FRAC_LOAD"", True); PsiMod.set_global_option(""GUESS"", ""READ""); PsiMod.set_global_option(""FRAC_DIIS"", frac_diis); PsiMod.set_global_option(""DF_INTS_IO"", ""LOAD""). PsiMod.set_g",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/frac.html:4537,energy,energy,4537,psi4manual/4.0b2/_modules/frac.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/frac.html,4,['energy'],['energy']
Energy Efficiency,"lobal_option('BASIS', '%s')\n"""""" % (mc['f_basis']); commands += """"""core.set_global_option('WRITER_FILE_LABEL', '%s')\n"""""" % \; (user_writer_file_label + ('' if user_writer_file_label == '' else '-') + mc['f_wfn'].lower() + '-' + mc['f_basis'].lower().replace('*', 's')); exec(commands). # Stash and set options if any; if mc[""f_options""]:; optionstash = p4util.OptionsState(*[[opt] for opt in list(mc[""f_options""])]); for k, v, in mc[""f_options""].items():; core.set_global_option(k.upper(), v); else:; optionstash = False. # Make energy(), etc. call; response = func(molecule=molecule, **kwargs); if ptype == 'energy':; mc['f_energy'] = response; elif ptype == 'gradient':; mc['f_gradient'] = response; mc['f_energy'] = core.variable('CURRENT ENERGY'); if verbose > 1:; mc['f_gradient'].print_out(); elif ptype == 'hessian':; mc['f_hessian'] = response; mc['f_energy'] = core.variable('CURRENT ENERGY'); if verbose > 1:; mc['f_hessian'].print_out(); Njobs += 1; if verbose > 1:; core.print_out(""\nCURRENT ENERGY: %14.16f\n"" % mc['f_energy']). # Restore modified options; if optionstash:; optionstash.restore(). # Fill in energies for subsumed methods; if ptype == 'energy':; for wfn in VARH[mc['f_wfn']]:; for job in JOBS_EXT:; if (wfn == job['f_wfn']) and (mc['f_basis'] == job['f_basis']) and \; (mc['f_options'] == job['f_options']):; job['f_energy'] = core.variable(VARH[wfn][wfn]). if verbose > 1:; core.print_variables(); core.clean_variables(); core.clean(). # Copy data from 'run' to 'obtained' table; for mce in JOBS_EXT:; if (mc['f_wfn'] == mce['f_wfn']) and (mc['f_basis'] == mce['f_basis']) and \; (mc['f_options'] == mce['f_options']):; mce['f_energy'] = mc['f_energy']; mce['f_gradient'] = mc['f_gradient']; mce['f_hessian'] = mc['f_hessian']. psioh.set_specific_retention(psif.PSIF_SCF_MOS, False). # Build string of title banner; instructions = ""\n"" + p4util.banner(f"" CBS Results{':' + label if label else ''} "", strNotOutfile=True) + ""\n""; core.print_out(instructions). # Insert obta",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:54514,ENERGY,ENERGY,54514,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,2,['ENERGY'],['ENERGY']
Energy Efficiency,"lobal_option_python does not recognize keyword %s"" % key). if EXTERN is None:; core.EXTERN = None; core.set_global_option(""EXTERN"", False); elif isinstance(EXTERN, core.ExternalPotential):; # Well this is probably the worst hack I have done, thats saying something; core.EXTERN = EXTERN; core.set_global_option(""EXTERN"", True); else:; raise ValidationError(""Options: set_global_option_python can either be a NULL or External Potential object""). core.set_global_option_python = _core_set_global_option_python. ## QCvar helps. _qcvar_transitions = {; # old: (replacement, release after next); ""SCSN-MP2 CORRELATION ENERGY"": (""SCS(N)-MP2 CORRELATION ENERGY"", 1.5),; ""SCSN-MP2 TOTAL ENERGY"": (""SCS(N)-MP2 TOTAL ENERGY"", 1.5),; ""MAYER_INDICES"": (""MAYER INDICES"", 1.5),; ""WIBERG_LOWDIN_INDICES"": (""WIBERG LOWDIN INDICES"", 1.5),; ""LOWDIN_CHARGES"": (""LOWDIN CHARGES"", 1.5),; ""MULLIKEN_CHARGES"": (""MULLIKEN CHARGES"", 1.5),; ""(AT) CORRECTION ENERGY"": (""A-(T) CORRECTION ENERGY"", 1.5),; ""CCSD(AT) TOTAL ENERGY"": (""A-CCSD(T) TOTAL ENERGY"", 1.5),; ""CCSD(AT) CORRELATION ENERGY"": (""A-CCSD(T) CORRELATION ENERGY"", 1.5),; ""CP-CORRECTED 2-BODY INTERACTION ENERGY"": (""CP-CORRECTED INTERACTION ENERGY THROUGH 2-BODY"", 1.7),; ""CP-CORRECTED 3-BODY INTERACTION ENERGY"": (""CP-CORRECTED INTERACTION ENERGY THROUGH 3-BODY"", 1.7),; ""CP-CORRECTED 4-BODY INTERACTION ENERGY"": (""CP-CORRECTED INTERACTION ENERGY THROUGH 4-BODY"", 1.7),; ""CP-CORRECTED 5-BODY INTERACTION ENERGY"": (""CP-CORRECTED INTERACTION ENERGY THROUGH 5-BODY"", 1.7),; ""NOCP-CORRECTED 2-BODY INTERACTION ENERGY"": (""NOCP-CORRECTED INTERACTION ENERGY THROUGH 2-BODY"", 1.7),; ""NOCP-CORRECTED 3-BODY INTERACTION ENERGY"": (""NOCP-CORRECTED INTERACTION ENERGY THROUGH 3-BODY"", 1.7),; ""NOCP-CORRECTED 4-BODY INTERACTION ENERGY"": (""NOCP-CORRECTED INTERACTION ENERGY THROUGH 4-BODY"", 1.7),; ""NOCP-CORRECTED 5-BODY INTERACTION ENERGY"": (""NOCP-CORRECTED INTERACTION ENERGY THROUGH 5-BODY"", 1.7),; ""VMFC-CORRECTED 2-BODY INTERACTION ENERGY"": (""VMFC-CORRECTED INTERACTION ENERGY",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html:19000,ENERGY,ENERGY,19000,psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html,10,['ENERGY'],['ENERGY']
Energy Efficiency,logram relationship [kg] uncertainty=0.000 000 091 e-51. inverse_fine_structure_constant; 137.035999139; inverse fine-structure constant [] uncertainty=0.000 000 031. inverse_meter_atomic_mass_unit_relationship; 1.33102504900E-15; inverse meter-atomic mass unit relationship [u] uncertainty=0.000 000 000 61 e-15. inverse_meter_electron_volt_relationship; 0.0000012398419739; inverse meter-electron volt relationship [eV] uncertainty=0.000 000 0076 e-6. inverse_meter_hartree_relationship; 4.556335252767E-8; inverse meter-hartree relationship [E_h] uncertainty=0.000 000 000 027 e-8. inverse_meter_hertz_relationship; 299792458; inverse meter-hertz relationship [Hz] uncertainty=(exact). inverse_meter_joule_relationship; 1.986445824E-25; inverse meter-joule relationship [J] uncertainty=0.000 000 024 e-25. inverse_meter_kelvin_relationship; 0.0143877736; inverse meter-kelvin relationship [K] uncertainty=0.000 000 83 e-2. inverse_meter_kilogram_relationship; 2.210219057E-42; inverse meter-kilogram relationship [kg] uncertainty=0.000 000 027 e-42. inverse_of_conductance_quantum; 12906.4037278; inverse of conductance quantum [ohm] uncertainty=0.000 0029. Josephson_constant; 4.835978525E+14; Josephson constant [Hz V^{-1}] uncertainty=0.0030 e9. joule_atomic_mass_unit_relationship; 6700535363; joule-atomic mass unit relationship [u] uncertainty=0.000 000 082 e9. joule_electron_volt_relationship; 6.241509126E+18; joule-electron volt relationship [eV] uncertainty=0.000 000 038 e18. joule_hartree_relationship; 2.293712317E+17; joule-hartree relationship [E_h] uncertainty=0.000 000 028 e17. joule_hertz_relationship; 1.509190205E+33; joule-hertz relationship [Hz] uncertainty=0.000 000 019 e33. joule_inverse_meter_relationship; 5.034116651E+24; joule-inverse meter relationship [m^{-1}] uncertainty=0.000 000 062 e24. joule_kelvin_relationship; 7.2429731E+22; joule-kelvin relationship [K] uncertainty=0.000 0042 e22. joule_kilogram_relationship; 1.112650056E-17; joule-kilogram relationshi,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodoc_physconst-1.html:17567,meter,meter-kilogram,17567,psi4manual/1.3.2/autodoc_physconst-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodoc_physconst-1.html,11,['meter'],['meter-kilogram']
Energy Efficiency,"lorie to joule conversion factor ; psi_dipmom_au2si = 8.47835281E-30 # Atomic units to SI units (Cm) conversion factor for dipoles ; psi_dipmom_au2debye = 2.54174623 # Atomic units to Debye conversion factor for dipoles ; psi_dipmom_debye2si = 3.335640952E-30 # Debye to SI units (Cm) conversion factor for dipoles ; psi_c_au = 137.035999679 # Speed of light in atomic units ; psi_hartree2ev = 27.21138 # Hartree to eV conversion factor ; psi_hartree2wavenumbers = 219474.6 # Hartree to cm$^{-1}$ conversion factor ; psi_hartree2kcalmol = 627.5095 # Hartree to kcal mol$^{-1}$ conversion factor ; psi_hartree2MHz = 6.579684E9 # Hartree to MHz conversion factor ; psi_kcalmol2wavenumbers = 349.7551 # kcal mol$^{-1}$ to cm$^{-1}$ conversion factor ; psi_e0 = 8.854187817E-12 # Vacuum permittivity (Fm$^{-1}$) ; psi_na = 6.02214179E23 # Avagadro's number ; psi_me = 9.10938215E-31 # Electron rest mass (in kg) . wrappers¶; Module with functions that call the four main driver; functions: driver.energy, driver.optimize,; driver.response, and driver.frequency. auto_fragments(name, **kwargs)[source]¶; Detects fragments if the user does not supply them.; Currently only used for the WebMO implementation of SAPT; usage: auto_fragments(‘’). call_function_in_1st_argument(funcarg, **largs)[source]¶; Function to make primary function call to energy(), opt(), etc.; with options dictionary largs.; Useful when funcarg to call is stored in variable. convert(p, symbol)[source]¶. reconstitute_bracketed_basis(needarray)[source]¶; Function to reform a bracketed basis set string from a sequential series; of basis sets (e.g, form ‘cc-pv[q5]z’ from array [cc-pvqz, cc-pv5z]). The; basis set array is extracted from the f_basis field of a NEED dictionary in; complete_basis_set(). Result is used to print a nicely; formatted basis set string in the results table. split_menial(menial)[source]¶; Function used by complete_basis_set() to separate; menial ‘scftot’ into [scf, tot] and ‘mp2corl’ into [mp2, corl]. tb",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodoc_driver-1.html:11509,energy,energy,11509,psi4manual/4.0b2/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodoc_driver-1.html,6,['energy'],['energy']
Energy Efficiency,"lose_all(); Close all open plugins. plugin_load(arg0); Load the plugin of name arg0. prepare_options_for_module(name); Sets up the options library to return options pertaining to the module or plugin name (e.g. SCF). print_global_options(); Prints the currently set global (all modules) options to the output file. print_options(); Prints the currently set options (to the output file) for the current module. print_out(arg0); Prints a string (using sprintf-like notation) to the output file. print_variables(); Prints to output file all QCVariables that have been set in global memory. psi_top_srcdir(); Returns the location of the source code. psimrcc(arg0); Runs the multireference coupled cluster code. reopen_outfile(); Reopens the output file. revoke_global_option_changed(key); Clear the touched status for keyword key at global (all-module) scope. revoke_local_option_changed(module, key); Clear the touched status for keyword key at module scope. sapt(dimer_wfn, monoa_wfn, monob_wfn); Runs the symmetry adapted perturbation theory code. scalar_variable(key); Returns the double QCVariable key (case-insensitive); prefer variable(). scalar_variables(); Returns dictionary of all double QCVariables; prefer variables(). scatter(arg0, arg1, arg2, arg3, arg4); New Scatter function. scfgrad(ref_wfn); Run scfgrad, which is a specialized DF-SCF gradient program. scfhess(ref_wfn); Run scfhess, which is a specialized DF-SCF hessian program. set_active_molecule(molecule); Activates a previously defined molecule in global memory so next computations use it. set_array_variable(key, value); Sets the requested (case-insensitive) Matrix QCVariable; prefer set_variable(). set_datadir(psidatadir); Sets the path to shared text resources, PSIDATADIR. set_global_option(*args, **kwargs); Overloaded function. set_global_option_python(key, EXTERN); This is a fairly hacky way to get around EXTERN issues. set_local_option(*args, **kwargs); Overloaded function. set_local_option_python(key, value); Sets",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/psi4api.html:8401,adapt,adapted,8401,psi4manual/1.9.x/psi4api.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/psi4api.html,2,['adapt'],['adapted']
Energy Efficiency,"lose_outfile(); Closes the output file. dcft(arg0); Runs the density cumulant functional theory code. del_array_variable(arg0); Removes the requested (case-insensitive) Matrix QC variable. del_scalar_variable(arg0); Removes the requested (case-insensitive) double QC variable. del_variable(key). detci(arg0); Runs the determinant-based configuration interaction code. dfmp2(arg0); Runs the DF-MP2 code. dfocc(arg0); Runs the density-fitted orbital optimized CC codes. dmrg(arg0); Runs the DMRG code. doublet(A, B, transA, transB); Returns the multiplication of two matrices A and B, with options to transpose each beforehand. fcidump_tei_helper(nirrep, restricted, …); Write integrals to file in FCIDUMP format. finalize(). flush_outfile(); Flushes the output file. fnocc(arg0); Runs the fno-ccsd(t)/qcisd(t)/mp4/cepa energy code. get_active_molecule(); Returns the currently active molecule object. get_array_variable(key). get_array_variables(). get_atomic_point_charges(); Returns the most recently computed atomic point charges, as a double * object. get_datadir(); Sets the path to shared text resources, PSIDATADIR. get_global_option(arg0); Given a string of a keyword name arg1, returns the value associated with the keyword from the global options. get_global_option_list(); Returns a list of all global options. get_gradient(). get_legacy_gradient(); Returns the global gradient as a (nat, 3) Matrix object. get_legacy_molecule(); Returns the currently active molecule object. get_local_option(arg0, arg1); Given a string of a keyword name arg2 and a particular module arg1, returns the value associated with the keyword in the module options scope. get_memory(); Returns the amount of memory available to Psi (in bytes). get_num_threads(); Returns the number of threads to use in SMP parallel computations. get_option(arg0, arg1); Given a string of a keyword name arg2 and a particular module arg1, returns the local value associated with the keyword if it’s been set, else the global value ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psi4api-1.html:294882,charge,charges,294882,psi4manual/1.3.2/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psi4api-1.html,2,['charge'],['charges']
Energy Efficiency,"losed-shell references; in the FNOCC module. Many-body perturbation theory¶; QCI and CC methods are closely related to perturbation theory, and the; MP2, MP3, and MP4(SDQ) correlation energies can be obtained as a free; by-product of a CCSD or QCISD computation. The following is an; example of the results for a computation run with the call; energy('fno-qcisd') to energy():; QCISD iterations converged!. OS MP2 FNO correction: -0.000819116338; SS MP2 FNO correction: -0.000092278158; MP2 FNO correction: -0.000911394496. OS MP2 correlation energy: -0.166478414245; SS MP2 correlation energy: -0.056669079827; MP2 correlation energy: -0.223147494072; * MP2 total energy: -76.258836941658. OS MP2.5 correlation energy: -0.171225850256; SS MP2.5 correlation energy: -0.054028401038; MP2.5 correlation energy: -0.225254251294; * MP2.5 total energy: -76.260943698880. OS MP3 correlation energy: -0.175973286267; SS MP3 correlation energy: -0.051387722248; MP3 correlation energy: -0.227361008515; * MP3 total energy: -76.263050456101. OS MP4(SDQ) correlation energy: -0.180324322304; SS MP4(SDQ) correlation energy: -0.048798468084; MP4(SDQ) correlation energy: -0.230995119324; * MP4(SDQ) total energy: -76.266684566910. OS QCISD correlation energy: -0.181578117924; SS QCISD correlation energy: -0.049853548145; QCISD correlation energy: -0.231431666069; * QCISD total energy: -76.267121113654. The first set of energies printed corresponds to the second-order FNO; correction mentioned previously. Results for many-body perturbation; theory through partial fourth order are then provided.; The notation MP4(SDQ) indicates that we have included all contributions to; the correlation energy through fourth order, with the exception of that; from connected triple excitations.; One need not run a full QCISD or CCSD computation to obtain these; perturbation theory results. The keywords for invoking perturbation; theory computations are given below in; Table FNOCC Methods. Full MP4 correlation; energ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/fnocc-1.html:5910,energy,energy,5910,psi4manual/1.4.0/fnocc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/fnocc-1.html,15,['energy'],['energy']
Energy Efficiency,"lowed if it is a single or double. fnocc1; Test QCISD(T) for H2O/cc-pvdz Energy. cc28; CCSD/cc-pVDZ optical rotation calculation (length gauge only) on Z-mat H2O2. opt1; SCF STO-3G geometry optimzation, with Z-matrix input. cc10; ROHF-CCSD cc-pVDZ energy for the state of the CN radical. casscf-sa-sp; Example of state-averaged CASSCF for the C2 molecule see C. D. Sherrill and P. Piecuch, J. Chem. Phys. 122, 124104 (2005). opt2; SCF DZ allene geometry optimization, with Cartesian input, first in c2v symmetry, then in Cs symmetry from a starting point with a non-linear central bond angle. cepa1; cc-pvdz H2O Test CEPA(1) Energy. mcscf3; RHF 6-31G** energy of water, using the MCSCF module and Z-matrix input. cc11; Frozen-core CCSD(ROHF)/cc-pVDZ on CN radical with disk-based AO algorithm. mp2-module; OMP2 cc-pVDZ energy for the H2O molecule. psimrcc-pt2; Mk-MRPT2 single point. F2 state described using the Ms = 0 component of the singlet. Uses TCSCF singlet orbitals. omp2p5-1; OMP2 cc-pVDZ energy for the H2O molecule. cepa0-grad1; CEPA0 cc-pVDZ gradient for the H2O molecule. dfomp2p5-1; DF-OMP2.5 cc-pVDZ energy for the H2O molecule. cisd-sp-2; 6-31G** H2O Test CISD Energy Point. rasci-h2o; RASCI/6-31G** H2O Energy Point. dfccd-grad1; DF-CCSD cc-pVDZ gradients for the H2O molecule. dfomp3-1; DF-OMP3 cc-pVDZ energy for the H2O molecule. dcft-grad2; RHF-ODC-12 analytic gradient computations for H2O use AO_BASIS=DISK and AO_BASIS=NONE, respectively. RHF-ODC-06 analytic gradient computations for H2O use AO_BASIS=DISK and AO_BASIS=NONE, respectively. cc32; CC3/cc-pVDZ H2O geom from Olsen et al., JCP 104, 8007 (1996). dfmp2-grad1; DF-MP2 cc-pVDZ gradients for the H2O molecule. cc8; UHF-CCSD(T) cc-pVDZ frozen-core energy for the state of the CN radical, with Z-matrix input. cc17; Single point energies of multiple excited states with EOM-CCSD. dfmp2-grad4; DF-MP2 cc-pVDZ gradient for the NO molecule. cc15; RHF-B-CCD(T)/6-31G** H2O single-point energy (fzc, MO-basis ). fci-dipole; 6",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html:19634,energy,energy,19634,psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"lowing energy methods have been set up for cbs(). scf; hf; mp2; mp2.5; mp3; mp4(sdq); mp4; mpn. omp2; omp2.5; omp3; olccd; lccd; lccsd; cepa(0); cepa(1). cepa(3); acpf; aqcc; qcisd; cc2; ccsd; fno-ccsd; bccd. cc3; qcisd(t); ccsd(t); fno-ccsd(t); bccd(t); cisd; cisdt. cisdtq; cin; fci; mrccsd; mrccsd(t); mrccsdt; mrccsdt(q). Parameters:; name (string) – 'scf' || 'ccsd' || etc.; First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be 'scf'. Overruled if stage_wfn keywords supplied. scf_wfn (string) – \(\Rightarrow\) 'scf' \(\Leftarrow\) || 'c4-scf' || etc.; Indicates the energy method for which the reference energy is to be; obtained. Generally unnecessary, as ‘scf’ is the scf in PSI4 but; can be used to direct lone scf components to run in PSI4 or Cfour; in a mixed-program composite method. corl_wfn (string) – 'mp2' || 'ccsd(t)' || etc.; Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with name or as the unlabeled; first argument to the function. delta_wfn (string) – 'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. delta_wfn_lesser (string) – \(\Rightarrow\) corl_wfn \(\Leftarrow\) || 'mp2' || etc.; Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. delta2_wfn (string) – 'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. delta2_wfn_lesser (string) – \(\Rightarrow\) delta_wfn \(\Leftarrow\) || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. delta3_wfn (string) – 'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a third delta correction; to",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/cbs-1.html:3936,energy,energy,3936,psi4manual/1.2.1/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/cbs-1.html,14,['energy'],['energy']
Energy Efficiency,"lowing; lines are all equivalent methods for specifying that 2 Gb of RAM is available; to PSI4:; memory 2 Gb. or. memory 2000 Mb. or. memory 2000000 Kb. One convenient way to override the PSI4 default memory is to place a memory; command in the ~/.psi4rc file, as detailed in Sec. Scratch Files and the ~/.psi4rc File. Return Values and PSI Variables¶; To harness the power of Python, PSI4 makes the most pertinent results of; each computation are made available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of H2; and H atom:; molecule h2{; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h{; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol*(2*h_energy - h2_energy); print""De=%f""%D_e. The energy() function returns the final result of the computation, which we; assign to a Python variable. The two energies are then converted to a; dissociation energy and printed to the output file using standard Python; notation. Sometimes there are multiple quantities of interest; these can be; accessed through the get_variable() function. For example, after performing a; density fitted MP2 computation, both the spin component scaled energy and the; unscaled MP2 energy are made available:; e_mp2=get_variable('DF-MP2 TOTAL ENERGY'); e_scs_mp2=get_variable('SCS-DF-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of; a calculation. The values for all can be printed in the output file; with the input file command print_variables(). Note that; PSI variables accumulate over a PSI4 instance and are not cleared by; clean(). So if you run in a single input file a STO-3G FCI; followed by a aug-cc-pVQZ SCF followed by a print_variables(); command, the last will include both SCF TOTAL ENERGY and; FCI TOTAL ENERGY. Don’t get excited that you got a high-quality calculation; cheaply. Refer to Appendix PSI Variables by Modul",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html:20052,energy,energy,20052,psi4manual/4.0b2/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html,4,['energy'],['energy']
Energy Efficiency,"lready a scalar variable!""); else:; core.set_array_variable(key, core.Matrix.from_array(_qcvar_reshape_set(key, val))); else:; if core.has_array_variable(key):; raise ValidationError(f""psi4.core.set_variable: Target variable '{key}' already an array variable!""); else:; core.set_scalar_variable(key, val). # TODO _qcvar_warnings(key). def _core_wavefunction_set_variable(self: core.Wavefunction, key: str, val: Union[core.Matrix, np.ndarray, float]) -> None:; """"""Sets scalar or array :ref:`QCVariable <sec:appendices:qcvars>` *key* to *val* on *self*. Parameters; ----------; self; Wavefunction instance.; key; Case-insensitive key to instance's double or :class:`~psi4.core.Matrix`; storage maps. - If ``CURRENT ENERGY``, syncs with ``self.energy_``.; - If ``CURRENT GRADIENT``, syncs with ``gradient_``.; - If ``CURRENT HESSIAN``, syncs with ``self.hessian_``.; val; Scalar or array to be stored in `key`. If :class:`~numpy.ndarray` and; data `key` does not naturally fit in 2D Matrix (often charge and; multipole QCVariables), it will be reshaped, as all; :class:`~numpy.ndarray` are stored as :class:`~psi4.core.Matrix`. Raises; ------; ~psi4.driver.ValidationError; If `val` is a scalar but `key` already exists as an array variable. Or; if `val` is an array but `key` already exists as a scalar variable. """"""; if isinstance(val, core.Matrix):; if self.has_scalar_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable '{key}' already a scalar variable!""); else:; self.set_array_variable(key, val); elif isinstance(val, np.ndarray):; if self.has_scalar_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable '{key}' already a scalar variable!""); else:; self.set_array_variable(key, core.Matrix.from_array(_qcvar_reshape_set(key, val))); else:; if self.has_array_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable '{key}' already an array variable!""); else:; self.set_scalar_variab",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html:40302,charge,charge,40302,psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html,4,['charge'],['charge']
Energy Efficiency,"lrec.; (6) molrec should be idempotent through this function (equiv to; schema validator) but are not idempotent throughout its life. if; fields permit, frame may be changed. Future? if fields permit,; mol may be symmetrized. Coordinates and angles may change units; or range if program returns them in only one form. name (str, optional) – Label for molecule; should be valid Python identifier.; units ({‘Angstrom’, ‘Bohr’}) – Units for geom.; input_units_to_au (float, optional) – If units=’Angstrom’, overrides consumer’s value for [A]–>[a0] conversion.; fix_com (bool) – Whether translation of geom is allowed or disallowed.; fix_orientation (bool) – Whether rotation of geom is allowed or disallowed.; fix_symmetry (str, optional) – Maximal point group symmetry which geom should be treated. Lowercase.; geom (ndarray of float) – (3 * nat, ) Cartesian coordinates in units.; elea (ndarray of int) – (nat, ) Mass number for atoms, if known isotope, else -1.; elez (ndarray of int) – (nat, ) Number of protons, nuclear charge for atoms.; elem (ndarray of str) – (nat, ) Element symbol for atoms.; mass (ndarray of float) – (nat, ) Atomic mass [u] for atoms.; real (ndarray of bool) – (nat, ) Real/ghostedness for atoms.; elbl (ndarray of str) – (nat, ) Label with any tagging information from element spec.; fragment_separators (list of int) – (nfr - 1, ) list of atom indices at which to split geom into fragments.; fragment_charges (list of float) – (nfr, ) list of charge allocated to each fragment.; fragment_multiplicities (list of int) – (nfr, ) list of multiplicity allocated to each fragment.; molecular_charge (float) – total charge on system.; molecular_multiplicity (int) – total multiplicity on system.; comment (str, optional) – Additional comment for molecule.; provenance (dict of str) – Accumulated history of molecule, with fields “creator”, “version”, “routine”.; connectivity (list of tuples of int, optional) – (nbond, 3) list of (0-indexed) (atomA, atomB, bond_order) (int, in",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/external_apis-1.html:8629,charge,charge,8629,psi4manual/1.4.0/external_apis-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/external_apis-1.html,5,['charge'],['charge']
Energy Efficiency,"ls for compatibility.; # OMP2,MP2.5,OCCD, etc get reduced to MP2,CC.; allowed_labels = {; ""HF"": "" SCF Density"",; ""SCF"": "" SCF Density"",; ""DFT"": "" SCF Density"",; ""MP2"": "" MP2 Density"",; ""MP3"": "" MP3 Density"",; ""MP4"": "" MP4 Density"",; ""CI"": "" CI Density"",; ""CC"": "" CC Density"",; }; # assign label from method name; fchk_label = f"" {method} Density""; if strict_label:; in_list = False; for key in allowed_labels:; if key in method:; if key is not method:; core.print_out(f""FCHKWriter: !WARNING! method '{method}'' renamed to label '{key}'.\n""); fchk_label = allowed_labels[key]; in_list = True; if not in_list:; core.print_out(f""FCHKWriter: !WARNING! {method} is not recognized. Using non-standard label.\n""); core.print_out(f""FCHKWriter: Writing {filename} with label '{fchk_label}'.\n""); fw.set_postscf_density_label(fchk_label). fw.write(filename); # needed for the pytest. The SCF density below follows PSI4 ordering not FCHK ordering.; if debug:; ret = {; ""filename"": filename,; ""detected energy"": method,; ""selected label"": fchk_label,; ""Total SCF Density"": fw.SCF_Dtot().np,; }; return ret; return None. [docs]; def molden(wfn, filename=None, density_a=None, density_b=None, dovirtual=None):; """"""Function to write wavefunction information in *wfn* to *filename* in; molden format. Will write natural orbitals from *density* (MO basis) if supplied.; Warning! Most post-SCF Wavefunctions do not build the density as this is often; much more costly than the energy. In addition, the Wavefunction density attributes; (Da and Db) return the SO density and must be transformed to the MO basis; to use with this function. .. versionadded:: 0.5; *wfn* parameter passed explicitly. :returns: None. :type wfn: :py:class:`~psi4.core.Wavefunction`; :param wfn: set of molecule, basis, orbitals from which to generate cube files. :type filename: str; :param filename: destination file name for MOLDEN file (optional). :type density_a: :py:class:`~psi4.core.Matrix`; :param density_a: density in the MO basis t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:99461,energy,energy,99461,psi4manual/1.8.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html,6,['energy'],['energy']
Energy Efficiency,"ls for compatibility.; # OMP2,MP2.5,OCCD, etc get reduced to MP2,CC.; allowed_labels = {; ""HF"": "" SCF Density"",; ""SCF"": "" SCF Density"",; ""DFT"": "" SCF Density"",; ""MP2"": "" MP2 Density"",; ""MP3"": "" MP3 Density"",; ""MP4"": "" MP4 Density"",; ""CI"": "" CI Density"",; ""CC"": "" CC Density"",; }; # assign label from method name; fchk_label = f"" {method} Density""; if strict_label:; in_list = False; for key in allowed_labels:; if key in method:; if key is not method:; core.print_out(f""FCHKWriter: !WARNING! method '{method}'' renamed to label '{key}'.\n""); fchk_label = allowed_labels[key]; in_list = True; if not in_list:; core.print_out(f""FCHKWriter: !WARNING! {method} is not recognized. Using non-standard label.\n""); core.print_out(f""FCHKWriter: Writing {filename} with label '{fchk_label}'.\n""); fw.set_postscf_density_label(fchk_label). fw.write(filename); # needed for the pytest. The SCF density below follows PSI4 ordering not FCHK ordering.; if debug:; ret = {; ""filename"": filename,; ""detected energy"": method,; ""selected label"": fchk_label,; ""Total SCF Density"": fw.SCF_Dtot().np,; }; return ret; return None. [docs]def molden(wfn, filename=None, density_a=None, density_b=None, dovirtual=None):; """"""Function to write wavefunction information in *wfn* to *filename* in; molden format. Will write natural orbitals from *density* (MO basis) if supplied.; Warning! Most post-SCF Wavefunctions do not build the density as this is often; much more costly than the energy. In addition, the Wavefunction density attributes; (Da and Db) return the SO density and must be transformed to the MO basis; to use with this function. .. versionadded:: 0.5; *wfn* parameter passed explicitly. :returns: None. :type wfn: :py:class:`~psi4.core.Wavefunction`; :param wfn: set of molecule, basis, orbitals from which to generate cube files. :type filename: str; :param filename: destination file name for MOLDEN file (optional). :type density_a: :py:class:`~psi4.core.Matrix`; :param density_a: density in the MO basis to ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:97960,energy,energy,97960,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,8,['energy'],['energy']
Energy Efficiency,"ls into groups of different importance. Next, the RASCI is run. The split-virtual CISD[TQ] takes all singles and doubles, and all triples and quadruples with no more than 2 electrons in the secondary virtual subspace (RAS 3). If any electrons are present in the tertiary virtual subspace (RAS 4), then that excitation is only allowed if it is a single or double. fnocc1; Test QCISD(T) for H2O/cc-pvdz Energy. cc28; CCSD/cc-pVDZ optical rotation calculation (length gauge only) on Z-mat H2O2. opt1; SCF STO-3G geometry optimzation, with Z-matrix input. cc10; ROHF-CCSD cc-pVDZ energy for the state of the CN radical. casscf-sa-sp; Example of state-averaged CASSCF for the C2 molecule see C. D. Sherrill and P. Piecuch, J. Chem. Phys. 122, 124104 (2005). opt2; SCF DZ allene geometry optimization, with Cartesian input, first in c2v symmetry, then in Cs symmetry from a starting point with a non-linear central bond angle. cepa1; cc-pvdz H2O Test CEPA(1) Energy. mcscf3; RHF 6-31G** energy of water, using the MCSCF module and Z-matrix input. cc11; Frozen-core CCSD(ROHF)/cc-pVDZ on CN radical with disk-based AO algorithm. mp2-module; OMP2 cc-pVDZ energy for the H2O molecule. psimrcc-pt2; Mk-MRPT2 single point. F2 state described using the Ms = 0 component of the singlet. Uses TCSCF singlet orbitals. omp2p5-1; OMP2 cc-pVDZ energy for the H2O molecule. cepa0-grad1; CEPA0 cc-pVDZ gradient for the H2O molecule. dfomp2p5-1; DF-OMP2.5 cc-pVDZ energy for the H2O molecule. cisd-sp-2; 6-31G** H2O Test CISD Energy Point. rasci-h2o; RASCI/6-31G** H2O Energy Point. dfccd-grad1; DF-CCSD cc-pVDZ gradients for the H2O molecule. dfomp3-1; DF-OMP3 cc-pVDZ energy for the H2O molecule. dcft-grad2; RHF-ODC-12 analytic gradient computations for H2O use AO_BASIS=DISK and AO_BASIS=NONE, respectively. RHF-ODC-06 analytic gradient computations for H2O use AO_BASIS=DISK and AO_BASIS=NONE, respectively. cc32; CC3/cc-pVDZ H2O geom from Olsen et al., JCP 104, 8007 (1996). dfmp2-grad1; DF-MP2 cc-pVDZ gradients fo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html:19289,energy,energy,19289,psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"ls per irrep. nfrzc(self); Number of frozen core electrons. nirrep(self); Number of irreps in the system. nmo(self); Number of molecule orbitals. nmopi(self); Returns the number of molecular orbitals per irrep. no_occupations(self); returns the natural orbital occupations on the wavefunction. nso(self); Number of symmetry orbitals. nsopi(self); Returns the number of symmetry orbitals per irrep. reference_wavefunction(self); Returns the reference wavefunction. same_a_b_dens(self); Returns true if the alpha and beta densities are the same. same_a_b_orbs(self); Returns true if the alpha and beta orbitals are the same. scalar_variable(self, arg0); Returns the requested (case-insensitive) double QC variable. scalar_variables(self); Returns the dictionary of all double QC variables. set_array(key, val). set_array_variable(self, arg0, arg1); Sets the requested (case-insensitive) Matrix QC variable. set_basisset(self, arg0, arg1); Sets the requested auxiliary basis. set_energy(self, arg0); Sets the Wavefunction’s energy. set_external_potential(self, arg0); Sets the requested external potential. set_frequencies(val). set_gradient(self, arg0); Sets the Wavefunction’s gradient. set_hessian(self, arg0); Sets the Wavefunction’s Hessian. set_legacy_frequencies(self, arg0); Sets the frequencies of the Hessian. set_name(self, arg0); Sets the level of theory this wavefunction corresponds to. set_print(self, arg0); Sets the print level of the Wavefunction. set_reference_wavefunction(self, arg0); docstring. set_scalar_variable(self, arg0, arg1); Sets the requested (case-insensitive) double QC variable. set_variable(key, val). shallow_copy(self, arg0); Copies the pointers to the internal data. sobasisset(self); Returns the symmetry orbitals basis. soccpi(self); Returns the number of singly occupied orbitals per irrep. to_file([filename]); Converts a Wavefunction object to a base class. variable(key). variables(). Methods Documentation. Ca(self: psi4.core.Wavefunction) → psi4.core.Matri",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.wavefunction.html:5371,energy,energy,5371,psi4manual/1.3.2/api/psi4.core.wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.wavefunction.html,1,['energy'],['energy']
Energy Efficiency,"ls — Psi4 [1.0.0 6a9a71b] Docs. Navigation. index. modules    . toc    . next    . previous    ; Psi4 [1.0.0 6a9a71b] » ; Psithon Functions: Invoking a Calculation ». Function Intercalls¶; For many of the Psi4 Python functions described above, it makes scientific; sense that they could be called in combination. For instance, one could; optimize all the reagents in a database or compute a; counterpoise-corrected interaction energy with an extrapolated method. The; table below outlines permitted intercalls between functions, showing that; db(opt(cbs(energy()))) is allowed, while db(cp(energy())) is not. This; table is not yet validated for calls with cp(). Permitted nesting of Psithon functions¶. Caller; Callee.  ; cp; db; opt; cbs; energy. Counterpoise Correct;  ; —; Y; Y; Y. Database, database(); —;  ; Y; Y; Y. Geometry Optimization, optimize() and gradient(); —; —;  ; Y; Y. Complete Basis Set; —; —; —;  ; Y. Single-Point Energy, energy(); —; —; —; —;  . The command db(opt(cbs(energy()))) is actually expressed as db(...,; db_func=opt, opt_func=cbs). The perhaps expected final argument of; cbs_func=energy is not necessary since energy() is always the function; called by default. Also, the outermost internal function call (db_func; above can be called as just func. Several examples of intercalls; between Python functions can be found in sample input pywrap_all.; All keyword arguments are passed along to each function traversed in the; Python driver, so there should be no concern for separating them, grouping; them, or designating them for a particular function when undertaking a; nested calculation. Where the same keyword is used by multiple functions,; prefixes are added, e.g., db_mode and opt_mode.; Function intercalls should not be used in sow/reap mode. Previous topic; Spectroscopic Constants for Diatomics; Next topic; Embarrassing Parallelism. This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. module",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/intercalls-1.html:1012,energy,energy,1012,psi4manual/1.0.0/intercalls-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/intercalls-1.html,2,['energy'],['energy']
Energy Efficiency,"ls. is_variable(self, arg0); Checks if variable arg2 is in the list, returns true if it is, and returns false if not. label(self, arg0); Gets the original label of the atom as given in the input file (C2, H4). mass(self, atom); Returns mass of atom (0-indexed). mass_number(self, arg0); Mass number (A) of atom if known, else -1. molecular_charge(self); Gets the molecular charge. move_to_com(self); Moves molecule to center of mass. multiplicity(self); Gets the multiplicity (defined as 2Ms + 1). nallatom(self); Number of real and dummy atoms. name(self); Gets molecule name. natom(self); Number of real atoms. nfragments(self); Gets the number of fragments in the molecule. nuclear_dipole(*args, **kwargs); Overloaded function. nuclear_repulsion_energy(self, dipole_field, …); Computes nuclear repulsion energy. nuclear_repulsion_energy_deriv1(self, arg0); Returns first derivative of nuclear repulsion energy as a matrix (natom, 3). nuclear_repulsion_energy_deriv2(self); Returns second derivative of nuclear repulsion energy as a matrix (natom X 3, natom X 3). orientation_fixed(self); Get whether or not orientation is fixed. point_group(self); Returns the current point group object. print_bond_angles(self); Print the bond angle geometrical parameters. print_cluster(self); Prints the molecule in Cartesians in input units adding fragment separators. print_distances(self); Print the interatomic distance geometrical parameters. print_in_input_format(self); Prints the molecule as Cartesian or ZMatrix entries, just as inputted. print_out(self); Prints the molecule in Cartesians in input units to output file. print_out_in_angstrom(self); Prints the molecule in Cartesians in Angstroms to output file. print_out_in_bohr(self); Prints the molecule in Cartesians in Bohr to output file. print_out_of_planes(self); Print the out-of-plane angle geometrical parameters to output file. reinterpret_coordentry(self, arg0); Do reinterpret coordinate entries during update_geometry(). reset_point_grou",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/api/psi4.core.molecule.html:4714,energy,energy,4714,psi4manual/1.2.1/api/psi4.core.molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/api/psi4.core.molecule.html,1,['energy'],['energy']
Energy Efficiency,"ls:; if key in method:; if key is not method:; core.print_out(f""FCHKWriter: !WARNING! method '{method}'' renamed to label '{key}'.\n""); fchk_label = allowed_labels[key]; in_list = True; if not in_list:; core.print_out(f""FCHKWriter: !WARNING! {method} is not recognized. Using non-standard label.\n""); core.print_out(f""FCHKWriter: Writing {filename} with label '{fchk_label}'.\n""); fw.set_postscf_density_label(fchk_label). fw.write(filename); # needed for the pytest. The SCF density below follows PSI4 ordering not FCHK ordering.; if debug:; ret = {; ""filename"": filename,; ""detected energy"": method,; ""selected label"": fchk_label,; ""Total SCF Density"": fw.SCF_Dtot().np,; }; return ret; return None. [docs]def molden(wfn, filename=None, density_a=None, density_b=None, dovirtual=None):; """"""Function to write wavefunction information in *wfn* to *filename* in; molden format. Will write natural orbitals from *density* (MO basis) if supplied.; Warning! Most post-SCF Wavefunctions do not build the density as this is often; much more costly than the energy. In addition, the Wavefunction density attributes; (Da and Db) return the SO density and must be transformed to the MO basis; to use with this function. .. versionadded:: 0.5; *wfn* parameter passed explicitly. :returns: None. :type wfn: :py:class:`~psi4.core.Wavefunction`; :param wfn: set of molecule, basis, orbitals from which to generate cube files. :type filename: str; :param filename: destination file name for MOLDEN file (optional). :type density_a: :py:class:`~psi4.core.Matrix`; :param density_a: density in the MO basis to build alpha NO's from (optional). :type density_b: :py:class:`~psi4.core.Matrix`; :param density_b: density in the MO basis to build beta NO's from, assumes restricted if not supplied (optional). :type dovirtual: bool; :param dovirtual: do write all the MOs to the MOLDEN file (true) or discard the unoccupied MOs, not valid for NO's (false) (optional). :examples:. 1. Molden file with the Kohn-Sham orbital",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:98426,energy,energy,98426,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,8,['energy'],['energy']
Energy Efficiency,"lse):; """"""Function to examine file *sowout* from a sow/reap distributed job; for formatted line with electronic energy information about index; *sownum* to be used for construction of *quantity* computations as; directed by master input file with *linkage* kwarg. When file *sowout*; is missing or incomplete files, function will either return zero; (*allvital* is ``False``) or terminate (*allvital* is ``True``) since; some sow/reap procedures can produce meaningful results (database); from an incomplete set of sown files, while others cannot (gradient,; hessian). """"""; E = 0.0. try:; freagent = open('%s.out' % (sowout), 'r'); except IOError:; if allvital:; raise ValidationError('Aborting upon output file \'%s.out\' not found.\n' % (sowout)); else:; ValidationError('Aborting upon output file \'%s.out\' not found.\n' % (sowout)); return 0.0; else:; while True:; line = freagent.readline(); if not line:; if E == 0.0:; if allvital:; raise ValidationError('Aborting upon output file \'%s.out\' has no %s RESULT line.\n' % (sowout, quantity)); else:; ValidationError('Aborting upon output file \'%s.out\' has no %s RESULT line.\n' % (sowout, quantity)); break; s = line.split(); if (len(s) != 0) and (s[0:3] == [quantity, 'RESULT:', 'computation']):; if int(s[3]) != linkage:; raise ValidationError('Output file \'%s.out\' has linkage %s incompatible with master.in linkage %s.'; % (sowout, str(s[3]), str(linkage))); if s[6] != str(sownum + 1):; raise ValidationError('Output file \'%s.out\' has nominal affiliation %s incompatible with item %s.'; % (sowout, s[6], str(sownum + 1))); if (s[8:10] == ['electronic', 'energy']):; E = float(s[10]); psi4.print_out('%s RESULT: electronic energy = %20.12f\n' % (quantity, E)); freagent.close(); return E. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; PSI4 [beta5] » ; Module code ». © Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/p4util/procutil.html:8031,energy,energy,8031,psi4manual/4.0b5/_modules/p4util/procutil.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/p4util/procutil.html,4,['energy'],['energy']
Energy Efficiency,"lse); if use_mdi:; return mdi_run(name, **kwargs). core.print_out(""\nScratch directory: %s\n"" % core.IOManager.shared_object().get_default_path()). basisstash = p4util.OptionsState(['BASIS']); return_wfn = kwargs.pop('return_wfn', False). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). ## Pre-planning interventions. # * Trip on function or alias as name; lowername = driver_util.upgrade_interventions(name). # * Allow specification of methods to arbitrary order; lowername, level = driver_util.parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. _filter_renamed_methods(""energy"", lowername). # * Avert pydantic anger at incomplete modelchem spec; userbas = core.get_global_option('BASIS') or kwargs.get('basis'); if lowername in integrated_basis_methods and userbas is None:; kwargs['basis'] = '(auto)'. # Are we planning?; plan = task_planner.task_planner(""energy"", lowername, molecule, **kwargs); logger.debug('ENERGY PLAN'); logger.debug(pp.pformat(plan.dict())). if kwargs.get(""return_plan"", False):; # Plan-only requested; return plan. elif not isinstance(plan, AtomicComputer):; # Advanced ""Computer"" active; plan.compute(); return plan.get_psi_results(return_wfn=return_wfn). else:; # We have unpacked to an AtomicInput; lowername = plan.method; basis = plan.basis; core.set_global_option(""BASIS"", basis). ## Second half of this fn -- entry means program running exactly analytic 0th derivative. # Commit to procedures['energy'] call hereafter; core.clean_variables(). #for precallback in hooks['energy']['pre']:; # precallback(lowername, **kwargs). # needed (+restore below) so long as AtomicComputer-s aren't run through json (where convcrit also lives); optstash = driver_util.negotiate_convergence_criterion((0, 0), lowername, return_optstash=True); optstash2 = p4util.OptionsState(['SCF', 'GUESS']). # Before invoking the procedure, we rename any file that should",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html:30713,energy,energy,30713,psi4manual/1.6.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html,2,['energy'],['energy']
Energy Efficiency,"lse); self.LOT = LOT; self.options = options if options else {}. if molecule is None:; molecule = psi4.core.get_active_molecule(); self.initial_molecule = molecule; assert self.initial_molecule.orientation_fixed(), ""Orientation must be fixed!""; assert self.initial_molecule.point_group().symbol() == ""c1"", ""Symmetry must be 'c1'!"". names = [self.initial_molecule.symbol(i) for i in range(self.initial_molecule.natom())]; psi4.core.print_out(""Initial atoms %s\n"" % names); self.atoms_list = names. psi4.core.print_out(""Psi4 options:\n""); for item, value in self.options.items():; psi4.core.print_out(""%s %s\n"" % (item, value)); psi4.core.set_global_option(item, value); psi4.core.IO.set_default_namespace(""xwrapper""). self.timing = {}. atoms = np.array(self.initial_molecule.geometry()); psi4.core.print_out(""Initial atoms %s\n"" % atoms); psi4.core.print_out(""Force:\n""); self._positions = atoms; self._callback = self.callback; self._nat = np.int32(len(atoms)). def calculate_force(self, pos=None, **kwargs):; """"""Fetch force, energy of PSI. Arguments:; - pos: positions of the atoms as array. If None, the positions of the current active; molecule is used.; """"""; if pos is None:; molecule = psi4.core.get_active_molecule(); pos = np.array(molecule.geometry()). self._force, self._potential = self.callback(pos, **kwargs); return self._force, self._potential. def callback(self, pos, **kwargs):; """"""Initialize psi with new positions and calculate force. Arguments:; - pos: positions of the atoms as array.; """""". self.initial_molecule.set_geometry(psi4.core.Matrix.from_array(pos)). self.calculate_gradient(self.LOT, pos=pos, **kwargs). self._potential = psi4.variable('CURRENT ENERGY'); self._force = -np.array(self.grd); self._vir = np.array([[0.0,0.0,0.0],[0.0,0.0,0.0],[0.0,0.0,0.0]]). return self._force, np.float64(self._potential). def calculate_gradient(self, LOT, bypass_scf=False, **kwargs):; """"""Calculate the gradient with @LOT. When bypass_scf=True a hf energy calculation has been done befo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/ipi_broker.html:2915,energy,energy,2915,psi4manual/1.6.x/_modules/psi4/driver/ipi_broker.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/ipi_broker.html,10,['energy'],['energy']
Energy Efficiency,"lse:; method_str = method_str[2:]; method, basis = method_str.split('/'); method_list.append(method); basis_list.append(basis); return method_list, basis_list. def _cbs_gufunc(func, total_method_name, **kwargs):; """"""; Text based wrapper of the CBS function.; """""". # Catch kwarg issues; kwargs = p4util.kwargs_lower(kwargs); return_wfn = kwargs.pop('return_wfn', False); core.clean_variables(); user_dertype = kwargs.pop('dertype', None); cbs_verbose = kwargs.pop('cbs_verbose', False); ptype = kwargs.pop('ptype', None). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). # Sanitize total_method_name; label = total_method_name; total_method_name = total_method_name.lower(); total_method_name = total_method_name.replace(' ', ''). # Split into components; method_list, basis_list = _parse_cbs_gufunc_string(total_method_name). # Single energy call?; single_call = len(method_list) == 1; single_call &= '[' not in basis_list[0]; single_call &= ']' not in basis_list[0]. if single_call:; method_name = method_list[0]; basis = basis_list[0]. # Save some global variables so we can reset them later; optstash = p4util.OptionsState(['BASIS']); core.set_global_option('BASIS', basis). ptype_value, wfn = func(method_name, return_wfn=True, molecule=molecule, **kwargs); core.clean(). optstash.restore(). if return_wfn:; return (ptype_value, wfn); else:; return ptype_value. # If we are not a single call, let CBS wrapper handle it!; cbs_kwargs = {}; cbs_kwargs['ptype'] = ptype; cbs_kwargs['return_wfn'] = True; cbs_kwargs['molecule'] = molecule; cbs_kwargs['verbose'] = cbs_verbose. # Find method and basis; if method_list[0] in ['scf', 'hf']:; cbs_kwargs['scf_wfn'] = method_list[0]; cbs_kwargs['scf_basis'] = basis_list[0]; if 'scf_scheme' in kwargs:; cbs_kwargs['scf_scheme'] = kwargs['scf_scheme']; else:; cbs_kwargs['corl_wfn'] = method_list[0]; cbs_kwargs['corl_basis'] = basis_list[0]; if 'corl_s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver_cbs.html:58421,energy,energy,58421,psi4manual/1.1.0/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver_cbs.html,1,['energy'],['energy']
Energy Efficiency,"lse:; method_str = method_str[2:]; method, basis = method_str.split('/'); method_list.append(method); basis_list.append(basis); return method_list, basis_list. def _cbs_gufunc(func, total_method_name, **kwargs):; """"""; Text based wrapper of the CBS function.; """""". # Catch kwarg issues; kwargs = p4util.kwargs_lower(kwargs); return_wfn = kwargs.pop('return_wfn', False); psi4.clean_variables(); user_dertype = kwargs.pop('dertype', None); cbs_verbose = kwargs.pop('cbs_verbose', False); ptype = kwargs.pop('ptype', None). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', psi4.get_active_molecule()); molecule.update_geometry(). # Sanitize total_method_name; label = total_method_name; total_method_name = total_method_name.lower(); total_method_name = total_method_name.replace(' ', ''). # Split into components; method_list, basis_list = _parse_cbs_gufunc_string(total_method_name). # Single energy call?; single_call = len(method_list) == 1; single_call &= '[' not in basis_list[0]; single_call &= ']' not in basis_list[0]. if single_call:; method_name = method_list[0]; basis = basis_list[0]. # Save some global variables so we can reset them later; optstash = p4util.OptionsState(['BASIS']); psi4.set_global_option('BASIS', basis). ptype_value, wfn = func(method_name, return_wfn=True, molecule=molecule, **kwargs); psi4.clean(). optstash.restore(). if return_wfn:; return (ptype_value, wfn); else:; return ptype_value. # If we are not a single call, let CBS wrapper handle it!; cbs_kwargs = {}; cbs_kwargs['ptype'] = ptype; cbs_kwargs['return_wfn'] = True; cbs_kwargs['molecule'] = molecule; cbs_kwargs['verbose'] = cbs_verbose. # Find method and basis; if method_list[0] in ['scf', 'hf']:; cbs_kwargs['scf_wfn'] = method_list[0]; cbs_kwargs['scf_basis'] = basis_list[0]; else:; cbs_kwargs['corl_wfn'] = method_list[0]; cbs_kwargs['corl_basis'] = basis_list[0]. if len(method_list) > 1:; cbs_kwargs['delta_wfn'] = method_list[1]; cbs_kwargs['delta_b",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:57978,energy,energy,57978,psi4manual/1.0.0/_modules/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html,1,['energy'],['energy']
Energy Efficiency,"lse:; scf_helper(name, **kwargs). psi4.print_out('\n'); p4util.banner('DFMP2'); psi4.print_out('\n'). # if the df_basis_mp2 basis is not set, pick a sensible one.; if psi4.get_global_option('DF_BASIS_MP2') == '':; ribasis = p4util.corresponding_rifit(psi4.get_global_option('BASIS')); if ribasis:; psi4.set_global_option('DF_BASIS_MP2', ribasis); psi4.print_out(' No DF_BASIS_MP2 auxiliary basis selected, defaulting to %s\n' % (ribasis)); else:; raise ValidationError('Keyword DF_BASIS_MP2 is required.'). e_dfmp2 = psi4.dfmp2(); e_scs_dfmp2 = psi4.get_variable('SCS-MP2 TOTAL ENERGY'). optstash.restore(). if (name.upper() == 'SCS-MP2'):; return e_scs_dfmp2; elif (name.upper() == 'DF-MP2') or (name.upper() == 'DFMP2') or (name.upper() == 'MP2'):; return e_dfmp2. [docs]def run_psimrcc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for a PSIMRCC computation; using a reference from the MCSCF module. """"""; run_mcscf(name, **kwargs); psi4.psimrcc(); return psi4.get_variable(""CURRENT ENERGY""). [docs]def run_psimrcc_scf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for a PSIMRCC computation; using a reference from the SCF module. """"""; # Bypass routine scf if user did something special to get it to converge; if not (('bypass_scf' in kwargs) and yes.match(str(kwargs['bypass_scf']))):; scf_helper(name, **kwargs). psi4.psimrcc(); return psi4.get_variable(""CURRENT ENERGY""). [docs]def run_mp2c(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a coupled MP2 calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_MP2']). molecule = psi4.get_active_molecule(); molecule.update_geometry(); monomerA = molecule.extract_subsets(1, 2); monomerA.set_name('monomerA'); monomerB = molecule.extract_subsets(2, 1); monomerB.set_name('monomerB'). # if the df_basis_mp2 basis is not set, pick a sensible one.; if psi4.get_global_option('DF_BASIS_MP2') == '':; ribasis = p4util.corresponding_rifit(psi4.get_global_option('BASIS')); if rib",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/proc.html:44936,ENERGY,ENERGY,44936,psi4manual/4.0b5/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/proc.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"lsen et al., JCP 104, 8007 (1996). omp2-4; SCS-OMP2 cc-pVDZ geometry optimization for the H2O molecule. mp2_5-grad2; MP2.5 cc-pVDZ gradient for the NO radical. mints8; Patch of a glycine with a methyl group, to make alanine, then DF-SCF energy calculation with the cc-pVDZ basis set. cc9a; ROHF-CCSD(T) cc-pVDZ energy for the state of the CN radical, with Z-matrix input. dfmp2-2; Density fitted MP2 energy of H2, using density fitted reference and automatic looping over cc-pVDZ and cc-pVTZ basis sets. Results are tabulated using the built in table functions by using the default options and by specifiying the format. omp2-grad1; OMP2 cc-pVDZ gradient for the H2O molecule. cc1; RHF-CCSD 6-31G** all-electron optimization of the H2O molecule. scf4; RHF cc-pVDZ energy for water, automatically scanning the symmetric stretch and bending coordinates using Python’s built-in loop mechanisms. The geometry is apecified using a Z-matrix with variables that are updated during the potential energy surface scan, and then the same procedure is performed using polar coordinates, converted to Cartesian coordinates. cisd-h2o-clpse; 6-31G** H2O Test CISD Energy Point with subspace collapse. omp2-3; OMP2 cc-pVDZ energy for the NO radical. cepa1; cc-pvdz H2O Test CEPA(1) Energy. cc24; Single point gradient of 1-2B1 state of H2O+ with EOM-CCSD. dftd3-grad; DF-BP86-D2 cc-pVDZ frozen core gradient of S22 HCN, calling Grimme’s dftd3 program for -D2 gradients. cc14; ROHF-CCSD/cc-pVDZ CH2 geometry optimization via analytic gradients. mp3-grad2; MP3 cc-pVDZ gradient for the NO radical. cc29; CCSD/cc-pVDZ optical rotation calculation (both gauges) on Cartesian H2O2. dfscf-bz2; Benzene Dimer DF-HF/cc-pVDZ. psithon1; Spectroscopic constants of H2, and the full ci cc-pVTZ level of theory. ocepa3; OCEPA cc-pVDZ energy with ROHF initial guess for the NO radical. matrix1; An example of using BLAS and LAPACK calls directly from the Psi input file, demonstrating matrix multiplication, eigendecomposition, Cho",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodoc_testsuite-1.html:20526,energy,energy,20526,psi4manual/4.0b5/autodoc_testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodoc_testsuite-1.html,4,['energy'],['energy']
Energy Efficiency,"lso be accessed through the first item below more; conveniently than the equivalent second and third items. optimize('mp2/cc-pv[tq]z + D:ccsd(t)/cc-pvdz'); optimize(cbs, corl_wfn='mp2', corl_basis='cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='cc-pvdz'); optimize(cbs, cbs_metadata=[{""wfn"": ""hf"", ""basis"": ""cc-pvqz""}, {""wfn"": ""mp2"", ""basis"": ""cc-pv[tq]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pvdz""}]). Many examples can be found at cbs-xtpl-energy,; cbs-xtpl-gradient, cbs-xtpl-opt,; cbs-xtpl-freq, cbs-xtpl-func,; cbs-xtpl-wrapper, cbs-xtpl-dict. psi4.cbs(name[, scf_basis, scf_scheme, corl_wfn, corl_basis, corl_scheme, delta_wfn, delta_wfn_lesser, delta_basis, delta_scheme, delta2_wfn, delta2_wfn_lesser, delta2_basis, delta2_scheme, cbs_metadata])[source]¶; Function to define a multistage energy method from combinations of; basis set extrapolations and delta corrections and condense the; components into a minimum number of calculations. Aliases:complete_basis_set(). Returns:(float) – Total electronic energy in Hartrees. PSI variables:. CBS TOTAL ENERGY; CBS REFERENCE ENERGY; CBS CORRELATION ENERGY; CURRENT ENERGY; CURRENT REFERENCE ENERGY; CURRENT CORRELATION ENERGY. Caution; Some features are not yet implemented. Buy a developer a coffee. No way to tell function to boost fitting basis size for all calculations.; Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in several; sequential stages (scf, corl, delta1, delta2, … ) covering treatment; of the reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction, etc.. Each is activated by its; stage_wfn keyword, or as a field in the `cbs_metadata` list, and is only; allowed if all preceding stages are active. Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy.; The cbs",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/cbs-1.html:1919,energy,energy,1919,psi4manual/1.3.2/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/cbs-1.html,2,['energy'],['energy']
Energy Efficiency,"lt in table functions by using the default options and by specifiying the format. cc8a; ROHF-CCSD(T) cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Cartesian input. cbs-xtpl-gradient; Various gradients for a strained helium dimer and water molecule. dft-jk; DFT JK on-disk test. cbs-xtpl-opt; Various extrapolated optimization methods for the H2 molecule. ci-multi; BH single points, checking that program can run multiple instances of DETCI in a single input, without an intervening clean() call. fd-freq-gradient-large; SCF DZ finite difference frequencies by energies for C4NH4. soscf-ref; Triple and Singlet Oxygen energy SOSCF, also tests non-symmetric density matrices. cisd-h2o+-0; 6-31G** H2O+ Test CISD Energy Point. sapt-dft-lrc; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. psimrcc-ccsd_t-4; Mk-MRCCSD(T) single point. \(^1A_1\) O$_3` state described using the Ms = 0 component of the singlet. Uses TCSCF orbitals. casscf-semi; CASSCF/6-31G** energy point. Check energy with frozen core/virtual orbs. after semicanonicalization. mp2-grad1; MP2 cc-pVDZ gradient for the H2O molecule. omp3-grad2; OMP3 cc-pVDZ gradient for the NO radical. fsapt1; This test case shows an example of running and analyzing a standard F-SAPT0/jun-cc-pvdz procedure for phenol dimer from the S22 database. extern1; External potential calculation involving a TIP3P water and a QM water. Finite different test of the gradient is performed to validate forces. cisd-h2o+-2; 6-31G** H2O+ Test CISD Energy Point. sapt1; SAPT0 cc-pVDZ computation of the ethene-ethyne interaction energy, using the cc-pVDZ-JKFIT RI basis for SCF and cc-pVDZ-RI for SAPT. Monomer geometries are specified using Cartesian coordinates. scf-upcast-custom-basis; test scf castup with custom basis sets. cc52; CCSD Response for H2O2. decontract; RHF/cc-pvdz-decontract HCl single-point energy Testing the in line -decontract option for basis sets. cc55; EOM-CCSD/6-31g excited state trans",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html:2694,energy,energy,2694,psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"lt modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module in ['', 'FNOCC']:; func = run_fnocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module == 'DETCI':; raise UpgradeHelper(""energy('mp4')"", ""energy('zapt4')"", 1.7,; "" Replace method MP with method ZAPT for ROHF reference. DETCI is orders-of-magnitude inefficient for perturbation theory.""). if module == 'DETCI':; core.print_out(""""""\nDETCI is ill-advised for method MP4 as it is available inefficiently as a """"""; """"""byproduct of a CISDT computation.\n""""""). if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_remp2(name, **kwargs):; """"""Function selecting the algorithm for a REMP2 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in [""RHF"", ""UHF""]:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_ccd(name, **kwargs):; """"""Function selecting the algorithm for a CCD energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option(""SCF"", ""REFERENCE""); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option(""QC_MODULE""). func = None; if reference in ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:31157,energy,energy,31157,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,8,['energy'],['energy']
Energy Efficiency,"lt parameters; define them. The dispersion correction is available after a calculation in; the PSI variable DISPERSION CORRECTION ENERGY.; By default, the output from the dftd3; program is suppressed; to see it in the output file, set print > 2. Variants of S. Grimme’s -D correction. Extension [1]; Variant and Computing Program; DFT_DISPERSION_PARAMETERS. -D; alias to -D2P4;  . -D1; -D1 [2] within PSI4;  . -D2; alias to -D2P4;  . -D2P4; -D2 [3] within PSI4; []. -D2GR; -D2 [3] through dftd3; [, ]. -D3; alias to -D3ZERO;  . -D3ZERO; -D3 [4] w/ original zero-damping through dftd3; [, , , ]. -D3BJ; -D3 [5] w/ newer Becke-Johnson rational damping through dftd3; [, , , ]. Footnotes. [1]Note that there are functionals with these extensions (e.g., wB97X-D) that,; not being Grimme corrections, have nothing to do with this table. [2][Grimme:2004:1463]. [3](1, 2) [Grimme:2006:1787]. [4][Grimme:2010:154104]. [5][Grimme:2011:1456]. A few practical examples:. DFT-D2 single point with default parameters (dftd3 not called); energy('bp86-d'). DFT-D3BJ optimization with default parameters; optimize('pbe-d3bj'). DFT-D2 optimization with custom s6 parameter; set dft_dispersion_parameters [1.20]; optimize('b3lyp-d2'). DFT-D3ZERO single point (b3lyp) with custom s8 parameter (reset all four values); set dft_dispersion_parameters [1.0, 2.0, 1.261, 14.0]; energy('b3lyp-d3'). If only dispersion corrections (rather than total energies) are of; interest, the dftd3 program can be run independently of the scf; through the python function run_dftd3(). (This function; is the same PSI4/dftd3 interface that is called during an scf job.); This route is much faster than running a DFT-D energy. Some set-up:; molecule nene {; Ne; Ne 1 2.0; }. nene.update_geometry(). The same four dispersion corrections/gradients as the section above:; >>> print nene.run_dftd3('bp86', 'd', dertype=0); -7.735e-05. >>> E, G = nene.run_dftd3('pbe', 'd3bj'); >>> print G; [[0.0, 0.0, -1.1809087569358e-05], [0.0, 0.0, 1.18090",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/dftd3.html:5246,energy,energy,5246,psi4manual/4.0b3/dftd3.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/dftd3.html,5,['energy'],['energy']
Energy Efficiency,"lt-in function fd_geoms_freq_0 in module psi4; fd_geoms_freq_0(...). fd_geoms_freq_0( (Molecule)arg1, (int)arg2) -> matrix_vector :. Gets list of displacements needed for a finite difference frequency computation, from energy points, for a given irrep.; C++ signature :. St6vectorIN5boost10shared_ptrIN3psi6MatrixEEESaIS4_EE fd_geoms_freq_0(N5boost10shared_ptrIN3psi8MoleculeEEE,i). psi4.fd_geoms_freq_1()¶; Python Library Documentation: built-in function fd_geoms_freq_1 in module psi4; fd_geoms_freq_1(...). fd_geoms_freq_1( (Molecule)arg1, (int)arg2) -> matrix_vector :. Gets list of displacements needed fof a finite difference frequency computation, from gradients, for a given irrep; C++ signature :. St6vectorIN5boost10shared_ptrIN3psi6MatrixEEESaIS4_EE fd_geoms_freq_1(N5boost10shared_ptrIN3psi8MoleculeEEE,i). psi4.fisapt()¶; Python Library Documentation: built-in function fisapt in module psi4; fisapt(...). fisapt( (Wavefunction)arg1) -> float :. Runs the functional-group intramolecular symmetry adapted perturbation theory code.; C++ signature :. d fisapt(N5boost10shared_ptrIN3psi12WavefunctionEEE). psi4.flush_outfile()¶; Python Library Documentation: built-in function flush_outfile in module psi4; flush_outfile(...). flush_outfile() -> None :. Flushes the output file.; C++ signature :. void flush_outfile(). psi4.fnocc()¶; Python Library Documentation: built-in function fnocc in module psi4; fnocc(...). fnocc( (Wavefunction)arg1) -> Wavefunction :. Runs the fno-ccsd(t)/qcisd(t)/mp4/cepa energy code; C++ signature :. N5boost10shared_ptrIN3psi12WavefunctionEEE fnocc(N5boost10shared_ptrIN3psi12WavefunctionEEE). psi4.get_active_efp()¶; Python Library Documentation: built-in function get_active_efp in module psi4; get_active_efp(...). get_active_efp() -> EFP :. Returns the currently active EFP object.; C++ signature :. N5boost10shared_ptrIN3psi3efp3EFPEEE get_active_efp(). psi4.get_active_molecule()¶; Python Library Documentation: built-in function get_active_molecule in m",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:23686,adapt,adapted,23686,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['adapt'],['adapted']
Energy Efficiency,"lt.extras[""component_results""]. * collect ManyBody-flavored AtomicResult from self.get_results(); * build wfn from nbody mol and basis (always def2-svp); * push qcvars to P::e and wfn. push various internal dicts to qcvars, too; * convert result to psi4.core.Matrix (non-energy) and set g/h on wfn; * return e/g/h and wfn. """""". __all__ = [; ""BsseEnum"",; ""ManyBodyComputer"",; ""nbody"",; ]. import copy; import itertools; import math; from typing import Any, Callable, Dict, List, Literal, Optional, Sequence, Set, Tuple, Union, TYPE_CHECKING; from ast import literal_eval; from enum import Enum. from pydantic import Field, validator. import pprint; pp = pprint.PrettyPrinter(width=120, compact=True, indent=1); import logging. import numpy as np; from qcelemental.models import DriverEnum, AtomicResult. from psi4 import core; from psi4.driver import constants, driver_nbody_multilevel, p4util; from psi4.driver.p4util.exceptions import *; from psi4.driver.task_base import BaseComputer, AtomicComputer, EnergyGradientHessianWfnReturn; from psi4.driver.driver_cbs import CompositeComputer; from psi4.driver.driver_findif import FiniteDifferenceComputer. if TYPE_CHECKING:; import qcportal. logger = logging.getLogger(__name__). FragBasIndex = Tuple[Tuple[int], Tuple[int]]. SubTaskComputers = Union[AtomicComputer, CompositeComputer, FiniteDifferenceComputer]. [docs]def nbody():; """"""; Computes the nbody interaction energy, gradient, or Hessian depending on input.; This is a generalized universal function for computing interaction and total quantities. :returns: *return type of func* |w--w| The data. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| data and wavefunction with energy/gradient/hessian set appropriately when **return_wfn** specified. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'``",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_nbody.html:7779,Energy,EnergyGradientHessianWfnReturn,7779,psi4manual/1.7.x/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_nbody.html,1,['Energy'],['EnergyGradientHessianWfnReturn']
Energy Efficiency,"lt: 1.0e-11. COSX_OVERLAP_FITTING (SCF)¶SCF (Expert) — Do reduce numerical COSX errors with overlap fitting?. Type: boolean; Default: true. COSX_PRUNING_SCHEME (SCF)¶SCF (Expert) — Pruning scheme for COSX grids. Type: string; Default: ROBUST. COSX_RADIAL_POINTS_FINAL (SCF)¶SCF — Number of radial points in final COSX grid. Type: integer; Default: 35. COSX_RADIAL_POINTS_INITIAL (SCF)¶SCF — Number of radial points in initial COSX grid. Type: integer; Default: 25. COSX_SPHERICAL_POINTS_FINAL (SCF)¶SCF — Number of spherical points in final COSX grid. Type: integer; Default: 110. COSX_SPHERICAL_POINTS_INITIAL (SCF)¶SCF — Number of spherical points in initial COSX grid. Type: integer; Default: 50. COUPLED_INDUCTION (SAPT)¶SAPT (Expert) — Solve the CPHF equations to compute coupled induction and exchange-induction. These are not available for ROHF, and the option is automatically false in this case. In all other cases, coupled induction is strongly recommended. Only turn it off if the induction energy is not going to be used. Type: boolean; Default: true. COUPLING (PSIMRCC)¶PSIMRCC — The order of coupling terms to include in MRCCSDT computations. Type: string; Possible Values: NONE, LINEAR, QUADRATIC, CUBIC; Default: CUBIC. COUPLING_TERMS (PSIMRCC)¶PSIMRCC — Do include the terms that couple the reference determinants?. Type: boolean; Default: true. COVALENT_CONNECT (OPTKING)¶OPTKING — When determining connectivity, a bond is assigned if interatomic distance is less than (this number) * sum of covalent radii. Type: double; Default: 1.3. CPHF_MEM_SAFETY_FACTOR (CPHF)¶CPHF — Memory safety factor for allocating JK. Type: double; Default: 0.75. CPHF_TASKS (CPHF)¶CPHF — Which tasks to run CPHF For * Valid choices: * -Polarizability *. Type: array; Default: No Default. CUBEPROP_BASIS_FUNCTIONS (GLOBALS)¶GLOBALS — List of basis function indices for which cube files are generated (1-based). All basis functions computed if empty. Type: array; Default: No Default. CUBEPROP_FILEPATH (G",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodoc_glossary_options_c.html:90314,energy,energy,90314,psi4manual/1.6.x/autodoc_glossary_options_c.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodoc_glossary_options_c.html,3,['energy'],['energy']
Energy Efficiency,"lt: FLETCHER_REEVES. PCG_CONVERGENCE (DFOCC)¶DFOCC — Convergence criterion for residual vector of preconditioned conjugate gradient method. If this keyword is not set by the user, DFOCC will estimate and use a value required to achieve R_CONVERGENCE residual convergence. The listed default will be used for the default value of R_CONVERGENCE. Type: conv double; Default: 1e-7. PCG_CONVERGENCE (OCC)¶OCC — Convergence criterion for residual vector of preconditioned conjugate gradient method. Type: conv double; Default: 1e-6. PCG_MAXITER (DFOCC)¶DFOCC — Maximum number of preconditioned conjugate gradient iterations. Type: integer; Default: 50. PCG_MAXITER (OCC)¶OCC — Maximum number of preconditioned conjugate gradient iterations. Type: integer; Default: 30. PCM (GLOBALS)¶GLOBALS — PCM boolean for pcmsolver module. Type: boolean; Default: false. PCM_CC_TYPE (PCM)¶PCM — PCM-CCSD algorithm type. Type: string; Possible Values: PTE; Default: PTE. PCM_SCF_TYPE (PCM)¶PCM (Expert) — Use total or separate potentials and charges in the PCM-SCF step. Type: string; Possible Values: TOTAL, SEPARATE; Default: TOTAL. PCMSOLVER_PARSED_FNAME (PCM)¶PCM (Expert) — Name of the PCMSolver input file as parsed by pcmsolver.py. Type: string; Default: No Default. PE (GLOBALS)¶GLOBALS — PE boolean for polarizable embedding module. Type: boolean; Default: false. PE_ECP (PE)¶PE — use PE(ECP) repulsive potentials. Type: boolean; Default: false. PERTURB_CBS (PSIMRCC)¶PSIMRCC — Removed in 1.4. Will raise an error in 1.5. Type: boolean; Default: false. PERTURB_CBS_COUPLING (PSIMRCC)¶PSIMRCC — Removed in 1.4. Will raise an error in 1.5. Type: boolean; Default: true. PERTURB_DIPOLE (SCF)¶SCF — An array of length three describing the magnitude (atomic units) of the dipole field in the {x,y,z} directions. Type: array; Default: No Default. PERTURB_H (SCF)¶SCF — Do perturb the Hamiltonian?. Type: boolean; Default: false. PERTURB_MAGNITUDE (DETCI)¶DETCI (Expert) — The magnitude of perturbation \(z\) in \(H = ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html:186978,charge,charges,186978,psi4manual/1.4.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html,9,['charge'],['charges']
Energy Efficiency,"lt: No Default. DF_BASIS_SAPT¶. Auxiliary basis set for SAPT density fitting computations. Defaults to a RI basis. Type: string; Possible Values: basis string; Default: No Default. FREEZE_CORE¶. Specifies how many core orbitals to freeze in correlated computations. TRUE or 1 will default to freezing the previous noble gas shell on each atom. In case of positive charges on fragments, an additional shell may be unfrozen, to ensure there are valence electrons in each fragment. With FALSE or 0, no electrons are frozen (with the exception of electrons treated by an ECP). With -1, -2, and -3, the user might request strict freezing of the previous first/second/third noble gas shell on every atom. In this case, when there are no valence electrons, the code raises an exception. More precise control over the number of frozen orbitals can be attained by using the keywords NUM_FROZEN_DOCC (gives the total number of orbitals to freeze, program picks the lowest-energy orbitals) or FROZEN_DOCC (gives the number of orbitals to freeze per irreducible representation) or by the option POLICY in combination with appropriate inputs to FREEZE_CORE_POLICY At present, POLICY is an experimental option and is subject to change. Type: string; Possible Values: FALSE, TRUE, 1, 0, -1, -2, -3, POLICY; Default: FALSE. PRINT¶. The amount of information to print to the output file for the sapt module. For 0, only the header and final results are printed. For 1, (recommended for large calculations) some intermediate quantities are also printed. Type: integer; Default: 1. Advanced Keywords for Higher-order SAPT¶. DO_CCD_DISP¶. Do CCD dispersion correction in SAPT2+, SAPT2+(3) or SAPT2+3?. Type: boolean; Default: false. DO_MBPT_DISP¶. Do MBPT dispersion correction in SAPT2+, SAPT2+(3) or SAPT2+3, if also doing CCD?. Type: boolean; Default: true. DO_THIRD_ORDER¶. Do compute third-order corrections?. Type: boolean; Default: false. INTS_TOLERANCE¶. Schwarz screening threshold. Minimum absolute value below",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/sapt.html:29845,energy,energy,29845,psi4manual/1.7.x/sapt.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/sapt.html,4,['energy'],['energy']
Energy Efficiency,"lt_xtpl(nbasis, xtpl_type)[source]¶; A helper function to determine default extrapolation type. Parameters. nbasis (int) – Number of basis sets; xtpl_type (str) – {‘scf’, ‘corl’}; Extrapolation type: ‘scf’ for the total energy, ‘corl’ for just the; correlation component. Returns; Extrapolation function to be used. Return type; Callable. Aliases¶; When a particular composite method or its functional form is going to be; reused often, it is convenient to define an alias to it. A convenient; place for such Python code to reside is in psi4/psi4/driver/aliases.py; (source location) or psi4/lib/psi4/driver/aliases.py (installed; location). No recompilation is necessary after defining an alias. Some; existing examples are below. psi4.driver.aliases.sherrill_gold_standard(func, label, **kwargs)[source]¶; Function to call the quantum chemical method known as ‘Gold Standard’; in the Sherrill group. Uses cbs() to evaluate; the following expression. Two-point extrapolation of the correlation energy; performed according to corl_xtpl_helgaker_2(). \[E_{total}^{\text{Au\_std}} = E_{total,\; \text{SCF}}^{\text{aug-cc-pVQZ}} \; + E_{corl,\; \text{MP2}}^{\text{aug-cc-pV[TQ]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD(T)}}\big\vert_{\text{aug-cc-pVTZ}}\]; >>> # [1] single-point energy by this composite method; >>> energy('sherrill_gold_standard'). >>> # [2] finite-difference geometry optimization; >>> optimize('sherrill_gold_standard'). >>> # [3] finite-difference geometry optimization, overwriting some pre-defined sherrill_gold_standard options; >>> optimize('sherrill_gold_standard', corl_basis='cc-pV[DT]Z', delta_basis='3-21g'). psi4.driver.aliases.allen_focal_point(func, label, **kwargs)[source]¶; Function to call Wes Allen-style Focal; Point Analysis. JCP 127 014306. Uses; cbs() to evaluate the following; expression. SCF employs a three-point extrapolation according; to scf_xtpl_helgaker_3(). MP2, CCSD, and; CCSD(T) employ two-point extrapolation performed according to; corl_xtpl_helg",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/cbs-1.html:26534,energy,energy,26534,psi4manual/1.4.0/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/cbs-1.html,4,['energy'],['energy']
Energy Efficiency,"lta4_wfn_lesser'] = 'mrccsdt'; if not ('delta4_basis' in kwargs):; kwargs['delta4_basis'] = 'cc-pVDZ'; if not ('delta4_scheme' in kwargs):; kwargs['delta4_scheme'] = highest_1. return cbs(name, **kwargs). #def run_mp2_5(name, **kwargs):; # r""""""Function that computes MP2.5 energy from results of a FNOCC; # MP3 calculation.; #; # .. math:: E_{total}^{\text{MP2.5}} = E_{total,\; \text{SCF}} \; + E_{corl,\; \text{MP2}} + E_{corl, \; \text{MP3}}; #; # :PSI variables:; #; # .. hlist::; # :columns: 1; #; # * :psivar:`MP2.5 TOTAL ENERGY <MP2.5TOTALENERGY>`; # * :psivar:`MP2.5 CORRELATION ENERGY <MP2.5CORRELATIONENERGY>`; #; # >>> energy('mp2.5'); #; # """"""; # lowername = name.lower(); # kwargs = kwargs_lower(kwargs); #; # # Run detci calculation and collect conventional quantities; # energy('mp3', **kwargs); # e_scf = psi4.get_variable('SCF TOTAL ENERGY'); # ce_mp2 = psi4.get_variable('MP2 CORRELATION ENERGY'); # ce_mp3 = psi4.get_variable('MP3 CORRELATION ENERGY'); # e_mp2 = e_scf + ce_mp2; # e_mp3 = e_scf + ce_mp3; #; # # Compute quantities particular to MP2.5; # ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); # e_mp25 = e_scf + ce_mp25; # psi4.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25); # psi4.set_variable('MP2.5 TOTAL ENERGY', e_mp25); # psi4.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); # psi4.set_variable('CURRENT ENERGY', e_mp25); #; # # build string of title banner and print results; # banners = ''; # banners += """"""psi4.print_out('\\n')\n""""""; # banners += """"""banner(' MP2.5 ')\n""""""; # banners += """"""psi4.print_out('\\n')\n\n""""""; # exec(banners); #; # tables = ''; # tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); # tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); # tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); # tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); # tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); # tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); # tables += """""" MP3 correlation energy: %16.8f\n",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/aliases.html:7092,ENERGY,ENERGY,7092,psi4manual/4.0b5/_modules/aliases.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/aliases.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"lta_{MP2}^{(2)} - (E_{ind-disp}^{(30)} + E_{exch-ind-disp}^{(30)})\]; where \(E_{int}^{MP2, corr}\) is the correlation part of the supermolecular MP2; interaction energy. \(\delta_{MP2}^{(2)}\) and \(\delta_{MP2}^{(3)}\) also improve the; description of electrostatically dominated complexes. \(\delta_{MP2}^{(2)}\); can be applied to SAPT2+ or SAPT2+(3) energies whereas \(\delta_{MP2}^{(3)}\); should be applied to SAPT2+3 energies.; A thorough analysis of the performance of these truncations of closed-shell SAPT can be; found in a review by Hohenstein and Sherrill [Hohenstein:2012:WIREs],; and a systematic study of the accuracy of these truncations (with and; without an improved CCD treatment of dispersion) using different basis sets; is reported in [Parker:2014:094106].; The closed-shell SAPT module relies entirely on the density-fitting approximation; of the two-electron integrals. The factorization of the SAPT energy; expressions, as implemented in PSI4, assumes the use of density-fitted; two-electron integrals, therefore, the closed-shell SAPT module cannot be run with; exact integrals. In practice, we have found that the density-fitting; approximation introduces negligible errors into the SAPT energy; (often less than 0.01 kcal/mol for small dimers) and greatly; improves efficiency.; The latest addition to the SAPT code is the SAPT0 method for open-shell; monomers [Gonthier:2016:134106]. This code is available for both exact and density fitted integrals,; except for the dispersion terms which implementation relies on a density fitting; factorization. Both UHF and ROHF REFERENCE can be used, but coupled; induction computations are currently not supported with ROHF. This means that orbital; relaxation is not included for ROHF and the uncoupled induction term is computed instead.; If both monomers are open-shell, their coupling is assumed to be high spin, i.e.; two doublets would interact to form a triplet. The S2 approximation and scaling¶; All exchange terms in SA",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/sapt-1.html:5400,energy,energy,5400,psi4manual/1.1.0/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/sapt-1.html,15,['energy'],['energy']
Energy Efficiency,"lti; BH single points, checking that program can run multiple instances of DETCI in a single input, without an intervening clean() call. dct-grad2; RHF-ODC-12 analytic gradient computations for H2O use AO_BASIS=DISK and AO_BASIS=NONE, respectively. RHF-ODC-06 analytic gradient computations for H2O use AO_BASIS=DISK and AO_BASIS=NONE, respectively. dfomp2-1; OMP2 cc-pVDZ energy for the H2O molecule. cbs-xtpl-freq; Various gradients for a strained helium dimer and water molecule. sapt-compare; SAPT0 aug-cc-pVDZ computation of the water-water interaction energy, using the three SAPT codes. cc33; CC3(UHF)/cc-pVDZ H2O \(R_e\) geom from Olsen et al., JCP 104, 8007 (1996). sapt8; SAPT0(ROHF) open-shell computation of CN - Ne interaction energy First with jun-cc-pVDZ and density fitted integrals with ROHF Then with cc-pVDZ and direct integrals, except for dispersion that is computed with cc-pVDZ-ri density fitting with ROHF. dft-custom-dhdf; DSD-PBEP86 S22 Ammonia test. omp2-3; OMP2 cc-pVDZ energy for the NO radical. castup3; SCF with various combinations of pk/density-fitting, castup/no-castup, and spherical/cartesian settings. Demonstrates that puream setting is getting set by orbital basis for all df/castup parts of calc. Demonstrates that answer doesn’t depend on presence/absence of castup. Demonstrates (by comparison to castup2) that output file doesn’t depend on options (scf_type) being set global or local. This input uses local. scf-response2; Compute the dipole polarizability for water with custom basis set. scf-guess-read3; Test if the the guess read in the same basis converges. scf-level-shift-uhf; SCF level shift on a UHF computation. nbody-convergence; Convergence of many-body gradients of different BSSE schemes. omp3-1; OMP3 cc-pVDZ energy for the H2O molecule. dfccsd-grad1; DF-CCSD cc-pVDZ gradients for the H2O molecule. soscf-ref; Triple and Singlet Oxygen energy SOSCF, also tests non-symmetric density matrices. cbs-xtpl-nbody; RHF interaction energies using ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html:13287,energy,energy,13287,psi4manual/master/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"ltiplicity(3). """"""; self.PYmultiplicity_specified = True; self.PYmultiplicity = mult. [docs] def multiplicity_specified(self):; """"""Whether the multiplicity was given by the user. >>> print H2OH2O.multiplicity_specified(); True. """"""; return self.PYmultiplicity_specified. [docs] def units(self):; """"""Gets the geometry units. >>> print H2OH2O.units(); Angstrom. """"""; return self.PYunits. [docs] def set_units(self, units):; """"""Sets the geometry units. >>> H2OH2O.set_units('Angstom'). """"""; if units == 'Angstrom' or units == 'Bohr':; self.PYunits = units; else:; raise ValidationError(""""""Argument to Molecule::set_units must be 'Angstrom' or 'Bohr'.""""""). [docs] def has_zmatrix(self):; """"""Gets the presence of any zmatrix entry. >>> print H2OH2O.has_zmatrix(); False. """"""; return self.zmat. [docs] def set_has_zmatrix(self, tf):; """"""Sets the presence of any zmatrix entry. >>> H2OH2O.set_has_zmatrix(True). """"""; self.zmat = tf. # <<< Simple Methods for Coordinates >>>. [docs] def Z(self, atom):; """"""Nuclear charge of atom (0-indexed). >>> print H2OH2O.Z(4); 1. """"""; return self.atoms[atom].Z(). [docs] def x(self, atom):; """"""x position of atom (0-indexed) in Bohr. >>> print H2OH2O.x(4); 3.17549201425. """"""; return self.input_units_to_au * self.atoms[atom].compute()[0]. [docs] def y(self, atom):; """"""y position of atom (0-indexed) in Bohr. >>> print H2OH2O.y(4); -0.706268134631. """"""; return self.input_units_to_au * self.atoms[atom].compute()[1]. [docs] def z(self, atom):; """"""z position of atom (0-indexed) in Bohr. >>> print H2OH2O.z(4); -1.43347254509. """"""; return self.input_units_to_au * self.atoms[atom].compute()[2]. [docs] def xyz(self, atom, posn=None):; """"""Returns a Vector3 with x, y, z position of atom (0-indexed); in Bohr or coordinate at *posn*. >>> print H2OH2O.xyz(4); [3.175492014248769, -0.7062681346308132, -1.4334725450878665]. """"""; temp = scale(self.atoms[atom].compute(), self.input_units_to_au); if posn >= 0:; return temp[posn]; else:; return temp. [docs] def mass(self, ato",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:7039,charge,charge,7039,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,2,['charge'],['charge']
Energy Efficiency,"lts <==\n'); PsiMod.print_out('\n'); eg2_0k = eg2 + zpe + hlc; PsiMod.print_out(' G1: %20.12lf\n' % (eqci + e_plus + e_2df + hlc1 + zpe)); PsiMod.print_out(' G2(MP2): %20.12lf\n' % eg2_mp2_0k); PsiMod.print_out(' G2: %20.12lf\n' % eg2_0k). PsiMod.set_variable(""G1 TOTAL ENERGY"",eqci + e_plus + e_2df + hlc1 + zpe); PsiMod.set_variable(""G2 TOTAL ENERGY"",eg2_0k); PsiMod.set_variable(""G2(MP2) TOTAL ENERGY"",eg2_mp2_0k). PsiMod.print_out('\n'); T = PsiMod.get_global_option('T'); PsiMod.print_out(' ==> %3.0lf Kelvin Results <==\n'% T); PsiMod.print_out('\n'). internal_energy = eg2_mp2_0k + du - zpe / 0.8929; enthalpy = eg2_mp2_0k + dh - zpe / 0.8929; gibbs = eg2_mp2_0k + dg - zpe / 0.8929. PsiMod.print_out(' G2(MP2) energy: %20.12lf\n' % internal_energy ); PsiMod.print_out(' G2(MP2) enthalpy: %20.12lf\n' % enthalpy); PsiMod.print_out(' G2(MP2) free energy: %20.12lf\n' % gibbs); PsiMod.print_out('\n'). PsiMod.set_variable(""G2(MP2) INTERNAL ENERGY"",internal_energy); PsiMod.set_variable(""G2(MP2) ENTHALPY"",enthalpy); PsiMod.set_variable(""G2(MP2) FREE ENERGY"",gibbs). internal_energy = eg2_0k + du - zpe / 0.8929; enthalpy = eg2_0k + dh - zpe / 0.8929; gibbs = eg2_0k + dg - zpe / 0.8929. PsiMod.print_out(' G2 energy: %20.12lf\n' % internal_energy ); PsiMod.print_out(' G2 enthalpy: %20.12lf\n' % enthalpy); PsiMod.print_out(' G2 free energy: %20.12lf\n' % gibbs). PsiMod.set_variable(""CURRENT ENERGY"",eg2_0k). PsiMod.set_variable(""G2 INTERNAL ENERGY"",internal_energy); PsiMod.set_variable(""G2 ENTHALPY"",enthalpy); PsiMod.set_variable(""G2 FREE ENERGY"",gibbs). PsiMod.clean(). optstash.restore(). # return 0K g2 results; return eg2_0k. # aliases for g2; procedures['energy']['gaussian-2'] = run_gaussian_2; procedures['energy']['g2'] = run_gaussian_2. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; PSI4 [beta4] » ; Module code ». © Copyright 2013, The Psi4 Project.; Last updated on Mar 20, 2014.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/gaussian_n.html:4982,energy,energy,4982,psi4manual/4.0b4/_modules/gaussian_n.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/gaussian_n.html,12,"['ENERGY', 'energy']","['ENERGY', 'energy']"
Energy Efficiency,"lts,; },; 'return_result': ret_ptype,; 'success': True,; }). return nbody_model. [docs] def get_psi_results(self, return_wfn: bool = False) -> EnergyGradientHessianWfnReturn:; """"""Called by driver to assemble results into ManyBody-flavored QCSchema,; then reshape and return them in the customary Psi4 driver interface: ``(e/g/h, wfn)``. Parameters; ----------; return_wfn; Whether to additionally return the dummy :py:class:`~psi4.core.Wavefunction`; calculation result as the second element of a tuple. Contents are:. - supersystem molecule; - dummy basis, def2-svp; - e/g/h member data; - QCVariables. Returns; -------; ret; Energy, gradient, or Hessian according to self.driver.; wfn; Wavefunction described above when *return_wfn* specified. """"""; nbody_model = self.get_results(); ret = nbody_model.return_result. wfn = core.Wavefunction.build(self.molecule, ""def2-svp"", quiet=True). # TODO all besides nbody may be better candidates for extras than qcvars. energy/gradient/hessian_body_dict in particular are too simple for qcvars (e.g., ""2""); dicts = [; #""energies"", # retired; #""ptype"", # retired; ""intermediates"",; ""intermediates_energy"", #""intermediates2"",; ""intermediates_gradient"", #""intermediates_ptype"",; ""intermediates_hessian"", #""intermediates_ptype"",; ""energy_body_dict"",; ""gradient_body_dict"", # ptype_body_dict; ""hessian_body_dict"", # ptype_body_dict; ""nbody"",; ""cp_energy_body_dict"",; ""nocp_energy_body_dict"",; ""vmfc_energy_body_dict"",; ""cp_gradient_body_dict"",; ""nocp_gradient_body_dict"",; ""vmfc_gradient_body_dict"",; ""cp_hessian_body_dict"",; ""nocp_hessian_body_dict"",; ""vmfc_hessian_body_dict"",; ]. for qcv, val in nbody_model.extras['qcvars'].items():; if isinstance(val, dict):; if qcv in dicts:; for qcv2, val2 in val.items():; for obj in [core, wfn]:; try:; obj.set_variable(str(qcv2), val2); except ValidationError:; obj.set_variable(f""{self.driver.name} {qcv2}"", val2); else:; for obj in [core, wfn]:; obj.set_variable(qcv, val). if self.driver == 'gradient':; ret = core.M",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_nbody.html:91924,energy,energy,91924,psi4manual/1.7.x/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_nbody.html,2,['energy'],['energy']
Energy Efficiency,"lts,; },; 'return_result': ret_ptype,; 'success': True,; }). return nbody_model. [docs] def get_psi_results(self, return_wfn: bool = False) -> EnergyGradientHessianWfnReturn:; """"""Called by driver to assemble results into ManyBody-flavored QCSchema,; then reshape and return them in the customary Psi4 driver interface: ``(e/g/h, wfn)``. Parameters; ----------; return_wfn; Whether to additionally return the dummy :py:class:`~psi4.core.Wavefunction`; calculation result as the second element of a tuple. Contents are:. - supersystem molecule; - dummy basis, def2-svp; - e/g/h member data; - QCVariables. Returns; -------; ret; Energy, gradient, or Hessian according to self.driver.; wfn; Wavefunction described above when *return_wfn* specified. """"""; nbody_model = self.get_results(); ret = nbody_model.return_result. wfn = core.Wavefunction.build(self.molecule, ""def2-svp"", quiet=True). # TODO all besides nbody may be better candidates for extras than qcvars. energy/gradient/hessian_body_dict in particular are too simple for qcvars (e.g., ""2""); dicts = [; #""energies"", # retired; #""ptype"", # retired; ""intermediates"",; ""intermediates_energy"", #""intermediates2"",; ""intermediates_gradient"", #""intermediates_ptype"",; ""intermediates_hessian"", #""intermediates_ptype"",; ""energy_body_dict"",; ""gradient_body_dict"", # ptype_body_dict; ""hessian_body_dict"", # ptype_body_dict; ""nbody"",; ""cp_energy_body_dict"",; ""nocp_energy_body_dict"",; ""vmfc_energy_body_dict"",; ""cp_gradient_body_dict"",; ""nocp_gradient_body_dict"",; ""vmfc_gradient_body_dict"",; ""cp_hessian_body_dict"",; ""nocp_hessian_body_dict"",; ""vmfc_hessian_body_dict"",; ]. for qcv, val in nbody_model.extras['qcvars'].items():; if isinstance(val, dict):; if qcv in dicts:; for qcv2, val2 in val.items():; for obj in [core, wfn]:; try:; obj.set_variable(str(qcv2), val2); except ValidationError:; obj.set_variable(f""{self.driver} {qcv2}"", val2); else:; for obj in [core, wfn]:; obj.set_variable(qcv, val). if self.driver == 'gradient':; ret = core.Matrix",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html:91490,energy,energy,91490,psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html,2,['energy'],['energy']
Energy Efficiency,"lude singly excited configurations from a coupled-pair computation. Type: boolean; Default: false. CEPA_OS_SCALE (OCC)¶OCC — Removed in 1.4. Will raise an error in 1.5. Type: double; Default: 1.27. CEPA_SOS_SCALE (OCC)¶OCC — Removed in 1.4. Will raise an error in 1.5. Type: double; Default: 1.3. CEPA_SS_SCALE (OCC)¶OCC — Removed in 1.4. Will raise an error in 1.5. Type: double; Default: 1.13. CEPA_TYPE (OCC)¶OCC — CEPA type such as CEPA0, CEPA1 etc. currently we have only CEPA0. Type: string; Possible Values: CEPA0; Default: CEPA0. CFOUR_ABCDTYPE (CFOUR)¶CFOUR — Specifies the way the \(\langle ab||cd \rangle\) molecular orbital integrals are handled in post-MP2 calculations. STANDARD (= 0) uses directly the corresponding MO integrals and thus results in an algorithm which in particular for large-scale calculations results in excessive use of disk space (storage of all \(\langle ab||cd\rangle\) integrals. AOBASIS (=2) uses an AO-based algorithm to evaluate all terms involving the \(\langle ab||cd\rangle\) integrals and significantly reduces the amount of disk storage. The use of ABCDTYPE=AOBASIS is strongly recommended for all CC calculations up to CCSD(T) and has been implemented for energy, gradient, second-derivative, and excitation energy calculations. Type: string; Possible Values: STANDARD, AOBASIS; Default: STANDARD. CFOUR_ACTIVE_ORBI (CFOUR)¶CFOUR — Specifies the active orbitals used in a TCSCF calculation and has to be used in combination with the keyword CFOUR_CORE_ORBITALS. The active orbitals are specified by either NIRREP or 2*NIRREP integers specifying the number of active orbitals of each symmetry type, where NIRREP is the number of irreducible representations in the computational point group. If there are no orbitals of a particular symmetry type a zero must be entered. For more information and an example see CFOUR_OCCUPATION . Type: array; Default: No Default. CFOUR_ANH_ALGORITHM (CFOUR)¶CFOUR — Specifies which algorithm is used for CFOUR_ANHARMONIC ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html:18612,reduce,reduces,18612,psi4manual/1.4.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html,9,['reduce'],['reduces']
Energy Efficiency,"lue 1 (0) when the Brueckner orbitals have (have not) converged. CBS NUMBER¶. NBODY NUMBER¶. FINDIF NUMBER¶; Number of tasks [] the named procedure performs. These are immediate; tasks, so if procedures are nested, the total number of tasks is; the product. CBS TOTAL ENERGY¶. CBS CORRELATION ENERGY¶. CBS REFERENCE ENERGY¶; The total electronic energy [Eh] and its breakdown into reference total; energy [Eh] and correlation correction components [Eh] for the compound; method requested through cbs(). CCname ROOT n TOTAL ENERGY¶. TD-fctl ROOT n TOTAL ENERGY¶; The total electronic energy [Eh] for the requested theory and root n (n starts at 0).; DFT functional labeled if canonical. CCname ROOT n (IN h) TOTAL ENERGY¶. TD-fctl ROOT n (IN h) TOTAL ENERGY¶; The total electronic energy [Eh] for the requested theory and root n within irrep h (n starts at 0).; DFT functional labeled if canonical. CCname ROOT n (h) TOTAL ENERGY¶. TD-fctl ROOT n (h) TOTAL ENERGY¶; The total electronic energy [Eh] for the requested theory and root n, which is of irrep h (n starts at 0).; DFT functional labeled if canonical. CCname ROOT n TOTAL ENERGY - h TRANSITION¶. TD-fctl ROOT n TOTAL ENERGY - h TRANSITION¶; The total electronic energy [Eh] for the requested theory and root n, and the transition is of irrep h, (n starts at 0). CCname ROOT n CORRELATION ENERGY¶; The correlation energy [Eh] for the requested coupled cluster level of theory and root n (n starts at 0).; DFT functional labeled if canonical. CCname ROOT n (IN h) CORRELATION ENERGY¶; The correlation energy [Eh] for the requested coupled cluster level of theory and root n within irrep h (n starts at 0). CCname ROOT n (h) CORRELATION ENERGY¶; The correlation energy [Eh] for the requested coupled cluster level of theory and root n, which is of irrep h (n starts at 0). CCname ROOT n CORRELATION ENERGY - h TRANSITION¶; The correlation energy [Eh] for the requested coupled cluster level of theory and root n, and the transition is of irrep h,",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/glossary_psivariables.html:8982,energy,energy,8982,psi4manual/1.6.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/glossary_psivariables.html,1,['energy'],['energy']
Energy Efficiency,"lue DIIS starts. Type: double; Default: 1e-2. DMRG_SCF_GRAD_THR¶. The density RMS convergence to stop an instruction during successive DMRG instructions. Type: double; Default: 1.e-6. DMRG_SCF_MAX_ITER¶. Maximum number of DMRG iterations. Type: integer; Default: 100. DMRG_SCF_STATE_AVG¶. Whether or not to use state-averaging for roots >=2 with DMRG-SCF. Type: boolean; Default: true. DMRG_SWEEP_DVDSON_RTOL¶. The residual tolerances for the Davidson diagonalization during DMRG instructions. Type: array; Default: No Default. DMRG_SWEEP_ENERGY_CONV¶. The energy convergence to stop an instruction during successive DMRG instructions. Type: array; Default: No Default. DMRG_SWEEP_MAX_SWEEPS¶. The maximum number of sweeps to stop an instruction during successive DMRG instructions. Type: array; Default: No Default. DMRG_SWEEP_NOISE_PREFAC¶. The noiseprefactors for successive DMRG instructions. Type: array; Default: No Default. DMRG_SWEEP_STATES¶. The number of reduced renormalized basis states to be retained during successive DMRG instructions. Type: array; Default: No Default. DMRG_UNITARY_WRITE¶. Whether or not to store the unitary on disk (convenient for restarting). Type: boolean; Default: true. Table Of Contents. DMRG; General; DMRG_CASPT2_CALC; DMRG_CASPT2_IMAG; DMRG_CASPT2_IPEA; DMRG_CASPT2_ORBS; DMRG_DIIS; DMRG_DIIS_WRITE; DMRG_EXCITATION; DMRG_IRREP; DMRG_LOCAL_INIT; DMRG_MOLDEN_WRITE; DMRG_MPS_WRITE; DMRG_MULTIPLICITY; DMRG_OPDM_AO_PRINT; DMRG_PRINT_CORR; DMRG_SCF_ACTIVE_SPACE; DMRG_SCF_DIIS_THR; DMRG_SCF_GRAD_THR; DMRG_SCF_MAX_ITER; DMRG_SCF_STATE_AVG; DMRG_SWEEP_DVDSON_RTOL; DMRG_SWEEP_ENERGY_CONV; DMRG_SWEEP_MAX_SWEEPS; DMRG_SWEEP_NOISE_PREFAC; DMRG_SWEEP_STATES; DMRG_UNITARY_WRITE. Previous topic; WFN_TYPE; Next topic; DMRG_CASPT2_CALC. This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; Psi4 [1.0.0 6a9a71b] » ; Appendices »; Keywords by Module ». © Copy",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__dmrg-1.html:3462,reduce,reduced,3462,psi4manual/1.0.0/autodir_options_c/module__dmrg-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__dmrg-1.html,2,['reduce'],['reduced']
Energy Efficiency,"lue DIIS starts. Type: double; Default: 1e-2. DMRG_SCF_GRAD_THR¶. The density RMS convergence to stop an instruction during successive DMRG instructions. Type: double; Default: 1.e-6. DMRG_SCF_MAX_ITER¶. Maximum number of DMRG iterations. Type: integer; Default: 100. DMRG_SCF_STATE_AVG¶. Whether or not to use state-averaging for roots >=2 with DMRG-SCF. Type: boolean; Default: true. DMRG_SWEEP_DVDSON_RTOL¶. The residual tolerances for the Davidson diagonalization during DMRG instructions. Type: array; Default: No Default. DMRG_SWEEP_ENERGY_CONV¶. The energy convergence to stop an instruction during successive DMRG instructions. Type: array; Default: No Default. DMRG_SWEEP_MAX_SWEEPS¶. The maximum number of sweeps to stop an instruction during successive DMRG instructions. Type: array; Default: No Default. DMRG_SWEEP_NOISE_PREFAC¶. The noiseprefactors for successive DMRG instructions. Type: array; Default: No Default. DMRG_SWEEP_STATES¶. The number of reduced renormalized basis states to be retained during successive DMRG instructions. Type: array; Default: No Default. DMRG_UNITARY_WRITE¶. Whether or not to store the unitary on disk (convenient for restarting). Type: boolean; Default: true. Table Of Contents. Interface to CheMPS2 by S. Wouters; Installation; Methods; DMRG Keywords; DMRG_CASPT2_CALC; DMRG_CASPT2_IMAG; DMRG_CASPT2_IPEA; DMRG_CASPT2_ORBS; DMRG_DIIS; DMRG_DIIS_WRITE; DMRG_EXCITATION; DMRG_IRREP; DMRG_LOCAL_INIT; DMRG_MOLDEN_WRITE; DMRG_MPS_WRITE; DMRG_MULTIPLICITY; DMRG_OPDM_AO_PRINT; DMRG_PRINT_CORR; DMRG_SCF_ACTIVE_SPACE; DMRG_SCF_DIIS_THR; DMRG_SCF_GRAD_THR; DMRG_SCF_MAX_ITER; DMRG_SCF_STATE_AVG; DMRG_SWEEP_DVDSON_RTOL; DMRG_SWEEP_ENERGY_CONV; DMRG_SWEEP_MAX_SWEEPS; DMRG_SWEEP_NOISE_PREFAC; DMRG_SWEEP_STATES; DMRG_UNITARY_WRITE. Previous topic; Interface to CFOUR by J. Stanton and J. Gauss; Next topic; Interface to DFTD3 by S. Grimme. This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. mo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/chemps2-1.html:5279,reduce,reduced,5279,psi4manual/1.0.0/chemps2-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/chemps2-1.html,2,['reduce'],['reduced']
Energy Efficiency,"lue at the smaller basis set in 3-point; extrapolation.; zMD; Zeta number of the medium basis set in 3-point extrapolation.; Must be `zLO + 1`.; valueMD; Energy, gradient, or Hessian value at the medium basis set in 3-point; extrapolation.; zHI; Zeta number of the larger basis set in 3-point extrapolation.; Must be `zLO + 2`.; valueHI; Energy, gradient, or Hessian value at the larger basis set in 3-point; extrapolation.; verbose; Controls volume of printing.; alpha; Not used. Returns; -------; float or ndarray; Eponymous function applied to input zetas and values; type from `valueLO`. Notes; -----; The extrapolation is calculated according to [4]_:; :math:`E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}, \alpha = 3.0`. References; ----------. .. [4] Halkier, Helgaker, Jorgensen, Klopper, & Olsen, Chem. Phys. Lett. 302 (1999) 437-446,; DOI: 10.1016/S0009-2614(99)00179-7. Examples; --------; >>> # [1] Hartree-Fock extrapolation; >>> psi4.energy('cbs', scf_wfn='hf', scf_basis='cc-pV[DTQ]Z', scf_scheme='scf_xtpl_helgaker_3'). """""". if (type(valueLO) != type(valueMD)) or (type(valueMD) != type(valueHI)):; raise ValidationError(; f""scf_xtpl_helgaker_3: Inputs must be of the same datatype! ({type(valueLO)}, {type(valueMD)}, {type(valueHI)})""; ). if isinstance(valueLO, float):. ratio = (valueHI - valueMD) / (valueMD - valueLO); alpha = -1 * math.log(ratio); beta = (valueHI - valueMD) / (math.exp(-1 * alpha * zMD) * (ratio - 1)); value = valueHI - beta * math.exp(-1 * alpha * zHI). if verbose:; # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> Helgaker 3-point SCF extrapolation for method: %s <==\n\n"""""" % (; functionname.upper()); cbsscheme += """""" LO-zeta (%s) Energy: % 16.12f\n"""""" % (str(zLO), valueLO); cbsscheme += """""" MD-zeta (%s) Energy: % 16.12f\n"""""" % (str(zMD), valueMD); cbsscheme += """""" HI-zeta (%s) Energy: % 16.12f\n"""""" % (str(zHI), valueHI); cbsscheme += """""" Alpha (exponent) Value: % 16.12f\n"""""" % (alpha); cbsscheme += """""" B",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs_helper.html:14767,energy,energy,14767,psi4manual/1.6.x/_modules/psi4/driver/driver_cbs_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs_helper.html,2,['energy'],['energy']
Energy Efficiency,"lue'] = 'INTERNAL'; elif isCart and not isZMat:; options['CFOUR']['CFOUR_COORDINATES']['value'] = 'CARTESIAN'; else:; raise ValidationError(""""""Strange mix of Cartesian and ZMatrixEntries in molecule unsuitable for Cfour.""""""). return text, options. [docs] def format_molecule_for_nwchem(self):; """""". """"""; factor = 1.0 if self.PYunits == 'Angstrom' else psi_bohr2angstroms. text = """"; text += '%d %d %s\n' % (self.molecular_charge(), self.multiplicity(), self.tagline). for i in range(self.natom()):; [x, y, z] = self.atoms[i].compute(); text += '%4s %17.12f %17.12f %17.12f\n' % (("""" if self.Z(i) else 'Bq') + self.symbol(i), \; x * factor, y * factor, z * factor); return text; pass. # if symm print M2OUT ""nosym\nnoorient\n"";; # print DIOUT ""angstrom\ngeometry={\n"";. [docs] def auto_fragments(self):; """"""Detects fragments in an unfragmented molecule using BFS; algorithm. Returns a new Molecule in Cartesian, fixed-geom; (no variable values), no dummy-atom format. Any non-default; charge and multiplicity assigned to first fragment. """"""; if self.nfragments() != 1:; print(""""""Molecule already fragmented so no further action by auto_fragments().""""""); return self. flist = self.BFS(). # form new molecule through a string since self may contain; # dummies or zmatrix specs that mayn't be valid with atom shuffling; new_geom = '\n'. if self.PYcharge_specified or self.PYmultiplicity_specified:; new_geom = """"""\n %d %d\n"""""" % (self.molecular_charge(), self.multiplicity()). for fr in range(len(flist)):; new_geom += """" if fr == 0 else "" --\n""; for at in flist[fr]:; geom = self.atoms[at].compute(); new_geom += """"""%-4s """""" % (("""" if self.Z(at) else ""@"") + self.symbol(at)); for j in range(3):; new_geom += """""" %17.12f"""""" % (geom[j]); new_geom += ""\n""; new_geom += "" units %s\n"" % (self.units()); if not self.PYmove_to_com:; new_geom += "" no_com\n""; if self.orientation_fixed():; new_geom += "" no_reorient\n"". subset = Molecule(new_geom); subset.update_geometry(); return subset. [docs] def BFS(self):; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molecule.html:26420,charge,charge,26420,psi4manual/1.0.0/_modules/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molecule.html,1,['charge'],['charge']
Energy Efficiency,"lue. \[\frac{1}{n}\sum_{rxn}^{n}{\textsf{\textsl{name}}_{rxn}-\text{REF}_{rxn}}\]. db_name DATABASE ROOT-MEAN-SQUARE DEVIATION¶; The rms deviation [kcal mol-1] of the requested method name; from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. \[\sqrt{\frac{1}{n}\sum_{rxn}^{n}{(\textsf{\textsl{name}}_{rxn}-\text{REF}_{rxn})^2}}\]. DCT LAMBDA ENERGY¶; An energy term in density cumulant theory [Eh]. This term is the; 2-electron cumulant’s contribution contribution to the reduced; density matrix energy expression. Not recommended for interpretative; use except by reduced density matrix specialists. DCT SCF ENERGY¶; An energy term in density cumulant theory [Eh]. This term is the; 1-electron reduced density matrix (1RDM) contribution to the reduced; density matrix energy expression, plus the contribution of the; antisymmetrized product of 1RDMs. Not recommended for interpretative; use except by reduced density matrix specialists. DCT THREE-PARTICLE ENERGY¶; The three-particle correlation energy correction [Eh] in density cumulant; theory, akin to (T) CORRECTION ENERGY in coupled-cluster. DCT TOTAL ENERGY¶; Total energy [Eh] in density cumulant theory. Sum of DCT SCF ENERGY,; DCT LAMBDA ENERGY, and DCT THREE-PARTICLE ENERGY when present. DETCI AVG DVEC NORM¶; A measure of configuration interaction convergence. DFT FUNCTIONAL TOTAL ENERGY¶; The total electronic energy [Eh] for the underlying functional of the; requested DFT method, without any dispersion correction; the first four; terms in Eq. (4) or (1). Quantity; \(E_{\text{FCTL}}\) in Eqs. (4) and (1).; Unless the method includes a dispersion correction, this quantity is; equal to SCF TOTAL ENERGY. DFT TOTAL ENERGY¶; The total electronic energy [Eh] for the requested DFT method,; \(E_{\text{DFT}}\) in Eq. (1). \begin{align*}; E_{\text{DFT}} & = E_{NN} + E_{1e^-} + E_{2e^-} + E_{xc} + E_{\text{-D}} + E_{\text{DH}} \\",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html:18664,reduce,reduced,18664,psi4manual/1.4.0/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html,5,['reduce'],['reduced']
Energy Efficiency,"lueHI.clone(); beta.name = 'Helgaker SCF (%s, %s) beta' % (zLO, zHI); beta.subtract(valueLO); beta.scale(beta_division); beta.scale(beta_mult). value = valueHI.clone(); value.subtract(beta); value.name = 'Helgaker SCF (%s, %s) data' % (zLO, zHI). if verbose > 2:; core.print_out(""""""\n ==> Helgaker 2-point exponential SCF extrapolation for method: %s <==\n\n"""""" % (functionname.upper())); core.print_out("""""" LO-zeta (%s)"""""" % str(zLO)); core.print_out("""""" LO-zeta Data""""""); valueLO.print_out(); core.print_out("""""" HI-zeta (%s)"""""" % str(zHI)); core.print_out("""""" HI-zeta Data""""""); valueHI.print_out(); core.print_out("""""" Extrapolated Data:\n""""""); value.print_out(); core.print_out("""""" Alpha (exponent) Value: %16.8f\n"""""" % (alpha)); core.print_out("""""" Beta Data:\n""""""); beta.print_out(). return value. else:; raise ValidationError(""scf_xtpl_helgaker_2: datatype is not recognized '%s'."" % type(valueLO)). def scf_xtpl_truhlar_2(functionname, zLO, valueLO, zHI, valueHI, verbose=True, alpha=None):; r""""""Extrapolation scheme using power form for reference energies with two adjacent zeta-level bases.; Used by :py:func:`~psi4.cbs`.; Truhlar, Chem. Phys. Lett. 294 (1998) 45-48, DOI: 10.1016/S0009-2614(98)00866-5. .. math:: E_{total}^X = E_{total}^{\infty} + \beta X^{-\alpha}, \alpha = 3.4. """""". if type(valueLO) != type(valueHI):; raise ValidationError(""scf_xtpl_truhlar_2: Inputs must be of the same datatype! (%s, %s)""; % (type(valueLO), type(valueHI))). if alpha is None:; alpha = 3.40. beta_division = 1 / (zHI ** (-1 * alpha) - zLO ** (-1 * alpha)); beta_mult = zHI ** (-1 * alpha). if isinstance(valueLO, float):; beta = (valueHI - valueLO) * beta_division; value = valueHI - beta * beta_mult. if verbose:; # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> Truhlar 2-point power form SCF extrapolation for method: %s <==\n\n"""""" % (functionname.upper()); cbsscheme += """""" LO-zeta (%s) Energy: % 16.12f\n"""""" % (str(zLO), valueLO); cbsscheme += """""" HI-zeta (%s) ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html:8780,power,power,8780,psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html,1,['power'],['power']
Energy Efficiency,"lueLO); cbsscheme += f""""""\n HI-zeta ({zHI}) Data\n""""""; cbsscheme += nppp(valueHI). cbsscheme += f""""""\n Alpha (exponent) Value: {alpha:16.8f}""""""; cbsscheme += f""""""\n Beta Data\n""""""; cbsscheme += nppp(beta); cbsscheme += f""""""\n Extrapolated Data\n""""""; cbsscheme += nppp(value); cbsscheme += ""\n""; core.print_out(cbsscheme); logger.debug(cbsscheme). return value. else:; raise ValidationError(f""scf_xtpl_helgaker_2: datatype is not recognized '{type(valueLO)}'.""). [docs]def scf_xtpl_truhlar_2(functionname: str, zLO: int, valueLO: Extrapolatable, zHI: int, valueHI: Extrapolatable, verbose: int = 1, alpha: Optional[float] = None) -> Extrapolatable:; r""""""Extrapolation scheme using power form for reference energies with two adjacent; zeta-level bases. Used by :py:func:`~psi4.cbs`. Parameters; ----------; functionname; Name of the CBS component (e.g., 'HF') used in summary printing.; zLO; Zeta number of the smaller basis set in 2-point extrapolation.; valueLO; Energy, gradient, or Hessian value at the smaller basis set in 2-point; extrapolation.; zHI; Zeta number of the larger basis set in 2-point extrapolation; Must be `zLO + 1`.; valueHI; Energy, gradient, or Hessian value at the larger basis set in 2-point; extrapolation.; verbose; Controls volume of printing.; alpha; Overrides the default :math:`\alpha = 3.4`. Returns; -------; float or ndarray; Eponymous function applied to input zetas and values; type from `valueLO`. Notes; -----; The extrapolation is calculated according to [2]_:; :math:`E_{total}^X = E_{total}^{\infty} + \beta X^{-\alpha}, \alpha = 3.4`. References; ----------. .. [2] Truhlar, Chem. Phys. Lett. 294 (1998) 45-48,; DOI: 10.1016/S0009-2614(98)00866-5. """""". if type(valueLO) != type(valueHI):; raise ValidationError(; f""scf_xtpl_truhlar_2: Inputs must be of the same datatype! ({type(valueLO)}, {type(valueHI)})""). if alpha is None:; alpha = 3.40. beta_division = 1 / (zHI**(-1 * alpha) - zLO**(-1 * alpha)); beta_mult = zHI**(-1 * alpha). if isinstance(valueLO, f",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs_helper.html:7126,Energy,Energy,7126,psi4manual/1.6.x/_modules/psi4/driver/driver_cbs_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs_helper.html,1,['Energy'],['Energy']
Energy Efficiency,"lues()):; nbody_results[""intermediates_hessian""] = trove[""hessian""]. debug = False; if debug:; for k, v in nbody_results.items():; if isinstance(v, np.ndarray):; print(f""CLS-prepared results >>> {k} {v.size}""); elif isinstance(v, dict):; print(f""CLS-prepared results >>> {k} {len(v)}""); for k2, v2 in v.items():; if isinstance(v2, np.ndarray):; print(f""CLS-prepared results >>> {k2} {v2.size}""); else:; print(f""CLS-prepared results >>> {k2} {v2}""); else:; print(f""CLS-prepared results >>> {k} {v}""). return nbody_results. [docs] def get_results(self, client: Optional[""qcportal.FractalClient""] = None) -> AtomicResult:; """"""Return results as ManyBody-flavored QCSchema."""""". info = ""\n"" + p4util.banner(f"" ManyBody Results "", strNotOutfile=True) + ""\n""; core.print_out(info); logger.info(info). results = self.prepare_results(client=client); ret_energy = results.pop(""ret_energy""); ret_ptype = results.pop(""ret_ptype""); ret_gradient = results.pop(""ret_gradient"", None). # load QCVariables; qcvars = {; 'NUCLEAR REPULSION ENERGY': self.molecule.nuclear_repulsion_energy(),; 'NBODY NUMBER': len(self.task_list),; }. properties = {; ""calcinfo_natom"": self.molecule.natom(),; ""nuclear_repulsion_energy"": self.molecule.nuclear_repulsion_energy(),; ""return_energy"": ret_energy,; }. for k, val in results.items():; qcvars[k] = val. qcvars['CURRENT ENERGY'] = ret_energy; if self.driver == 'gradient':; qcvars['CURRENT GRADIENT'] = ret_ptype; properties[""return_gradient""] = ret_ptype; elif self.driver == 'hessian':; qcvars['CURRENT GRADIENT'] = ret_gradient; qcvars['CURRENT HESSIAN'] = ret_ptype; properties[""return_gradient""] = ret_gradient; properties[""return_hessian""] = ret_ptype. component_results = self.dict()['task_list']; for k, val in component_results.items():; val['molecule'] = val['molecule'].to_schema(dtype=2). nbody_model = AtomicResult(; **{; 'driver': self.driver,; 'model': {; 'method': self.method,; 'basis': self.basis,; },; 'molecule': self.molecule.to_schema(dtype=2),; 'properties':",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_nbody.html:89850,ENERGY,ENERGY,89850,psi4manual/1.7.x/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_nbody.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"lues. scf-uhf-grad-nobeta; UHF gradient for a one-electron system (no beta electrons). pywrap-align; apply linear fragmentation algorithm to a water cluster. dft-b2plyp; Double-hybrid density functional B2PYLP. Reproduces portion of Table I in S. Grimme’s J. Chem. Phys 124 034108 (2006) paper defining the functional. fnocc6; Test method/basis with disk_df. isapt-charged; This test case shows an example of running the I-SAPT0/aug-cc-pVDZ computation for a positively charged system, illustrating the cation-pi interaction. The SIAO1 link partitioning algorithm is used. The system is taken from http://dx.doi.org/10.1016/j.comptc.2014.02.008. cc13; UHF-CCSD/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. dft-freq; Frequencies for H2O B3LYP/6-31G* at optimized geometry. props2; DF-SCF cc-pVDZ of benzene-hydronium ion, scanning the dissociation coordinate with Python’s built-in loop mechanism. The geometry is specified by a Z-matrix with dummy atoms, fixed parameters, updated parameters, and separate charge/multiplicity specifiers for each monomer. One-electron properties computed for dimer and one monomer. dlpnomp2-2; comparison of DF-MP2 and DLPNO-MP2 with a CBS extrapolation. cepa-module; routing check on lccd, lccsd, cepa(0). dfccsd-t-grad1; DF-CCSD(T) cc-pVDZ gradients for the H2O molecule. olccd2; OLCCD cc-pVDZ energy with B3LYP initial guess for the NO radical. ao-casscf-sp; CASSCF/6-31G** energy point. cisd-h2o+-0; 6-31G** H2O+ Test CISD Energy Point. dfmp2-freq1; DF-MP2 frequency by difference of energies for H2O. scf4; RHF cc-pVDZ energy for water, automatically scanning the symmetric stretch and bending coordinates using Python’s built-in loop mechanisms. The geometry is specified using a Z-matrix with variables that are updated during the potential energy surface scan, and then the same procedure is performed using polar coordinates, converted to Cartesian coordinates. cc33; CC3(UHF)/cc-pVDZ H2O \(R_e\) geom from Olsen et al., JCP 104, 800",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html:38287,charge,charge,38287,psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,2,['charge'],['charge']
Energy Efficiency,"luster Theory¶; This DETCI-based version of this feature is not yet released. However,; the current version of the code does include an interface to; Kallay’s MRCC code.; The DETCI module is also capable of computing arbitrary-order; coupled-cluster energies, using an approach similar to that of Hirata; and Bartlett [Hirata:2000:216], or of Olsen [Olsen:2000:7140].; Notably, the approach in DETCI also allows arbitrary-order; active space coupled-cluster procedures. The general algorithm; for doing this in DETCI is inefficient compared to optimized; lower-order coupled-cluster codes and should not be used for CCSD,; where the CCENERGY module is much more efficient. For higher-order; CC (like CCSDT and beyond), the code is also not as efficient as the; MRCC code by Kállay, to which PSI4 can interface (see Section; Interface to MRCC by M. Kállay); however, it may allow certain truncations of the model; space that might not be available presently in MRCC. For very small; systems, the code can be useful for testing of, for example, CCSDTQ or; its active-space CCSDtq analog [Piecuch:1999:6103].; To perform arbitrary-order coupled-cluster, set the DETCI; option CC to TRUE, and set; CC_EX_LEVEL (note: not EX_LEVEL); to the desired coupled-cluster excitation level, and invoke; energy('detci'). Various other DETCI options have a similar; option for coupled-cluster, usually named beginning with CC. The full; list of options is given in Appendix DETCI. table of contents. CI: Configuration Interaction; Basic DETCI Keywords; REFERENCE; R_CONVERGENCE; EX_LEVEL; FCI; FROZEN_DOCC; RESTRICTED_DOCC; RESTRICTED_UOCC; FROZEN_UOCC; CI_MAXITER; NUM_ROOTS; ICORE; DIAG_METHOD; OPDM; TDM; DIPMOM; MPN. Arbitrary Order Perturbation Theory; Arbitrary Order Coupled-Cluster Theory. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Theoretical Methods: SCF to FCI. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/detci-1.html:12850,energy,energy,12850,psi4manual/1.1.0/detci-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/detci-1.html,2,['energy'],['energy']
Energy Efficiency,"luster lambda (response) equations. LOWDIN CHARGES¶; Property of partial atomic charges [e] by the method of Löwdin, (nat,). MAYER INDICES¶; Property of Mayer bond indices, (nat, nat). MBIS CHARGES¶. MBIS DIPOLES¶. MBIS OCTUPOLES¶. MBIS QUADRUPOLES¶; Per-atom charges [e], dipoles [e a0], quadrupoles [e a0^2], and octupoles [e a0^3]; resulting from partitioning the total electron density through the Minimal Basis; Iterative Stockholder (MBIS) Charge Partitioning Scheme. MBIS FREE ATOM n VOLUME¶; Free-atom volume [a0^3] for atom n, computed using the MBIS charge; partitioning scheme. Free atom densities are computed at the same; level of theory as the parent MBIS calculation, with UHF turned on; as needed. MBIS RADIAL MOMENTS <R^3>¶; Per-atom expectation value of r^3 [a0^3], equivalent to the volume; of the MBIS-partitioned density. MBIS VALENCE CHARGES¶; Per-atom valence charges [e] computed from an MBIS partitioned density. MBIS VALENCE WIDTHS¶; Per-atom density width [a0] of the associated valence charge computed; from an MBIS partitioned density. Equivalent to the inverse of the; linear decay rate of the atomic density. MBIS VOLUME RATIOS¶; Per-atom ratio between the atomic volume (<R^3>) and the free-atomic; volume, unitless. MCSCF TOTAL ENERGY¶; Multiconfigurational self-consistent-field energy [E_h] in the course of; a configuration interaction computation. May be single-root or state-averaged. mtd DIPOLE¶; Dipole array [e a0] for the named method, (3,). mtd QUADRUPOLE¶; Redundant quadrupole array [e a0^2] for the named method, (3, 3). mtd OCTUPOLE¶; Redundant octupole array [e a0^3] for the named method, (3, 3, 3). mtd HEXADECAPOLE¶; Redundant hexadecapole array [e a0^4] for the named method, (3, 3, 3, 3). mtd 32-POLE¶; Redundant 32-pole array [e a0^5] for the named method, (3, 3, 3, 3, 3). mtd 64-POLE¶; Redundant 64-pole array [e a0^6] for the named method, (3, 3, 3, 3, 3, 3). mtd 128-POLE¶; Redundant 128-pole array [e a0^7] for the named method, (3, 3, 3, 3, ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/glossary_psivariables.html:34942,charge,charge,34942,psi4manual/master/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/master/glossary_psivariables.html,1,['charge'],['charge']
Energy Efficiency,"luster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). psi4.gradient(name[, molecule, return_wfn, func, dertype])[source]; Function complementary to optimize(). Carries out one gradient pass,; deciding analytic or finite difference. Returns:; Matrix – Total electronic gradient in Hartrees/Bohr. Returns:; (Matrix, Wavefunction) – gradient and wavefunction when return_wfn specified. Examples:. >>> # [1] Single-point dft gradient getting the gradient; >>> # in file, core.Matrix, and np.array forms; >>> set gradient_write on; >>> G, wfn = gradient('b3lyp-d', return_wfn=True); >>> wfn.gradient().print_out(); >>> np.array(G). «; hide menu. menu; sidebar; »; . Navi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/opt.html:17085,energy,energy,17085,psi4manual/1.7.x/opt.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/opt.html,4,['energy'],['energy']
Energy Efficiency,"lution, but this should not be blindly assumed. (Default: The occupation is given by the core Hamiltonian initial guess). Psi4 Interface: The arrays above are specified in PSI as (white space tolerant) [3,1,1,0] and [[3,1,1,0],[3,0,1,0]]. Type: array; Default: No Default. CFOUR_OMP_NUM_THREADS (CFOUR)¶CFOUR (Expert) — Sets the OMP_NUM_THREADS environment variable before calling CFOUR. If the environment variable OMP_NUM_THREADS is set prior to calling Psi4 then that value is used. When set, this option overrides everything. Be aware the -n command-line option described in section Threading does not affect CFOUR. Type: integer; Default: 1. CFOUR_OPEN-SHELL (CFOUR)¶CFOUR — Specifies which kind of open-shell CC treatment is employed. The default is a spin-orbital CC treatment (SPIN-ORBITAL =1) which is the only possible choice for UHF-CC schemes anyways. For ROHF-CC treatments, the possible options are beside the standard spin-orbital scheme a spin-restricted CC approach (SR-CC=3), as well as a corresponding linear approximation (which in the literature usually is referred to as partially-spin-adapted CC scheme) (PSA-CC=1). SR-CC and PSA-CC are within the CCSD approximation restricted to excitations defined by the first-order interacting space arguments. With the keywords PSA-CC_FULL (=2) or SR-CC_FULL (=6) inclusion of the so called “pseudo-triples” beyond the first-order interacting space is also possible. The two-determinant CC method for open-shell singlet states can be activated by TD-CC (=8). Type: string; Possible Values: SPIN-ORBITAL, SR-CC, PSA-CC_FULL, SR-CC_FULL, TD-CC; Default: SPIN-ORBITAL. CFOUR_OPT_MAXCYC (CFOUR)¶CFOUR — Identical to CFOUR_GEO_MAXCYC. Type: integer; Default: 50. CFOUR_ORBITALS (CFOUR)¶CFOUR — Specifies the type of molecular orbitals used in post-HF calculations. STANDARD (=0) requests usage of the orbitals (from a corresponding HF-SCF calculation) without any modification. These are in the case of RHF/UHF the usual canonical HF orbitals a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html:62028,adapt,adapted,62028,psi4manual/1.4.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html,9,['adapt'],['adapted']
Energy Efficiency,"lver has already been installed alongside.; If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; PCMSolver can be obtained through conda install pcmsolver -c psi4.; Then enable it as a feature with ENABLE_PCMSolver,; hint its location with CMAKE_PREFIX_PATH,; and rebuild PSI4 to detect PCMSolver and activate dependent code. To remove a conda installation, conda remove pcmsolver. Source. If using PSI4 built from source and you want PCMSolver built from; from source also,; enable it as a feature with ENABLE_PCMSolver,; and let the build system fetch and build it and activate dependent code. Using the polarizable continuum model¶; The inclusion of a PCM description of the solvent into your calculation; is achieved by setting PCM true in your input file.; PSI4 understands the additional option PCM_SCF_TYPE with possible values total; (the default) or separate.; The latter forces the separate handling of nuclear and electronic electrostatic potentials and; polarization charges. It is mainly useful for debugging.; For the calculation of vertical excitation energies with PCM non-equilibrium solvation should be included with:; pcm = {; Medium {; Nonequilibrium = True; }; }. Note; At present PCM can only be used for energy calculations with SCF; wavefunctions and CC wavefunctions in the PTE approximation [Cammi:2009:164104].; All ERI algorithms (PK, OUT_OF_CORE, DIRECT, DF, CD) are supported. Note; linear response calculations (static polarisabilities, TD-SCF) are supported for RHF/UHF if available. Warning; The PCMSolver library cannot exploit molecular point group symmetry. Warning; ROHF with PCM is known not to work. See issue #999 on GitHub.; For the adventurous, a fix is available in pull request #953 on GitHub. Warning; Analytic gradients and Hessians are not available with PCM. Finite differences will be used; regardless of the dertype passed to the optimize function.; See pcmsolver/opt-fd for a s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/pcmsolver-1.html:1928,charge,charges,1928,psi4manual/1.4.0/pcmsolver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/pcmsolver-1.html,5,['charge'],['charges']
Energy Efficiency,"lvers). Type: string; Possible Values: DL, RAYLEIGH; Default: DL. SOS_TYPE (DFOCC)¶DFOCC — Type of the SOS method. Type: string; Possible Values: SOS, SOSPI; Default: SOS. SOS_TYPE (OCC)¶OCC — Type of the SOS method. Type: string; Possible Values: SOS, SOSPI; Default: SOS. SOSCF (SCF)¶SCF — Do use second-order SCF convergence methods?. Type: boolean; Default: false. SOSCF_CONV (SCF)¶SCF — Second order convergence threshold. Cease microiterating at this value. Type: conv double; Default: 5.0e-3. SOSCF_MAX_ITER (SCF)¶SCF — Maximum number of second-order microiterations to perform. Type: integer; Default: 5. SOSCF_MIN_ITER (SCF)¶SCF — Minimum number of second-order microiterations to perform. Type: integer; Default: 1. SOSCF_PRINT (SCF)¶SCF — Do we print the SOSCF microiterations?. Type: boolean; Default: false. SOSCF_START_CONVERGENCE (SCF)¶SCF — When to start second-order SCF iterations based on gradient RMS. Type: conv double; Default: 1.0e-2. SPIN_SCALE_TYPE (OCC)¶OCC (Expert) — Controls the spin scaling set to current energy. This is set by Psi internally. Type: string; Possible Values: NONE, CUSTOM, SCS, SCSN, SCSVDW, SOS, SOSPI; Default: NONE. SPINADAPT_ENERGIES (CCENERGY)¶CCENERGY — Do print spin-adapted pair energies?. Type: boolean; Default: false. SS_E_CONVERGENCE (CCEOM)¶CCEOM — Convergence criterion for excitation energy (change) in the Davidson algorithm for the CIS guess to CC-EOM. Type: conv double; Default: 1e-6. SS_R_CONVERGENCE (CCEOM)¶CCEOM — Convergence criterion for norm of the residual vector in the Davidson algorithm for the CIS guess to CC-EOM. Type: conv double; Default: 1e-6. SS_SCALE (OCC)¶OCC — A custom scaling parameter for same-spin terms in OCC. The result goes to a CUSTOM SCS variable, exact name method-dependent. Type: double; Default: 1. SS_SKIP_DIAG (CCEOM)¶CCEOM — Do skip diagonalization of Hbar SS block?. Type: boolean; Default: false. SS_VECS_PER_ROOT (CCEOM)¶CCEOM — SS vectors stored per root. Type: integer; Default: 5. SSAPT0_SC",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html:218833,energy,energy,218833,psi4manual/1.4.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html,4,['energy'],['energy']
Energy Efficiency,"lvers). Type: string; Possible Values: DL, RAYLEIGH; Default: DL. SOS_TYPE (DFOCC)¶DFOCC — Type of the SOS method. Type: string; Possible Values: SOS, SOSPI; Default: SOS. SOS_TYPE (OCC)¶OCC — Type of the SOS method. Type: string; Possible Values: SOS, SOSPI; Default: SOS. SOSCF (SCF)¶SCF — Do use second-order SCF convergence methods?. Type: boolean; Default: false. SOSCF_CONV (SCF)¶SCF — Second order convergence threshold. Cease microiterating at this value. Type: conv double; Default: 5.0e-3. SOSCF_MAX_ITER (SCF)¶SCF — Maximum number of second-order microiterations to perform. Type: integer; Default: 5. SOSCF_MIN_ITER (SCF)¶SCF — Minimum number of second-order microiterations to perform. Type: integer; Default: 1. SOSCF_PRINT (SCF)¶SCF — Do we print the SOSCF microiterations?. Type: boolean; Default: false. SOSCF_START_CONVERGENCE (SCF)¶SCF — When to start second-order SCF iterations based on gradient RMS. Type: conv double; Default: 1.0e-2. SPIN_SCALE_TYPE (OCC)¶OCC (Expert) — Controls the spin scaling set to current energy. This is set by Psi internally. Type: string; Possible Values: NONE, CUSTOM, SCS, SCSN, SCSVDW, SOS, SOSPI; Default: NONE. SS_E_CONVERGENCE (CCEOM)¶CCEOM — Convergence criterion for excitation energy (change) in the Davidson algorithm for the CIS guess to CC-EOM. Type: conv double; Default: 1e-6. SS_R_CONVERGENCE (CCEOM)¶CCEOM — Convergence criterion for norm of the residual vector in the Davidson algorithm for the CIS guess to CC-EOM. Type: conv double; Default: 1e-6. SS_SCALE (OCC)¶OCC — A custom scaling parameter for same-spin terms in OCC. The result goes to a CUSTOM SCS variable, exact name method-dependent. Type: double; Default: 1. SS_SKIP_DIAG (CCEOM)¶CCEOM — Do skip diagonalization of Hbar SS block?. Type: boolean; Default: false. SS_VECS_PER_ROOT (CCEOM)¶CCEOM — SS vectors stored per root. Type: integer; Default: 5. SSAPT0_SCALE (FISAPT)¶FISAPT — Do sSAPT0 exchange-scaling with F-SAPT. Type: boolean; Default: false. STABILITY_ADD_VEC",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodoc_glossary_options_c.html:223305,energy,energy,223305,psi4manual/1.6.x/autodoc_glossary_options_c.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodoc_glossary_options_c.html,1,['energy'],['energy']
Energy Efficiency,"lvl=None, dashparam=None, dertype=None, verbose=1)¶; Compute dispersion correction via Grimme’s DFTD3 program. Parameters. func (Optional[str]) – Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Any or all parameters initialized; from dashcoeff[dashlvl][func] can be overwritten via; dashparam.; dashlvl (Optional[str]) – Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or “alias” or; “formal” to one.; dashparam (Optional[Dict]) – Values for the same keys as dashcoeff[dashlvl][‘default’]; used to override any or all values initialized by func.; Extra parameters will error.; dertype (Union[int, str, None]) – Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int) – Amount of printing. Returns. energy (float) – When dertype=0, energy [Eh].; gradient (ndarray) – When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ndarray) – When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. class psi4.driver.procrouting.empirical_dispersion.EmpiricalDispersion(*, name_hint=None, level_hint=None, param_tweaks=None, engine=None, save_pairwise_disp=False)[source]¶; Lightweight unification of empirical dispersion calculation modes. dashlevel¶; {‘d1’, ‘d2’, ‘d3zero’, ‘d3bj’, ‘d3mzero’, ‘d3mbj’, ‘chg’, ‘das2009’, ‘das2010’, ‘nl’, ‘dmp2’}; Name of dispersion correction to be applied. Resolved; from name_hint and/or level_hint into a key of; empirical_dispersion_resources.dashcoeff. Type; str. dashparams¶; Complete set of parameter values defining the flexible parts; of dashlevel. Number and parameter names vary by; dashlevel. Resolved into a complete set (keys of; dashcoeff[dashlevel][‘default’]) from name_hint and/or; dashcoeff_supplement and/or user param_tweaks. Type; dict",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/dftd3-1.html:10792,energy,energy,10792,psi4manual/1.4.0/dftd3-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/dftd3-1.html,4,['energy'],['energy']
Energy Efficiency,"lvl=None, dashparam=None, dertype=None, verbose=1)¶; Compute dispersion correction via Grimme’s DFTD3 program. Parameters. func (Optional[str]) – Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Any or all parameters initialized; from dashcoeff[dashlvl][func] can be overwritten via; dashparam.; dashlvl (Optional[str]) – Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or “alias” or; “formal” to run.; dashparam (Optional[Dict]) – Values for the same keys as dashcoeff[dashlvl][‘default’]; used to override any or all values initialized by func.; Extra parameters will error.; dertype (Union[int, str, None]) – Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int) – Amount of printing. Returns. energy (float) – When dertype=0, energy [Eh].; gradient (ndarray) – When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ndarray) – When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. class psi4.driver.procrouting.empirical_dispersion.EmpiricalDispersion(*, name_hint=None, level_hint=None, param_tweaks=None, engine=None, save_pairwise_disp=False)[source]¶; Lightweight unification of empirical dispersion calculation modes. dashlevel¶; {‘d1’, ‘d2’, ‘d3zero’, ‘d3bj’, ‘d3mzero’, ‘d3mbj’, ‘chg’, ‘das2009’, ‘das2010’, ‘nl’, ‘dmp2’, “d4bjeeqatm”}; Name of dispersion correction to be applied. Resolved; from name_hint and/or level_hint into a key of; empirical_dispersion_resources.dashcoeff. Type; str. dashparams¶; Complete set of parameter values defining the flexible parts; of dashlevel. Number and parameter names vary by; dashlevel. Resolved into a complete set (keys of; dashcoeff[dashlevel][‘default’]) from name_hint and/or; dashcoeff_supplement and/or user param_twea",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/dftd3-1.html:11496,energy,energy,11496,psi4manual/1.5.0/dftd3-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/dftd3-1.html,6,['energy'],['energy']
Energy Efficiency,"lxd)):; pass; else:; raise ValidationError('Deformation correction mode \'%s\' not valid.' % (db_rlxd)). # Option zero-point-correction- whether for thermochem databases jobs are corrected by zpe; db_zpe = 'no'; if 'zpe' in kwargs:; db_zpe = kwargs['zpe']. if yes.match(str(db_zpe)):; raise ValidationError('Zero-point-correction mode \'yes\' not yet implemented.'); elif no.match(str(db_zpe)):; pass; else:; raise ValidationError('Zero-point-correction \'mode\' %s not valid.' % (db_zpe)). # Option benchmark- whether error statistics computed wrt alternate reference energies; db_benchmark = 'default'; if 'benchmark' in kwargs:; db_benchmark = kwargs['benchmark']. if (db_benchmark.lower() == 'default'):; pass; else:; BIND = p4util.getattr_ignorecase(database, 'BIND_' + db_benchmark); if BIND is None:; raise ValidationError('Special benchmark \'%s\' not available for database %s.' % (db_benchmark, db_name)). # Option tabulate- whether tables of variables other than primary energy method are formed; db_tabulate = []; if 'tabulate' in kwargs:; db_tabulate = kwargs['tabulate']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, basestring):; if (db_subset.lower() == 'small'):; try:; database.HRXN_SM; except AttributeError:; raise ValidationError('Special subset \'small\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_SM; elif (db_subset.lower() == 'large'):; try:; database.HRXN_LG; except AttributeError:; raise ValidationError('Special subset \'large\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_LG; elif (db_subset.lower() == 'equilibrium'):; try:; database.HRXN_EQ; except AttributeError:; raise ValidationError('Special subset \'equilibrium\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_EQ; else:; HRXN = p4util.getattr_ignorecase(database, db_subset); if HRXN is None:; HRXN =",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:35856,energy,energy,35856,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,2,['energy'],['energy']
Energy Efficiency,"ly once the monomer whose energy will be subtracted from each of the three dimers.; RGC1-HeHe-0.85-dimer; RGC1-He-mono-unCP; RGC1-HeHe-1.0-dimer; RGC1-HeHe-1.5-dimer. At the end of the job, the Requested Energy table is printed that gives the total; energies for the requested model chemistry for each reagent and each reaction, as; well as the stoichiometric weights by which the reagent energies are transformed; into the reaction energy. In this case, the dimer is +1 and the monomer is -2,; indicating the interaction energy is computed from dimer less first monomer; less second (identical) monomer. Error statistics are computed with respect to the reference; energies stored in the database. One of these, the mean absolute deviation, is; returned by the wrapper as an ordinary Python variable. (For databases; without a stored reference energy, e.g., BASIC, large and meaningless numbers are; printed for error.) The other two tables tabulate the PSI variables requested; through keyword tabulate, in this case the total SCF energy and the number; of atoms in each reagent.; ==> Mp2 Total Energy <==. ------------------------------------------------------------------------------------------------------; Reaction Reaction Value Reagent 1 Reagent 2; Value Wt Value Wt; ------------------------------------------------------------------------------------------------------; RGC1-HeHe-0.85 0.00004802 -5.69430495 1 -2.84717649 -2; RGC1-HeHe-1.0 -0.00000064 -5.69435362 1 -2.84717649 -2; ------------------------------------------------------------------------------------------------------. ==> Requested Energy <==. ------------------------------------------------------------------------------------------------------; Reaction Reaction Energy Reaction Error Reagent 1 Reagent 2; Ref Calc [kcal/mol] [kJ/mol] [Eh] Wt [Eh] Wt; ------------------------------------------------------------------------------------------------------; RGC1-HeHe-0.85 0.0376 0.0301 -0.0075 -0.0312 -5.69430495 1 -2.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/db-1.html:7636,energy,energy,7636,psi4manual/1.4.0/db-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/db-1.html,9,['energy'],['energy']
Energy Efficiency,"ly with closed shell reference determinant, it must be zero otherwise. This becomes nsing (option #2) in fort.56. Type: integer; Default: 1. MRCC_NUM_TRIPLET_ROOTS¶. Number of triplet roots. (Strictly speaking number of of roots with \(M_s=0\) and S is odd.) See notes at option MRCC_NUM_SINGLET_ROOTS This becomes ntrip (option #3) in fort.56. Type: integer; Default: 0. Expert¶. MRCC_METHOD¶. If more than one root is requested and calc=1, LR-CC (EOM-CC) calculation is performed automatically for the excited states. This overrides all automatic determination of method and will only work with energy(). This becomes CC/CI (option #5) in fort.56. See Table MRCC_METHOD for details. Type: integer; Default: 1. MRCC_OMP_NUM_THREADS¶. Sets the OMP_NUM_THREADS environment variable before calling MRCC. If the environment variable OMP_NUM_THREADS is set prior to calling Psi4 then that value is used. When set, this option overrides everything. Be aware the -n command-line option described in section Threading does not affect MRCC. Type: integer; Default: 1. MRCC_RESTART¶. The program restarts from the previously calculated parameters if it is 1. In case it is 2, the program executes automatically the lower-level calculations of the same type consecutively (e.g., CCSD, CCSDT, and CCSDTQ if CCSDTQ is requested) and restarts each calculation from the previous one (rest=2 is available only for energy calculations). Currently, only a value of 0 and 2 are supported. This becomes rest (option #4) in fort.56. Type: integer; Default: 0. table of contents. MRCC; General; E_CONVERGENCE; INTS_TOLERANCE; MRCC_LEVEL; MRCC_NUM_DOUBLET_ROOTS; MRCC_NUM_SINGLET_ROOTS; MRCC_NUM_TRIPLET_ROOTS. Expert; MRCC_METHOD; MRCC_OMP_NUM_THREADS; MRCC_RESTART. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodir_options_c/module__mrcc-1.html:2476,energy,energy,2476,psi4manual/1.2.1/autodir_options_c/module__mrcc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodir_options_c/module__mrcc-1.html,2,['energy'],['energy']
Energy Efficiency,"ly, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Any or all parameters initialized; from `dashcoeff[dashlvl][func]` can be overwritten via; `dashparam`.; dashlvl : str, optional; Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in `dashcoeff` or ""alias"" or; ""formal"" to one.; dashparam : dict, optional; Values for the same keys as `dashcoeff[dashlvl]['default']`; used to override any or all values initialized by `func`.; Extra parameters will error.; dertype : int or str, optional; Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose : int, optional; Amount of printing. Returns; -------; energy : float; When `dertype=0`, energy [Eh].; gradient : ndarray; When `dertype=1`, (nat, 3) gradient [Eh/a0].; (energy, gradient) : tuple of float and ndarray; When `dertype=None`, both energy [Eh] and (nat, 3) gradient [Eh/a0]. """"""; from . import intf_dftd3. if dertype is None:; derint, derdriver = -1, 'gradient'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). jobrec = intf_dftd3.run_dftd3_from_arrays(; molrec=self.to_dict(np_out=False),; name_hint=func,; level_hint=dashlvl,; param_tweaks=dashparam,; ptype=derdriver,; verbose=verbose). if isinstance(self, Molecule):; pass; else:; from psi4 import core. for k, qca in jobrec['qcvars'].items():; if not isinstance(qca.data, np.ndarray):; core.set_variable(k, float(qca.data)). if derint == -1:; return (float(jobrec['qcvars']['DISPERSION CORRECTION ENERGY'].data),; jobrec['qcvars']['DISPERSION CORRECTION GRADIENT'].data); elif derint == 0:; return float(jobrec['qcvars']['DISPERSION CORRECTION ENERGY'].data); elif derint == 1:; return jobrec['qcvars']['DISPERSION CORRECTION GRADIENT'].data. @staticmethod; def from_schema(molschema, return_dict=False, verbose=1):; """"""Construct Molecule ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/qcdb/molecule.html:40617,energy,energy,40617,psi4manual/1.3.2/_modules/psi4/driver/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/qcdb/molecule.html,2,['energy'],['energy']
Energy Efficiency,"ly, the user can request that the DF-CCSD(T) procedure use a; set of vectors defined by the Cholesky decomposition of the ERI tensor as; the auxiliary basis. This feature is enabled by specifying CC_TYPE CD.; CD methods can be enabled in the SCF; procedure as well, by specifying the SCF_TYPE as CD. The; accuracy of the decomposition can be controlled through the keyword; CHOLESKY_TOLERANCE.; The following input file sets up a DF-CCSD(T); computation using CD integrals; molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; scf_type cd; cc_type cd; basis aug-cc-pvdz; freeze_core true; }; energy('ccsd(t)'). The resulting CCSD(T) correlation energy will be equivalent to that; obtained from a conventional computation if CHOLESKY_TOLERANCE is; sufficiently small (e.g. 1e-9). Gn theory¶; The FNOCC module contains all the components that comprise the Gn family; of composite methods. Currently, only the G2 method is supported; [Curtiss:1991:7221]. The G2 procedure may be called through the; energy() wrapper:; energy('gaussian-2'). Supported methods¶; The various methods supported by the FNOCC module in PSI4 are detailed; in Table FNOCC Methods. Note that these methods; are implemented for closed-shell references only. For open-shell references,; the calls energy('mp2.5'), energy('mp3'), and energy('mp4') will; default to implementations of these methods in other modules. name; calls method; type select. qcisd; quadratic configuration interaction singles doubles; CI_TYPE CONV. qcisd(t); qcisd with perturbative triples; CI_TYPE CONV. mp2.5; average of second- and third-order perturbation theories; MP_TYPE CONV. mp3; third-order perturbation theory; MP_TYPE CONV. mp4(sdq); fourth-order perturbation theory, minus triples contribution; MP_TYPE CONV. mp4; full fourth-order perturbation theory; MP_TYPE CONV. lccd; linear ccd; CC_TYPE CONV. cepa(0), lccsd; coupled electron pair approximation, variant 0; CC_TYPE CONV. cepa(1); coupled electron pair approximation, variant 1; CC_T",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/fnocc-1.html:12535,energy,energy,12535,psi4manual/1.4.0/fnocc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/fnocc-1.html,10,['energy'],['energy']
Energy Efficiency,"ly, the user can request that the DF-CCSD(T) procedure use a; set of vectors defined by the Cholesky decomposition of the ERI tensor as; the auxiliary basis. This feature is enabled by specifying CC_TYPE CD.; CD methods can be enabled in the SCF; procedure as well, by specifying the SCF_TYPE as CD. The; accuracy of the decomposition can be controlled through the keyword; CHOLESKY_TOLERANCE.; The following input file sets up a DF-CCSD(T); computation using CD integrals; molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; scf_type cd; cc_type cd; basis aug-cc-pvdz; freeze_core true; }; energy('ccsd(t)'). The resulting CCSD(T) correlation energy will be equivalent to that; obtained from a conventional computation if CHOLESKY_TOLERANCE is; sufficiently small (e.g. 1e-9). Gn theory¶; The FNOCC module contains all the components that comprise the Gn family; of composite methods. Currently, only the G2 method is supported; [Curtiss:1991:7221]. The G2 procedure may be called through the; energy() wrapper:; energy('gaussian-2'). Supported methods¶; The various methods supported by the FNOCC module in PSI4 are; summarized in Table FNOCC Methods; and detailed (except FNO) in Table FNOCC Capabilities. Note that these methods are implemented; for closed-shell reference only. Without set qc_module fnocc,; these methods may default to implementations in other modules. Theoretical methods accessible through FNOCC¶. name; calls method; plain; FNO. mp3; third-order MP perturbation theory; E; E. mp4(sdq); fourth-order MP perturbation theory, less triples; E; E. mp4; full fourth-order MP perturbation theory; E; E. cisd; configuration interaction singles and doubles; E; E. qcisd; quadratic configuration interaction singles doubles; E; E. qcisd(t); QCISD with perturbative triples; E; E. lccd; linear coupled cluster doubles; E; E. cepa(0), lccsd; coupled electron pair approximation, variant 0; E; E. cepa(1); coupled electron pair approximation, variant 1; E; E. cepa(3); coupled ele",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/fnocc.html:12535,energy,energy,12535,psi4manual/1.7.x/fnocc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/fnocc.html,8,['energy'],['energy']
Energy Efficiency,"lytic and via finite-differences of 2-1A1 state of H2O with EOM-CCSD. mpn-bh; MP(n)/aug-cc-pVDZ BH Energy Point, with n=2-19. Compare against M. L. Leininger et al., J. Chem. Phys. 112, 9213 (2000). mints15; check SP basis Fortran exponent parsing. dfmp2-freq2; DF-MP2 frequency by difference of energies for H2O. omp3-2; OMP3 cc-pCVDZ energy with ROHF initial guess for the NO radical. cc45; RHF-EOM-CC2/cc-pVDZ lowest two states of each symmetry of H2O. dfomp2-grad3; Tests OMP2 gradient in the presence of a dipole field. omp2p5-grad1; OMP2.5 cc-pVDZ gradient for the H2O molecule. opt-freeze-coords; SCF/cc-pVDZ optimization example with frozen cartesian. sapt10; usapt example with empty beta due to frozen core. dft-grad-lr1; wB97X-D cc-pVDZ gradient of S22 HCN update df/pk_ref values due to new BraggSlater radii. scf-cholesky-basis; incremental Cholesky filtered SCF. scf-guess-read3; Test if the the guess read in the same basis converges. extern3; External potential calculation with one Ghost atom and one point charge at the same position. mbis-3; MBIS calculation on OH radical. dfomp2p5-2; DF-OMP2.5 cc-pVDZ energy for the H2O+ cation. isapt-charged; This test case shows an example of running the I-SAPT0/aug-cc-pVDZ computation for a positively charged system, illustrating the cation-pi interaction. The SIAO1 link partitioning algorithm is used. The system is taken from http://dx.doi.org/10.1016/j.comptc.2014.02.008. opt4; SCF cc-pVTZ geometry optimzation, with Z-matrix input. opt14; 6-31G(d) optimization of SF4 starting from linear bond angle that is not linear in the optimized structure but is in a symmetry plane of the molecule. soscf-ref; Triple and Singlet Oxygen energy SOSCF, also tests non-symmetric density matrices. opt2-fd; SCF DZ allene geometry optimzation, with Cartesian input. x2c2; Test of SFX2C-1e on Water cc-pVDZ-DK. In this test the Dirac equation is solved in the uncontracted cc-pVDZ-DK basis. The reference numbers are from Lan Cheng’s implementation i",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html:21146,charge,charge,21146,psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,2,['charge'],['charge']
Energy Efficiency,"l| ``'off'`` |dr|. Indicates whether, for *name* values built atop of scf calculations,; the scf step is skipped. Suitable when special steps are taken to get; the scf to converge in an explicit preceeding scf step. :examples:. >>> # [1] Coupled-cluster singles and doubles calculation with psi code; >>> energy('ccsd'). >>> # [2] Charge-transfer SAPT calculation with scf projection from small into requested basis; >>> energy('sapt0-ct',cast_up=True). >>> # [3] Arbitrary-order MPn calculation; >>> energy('mp4'). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Make sure the molecule the user provided is the active one; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(). # Allow specification of methods to arbitrary order; lowername, level = parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. try:; return procedures['energy'][lowername](lowername, **kwargs); except KeyError:; raise ValidationError('Energy method %s not available.' % (lowername)). [docs]def gradient(name, **kwargs):; r""""""Function complementary to optimize(). Carries out one gradient pass,; deciding analytic or finite difference. """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs); dertype = 1. # Order of precedence:; # 1. Default for wavefunction; # 2. Value obtained from kwargs, if user changed it; # 3. If user provides a custom 'func' use that. # Allow specification of methods to arbitrary order; lowername, level = parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. # 1. set the default to that of the provided name; if lowername in procedures['gradient']:; dertype = 1; elif lowername in procedures['energy']:; dertype = 0; func = energy. if (PsiMod.get_global_option('REFERENCE').lower() == 'rks') or (PsiMod.get_global_option('REFERENCE').lower() == 'uks'):; dertype = 0; func = energy. # 2. Check if the user passes dertype into this function; if 'de",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/driver.html:20219,energy,energy,20219,psi4manual/4.0b2/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/driver.html,3,"['Energy', 'energy']","['Energy', 'energy']"
Energy Efficiency,l| ``xtpl_highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the delta correction; to the correlation energy.; Defaults to :py:func:`~corl_xtpl_helgaker_2` if two valid basis sets; present in ``delta_basis`` and :py:func:`~xtpl_highest_1` otherwise. .. hlist::; :columns: 1. * xtpl_highest_1; * corl_xtpl_helgaker_2. :type delta2_scheme: function; :param delta2_scheme: |dl| ``xtpl_highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the second delta correction; to the correlation energy.; Defaults to :py:func:`~corl_xtpl_helgaker_2` if two valid basis sets; present in ``delta2_basis`` and :py:func:`~xtpl_highest_1` otherwise. .. hlist::; :columns: 1. * xtpl_highest_1; * corl_xtpl_helgaker_2. :type delta3_scheme: function; :param delta3_scheme: |dl| ``xtpl_highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the third delta correction; to the correlation energy.; Defaults to :py:func:`~corl_xtpl_helgaker_2` if two valid basis sets; present in ``delta3_basis`` and :py:func:`~xtpl_highest_1` otherwise. :type delta4_scheme: function; :param delta4_scheme: |dl| ``xtpl_highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the fourth delta correction; to the correlation energy.; Defaults to :py:func:`~corl_xtpl_helgaker_2` if two valid basis sets; present in ``delta4_basis`` and :py:func:`~xtpl_highest_1` otherwise. :type delta5_scheme: function; :param delta5_scheme: |dl| ``xtpl_highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the fifth delta correction; to the correlation energy.; Defaults to :py:func:`~corl_xtpl_helgaker_2` if two valid basis sets; present in ``delta5_basis`` and :py:func:`~xtpl_highest_1` otherwise. :type scf_alpha: float. Overrides the default \,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html:33908,energy,energy,33908,psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html,1,['energy'],['energy']
Energy Efficiency,"l¶; Returns true if the alpha and beta densities are the same. same_a_b_orbs(self: psi4.core.Wavefunction) → bool¶; Returns true if the alpha and beta orbitals are the same. scalar_variable(self: psi4.core.Wavefunction, arg0: str) → float¶; Returns the requested (case-insensitive) double QC variable. Prefer variable(). scalar_variables(self: psi4.core.Wavefunction) → Dict[str, float]¶; Returns the dictionary of all double QC variables. Prefer variables(). set_array(key, val)¶. Deprecated since version 1.4: Use psi4.core.Wavefunction.set_variable() instead. set_array_variable(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.Matrix) → None¶; Sets the requested (case-insensitive) Matrix QC variable. Syncs with Wavefunction.gradient_ or hessian_ if CURRENT GRADIENT or HESSIAN. Prefer set_variable(). set_basisset(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.BasisSet) → None¶; Sets the requested auxiliary basis. set_energy(self: psi4.core.Wavefunction, arg0: float) → None¶; Sets the Wavefunction’s energy. Syncs with Wavefunction’s QC variable CURRENT ENERGY. set_external_potential(self: psi4.core.Wavefunction, arg0: psi4.core.ExternalPotential) → None¶; Sets the requested external potential. set_gradient(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunction’s gradient. Syncs with Wavefunction’s QC variable CURRENT GRADIENT. set_hessian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunction’s Hessian. Syncs with Wavefunction’s QC variable CURRENT HESSIAN. set_lagrangian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the orbital Lagrangian matrix. set_module(self: psi4.core.Wavefunction, module: str) → None¶; Sets name of the last/highest level of theory module (internal or external) touching the wavefunction. set_name(self: psi4.core.Wavefunction, arg0: str) → None¶; Sets the level of theory this wavefunction corresponds to. set_potential_variable(self: psi4.core.Wavefuncti",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Wavefunction.html:22260,energy,energy,22260,psi4manual/1.7.x/api/psi4.core.Wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Wavefunction.html,4,['energy'],['energy']
Energy Efficiency,"m = item + "".npy""; else:; filenum = name_split[-1]; try:; filenum = int(filenum); except ValueError:; filenum = 32 # Default file number is the checkpoint one; psioh = core.IOManager.shared_object(); psio = core.IO.shared_object(); filepath = psioh.get_file_path(filenum); namespace = psio.get_default_namespace(); pid = str(os.getpid()); prefix = 'psi'; targetfile = filepath + prefix + '.' + pid + '.' + namespace + '.' + str(filenum); core.print_out(f"" \n Copying restart file <{item}> to <{targetfile}> for internal processing\n""); shutil.copy(item, targetfile). logger.info(f""Compute energy(): method={lowername}, basis={core.get_global_option('BASIS').lower()}, molecule={molecule.name()}, nre={'w/EFP' if hasattr(molecule, 'EFP') else molecule.nuclear_repulsion_energy()}""); logger.debug(""w/EFP"" if hasattr(molecule, ""EFP"") else pp.pformat(molecule.to_dict())); wfn = procedures['energy'][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return energy(): {core.variable('CURRENT ENERGY')}""). for postcallback in hooks['energy']['post']:; postcallback(lowername, wfn=wfn, **kwargs). basisstash.restore(); optstash.restore(); optstash2.restore(). if return_wfn: # TODO current energy safer than wfn.energy() for now, but should be revisited. # TODO place this with the associated call, very awkward to call this in other areas at the moment; if lowername in ['efp', 'mrcc', 'dmrg']:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the incoming reference wavefunction.\n\n""); elif 'sapt' in lowername:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the dimer SCF wavefunction.\n\n""). return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]; def gradient(name, **kwargs):; r""""""Function complementary to :py:func:`~psi4.driver.optimize()`. Carries out one",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:40778,ENERGY,ENERGY,40778,psi4manual/1.8.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html,3,['ENERGY'],['ENERGY']
Energy Efficiency,"m = item + "".npy""; else:; filenum = name_split[-1]; try:; filenum = int(filenum); except ValueError:; filenum = 32 # Default file number is the checkpoint one; psioh = core.IOManager.shared_object(); psio = core.IO.shared_object(); filepath = psioh.get_file_path(filenum); namespace = psio.get_default_namespace(); pid = str(os.getpid()); prefix = 'psi'; targetfile = filepath + prefix + '.' + pid + '.' + namespace + '.' + str(filenum); core.print_out(f"" \n Copying restart file <{item}> to <{targetfile}> for internal processing\n""); shutil.copy(item, targetfile). logger.info(f""Compute energy(): method={lowername}, basis={core.get_global_option('BASIS').lower()}, molecule={molecule.name()}, nre={'w/EFP' if hasattr(molecule, 'EFP') else molecule.nuclear_repulsion_energy()}""); logger.debug(""w/EFP"" if hasattr(molecule, ""EFP"") else pp.pformat(molecule.to_dict())); wfn = procedures['energy'][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return energy(): {core.variable('CURRENT ENERGY')}""). for postcallback in hooks['energy']['post']:; postcallback(lowername, wfn=wfn, **kwargs). basisstash.restore(); optstash.restore(); optstash2.restore(). if return_wfn: # TODO current energy safer than wfn.energy() for now, but should be revisited. # TODO place this with the associated call, very awkward to call this in other areas at the moment; if lowername in ['efp', 'mrcc', 'dmrg']:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the incoming reference wavefunction.\n\n""); elif 'sapt' in lowername:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the dimer SCF wavefunction.\n\n""). return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]def gradient(name, **kwargs):; r""""""Function complementary to :py:func:`~psi4.driver.optimize()`. Carries out one g",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html:40774,ENERGY,ENERGY,40774,psi4manual/1.7.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"m = item + "".npy""; else:; filenum = name_split[-1]; try:; filenum = int(filenum); except ValueError:; filenum = 32 # Default file number is the checkpoint one; psioh = core.IOManager.shared_object(); psio = core.IO.shared_object(); filepath = psioh.get_file_path(filenum); namespace = psio.get_default_namespace(); pid = str(os.getpid()); prefix = 'psi'; targetfile = filepath + prefix + '.' + pid + '.' + namespace + '.' + str(filenum); core.print_out(f"" \n Copying restart file <{item}> to <{targetfile}> for internal processing\n""); shutil.copy(item, targetfile). logger.info(f""Compute energy(): method={lowername}, basis={core.get_global_option('BASIS').lower()}, molecule={molecule.name()}, nre={'w/EFP' if hasattr(molecule, 'EFP') else molecule.nuclear_repulsion_energy()}""); logger.debug(""w/EFP"" if hasattr(molecule, ""EFP"") else pp.pformat(molecule.to_dict())); wfn = procedures['energy'][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return energy(): {core.variable('CURRENT ENERGY')}""). for postcallback in hooks['energy']['post']:; postcallback(lowername, wfn=wfn, **kwargs). basisstash.restore(); optstash.restore(); optstash2.restore(). if return_wfn: # TODO current energy safer than wfn.energy() for now, but should be revisited. # TODO place this with the associated call, very awkward to call this in other areas at the moment; if lowername in ['efp', 'mrcc', 'dmrg']:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the incoming reference wavefunction.\n\n""); elif 'sapt' in lowername:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the dimer SCF wavefunction.\n\n""). return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]def gradient(name, **kwargs):; r""""""Function complementary to :py:func:`~psi4.optimize()`. Carries out one gradient",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html:33944,ENERGY,ENERGY,33944,psi4manual/1.6.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"m a string. atom_at_position(b, tol=0.05)[source]¶; Tests to see of an atom is at the passed position b in Bohr with a tolerance tol.; >>> print H2OH2O.atom_at_position([1.35*(1.0/psi_bohr2angstroms), 0.10*(1.0/psi_bohr2angstroms), 0.0*(1.0/psi_bohr2angstroms)]); 3. atom_entry(atom)[source]¶; Returns the CoordEntry for an atom. atom_to_unique(iatom)[source]¶; NYI Converts an atom number to the number of its generating unique atom.; The return value is in [0, nunique). atom_to_unique_offset(iatom)[source]¶; NYI Converts an atom number to the offset of this atom; in the list of generated atoms. The unique atom itself is allowed offset 0. center_of_mass()[source]¶; Computes center of mass of molecule (does not translate molecule).; >>> H2OH2O.center_of_mass(); [-0.12442647346606871, 0.00038657002584110707, 0.0]. charge(atom)[source]¶; Returns charge of atom (0-indexed).; Related to SAD guess in libmints version.; >>> print H2OH2O.charge(4); 1.0. charge_specified()[source]¶; Whether the charge was given by the user; >>> print H2OH2O.charge_specified(); True. clear()[source]¶; Zero it out. clone()[source]¶; Returns new, independent Molecule object.; >>> dimer = H2OH2O.clone(). create_molecule_from_string(text)[source]¶; Given a string geom of psi4-style geometry specification; (including newlines to separate lines), builds a new molecule.; Called from constructor. create_psi4_string_from_molecule()[source]¶; Regenerates a input file molecule specification string from the; current state of the Molecule. Contains geometry info,; fragmentation, charges and multiplicities, and any frame; restriction. deactivate_all_fragments()[source]¶; Sets all fragments in the molecule to be inactive. distance_matrix()[source]¶; Computes a matrix depicting distances between atoms. Prints; formatted and returns array.; >>> H2OH2O.distance_matrix(); Interatomic Distances (Angstroms); [1] [2] [3] [4] [5] [6]; [1] 0.00000; [2] 0.95711 0.00000; [3] 0.96391 1.51726 0.00000; [4] 2.91042 3.34878 1.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodoc_driver-1.html:45578,charge,charge,45578,psi4manual/4.0b5/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodoc_driver-1.html,2,['charge'],['charge']
Energy Efficiency,"m a string. atom_at_position(b, tol=0.05)[source]¶; Tests to see of an atom is at the passed position b in Bohr with a tolerance tol.; >>> print H2OH2O.atom_at_position([1.35*(1.0/psi_bohr2angstroms), 0.10*(1.0/psi_bohr2angstroms), 0.0*(1.0/psi_bohr2angstroms)]); 3. atom_entry(atom)[source]¶; Returns the CoordEntry for an atom. atom_to_unique(iatom)[source]¶; NYI Converts an atom number to the number of its generating unique atom.; The return value is in [0, nunique). atom_to_unique_offset(iatom)[source]¶; NYI Converts an atom number to the offset of this atom; in the list of generated atoms. The unique atom itself is allowed offset 0. center_of_mass()[source]¶; Computes center of mass of molecule (does not translate molecule).; >>> H2OH2O.center_of_mass(); [-0.12442647346606871, 0.00038657002584110707, 0.0]. charge(atom)[source]¶; Returns charge of atom (0-indexed).; Related to SAD guess in libmints version.; >>> print H2OH2O.charge(4); 1.0. charge_specified()[source]¶; Whether the charge was given by the user; >>> print H2OH2O.charge_specified(); True. clear()[source]¶; Zero it out. clone()[source]¶; Returns new, independent Molecule object.; >>> dimer = H2OH2O.clone(). create_molecule_from_string(text)[source]¶; Given a string geom of psi4-style geometry specification; (including newlines to separate lines), builds a new molecule.; Called from constructor. deactivate_all_fragments()[source]¶; Sets all fragments in the molecule to be inactive. distance_matrix()[source]¶; Computes a matrix depicting distances between atoms. Prints; formatted and returns array.; >>> H2OH2O.distance_matrix(); Interatomic Distances (Angstroms); [1] [2] [3] [4] [5] [6]; [1] 0.00000; [2] 0.95711 0.00000; [3] 0.96391 1.51726 0.00000; [4] 2.91042 3.34878 1.95159 0.00000; [5] 3.32935 3.86422 2.43843 0.95895 0.00000; [6] 3.32935 3.86422 2.43843 0.95895 1.51712 0.00000. equivalent(iuniq, j)[source]¶; NYI Returns the j’th atom equivalent to iuniq. everything()[source]¶; Quick print of class da",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_driver-1.html:41838,charge,charge,41838,psi4manual/4.0b3/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_driver-1.html,4,['charge'],['charge']
Energy Efficiency,"m adjacent iterations can; quench oscillations. This mixing, known as “damping” can be activated by setting; the DAMPING_PERCENTAGE keyword to a nonzero percent. ERI Algorithms¶; The key difficulty in the SCF procedure is treatment of the four-index ERI; contributions to the Fock Matrix. A number of algorithms are available in; PSI4 for these terms. The algorithm is selected by the SCF_TYPE; keyword, which may be one of the following. PK [Default]; An in-core, presorted algorithm using exact ERIs. Quite fast; for a zero-error algorithm if enough memory is available. Integrals are; generated only once, and symmetry is utilized to reduce number of integrals.; OUT_OF_CORE; An out-of-core, unsorted algorithm using exact; ERIs. Overcomes the memory bottleneck of the current PK algorithm. Integrals are; generated only once, and symmetry is utilized to reduce number of integrals.; DIRECT; An in-core repeated integral evaluation algorithm using; exact ERIs. Symmetry is used to reduce the number of integrals, and no disk is; used. However, integral regeneration is quite costly, implying that this; algorithm should be used only if there is not enough disk space for the; OUT_OF_CORE algorithm.; DF; A density-fitted algorithm designed for computations with thousands of basis; functions. This algorithm is highly optimized, and is threaded with a mixture of; parallel BLAS and OpenMP. Note that this algorithm should use the -JKFIT series; of auxiliary bases, not the -RI or -MP2FIT bases. The default guess for; auxiliary basis set should work for all Dunning bases, otherwise the; DF_BASIS_SCF keyword can be used to manually specify the auxiliary basis.; This algorithm is preferred unless either absolute accuracy is required; [CCSD(T)] or a -JKFIT auxiliary basis is unavailable for the; primary basis/atoms involved. For some of these algorithms, Schwarz and/or density sieving can be used to; identify negligible integral contributions in extended systems. To activate; sieving, set th",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/scf-1.html:17588,reduce,reduce,17588,psi4manual/4.0b2/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf-1.html,4,['reduce'],['reduce']
Energy Efficiency,"m combinations of; basis set extrapolations and delta corrections and condense the; components into a minimum number of calculations. :aliases: complete_basis_set(). :returns: (*float*) -- Total electronic energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CBS TOTAL ENERGY <CBSTOTALENERGY>`; * :psivar:`CBS REFERENCE ENERGY <CBSREFERENCEENERGY>`; * :psivar:`CBS CORRELATION ENERGY <CBSCORRELATIONENERGY>`; * :psivar:`CURRENT ENERGY <CURRENTENERGY>`; * :psivar:`CURRENT REFERENCE ENERGY <CURRENTREFERENCEENERGY>`; * :psivar:`CURRENT CORRELATION ENERGY <CURRENTCORRELATIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - No way to tell function to boost fitting basis size for all calculations. - No way to extrapolate def2 family basis sets. - Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in several; sequential stages (scf, corl, delta, delta2, delta3, delta4, delta5) covering treatment; of the reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction, etc.. Each is activated by its; stage_wfn keyword and is only allowed if all preceding stages are active. .. include:: ../cbs_eqn.rst. * Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy. The cbs() function requires, at a minimum, ``name='scf'`` and ``scf_basis``; keywords to be specified for reference-step only jobs and ``name`` and; ``corl_basis`` keywords for correlated jobs. The following energy methods have been set up for cbs(). .. hlist::; :columns: 5. * scf; * hf; * mp2; * mp2.5; * mp3; * mp4(sdq); * mp4; * mp\ *n*; * omp2; * omp2.5; * omp3; * olccd; * lccd; * lccsd; * cepa(0); * cepa(1); * cepa(3); * acpf; * aqcc; * qcisd; * cc2; * ccsd; * fno-ccsd; * bccd; * cc3; * qcisd(t); * ccsd(t); * fno",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver_cbs.html:18951,energy,energy,18951,psi4manual/1.1.0/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver_cbs.html,8,['energy'],['energy']
Energy Efficiency,"m complex Size vs cost tradeoff is rough here. dfomp3-1; DF-OMP3 cc-pVDZ energy for the H2O molecule. fsapt-allterms; This test case shows an example of running and analyzing a standard F-SAPT0/jun-cc-pvdz procedure for HSG-18-dimer from the HSG database. nbo; Generation of NBO file. tdscf-6; td-camb3lyp with DiskDF and method/basis specification. mpn-bh; MP(n)/aug-cc-pVDZ BH Energy Point, with n=2-19. Compare against M. L. Leininger et al., J. Chem. Phys. 112, 9213 (2000). stability1; UHF->UHF stability analysis test for BH with cc-pVDZ Test direct SCF with and without symmetry, test PK without symmetry. mcscf1; ROHF 6-31G** energy of the \(^{3}B_1\) state of CH2, with Z-matrix input. The occupations are specified explicitly. dfccsdl1; DF-CCSDL cc-pVDZ energy for the H2O molecule. scf2; RI-SCF cc-pVTZ energy of water, with Z-matrix input and cc-pVTZ-RI auxilliary basis. opt-irc-2; Compute the IRC for HCN <-> NCH interconversion at the RHF/DZP level of theory. dfccd1; DF-CCD cc-pVDZ energy for the H2O molecule. mints15; check SP basis Fortran exponent parsing. cc32; CC3/cc-pVDZ H2O \(R_e\) geom from Olsen et al., JCP 104, 8007 (1996). cc16; ROHF and UHF-B-CCD(T)/cc-pVDZ \(^{3}B_1\) CH2 single-point energy (fzc, MO-basis \(\langle ab|cd \rangle\) ). dfomp2-3; OMP2 cc-pVDZ energy for the H2O molecule. mp2p5-grad1; MP2.5 cc-pVDZ gradient for the H2O molecule. mints10; H2 with tiny basis set, to test basis set parser’s handling of integers. scf-occ; force occupations in scf. x2c-perturb-h; Test SFX2C-1e with a static electric field on He aug-cc-pVTZ. cisd-h2o+-1; 6-31G** H2O+ Test CISD Energy Point. dft-custom; DFT custom functional test. omp2p5-grad1; OMP2.5 cc-pVDZ gradient for the H2O molecule. cc22; ROHF-EOM-CCSD/DZ on the lowest two states of each irrep in \(^{3}B_1\) CH2. dfcasscf-sa-sp; Example of state-averaged CASSCF for the C2 molecule. decontract; RHF/cc-pvdz-decontract HCl single-point energy Testing the in line -decontract option for basis sets. dct8; DCT c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html:25275,energy,energy,25275,psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"m functional import *; from psifiles import *; # never import wrappers or aliases into this file. # Procedure lookup tables; procedures = {; 'energy': {; 'scf' : run_scf,; 'mcscf' : run_mcscf,; 'dcft' : run_dcft,; 'dfmp2' : run_dfmp2,; 'df-mp2' : run_dfmp2,; 'mp2' : run_mp2,; 'omp2' : run_omp2,; 'omp3' : run_omp3,; 'sapt0' : run_sapt,; 'sapt2' : run_sapt,; 'sapt2+' : run_sapt,; 'sapt2+(3)' : run_sapt,; 'sapt2+3' : run_sapt,; 'sapt0-ct' : run_sapt_ct,; 'sapt2-ct' : run_sapt_ct,; 'sapt2+-ct' : run_sapt_ct,; 'sapt2+(3)-ct' : run_sapt_ct,; 'sapt2+3-ct' : run_sapt_ct,; 'mp2c' : run_mp2c,; 'ccenergy' : run_ccenergy, # full control over ccenergy; 'ccsd' : run_ccenergy,; 'ccsd(t)' : run_ccenergy,; 'cc2' : run_ccenergy,; 'cc3' : run_ccenergy,; 'mrcc' : run_mrcc, # interface to Kallay's MRCC program; 'bccd' : run_bccd,; 'bccd(t)' : run_bccd_t,; 'eom-ccsd' : run_eom_cc,; 'eom-cc2' : run_eom_cc,; 'eom-cc3' : run_eom_cc,; 'eom_ccsd' : run_eom_cc,; 'eom_cc2' : run_eom_cc,; 'eom_cc3' : run_eom_cc,; 'detci' : run_detci, # full control over detci; 'mp' : run_detci, # arbitrary order mp(n); 'zapt' : run_detci, # arbitrary order zapt(n); 'cisd' : run_detci,; 'cisdt' : run_detci,; 'cisdtq' : run_detci,; 'ci' : run_detci, # arbitrary order ci(n); 'fci' : run_detci,; 'adc' : run_adc,; 'cphf' : run_libfock,; 'cis' : run_libfock,; 'tdhf' : run_libfock,; 'cpks' : run_libfock,; 'tda' : run_libfock,; 'tddft' : run_libfock,; 'psimrcc' : run_psimrcc,; 'psimrcc_scf' : run_psimrcc_scf,; 'hf' : run_scf,; 'rhf' : run_scf,; 'uhf' : run_scf,; 'rohf' : run_scf,; 'rscf' : run_scf,; 'uscf' : run_scf,; 'roscf' : run_scf,; 'df-scf' : run_scf,; 'cepa(0)' : run_cepa,; 'cepa(1)' : run_cepa,; 'cepa(3)' : run_cepa,; 'acpf' : run_cepa,; 'aqcc' : run_cepa,; 'sdci' : run_cepa,; 'dci' : run_cepa,; # Upon adding a method to this list, add it to the docstring in energy() below; # If you must add an alias to this list (e.g., dfmp2/df-mp2), please search the; # whole driver to find uses of name in return values and ps",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/driver.html:676,energy,energy,676,psi4manual/4.0b3/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/driver.html,4,['energy'],['energy']
Energy Efficiency,"m is smaller than this value DIIS starts. Type: double; Default: 1e-2. DMRG_SCF_GRAD_THR¶. The density RMS convergence to stop an instruction during successive DMRG instructions. Type: double; Default: 1.e-6. DMRG_SCF_MAX_ITER¶. Maximum number of DMRG iterations. Type: integer; Default: 100. DMRG_SCF_STATE_AVG¶. Whether or not to use state-averaging for roots >=2 with DMRG-SCF. Type: boolean; Default: true. DMRG_SWEEP_DVDSON_RTOL¶. The residual tolerances for the Davidson diagonalization during DMRG instructions. Type: array; Default: No Default. DMRG_SWEEP_ENERGY_CONV¶. The energy convergence to stop an instruction during successive DMRG instructions. Type: array; Default: No Default. DMRG_SWEEP_MAX_SWEEPS¶. The maximum number of sweeps to stop an instruction during successive DMRG instructions. Type: array; Default: No Default. DMRG_SWEEP_NOISE_PREFAC¶. The noise prefactors for successive DMRG instructions. Type: array; Default: No Default. DMRG_SWEEP_STATES¶. The number of reduced renormalized basis states to be retained during successive DMRG instructions. Type: array; Default: No Default. DMRG_UNITARY_WRITE¶. Whether or not to store the unitary on disk (convenient for restarting). Type: boolean; Default: true. table of contents. DMRG; General; DMRG_CASPT2_CALC; DMRG_CASPT2_IMAG; DMRG_CASPT2_IPEA; DMRG_CASPT2_ORBS; DMRG_DIIS; DMRG_DIIS_WRITE; DMRG_EXCITATION; DMRG_IRREP; DMRG_LOCAL_INIT; DMRG_MOLDEN_WRITE; DMRG_MPS_WRITE; DMRG_MULTIPLICITY; DMRG_OPDM_AO_PRINT; DMRG_PRINT_CORR; DMRG_SCF_ACTIVE_SPACE; DMRG_SCF_DIIS_THR; DMRG_SCF_GRAD_THR; DMRG_SCF_MAX_ITER; DMRG_SCF_STATE_AVG; DMRG_SWEEP_DVDSON_RTOL; DMRG_SWEEP_ENERGY_CONV; DMRG_SWEEP_MAX_SWEEPS; DMRG_SWEEP_NOISE_PREFAC; DMRG_SWEEP_STATES; DMRG_UNITARY_WRITE. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; DMRG. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodir_options_c/module__dmrg-1.html:3415,reduce,reduced,3415,psi4manual/1.4.0/autodir_options_c/module__dmrg-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/module__dmrg-1.html,4,['reduce'],['reduced']
Energy Efficiency,"m is smaller than this value DIIS starts. Type: double; Default: 1e-2. DMRG_SCF_GRAD_THR¶. The density RMS convergence to stop an instruction during successive DMRG instructions. Type: double; Default: 1.e-6. DMRG_SCF_MAX_ITER¶. Maximum number of DMRG iterations. Type: integer; Default: 100. DMRG_SCF_STATE_AVG¶. Whether or not to use state-averaging for roots >=2 with DMRG-SCF. Type: boolean; Default: true. DMRG_SWEEP_DVDSON_RTOL¶. The residual tolerances for the Davidson diagonalization during DMRG instructions. Type: array; Default: No Default. DMRG_SWEEP_ENERGY_CONV¶. The energy convergence to stop an instruction during successive DMRG instructions. Type: array; Default: No Default. DMRG_SWEEP_MAX_SWEEPS¶. The maximum number of sweeps to stop an instruction during successive DMRG instructions. Type: array; Default: No Default. DMRG_SWEEP_NOISE_PREFAC¶. The noise prefactors for successive DMRG instructions. Type: array; Default: No Default. DMRG_SWEEP_STATES¶. The number of reduced renormalized basis states to be retained during successive DMRG instructions. Type: array; Default: No Default. DMRG_UNITARY_WRITE¶. Whether or not to store the unitary on disk (convenient for restarting). Type: boolean; Default: true. table of contents. DMRG; General; DMRG_CASPT2_CALC; DMRG_CASPT2_IMAG; DMRG_CASPT2_IPEA; DMRG_CASPT2_ORBS; DMRG_DIIS; DMRG_DIIS_WRITE; DMRG_EXCITATION; DMRG_IRREP; DMRG_LOCAL_INIT; DMRG_MOLDEN_WRITE; DMRG_MPS_WRITE; DMRG_MULTIPLICITY; DMRG_OPDM_AO_PRINT; DMRG_PRINT_CORR; DMRG_SCF_ACTIVE_SPACE; DMRG_SCF_DIIS_THR; DMRG_SCF_GRAD_THR; DMRG_SCF_MAX_ITER; DMRG_SCF_STATE_AVG; DMRG_SWEEP_DVDSON_RTOL; DMRG_SWEEP_ENERGY_CONV; DMRG_SWEEP_MAX_SWEEPS; DMRG_SWEEP_NOISE_PREFAC; DMRG_SWEEP_STATES; DMRG_UNITARY_WRITE. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Appendices; Keywords by Module; DMRG. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2021 02:41AM.; Created using Sphinx 4.3.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodir_options_c/module__dmrg-1.html:3428,reduce,reduced,3428,psi4manual/1.5.0/autodir_options_c/module__dmrg-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodir_options_c/module__dmrg-1.html,4,['reduce'],['reduced']
Energy Efficiency,"m is very slow and it should; be avoided whenever possible. Direct Inversion is automatically invoked if the newer algorithm; is not available.; The Davidson algorithm for stability analysis was implemented recently.; Only the lowest eigenvalues of the electronic Hessian are computed, and Hessian-vector; products are computed instead of the full Hessian. This algorithm is thus; much more efficient than the Direct Inversion, but at present, it is only available for UHF \(\rightarrow\) UHF stability; analysis. The capabilities of both algorithms are summarized below:. Stability analysis methods available in PSI4¶. Algorithm; REFERENCE; Stability checked; SCF_TYPE. Direct Inversion; RHF; Internal, External (\(\rightarrow\) UHF); PK only. ROHF; Internal; PK only. Davidson; UHF; Internal; Anything. The best algorithm is automatically selected, i.e. Davidson for UHF \(\rightarrow\) UHF and Direct Inversion otherwise.; In addition to the options available for Direct Inversion, the Davidson algorithm can automatically; adapt FOLLOW_STEP_SCALE to find a new SCF minimum. If MAX_ATTEMPTS > 1, additional attempts; will automatically increment FOLLOW_STEP_SCALE by 0.2 every time the SCF falls back to the previously; found unstable minimum. The increment can be adjusted by setting FOLLOW_STEP_INCREMENT.; The default value is 0.2; adjust if needed to try different values of FOLLOW_STEP_SCALE in a single computation.; The Davidson solver for the eigenvalues is controlled through several keywords. In the following; we only report the most pertinent for stability analysis, see documentation for the CPHF; module for a complete list.; Some default values were modified for the stability analysis code, in that case they are; explicitly indicated here. SOLVER_MAXITER: maximum number of iterations; SOLVER_CONVERGENCE: eigenvector convergence threshold; SOLVER_N_ROOT: Solve for N eigenvectors in each irreducible representation; SOLVER_N_GUESS: Use N guess vectors, this needs to be larger tha",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/scf-1.html:29237,adapt,adapt,29237,psi4manual/1.1.0/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/scf-1.html,2,['adapt'],['adapt']
Energy Efficiency,m method. set_tpdm_presorted() psi4.core.Deriv method. set_tweak() psi4.core.LibXCFunctional method. set_units() psi4.core.Molecule method. set_variable() in module psi4.core. psi4.core.CCWavefunction method. psi4.core.CIWavefunction method. psi4.core.CUHF method. psi4.core.DFEP2Wavefunction method. psi4.core.HF method. psi4.core.Molecule method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF method. psi4.core.Wavefunction method. set_vv10_b() psi4.core.SuperFunctional method. set_vv10_c() psi4.core.SuperFunctional method. set_wcombine() psi4.core.DFJCOSK method. psi4.core.DirectJK method. psi4.core.JK method. psi4.core.MemDFJK method. set_write_dpd_so_tpdm() psi4.core.IntegralTransform method. set_x_alpha() psi4.core.SuperFunctional method. set_x_beta() psi4.core.SuperFunctional method. set_x_omega() psi4.core.SuperFunctional method. setName() psi4.core.ExternalPotential method. setting. ; keywords anharmonicity(). keywords cbs(). keywords cp. keywords database(). keywords energy(). keywords frequency(). keywords general. keywords molecule. keywords optimize(). keywords properties(). keywords vmfc. SF_RESTRICT (DETCI). shallow_copy() psi4.core.CCWavefunction method. psi4.core.CIWavefunction method. psi4.core.CUHF method. psi4.core.DFEP2Wavefunction method. psi4.core.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF method. psi4.core.Wavefunction method. shape psi4.core.Matrix attribute. psi4.core.Vector attribute. shared_object() psi4.core.IO static method. psi4.core.IOManager static method. shell() psi4.core.BasisSet method. shell_extents() psi4.core.BasisExtents method. shell_on_center() psi4.core.BasisSet method. shell_significant() psi4.core.ERI method. psi4.core.ERISieve method. psi4.core.TwoBodyAOInt method. psi4.core.TwoElectronInt method. shell_to_ao_function() psi4.core.BasisSet method. shell_to_basis_function() psi4.core.BasisSet method. shell_to_center() psi4.core.BasisSet method. ShellInfo class in psi4.core. shells_iterat,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/genindex.html:141205,energy,energy,141205,psi4manual/1.6.x/genindex.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/genindex.html,1,['energy'],['energy']
Energy Efficiency,"m model, including detailed dict at atomicresult.extras[""findif_record""]. * convert result to psi4.core.Matrix. _findif_schema_to_wfn(); -----------------------; * build wfn from findif mol and basis (if singular) and module (if singular); * push qcvars to P::e and wfn. gradient_write(); ----------------; * write .grad file if requested. hessian_write(); ---------------; * write .hess file if requested. * return dd/g/h and wfn. """""". import copy; import logging; from functools import partial; from typing import Any, Callable, Dict, Iterator, List, Optional, Tuple, Union, TYPE_CHECKING. import numpy as np; try:; from pydantic.v1 import Field, validator; except ImportError:; from pydantic import Field, validator; from qcelemental.models import DriverEnum, AtomicResult; from qcelemental import constants. from psi4 import core; from psi4.driver import p4util, pp, qcdb, nppp10; from psi4.driver.p4util.exceptions import ValidationError; from psi4.driver.task_base import AtomicComputer, BaseComputer, EnergyGradientHessianWfnReturn. if TYPE_CHECKING:; import qcportal. logger = logging.getLogger(__name__). # CONVENTIONS:; # n_ at the start of a variable name is short for ""number of.""; # _pi at the end of a variable name is short for ""per irrep.""; # h is the index of an irrep. def _displace_cart(mass: np.ndarray, geom: np.ndarray, salc_list: core.CdSalcList, i_m: Iterator[Tuple], step_size: float) -> Tuple[np.ndarray, str]:; """"""Displace a geometry along the specified displacement SALCs. Parameters; ----------; mass; (nat, ) masses [u] of atoms of the molecule (const).; geom; (nat, 3) reference geometry [a0] of the molecule (const).; salc_list; A list of Cartesian displacement SALCs; i_m; An iterator containing tuples. Each tuple has the index of a salc in; salc_list and the number of steps (positive or negative) to displace; the salc at that index.; step_size; The size of a single ""step,"" i.e., the stencil size. Returns; -------; disp_geom; (nat, 3) Displaced geometry.; label;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html:4994,Energy,EnergyGradientHessianWfnReturn,4994,psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,1,['Energy'],['EnergyGradientHessianWfnReturn']
Energy Efficiency,"m one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None, *, quiet=False)¶. Parameters; quiet (bool) – . c1_deep_copy(self: psi4.core.RHF, basis: psi4.core.BasisSet) → psi4.core.RHF¶; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet basis. check_phases(self: psi4.core.HF) → None¶; docstring. clear_external_cpscf_perturbations(self: psi4.core.HF) → None¶; Clear private external_cpscf_perturbations map. clear_external_potentials(self: psi4.core.HF) → None¶; Clear private external_potentials list. compute_E(self: psi4.core.HF) → float¶; docstring. compute_energy()¶; Base class Wavefunction requires this function. Here it is; simply a wrapper around initialize(), iterations(), finalize_energy(). It; returns the SCF energy computed by finalize_energy(). compute_fvpi(self: psi4.core.HF) → None¶; Update number of frozen virtuals. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. compute_initial_E(self: psi4.core.HF) → float¶; docstring. compute_orbital_gradient(save_fock, max_diis_vectors)¶; docstring. Return type; float. Parameters. save_fock (bool) – ; max_diis_vectors (int) – . compute_spin_contamination(self: psi4.core.HF) → None¶; docstring. cphf_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix]) → List[psi4.core.Matrix]¶; CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self: psi4.core.HF) → bool¶; Adds occupied guess alpha orbitals. cphf_solve(self: psi4.core.HF, x_vec: List[psi4.core.Matrix], conv_tol: float, max_iter: int, print_lvl: int = 2) → List[psi4.core.Matrix]¶; Solves the CPHF equations for a given set of x ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.RHF.html:18129,energy,energy,18129,psi4manual/1.6.x/api/psi4.core.RHF.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.RHF.html,2,['energy'],['energy']
Energy Efficiency,"m one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None, *, quiet=False)¶. Parameters; quiet (bool) – . c1_deep_copy(self: psi4.core.UHF, basis: psi4.core.BasisSet) → psi4.core.UHF¶; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet basis. check_phases(self: psi4.core.HF) → None¶; docstring. clear_external_cpscf_perturbations(self: psi4.core.HF) → None¶; Clear private external_cpscf_perturbations map. clear_external_potentials(self: psi4.core.HF) → None¶; Clear private external_potentials list. compute_E(self: psi4.core.HF) → float¶; docstring. compute_energy()¶; Base class Wavefunction requires this function. Here it is; simply a wrapper around initialize(), iterations(), finalize_energy(). It; returns the SCF energy computed by finalize_energy(). compute_fvpi(self: psi4.core.HF) → None¶; Update number of frozen virtuals. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. compute_initial_E(self: psi4.core.HF) → float¶; docstring. compute_orbital_gradient(save_fock, max_diis_vectors)¶; docstring. Return type; float. Parameters. save_fock (bool) – ; max_diis_vectors (int) – . compute_spin_contamination(self: psi4.core.HF) → None¶; docstring. cphf_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix]) → List[psi4.core.Matrix]¶; CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self: psi4.core.HF) → bool¶; Adds occupied guess alpha orbitals. cphf_solve(self: psi4.core.HF, x_vec: List[psi4.core.Matrix], conv_tol: float, max_iter: int, print_lvl: int = 2) → List[psi4.core.Matrix]¶; Solves the CPHF equations for a given set of x ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.UHF.html:18129,energy,energy,18129,psi4manual/1.6.x/api/psi4.core.UHF.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.UHF.html,2,['energy'],['energy']
Energy Efficiency,"m psi4 import core. if TYPE_CHECKING:; import qcportal. logger = logging.getLogger(__name__). EnergyGradientHessianWfnReturn = Union[float, core.Matrix, Tuple[Union[float, core.Matrix], core.Wavefunction]]. [docs]class BaseComputer(qcel.models.ProtoModel):; """"""Base class for ""computers"" that plan, run, and process QC tasks."""""". [docs] @abc.abstractmethod; def compute(self):; pass. [docs] @abc.abstractmethod; def plan(self):; pass. class Config(qcel.models.ProtoModel.Config):; extra = ""allow""; allow_mutation = True. [docs]class AtomicComputer(BaseComputer):; """"""Computer for analytic single-geometry computations."""""". molecule: Any = Field(..., description=""The molecule to use in the computation.""); basis: str = Field(..., description=""The quantum chemistry basis set to evaluate (e.g., 6-31g, cc-pVDZ, ...).""); method: str = Field(..., description=""The quantum chemistry method to evaluate (e.g., B3LYP, MP2, ...).""); driver: DriverEnum = Field(..., description=""The resulting type of computation: energy, gradient, hessian, properties.""; ""Note for finite difference that this should be the target driver, not the means driver.""); keywords: Dict[str, Any] = Field(default_factory=dict, description=""The keywords to use in the computation.""); computed: bool = Field(False, description=""Whether quantum chemistry has been run on this task.""); result: Any = Field(default_factory=dict, description="":py:class:`~qcelemental.models.AtomicResult` return.""); result_id: Optional[str] = Field(None, description=""The optional ID for the computation.""). class Config(qcel.models.ProtoModel.Config):; pass. [docs] @validator(""basis""); def set_basis(cls, basis):; return basis.lower(). [docs] @validator(""method""); def set_method(cls, method):; return method.lower(). [docs] @validator(""keywords""); def set_keywords(cls, keywords):; return copy.deepcopy(keywords). [docs] def plan(self) -> AtomicInput:; """"""Form QCSchema input from member data."""""". atomic_model = AtomicInput(**{; ""molecule"": self.molecu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/task_base.html:2564,energy,energy,2564,psi4manual/1.7.x/_modules/psi4/driver/task_base.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/task_base.html,2,['energy'],['energy']
Energy Efficiency,"m regular version. """"""; xstr = self.x.variable_to_string(12); ystr = self.y.variable_to_string(12); zstr = self.z.variable_to_string(12); return "" %17s %17s %17s\n"" % (xstr, ystr, zstr); # should go to outfile. [docs] def invalidate(self):; """"""Flags the current coordinates as being outdated.""""""; self.computed = False; self.x.invalidate(); self.y.invalidate(); self.z.invalidate(). [docs] def clone(self):; """"""Returns new, independent CartesianEntry object""""""; return copy.deepcopy(self). [docs] def everything(self):; CoordEntry.everything(self); print('\nCartesianEntry\n Type = %s\n x = %s\n y = %s\n z = %s\n\n' % (self.type(), self.x.variable_to_string(8), self.y.variable_to_string(8), self.z.variable_to_string(8))). [docs]class ZMatrixEntry(CoordEntry):; """"""Class to hold all information about an atom, including its; coordinate specification as any position of ZMatrix. """""". def __init__(self, entry_number, Z, charge, mass, symbol, label, \; rto=None, rval=0, ato=None, aval=0, dto=None, dval=0, basis=None, shells=None):; """"""Constructor"""""" # note that pos'n of basis arg changed from libmints; CoordEntry.__init__(self, entry_number, Z, charge, mass, symbol, label, basis, shells); self.rto = rto; self.rval = rval; self.ato = ato; self.aval = aval; self.dto = dto; self.dval = dval. [docs] def invalidate(self):; """"""Flags the current coordinates as being outdated""""""; self.computed = False; if self.rval != 0:; self.rval.invalidate(); if self.aval != 0:; self.aval.invalidate(); if self.dval != 0:; self.dval.invalidate(). [docs] def print_in_input_format(self):; """"""Prints the updated geometry, in the format provided by the user""""""; text = """"; if self.rto == None and self.ato == None and self.dto == None:; # The first atom; text += ""\n""; elif self.ato == None and self.dto == None:; # The second atom; now_rto = self.rto.entry_number() + 1; now_rval = self.rval.variable_to_string(10); text += "" %5d %11s\n"" % (now_rto, now_rval); elif self.dto == None:; # The third atom; now_rto = s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html:13988,charge,charge,13988,psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html,1,['charge'],['charge']
Energy Efficiency,"m title: label prepended to all psivars computed. :examples:. >>> # [1] Moments with specific label; >>> E, wfn = energy('hf', return_wfn=True); >>> oeprop(wfn, 'DIPOLE', 'QUADRUPOLE', title='H3O+ SCF'). """"""; oe = core.OEProp(wfn); if 'title' in kwargs:; oe.set_title(kwargs['title']); for prop in args:; oe.add(prop.upper()). # If we're doing MBIS, we want the free-atom volumes; # in order to compute volume ratios,; # but only if we're calling oeprop as the whole molecule; free_atom = kwargs.get('free_atom',False); if ""MBIS_VOLUME_RATIOS"" in prop.upper() and not free_atom:; core.print_out("" Computing free-atom volumes\n""); free_atom_volumes(wfn). oe.compute(). [docs]; def cubeprop(wfn: core.Wavefunction, **kwargs):; """"""Evaluate properties on a grid and generate cube files. .. versionadded:: 0.5; *wfn* parameter passed explicitly. :returns: None. :param wfn: set of molecule, basis, orbitals from which to generate cube files. :examples:. >>> # [1] Cube files for all orbitals; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> cubeprop(wfn). >>> # [2] Cube files for density (alpha, beta, total, spin) and four orbitals; >>> # (two alpha, two beta); >>> set cubeprop_tasks ['orbitals', 'density']; >>> set cubeprop_orbitals [5, 6, -5, -6]; >>> E, wfn = energy('scf', return_wfn=True); >>> cubeprop(wfn). """"""; # By default compute the orbitals; if not core.has_global_option_changed('CUBEPROP_TASKS'):; core.set_global_option('CUBEPROP_TASKS', ['ORBITALS']). cp = core.CubeProperties(wfn); cp.compute_properties(). [docs]; def set_memory(inputval: Union[str, int, float], execute: bool = True, quiet: bool = False) -> int:; """"""Reset the total memory allocation. Parameters; ----------; inputval; Memory value. An Integer or float is taken literally as bytes to be set.; A string is taken as a unit-containing value (e.g., 30 mb), which is; case-insensitive.; execute; When False, interpret *inputval* without setting in Psi4 core.; quiet; When True, do not print to the output file. Returns",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/_modules/psi4/driver/p4util/util.html:2862,energy,energy,2862,psi4manual/master/_modules/psi4/driver/p4util/util.html,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/p4util/util.html,2,['energy'],['energy']
Energy Efficiency,"m title: label prepended to all psivars computed. :examples:. >>> # [1] Moments with specific label; >>> E, wfn = energy('hf', return_wfn=True); >>> oeprop(wfn, 'DIPOLE', 'QUADRUPOLE', title='H3O+ SCF'). """"""; oe = core.OEProp(wfn); if 'title' in kwargs:; oe.set_title(kwargs['title']); for prop in args:; oe.add(prop.upper()). # If we're doing MBIS, we want the free-atom volumes; # in order to compute volume ratios,; # but only if we're calling oeprop as the whole molecule; free_atom = kwargs.get('free_atom',False); if ""MBIS_VOLUME_RATIOS"" in prop.upper() and not free_atom:; core.print_out("" Computing free-atom volumes\n""); free_atom_volumes(wfn). oe.compute(). [docs]; def cubeprop(wfn: core.Wavefunction, **kwargs):; """"""Evaluate properties on a grid and generate cube files. .. versionadded:: 0.5; *wfn* parameter passed explicitly. :returns: None. :param wfn: set of molecule, basis, orbitals from which to generate cube files. :examples:. >>> # [1] Cube files for all orbitals; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> cubeprop(wfn). >>> # [2] Cube files for density (alpha, beta, total, spin) and four orbitals; >>> # (two alpha, two beta); >>> set cubeprop_tasks ['orbitals', 'density']; >>> set cubeprop_orbitals [5, 6, -5, -6]; >>> E, wfn = energy('scf', return_wfn=True); >>> cubeprop(wfn). """"""; # By default compute the orbitals; if not core.has_global_option_changed('CUBEPROP_TASKS'):; core.set_global_option('CUBEPROP_TASKS', ['ORBITALS']). if ((core.get_global_option('INTEGRAL_PACKAGE') == 'ERD') and ('ESP' in core.get_global_option('CUBEPROP_TASKS'))):; raise ValidationError('INTEGRAL_PACKAGE ERD does not play nicely with electrostatic potential, so stopping.'). cp = core.CubeProperties(wfn); cp.compute_properties(). [docs]; def set_memory(inputval: Union[str, int, float], execute: bool = True, quiet: bool = False) -> int:; """"""Reset the total memory allocation. Parameters; ----------; inputval; Memory value. An Integer or float is taken literally as bytes to b",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/util.html:2855,energy,energy,2855,psi4manual/1.9.x/_modules/psi4/driver/p4util/util.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/util.html,2,['energy'],['energy']
Energy Efficiency,"m(); elements = [self.molecule.true_atomic_number(iatom) for iatom in range(natom)]; MDI_Send(elements, natom, MDI_INT, self.comm); return elements. # Respond to the <ENERGY command; def send_energy(self):; """""" Send the total energy through MDI. :returns: *energy* Energy of the system; """"""; self.run_scf(); MDI_Send(self.energy, 1, MDI_DOUBLE, self.comm); return self.energy. # Respond to the <FORCES command; def send_forces(self):; """""" Send the nuclear forces through MDI. :returns: *forces* Atomic forces; """"""; force_matrix = psi4.driver.gradient(self.scf_method, **self.kwargs); forces = force_matrix.np.ravel(); MDI_Send(forces, len(forces), MDI_DOUBLE, self.comm); return forces. # Respond to the >CHARGES command; def recv_charges(self, charges=None):; """""" Receive a set of nuclear charges through MDI and assign them to the atoms in the current molecule. Arguments:; charges: New nuclear charges. If None, receive through MDI.; """"""; natom = self.molecule.natom(); if charges is None:; charges = MDI_Recv(natom, MDI_DOUBLE, self.comm). # Assign the charge of all atoms, taking care to avoid ghost atoms; jatom = 0; for iatom in range(natom):; while self.molecule.fZ(jatom) == 0 and jatom < self.molecule.nallatom():; jatom = jatom + 1; if jatom >= self.molecule.nallatom():; raise Exception('Unexpected number of ghost atoms when receiving masses'); self.molecule.set_nuclear_charge(iatom, charges[jatom]); jatom = jatom + 1. # Respond to the >COORDS command; def recv_coords(self, coords=None):; """""" Receive a set of nuclear coordinates through MDI and assign them to the atoms in the current molecule. Arguments:; coords: New nuclear coordinates. If None, receive through MDI.; """"""; natom = self.molecule.natom(); if coords is None:; coords = MDI_Recv(3 * natom, MDI_DOUBLE, self.comm); matrix = psi4.core.Matrix.from_array(np.array(coords).reshape(-1, 3)); self.molecule.set_geometry(matrix). # Respond to the >MASSES command; def recv_masses(self, masses=None):; """""" Receive a set of nucle",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html:6792,charge,charges,6792,psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html,16,['charge'],['charges']
Energy Efficiency,"m(); elements = [self.molecule.true_atomic_number(iatom) for iatom in range(natom)]; MDI_Send(elements, natom, MDI_INT, self.comm); return elements. # Respond to the <ENERGY command; def send_energy(self):; """""" Send the total energy through MDI. :returns: *energy* Energy of the system; """"""; self.run_scf(); MDI_Send(self.energy, 1, MDI_DOUBLE, self.comm); return self.energy. # Respond to the <FORCES command; def send_forces(self):; """""" Send the nuclear forces through MDI. :returns: *forces* Atomic forces; """"""; force_matrix = psi4.driver.gradient(self.scf_method, **self.kwargs); forces = force_matrix.np.ravel(); MDI_Send(forces, len(forces), MDI_DOUBLE, self.comm); return forces. # Respond to the >CHARGES command; def recv_charges(self, charges=None):; """""" Receive a set of nuclear charges through MDI and assign them to the atoms in the current molecule. Arguments:; charges: New nuclear charges. If None, receive through MDI.; """"""; natom = self.molecule.natom(); if charges is None:; charges = MDI_Recv(natom, MDI_DOUBLE, self.comm). # Assign the charge of all atoms, taking care to avoid ghost atoms; jatom = 0; for iatom in range(natom):; while self.molecule.fZ(jatom) == 0 and jatom < self.molecule.nallatom():; jatom = jatom + 1; if jatom >= self.molecule.nallatom():; raise Exception('Unexpected number of ghost atoms when receiving masses'); self.molecule.set_nuclear_charge(iatom, charges[jatom]); jatom = jatom + 1. # Respond to the >COORDS command; def recv_coords(self, coords=None):; """""" Receive a set of nuclear coordinates through MDI and assign them to the atoms in the current molecule. Arguments:; coords: New nuclear coordinates. If None, receive through MDI.; """"""; natom = self.molecule.natom(); if coords is None:; coords = MDI_Recv(3 * natom, MDI_DOUBLE, self.comm); matrix = psi4.core.Matrix.from_array(np.array(coords).reshape(-1, 3)); self.molecule.set_geometry(matrix); self.molecule._initial_cartesian = matrix. # Respond to the >MASSES command; def recv_masses(self",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html:7224,charge,charges,7224,psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html,12,['charge'],['charges']
Energy Efficiency,"m). mp2-def2; Test case for Binding Energy of C4H5N (Pyrrole) with CO2 using MP2/def2-TZVPP. dft-reference; MP2 with a PBE0 reference computation. pywrap-bfs; apply linear fragmentation algorithm to a water cluster. castup1; Test of SAD/Cast-up (mainly not dying due to file weirdness). mcscf1; ROHF 6-31G** energy of the \(^{3}B_1\) state of CH2, with Z-matrix input. The occupations are specified explicitly. cbs-xtpl-opt; Various extrapolated optimization methods for the H2 molecule. dft-jk; DFT JK on-disk test. sapt-dft-lrc; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. cbs-xtpl-alpha; Extrapolated water energies. dft-dldf; Dispersionless density functional (dlDF+D) internal match to Psi4 Extensive testing has been done to match supplemental info of Szalewicz et. al., Phys. Rev. Lett., 103, 263201 (2009) and Szalewicz et. al., J. Phys. Chem. Lett., 1, 550-555 (2010). opt3; SCF cc-pVDZ geometry optimzation, with Z-matrix input. mcscf3; RHF 6-31G** energy of water, using the MCSCF module and Z-matrix input. scf-dipder; Test SCF dipole derivatives against old Psi3 reference values. dfccsdat1; DF-CCSD(AT) cc-pVDZ energy for the H2O molecule. pywrap-checkrun-rohf; This checks that all energy methods can run with a minimal input and set symmetry. cc4a; RHF-CCSD(T) cc-pVQZ frozen-core energy of the BH molecule, with Cartesian input. This version tests the FROZEN_DOCC option explicitly. dft-psivar; HF and DFT variants single-points on zmat methane, mostly to test that PSI variables are set and computed correctly. Now also testing that CSX harvesting PSI variables correctly update ref_dft_2e/xc due to new BraggSlater radii. fci-tdm-2; BH-H2+ FCI/cc-pVDZ Transition Dipole Moment. mints-benchmark; run some BLAS benchmarks. mp2-grad1; MP2 cc-pVDZ gradient for the H2O molecule. mints12; test roundtrip-ness of dict repr for psi4.core.Molecule and qcdb.Molecule. cc13c; Tests RHF CCSD(T)gradients. ao-casscf-sp; CASSCF/6-31G** energy point. x2c2; Test of SFX2C-1e",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html:14801,energy,energy,14801,psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"m-centered point charges for fragments whose basis sets are not included in the computation. The nbody function computes counterpoise-corrected (CP), non-CP (noCP), and Valiron-Mayer Function Counterpoise (VMFC) interaction energies for complexes composed of arbitrary numbers of monomers.; Examples :; # Counterpoise corrected CCSD(T) energies for the Helium dimer; molecule mol {; He; --; He 1 3; }; # Calculate interaction energies only (skips monomers in monomer basis):; energy('CCSD(T)', bsse_type='cp'); # Calculate interaction and total energies, return interaction energies:; energy('CCSD(T)', bsse_type=['cp','nocp']); # Calculate and return counterpoise-corrected gradient; # Useful for e.g. CP-corrected geometry optimization; gradient('CCSD(T)', bsse_type='cp', return_total_data=True). # noCP, VMFC, and CP energy for a helium cluster, limited at 3 bodies; molecule mol {; He 0 0 0; --; He 0 0 4; --; He 0 4 0; --; He 4 0 0; }. # Returns the nocp energy as its first in the list; energy('CCSD(T)', bsse_type=['nocp', 'cp', 'vmfc'], max_nbody=3). API¶. class psi4.driver.driver_nbody.BsseEnum(value)[source]¶; Available basis-set superposition error (BSSE) treatments. cp = 'cp'¶. nocp = 'nocp'¶. vmfc = 'vmfc'¶. pydantic model psi4.driver.driver_nbody.ManyBodyComputer[source]¶. Show JSON schema{; ""title"": ""ManyBodyComputer"",; ""description"": ""Base class for \""computers\"" that plan, run, and process QC tasks."",; ""type"": ""object"",; ""properties"": {; ""molecule"": {; ""title"": ""Molecule"",; ""description"": ""The target molecule, if not the last molecule defined.""; },; ""basis"": {; ""title"": ""Basis"",; ""default"": ""(auto)"",; ""type"": ""string""; },; ""method"": {; ""title"": ""Method"",; ""default"": ""(auto)"",; ""type"": ""string""; },; ""driver"": {; ""description"": ""The computation driver; i.e., energy, gradient, hessian."",; ""allOf"": [; {; ""$ref"": ""#/definitions/DriverEnum""; }; ]; },; ""keywords"": {; ""title"": ""Keywords"",; ""description"": ""The computation keywords/options."",; ""default"": {},; ""type"": ""objec",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/nbody.html:3623,energy,energy,3623,psi4manual/1.7.x/nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/nbody.html,4,['energy'],['energy']
Energy Efficiency,"m-centered point charges for fragments whose basis sets are not included in the computation. The nbody function computes counterpoise-corrected (CP), non-CP (noCP), and Valiron-Mayer Function Counterpoise (VMFC) interaction energies for complexes composed of arbitrary numbers of monomers.; Examples :; # Counterpoise corrected CCSD(T) energies for the Helium dimer; molecule mol {; He; --; He 1 3; }; # Calculate interaction energies only (skips monomers in monomer basis):; energy('CCSD(T)', bsse_type='cp'); # Calculate interaction and total energies, return interaction energies:; energy('CCSD(T)', bsse_type=['cp','nocp']); # Calculate and return counterpoise-corrected gradient; # Useful for e.g. CP-corrected geometry optimization; gradient('CCSD(T)', bsse_type='cp', return_total_data=True). # noCP, VMFC, and CP energy for a helium cluster, limited at 3 bodies; molecule mol {; He 0 0 0; --; He 0 0 4; --; He 0 4 0; --; He 4 0 0; }. # Returns the nocp energy as its first in the list; energy('CCSD(T)', bsse_type=['nocp', 'cp', 'vmfc'], max_nbody=3). API¶. class psi4.driver.driver_nbody.BsseEnum(value, names=None, *, module=None, qualname=None, type=None, start=1, boundary=None)[source]¶; Available basis-set superposition error (BSSE) treatments. cp = 'cp'¶. nocp = 'nocp'¶. vmfc = 'vmfc'¶. pydantic model psi4.driver.driver_nbody.ManyBodyComputer[source]¶. Show JSON schema{; ""title"": ""ManyBodyComputer"",; ""description"": ""Base class for \""computers\"" that plan, run, and process QC tasks."",; ""type"": ""object"",; ""properties"": {; ""molecule"": {; ""title"": ""Molecule"",; ""description"": ""The target molecule, if not the last molecule defined.""; },; ""basis"": {; ""title"": ""Basis"",; ""default"": ""(auto)"",; ""type"": ""string""; },; ""method"": {; ""title"": ""Method"",; ""default"": ""(auto)"",; ""type"": ""string""; },; ""driver"": {; ""description"": ""The computation driver; i.e., energy, gradient, hessian."",; ""allOf"": [; {; ""$ref"": ""#/definitions/DriverEnum""; }; ]; },; ""keywords"": {; ""title"": ""Keywords"",; ""desc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/nbody.html:3625,energy,energy,3625,psi4manual/1.8.x/nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/nbody.html,2,['energy'],['energy']
Energy Efficiency,"m-centered point charges for fragments whose basis sets are not included in the computation. The nbody function computes counterpoise-corrected (CP), non-CP (noCP), and Valiron-Mayer Function Counterpoise (VMFC) interaction energies for complexes composed of arbitrary numbers of monomers.; Examples :; # Counterpoise corrected CCSD(T) energies for the Helium dimer; molecule mol {; He; --; He 1 3; }; # Calculate interaction energies only (skips monomers in monomer basis):; energy('CCSD(T)', bsse_type='cp'); # Calculate interaction and total energies, return interaction energies:; energy('CCSD(T)', bsse_type=['cp','nocp']); # Calculate and return counterpoise-corrected gradient; # Useful for e.g. CP-corrected geometry optimization; gradient('CCSD(T)', bsse_type='cp', return_total_data=True). # noCP, VMFC, and CP energy for a helium cluster, limited at 3 bodies; molecule mol {; He 0 0 0; --; He 0 0 4; --; He 0 4 0; --; He 4 0 0; }. # Returns the nocp energy as its first in the list; energy('CCSD(T)', bsse_type=['nocp', 'cp', 'vmfc'], max_nbody=3). class psi4.driver.driver_nbody.ManyBodyComputer(**data)[source]¶. Parameters. molecule (Any) – The target molecule, if not the last molecule defined.; basis (str, Default: (auto)) – ; method (str, Default: (auto)) – ; driver ({energy,gradient,hessian,properties}) – The computation driver; i.e., energy, gradient, hessian.; keywords (Dict[Any], Default: {}) – The computation keywords/options.; bsse_type ({nocp,cp,vmfc}, Default: [<BsseEnum.cp: 'cp'>]) – Requested BSSE treatments. First in list determines which interaction or total energy/gradient/Hessian returned.; nfragments (int, Default: -1) – Number of distinct fragments comprising full molecular supersystem.; max_nbody (int, Default: -1) – Maximum number of bodies to include in the many-body treatment. Possible: max_nbody <= nfragments. Default: max_nbody = nfragments.; nbodies_per_mc_level (List[List[Union[int, ]]], Default: []) – Distribution of active n-body levels among",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/nbody.html:3620,energy,energy,3620,psi4manual/1.6.x/nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/nbody.html,2,['energy'],['energy']
Energy Efficiency,"m-centered point charges. keys: 1-based index of fragment, values: list of charges for each fragment.; Add atom-centered point charges for fragments whose basis sets are not included in the computation. """"""; pass. [docs]; class BsseEnum(str, Enum):; """"""Available basis-set superposition error (BSSE) treatments."""""". nocp = ""nocp"" # plain supramolecular interaction energy; cp = ""cp"" # counterpoise correction; vmfc = ""vmfc"" # Valiron-Mayer function counterpoise. def _sum_cluster_ptype_data(; ptype: DriverEnum,; ptype_dict: Dict,; compute_list: Set[FragBasIndex],; fragment_slice_dict: Dict[int, Sequence],; fragment_size_dict: Dict[int, int],; mc_level_lbl: int,; vmfc: bool = False,; nb: int = 0,; ) -> Union[float, np.ndarray]:; """"""; Sum arrays from n-body computations to obtain the BSSE corrected or uncorrected scalar or array. Parameters; ----------; ptype; Hint to shape of array data to sum.; ptype_dict; Dictionary containing computed energy, gradient, or Hessian obtained from each subsystem computation; compute_list; A list of (frag, bas) tuples notating all the required computations.; fragment_slice_dict; Dictionary containing slices that index the gradient or Hessian matrix for each of the 1-indexed fragments.; For He--HOOH--Me cluster, `{1: slice(0, 1, None), 2: slice(1, 5, None), 3: slice(5, 10, None)}`.; fragment_size_dict; Dictionary containing the number of atoms of each 1-indexed fragment.; For He--HOOH--Me cluster, `{1: 1, 2: 4, 3: 5}`.; vmfc; Is it a VMFC calculation?; nb; n-body level; required for VMFC calculations.; mc_level_lbl; User label for what modelchem level results should be pulled out of *ptype_dict*.; This is the 1-indexed counterpart to 0-indexed mc_level_idx. Returns; -------; ret; Scalar or array containing the summed energy, gradient, or Hessian result.; Formerly, passed in and modified in place and only called for g/h. """"""; sign = 1; nat = sum(fragment_size_dict.values()). def labeler(frag: Tuple, bas:Tuple) -> str:; return str(mc_level_lbl",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:11645,energy,energy,11645,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,2,['energy'],['energy']
Energy Efficiency,"m. Phys. 122, 124104 (2005). tu3-h2o-opt; Optimize H2O HF/cc-pVDZ. cc22; ROHF-EOM-CCSD/DZ on the lowest two states of each irrep in \(^{3}B_1\) CH2. cc16; ROHF and UHF-B-CCD(T)/cc-pVDZ \(^{3}B_1\) CH2 single-point energy (fzc, MO-basis \(\langle ab|cd \rangle\) ). dft-vv10; He Dimer VV10 functional test. notes: DFT_VV10_B/C overwrites the NL_DISPERSION_PARAMETERS tuple updated ‘bench’ reference values for new BraggSlater radii. scf-auto-cholesky; Cholesky filter a complete basis. dfccsd-t-grad1; DF-CCSD(T) cc-pVDZ gradients for the H2O molecule. dfomp2-1; OMP2 cc-pVDZ energy for the H2O molecule. dct6; DCT calculation for the triplet O2 using DC-06 and DC-12. Only two-step algorithm is tested. omp3-3; OMP3 cc-pCVDZ energy with B3LYP initial guess for the NO radical. cc14; ROHF-CCSD/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. opt-multi-dimer-c1; Multi-fragment opt of C2h methane dimer with user-combined reference points. fd-freq-energy-large; SCF DZ finite difference frequencies by energies for C4NH4. cisd-sp-2; 6-31G** H2O Test CISD Energy Point. nbody-nocp-gradient; Computation of NoCP-corrected water trimer gradient (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). psimrcc-ccsd_t-2; Mk-MRCCSD(T) single point. \(^1A_1\) CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. opt3; SCF cc-pVDZ geometry optimzation, with Z-matrix input. nbody-cp-gradient; Computation of CP-corrected water trimer gradient (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). mints3; Test individual integral objects for correctness. phi-ao; Test computing values of basis functions (puream and non-puream) at points. dct3; DC-06 calculation for the He dimer. This performs a simultaneous update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the AO Basis, using integrals stored on disk. dft-grad1; DF-BP86-D2 cc-pVDZ frozen core gradient of S22 HCN update ref gradie",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html:36863,energy,energy-large,36863,psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy-large']
Energy Efficiency,"m; the energy/opt computation will always; be run on the molecule defined in the preceding block. For advanced; users, unexpected difficulties may arise due to: (1) the EFP fragment; from the last molecule block executed will always be active (and; potentially interfering with SCF) and (2) recalling a molecule; through activate(name) (where name was the python handle; in the molecule block) will not load up any EFP portion of that; molecule. This divergent treatment is a stopgap while we determine; how best to handle molecules with different domains. At this time, PSI4 is only able to perform pure-efp single-points and; geometry optimizations and mixed qm/efp SCF single-points. name; molecule composition; calls method. efp; efp; efp. pure EFP; EFP interaction energy (IE) on all frags. mixed QM/EFP; EFP IE on EFP frags only. pure QM; error. scf; scf; scf. pure EFP; error. mixed QM/EFP; SCF energy on QM frags w/coupling to EFP frags, plus EFP IE on EFP frags. pure QM; SCF energy on all frags (normal PSI4 operation). Fragment Library¶; Below are documented the EFP fragments available from the LIBEFP library.; These systems are accessible in molecule {...} blocks without; additional configuration. How to configure libefp for building Psi4¶; Role and Dependencies. Role — In PSI4, libefp is a library that provides additional; molecular modeling capabilities (EFP).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) libefp; Upstream Dependencies — libefp \(\Leftarrow\) BLAS/LAPACK. CMake Variables. ENABLE_libefp — CMake variable toggling whether Psi4 builds with libefp; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For libefp, set to an installation directory containing include/efp.h; libefp_DIR — CMake variable to specify where pre-built libefp can be found. Set to installation directory containing share/cmake/libefp/libefpConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_libefp — CMake variable to force internal build of libef",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/libefp-1.html:7246,energy,energy,7246,psi4manual/1.2.1/libefp-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/libefp-1.html,13,['energy'],['energy']
Energy Efficiency,"m; the energy/opt computation will always; be run on the molecule defined in the preceding block. For advanced; users, unexpected difficulties may arise due to: (1) the EFP fragment; from the last molecule block executed will always be active (and; potentially interfering with SCF) and (2) recalling a molecule; through activate(name) (where name was the python handle; in the molecule block) will not load up any EFP portion of that; molecule. This divergent treatment is a stopgap while we determine; how best to handle molecules with different domains. At this time, PSI4 is only able to perform pure-efp single-points and; geometry optimizations and mixed qm/efp SCF single-points. name; molecule composition; calls method. efp; efp; efp. pure EFP; EFP interaction energy (IE) on all frags. mixed QM/EFP; EFP IE on EFP frags only. pure QM; error. scf; scf; scf. pure EFP; error. mixed QM/EFP; SCF energy on QM frags w/coupling to EFP frags, plus EFP IE on EFP frags. pure QM; SCF energy on all frags (normal PSI4 operation). Fragment Library¶; Below are documented the EFP fragments available from the LIBEFP library.; These systems are accessible in molecule {...} blocks without; additional configuration. How to configure libefp for building Psi4¶; Role and Dependencies. Role — In PSI4, libefp is a library that provides additional; molecular modeling capabilities (EFP).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) libefp; Upstream Dependencies — libefp \(\Leftarrow\) None. CMake Variables. ENABLE_libefp — CMake variable toggling whether Psi4 builds with libefp; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For libefp, set to an installation directory containing include/efp.h; libefp_DIR — CMake variable to specify where pre-built libefp can be found. Set to installation directory containing share/cmake/libefp/libefpConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_libefp — CMake variable to force internal build of libefp inste",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/libefp-1.html:7110,energy,energy,7110,psi4manual/1.1.0/libefp-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/libefp-1.html,2,['energy'],['energy']
Energy Efficiency,"m; the energy/opt computation will always; be run on the molecule defined in the preceding block. For advanced; users, unexpected difficulties may arise due to: (1) the EFP fragment; from the last molecule block executed will always be active (and; potentially interfering with SCF) and (2) recalling a molecule; through activate(name) (where name was the python handle; in the molecule block) will not load up any EFP portion of that; molecule. This divergent treatment is a stopgap while we determine; how best to handle molecules with different domains. At this time, Psi4 is only able to perform pure-efp single-points and; geometry optimizations and mixed qm/efp SCF single-points. name; molecule composition; calls method. efp; efp; efp. pure EFP; EFP interaction energy (IE) on all frags. mixed QM/EFP; EFP IE on EFP frags only. pure QM; error. scf; scf; scf. pure EFP; error. mixed QM/EFP; SCF energy on QM frags w/coupling to EFP frags, plus EFP IE on EFP frags. pure QM; SCF energy on all frags (normal Psi4 operation). Fragment Library¶; Below are documented the EFP fragments available from the LIBEFP library.; These systems are accessible in molecule {...} blocks without; additional configuration. 2aminopyridine¶. rotate: click+drag; translate: alt+click+drag; zoom: scroll. Visualization by ChemDoodle Web; Comment; 2-aminopyridine, S22 Complex Elec.: 6-31G* Rest: 6-311++G(3df,2p). Full Geometry in Angstroms; N -0.297712 -1.170382 0.001714; C -0.912531 0.026013 0.004723; C -0.175714 1.226496 0.003700; C 1.204216 1.176210 0.000547; C 1.842683 -0.065832 -0.001280; C 1.045154 -1.196712 0.000533; H -0.697132 2.173907 0.003778; H 1.778223 2.092763 0.001427; H 2.918377 -0.152929 -0.000909; H 1.493951 -2.183173 0.004591; N -2.277071 0.027597 -0.043650; H -2.727502 0.885639 0.221497; H -2.756811 -0.823399 0.254372. pyrazine¶. rotate: click+drag; translate: alt+click+drag; zoom: scroll. Visualization by ChemDoodle Web; Comment; Pyrazine Elec.: 6-31G* Rest: 6-311++G(3df,2p). Full ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/libefp-1.html:6404,energy,energy,6404,psi4manual/1.0.0/libefp-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/libefp-1.html,2,['energy'],['energy']
Energy Efficiency,"mPy representation of the Wavefunction. Return type; dict. twoel_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix], arg1: bool, arg2: str) → List[psi4.core.Matrix]¶; Two-electron Hessian-vector products. validate_diis()¶; Sanity-checks DIIS control options. Raises; psi4.driver.p4util.exceptions.ValidationError – If any of DIIS options don’t play well together. Returns; Whether some form of DIIS is enabled during SCF. Return type; bool. variable(key)¶; Return copy of scalar or array QCVariable key from self psi4.core.Wavefunction. Returns; Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles) are returned as numpy.ndarray of natural dimensionality.; Other array variables are returned as Matrix and may have an extra dimension with symmetry information. Return type; float or numpy.ndarray or Matrix. Parameters. cls (psi4.core.Wavefunction) – ; key (str) – . Example; >>> g, wfn = psi4.gradient(""hf/cc-pvdz"", return_wfn=True); >>> wfn.variable(""CURRENT ENERGY""); -100.00985995185668; >>> wfn.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> wfn.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> wfn.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). variables(include_deprecated_keys=False)¶; Return all scalar or array QCVariables from cls. Return type; Dict[str, Union[float, Matrix, ndarray]]. Parameters; include_deprecated_keys (bool) – . write_molden(filename=None, do_virtual=None, use_natural=False)¶; Function to write wavefunction information in wfn to filename in; molden format. Will write natural orbitals from density (MO basis) if supplied.; Warning! Most post-SCF Wavefunctions do not build the density as this is often; much more costly than the energy. In addition, the Wavefunction density attributes; (Da and Db) return the SO density and must be transformed to the MO basis; to use with this f",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.CUHF.html:35669,ENERGY,ENERGY,35669,psi4manual/1.6.x/api/psi4.core.CUHF.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.CUHF.html,5,['ENERGY'],['ENERGY']
Energy Efficiency,"m_to_meter = 10e-10;. if len(rvals) != len(energies):; raise Exception(""The number of energies must match the number of distances""). npoints = len(rvals). if npoints != 5 and npoints != 9:; raise Exception(""Only 5- or 9-point fits are implemented right now""). psi4.print_out(""\n\nPerforming a %d-point fit\n"" % npoints). psi4.print_out(""\nOptimizing geometry based on current surface:\n\n"");; if (npoints == 5):; optx = rvals[2]; elif (npoints == 9):; optx = rvals[4]. # Make sure the molecule the user provided is the active one; molecule = mol if mol is not None else psi4.get_active_molecule(); molecule.update_geometry(). natoms = molecule.natom(); if natoms != 2:; raise Exception(""The current molecule must be a diatomic for this code to work!""); m1 = molecule.mass(0); m2 = molecule.mass(1). maxit = 30; thres = 1.0e-9; for i in range(maxit):; if (npoints == 5):; grad= first_deriv_5pt(rvals, energies, optx); secd = second_deriv_5pt(rvals, energies, optx); energy = function_5pt(rvals, energies, optx); elif (npoints == 9):; grad = first_deriv_9pt(rvals, energies, optx); secd = second_deriv_9pt(rvals, energies, optx); energy = function_9pt(rvals, energies, optx); psi4.print_out("" E = %20.14f, x = %14.7f, grad = %20.14f\n"" % (energy, optx, grad)); if abs(grad) < thres:; break; optx -= grad / secd;; psi4.print_out("" Final E = %20.14f, x = %14.7f, grad = %20.14f\n"" % (function_5pt(rvals, energies, optx), optx, grad));. if optx < min(rvals):; raise Exception(""Minimum energy point is outside range of points provided. Use a lower range of r values.""); if optx > max(rvals):; raise Exception(""Minimum energy point is outside range of points provided. Use a higher range of r values.""). if (npoints == 5):; energy = function_5pt(rvals, energies, optx); first = first_deriv_5pt(rvals, energies, optx); secd = second_deriv_5pt(rvals, energies, optx) * p4const.psi_hartree2aJ; third = third_deriv_5pt(rvals, energies, optx) * p4const.psi_hartree2aJ; fourth = fourth_deriv_5pt(rvals, energies, ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/diatomic.html:3243,energy,energy,3243,psi4manual/1.0.0/_modules/diatomic.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/diatomic.html,2,['energy'],['energy']
Energy Efficiency,m_to_nuclear_magneton_ratio; 2.792775600; shielded proton mag. mom. to nuclear magneton ratio [] uncertainty=0.000 000 030. speed_of_light_in_vacuum; 299792458; speed of light in vacuum [m s^{-1}] uncertainty=(exact). standard_acceleration_of_gravity; 9.80665; standard acceleration of gravity [m s^{-2}] uncertainty=(exact). standard_atmosphere; 101325; standard atmosphere [Pa] uncertainty=(exact). standard_state_pressure; 100000; standard-state pressure [Pa] uncertainty=(exact). Stefan_Boltzmann_constant; 5.670367E-8; Stefan-Boltzmann constant [W m^{-2} K^{-4}] uncertainty=0.000 013 e-8. tau_Compton_wavelength; 6.97787E-16; tau Compton wavelength [m] uncertainty=0.000 063 e-15. tau_Compton_wavelength_over_2_pi; 1.11056E-16; tau Compton wavelength over 2 pi [m] uncertainty=0.000 010 e-15. tau_electron_mass_ratio; 3477.15; tau-electron mass ratio [] uncertainty=0.31. tau_mass; 3.16747E-27; tau mass [kg] uncertainty=0.000 29 e-27. tau_mass_energy_equivalent; 2.84678E-10; tau mass energy equivalent [J] uncertainty=0.000 26 e-10. tau_mass_energy_equivalent_in_MeV; 1776.82; tau mass energy equivalent in MeV [MeV] uncertainty=0.16. tau_mass_in_u; 1.90749; tau mass in u [u] uncertainty=0.000 17. tau_molar_mass; 0.00190749; tau molar mass [kg mol^{-1}] uncertainty=0.000 17 e-3. tau_muon_mass_ratio; 16.8167; tau-muon mass ratio [] uncertainty=0.0015. tau_neutron_mass_ratio; 1.89111; tau-neutron mass ratio [] uncertainty=0.000 17. tau_proton_mass_ratio; 1.89372; tau-proton mass ratio [] uncertainty=0.000 17. Thomson_cross_section; 6.6524587158E-29; Thomson cross section [m^2] uncertainty=0.000 000 000 91 e-28. triton_electron_mass_ratio; 5496.92153588; triton-electron mass ratio [] uncertainty=0.000 000 26. triton_g_factor; 5.957924920; triton g factor [] uncertainty=0.000 000 028. triton_mag_mom; 1.504609503E-26; triton mag. mom. [J T^{-1}] uncertainty=0.000 000 012 e-26. triton_mag_mom_to_Bohr_magneton_ratio; 0.0016223936616; triton mag. mom. to Bohr magneton ratio [] uncert,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodoc_physconst-1.html:34559,energy,energy,34559,psi4manual/1.3.2/autodoc_physconst-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodoc_physconst-1.html,11,['energy'],['energy']
Energy Efficiency,"m_{r\rightarrow\infty} v_{\mathrm{x}}^{\mathrm{Local}} (r) = 0\]; IP-tuned LRC functionals effectively pin the chemical potential at \(N\); electrons to the correct value determined by the ionization potential. This; often cleans up the MSIE problem for a surprisingly large number of high-lying; occupied orbitals, as determined by fractional particle curves. Other gap; fitting techniques involving the electron affinity or band gap are sometimes; also used. IP-fitting is found to be particularly critical for the qualitative; determination of excited state ordering in many low band-gap systems.; For dispersion-bound complexes, a very simple additive empirical dispersion; potential, based on a damped Lennard-Jones potential can often produce; remarkably accurate results with KS-DFT. This approach was championed by Grimme,; whose “-D2” and more modern “-D3” approaches are a de facto industry standards. Minimal Input¶; Minimal input for a KS-DFT computation is a molecule block, basis set; option, and a call to energy('b3lyp') (or other valid functional name):; molecule {; He; }. set basis sto-3g. energy('b3lyp'). This will run a B3LYP Restricted Kohn–Sham (RKS) on neutral singlet Helium in; \(D_{2h}\) spatial symmetry with a minimal STO-3G basis, 1.0E-6 energy; and density convergence criteria, a DF ERI algorithm, symmetric; orthogonalization, DIIS, and a core Hamiltonian guess (because single atom). For more information on; any of these options, see the relevant section below, or in the preceding; Hartree–Fock section. Spin/Symmetry Treatment¶; PSI4 implements the most popular spin specializations of KS-DFT, including:. Restricted Kohn–Sham (RKS) [Default]Appropriate only for closed-shell singlet systems, but twice as efficient; as the other flavors, as the alpha and beta densities are constrained to be; identical. Unrestricted Kohn–Sham (UKS)Appropriate for most open-shell systems and fairly easy to converge.; The spatial parts of the alpha and beta orbitals are fully i",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/dft-1.html:12957,energy,energy,12957,psi4manual/1.4.0/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/dft-1.html,9,['energy'],['energy']
Energy Efficiency,"mage of the scene. Generally the view orientation and some specific; details of the .pymol files require some small tweaks to permit; publication-quality renderings. Adding Point Charges to F/I-SAPT Computations¶; Point charges can be added to the interacting subsystems A and B as well; as to the linking fragment C. Briefly, the interaction between the point charges in A(B); and fragment B(A) enters the SAPT0 interction energy. It explicitly affects in the electrostatics; and induction components, and implicitly affects other SAPT0 components by polarizing the orbitals.; If point charges are present in both subsystems A and B, an additional charge-charge interaction; term is also added to the electrostatic energy. When point charges are assigned to subsystem C, the point; charges in C only polarize the orbitals in both fragment A and B. However, the presence of charges in C does not; directly contribute to the SAPT0 interaction energy.; Examples fsapt-ext-abc and fsapt-ext-abc2; illustrate the use of point charges in F/I-SAPT procedure. F/I-SAPT Keywords¶; The input files described above cover roughly 90% of all F/I-SAPT analyses. For; more delicate or involved problems, there are a large number of user options; that permit the customization of the I-SAPT subsystem partition, the convergence; of the IBO localization procedure, numerical thresholds, etc. We have an entire; video tutorial devoted to F/I-SAPT Options .; Direct source-code documentation on these options is available here. Additional Notes¶. Caution; In constrast to Ed Hohenstein’s SAPT0 code, FISAPT uses the -JKFIT; auxiliary basis sets for all Fock-type terms (e.g., electrostatics, exchange,; induction, and core Fock matrix elements in exchange-dispersion), and the -RI; auxiliary basis sets only for the dispersion term. Ed’s code uses the -RI; basis sets for all SAPT terms, which can be problematic for heavy elements.; As such, Ed’s SAPT0 code will yield slightly different results than FISAPT. The; diff",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/fisapt-1.html:12814,charge,charges,12814,psi4manual/1.4.0/fisapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/fisapt-1.html,6,['charge'],['charges']
Energy Efficiency,"make alanine, then DF-SCF energy calculation with the cc-pVDZ basis set. mrcc4; CCSDT cc-pVDZ optimization and frequencies for the H2O molecule using MRCC. omp2-5; SOS-OMP2 cc-pVDZ geometry optimization for the H2O molecule. props1; RHF STO-3G dipole moment computation, performed by applying a finite electric field and numerical differentiation. cc42; RHF-CC2-LR/STO-3G optical rotation of (S)-methyloxirane. gauge = length, omega = (589 355 nm). omp2_5-1; OMP2 cc-pVDZ energy for the H2O molecule. fci-dipole; 6-31G H2O Test FCI Energy Point. pywrap-freq-e-sowreap; Finite difference of energies frequency, run in sow/reap mode. fnocc3; Test FNO-QCISD(T) computation. tu4-h2o-freq; Frequencies for H2O HF/cc-pVDZ at optimized geometry. dcft3; DC-06 calculation for the He dimer. This performs a simultaneous update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the AO Basis, using integrals stored on disk. cc4a; RHF-CCSD(T) cc-pVQZ frozen-core energy of the BH molecule, with Cartesian input. This version tests the FROZEN_DOCC option explicitly. cisd-h2o+-1; 6-31G** H2O+ Test CISD Energy Point. dft-psivar; HF and DFT variants single-points on zmat methane, mostly to test that PSI variables are set and computed correctly. pywrap-alias; Test parsed and exotic calls to energy() like zapt4, mp2.5, and cisd are working. cc8b; ROHF-CCSD cc-pVDZ frozen-core energy for the state of the CN radical, with Cartesian input. mints3; Test individual integral objects for correctness. omp3-2; OMP3 cc-pVDZ energy with ROHF initial guess for the NO radical. cc2; 6-31G** H2O CCSD optimization by energies, with Z-Matrix input. pywrap-checkrun-convcrit; Advanced python example sets different sets of scf/post-scf conv crit and check to be sure computation has actually converged to the expected accuracy. cepa0-grad2; CEPA cc-pVDZ gradient for the NO radical. cc45; RHF-EOM-CC2/cc-pVDZ lowest two states of each symmetry of H2O. fci-tdm-2; BH-H2+ FCI/cc-pVD",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodoc_testsuite-1.html:13821,energy,energy,13821,psi4manual/4.0b5/autodoc_testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodoc_testsuite-1.html,4,['energy'],['energy']
Energy Efficiency,"mal input and set symmetry. fsapt-ext; Quick test of external potential in F-SAPT (see fsapt1 for a real example). psimrcc-fd-freq1; Mk-MRCCSD single point. \(^3 \Sigma ^-\) O2 state described using the Ms = 0 component of the triplet. Uses ROHF triplet orbitals. dft-grad-lr2; Tests CAM gradients with and without XC pieces to narrow grid error. dfomp2p5-grad2; DF-OMP2.5 cc-pVDZ gradients for the H2O+ cation. dft2; DFT Functional Test. fd-gradient; SCF STO-3G finite-difference tests. scf-hess3; CONV SCF 6-31G analytical vs finite-difference tests Tests UHF hessian code for Ca != Cb. cc23; ROHF-EOM-CCSD/DZ analytic gradient lowest \(^{2}B_1\) state of H2O+ (A1 excitation). fnocc4; Test FNO-DF-CCSD(T) energy. opt-multi-dimer-c2h; Multi-fragment opt of C2h methane dimer with user-combined reference points. olccd-grad2; OLCCD cc-pVDZ gradient for the NO radical. fci-h2o-fzcv; 6-31G H2O Test FCI Energy Point. dfmp2-freq1; DF-MP2 frequency by difference of energies for H2O. cc37; CC2(UHF)/cc-pVDZ energy of H2O+. scf-response1; Compute the dipole, quadrupole, and traceless quadrupoles for water. mbis-6; MBIS calculation on H2O. mints2; A test of the basis specification. A benzene atom is defined using a ZMatrix containing dummy atoms and various basis sets are assigned to different atoms. The symmetry of the molecule is automatically lowered to account for the different basis sets. cc46; EOM-CC2/cc-pVDZ on H2O2 with two excited states in each irrep. omp3-4; SCS-OMP3 cc-pVDZ geometry optimization for the H2O molecule. pywrap-checkrun-convcrit; Advanced python example sets different sets of scf/post-scf conv crit and check to be sure computation has actually converged to the expected accuracy. extern1; External potential calculation involving a TIP3P water and a QM water. Finite different test of the gradient is performed to validate forces. dfccsd1; DF-CCSD cc-pVDZ energy for the H2O molecule. cbs-parser; mtd/basis syntax examples. scf-occ; force occupations in scf. fd-freq-g",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html:27863,energy,energy,27863,psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"maller than this value DIIS starts. Type: double; Default: 1e-2. DMRG_SCF_GRAD_THR¶. The density RMS convergence to stop an instruction during successive DMRG instructions. Type: double; Default: 1.e-6. DMRG_SCF_MAX_ITER¶. Maximum number of DMRG iterations. Type: integer; Default: 100. DMRG_SCF_STATE_AVG¶. Whether or not to use state-averaging for roots >=2 with DMRG-SCF. Type: boolean; Default: true. DMRG_SWEEP_DVDSON_RTOL¶. The residual tolerances for the Davidson diagonalization during DMRG instructions. Type: array; Default: No Default. DMRG_SWEEP_ENERGY_CONV¶. The energy convergence to stop an instruction during successive DMRG instructions. Type: array; Default: No Default. DMRG_SWEEP_MAX_SWEEPS¶. The maximum number of sweeps to stop an instruction during successive DMRG instructions. Type: array; Default: No Default. DMRG_SWEEP_NOISE_PREFAC¶. The noise prefactors for successive DMRG instructions. Type: array; Default: No Default. DMRG_SWEEP_STATES¶. The number of reduced renormalized basis states to be retained during successive DMRG instructions. Type: array; Default: No Default. DMRG_UNITARY_WRITE¶. Whether or not to store the unitary on disk (convenient for restarting). Type: boolean; Default: true. table of contents. DMRG; General; DMRG_CASPT2_CALC; DMRG_CASPT2_IMAG; DMRG_CASPT2_IPEA; DMRG_CASPT2_ORBS; DMRG_DIIS; DMRG_DIIS_WRITE; DMRG_EXCITATION; DMRG_IRREP; DMRG_LOCAL_INIT; DMRG_MOLDEN_WRITE; DMRG_MPS_WRITE; DMRG_MULTIPLICITY; DMRG_OPDM_AO_PRINT; DMRG_PRINT_CORR; DMRG_SCF_ACTIVE_SPACE; DMRG_SCF_DIIS_THR; DMRG_SCF_GRAD_THR; DMRG_SCF_MAX_ITER; DMRG_SCF_STATE_AVG; DMRG_SWEEP_DVDSON_RTOL; DMRG_SWEEP_ENERGY_CONV; DMRG_SWEEP_MAX_SWEEPS; DMRG_SWEEP_NOISE_PREFAC; DMRG_SWEEP_STATES; DMRG_UNITARY_WRITE. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Appendices; Keywords by Module; DMRG. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodir_options_c/module__dmrg.html:3428,reduce,reduced,3428,psi4manual/1.7.x/autodir_options_c/module__dmrg.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodir_options_c/module__dmrg.html,2,['reduce'],['reduced']
Energy Efficiency,"mals)); else:; freqs.append(""""""{:.{prec}f}"""""".format(fr.real, prec=decimals)); return np.array(freqs). [docs]; def print_vibs(vibinfo: Dict[str, Datum], atom_lbl: List[str] = None, *, normco: str = 'x', shortlong: bool = True, groupby: int = None, prec: int = 4, ncprec: int = None) -> str:; """"""Pretty printer for vibrational analysis. Parameters; ----------; vibinfo; Results of a Hessian solution.; atom_lbl; Atomic symbols for printing. If None, integers used.; normco; {'q', 'w', 'x'}; Which normal coordinate definition to print (reduced mass, etc. unaffected by this parameter). Must be. * `q` [a0 u^1/2], the mass-weighted normalized eigenvectors of the Hessian,; * `w` [a0], the un-mass-weighted (Cartesian) of q, or; * `x` [a0], the normalized w.; shortlong; Whether normal coordinates should be in (nat, 3) `True` or (nat * 3, 1) `False` format.; groupby; How many normal coordinates per row. Defaults to 3/6 for shortlong=T/F. Value of `-1` uses one row.; prec; Number of decimal places for frequencies, reduced masses, etc.; ncprec; Number of decimal places for normal coordinates. Defaults to 2 for shortlong=short and 4 for shortlong=long. Returns; -------; str; String suitable for printing. """""". def grouper(iterable, n, fillvalue=None):; ""Collect data into fixed-length chunks or blocks""; # grouper('ABCDEFG', 3, 'x') --> ABC DEF Gxx""; args = [iter(iterable)] * n; return itertools.zip_longest(*args, fillvalue=fillvalue). if normco not in ['q', 'w', 'x']:; raise ValidationError(""""""Requested normal coordinates not among allowed q/w/x: """""" + normco). nat = int(len(vibinfo['q'].data[:, 0]) / 3); if atom_lbl is None:; atom_lbl = [''] * nat. active = [idx for idx, trv in enumerate(vibinfo['TRV'].data) if trv == 'V']. presp = 2; colsp = 2; if shortlong:; groupby = groupby if groupby else 3; ncprec = ncprec if ncprec else 2; width = (ncprec + 4) * 3; prewidth = 24; else:; groupby = groupby if groupby else 6; ncprec = ncprec if ncprec else 4; width = ncprec + 8; prewidth = 24; if",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html:25852,reduce,reduced,25852,psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html,6,['reduce'],['reduced']
Energy Efficiency,"manently a dummy function; pass. [docs] def plan(self):; # uncalled function; return [t.plan() for t in self.task_list.values()]. [docs] def compute(self, client: Optional[""qcportal.FractalClient""] = None):; """"""Run each job in task list.""""""; instructions = ""\n"" + p4util.banner(f"" FiniteDifference Computations"", strNotOutfile=True) + ""\n""; logger.debug(instructions); core.print_out(instructions). with p4util.hold_options_state():; for t in self.task_list.values():; t.compute(client=client). def _prepare_results(self, client: Optional[""qcportal.FractalClient""] = None):; results_list = {k: v.get_results(client=client) for k, v in self.task_list.items()}. # load AtomicComputer results into findifrec[reference]; reference = self.findifrec[""reference""]; task = results_list[""reference""]; response = task.return_result; reference[""module""] = getattr(task.provenance, ""module"", None). if task.driver == 'energy':; reference['energy'] = response. elif task.driver == 'gradient':; reference['gradient'] = response; reference['energy'] = task.extras['qcvars']['CURRENT ENERGY']. elif task.driver == 'hessian':; reference['hessian'] = response; reference['energy'] = task.extras['qcvars']['CURRENT ENERGY']; if 'CURRENT GRADIENT' in task.extras['qcvars']:; reference['gradient'] = task.extras['qcvars']['CURRENT GRADIENT']. dipole_available = False; if 'CURRENT DIPOLE' in task.extras['qcvars']:; reference['dipole'] = task.extras['qcvars']['CURRENT DIPOLE']; dipole_available = True. # load AtomicComputer results into findifrec[displacements]; for label, displacement in self.findifrec[""displacements""].items():; task = results_list[label]; response = task.return_result. if task.driver == 'energy':; displacement['energy'] = response. elif task.driver == 'gradient':; displacement['gradient'] = response; displacement['energy'] = task.extras['qcvars']['CURRENT ENERGY']. elif task.driver == 'hessian':; displacement['hessian'] = response; displacement['energy'] = task.extras['qcvars']['CURRENT ENER",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_findif.html:46978,energy,energy,46978,psi4manual/1.7.x/_modules/psi4/driver/driver_findif.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_findif.html,2,['energy'],['energy']
Energy Efficiency,mass energy equivalent [J] uncertainty=0.000 000 055 e-10. helion_mass_energy_equivalent_in_MeV; 2808.391586; helion mass energy equivalent in MeV [MeV] uncertainty=0.000 017. helion_mass_in_u; 3.01493224673; helion mass in u [u] uncertainty=0.000 000 000 12. helion_molar_mass; 0.00301493224673; helion molar mass [kg mol^{-1}] uncertainty=0.000 000 000 12 e-3. helion_proton_mass_ratio; 2.99315267046; helion-proton mass ratio [] uncertainty=0.000 000 000 29. hertz_atomic_mass_unit_relationship; 4.4398216616E-24; hertz-atomic mass unit relationship [u] uncertainty=0.000 000 0020 e-24. hertz_electron_volt_relationship; 4.135667662E-15; hertz-electron volt relationship [eV] uncertainty=0.000 000 025 e-15. hertz_hartree_relationship; 1.5198298460088E-16; hertz-hartree relationship [E_h] uncertainty=0.000 000 000 0090 e-16. hertz_inverse_meter_relationship; 3.335640951E-9; hertz-inverse meter relationship [m^{-1}] uncertainty=(exact). hertz_joule_relationship; 6.626070040E-34; hertz-joule relationship [J] uncertainty=0.000 000 081 e-34. hertz_kelvin_relationship; 4.7992447E-11; hertz-kelvin relationship [K] uncertainty=0.000 0028 e-11. hertz_kilogram_relationship; 7.372497201E-51; hertz-kilogram relationship [kg] uncertainty=0.000 000 091 e-51. inverse_fine_structure_constant; 137.035999139; inverse fine-structure constant [] uncertainty=0.000 000 031. inverse_meter_atomic_mass_unit_relationship; 1.33102504900E-15; inverse meter-atomic mass unit relationship [u] uncertainty=0.000 000 000 61 e-15. inverse_meter_electron_volt_relationship; 0.0000012398419739; inverse meter-electron volt relationship [eV] uncertainty=0.000 000 0076 e-6. inverse_meter_hartree_relationship; 4.556335252767E-8; inverse meter-hartree relationship [E_h] uncertainty=0.000 000 000 027 e-8. inverse_meter_hertz_relationship; 299792458; inverse meter-hertz relationship [Hz] uncertainty=(exact). inverse_meter_joule_relationship; 1.986445824E-25; inverse meter-joule relationship [J] uncertainty=0.000 000,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodoc_physconst-1.html:16369,joule,joule,16369,psi4manual/1.3.2/autodoc_physconst-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodoc_physconst-1.html,11,['joule'],['joule']
Energy Efficiency,"mat.coldim()[0]):; temp.append(mat.get(row, col)); arr.append(temp); return arr. [docs]; def expand_psivars(; pvdefs: Dict[str, Dict[str, Union[List[str], Callable]]],; verbose: Optional[int] = None):; """"""From rules on building QCVariables from others, set new variables to; P::e if all the contributors are available. Parameters; ----------; pvdefs; Dictionary with keys with names of QCVariables to be created and values; with dictionary of two keys: 'args', the QCVariables that contribute to; the key and 'func', a function (or lambda) to combine them.; verbose; Control print level. If unspecified (None), value taken from; :term:`PRINT <PRINT (GLOBALS)>`. Status printing when verbose > 2. Examples; --------; >>> pv1 = dict(); >>> pv1['SAPT CCD DISP'] = {'func': lambda x: x[0] * x[1] + x[2] + x[3] + x[4],; 'args': ['SAPT EXCHSCAL', 'SAPT EXCH-DISP20 ENERGY', 'SAPT DISP2(CCD) ENERGY',; 'SAPT DISP22(S)(CCD) ENERGY', 'SAPT EST.DISP22(T)(CCD) ENERGY']}; >>> pv1['SAPT0 ELST ENERGY'] = {'func': sum, 'args': ['SAPT ELST10,R ENERGY']}; >>> expand_psivars(pv1). """"""; if verbose is None:; verbose = core.get_global_option('PRINT'). for pvar, action in pvdefs.items():; if verbose >= 2:; print(""""""building %s %s"""""" % (pvar, '.' * (50 - len(pvar))), end=''). psivars = core.scalar_variables(); data_rich_args = []. for pv in action['args']:; if isinstance(pv, str):; if pv in psivars:; data_rich_args.append(psivars[pv]); else:; if verbose >= 2:; print(""""""EMPTY, missing {}"""""".format(pv)); break; else:; data_rich_args.append(pv); else:; result = action['func'](data_rich_args); core.set_variable(pvar, result); if verbose >= 2:; print(""""""SUCCESS""""""). [docs]; def provenance_stamp(routine: str, module: str = None) -> Dict[str, str]:; """"""Prepare QCSchema Provenance with |PSIfour| credentials. Parameters; ----------; routine; Name of driver function generating the QCSchema.; module; Primary contributing |PSIfour| library, like ``ccenergy`` or ``dfmp2``. Returns; -------; provenance : Dict[str, s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/procutil.html:18884,ENERGY,ENERGY,18884,psi4manual/1.8.x/_modules/psi4/driver/p4util/procutil.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/procutil.html,9,['ENERGY'],['ENERGY']
Energy Efficiency,"math:`\alpha = 3.4`. Returns; -------; float or ndarray; Eponymous function applied to input zetas and values; type from `valueLO`. Notes; -----; The extrapolation is calculated according to [2]_:; :math:`E_{total}^X = E_{total}^{\infty} + \beta X^{-\alpha}, \alpha = 3.4`. References; ----------. .. [2] Truhlar, Chem. Phys. Lett. 294 (1998) 45-48,; DOI: 10.1016/S0009-2614(98)00866-5. """""". if type(valueLO) != type(valueHI):; raise ValidationError(; f""scf_xtpl_truhlar_2: Inputs must be of the same datatype! ({type(valueLO)}, {type(valueHI)})""). if alpha is None:; alpha = 3.40. beta_division = 1 / (zHI**(-1 * alpha) - zLO**(-1 * alpha)); beta_mult = zHI**(-1 * alpha). if isinstance(valueLO, float):; beta = (valueHI - valueLO) * beta_division; value = valueHI - beta * beta_mult. if verbose:; # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> Truhlar 2-point power form SCF extrapolation for method: %s <==\n\n"""""" % (; functionname.upper()); cbsscheme += """""" LO-zeta (%s) Energy: % 16.12f\n"""""" % (str(zLO), valueLO); cbsscheme += """""" HI-zeta (%s) Energy: % 16.12f\n"""""" % (str(zHI), valueHI); cbsscheme += """""" Alpha (exponent) Value: % 16.12f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: % 16.12f\n\n"""""" % (beta). name_str = ""%s/(%s,%s)"" % (functionname.upper(), _zeta_val2sym[zLO].upper(), _zeta_val2sym[zHI].upper()); cbsscheme += """""" @Extrapolated """"""; cbsscheme += name_str + ':'; cbsscheme += "" "" * (18 - len(name_str)); cbsscheme += """"""% 16.12f\n\n"""""" % value; core.print_out(cbsscheme); logger.debug(cbsscheme). return value. elif isinstance(valueLO, np.ndarray):. beta = (valueHI - valueLO) * beta_division; value = valueHI - beta * beta_mult. if verbose > 2:; cbsscheme = f""""""\n ==> Truhlar 2-point power SCF extrapolation for method: {functionname.upper()} <==\n""""""; cbsscheme += f""""""\n LO-zeta ({zLO}) Data\n""""""; cbsscheme += nppp(valueLO); cbsscheme += f""""""\n HI-zeta ({zHI}) Data\n""""""; cbsscheme += nppp(valueHI). cbsscheme += f""""""\n",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs_helper.html:8480,Energy,Energy,8480,psi4manual/1.6.x/_modules/psi4/driver/driver_cbs_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs_helper.html,1,['Energy'],['Energy']
Energy Efficiency,"mation, such as orbitals, densities,; orbital energies and basis set information is currently supported, but geometry; optimization and vibrational frequency information are not supported at this; time. To generate a FCHK file, simply store the wavefunction from the energy; calculation, and use it to create an FCHK writer:; 1; 2; 3energy, wfn = energy('scf', return_wfn=True); fchk_writer = psi4.core.FCHKWriter(wfn); fchk_writer.write('output.fchk'). The file will be written to the name passed to the FCHK writer’s write(); method. Note that for MP2 and CCSD methods, the energy can be computed without; the expensive steps required to compute the density, so energy calls for these; methods will return a wavefunction that has the Hartree–Fock density. If a; density is required for these methods, the user should instead request a; gradient computation, to ensure that the density is updated appropriately:; 1; 2; 3grad, wfn = gradient('mp2', return_wfn=True); fchk_writer = psi4.core.FCHKWriter(wfn); fchk_writer.write('output.fchk'). psi4.fchk(wfn, filename)[source]¶; Function to write wavefunction information in wfn to filename in; Gaussian FCHK format. New in version 0.6. Returns:None. Parameters:; filename (string) – destination file name for FCHK file; wfn (Wavefunction) – set of molecule, basis, orbitals from which to generate fchk file. Notes. A description of the FCHK format is http://wild.life.nctu.edu.tw/~jsyu/compchem/g09/g09ur/f_formchk.htm; The allowed headers for methods are general and limited, i.e., “Total SCF|MP2|CI|CC Density”,; so “CC” is always used for the post-HF case. Examples:. >>> # [1] FCHK file for DFT calculation; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> fchk(wfn, 'mycalc.fchk'). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. © Copyright 2019, The Psi4 Project.; Last updated on Wednesday, 15 May 2019 08:49PM.; Created using Sphinx 1.8.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/fchk-1.html:2173,energy,energy,2173,psi4manual/1.3.2/fchk-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/fchk-1.html,2,['energy'],['energy']
Energy Efficiency,"matrix input. frac; Carbon/UHF Fractionally-Occupied SCF Test Case. pywrap-basis; SAPT calculation on bimolecular complex where monomers are unspecified so driver auto-fragments it. Basis set and auxiliary basis sets are assigned by atom type. psimrcc-sp1; Mk-MRCCSD single point. O2 state described using the Ms = 0 component of the triplet. Uses ROHF triplet orbitals. fd-freq-gradient; STO-3G frequencies for H2O by finite-differences of gradients. dfmp2-1; Density fitted MP2 cc-PVDZ/cc-pVDZ-RI computation of formic acid dimer binding energy using automatic counterpoise correction. Monomers are specified using Cartesian coordinates. cc13; UHF-CCSD/cc-pVDZ CH2 geometry optimization via analytic gradients. cc34; RHF-CCSD/cc-pVDZ energy of H2O partitioned into pair energy contributions. cepa3; cc-pvdz H2O Test coupled-pair CISD against DETCI CISD. cisd-opt-fd; H2O CISD/6-31G** Optimize Geometry by Energies. omp2-grad2; OMP2 cc-pVDZ gradient for the NO radical. mrcc1; CCSDT cc-pVDZ energy for the H2O molecule using MRCC. cc49; EOM-CC3(UHF) on CH radical with user-specified basis and properties for particular root. cc41; RHF-CC2-LR/cc-pVDZ optical rotation of H2O2. gauge = both, omega = (589 355 nm). sapt1; SAPT0 cc-pVDZ computation of the ethene-ethyne interaction energy, using the cc-pVDZ-JKFIT RI basis for SCF and cc-pVDZ-RI for SAPT. Monomer geometries are specified using Cartesian coordinates. cc39; RHF-CC2-LR/cc-pVDZ dynamic polarizabilities of HOF molecule. cisd-h2o+-2; 6-31G** H2O+ Test CISD Energy Point. mints2; A test of the basis specification. A benzene atom is defined using a ZMatrix containing dummy atoms and various basis sets are assigned to different atoms. The symmetry of the molecule is automatically lowered to account for the different basis sets. dft-b2plyp; Double-hybrid density functional B2PYLP. Reproduces portion of Table I in S. Grimme’s J. Chem. Phys 124 034108 (2006) paper defining the functional. props3; DF-SCF cc-pVDZ multipole moments of benz",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodoc_testsuite-1.html:6426,energy,energy,6426,psi4manual/4.0b4/autodoc_testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodoc_testsuite-1.html,8,['energy'],['energy']
Energy Efficiency,"matrix with variables that are updated during the potential energy surface scan, and then the same procedure is performed using polar coordinates, converted to Cartesian coordinates. mom-h2o-4; MOM excitation from LUMO HOMO+4. scf-freq1; Analytic vs. finite difference DF-SCF frequency test for water. opt8; Various constrained energy minimizations of HOOH with cc-pvdz RHF. Cartesian-coordinate constrained optimizations of HOOH in Cartesians. mp2-1; All-electron MP2 6-31G** geometry optimization of water. scf-guess; Test initial SCF guesses on FH and FH+ in cc-pVTZ basis. dfccd-grad1; DF-CCSD cc-pVDZ gradients for the H2O molecule. cc11; Frozen-core CCSD(ROHF)/cc-pVDZ on CN radical with disk-based AO algorithm. dfscf-bz2; Benzene Dimer DF-HF/cc-pVDZ. cc49; EOM-CC3(UHF) on CH radical with user-specified basis and properties for particular root. dfomp2p5-grad2; DF-OMP2.5 cc-pVDZ gradients for the H2O+ cation. mp3-grad2; MP3 cc-pVDZ gradient for the NO radical. dct9; UHF-ODC-12 and RHF-ODC-12 single-point energy for H2O. This performs a simultaneous update of orbitals and cumulants, using DIIS extrapolation. Four-virtual integrals are handled in the AO basis, where integral transformation is avoided. In the next RHF-ODC-12 computation, AO_BASIS=NONE is used, where four-virtual integrals are transformed into MO basis. rasci-c2-active; 6-31G* C2 Test RASCI Energy Point, testing two different ways of specifying the active space, either with the ACTIVE keyword, or with RAS1, RAS2, RESTRICTED_DOCC, and RESTRICTED_UOCC. freq-masses; check nonphysical masses possible. dft3; DFT integral algorithms test, performing w-B97 RKS and UKS computations on water and its cation, using all of the different integral algorithms. This tests both the ERI and ERF integrals. cbs-xtpl-freq; Various gradients for a strained helium dimer and water molecule. scf6; Tests RHF/ROHF/UHF SCF gradients. opt13; B3LYP cc-pVDZ geometry optimzation of phenylacetylene, starting from not quite linear structure ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html:5424,energy,energy,5424,psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"matted basis set string, e.g. ``""cc-pv[q5]z""`` for the above example. """""". if len(basisarray) == 1:; return basisarray[0]. else:; zetaindx = [i for i in range(len(basisarray[0])) if basisarray[0][i] != basisarray[1][i]][0]; ZSET = [bas[zetaindx] for bas in basisarray]; pre = basisarray[1][:zetaindx]; post = basisarray[1][zetaindx + 1:]. return """".join([pre, ""["", *ZSET, ""]"", post]). def return_energy_components():; """"""Define some quantum chemical knowledge, namely what methods are subsumed in others."""""". # yapf: disable; VARH = {}; VARH['scf'] = {; 'scf': 'SCF TOTAL ENERGY'}; VARH['hf'] = {; 'hf': 'HF TOTAL ENERGY'}; VARH['mp2'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY'}; VARH['dlpno-mp2'] = {; 'hf': 'HF TOTAL ENERGY',; 'dlpno-mp2': 'MP2 TOTAL ENERGY'}; VARH['mp2d'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2d': 'MP2D TOTAL ENERGY'}; VARH['mp2.5'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'mp2.5': 'MP2.5 TOTAL ENERGY',; 'mp3': 'MP3 TOTAL ENERGY'}; VARH['mp3'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'mp2.5': 'MP2.5 TOTAL ENERGY',; 'mp3': 'MP3 TOTAL ENERGY'}; VARH['mp4(sdq)'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'mp2.5': 'MP2.5 TOTAL ENERGY',; 'mp3': 'MP3 TOTAL ENERGY',; 'mp4(sdq)': 'MP4(SDQ) TOTAL ENERGY'}; VARH['mp4'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'mp2.5': 'MP2.5 TOTAL ENERGY',; 'mp3': 'MP3 TOTAL ENERGY',; 'mp4(sdq)': 'MP4(SDQ) TOTAL ENERGY',; 'mp4': 'MP4 TOTAL ENERGY'}; VARH['omp2'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'omp2': 'OMP2 TOTAL ENERGY'}; VARH['omp2.5'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'mp2.5': 'MP2.5 TOTAL ENERGY',; 'omp2.5': 'OMP2.5 TOTAL ENERGY'}; VARH['omp3'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'mp3': 'MP3 TOTAL ENERGY',; 'omp3': 'OMP3 TOTAL ENERGY'}; VARH['olccd'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'olccd': 'OLCCD TOTAL ENERGY'}; VARH['lccd'] = {; 'hf': 'HF TOTAL EN",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html:11520,ENERGY,ENERGY,11520,psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html,4,['ENERGY'],['ENERGY']
Energy Efficiency,"matted basis set string, e.g. ``""cc-pv[q5]z""`` for the above example. """""". if len(basisarray) == 1:; return basisarray[0]. else:; zetaindx = [i for i in range(len(basisarray[0])) if basisarray[0][i] != basisarray[1][i]][0]; ZSET = [bas[zetaindx] for bas in basisarray]; pre = basisarray[1][:zetaindx]; post = basisarray[1][zetaindx + 1:]. return """".join([pre, ""["", *ZSET, ""]"", post]). def return_energy_components():; """"""Define some quantum chemical knowledge, namely what methods are subsumed in others."""""". # yapf: disable; VARH = {}; VARH['scf'] = {; 'scf': 'SCF TOTAL ENERGY'}; VARH['hf'] = {; 'hf': 'HF TOTAL ENERGY'}; VARH['mp2'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY'}; VARH['dlpno-mp2'] = {; 'hf': 'HF TOTAL ENERGY',; 'dlpno-mp2': 'MP2 TOTAL ENERGY'}; VARH['mp2d'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2d': 'MP2D TOTAL ENERGY'}; VARH['mp2.5'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'mp2.5': 'MP2.5 TOTAL ENERGY',; 'mp3': 'MP3 TOTAL ENERGY'}; VARH['mp3'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'mp2.5': 'MP2.5 TOTAL ENERGY',; 'mp3': 'MP3 TOTAL ENERGY'}; VARH['mp4(sdq)'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'mp2.5': 'MP2.5 TOTAL ENERGY',; 'mp3': 'MP3 TOTAL ENERGY',; 'mp4(sdq)': 'MP4(SDQ) TOTAL ENERGY'}; VARH['mp4'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'mp2.5': 'MP2.5 TOTAL ENERGY',; 'mp3': 'MP3 TOTAL ENERGY',; 'mp4(sdq)': 'MP4(SDQ) TOTAL ENERGY',; 'mp4': 'MP4 TOTAL ENERGY'}; VARH['omp2'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'omp2': 'OMP2 TOTAL ENERGY'}; VARH['omp2.5'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'mp2.5': 'MP2.5 TOTAL ENERGY',; 'omp2.5': 'OMP2.5 TOTAL ENERGY'}; VARH['omp3'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'mp3': 'MP3 TOTAL ENERGY',; 'omp3': 'OMP3 TOTAL ENERGY'}; VARH['olccd'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'olccd': 'OLCCD TOTAL ENERGY'}; VARH['oremp2'] = {; 'hf': 'HF TOTAL ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_cbs.html:11571,ENERGY,ENERGY,11571,psi4manual/1.7.x/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_cbs.html,16,['ENERGY'],['ENERGY']
Energy Efficiency,"maximum number of electrons in RAS IV, for CC. Type: integer; Default: -1. CC_SCALE_OS (FNOCC); FNOCC — Oppposite-spin scaling factor for SCS-CCSD. Type: double; Default: 1.27. CC_SCALE_SS (FNOCC); FNOCC — Same-spin scaling factor for SCS-CCSD. Type: double; Default: 1.13. CC_SS_SCALE (CCENERGY); CCENERGY — Coupled-cluster same-spin scaling value. Type: double; Default: 1.13. CC_TIMINGS (FNOCC); FNOCC — Do time each cc diagram?. Type: boolean; Default: false. CC_TYPE (GLOBALS); GLOBALS — Algorithm to use for CC or CEPA computation (e.g., CCD, CCSD(T), CEPA(3), ACPF). See Cross-module Redundancies for details. Type: string; Possible Values: DF, CONV, CD; Default: CONV. CC_UPDATE_EPS (DETCI); DETCI (Expert) — Do update T amplitudes with orbital eigenvalues? (Usually would do this). Not doing this is experimental. Type: boolean; Default: true. CC_VAL_EX_LEVEL (DETCI); DETCI — The CC valence excitation level. Type: integer; Default: 0. CC_VARIATIONAL (DETCI); DETCI (Expert) — Do use variational energy expression in CC computation? Experimental. Type: boolean; Default: false. CC_VECS_READ (DETCI); DETCI — Do import a CC vector from disk?. Type: boolean; Default: false. CC_VECS_WRITE (DETCI); DETCI — Do export a CC vector to disk?. Type: boolean; Default: false. CCD_E_CONVERGENCE (SAPT); SAPT — E converge value for CCD. Type: conv double; Default: 1e-8. CCD_MAXITER (SAPT); SAPT — Max CCD iterations. Type: integer; Default: 50. CCD_T_CONVERGENCE (SAPT); SAPT — Convergence tolerance for CCD amplitudes. Type: conv double; Default: 1e-8. CCL_ENERGY (OCC); OCC — Do compute CC Lambda energy? In order to this option to be valid one should use “TPDM_ABCD_TYPE = COMPUTE” * option. Type: boolean; Default: false. CEPA_LEVEL (FNOCC); FNOCC (Expert) — Which coupled-pair method is called? This parameter is used internally by the python driver. Changing its value won’t have any effect on the procedure. Type: string; Default: CEPA(0). CEPA_NO_SINGLES (FNOCC); FNOCC — Flag to exclude singl",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodoc_glossary_options_c-1.html:15396,energy,energy,15396,psi4manual/1.3.2/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodoc_glossary_options_c-1.html,2,['energy'],['energy']
Energy Efficiency,"maximum number of electrons in RAS IV, for CC. Type: integer; Default: -1. CC_SCALE_OS (FNOCC); FNOCC — Oppposite-spin scaling factor for SCS-CCSD. Type: double; Default: 1.27. CC_SCALE_SS (FNOCC); FNOCC — Same-spin scaling factor for SCS-CCSD. Type: double; Default: 1.13. CC_SS_SCALE (CCENERGY); CCENERGY — Coupled-cluster same-spin scaling value. Type: double; Default: 1.13. CC_TIMINGS (FNOCC); FNOCC — Do time each cc diagram?. Type: boolean; Default: false. CC_TYPE (GLOBALS); GLOBALS — Algorithm to use for CC or CEPA computation (e.g., CCD, CCSD(T), CEPA(3), ACPF). See Cross-module Redundancies for details. Type: string; Possible Values: DF, CONV, CD; Default: CONV. CC_UPDATE_EPS (DETCI); DETCI (Expert) — Do update T amplitudes with orbital eigenvalues? (Usually would do this). Not doing this is experimental. Type: boolean; Default: true. CC_VAL_EX_LEVEL (DETCI); DETCI — The CC valence excitation level. Type: integer; Default: 0. CC_VARIATIONAL (DETCI); DETCI (Expert) — Do use variational energy expression in CC computation? Experimental. Type: boolean; Default: false. CC_VECS_READ (DETCI); DETCI — Do import a CC vector from disk?. Type: boolean; Default: false. CC_VECS_WRITE (DETCI); DETCI — Do export a CC vector to disk?. Type: boolean; Default: false. CCD_E_CONVERGENCE (SAPT); SAPT — E converge value for CCD. Type: conv double; Default: 1e-8. CCD_MAXITER (SAPT); SAPT — Max CCD iterations. Type: integer; Default: 50. CCD_T_CONVERGENCE (SAPT); SAPT — Convergence tolerance for CCD amplitudes. Type: conv double; Default: 1e-8. CCL_ENERGY (OCC); OCC — Do compute CC Lambda energy? In order to this option to be valid one should use “TPDM_ABCD_TYPE = COMPUTE” option. Type: boolean; Default: false. CEPA_LEVEL (FNOCC); FNOCC (Expert) — Which coupled-pair method is called? This parameter is used internally by the python driver. Changing its value won’t have any effect on the procedure. Type: string; Default: CEPA(0). CEPA_NO_SINGLES (FNOCC); FNOCC — Flag to exclude singly ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html:15800,energy,energy,15800,psi4manual/1.0.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html,6,['energy'],['energy']
Energy Efficiency,"mbedded charges. print_out(self); Print python print helper to the outfile. setName(self, arg0); Sets the name. Methods Documentation. addBasis(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet, coefs: psi4.core.Vector) → None¶; Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self: psi4.core.ExternalPotential, Z: float, x: float, y: float, z: float) → None¶; Add a charge Z at (x,y,z). appendCharges(self: psi4.core.ExternalPotential, arg0: List[Tuple[float, float, float, float]]) → None¶; Append a vector of charge tuples to a current ExternalPotential. clear(self: psi4.core.ExternalPotential) → None¶; Reset the field to zero (eliminates all entries). computeExternExternInteraction(self: psi4.core.ExternalPotential, arg0: psi4.core.ExternalPotential) → float¶; Compute the interaction between this potential and other external potential. computeNuclearEnergy(self: psi4.core.ExternalPotential, arg0: psi4.core.Molecule) → float¶; Compute the contribution to the nuclear repulsion energy for the given molecule. computePotentialMatrix(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet) → psi4.core.Matrix¶; Compute the external potential matrix in the given basis set. getCharges(self: psi4.core.ExternalPotential) → List[Tuple[float, float, float, float]]¶; Get the vector of charge tuples. gradient_on_charges(self: psi4.core.ExternalPotential) → psi4.core.Matrix¶; Get the gradient on the embedded charges. print_out(self: psi4.core.ExternalPotential) → None¶; Print python print helper to the outfile. setName(self: psi4.core.ExternalPotential, arg0: str) → None¶; Sets the name. table of contents. ExternalPotential; ExternalPotential; ExternalPotential.addBasis(); ExternalPotential.addCharge(); ExternalPotential.appendCharges(); ExternalPotential.clear(); ExternalPotential.computeExternExternInteraction(); ExternalPotential.computeNuclearEnergy(); ExternalPotential.computePotentialMatrix(); ExternalPotential.getCharges(); ExternalPotentia",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/api/psi4.core.ExternalPotential.html:2069,energy,energy,2069,psi4manual/1.9.x/api/psi4.core.ExternalPotential.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.ExternalPotential.html,2,['energy'],['energy']
Energy Efficiency,"mbedded charges. print_out(self); Print python print helper to the outfile. setName(self, arg0); Sets the name. Methods Documentation. addBasis(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet, coefs: psi4.core.Vector) → None¶; Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self: psi4.core.ExternalPotential, Z: float, x: float, y: float, z: float) → None¶; Add a charge Z at (x,y,z). appendCharges(self: psi4.core.ExternalPotential, arg0: list[tuple[float, float, float, float]]) → None¶; Append a vector of charge tuples to a current ExternalPotential. clear(self: psi4.core.ExternalPotential) → None¶; Reset the field to zero (eliminates all entries). computeExternExternInteraction(self: psi4.core.ExternalPotential, arg0: psi4.core.ExternalPotential) → float¶; Compute the interaction between this potential and other external potential. computeNuclearEnergy(self: psi4.core.ExternalPotential, arg0: psi4.core.Molecule) → float¶; Compute the contribution to the nuclear repulsion energy for the given molecule. computePotentialMatrix(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet) → psi4.core.Matrix¶; Compute the external potential matrix in the given basis set. getCharges(self: psi4.core.ExternalPotential) → list[tuple[float, float, float, float]]¶; Get the vector of charge tuples. gradient_on_charges(self: psi4.core.ExternalPotential) → psi4.core.Matrix¶; Get the gradient on the embedded charges. print_out(self: psi4.core.ExternalPotential) → None¶; Print python print helper to the outfile. setName(self: psi4.core.ExternalPotential, arg0: str) → None¶; Sets the name. table of contents. ExternalPotential; ExternalPotential; ExternalPotential.addBasis(); ExternalPotential.addCharge(); ExternalPotential.appendCharges(); ExternalPotential.clear(); ExternalPotential.computeExternExternInteraction(); ExternalPotential.computeNuclearEnergy(); ExternalPotential.computePotentialMatrix(); ExternalPotential.getCharges(); ExternalPotentia",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/api/psi4.core.ExternalPotential.html:2076,energy,energy,2076,psi4manual/master/api/psi4.core.ExternalPotential.html,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.ExternalPotential.html,2,['energy'],['energy']
Energy Efficiency,"mbedded slat diagram as suitable; for main paper. A single table is formed in sections by *bas* with; lines *mtd* within each section. """"""; rowplan = ['bas', 'mtd']; columnplan = [; ['l', r""""""Method \& Basis Set"""""", '', textables.label, {}],; ['d', r'S22', 'HB', textables.val, {'sset': 'hb', 'dbse': 'S22'}],; ['d', r'S22', 'MX/DD', textables.val, {'sset': 'mxdd', 'dbse': 'S22'}],; ['d', r'S22', 'TT', textables.val, {'sset': 'tt', 'dbse': 'S22'}],; ['d', r'Overall', 'HB', textables.val, {'sset': 'hb', 'dbse': 'DB4'}],; ['d', r'Overall', 'MX/DD', textables.val, {'sset': 'mxdd', 'dbse': 'DB4'}],; ['d', r'Overall', 'TT', textables.val, {'sset': 'tt', 'dbse': 'DB4'}],; ['l', r""""""Error Distribution\footnotemark[1]"""""",; r""""""\includegraphics[width=6.67cm,height=3.5mm]{%s%s.pdf}"""""" % (plotpath, 'blank'),; textables.graphics, {}],; ['d', r'Time', '', textables.empty, {}]]; # TODO Time column not right at all. footnotes = [fnreservoir['blankslat']]; landscape = False; theme = 'smmerge'; title = r""""""Interaction energy [kcal/mol] {{err}} subset statistics with computed with {{opt}}{0}."""""".format(; '' if subjoin else r"""""" and {bas}""""""); return rowplan, columnplan, landscape, footnotes, title, theme. [docs] def table_merge_suppmat(self, plotpath, subjoin):; """"""Specialization of table_generic into table with as many statistics; as will fit (mostly fullcurve and a few 5min) plus embedded slat; diagram as suitable for supplementary material. Multiple tables are; formed, one for each in *bas* with lines *mtd* within each table. """"""; rowplan = ['bas', 'mtd']; columnplan = [; ['l', r""""""Method \& Basis Set"""""", '', textables.label, {}],; ['d', 'S22', 'HB', textables.val, {'sset': 'hb', 'dbse': 'S22'}],; ['d', 'S22', 'MX', textables.val, {'sset': 'mx', 'dbse': 'S22'}],; ['d', 'S22', 'DD', textables.val, {'sset': 'dd', 'dbse': 'S22'}],; ['d', 'S22', 'TT', textables.val, {'sset': 'tt', 'dbse': 'S22'}],; ['d', 'NBC10', 'MX', textables.val, {'sset': 'mx', 'dbse': 'NBC1'}],; ['d', 'NBC10', 'DD',",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:103754,energy,energy,103754,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html,1,['energy'],['energy']
Energy Efficiency,"mber of electrons; - 'ms2' : spin polarization of the system; - 'isym' : symmetry of state (if present in FCIDUMP); - 'orbsym' : list of symmetry labels of each orbital; - 'uhf' : whether restricted or unrestricted; - 'ONE-ELECTRON ENERGY' : SCF one-electron energy; - 'TWO-ELECTRON ENERGY' : SCF two-electron energy; - 'SCF TOTAL ENERGY' : SCF total energy; - 'MP2 CORRELATION ENERGY' : MP2 correlation energy. :param expected: Reference FCIDUMP file against which `computed` is compared.; :param computed: Input FCIDUMP file to compare against `expected`.; :param label: string labeling the test; """""". # Grab expected header and integrals; ref_intdump = fcidump_from_file(expected); intdump = fcidump_from_file(computed). # Compare headers; compare_recursive(; ref_intdump,; intdump,; 'FCIDUMP header',; forgive=['enuc', 'hcore', 'eri', 'epsilon']). ref_energies = energies_from_fcidump(ref_intdump); energies = energies_from_fcidump(intdump). pass_1el = compare_values(ref_energies['ONE-ELECTRON ENERGY'], energies['ONE-ELECTRON ENERGY'], 7,; label + '. 1-electron energy'); pass_2el = compare_values(ref_energies['TWO-ELECTRON ENERGY'], energies['TWO-ELECTRON ENERGY'], 7,; label + '. 2-electron energy'); pass_scf = compare_values(ref_energies['SCF TOTAL ENERGY'], energies['SCF TOTAL ENERGY'], 10,; label + '. SCF total energy'); pass_mp2 = compare_values(ref_energies['MP2 CORRELATION ENERGY'], energies['MP2 CORRELATION ENERGY'], 10,; label + '. MP2 correlation energy'). compare_integers(True, (pass_1el and pass_2el and pass_scf and pass_mp2), label). [docs]; def energies_from_fcidump(intdump) -> Dict[str, float]:; """"""From integrals dictionary generated from :py:func:`fcidump_from_file`,; compute energies. :returns: a dictionary with energies. - 'NUCLEAR REPULSION ENERGY'; - 'ONE-ELECTRON ENERGY'; - 'TWO-ELECTRON ENERGY'; - 'SCF TOTAL ENERGY'; - 'MP2 CORRELATION ENERGY'. """"""; energies = {}; energies['NUCLEAR REPULSION ENERGY'] = intdump['enuc']; epsilon = intdump['epsilon']; Hcore =",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fcidump.html:13400,ENERGY,ENERGY,13400,psi4manual/1.8.x/_modules/psi4/driver/p4util/fcidump.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fcidump.html,6,['ENERGY'],['ENERGY']
Energy Efficiency,"mber of electrons; - 'ms2' : spin polarization of the system; - 'isym' : symmetry of state (if present in FCIDUMP); - 'orbsym' : list of symmetry labels of each orbital; - 'uhf' : whether restricted or unrestricted; - 'ONE-ELECTRON ENERGY' : SCF one-electron energy; - 'TWO-ELECTRON ENERGY' : SCF two-electron energy; - 'SCF TOTAL ENERGY' : SCF total energy; - 'MP2 CORRELATION ENERGY' : MP2 correlation energy. :param expected: Reference FCIDUMP file against which `computed` is compared.; :param computed: Input FCIDUMP file to compare against `expected`.; :param label: string labeling the test; """""". # Grab expected header and integrals; ref_intdump = fcidump_from_file(expected); intdump = fcidump_from_file(computed). # Compare headers; compare_recursive(; ref_intdump,; intdump,; 'FCIDUMP header',; forgive=['enuc', 'hcore', 'eri', 'epsilon']). ref_energies = energies_from_fcidump(ref_intdump); energies = energies_from_fcidump(intdump). pass_1el = compare_values(ref_energies['ONE-ELECTRON ENERGY'], energies['ONE-ELECTRON ENERGY'], 7,; label + '. 1-electron energy'); pass_2el = compare_values(ref_energies['TWO-ELECTRON ENERGY'], energies['TWO-ELECTRON ENERGY'], 7,; label + '. 2-electron energy'); pass_scf = compare_values(ref_energies['SCF TOTAL ENERGY'], energies['SCF TOTAL ENERGY'], 10,; label + '. SCF total energy'); pass_mp2 = compare_values(ref_energies['MP2 CORRELATION ENERGY'], energies['MP2 CORRELATION ENERGY'], 10,; label + '. MP2 correlation energy'). compare_integers(True, (pass_1el and pass_2el and pass_scf and pass_mp2), label). [docs]def energies_from_fcidump(intdump) -> Dict[str, float]:; """"""From integrals dictionary generated from :py:func:`fcidump_from_file`,; compute energies. :returns: a dictionary with energies. - 'NUCLEAR REPULSION ENERGY'; - 'ONE-ELECTRON ENERGY'; - 'TWO-ELECTRON ENERGY'; - 'SCF TOTAL ENERGY'; - 'MP2 CORRELATION ENERGY'. """"""; energies = {}; energies['NUCLEAR REPULSION ENERGY'] = intdump['enuc']; epsilon = intdump['epsilon']; Hcore = i",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/fcidump.html:13392,ENERGY,ENERGY,13392,psi4manual/1.7.x/_modules/psi4/driver/p4util/fcidump.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/fcidump.html,2,['ENERGY'],['ENERGY']
Energy Efficiency,"mber of electrons; - 'ms2' : spin polarization of the system; - 'isym' : symmetry of state (if present in FCIDUMP); - 'orbsym' : list of symmetry labels of each orbital; - 'uhf' : whether restricted or unrestricted; - 'ONE-ELECTRON ENERGY' : SCF one-electron energy; - 'TWO-ELECTRON ENERGY' : SCF two-electron energy; - 'SCF TOTAL ENERGY' : SCF total energy; - 'MP2 CORRELATION ENERGY' : MP2 correlation energy. :param expected: Reference FCIDUMP file against which `computed` is compared.; :param computed: Input FCIDUMP file to compare against `expected`.; :param label: string labeling the test; """""". # Grab expected header and integrals; ref_intdump = fcidump_from_file(expected); intdump = fcidump_from_file(computed). # Compare headers; compare_recursive(; ref_intdump,; intdump,; 'FCIDUMP header',; forgive=['enuc', 'hcore', 'eri', 'epsilon']). ref_energies = energies_from_fcidump(ref_intdump); energies = energies_from_fcidump(intdump). pass_1el = compare_values(ref_energies['ONE-ELECTRON ENERGY'], energies['ONE-ELECTRON ENERGY'], 7,; label + '. 1-electron energy'); pass_2el = compare_values(ref_energies['TWO-ELECTRON ENERGY'], energies['TWO-ELECTRON ENERGY'], 7,; label + '. 2-electron energy'); pass_scf = compare_values(ref_energies['SCF TOTAL ENERGY'], energies['SCF TOTAL ENERGY'], 10,; label + '. SCF total energy'); pass_mp2 = compare_values(ref_energies['MP2 CORRELATION ENERGY'], energies['MP2 CORRELATION ENERGY'], 10,; label + '. MP2 correlation energy'). compare_integers(True, (pass_1el and pass_2el and pass_scf and pass_mp2), label). [docs]def energies_from_fcidump(intdump):; energies = {}; energies['NUCLEAR REPULSION ENERGY'] = intdump['enuc']; epsilon = intdump['epsilon']; Hcore = intdump['hcore']; eri = intdump['eri']. # Compute SCF energy; energies['ONE-ELECTRON ENERGY'], energies['TWO-ELECTRON ENERGY'] = _scf_energy(Hcore, eri,; np.where(epsilon < 0)[0],; intdump['uhf']); # yapf: disable; energies['SCF TOTAL ENERGY'] = energies['ONE-ELECTRON ENERGY'] + energie",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/p4util/fcidump.html:13164,ENERGY,ENERGY,13164,psi4manual/1.6.x/_modules/psi4/driver/p4util/fcidump.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/p4util/fcidump.html,2,['ENERGY'],['ENERGY']
Energy Efficiency,"mber of geometry optimization cycles. Psi4 Interface: Geometry optimizations run through PSI (except in sandwich mode) use PSI’s optimizer and so this keyword has no effect. Use optking keywords instead, particularly GEOM_MAXITER. Type: integer; Default: 50. CFOUR_GEO_MAXSTEP (CFOUR)¶CFOUR — Specifies largest step (in millibohr) which is allowed in geometry optimizations. Psi4 Interface: Geometry optimizations run through PSI (except in sandwich mode) use PSI’s optimizer and so this keyword has no effect. Use optking keywords instead, particularly INTRAFRAG_STEP_LIMIT. Type: integer; Default: 300. CFOUR_GEO_METHOD (CFOUR)¶CFOUR — Specifies the used geometry optimization methods. The following values are permitted: NR (=0) — straightforward Newton-Raphson search for minimum; RFA (=1) — Rational Function Approximation search for minimum (this method can be used to find minima when the initial structure is in a region where the Hessian index is nonzero); TS (=2) Cerjan-Miller eigenvector following search for a transition state (can be started in a region where the Hessian index is not equal to unity); MANR (=3) — Morse-adjusted Newton-Raphson search for minimum (very efficient minimization scheme, particularly if the Hessian is available); SINGLE_POINT (=5) for a single-point energy calculation. ENERONLY (=6) requests a geometry optimization based on single-point energy calculations. Default: SINGLE-POINT (NR as soon as variables are marked to be optimized). Type: string; Possible Values: NR, RFA, TS, MANR, SINGLE_POINT, ENERONLY; Default: SINGLE_POINT. CFOUR_GIAO (CFOUR)¶CFOUR — Specifies whether gauge-including atomic orbitals are used (ON) or not (OFF). Default: ON for CFOUR_PROPS =NMR and =MAGNETIC, otherwise OFF. Type: string; Possible Values: ON, OFF; Default: No Default. CFOUR_GRID (CFOUR)¶CFOUR — Keyword used to control type of grid calculation (see later section in this manual). Options are OFF (=0), no grid calculation; CARTESIAN (=1), steps are in Cartesian ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html:49544,efficient,efficient,49544,psi4manual/1.4.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html,18,"['efficient', 'energy']","['efficient', 'energy']"
Energy Efficiency,"mber starts at GS = 0), (3, 3). CC ROOT n QUADRUPOLE XX¶. CC ROOT n QUADRUPOLE XY¶. CC ROOT n QUADRUPOLE XZ¶. CC ROOT n QUADRUPOLE YY¶. CC ROOT n QUADRUPOLE YZ¶. CC ROOT n QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; coupled cluster level of theory and root n (numbering starts at GS = 0).; Deprecated in favor of CC ROOT n QUADRUPOLE. CC ROOT n TOTAL ENERGY¶. CC ROOT n CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the requested coupled cluster level of theory and root; n (numbering starts at GS = 0). CC TOTAL ENERGY¶. CC CORRELATION ENERGY¶. CC T1 DIAGNOSTIC¶. CC D1 DIAGNOSTIC¶. CC NEW D1 DIAGNOSTIC¶. CC D2 DIAGNOSTIC¶; Diagnostic of multireference character. CC2 TOTAL ENERGY¶. CC2 CORRELATION ENERGY¶. CC3 TOTAL ENERGY¶. CC3 CORRELATION ENERGY¶. CC4 TOTAL ENERGY¶. CC4 CORRELATION ENERGY¶. CCnn TOTAL ENERGY¶. CCnn CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the requested approximate coupled-cluster (CC2, CC3, up to CCnn); level of theory. CC DIPOLE¶; Dipole array [e a0] for the requested coupled cluster level of theory and root, (3,). CC DIPOLE X¶. CC DIPOLE Y¶. CC DIPOLE Z¶; The three components of the dipole [Debye] for the requested; coupled cluster level of theory and root.; Deprecated in favor of CC DIPOLE. CC2 DIPOLE POLARIZABILITY @ xNM¶; The dipole polarizability [au] calculated at the CC2 level; for a given (x) wavelength, (x) rounded to nearest integer. CC2 SPECIFIC ROTATION (LEN) @ xNM¶; The specific rotation [deg/(dm (g/cm^3))] calculated at the CC2 level in the; length gauge for a given (x) wavelength, (x) rounded to nearest integer. CC2 SPECIFIC ROTATION (VEL) @ xNM¶; The specific rotation [deg/(dm (g/cm^3))] calculated at the CC2 level in the; velocity gauge for a given (x) wavelength, (x) rounded to nearest integer. CC2 SPECIFIC ROTATION (MVG) @ xNM¶; The specific rotation [deg/(dm (g/cm^3))] calculated at the CC",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html:4323,energy,energy,4323,psi4manual/1.4.0/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html,8,['energy'],['energy']
Energy Efficiency,"mbination of the ODC-13 method with a three-particle energy correction; [\(\mbox{ODC-13$(\lambda_3)$}\)] can be used (see below).; For the detailed comparison of the quality of these methods, we refer; users to our publications.; The DCT functional can be specified by the DCT_FUNCTIONAL option. The; default choice is the ODC-12 functional. The DCT code can also be used to; compute the \((\lambda_3)\) energy correction that perturbatively accounts; for three-particle correlation effects, similarly to the (T) correction in coupled; cluster theory. Computation of the \((\lambda_3)\) correction can be; requested by setting the THREE_PARTICLE option to PERTURBATIVE. A; combination of the ODC-13 functional with the \((\lambda_3)\) correction; [denoted as \(\mbox{ODC-13$(\lambda_3)$}\)] has been shown to provide highly; accurate results for open-shell molecules near equilibrium geometries.; At the present moment, all of the DCT methods support unrestricted reference; orbitals (REFERENCE UHF), which can be used to perform energy and; gradient computations for both closed- and open-shell molecules. In addition,; the ODC-06 and ODC-12 methods support restricted reference orbitals; (REFERENCE RHF) for the energy and gradient computations of; closed-shell molecules. Note that in this case restricted reference orbitals; are only available for ALGORITHM SIMULTANEOUS. Iterative Algorithms¶; As explained in the Theory section, in order to obtain the DCT energy one; needs to solve a system of coupled equations for orbitals and density; cumulant. At the present moment three iterative algorithms for the solution of the; equations are available. The choice of the algorithm is controlled using the; ALGORITHM option. SIMULTANEOUS [Default]In the simultaneous algorithm the DCT equations are solved in macroiterations.; Each macroiteration consists of a single iteration of the cumulant update; followed by a single iteration of the orbital update and orbital transformation; of the integrals. ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/dct-1.html:7341,energy,energy,7341,psi4manual/1.4.0/dct-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/dct-1.html,9,['energy'],['energy']
Energy Efficiency,"mbis-1; MBIS calculation on H2O. olccd2; OLCCD cc-pVDZ energy with B3LYP initial guess for the NO radical. sapt9; usapt example with empty beta. nbody-multi-level; Multilevel computation of water trimer energy (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). cc49; EOM-CC3(UHF) on CH radical with user-specified basis and properties for particular root. scf-hess5; DF SCF 6-31G analytical vs finite-difference tests Tests DF UHF hessian code for Ca != Cb. sapt-compare; SAPT0 cc-pVDZ computation of the ethene-ethyne interaction energy, using the cc-pVDZ-JKFIT RI basis for SCF and cc-pVDZ-RI for SAPT. Monomer geometries are specified using Cartesian coordinates. mp2p5-grad2; MP2.5 cc-pVDZ gradient for the NO radical. omp2p5-1; OMP2.5 cc-pVDZ energy for the H2O molecule. dct4; DCT calculation for the HF+ using DC-06 functional. This performs both two-step and simultaneous update of the orbitals and cumulant using DIIS extrapolation. Four-virtual integrals are first handled in the MO Basis for the first two energy computations. In the next two the ao_basis=disk algorithm is used, where the transformation of integrals for four-virtual case is avoided. The computation is then repeated using the DC-12 functional with the same algorithms. mcscf2; TCSCF cc-pVDZ energy of asymmetrically displaced ozone, with Z-matrix input. dct6; DCT calculation for the triplet O2 using DC-06 and DC-12. Only two-step algorithm is tested. density-screen-2; RKS Density Matrix based-Integral Screening Test for benzene. psithon2; Accesses basis sets, databases, plugins, and executables in non-install locations. cc8a; ROHF-CCSD(T) cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Cartesian input. sapt-sf1; Tests the Psi4 SF-SAPT code. cbs-delta-energy; Extrapolated energies with delta correction. sapt-exch-ind-inf; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. dfmp2-freq2; DF-MP2 frequency by difference of energies for H2O. cc51; EOM-CC3/c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html:35641,energy,energy,35641,psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"mbj', 'd', 'd2', 'd3', 'd3m'}) – Flavor of a posteriori dispersion correction for which to load; parameters and call procedure in DFTD3. Must be a keys in; dashcoeff dict (or a key in dashalias that resolves to one).; dashparam (dict, optional) – Dictionary of the same keys as dashcoeff[dashlvl] used to; override any or all values initialized by; dashcoeff[dashlvl][func].; dertype ({None, 0, 'none', 'energy', 1, 'first', 'gradient'}, optional) – Maximum derivative level at which to run DFTD3. For large; mol, energy-only calculations can be significantly more; efficient. Also controls return values, see below.; verbose (bool, optional) – When True, additionally include DFTD3 output in output. Returns:; energy (float, optional) – When dertype is 0, energy [Eh].; gradient (list of lists of floats or psi4.core.Matrix, optional) – When dertype is 1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (float and list of lists of floats or psi4.core.Matrix, optional) – When dertype is unspecified, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; research site: https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/dft-d3; Psi4 mode: When psi4 the python module is importable at import qcdb. time, Psi4 mode is activated, with the following alterations:; * output goes to output file; * gradient returned as psi4.core.Matrix, not list o’lists; * scratch is written to randomly named subdirectory of psi scratch; * psivar “DISPERSION CORRECTION ENERGY” is set; * verbose triggered when PRINT keywork of SCF module >=3. run_gcp(func=None, dertype=None, verbose=False); Function to call Grimme’s dftd3 program (http://toc.uni-muenster.de/DFTD3/); to compute the -D correction of level dashlvl using parameters for; the functional func. The dictionary dashparam can be used to supply; a full set of dispersion parameters in the absense of func or to supply; individual overrides in the presence of func. Returns energy if dertype is 0,; gradient if dertype is 1, else tuple of energy and",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/api/psi4.core.molecule.html:49380,energy,energy,49380,psi4manual/1.2.1/api/psi4.core.molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/api/psi4.core.molecule.html,1,['energy'],['energy']
Energy Efficiency,"mbj', 'd', 'd2', 'd3', 'd3m'}) – Flavor of a posteriori dispersion correction for which to load; parameters and call procedure in DFTD3. Must be a keys in; dashcoeff dict (or a key in dashalias that resolves to one).; dashparam (dict, optional) – Dictionary of the same keys as dashcoeff[dashlvl] used to; override any or all values initialized by; dashcoeff[dashlvl][func].; dertype ({None, 0, 'none', 'energy', 1, 'first', 'gradient'}, optional) – Maximum derivative level at which to run DFTD3. For large; mol, energy-only calculations can be significantly more; efficient. Also controls return values, see below.; verbose (bool, optional) – When True, additionally include DFTD3 output in output. Returns:; energy (float, optional) – When dertype is 0, energy [Eh].; gradient (list of lists of floats or psi4.core.Matrix, optional) – When dertype is 1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (float and list of lists of floats or psi4.core.Matrix, optional) – When dertype is unspecified, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; research site: https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/dft-d3; Psi4 mode: When psi4 the python module is importable at import qcdb. time, Psi4 mode is activated, with the following alterations:; * output goes to output file; * gradient returned as psi4.core.Matrix, not list o’lists; * scratch is written to randomly named subdirectory of psi scratch; * psivar “DISPERSION CORRECTION ENERGY” is set; * verbose triggered when PRINT keywork of SCF module >=3. run_gcp(func=None, dertype=None, verbose=False)¶; Function to call Grimme’s dftd3 program (http://toc.uni-muenster.de/DFTD3/); to compute the -D correction of level dashlvl using parameters for; the functional func. The dictionary dashparam can be used to supply; a full set of dispersion parameters in the absense of func or to supply; individual overrides in the presence of func. Returns energy if dertype is 0,; gradient if dertype is 1, else tuple of energy an",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/psi4api-1.html:140375,energy,energy,140375,psi4manual/1.2.1/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html,3,['energy'],['energy']
Energy Efficiency,"mcc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | eom-cc3 | EOM-CC3 :ref:`[manual] <sec:eomcc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+. .. comment missing and why; .. comment a certain isapt --- marginally released; .. comment mrcc --- this is handled in its own table; .. comment psimrcc_scf --- convenience fn. .. include:: autodoc_dft_energy.rst. .. include:: mrcc_table_energy.rst. .. include:: cfour_table_energy.rst. :examples:. >>> # [1] Coupled-cluster singles and doubles calculation with psi code; >>> energy('ccsd'). >>> # [2] Charge-transfer SAPT calculation with scf projection from small into; >>> # requested basis, with specified projection fitting basis; >>> set basis_guess true; >>> set df_basis_guess jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). >>> # [3] Arbitrary-order MPn calculation; >>> energy('mp7'). >>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> # Note that the integral transformation is not done automatically when detci is run in a separate step.; >>> molecule H2 {\n0 1\nH\nH 1 0.74\n}; >>> set global basis cc-pVDZ; >>> set global reference rohf; >>> scf_e, scf_wfn = energy('scf', return_wfn = True); >>> H2.set_multiplicity(3); >>> psi4.MintsHelper(scf_wfn.basisset()).integrals(); >>> energy('detci', ref_wfn=scf_wfn). >>> # [5] Run two CI calculations, keeping the integrals generated in the first one.; >>> molecule ne {\nNe\n}; >>> set globals basis cc-pVDZ; >>> cisd_e, cisd_wfn = energy('cisd', return_wfn = True); >>> energy('fci', ref_wfn=cisd_wfn). >>> # [6] Can automatically perform complete basis set extrapolations; >>> energy(""MP2/cc-pV[DT]Z""). """"""; kwargs = p4util.kwargs_lower(kwargs). # Bounce if name is function; if hasattr(name, '__call__'):; return name(energy, kwargs.pop('label', 'custom functio",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver.html:27692,energy,energy,27692,psi4manual/1.0.0/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver.html,1,['energy'],['energy']
Energy Efficiency,"mdi = True; except ImportError:; pass. try:; from mpi4py import MPI; use_mpi4py = True; except ImportError:; use_mpi4py = False. class MDIEngine():; def __init__(self, scf_method: str, **kwargs):; """""" Initialize an MDIEngine object for communication with MDI (MolSSI driver interface). Parameters; ----------; scf_method; Method (SCF or post-SCF) used when calculating energies or gradients.; molecule; The target molecule, if not the last molecule defined.; kwargs; Any additional arguments to pass to :func:`psi4.driver.energy` or; :func:`psi4.driver.gradient` computation. """""". # Method used when the SCF command is received; self.scf_method = scf_method. # Additional arguments for energy, gradient, or optimization calculations; self.kwargs = kwargs. # Molecule all MDI operations are performed on; input_molecule = kwargs.pop('molecule', psi4.core.get_active_molecule()); self.molecule = input_molecule.clone(); psi4.core.set_active_molecule(self.molecule). # Most recent SCF energy; self.energy = 0.0. # Variables used when MDI sets a lattice of point charges; self.nlattice = 0 # number of lattice point charges; self.clattice = [] # list of lattice coordinates; self.lattice = [] # list of lattice charges; self.lattice_field = psi4.QMMMbohr() # Psi4 chargefield. # MPI variables; self.mpi_world = None; self.world_rank = 0. # Flag for if a lattice of point charges has been set; self.set_lattice = False. # Get correct intra-code MPI communicator; if use_mpi4py:; self.mpi_world = MDI_MPI_get_world_comm(); self.world_rank = self.mpi_world.Get_rank(). # Psi4 does not currently support multiple MPI ranks; if self.mpi_world.Get_size() != 1:; MPI.COMM_WORLD.Abort(). # Accept a communicator to the driver code; self.comm = MDI_Accept_Communicator(). # Ensure that the molecule is using c1 symmetry; self.molecule.reset_point_group('c1'); self.molecule.fix_orientation(True); self.molecule.fix_com(True); self.molecule.reinterpret_coordentry(False); self.molecule.update_geometry(). # Flag to ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/mdi_engine.html:2559,energy,energy,2559,psi4manual/1.7.x/_modules/psi4/driver/mdi_engine.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/mdi_engine.html,2,['energy'],['energy']
Energy Efficiency,"me += f""""""\n Beta Data\n""""""; cbsscheme += nppp(beta); cbsscheme += f""""""\n Extrapolated Data\n""""""; cbsscheme += nppp(np_value); cbsscheme += ""\n""; core.print_out(cbsscheme); logger.debug(cbsscheme). ## Build and set from numpy routines; #value = core.Matrix(*valueHI.shape); #value_view = np.asarray(value); #value_view[:] = np_value; #return value. return np_value. else:; raise ValidationError(f""scf_xtpl_helgaker_3: datatype is not recognized '{type(valueLO)}'.""). [docs]def corl_xtpl_helgaker_2(functionname: str, zLO: int, valueLO: Extrapolatable, zHI: int, valueHI: Extrapolatable, verbose: int = 1, alpha: Optional[float] = None) -> Extrapolatable:; r""""""Extrapolation scheme for correlation energies with two adjacent zeta-level bases.; Used by :py:func:`~psi4.driver.cbs`. Parameters; ----------; functionname; Name of the CBS component (e.g., 'MP2') used in summary printing.; zLO; Zeta number of the smaller basis set in 2-point extrapolation.; valueLO; Energy, gradient, or Hessian value at the smaller basis set in 2-point; extrapolation.; zHI; Zeta number of the larger basis set in 2-point extrapolation.; Must be `zLO + 1`.; valueHI; Energy, gradient, or Hessian value at the larger basis set in 2-point; extrapolation.; verbose; Controls volume of printing.; alpha; Overrides the default :math:`\alpha = 3.0`. Returns; -------; float or ~numpy.ndarray; Eponymous function applied to input zetas and values; type from `valueLO`. Notes; -----; The extrapolation is calculated according to [5]_:; :math:`E_{corl}^X = E_{corl}^{\infty} + \beta X^{-alpha}`. References; ----------. .. [5] Halkier, Helgaker, Jorgensen, Klopper, Koch, Olsen, & Wilson,; Chem. Phys. Lett. 286 (1998) 243-252,; DOI: 10.1016/S0009-2614(99)00179-7. Examples; --------; >>> # [1] CISD extrapolation; >>> energy('cbs', corl_wfn='cisd', corl_basis='cc-pV[DT]Z', corl_scheme='corl_xtpl_helgaker_2'). """"""; if type(valueLO) != type(valueHI):; raise ValidationError(; f""corl_xtpl_helgaker_2: Inputs must be of the same d",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_cbs_helper.html:18056,Energy,Energy,18056,psi4manual/1.7.x/_modules/psi4/driver/driver_cbs_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_cbs_helper.html,1,['Energy'],['Energy']
Energy Efficiency,"me += f""""""\n Extrapolated Data\n""""""; cbsscheme += nppp(value); cbsscheme += ""\n""; core.print_out(cbsscheme); logger.debug(cbsscheme). return value. else:; raise ValidationError(f""scf_xtpl_Karton_2: datatype is not recognized '{type(valueLO)}'.""). [docs]; def scf_xtpl_helgaker_3(functionname: str, zLO: int, valueLO: Extrapolatable, zMD: int, valueMD: Extrapolatable, zHI: int, valueHI: Extrapolatable, verbose: int = 1, alpha: Optional[float] = None) -> Extrapolatable:; r""""""Extrapolation scheme for reference energies with three adjacent zeta-level bases.; Used by :py:func:`~psi4.driver.cbs`. Parameters; ----------; functionname; Name of the CBS component (e.g., 'HF') used in summary printing.; zLO; Zeta number of the smaller basis set in 3-point extrapolation.; valueLO; Energy, gradient, or Hessian value at the smaller basis set in 3-point; extrapolation.; zMD; Zeta number of the medium basis set in 3-point extrapolation.; Must be `zLO + 1`.; valueMD; Energy, gradient, or Hessian value at the medium basis set in 3-point; extrapolation.; zHI; Zeta number of the larger basis set in 3-point extrapolation.; Must be `zLO + 2`.; valueHI; Energy, gradient, or Hessian value at the larger basis set in 3-point; extrapolation.; verbose; Controls volume of printing.; alpha; Not used. Returns; -------; float or ~numpy.ndarray; Eponymous function applied to input zetas and values; type from `valueLO`. Notes; -----; The extrapolation is calculated according to [4]_:; :math:`E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}, \alpha = 3.0`. References; ----------. .. [4] Halkier, Helgaker, Jorgensen, Klopper, & Olsen, Chem. Phys. Lett. 302 (1999) 437-446,; DOI: 10.1016/S0009-2614(99)00179-7. Examples; --------; >>> # [1] Hartree-Fock extrapolation; >>> psi4.energy('cbs', scf_wfn='hf', scf_basis='cc-pV[DTQ]Z', scf_scheme='scf_xtpl_helgaker_3'). """""". if (type(valueLO) != type(valueMD)) or (type(valueMD) != type(valueHI)):; raise ValidationError(; f""scf_xtpl_helgaker_3: Inputs must b",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html:14039,Energy,Energy,14039,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html,3,['Energy'],['Energy']
Energy Efficiency,"me = root + '.stats.dat' . # => Traverse <= #; PsiMod.set_global_option(""DF_INTS_IO"", ""SAVE""). Ns = []; energies = []; potentials = []; convs = []; stats = []. # Run one SCF to burn things in; energy('scf'). # Determine HOMO; ref = PsiMod.wavefunction(); eps_a = ref.epsilon_a(); eps_b = ref.epsilon_b(); if (Na == Nb):; HOMO = -Nb; elif (Nb == 0):; HOMO = Na; else:; E_a = eps_a[int(Na - 1)] ; E_b = eps_b[int(Nb - 1)] ; if (E_a >= E_b):; HOMO = Na; else: ; HOMO = -Nb. stats.append('\t%6d %6d %6d %6d %6d %6d\n' %(N, Na, Nb, charge, mult, HOMO)). if (HOMO > 0):; Na = Na - 1; else:; Nb = Nb - 1; charge = charge + 1; mult = Na - Nb + 1. PsiMod.set_global_option(""DF_INTS_IO"", ""LOAD""); PsiMod.set_global_option(""FRAC_START"", frac_start); PsiMod.set_global_option(""FRAC_RENORMALIZE"", True). # Nuke 'em Rico! ; for Nintegral in range(N,Nmin,-1):. # Nuke the current HOMO; for occ in foccs:. PsiMod.set_global_option(""FRAC_OCC"", [HOMO]); PsiMod.set_global_option(""FRAC_VAL"", [occ]) . E = energy('scf'); C = 1; if (E == 0.0):; E = PsiMod.get_variable('SCF ITERATION ENERGY'); C = 0. if (HOMO > 0):; ref = PsiMod.wavefunction(); eps = ref.epsilon_a(); potentials.append(eps[HOMO-1]); else:; ref = PsiMod.wavefunction(); eps = ref.epsilon_b(); potentials.append(eps[-HOMO-1]). Ns.append(Nintegral + occ - 1.0); energies.append(E); convs.append(C). PsiMod.set_global_option(""FRAC_START"", 2); PsiMod.set_global_option(""FRAC_LOAD"", True); PsiMod.set_global_option(""FRAC_DIIS"", frac_diis); PsiMod.set_global_option(""GUESS"", ""READ""). # Set the next charge/mult; mol.set_molecular_charge(charge) ; mol.set_multiplicity(mult). # Determine HOMO; ref = PsiMod.wavefunction(); eps_a = ref.epsilon_a(); eps_b = ref.epsilon_b(); if (Na == Nb):; HOMO = -Nb; elif (Nb == 0):; HOMO = Na; else:; E_a = eps_a[int(Na - 1)] ; E_b = eps_b[int(Nb - 1)] ; if (E_a >= E_b):; HOMO = Na; else: ; HOMO = -Nb. stats.append('\t%6d %6d %6d %6d %6d %6d\n' %(Nintegral-1, Na, Nb, charge, mult, HOMO)). if (HOMO > 0):; Na = Na - 1; else:",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/frac.html:8628,energy,energy,8628,psi4manual/4.0b4/_modules/frac.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/frac.html,2,['energy'],['energy']
Energy Efficiency,"me == 'fnocc-mp') and (level == 3):; emp3 = PsiMod.get_variable(""MP3 TOTAL ENERGY""); cemp3 = PsiMod.get_variable(""MP3 CORRELATION ENERGY""); PsiMod.set_variable(""CURRENT ENERGY"",emp3); PsiMod.set_variable(""CURRENT CORRELATION ENERGY"",cemp3); elif ( lowername == 'fno-mp3' ):; emp3 = PsiMod.get_variable(""MP3 TOTAL ENERGY""); cemp3 = PsiMod.get_variable(""MP3 CORRELATION ENERGY""); PsiMod.set_variable(""CURRENT ENERGY"",emp3); PsiMod.set_variable(""CURRENT CORRELATION ENERGY"",cemp3); elif ( lowername == 'mp4(sdq)'):; emp4sdq = PsiMod.get_variable(""MP4(SDQ) TOTAL ENERGY""); cemp4sdq = PsiMod.get_variable(""MP4(SDQ) CORRELATION ENERGY""); PsiMod.set_variable(""CURRENT ENERGY"",emp4sdq); PsiMod.set_variable(""CURRENT CORRELATION ENERGY"",cemp4sdq); elif ( lowername == 'fno-mp4(sdq)'):; emp4sdq = PsiMod.get_variable(""MP4(SDQ) TOTAL ENERGY""); cemp4sdq = PsiMod.get_variable(""MP4(SDQ) CORRELATION ENERGY""); PsiMod.set_variable(""CURRENT ENERGY"",emp4sdq); PsiMod.set_variable(""CURRENT CORRELATION ENERGY"",cemp4sdq); elif ( lowername == 'fno-mp4'):; emp4 = PsiMod.get_variable(""MP4 TOTAL ENERGY""); cemp4 = PsiMod.get_variable(""MP4 CORRELATION ENERGY""); PsiMod.set_variable(""CURRENT ENERGY"",emp4); PsiMod.set_variable(""CURRENT CORRELATION ENERGY"",cemp4); elif (lowername == 'fnocc-mp') and (level == 4):; emp4 = PsiMod.get_variable(""MP4 TOTAL ENERGY""); cemp4 = PsiMod.get_variable(""MP4 CORRELATION ENERGY""); PsiMod.set_variable(""CURRENT ENERGY"",emp4); PsiMod.set_variable(""CURRENT CORRELATION ENERGY"",cemp4). # restore symmetry for fno-cc; if (PsiMod.get_option('FNOCC','NAT_ORBS')):; molecule.reset_point_group(user_pg); molecule.update_geometry(). # restore options; optstash.restore(). return PsiMod.get_variable(""CURRENT ENERGY""). [docs]def run_cepa(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a cepa-like calculation. >>> energy('cepa(1)'). """"""; lowername = name.lower(); uppername = name.upper(); kwargs = kwargs_lower(kwargs). # save user options; optstash = OptionsState(; ['TRA",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/proc.html:75368,ENERGY,ENERGY,75368,psi4manual/4.0b4/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/proc.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"me methods and the default routing is not suitable, this targets a module. CCENERGY covers CCHBAR, etc. OCC covers OCC and DFOCC. Type: string; Possible Values: CCENERGY, DETCI, DFMP2, FNOCC, OCC, ADCC, CCT3; Default: No Default. QC_TYPE (DCT)¶DCT — Controls the type of the quadratically-convergent algorithm (effective for ALGORITHM = QC). If set to TWOSTEP the Newton-Raphson equations are only solved for the orbital updates, the cumulant is updated using the standard Jacobi algorithm. If set to SIMULTANEOUS both cumulant and orbitals are updated in a single Newton-Raphson step. Type: string; Possible Values: TWOSTEP, SIMULTANEOUS; Default: SIMULTANEOUS. QCHF (DFOCC)¶DFOCC — Do perform a QCHF computation?. Type: boolean; Default: false. QCHF (SCF)¶SCF — Do perform a QCHF computation?. Type: boolean; Default: false. QMEFP (EFP)¶EFP (Expert) — Do turn on QM/EFP terms?. Type: boolean; Default: false. R4S (DETCI)¶DETCI (Expert) — Do restrict strings with \(e-\) in RAS IV? Useful to reduce the number of strings required if MIXED4=true, as in a split-virutal CISD[TQ] computation. If more than one electron is in RAS IV, then the holes in RAS I cannot exceed the number of particles in RAS III + RAS IV (i.e., EX_LEVEL), or else the string is discarded. Type: boolean; Default: false. R_CONVERGENCE (ADC)¶ADC — Convergence threshold for ADC matrix diagonalisation. Negative values keep the * adcc default (1e-6). Type: conv double; Default: -1. R_CONVERGENCE (CCENERGY)¶CCENERGY — Convergence criterion for wavefunction (change) in CC amplitude equations. Type: conv double; Default: 1e-7. R_CONVERGENCE (CCEOM)¶CCEOM — Convergence criterion for norm of the residual vector in the Davidson algorithm for CC-EOM. Type: conv double; Default: 1e-6. R_CONVERGENCE (CCLAMBDA)¶CCLAMBDA — Convergence criterion for wavefunction (change) in CC lambda-amplitude equations. Type: conv double; Default: 1e-7. R_CONVERGENCE (CCRESPONSE)¶CCRESPONSE — Convergence criterion for wavefunction (change) in p",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html:195441,reduce,reduce,195441,psi4manual/1.4.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html,4,['reduce'],['reduce']
Energy Efficiency,"me of the keyword.; Any of the above keyword specifications can be scoped to individual modules,; by adding the name of the module after the set keyword. Omitting the module; name, or using the name global or globals will result in the keyword being; applied to all modules. For example, in the following input; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13molecule{; o; h 1 roh; h 1 roh 2 ahoh. roh = 0.957; ahoh = 104.5; }. set basis cc-pVDZ; set ccenergy print 3; set scf print 1; energy('ccsd'). the basis set is set to cc-pVDZ throughout, the SCF code will have a print; level of 1 and the ccenergy code, which performs coupled cluster computations,; will use a print level of 3. In this example a full CCSD computation is; performed by running the SCF code first, then the coupled cluster modules;; the energy() Python helper function ensures that this is performed correctly.; Note that the Python interpreter executes commands in the order they appear in; the input file, so if the last four commands in the above example were to read; 1; 2; 3; 4set basis cc-pVDZ; energy('ccsd'); set ccenergy print 3; set scf print 1. the commands that set the print level would be ineffective, as they would be; processed after the CCSD computation completes.; In PsiAPI mode, one can use commands set_options() and; set_module_options() like below. Note that these values; should be of correct type, strings for strings, floats for floats like; convergences. The function ~psi4.core.clean_options that reinitializes; all options may also be useful to separate calculations in a PsiAPI; session.; 1; 2; 3; 4; 5; 6; 7; 8; 9psi4.set_options({; 'scf_type': 'pk',; 'e_convergence': 1.e-5,; 'soscf': True; }). psi4.set_module_options({; 'geom_maxiter': 50; }). Basis Sets¶. Basis Sets; Built-In Basis Sets; Mixing Basis Sets; Decontracted Basis Sets; User-Defined Basis Sets. PSI Variables¶; To harness the power of Python, PSI4 makes the most pertinent results; of each computation available to the Python interpret",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psithoninput-1.html:7625,energy,energy,7625,psi4manual/1.1.0/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psithoninput-1.html,2,['energy'],['energy']
Energy Efficiency,"me of the keyword.; Any of the above keyword specifications can be scoped to individual modules,; by adding the name of the module after the set keyword. Omitting the module; name, or using the name global or globals will result in the keyword being; applied to all modules. For example, in the following input; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13molecule{; o; h 1 roh; h 1 roh 2 ahoh. roh = 0.957; ahoh = 104.5; }. set basis cc-pVDZ; set ccenergy print 3; set scf print 1; energy('ccsd'). the basis set is set to cc-pVDZ throughout, the SCF code will have a print; level of 1 and the ccenergy code, which performs coupled cluster computations,; will use a print level of 3. In this example a full CCSD computation is; performed by running the SCF code first, then the coupled cluster modules;; the energy() Python helper function ensures that this is performed correctly.; Note that the Python interpreter executes commands in the order they appear in; the input file, so if the last four commands in the above example were to read; 1; 2; 3; 4set basis cc-pVDZ; energy('ccsd'); set ccenergy print 3; set scf print 1. the commands that set the print level would be ineffective, as they would be; processed after the CCSD computation completes.; In PsiAPI mode, one can use commands set_options() and; set_module_options() like below. Note that these values; should be of correct type, strings for strings, floats for floats like; convergences. The function ~psi4.core.clean_options that reinitializes; all options may also be useful to separate calculations in a PsiAPI; session.; 1; 2; 3; 4; 5; 6; 7; 8; 9psi4.set_options({; 'scf_type': 'pk',; 'e_convergence': 1.e-5,; 'soscf': True; }). psi4.set_module_options({; 'geom_maxiter': 50; }). Basis Sets¶. Basis Sets; Built-In Basis Sets; Mixing Basis Sets; Decontracted Basis Sets; User-Defined Basis Sets; Inputting effective core potentials (ECPs). PSI Variables¶; To harness the power of Python, PSI4 makes the most pertinent results; of each c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html:8433,energy,energy,8433,psi4manual/1.2.1/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html,4,['energy'],['energy']
Energy Efficiency,"me reversal symmetry. For very small block sizes, this could conceivably eliminate the entire H0 block; the program should print warnings if this occurs. Type: integer; Default: 1000. H0_BLOCK_COUPLING¶. Do use coupling block in preconditioner?. Type: boolean; Default: false. H0_BLOCK_COUPLING_SIZE¶. Parameters which specifies the size of the coupling block within the generalized davidson preconditioner. Type: integer; Default: 0. H0_GUESS_SIZE¶. size of H0 block for initial guess. Type: integer; Default: 1000. HD_AVG¶. How to average H diag energies over spin coupling sets. HD_EXACT uses the exact diagonal energies which results in expansion vectors which break spin symmetry. HD_KAVE averages the diagonal energies over a spin-coupling set yielding spin pure expansion vectors. ORB_ENER employs the sum of orbital energy approximation giving spin pure expansion vectors but usually doubles the number of Davidson iterations. EVANGELISTI uses the sums and differences of orbital energies with the SCF reference energy to produce spin pure expansion vectors. LEININGER approximation which subtracts the one-electron contribution from the orbital energies, multiplies by 0.5, and adds the one-electron contribution back in, producing spin pure expansion vectors and developed by Matt Leininger and works as well as EVANGELISTI. Type: string; Possible Values: EVANGELISTI, HD_EXACT, HD_KAVE, ORB_ENER, LEININGER, Z_KAVE; Default: EVANGELISTI. Expert Density Matrices¶. TPDM¶. Do compute two-particle density matrix if not otherwise required? Warning: This will hold 4 dense active TPDM’s in memory. Type: boolean; Default: false. Expert Root Following¶. FOLLOW_VECTOR¶. In following a particular root (see FOLLOW_ROOT , sometimes the root number changes. To follow a root of a particular character, one can specify a list of determinants and their coefficients, and the code will follow the root with the closest overlap. The user specifies arrays containing the absolute alpha string indices (",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__detci-1.html:15233,energy,energy,15233,psi4manual/1.3.2/autodir_options_c/module__detci-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__detci-1.html,26,['energy'],['energy']
Energy Efficiency,"me to code completion. We are very interested in optimizing; and extending the code, so expect performance gains and extensions to; gradients/hessians and TDDFT in future releases.; Some rough guidelines for using the KS-DFT code are as follows,. Use DF for the ERI algorithm wherever possible.; PSI4 is a “tight” code, meaning we’ve set the default numerical cutoffs; for integrals, grids, and convergence criteria in such a way that you will often; get many more digits of precision than needed. You may be able to realize; additional speed gains by loosening some of these thresholds. See; SCF Convergence for default convergence criteria.; Read the literature to determine which functional technology to use. The world; contains far too many papers using B3LYP on noncovalent interactions without a -D. The “best-practice” input file for KS-DFT is:; memory 1 GB # As much as you've got, the DF algorithm can use. molecule {; H; H 1 0.7; }. set {; basis cc-pvdz; scf_type df; guess sad; }. energy('b3lyp'). Advanced Functional Use and Manipulation¶; New DFT functionals can be created from scratch from within the input; file and accessed using the dft_functional keyword argument in the; energy call:; # DFT Custom Functional. molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; basis sto-3g; dft_spherical_points 302; dft_radial_points 99; reference rks; }. pbe0 = {; ""name"": ""my_PBE0"",; ""x_functionals"": {""GGA_X_PBE"": {""alpha"": 0.75}},; ""x_hf"": {""alpha"": 0.25},; ""c_functionals"": {""GGA_C_PBE"": {}}; }. func_call = energy('SCF', dft_functional=pbe0). # as PBE0 is a pre-defined functional, the call above is equivalent to both below:; func_call = energy('SCF', dft_functional=""PBE0""); func_call = energy('PBE0'). Supported keywords include:. name: string, name of the functional. for custom defined functionals used for printing only.; xc_functionals: dict, definition of a complete (X + C) functional based in LibXC name; x_functionals: dict, definition of exchange functionals using Lib",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/dft-1.html:28702,energy,energy,28702,psi4manual/1.4.0/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/dft-1.html,9,['energy'],['energy']
Energy Efficiency,"me'] = corl_xtpl_helgaker_2. if not ('delta_wfn' in kwargs):; kwargs['delta_wfn'] = 'ccsd(t)'; if not ('delta_wfn_lesser' in kwargs):; kwargs['delta_wfn_lesser'] = 'mp2'; if not ('delta_basis' in kwargs):; kwargs['delta_basis'] = 'aug-cc-pVTZ'; if not ('delta_scheme' in kwargs):; kwargs['delta_scheme'] = highest_1. return cbs(name, **kwargs). #def run_mp2_5(name, **kwargs):; # r""""""Function that computes MP2.5 energy from results of a FNOCC; # MP3 calculation.; #; # .. math:: E_{total}^{\text{MP2.5}} = E_{total,\; \text{SCF}} \; + E_{corl,\; \text{MP2}} + E_{corl, \; \text{MP3}}; #; # :PSI variables: ; #; # .. hlist:: ; # :columns: 1 ; # ; # * :psivar:`MP2.5 TOTAL ENERGY <MP2.5TOTALENERGY>` ; # * :psivar:`MP2.5 CORRELATION ENERGY <MP2.5CORRELATIONENERGY>` ; #; # >>> energy('mp2.5'); #; # """"""; # lowername = name.lower(); # kwargs = kwargs_lower(kwargs); #; # # Run detci calculation and collect conventional quantities; # energy('mp3', **kwargs); # e_scf = PsiMod.get_variable('SCF TOTAL ENERGY'); # ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); # ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'); # e_mp2 = e_scf + ce_mp2; # e_mp3 = e_scf + ce_mp3; #; # # Compute quantities particular to MP2.5; # ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); # e_mp25 = e_scf + ce_mp25; # PsiMod.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25); # PsiMod.set_variable('MP2.5 TOTAL ENERGY', e_mp25); # PsiMod.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); # PsiMod.set_variable('CURRENT ENERGY', e_mp25); #; # # build string of title banner and print results; # banners = ''; # banners += """"""PsiMod.print_out('\\n')\n""""""; # banners += """"""banner(' MP2.5 ')\n""""""; # banners += """"""PsiMod.print_out('\\n')\n\n""""""; # exec(banners); #; # tables = ''; # tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); # tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); # tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); # tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); # tables += """"""",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/aliases.html:2804,ENERGY,ENERGY,2804,psi4manual/4.0b4/_modules/aliases.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/aliases.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"me)[source]¶. fetch_sect(name)[source]¶. find_sect(path)[source]¶. get(k)[source]¶. get_keys()[source]¶. get_keyword(path)[source]¶. get_sects()[source]¶. getkw(path)[source]¶. is_required()[source]¶. is_set(key=None)[source]¶. run_callbacks(templ)[source]¶. sanitize(templ)[source]¶. sanity_check(path=None)[source]¶. set(k, val)[source]¶. set_status(set)[source]¶. setkw(name, arg)[source]¶. status()[source]¶. xvalidate(templ, path=None)[source]¶. check_ignored(list, sect)[source]¶. check_opt(sect, key)[source]¶. check_required(list, sect)[source]¶. parse_error(s, t, d, err)[source]¶. test(strng)[source]¶. wrappers¶; Module with functions that call the four main driver; functions: driver.energy, driver.optimize,; driver.response, and driver.frequency. auto_fragments(name, **kwargs)[source]¶; Detects fragments if the user does not supply them.; Currently only used for the WebMO implementation of SAPT; usage: auto_fragments(‘’). call_function_in_1st_argument(funcarg, **largs)[source]¶; Function to make primary function call to energy(), opt(), etc.; with options dictionary largs.; Useful when funcarg to call is stored in variable. convert(p, symbol)[source]¶. reconstitute_bracketed_basis(needarray)[source]¶; Function to reform a bracketed basis set string from a sequential series; of basis sets (e.g, form ‘cc-pv[q5]z’ from array [cc-pvqz, cc-pv5z]). The; basis set array is extracted from the f_basis field of a NEED dictionary in; complete_basis_set(). Result is used to print a nicely; formatted basis set string in the results table. split_menial(menial)[source]¶; Function used by complete_basis_set() to separate; menial ‘scftot’ into [scf, tot] and ‘mp2corl’ into [mp2, corl]. tblhead(tbl_maxrgt, tbl_delimit, ttype)[source]¶; Function that prints the header for the changable-width results tables in db().; tbl_maxrgt is the number of reagent columns the table must plan for. tbl_delimit; is a string of dashes of the correct length to set off the table. ttype is 1 for; tab",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodoc_driver-1.html:17363,energy,energy,17363,psi4manual/4.0b5/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodoc_driver-1.html,2,['energy'],['energy']
Energy Efficiency,"me, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp3_gradient(name, **kwargs):; """"""Function selecting the algorithm for an OMP3 gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError(['select_omp3_gradient', name, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp2p5(name, **kwargs):; """"""Function selecting the algorithm for a MP2.5 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP_TYPE') if core.has_global_option_changed(""MP_TYPE"") else ""DF""; module = core.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError(['select_mp2p5', name, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp2p5_gradient(name, **kwargs):; """"""Function selecting the algorithm for a MP2.5 gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP_TYPE') if core.has_global_option_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:14418,energy,energy,14418,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,6,['energy'],['energy']
Energy Efficiency,"me, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp3_gradient(name, **kwargs):; """"""Function selecting the algorithm for an OMP3 gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError(['select_omp3_gradient', name, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp2p5(name, **kwargs):; """"""Function selecting the algorithm for a MP2.5 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError(['select_mp2p5', name, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp2p5_gradient(name, **kwargs):; """"""Function selecting the algorithm for a MP2.5 gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only [df]occ. func =",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html:11547,energy,energy,11547,psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,3,['energy'],['energy']
Energy Efficiency,"me, molecule, findif_meta_dict[""reference""], 1, ndisp,; **kwargs); var_dict = core.variables(). for n, displacement in enumerate(findif_meta_dict[""displacements""].values(), start=2):; _process_displacement(; energy, lowername, molecule, displacement, n, ndisp, write_orbitals=False, **kwargs). # Reset variables; for key, val in var_dict.items():; core.set_variable(key, val). # Compute the gradient; core.set_local_option('FINDIF', 'GRADIENT_WRITE', True); G = driver_findif.compute_gradient_from_energies(findif_meta_dict); grad_psi_matrix = core.Matrix.from_array(G); grad_psi_matrix.print_out(); wfn.set_gradient(grad_psi_matrix). # Explicitly set the current energy..; core.set_variable('CURRENT ENERGY', findif_meta_dict[""reference""][""energy""]). optstash.restore(). if core.get_option('FINDIF', 'GRADIENT_WRITE'):; filename = core.get_writer_file_prefix(wfn.molecule().name()) + "".grad""; qcdb.gradparse.to_string(np.asarray(wfn.gradient()), filename, dtype='GRD', mol=molecule, energy=wfn.energy()). if return_wfn:; return (wfn.gradient(), wfn); else:; return wfn.gradient(). [docs]def properties(*args, **kwargs):; r""""""Function to compute various properties. :aliases: prop(). :returns: none. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - This function at present has a limited functionality.; Consult the keywords sections of other modules for further property capabilities. +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | Name | Calls Method | Reference | Supported Properties |; +====================+===============================================+================+===============================================================+; | scf | Self-consistent field method(s) | RHF/ROHF/UHF | Listed :ref:`here <sec:oeprop>` |; +--------------------+-----------------------------------------------+----------------+--------------------------------------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html:42374,energy,energy,42374,psi4manual/1.3.2/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html,1,['energy'],['energy']
Energy Efficiency,"me, npoints, deriv):. # Call this first; sup = PsiMod.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('DSD-PBEP86'); # Tab in, trailing newlines; sup.set_description(' DSD-PBEP86 Dispersion-corrected SCS Double Hybrid XC Functional (opt. for -D2)\n'); # Tab in, trailing newlines; sup.set_citation(' S. Kozuch, Phys. Chem. Chem. Phys., 13, 20104, 2011\n'). # Add member functionals; X = build_functional('PBE_X'); X.set_alpha(1.0); sup.add_x_functional(X); C = build_functional('P86_C'); C.set_alpha(0.45); sup.add_c_functional(C). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.68); sup.set_c_alpha(1.0); sup.set_c_ss_alpha(0.23); sup.set_c_os_alpha(0.51). # => -D2 <=. sup.set_dispersion(PsiMod.Dispersion.build(*dash_server('dsd-pbep86', 'd2p4'))). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_dsd_pbepbe_superfunctional(name, npoints, deriv):. # Call this first; sup = PsiMod.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('DSD-PBEPBE'); # Tab in, trailing newlines; sup.set_description(' DSD-PBEPBE Dispersion-corrected SCS Double Hybrid XC Functional\n'); # Tab in, trailing newlines; sup.set_citation(' S. Kozuch, Phys. Chem. Chem. Phys., 13, 20104, 2011\n'). # Add member functionals; X = build_functional('PBE_X'); X.set_alpha(1.0); sup.add_x_functional(X); C = build_functional('PBE_C'); C.set_alpha(0.51); sup.add_c_functional(C). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.66); sup.set_c_alpha(1.0); sup.set_c_ss_alpha(0.12); sup.set_c_os_alpha(0.53). # => -D2 <=. sup.set_dispersion(PsiMod.Dispersion.build(*dash_server('dsd-pbepbe', 'd2p4'))). # => End User-Customizati",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/functional.html:76247,allocate,allocate,76247,psi4manual/4.0b4/_modules/functional.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/functional.html,2,['allocate'],['allocate']
Energy Efficiency,"me, return_wfn=True, molecule=moleculeclone, **kwargs); energies.append(core.get_variable('CURRENT ENERGY')). # clean may be necessary when changing irreps of displacements; core.clean(). # S/R: Write each displaced geometry to an input file; elif freq_mode == 'sow':; moleculeclone.set_geometry(displacement). # S/R: Prepare molecule, options, kwargs, function call and energy save; with open('%s.in' % (rfile), 'wb') as freagent:; freagent.write('# This is a psi4 input file auto-generated from the gradient() wrapper.\n\n'); freagent.write(p4util.format_molecule_for_input(moleculeclone, forcexyz=True).encode('utf-8')); freagent.write(p4util.format_options_for_input(moleculeclone, **kwargs).encode('utf-8')); p4util.format_kwargs_for_input(freagent, **kwargs); freagent.write(""""""electronic_energy = %s('%s', **kwargs)\n\n"""""" % (energy.__name__, lowername)); freagent.write(""""""core.print_out('\\nHESSIAN RESULT: computation %d for item %d """""" % (os.getpid(), n + 1)); freagent.write(""""""yields electronic energy %20.12f\\n' % (electronic_energy))\n\n""""""). # S/R: Read energy from each displaced geometry output file and save in energies array; elif freq_mode == 'reap':; exec(banners); core.set_variable('NUCLEAR REPULSION ENERGY', moleculeclone.nuclear_repulsion_energy()); energies.append(p4util.extract_sowreap_from_output(rfile, 'HESSIAN', n, freq_linkage, True)). # S/R: Quit sow after writing files. Initialize skeleton wfn to receive grad for reap; if freq_mode == 'sow':; optstash.restore(); optstash_conv.restore(); if return_wfn:; return (None, None); else:; return None; elif freq_mode == 'reap':; # core.set_variable('CURRENT ENERGY', energies[-1]); wfn = core.Wavefunction.build(molecule, core.get_global_option('BASIS')). # Assemble Hessian from energies; H = core.fd_freq_0(molecule, energies, irrep); wfn.set_hessian(H); wfn.set_frequencies(core.get_frequencies()). # The last item in the list is the reference energy, return it; core.set_variable('CURRENT ENERGY', energies[-1]). ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html:79497,energy,energy,79497,psi4manual/1.1.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html,1,['energy'],['energy']
Energy Efficiency,"me, return_wfn=True, molecule=moleculeclone, **kwargs); energies.append(core.get_variable('CURRENT ENERGY')). # clean may be necessary when changing irreps of displacements; core.clean(). # S/R: Write each displaced geometry to an input file; elif freq_mode == 'sow':; moleculeclone.set_geometry(displacement). # S/R: Prepare molecule, options, kwargs, function call and energy save; with open('%s.in' % (rfile), 'wb') as freagent:; freagent.write('# This is a psi4 input file auto-generated from the gradient() wrapper.\n\n'); freagent.write(p4util.format_molecule_for_input(moleculeclone, forcexyz=True).encode('utf-8')); freagent.write(p4util.format_options_for_input(moleculeclone, **kwargs).encode('utf-8')); p4util.format_kwargs_for_input(freagent, **kwargs); freagent.write(""""""electronic_energy = %s('%s', **kwargs)\n\n"""""" % (energy.__name__, lowername)); freagent.write(""""""core.print_out('\\nHESSIAN RESULT: computation %d for item %d """""" % (os.getpid(), n + 1)); freagent.write(""""""yields electronic energy %20.12f\\n' % (electronic_energy))\n\n""""""). # S/R: Read energy from each displaced geometry output file and save in energies array; elif freq_mode == 'reap':; exec(banners); core.set_variable('NUCLEAR REPULSION ENERGY', moleculeclone.nuclear_repulsion_energy()); energies.append(p4util.extract_sowreap_from_output(rfile, 'HESSIAN', n, freq_linkage, True)). # S/R: Quit sow after writing files. Initialize skeleton wfn to receive grad for reap; if freq_mode == 'sow':; optstash.restore(); optstash_conv.restore(); if return_wfn:; return (None, None); else:; return None; elif freq_mode == 'reap':; # core.set_variable('CURRENT ENERGY', energies[-1]); wfn = core.Wavefunction.build(molecule, core.get_global_option('BASIS')). # Assemble Hessian from energies; H = core.fd_freq_0(molecule, energies, irrep); wfn.set_hessian(H); wfn.set_gradient(G0); wfn.set_frequencies(core.get_frequencies()). # The last item in the list is the reference energy, return it; core.set_variable('CURRENT EN",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html:83048,energy,energy,83048,psi4manual/1.2.1/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html,1,['energy'],['energy']
Energy Efficiency,"me, return_wfn=True, molecule=moleculeclone, **kwargs); energies.append(psi4.get_variable('CURRENT ENERGY')). # clean may be necessary when changing irreps of displacements; psi4.clean(). # S/R: Write each displaced geometry to an input file; elif freq_mode == 'sow':; moleculeclone.set_geometry(displacement). # S/R: Prepare molecule, options, kwargs, function call and energy save; with open('%s.in' % (rfile), 'wb') as freagent:; freagent.write('# This is a psi4 input file auto-generated from the gradient() wrapper.\n\n'); freagent.write(p4util.format_molecule_for_input(moleculeclone, forcexyz=True).encode('utf-8')); freagent.write(p4util.format_options_for_input(moleculeclone, **kwargs).encode('utf-8')); p4util.format_kwargs_for_input(freagent, **kwargs); freagent.write(""""""electronic_energy = %s('%s', **kwargs)\n\n"""""" % (energy.__name__, lowername)); freagent.write(""""""psi4.print_out('\\nHESSIAN RESULT: computation %d for item %d """""" % (os.getpid(), n + 1)); freagent.write(""""""yields electronic energy %20.12f\\n' % (electronic_energy))\n\n""""""). # S/R: Read energy from each displaced geometry output file and save in energies array; elif freq_mode == 'reap':; exec(banners); psi4.set_variable('NUCLEAR REPULSION ENERGY', moleculeclone.nuclear_repulsion_energy()); energies.append(p4util.extract_sowreap_from_output(rfile, 'HESSIAN', n, freq_linkage, True)). # S/R: Quit sow after writing files. Initialize skeleton wfn to receive grad for reap; if freq_mode == 'sow':; optstash.restore(); optstash_conv.restore(); if return_wfn:; return (None, None); else:; return None; elif freq_mode == 'reap':; # psi4.set_variable('CURRENT ENERGY', energies[-1]); wfn = psi4.new_wavefunction(molecule, psi4.get_global_option('BASIS')). # Assemble Hessian from energies; H = psi4.fd_freq_0(molecule, energies, irrep); wfn.set_hessian(H); wfn.set_frequencies(psi4.get_frequencies()). # The last item in the list is the reference energy, return it; psi4.set_variable('CURRENT ENERGY', energies[-1]). ps",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver.html:77515,energy,energy,77515,psi4manual/1.0.0/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver.html,1,['energy'],['energy']
Energy Efficiency,"me, str(dertype), alternatives)). return dertype. def _energy_is_invariant(gradient, stationary_criterion=1.e-2):; """"""Polls options and probes `gradient` to return whether current method; and system expected to be invariant to translations and rotations of; the coordinate system. """"""; stationary_point = gradient.rms() < stationary_criterion # 1.e-2 pulled out of a hat. efp = core.get_active_efp(); efp_present = efp.nfragments() > 0. translations_projection_sound = (not core.get_option('SCF', 'EXTERN') and; not core.get_option('SCF', 'PERTURB_H') and; not efp_present); rotations_projection_sound = (translations_projection_sound and; stationary_point). return translations_projection_sound, rotations_projection_sound. [docs]def energy(name, **kwargs):; r""""""Function to compute the single-point electronic energy. :returns: *float* |w--w| Total electronic energy in Hartrees. SAPT & EFP return interaction energy. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY <CURRENTENERGY>`; * :psivar:`CURRENT REFERENCE ENERGY <CURRENTREFERENCEENERGY>`; * :psivar:`CURRENT CORRELATION ENERGY <CURRENTCORRELATIONENERGY>`. :type name: string; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple. :type restart_file: string; :param restart_file: ``['file.1, file.32]`` || ``./file`` || etc. Binary data files to be renamed for calculation restart. .. _`table:energy_gen`:. +--",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html:4891,energy,energy,4891,psi4manual/1.2.1/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html,1,['energy'],['energy']
Energy Efficiency,"me='scf' and scf_basis; keywords to be specified for reference-step only jobs and name and; corl_basis keywords for correlated jobs.; The following energy methods have been set up for cbs(). scf; mp2; mp2.5; mp3; mp4(sdq); mp4. omp2; omp3; ocepa; cepa0; cepa(0); cepa(1). cepa(3); acpf; aqcc; qcisd; cc2; ccsd. fno-df-ccsd; bccd; cc3; qcisd(t); ccsd(t); fno-df-ccsd(t). bccd(t); cisd; cisdt; cisdtq; cin; fci. Parameters:; name (string) – 'scf' || 'ccsd' || etc.; First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be 'scf'. Overruled if stage_wfn keywords supplied. corl_wfn (string) – 'mp2' || 'ccsd(t)' || etc.; Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with name or as the unlabeled; first argument to the function. delta_wfn (string) – 'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. delta_wfn_lesser (string) – 'mp2' || 'ccsd' || etc.; Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. delta2_wfn (string) – 'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. delta2_wfn_lesser (string) – 'mp2' || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. Basis Sets; Currently, the basis set set through set commands have no influence; on a cbs calculation. Parameters:; scf_basis (basis string) – corl_basis || 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, scf_basis can default; to corl_basis. corl_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/cbs-1.html:3319,energy,energy,3319,psi4manual/4.0b4/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/cbs-1.html,4,['energy'],['energy']
Energy Efficiency,"me_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 2):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'corl', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'corl', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy']; zHI = NEED['HI']['f_zeta']; eLO = NEED['LO']['f_energy']; zLO = NEED['LO']['f_zeta']. # Compute extrapolated energy; energypiece = (eHI * zHI ** 3 - eLO * zLO ** 3) / (zHI ** 3 - zLO ** 3); beta = (eHI - eLO) / (zHI ** (-3) - zLO ** (-3)). # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); PsiMod.print_out(cbsscheme). return energypiece. [docs]def scf_xtpl_helgaker_3(**largs):; r""""""Extrapolation scheme for reference energies with three adjacent zeta-level bases.; Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 3):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnn",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:80303,Energy,Energy,80303,psi4manual/4.0b2/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html,3,['Energy'],['Energy']
Energy Efficiency,"me_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 2):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'corl', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'corl', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy']; zHI = NEED['HI']['f_zeta']; eLO = NEED['LO']['f_energy']; zLO = NEED['LO']['f_zeta']. # Compute extrapolated energy; energypiece = (eHI * zHI ** 3 - eLO * zLO ** 3) / (zHI ** 3 - zLO ** 3); beta = (eHI - eLO) / (zHI ** (-3) - zLO ** (-3)). # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); psi4.print_out(cbsscheme). return energypiece. [docs]def scf_xtpl_helgaker_3(**largs):; r""""""Extrapolation scheme for reference energies with three adjacent zeta-level bases.; Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 3):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnnam",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:96084,Energy,Energy,96084,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,1,['Energy'],['Energy']
Energy Efficiency,"med in terms of three-center; two-electron integrals [Lehtola:2020:144105]. The potential in; the SAPGAU scheme is passed with the SAPGAU_BASIS; keyword. The default potential is given by the large fit to the; HelFEM potential, sap_helfem_large, described in; [Lehtola:2020:144105]. Note that this guess is known in the DIRAC; program as .SCRPOT and in the ERKALE program as SAPFIT. These are all set by the GUESS keyword. Also, an automatic Python; procedure has been developed for converging the SCF in a small basis, and then; casting up to the true basis. This can be done by adding; BASIS_GUESS = SMALL_BASIS to the options list. We recommend the; 3-21G or pcseg-0 basis for the small basis due to its efficient mix of flexibility and; compactness. An example of performing an RHF solution of water by SAD guessing; in a 3-21G basis and then casting up to cc-pVTZ is shown below:; molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; basis cc-pvtz; basis_guess 3-21G; guess sad; }. energy('scf'). Restarting the SCF¶; Reading orbital data from a previous calculations is done via the restart_file option,; where the actual file is a serialized wfn object (see saving the wfn); By default, the orbital data file of the converged SCF(psi.PID.name.180.npy) is deleted; after PSI4 exits or the clean() function is called. The orbital guess is automatically; set to READ when restart_file is given a wfn file.; To write the orbitals after every iteration and keep the orbitals from the last iteration, the write_orbitals options is available:; energy('scf', write_orbitals='my_mos'),. which writes a Wavefunction object converted (serialized) to a numpy file called my_mos.npy.; The restart can then be done as follows:; energy('scf', restart_file='my_mos'). Specifying the .npy suffix when writing and reading restart files is optional.; Alternatively, the restart can also be done from any previously saved wfn object.; energy, scf_wfn = energy('scf',return_wfn=True); scf_wfn.to_file('my_wfn",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/scf.html:20375,energy,energy,20375,psi4manual/1.8.x/scf.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/scf.html,3,['energy'],['energy']
Energy Efficiency,"med to the MO basis; to use with this function. New in version 0.5: wfn parameter passed explicitly. Returns:None. Parameters:; wfn (Wavefunction) – set of molecule, basis, orbitals from which to generate cube files; filename (string) – destination file name for MOLDEN file (optional); density_a (Matrix) – density in the MO basis to build alpha NO’s from (optional); density_b (Matrix) – density in the MO basis to build beta NO’s from, assumes restricted if not supplied (optional); dovirtual (bool) – do write all the MOs to the MOLDEN file (true) or discard the unoccupied MOs, not valid for NO’s (false) (optional). Examples:. >>> # [1] Molden file for DFT calculation; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> molden(wfn, 'mycalc.molden'). >>> # [2] Molden file for CI/MCSCF computation using NO roots; >>> E, wfn = energy('ci', return_wfn=True); >>> molden(wfn, 'no_root1.molden', density_a=wfn.opdm(0, 0, ""A"", True)). >>> # [3] The following does NOT work, please see below; >>> E, wfn = energy('ccsd', return_wfn=True); >>> molden(wfn, 'ccsd_no.molden', density_a=wfn.Da()). >>> # [4] This WILL work, note the transformation of Da (SO->MO); >>> E, wfn = properties('ccsd', properties=['dipole'], return_wfn=True); >>> Da_so = wfn.Da(); >>> SCa = core.doublet(wfn.S(), wfn.Ca(), False, False); >>> Da_mo = core.triplet(SCa, Da_so, SCa, True, False, False); >>> molden(wfn, 'ccsd_no.molden', density_a=Da_mo). Options¶. MOLDEN_WRITE¶. Do write a MOLDEN output file? If so, the filename will end in .molden, and the prefix is determined by WRITER_FILE_LABEL (if set), or else by the name of the output file plus the name of the current molecule. Type: boolean; Default: false. WRITER_FILE_LABEL¶. Base filename for text files written by PSI, such as the MOLDEN output file, the Hessian file, the internal coordinate file, etc. Use the add_str_i function to make this string case sensitive. Type: string; Default: No Default. MOLDEN_WITH_VIRTUAL¶. Write all the MOs to the MOLDEN file ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/molden-1.html:2640,energy,energy,2640,psi4manual/1.3.2/molden-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/molden-1.html,2,['energy'],['energy']
Energy Efficiency,"med,; in which case should be ``'scf'``. Overruled if stage_wfn keywords supplied. :type scf_wfn: str; :param scf_wfn: |dl| ``'scf'`` |dr| || ``'c4-scf'`` || etc. Indicates the energy method for which the reference energy is to be; obtained. Generally unnecessary, as 'scf' is *the* scf in |PSIfour| but; can be used to direct lone scf components to run in |PSIfour| or Cfour; in a mixed-program composite method. :type corl_wfn: str; :param corl_wfn: ``'mp2'`` || ``'ccsd(t)'`` || etc. Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with ``name`` or as the unlabeled; first argument to the function. :type delta_wfn: str; :param delta_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. :type delta_wfn_lesser: str; :param delta_wfn_lesser: |dl| ``corl_wfn`` |dr| || ``'mp2'`` || etc. Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. :type delta2_wfn: str; :param delta2_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta2_wfn_lesser: str; :param delta2_wfn_lesser: |dl| ``delta_wfn`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. * Basis Sets; Currently, the basis set set through ``set`` commands have no influence; on a cbs calculation. :type scf_basis: :ref:`basis string <apdx:basisElement>`; :param scf_basis: |dl| ``corl_basis`` |dr| || ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, ``scf_basis`` can default; to ``corl_basis``. :type corl_basis: :ref:`basis string <apdx:basisElement>`; :param corl_basis: ``'c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html:36997,energy,energy,36997,psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html,30,['energy'],['energy']
Energy Efficiency,"memory parallelization to run efficiently on; multi-core machines (see Sec. Threading).; An advanced parser written in Python allows the user; input to have a very simple style for routine computations, but it can also; automate very complex tasks with ease.; PSI4 is, in many ways, a whole new package compared to Psi3.; While some libraries and modules remain the same, the majority of the code has; been rewritten from scratch based on a powerful set of new libraries written; in C++. A totally new Python front-end makes PSI4 incredibly user-friendly; and automates many common tasks such as basis set extrapolation, composite; methods, running the same computation on every molecule in a test set, etc.; Density-functional theory, absent in Psi3, is quite efficient; in PSI4, with many functionals available. Density fitting is ubiquitous in; PSI4, leading to some of the most efficient MP2 and CCSD(T) code available.; PSI4 also introduces extensive,; powerful features for energy component analysis of non-covalent interactions; via symmetry-adapted perturbation theory. Orbital-optimized versions of; perturbation theory and coupled-cluster methods, and their analytic gradients,; have also been added. Through external libraries, PSI4 gains access to implicit; solvent (PCM) capabilities, density-matrix renormalization group CI, effective; fragment potentials, Grimme dispersion corrections, and high-order; coupled-cluster theory.; In this section, we provide an overview of some of the features of; PSI4 along with the prerequisite steps for running calculations.; Sec. Tutorial provides a brief tutorial to help new users; get started. Section Psithon offers further details into the; structure of PSI4 input files and how Python can be mixed with; quantum chemistry directives in PSI4. Section Psithon Functions; provides more detail on the Python functions provided by PSI4; and discusses some of the higher-level functions such as counterpoise; correction, complete-basis-set extrapol",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/introduction-1.html:1226,power,powerful,1226,psi4manual/1.1.0/introduction-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/introduction-1.html,45,"['adapt', 'energy', 'power']","['adapted', 'energy', 'powerful']"
Energy Efficiency,"ment %d of %d' % (n + 1, ndisp)); print("""""" %d"""""" % (n + 1), end=('\n' if (n + 1 == ndisp) else '')); sys.stdout.flush(). # Load in displacement into the active molecule; moleculeclone.set_geometry(displacement). # Perform the energy calculation; E, wfn = energy(lowername, return_wfn=True, molecule=moleculeclone, **kwargs); energies.append(core.get_variable('CURRENT ENERGY')). # S/R: Write each displaced geometry to an input file; elif opt_mode == 'sow':; moleculeclone.set_geometry(displacement). # S/R: Prepare molecule, options, and kwargs; with open('%s.in' % (rfile), 'wb') as freagent:; freagent.write('# This is a psi4 input file auto-generated from the gradient() wrapper.\n\n'.encode('utf-8')); freagent.write(p4util.format_molecule_for_input(moleculeclone).encode('utf-8')); freagent.write(p4util.format_options_for_input().encode('utf-8')); p4util.format_kwargs_for_input(freagent, **kwargs). # S/R: Prepare function call and energy save; freagent.write((""""""electronic_energy = energy('%s', **kwargs)\n\n"""""" % (lowername)).encode('utf-8')); freagent.write((""""""core.print_out('\\nGRADIENT RESULT: computation %d for item %d """""" % (os.getpid(), n + 1)).encode('utf-8')); freagent.write(""""""yields electronic energy %20.12f\\n' % (electronic_energy))\n\n"""""".encode('utf-8')). # S/R: Read energy from each displaced geometry output file and save in energies array; elif opt_mode == 'reap':; exec(banners); core.set_variable('NUCLEAR REPULSION ENERGY', moleculeclone.nuclear_repulsion_energy()); energies.append(p4util.extract_sowreap_from_output(rfile, 'GRADIENT', n, opt_linkage, True)). # S/R: Quit sow after writing files. Initialize skeleton wfn to receive grad for reap; if opt_mode == 'sow':; optstash.restore(); if return_wfn:; return (None, None) # any point to building a dummy wfn here?; else:; return None; elif opt_mode == 'reap':; core.set_variable('CURRENT ENERGY', energies[-1]); wfn = core.Wavefunction.build(molecule, core.get_global_option('BASIS')). # Compute the gradient",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html:43256,energy,energy,43256,psi4manual/1.1.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html,2,['energy'],['energy']
Energy Efficiency,"ment %d of %d' % (n + 1, ndisp)); print("""""" %d"""""" % (n + 1), end=('\n' if (n + 1 == ndisp) else '')); sys.stdout.flush(). # Load in displacement into the active molecule; moleculeclone.set_geometry(displacement). # Perform the energy calculation; E, wfn = energy(lowername, return_wfn=True, molecule=moleculeclone, **kwargs); energies.append(psi4.get_variable('CURRENT ENERGY')). # S/R: Write each displaced geometry to an input file; elif opt_mode == 'sow':; moleculeclone.set_geometry(displacement). # S/R: Prepare molecule, options, and kwargs; with open('%s.in' % (rfile), 'wb') as freagent:; freagent.write('# This is a psi4 input file auto-generated from the gradient() wrapper.\n\n'.encode('utf-8')); freagent.write(p4util.format_molecule_for_input(moleculeclone).encode('utf-8')); freagent.write(p4util.format_options_for_input().encode('utf-8')); p4util.format_kwargs_for_input(freagent, **kwargs). # S/R: Prepare function call and energy save; freagent.write((""""""electronic_energy = energy('%s', **kwargs)\n\n"""""" % (lowername)).encode('utf-8')); freagent.write((""""""psi4.print_out('\\nGRADIENT RESULT: computation %d for item %d """""" % (os.getpid(), n + 1)).encode('utf-8')); freagent.write(""""""yields electronic energy %20.12f\\n' % (electronic_energy))\n\n"""""".encode('utf-8')). # S/R: Read energy from each displaced geometry output file and save in energies array; elif opt_mode == 'reap':; exec(banners); psi4.set_variable('NUCLEAR REPULSION ENERGY', moleculeclone.nuclear_repulsion_energy()); energies.append(p4util.extract_sowreap_from_output(rfile, 'GRADIENT', n, opt_linkage, True)). # S/R: Quit sow after writing files. Initialize skeleton wfn to receive grad for reap; if opt_mode == 'sow':; optstash.restore(); if return_wfn:; return (None, None) # any point to building a dummy wfn here?; else:; return None; elif opt_mode == 'reap':; psi4.set_variable('CURRENT ENERGY', energies[-1]); wfn = psi4.new_wavefunction(molecule, psi4.get_global_option('BASIS')). # Compute the gradient; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver.html:41922,energy,energy,41922,psi4manual/1.0.0/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver.html,1,['energy'],['energy']
Energy Efficiency,"ments by other psi4 developers. Major; differences from the C++ class are: no basisset handling, no symmetry,; no pubchem, no efp, no discarding dummies. This class translated so; that databases can function independently of psi4. >>> H2OH2O = qcdb.Molecule(\""\""\""; 0 1; O1 -1.551007 -0.114520 0.000000; H1 -1.934259 0.762503 0.000000; H2 -0.599677 0.040712 0.000000; --; 0 1; X 0.000000 0.000000 0.000000; O2 1.350625 0.111469 0.000000; H3 1.680398 -0.373741 -0.758561; H4 1.680398 -0.373741 0.758561; no_com; no_reorient; units angstrom; \""\""\""). >>> H2O = qcdb.Molecule.init_with_xyz('h2o.xyz'); """"""; FullPointGroupList = [""ATOM"", ""C_inf_v"", ""D_inf_h"", ""C1"", ""Cs"", ""Ci"", \; ""Cn"", ""Cnv"", ""Cnh"", ""Sn"", ""Dn"", ""Dnd"", ""Dnh"", ""Td"", ""Oh"", ""Ih""]. def __init__(self, psi4molstr=None):; """"""Initialize Molecule object from string in psi4 format"""""". # <<< Basic Molecule Information >>>. # Molecule (or fragment) name; self.PYname = 'default'; # The molecular charge; self.PYmolecular_charge = 0; # Whether the charge was given by the user; self.PYcharge_specified = False; # The multiplicity (defined as 2Ms + 1); self.PYmultiplicity = 1; # Whether the multiplicity was specified by the user; self.PYmultiplicity_specified = False; # The units used to define the geometry; self.PYunits = 'Angstrom'; # The conversion factor to take input units to Bohr; self.input_units_to_au = 1.0 / psi_bohr2angstroms; # Whether this molecule has at least one zmatrix entry; self.zmat = False # TODO None?. # <<< Coordinates >>>. # Atom info vector (no knowledge of dummy atoms); self.atoms = []; # Atom info vector (includes dummy atoms); self.full_atoms = []; # A list of all variables known, whether they have been set or not.; self.all_variables = []; # A listing of the variables used to define the geometries; self.geometry_variables = {}. # <<< Fragmentation >>>. # The list of atom ranges defining each fragment from parent molecule; self.fragments = []; # A list describing how to handle each fragment; self.fragmen",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:3045,charge,charge,3045,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,1,['charge'],['charge']
Energy Efficiency,"ments were defined as follows:. \[\bar{g}_{pq}^{rs} = g_{pq}^{rs} - g_{pq}^{sr}\]. \[f_p^q = h_p^q + \bar{g}_{pr}^{qs} \gamma_{s}^{r}\]; Energy functional \(E_{DCT}\) has several important properties. First,; the energy is now a function of two sets of independent parameters, the; idempotent part of \(\boldsymbol{\gamma_1}\) (\(\boldsymbol{\kappa}\)) and the density cumulant; (\(\boldsymbol{\lambda_2}\)). As a result, the energy functional is Hermitian,; which is important for the evaluation of the molecular properties. The additive; separability of the density cumulant guarantees that all of the DCT methods; are size-extensive and size-consistent. Furthermore, the N-representability; problem is now greatly simplified, because the idempotent part of \(\boldsymbol{\gamma_1}\) is; N-representable by construction. One only needs to worry about the; N-representability of the density cumulant, which is a relatively small part of; \(\boldsymbol{\gamma_2}\).; In order to obtain the DCT energy, two conditions must be satisfied:. The energy must be stationary with respect to a set of orbitals. This can be done by; diagonalizing the generalized Fock operator (as in the DC-06 and DC-12 methods, see below),; which introduces partial orbital relaxation, or by fully relaxing the orbitals and minimizing the entire energy expression; (as in the ODC-06 and ODC-12 methods).; The energy must be stationary with respect to the variation of the density; cumulant \(\boldsymbol{\lambda_2}\), constrained to N-representability conditions. Making the energy stationary requires solution of two sets of coupled; equations for orbitals and density cumulant, respectively (also known as; residual equations). At the present moment, three different algorithms for the; solution of the system of coupled equations are available (see; Iterative Algorithms for details).; Publications resulting from the use of the DCT code should cite contributions; listed here. Methods¶; Currently five DCT methods (functio",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/dct-1.html:3655,energy,energy,3655,psi4manual/1.4.0/dct-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/dct-1.html,9,['energy'],['energy']
Energy Efficiency,"merA', 'monomerB'); PsiMod.IO.set_default_namespace('monomerB'); PsiMod.set_local_option('SCF', 'SAPT', '2-monomer_B'); PsiMod.print_out('\n'); banner('Monomer B HF'); PsiMod.print_out('\n'); e_monomerB = scf_helper('RHF', **kwargs); PsiMod.print_out('\n'); banner('Monomer B DFMP2'); PsiMod.print_out('\n'); e_monomerB_mp2 = PsiMod.dfmp2(); PsiMod.set_global_option('DF_INTS_IO', df_ints_io). PsiMod.IO.change_file_namespace(PSIF_SAPT_MONOMERA, 'monomerA', 'dimer'); PsiMod.IO.change_file_namespace(PSIF_SAPT_MONOMERB, 'monomerB', 'dimer'). activate(molecule); PsiMod.IO.set_default_namespace('dimer'); PsiMod.set_local_option('SAPT', 'E_CONVERGENCE', 10e-10); PsiMod.set_local_option('SAPT', 'D_CONVERGENCE', 10e-10); PsiMod.set_local_option('SAPT', 'SAPT_LEVEL', 'MP2C'); PsiMod.print_out('\n'); banner('MP2C'); PsiMod.print_out('\n'). PsiMod.set_variable('MP2C DIMER MP2 ENERGY', e_dimer_mp2); PsiMod.set_variable('MP2C MONOMER A MP2 ENERGY', e_monomerA_mp2); PsiMod.set_variable('MP2C MONOMER B MP2 ENERGY', e_monomerB_mp2). e_sapt = PsiMod.sapt(). optstash.restore(); return e_sapt. [docs]def run_sapt(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SAPT calculation of any level. """"""; optstash = OptionsState(; ['SCF', 'SCF_TYPE']). # Alter default algorithm; if not PsiMod.has_option_changed('SCF', 'SCF_TYPE'):; PsiMod.set_local_option('SCF', 'SCF_TYPE', 'DF'). molecule = PsiMod.get_active_molecule(); user_pg = molecule.schoenflies_symbol(); molecule.reset_point_group('c1'); molecule.fix_orientation(True); molecule.update_geometry(); if user_pg != 'c1':; PsiMod.print_out(' SAPT does not make use of molecular symmetry, further calculations in C1 point group.\n'). if (PsiMod.get_option('SCF','REFERENCE') != 'RHF' ):; raise ValidationError('SAPT requires requires \""reference rhf\"".'). nfrag = molecule.nfragments(); if nfrag != 2:; raise ValidationError('SAPT requires active molecule to have 2 fragments, not %s.' % (nfrag)). sapt_basis = 'dimer'; if 'sapt_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/proc.html:45913,ENERGY,ENERGY,45913,psi4manual/4.0b4/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/proc.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"merate(eigs):; for idx, x in np.ndenumerate(block):; eigs_dump += '{: 29.20E} {:4d} {:4d} {:4d} {:4d}\n'.format(x, mo_idx(iorb), 0, 0, 0); iorb += 1; return eigs_dump. def _irrep_map(wfn):; """"""Returns an array of irrep indices that maps from Psi4's ordering convention to the standard FCIDUMP convention.; """"""; symm = wfn.molecule().point_group().symbol(); psi2dump = {'c1' : [1], # A; 'ci' : [1,2], # Ag Au; 'c2' : [1,2], # A B; 'cs' : [1,2], # A' A""; 'd2' : [1,4,3,2], # A B1 B2 B3; 'c2v' : [1,4,2,3], # A1 A2 B1 B2; 'c2h' : [1,4,2,3], # Ag Bg Au Bu; 'd2h' : [1,4,6,7,8,5,3,2] # Ag B1g B2g B3g Au B1u B2u B3u; }. irrep_map = psi2dump[symm]; return np.array(irrep_map, dtype='int'). [docs]def fcidump_from_file(fname):; """"""Function to read in a FCIDUMP file. :returns: a dictionary with FCIDUMP header and integrals; - 'norb' : number of basis functions; - 'nelec' : number of electrons; - 'ms2' : spin polarization of the system; - 'isym' : symmetry of state (if present in FCIDUMP); - 'orbsym' : list of symmetry labels of each orbital; - 'uhf' : whether restricted or unrestricted; - 'enuc' : nuclear repulsion plus frozen core energy; - 'epsilon' : orbital energies; - 'hcore' : core Hamiltonian; - 'eri' : electron-repulsion integrals. :param fname: FCIDUMP file name; """"""; intdump = {}; with open(fname, 'r') as handle:; assert '&FCI' == handle.readline().strip(). skiplines = 1; read = True; while True:; skiplines += 1; line = handle.readline(); if 'END' in line:; break. key, value = line.split('='); value = value.strip().rstrip(','); if key == 'UHF':; value = 'TRUE' in value; elif key == 'ORBSYM':; value = [int(x) for x in value.split(',')]; else:; value = int(value.replace(',', '')). intdump[key.lower()] = value. # Read the data and index, skip header; raw_ints = np.genfromtxt(fname, skip_header=skiplines). # Read last line, i.e. Enuc + Efzc; intdump['enuc'] = raw_ints[-1, 0]. # Read in integrals and indices; ints = raw_ints[:-1, 0]. # Get dimensions and indices; nbf = intdump['",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/fcidump.html:9777,energy,energy,9777,psi4manual/1.4.0/_modules/psi4/driver/p4util/fcidump.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/fcidump.html,2,['energy'],['energy']
Energy Efficiency,"mers are unspecified so driver auto-fragments it. Basis set and auxiliary basis sets are assigned by atom type. cfour/pywrap-db1; Database calculation, so no molecule section in input file. Portions of the full databases, restricted by subset keyword, are computed by sapt0 and dfmp2 methods. cfour/kw-5; Basis set spherical/Cartesian with basis and cfour_spherical. cfour/sp-rohf-ccsd; single-point CCSD/qz2p on NH2. cfour/sp-uhf-ccsd_t_-ecc; single-point CCSD(T)/qz2p on NH2 with ecc. cfour/kw-1; testing best practices options, part i. cfour/mints5; geometries from a variety of input formats. references from psi4, testing whether geometry strings read identically for psi4/cfour. cfour/kw-8; Translating psi4 options to cfour, part ii. cfour/sp-uhf-cc3; single-point CC3/qz2p on NH2. cfour/sp-rohf-ccsd_t_-ao-ecc; single-point CCSD(T)/qz2p on NH2 with ecc, aobasis. cfour/sp-uhf-mp2; single-point MP2/qz2p on NH2. cfour/opt-rhf-ccsd_t_; optimization CCSD(T)/dzp on water. cfour/psi-uhf-scsmp2; UHF MP2 energy components. Checks that computed identically between cfour and psi4. cfour/sp-uhf-scf; single-point HF/qz2p on NH2. cfour/sp-rhf-ccsd-ao; single-point CCSD/qz2p on water with aobasis. cfour/sp-uhf-ccsdt; single-point CCSDT/qz2p on NH2. cfour/sp-rhf-scf; single-point HF/qz2p on water. cfour/kw-7; Translating psi4 options to cfour, part i. cfour/opt-rhf-scf; optimization HF/svp on water. cfour/puream; Basis set spherical/Cartesian behavior in cfour. cfour/sp-uhf-ccsd_t_-ao-ecc; single-point CCSD(T)/qz2p on NH2 with ecc, aobasis. cfour/sp-rohf-ccsd_t_; single-point CCSD(T)/qz2p on NH2. cfour/psi-a24-grad; geometry after three optimization cycles on A24 database, cfour matches psi4. cfour/kw-2; testing best practices options, part ii. cfour/mints5-grad; geometry after three optimization cycles for a variety of input formats, references from psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Appendices; Test Suite and Sam",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_cfour.html:4137,energy,energy,4137,psi4manual/1.6.x/autodoc_testsuite_cfour.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_cfour.html,1,['energy'],['energy']
Energy Efficiency,"mes 10^{-3}\);  . MOLPRO [2] [5]; \(1.0 \times 10^{-6}\); \(3.0 \times 10^{-4}\);  ; \(3.0 \times 10^{-4}\);  . GAU_TIGHT [3] [6];  ; \(1.5 \times 10^{-5}\); \(1.0 \times 10^{-5}\); \(6.0 \times 10^{-5}\); \(4.0 \times 10^{-5}\). GAU_VERYTIGHT [6];  ; \(2.0 \times 10^{-6}\); \(1.0 \times 10^{-6}\); \(6.0 \times 10^{-6}\); \(4.0 \times 10^{-6}\). Footnotes. [1]Default. [2]Baker convergence criteria are the same. [3](1, 2) Counterpart NWCHEM convergence criteria are the same. [4](1, 2, 3) Convergence achieved when all active criteria are fulfilled. [5](1, 2, 3) Convergence achieved when Max Force and one of Max Energy or Max Disp are fulfilled. [6](1, 2, 3, 4, 5) Normal convergence achieved when all four criteria (Max Force, RMS Force,; Max Disp, and RMS Disp) are fulfilled. To help with flat; potential surfaces, alternate convergence achieved when 100\(\times\)rms force is less; than RMS Force criterion. For ultimate control, specifying a value for any of the five monitored options activates that; criterium and overwrites/appends it to the criteria set by G_CONVERGENCE.; Note that this revokes the special convergence arrangements detailed in notes [5] and [6]; and instead requires all active criteria to be fulfilled to; achieve convergence. To avoid this revokation, turn on keyword FLEXIBLE_G_CONVERGENCE. Output¶; The progress of a geometry optimization can be monitored by grepping the output file for the; tilde character (~). This produces a table like the one below that shows; for each iteration the value for each of the five quantities and whether the criterion; is active and fulfilled (*), active and unfulfilled ( ), or inactive (o).; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10--------------------------------------------------------------------------------------------- ~; Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~; --------------------------------------------------------------------------------------------- ~; Convergence Criteria 1.00e-06 * 3.00e-04 * o ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/optking-1.html:13559,monitor,monitored,13559,psi4manual/1.1.0/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/optking-1.html,2,['monitor'],['monitored']
Energy Efficiency,"mes assembled from implementations by multiple coders. Conversely,; some capabilities may be implemented multiple times. Capabilities,; modules, algorithm types, and defaults are detailed for many ground-state; methods at Table Module Capabilities. Its; analogous summary table (with modules collapsed) is at Summary; Capabilities. PSI4 transparently selects the; most efficient implementation, so one generally needn’t consult this; table. However, to understand the details of what combinations are; accessible or what alternate implementations are available, read on.; Note that HF, DFT, and MPn (n<=3); default to density-fitted integrals, while all higher methods default to; conventional integrals. Therefore, for a closed-shell molecule:; # runs MP2 with default algorithm type ``DF`` with default implementation DFMP2; energy('mp2'). # runs MP2 with algorithm type ``CONV`` with default implementation OCC; set mp2_type conv; energy('mp2'). # runs MP2 with default algorithm type ``DF`` with implementation OCC; set qc_module occ; energy('mp2'). # runs MP2 with algorithm type ``CONV`` with implementation FNOCC; set mp2_type conv; set qc_module fnocc; energy('mp2'). Capabilities of PSI4, including details of overlapping modules. “✓” runs analytically. “∷” runs derivative with internal finite difference. Single underline “✓̲” or “∷̲” is default module when QC_MODULE unspecified. Double underline “✓̳” or “∷̳” is default algorithm type when type selector (e.g., CC_TYPE) unspecified.¶. ◻; ◻; name ↓ →; type[1] ↓ →; ◻. QC_MODULE ↓; REFERENCE →; ◻; ◻; FREEZE_CORE[2]→. PSI4 Capabilities. Restricted (RHF); Unrestricted (UHF); Restricted Open (ROHF). energy(); gradient()[3]; energy(); gradient()[3]; energy(); gradient()[3]. CV; DF; CD; CV; DF; CD; CV; DF; CD; CV; DF; CD; CV; DF; CD; CV; DF; CD. A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F. hf; SCF_TYPE. ✓. ✓̳. ✓. ✓. ✓̳. ∷. ✓. ✓̳. ✓. ✓. ✓̳. ∷. ✓. ✓̳. ✓. ✓. ✓̳. ∷. SCF; ✓̲. ✓̳.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/capabilities.html:1492,energy,energy,1492,psi4manual/1.7.x/capabilities.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/capabilities.html,4,['energy'],['energy']
Energy Efficiency,"mes the data; is passed in. Returns:A deserialized Wavefunction object. Return type:Wavefunction. frzcpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of frozen core orbitals per irrep. frzvpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of frozen virtual orbitals per irrep. get_amplitudes(self: psi4.core.CCWavefunction) → Dict[str, psi4.core.Matrix]. Get dict of converged T amplitudes. amps : dict (spacestr, SharedMatrix); spacestr is a description of the amplitude set using the following conventions.; I,J,K -> alpha occupied; i,j,k -> beta occupied; A,B,C -> alpha virtual; a,b,c -> beta virtual. The following entries are stored in the amps, depending on the reference type; RHF: “tIA”, “tIjAb”; UHF: tIA, tia, tIjAb, tIJAB, tijab; ROHF: tIA, tia, tIjAb, tIJAB, tijab. Examples; RHF T1 diagnostic = sqrt(sum_ia (T_ia * T_ia)/nelec); >>> mol = “””; … 0 1; … Ne 0.0 0.0 0.0; … symmetry c1”“”; >>> e, wfn = psi4.energy(“CCSD/cc-pvdz”, return_wfn=True); >>> t1 = wfn.get_amplitudes()[‘tia’].to_array(); >>> t1_diagnostic = np.sqrt(np.dot(t1.ravel(),t1.ravel())/ (2 * wfn.nalpha()); >>> t1_diagnostic == psi4.variable(“CC T1 DIAGNOSTIC”); True. Warning; Symmetry free calculations only (nirreps > 1 will cause error). Warning; No checks that the amplitudes will fit in core. Do not use for proteins. get_array(key)¶. get_basisset(self: psi4.core.Wavefunction, arg0: str) → psi4.core.BasisSet¶; Returns the requested auxiliary basis. get_dipole_field_strength(self: psi4.core.Wavefunction) → List[float[3]]¶; Returns a vector of length 3, containing the x, y, and z dipole field strengths. get_print(self: psi4.core.Wavefunction) → int¶; Get the print level of the Wavefunction. get_scratch_filename(filenumber)¶; Given a wavefunction and a scratch file number, canonicalizes the name; so that files can be consistently written and read. get_variable(key)¶. gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Wavefunction",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.ccwavefunction.html:7606,energy,energy,7606,psi4manual/1.3.2/api/psi4.core.ccwavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.ccwavefunction.html,1,['energy'],['energy']
Energy Efficiency,"mes tol (option #16) in fort.56. Type: conv double; Default: 1e-6. E_CONVERGENCE (OCC)¶OCC — Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. E_CONVERGENCE (PSIMRCC)¶PSIMRCC — Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. E_CONVERGENCE (SAPT)¶SAPT — Convergence criterion for energy (change) in the SAPT \(E_{ind,resp}^{(20)}\) term during solution of the CPHF equations. Type: conv double; Default: 1e-10. E_CONVERGENCE (SCF)¶SCF — Convergence criterion for SCF energy. See Table SCF Convergence & Algorithm for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. EA_POLES (OCC)¶OCC — Do compute OCC poles for electron affinities? Only valid for OMP2. Type: boolean; Default: false. EFP_DISP (EFP)¶EFP — Do include dispersion energy term in EFP computation?. Type: boolean; Default: true. EFP_DISP_DAMPING (EFP)¶EFP — Fragment-fragment dispersion damping type. TT is a damping formula by Tang and Toennies. OVERLAP is overlap-based dispersion damping. Type: string; Possible Values: TT, OVERLAP, OFF; Default: OVERLAP. EFP_ELST (EFP)¶EFP — Do include electrostatics energy term in EFP computation?. Type: boolean; Default: true. EFP_ELST_DAMPING (EFP)¶EFP — Fragment-fragment electrostatic damping type. SCREEN is a damping formula based on screen group in the EFP potential. OVERLAP is damping that computes charge penetration energy. Type: string; Possible Values: SCREEN, OVERLAP, OFF; Default: SCREEN. EFP_EXCH (EFP)¶EFP — Do include exchange repulsion energy term in EFP computation?. Type: boolean; Default: true. EFP_IND (EFP)¶EFP — Do include polarization energy term in EFP computation? (EFP_POL c. v1.1). Type: boolean; Default: true. EFP_IND_DAMPING (EFP)¶EFP — Fragment-fragment polarization damping type. TT",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html:119112,energy,energy,119112,psi4manual/1.4.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html,8,['energy'],['energy']
Energy Efficiency,"meter('Meta_a11', 15.23694). C = build_functional('M_C'); C.set_name('M05_2X_C'). # LSDA Correlation type is PW92, no parameters. # GGA Correlation type is B97; C.set_parameter('B97_os_gamma', 0.0031 * 2.0); C.set_parameter('B97_os_a0', 1.00000); C.set_parameter('B97_os_a1', 1.09297); C.set_parameter('B97_os_a2', -3.79171); C.set_parameter('B97_os_a3', 2.82810); C.set_parameter('B97_os_a4', -10.58909). C.set_parameter('B97_ss_gamma', 0.06); C.set_parameter('B97_ss_a0', 1.00000); C.set_parameter('B97_ss_a1', -3.05430); C.set_parameter('B97_ss_a2', 7.61854); C.set_parameter('B97_ss_a3', 1.47665); C.set_parameter('B97_ss_a4', -11.92365). # Meta Correlation type is Becke metric, no parameters. # Add the functionals in; sup.add_x_functional(X); sup.add_c_functional(C). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.56) # Hartree-Fock exact exchange; sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_m05d3zero_superfunctional(name, npoints, deriv):. sup = build_m05_superfunctional(name, npoints, deriv); sup.set_name('M05-D3ZERO'). # => -D3 <= #; sup.set_dispersion(PsiMod.Dispersion.build(*dash_server('m05', 'd3zero'))). return sup. [docs]def build_m05_2xd3zero_superfunctional(name, npoints, deriv):. sup = build_m05_2x_superfunctional(name, npoints, deriv); sup.set_name('M05-2X-D3ZERO'). # => -D3 <= #; sup.set_dispersion(PsiMod.Dispersion.build(*dash_server('m05-2x', 'd3zero'))). return sup. [docs]def build_dldf_superfunctional(name, npoints, deriv):. # Call this first; sup = PsiMod.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('dlDF'); # Tab in, trailing newlines; sup.set_description(' Dispersionless Hybrid Meta-GGA XC Functional\n'); # Tab in, trailing newlines; sup.set_citation(' Pernal et. al., Phys. Rev. Lett., 103, 263201,",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/functional.html:65863,allocate,allocate,65863,psi4manual/4.0b4/_modules/functional.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/functional.html,2,['allocate'],['allocate']
Energy Efficiency,"meter('Meta_a11', 15.23694). C = build_functional('M_C'); C.set_name('M05_2X_C'). # LSDA Correlation type is PW92, no parameters. # GGA Correlation type is B97; C.set_parameter('B97_os_gamma', 0.0031 * 2.0); C.set_parameter('B97_os_a0', 1.00000); C.set_parameter('B97_os_a1', 1.09297); C.set_parameter('B97_os_a2', -3.79171); C.set_parameter('B97_os_a3', 2.82810); C.set_parameter('B97_os_a4', -10.58909). C.set_parameter('B97_ss_gamma', 0.06); C.set_parameter('B97_ss_a0', 1.00000); C.set_parameter('B97_ss_a1', -3.05430); C.set_parameter('B97_ss_a2', 7.61854); C.set_parameter('B97_ss_a3', 1.47665); C.set_parameter('B97_ss_a4', -11.92365). # Meta Correlation type is Becke metric, no parameters. # Add the functionals in; sup.add_x_functional(X); sup.add_c_functional(C). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.56) # Hartree-Fock exact exchange; sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_m05d3zero_superfunctional(name, npoints, deriv):. sup = build_m05_superfunctional(name, npoints, deriv); sup.set_name('M05-D3ZERO'). # => -D3 <= #; sup.set_dispersion(psi4.Dispersion.build(*dash_server('m05', 'd3zero'))). return sup. [docs]def build_m05_2xd3zero_superfunctional(name, npoints, deriv):. sup = build_m05_2x_superfunctional(name, npoints, deriv); sup.set_name('M05-2X-D3ZERO'). # => -D3 <= #; sup.set_dispersion(psi4.Dispersion.build(*dash_server('m05-2x', 'd3zero'))). return sup. [docs]def build_dldf_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('dlDF'); # Tab in, trailing newlines; sup.set_description(' Dispersionless Hybrid Meta-GGA XC Functional\n'); # Tab in, trailing newlines; sup.set_citation(' Pernal et. al., Phys. Rev. Lett., 103, 263201, 2009\",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/functional.html:66499,allocate,allocate,66499,psi4manual/4.0b5/_modules/functional.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/functional.html,3,['allocate'],['allocate']
Energy Efficiency,"meter)**2; B = constants.h / (8.0 * np.pi**2 * constants.c * I). # alpha_e and quartic centrifugal distortion constant; ae = -(6.0 * B**2 / we) * ((1.05052209e-3*we*d3)/(np.sqrt(B * d2**3))+1.0); de = 4.0*B**3 / we**2. # B0 and r0 (plus re check using Be); B0 = B - ae / 2.0; r0 = np.sqrt(constants.h / (8.0 * np.pi**2 * mu * constants.c * B0)); recheck = np.sqrt(constants.h / (8.0 * np.pi**2 * mu * constants.c * B)); r0 /= angstrom_to_meter; recheck /= angstrom_to_meter. # Fundamental frequency nu; nu = we - 2.0 * wexe; zpve_nu = 0.5 * we - 0.25 * wexe; zpve_we = 0.5 * we. # Generate pretty pictures, if requested; if(plot_fit):; try:; import matplotlib.pyplot as plt; except ImportError:; msg = ""\n\tPlot not generated; matplotlib is not installed on this machine.\n\n""; print(msg); core.print_out(msg). # Correct the derivatives for the missing factorial prefactors; dvals = np.zeros(5); dvals[0:5] = derivs[0:5]; dvals[2] /= 2; dvals[3] /= 6; dvals[4] /= 24. # Default plot range, before considering energy levels; minE = np.min(energies); maxE = np.max(energies); minR = np.min(rvals); maxR = np.max(rvals). # Plot vibrational energy levels; we_au = we / constants.hartree2wavenumbers; wexe_au = wexe / constants.hartree2wavenumbers; coefs2 = [ dvals[2], dvals[1], dvals[0] ]; coefs4 = [ dvals[4], dvals[3], dvals[2], dvals[1], dvals[0] ]; for n in range(3):; Eharm = we_au*(n+0.5); Evpt2 = Eharm - wexe_au*(n+0.5)**2; coefs2[-1] = -Eharm; coefs4[-1] = -Evpt2; roots2 = np.roots(coefs2); roots4 = np.roots(coefs4); xvals2 = roots2 + re; xvals4 = np.choose(np.where(np.isreal(roots4)), roots4)[0].real + re; Eharm += dvals[0]; Evpt2 += dvals[0]; plt.plot(xvals2, [Eharm, Eharm], 'b', linewidth=1); plt.plot(xvals4, [Evpt2, Evpt2], 'g', linewidth=1); maxE = Eharm; maxR = np.max([xvals2,xvals4]); minR = np.min([xvals2,xvals4]). # Find ranges for the plot; dE = maxE - minE; minE -= 0.2*dE; maxE += 0.4*dE; dR = maxR - minR; minR -= 0.2*dR; maxR += 0.2*dR. # Generate the fitted PES; xpts = np",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/diatomic.html:7399,energy,energy,7399,psi4manual/1.4.0/_modules/psi4/driver/diatomic.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/diatomic.html,14,['energy'],['energy']
Energy Efficiency,"meters (dftd3 not called); energy('bp86-d'). DFT-D3BJ optimization with default parameters; optimize('pbe-d3bj'). DFT-D2 optimization with custom s6 parameter; set dft_dispersion_parameters [1.20]; optimize('b3lyp-d2'). DFT-D3ZERO single point (b3lyp) with custom s8 parameter (reset all four values); set dft_dispersion_parameters [1.0, 2.0, 1.261, 14.0]; energy('b3lyp-d3'). DFT-D2 single point with dftd3 instead of PSI4‘s libdisp; energy('pbe-d2', engine='dftd3'). If only dispersion corrections (rather than total energies) are of; interest, the dispersion programs can be run independently of the scf; through the python function run_dftd3() or run_dftd4(). (These functions; call QCEngine, which is the same PSI4 + dftd3/dftd4 interface that is called during an scf job.); This “D-only” route is much faster than running a DFT-D energy.; This route is NOT available for s-dftd3. File an issue if a definite need arises.; Note that in a DFT+D energy or gradient calculation, user-specified; dispersion parameters override any information provided about the; functional. The same holds true for a dftd3 “D-only” calculation. But; in a dftd4 “D-only” calculation, functional information overrides; any user-specified dispersion parameters. Some set-up:; molecule nene {; Ne; Ne 1 2.0; }. nene.update_geometry(). The same four dispersion corrections/gradients as the section above:; >>> print nene.run_dftd3('bp86', 'd', dertype=0); -7.735e-05. >>> E, G = nene.run_dftd3('pbe', 'd3bj'); >>> print G; [[0.0, 0.0, -1.1809087569358e-05], [0.0, 0.0, 1.1809087569358e-05]]. >>> E, G = nene.run_dftd3('b3lyp', 'd2', {'s6': 1.20}); >>> print E; -8.84e-05. >>> E, G = nene.run_dftd3(dashlvl='d3', dashparam={'s8': 2.0, 'alpha6': 14.0, 'sr6': 1.261, 's6': 1.0}); >>> print E; -0.00024762. qcdb.Molecule.run_dftd3(self, func=None, dashlvl=None, dashparam=None, dertype=None, verbose=1)¶; Compute dispersion correction via Grimme’s DFTD3 program. Parameters:. func (Optional[str]) – Name of functional (func o",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/dftd3.html:12634,energy,energy,12634,psi4manual/1.7.x/dftd3.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/dftd3.html,4,['energy'],['energy']
Energy Efficiency,"meters [1.0, 2.0, 1.261, 14.0]; energy('b3lyp-d3'). If only dispersion corrections (rather than total energies) are of; interest, the dftd3 program can be run independently of the scf; through the python function run_dftd3(). (This function; is the same PSI4/dftd3 interface that is called during an scf job.); This route is much faster than running a DFT-D energy. Some set-up:; molecule nene {; Ne; Ne 1 2.0; }. nene.update_geometry(). The same four dispersion corrections/gradients as the section above:; >>> print nene.run_dftd3('bp86', 'd', dertype=0); -7.735e-05. >>> E, G = nene.run_dftd3('pbe', 'd3bj'); >>> print G; [[0.0, 0.0, -1.1809087569358e-05], [0.0, 0.0, 1.1809087569358e-05]]. >>> E, G = nene.run_dftd3('b3lyp', 'd2', {'s6': 1.20}); >>> print E; -8.84e-05. >>> E, G = nene.run_dftd3(dashlvl='d3', dashparam={'s8': 2.0, 'alpha6': 14.0, 'sr6': 1.261, 's6': 1.0}); >>> print E; -0.00024762. run_dftd3(self, func=None, dashlvl=None, dashparam=None, dertype=None)[source]¶; Function to call Grimme’s dftd3 program (http://toc.uni-muenster.de/DFTD3/); to compute the -D correction of level dashlvl using parameters for; the functional func. The dictionary dashparam can be used to supply; a full set of dispersion parameters in the absense of func or to supply; individual overrides in the presence of func. Returns energy if dertype is 0,; gradient if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The dftd3 executable must be independently compiled and found in; PATH. Table Of Contents. Interface to DFTD3 by S. Grimme; Installation; Theory; Running DFTD3. Previous topic; Interface to MRCC by M. Kállay; Next topic; Interface to Molden; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta5] » ; Interfaces: Enhancing PSI4 Capabilities ». © Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/dftd3-1.html:6938,energy,energy,6938,psi4manual/4.0b5/dftd3-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/dftd3-1.html,4,['energy'],['energy']
Energy Efficiency,"meters, VWN1 Spin Polarization. vwn5rpa_c; VWN5 LSDA Correlation, RPA Parameters, VWN5 Spin Polarization. vwn5_c; VWN5 LSDA Correlation, QMC Parameters, VWN5 Spin Polarization. dldf; Dispersionless Hybrid Meta-GGA XC Functional. dldf+d; Dispersionless Hybrid Meta-GGA XC Functional. dldf+d09; Dispersionless Hybrid Meta-GGA XC Functional. name; calls method in Stanton and Gauss’s CFOUR program [manual]. c4-scf; Hartree–Fock (HF). c4-mp2; 2nd-order Møller–Plesset perturbation theory (non-density-fitting) (MP2). c4-mp3; 3rd-order Møller–Plesset perturbation theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. 1; 2>>> # [1] Analytic hf optimization; >>> optimize('hf'). 1; 2; 3; 4>>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). 1; 2; 3>>> # [3] Forced finite difference hf optimization run in; >>> # embarrassingly parallel fashion; >>> optimize('hf', dertype='energy', mode='sow'). 1; 2>>> # [4] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). 1; 2; 3; 4>>> # [5] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). Navigation. Index. modules    .    .  · ; 1.1;  · . PSI4. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.opt.html:7405,energy,energy,7405,psi4manual/1.1.0/api/psi4.driver.opt.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.opt.html,2,['energy'],['energy']
Energy Efficiency,"meters, and separate charge/multiplicity specifiers for each monomer. One-electron properties computed for dimer and one monomer. cepa0-grad2; CEPA cc-pVDZ gradient for the NO radical. dcft3; DC-06 calculation for the He dimer. This performs a simultaneous update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the AO Basis, using integrals stored on disk. cc2; 6-31G** H2O CCSD optimization by energies, with Z-Matrix input. cc6; Frozen-core CCSD(T)/cc-pVDZ on C4H4N anion with disk ao algorithm. dfomp2p5-grad1; DF-OMP2.5 cc-pVDZ gradients for the H2O molecule. omp2-3; OMP2 cc-pVDZ energy for the NO radical. cc49; EOM-CC3(UHF) on CH radical with user-specified basis and properties for particular root. dcft7; DCFT calculation for the triplet O2 using ODC-06 and ODC-12 functionals. Only simultaneous algorithm is tested. cc48; reproduces dipole moments in J.F. Stanton’s “biorthogonal” JCP paper. pywrap-checkrun-rohf; This checks that all energy methods can run with a minimal input and set symmetry. ci-property; CI/MCSCF cc-pvDZ properties for Potassium nitrate (rocket fuel!). tu4-h2o-freq; Optimization followed by frequencies H2O HF/cc-pVDZ. dcft2; DC-06 calculation for the He dimer. This performs a two-step update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the MO Basis. x2c3; Test of SFX2C-1e on Water uncontracted cc-pVDZ The reference numbers are from Lan Cheng’s implementation in Cfour. scf11-freq-from-energies; Test frequencies by finite differences of energies for planar C4NH4 TS. tu3-h2o-opt; Optimize H2O HF/cc-pVDZ. sapt2; SAPT0 aug-cc-pVDZ computation of the benzene-methane interaction energy, using the aug-pVDZ-JKFIT DF basis for SCF, the aug-cc-pVDZ-RI DF basis for SAPT0 induction and dispersion, and the aug-pVDZ-JKFIT DF basis for SAPT0 electrostatics and induction. This example uses frozen core as well as asyncronous I/O while forming the DF integrals and CPHF coeff",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html:23170,energy,energy,23170,psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"meters:; name_hint (str, optional) – Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Any or all parameters initialized from; dashcoeff[dashlevel][functional-without-dashlevel] or; dashcoeff_supplement[dashlevel][functional-with-dashlevel]; can be overwritten via `param_tweaks.; level_hint (str, optional) – Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or “alias” or; “formal” to one.; param_tweaks (list or dict, optional) – Values for the same keys as dashcoeff[dashlevel][‘default’]; (and same order if list) used to override any or all values; initialized by name_hint. Extra parameters will error.; engine (str, optional) – Override which code computes dispersion. See above for allowed; values. Really only relevant for -D2, which can be computed by; libdisp or dftd3. Methods Summary. compute_energy(molecule); Compute dispersion energy based on engine, dispersion level, and parameters in self. compute_gradient(molecule); Compute dispersion gradient based on engine, dispersion level, and parameters in self. compute_hessian(molecule); Compute dispersion Hessian based on engine, dispersion level, and parameters in self. print_out(); Format dispersion parameters of self for output file. Methods Documentation. compute_energy(molecule)[source]¶; Compute dispersion energy based on engine, dispersion level, and parameters in self. Parameters:molecule (psi4.core.Molecule) – System for which to compute empirical dispersion correction. Returns:Dispersion energy [Eh]. Return type:float. Notes. DISPERSION CORRECTION ENERGY; Disp always set. Overridden in SCF finalization, but that only changes for “-3C” methods.; self.fctldash + DISPERSION CORRECTION ENERGY; Set if fctldash nonempty. compute_gradient(molecule)[source]¶; Compute dispersion gradient based on engine, dispersion level, and parameters in self. Parameters:molecule (psi4.c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.driver.empiricaldispersion.html:3165,energy,energy,3165,psi4manual/1.3.2/api/psi4.driver.empiricaldispersion.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.driver.empiricaldispersion.html,1,['energy'],['energy']
Energy Efficiency,"method from which the delta correction is to be calculated. By default, it; is set to ```wfn``` from the previous field in the ```cbs_metadata``` array.; * ```basis_lo```: basis set to be used for the delta correction. By default, it is the same as the; ```basis``` specified above. * Others. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> energy(cbs, scf_wfn='scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> energy(cbs, corl_wfn='mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> energy(cbs, scf_wfn='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> energy(cbs, corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> energy(cbs, corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> energy(cbs, corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> energy(cbs, corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] a Q5-zeta MP2 calculation, correct",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html:44249,energy,energy,44249,psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html,2,['energy'],['energy']
Energy Efficiency,"method from_serial(json_data); Converts serialized data to the correct Psi4 data type. gemm(self: psi4.core.Matrix, arg0: bool, arg1: bool, arg2: float, arg3: psi4.core.Matrix, arg4: psi4.core.Matrix, arg5: float) → None; docstring. get(*args, **kwargs); Overloaded function. get(self: psi4.core.Matrix, arg0: int, arg1: int, arg2: int) -> float. docstring. get(self: psi4.core.Matrix, arg0: int, arg1: int) -> float. docstring. identity(self: psi4.core.Matrix) → None; docstring. invert(self: psi4.core.Matrix) → None; docstring. load(self: psi4.core.Matrix, arg0: str) → None; docstring. load_mpqc(self: psi4.core.Matrix, arg0: str) → None; docstring. name; The name of the Matrix. Used in printing. nirrep(self: psi4.core.Matrix) → int; docstring. np; View without only one irrep. classmethod np_read(filename, prefix=''). np_write(filename=None, prefix=''). nph; View with irreps. partial_cholesky_factorize(self: psi4.core.Matrix, arg0: float, arg1: bool) → psi4.core.Matrix; docstring. power(self: psi4.core.Matrix, arg0: float, arg1: float) → psi4.core.Dimension; docstring. print_out(self: psi4.core.Matrix) → None; docstring. project_out(self: psi4.core.Matrix, arg0: psi4.core.Matrix) → None; docstring. remove_symmetry(self: psi4.core.Matrix, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix) → None; docstring. rms(self: psi4.core.Matrix) → float; docstring. rotate_columns(self: psi4.core.Matrix, arg0: int, arg1: int, arg2: int, arg3: float) → None; docstring. rowdim(self: psi4.core.Matrix) → psi4.core.Dimension; docstring. rows(self: psi4.core.Matrix, arg0: int) → int; docstring. save(self: psi4.core.Matrix, arg0: str, arg1: bool, arg2: bool, arg3: bool) → None; docstring. scale(self: psi4.core.Matrix, arg0: float) → None; docstring. scale_column(self: psi4.core.Matrix, arg0: int, arg1: int, arg2: float) → None; docstring. scale_row(self: psi4.core.Matrix, arg0: int, arg1: int, arg2: float) → None; docstring. schmidt(self: psi4.core.Matrix) → None. set(*args, **kwargs); Overlo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/api/psi4.core.matrix.html:13586,power,power,13586,psi4manual/1.1.0/api/psi4.core.matrix.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.matrix.html,1,['power'],['power']
Energy Efficiency,"method in cbs_methods]); lowername = name.lower(); if dertype == 1:; # Bounce to CBS in pure-gradient mode if ""method/basis"" name and all parts have analytic grad. avail.; return driver_cbs._cbs_gufunc(gradient, name, ptype='gradient', **kwargs); else:; # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash = driver_util._set_convergence_criterion('energy', cbs_methods[0], 8, 10, 8, 10, 8). else:; # Allow specification of methods to arbitrary order; lowername = name.lower(); _filter_renamed_methods(""gradient"", lowername); lowername, level = driver_util.parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. # Prevent methods that do not have associated gradients; if lowername in energy_only_methods:; raise ValidationError(""gradient('%s') does not have an associated gradient"" % name). dertype = _find_derivative_type('gradient', lowername, user_dertype). # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash = driver_util._set_convergence_criterion('energy', lowername, 8, 10, 8, 10, 8). # Commit to procedures[] call hereafter; return_wfn = kwargs.pop('return_wfn', False); core.clean_variables(). # no analytic derivatives for scf_type cd; if core.get_global_option('SCF_TYPE') == 'CD':; if (dertype == 1):; raise ValidationError(""""""No analytic derivatives for SCF_TYPE CD.""""""). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). # Does dertype indicate an analytic procedure both exists and is wanted?; if dertype == 1:; core.print_out(""""""gradient() will perform analytic gradient computation.\n""""""). # Perform the gradient calculation; wfn = procedures['gradient'][lowername](lowername, molecule=molecule, **kwargs). else:; core.print_out(""""""gradient() will perform gradient computation by finite difference of analytic energies.\n""""""). opt_iter = kwar",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:42004,energy,energy,42004,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,4,['energy'],['energy']
Energy Efficiency,"method': self.method,; 'basis': self.basis,; },; 'molecule': self.molecule.to_schema(dtype=2),; 'properties': properties,; 'provenance': p4util.provenance_stamp(__name__, module=assembled_results[""module""]),; 'extras': {; 'qcvars': qcvars,; 'cbs_record': copy.deepcopy(self.cbsrec),; },; 'return_result': assembled_results['ret_ptype'],; 'success': True,; }). logger.debug('CBS QCSchema\n' + pp.pformat(cbs_model.dict())). return cbs_model. def get_psi_results(self, return_wfn: bool = False) -> EnergyGradientHessianWfnReturn:; """"""Called by driver to assemble results into Composite-flavored QCSchema,; then reshape and return them in the customary Psi4 driver interface: ``(e/g/h, wfn)``. Parameters; ----------; return_wfn; Whether to additionally return the dummy :py:class:`~psi4.core.Wavefunction`; calculation result as the second element of a tuple. Contents are:. - molecule; - dummy basis, def2-svp; - e/g/h member data; - QCVariables; - module if simple. Returns; -------; ret; Energy, gradient, or Hessian according to self.driver.; wfn; Wavefunction described above when *return_wfn* specified. """"""; cbs_model = self.get_results(). if cbs_model.driver == 'energy':; ret_ptype = cbs_model.return_result; else:; ret_ptype = core.Matrix.from_array(cbs_model.return_result); wfn = _cbs_schema_to_wfn(cbs_model). if return_wfn:; return (ret_ptype, wfn); else:; return ret_ptype. def _cbs_schema_to_wfn(cbs_model):; """"""Helper function to produce Wavefunction from a Composite-flavored AtomicResult."""""". mol = core.Molecule.from_schema(cbs_model.molecule.dict()); basis = core.BasisSet.build(mol, ""ORBITAL"", 'def2-svp', quiet=True); wfn = core.Wavefunction(mol, basis); if hasattr(cbs_model.provenance, ""module""):; wfn.set_module(cbs_model.provenance.module). # wfn.set_energy(cbs_model['extras'['qcvars'].get('CBS TOTAL ENERGY')) # catches Wfn.energy_; for qcv, val in cbs_model.extras['qcvars'].items():; for obj in [core, wfn]:; obj.set_variable(qcv, val). return wfn. «; hide menu. menu; sid",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html:60838,Energy,Energy,60838,psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html,1,['Energy'],['Energy']
Energy Efficiency,"method. run_dftd4() in module qcdb.Molecule. psi4.core.Molecule method. run_gcp() in module qcdb.Molecule. psi4.core.Molecule method. run_gdma() in module psi4.core. RUN_MP2 (FNOCC). RUN_MP3 (FNOCC). RUN_MP4 (FNOCC). S. S (DETCI). s psi4.core.AOShellCombinationsIterator attribute. S() psi4.core.Wavefunction method. s6() psi4.core.Dispersion method. s8() psi4.core.Dispersion method. S_CHOLESKY_TOLERANCE (SCF). S_CUT (DLPNO). S_ORTHOGONALIZATION (SCF). S_TOLERANCE (SCF). sad_ psi4.core.HF attribute. SAD_CHOL_TOLERANCE (SCF). SAD_D_CONVERGENCE (SCF). SAD_E_CONVERGENCE (SCF). SAD_FRAC_OCC (SCF). SAD_MAXITER (SCF). SAD_PRINT (SCF). SAD_SCF_TYPE (SCF). SAD_SPIN_AVERAGE (SCF). SADGuess class in psi4.core. salc_name() psi4.core.CdSalcList method. SalcComponent class in psi4.core. same_a_b_dens() psi4.core.Wavefunction method. same_a_b_orbs() psi4.core.Wavefunction method. sanitize_method() in module psi4.driver. in module psi4.driver.p4util. sanitize_name() in module psi4.driver. SAPT. charge-transfer. higher-order. output. SAPT(DFT). SAPT0. theory. SAPT (SCF). SAPT ALPHA. SAPT CT ENERGY. SAPT DISP ENERGY. SAPT DISP2(CCD) ENERGY. SAPT DISP20 ENERGY. SAPT DISP21 ENERGY. SAPT DISP22(S)(CCD) ENERGY. SAPT DISP22(SDQ) ENERGY. SAPT DISP22(T) ENERGY. SAPT DISP22(T)(CCD) ENERGY. SAPT DISP30 ENERGY. SAPT ELST ENERGY. SAPT ELST EXTERN-EXTERN ENERGY. SAPT ELST10,R ENERGY. SAPT ELST12,R ENERGY. SAPT ELST13,R ENERGY. SAPT ENERGY. SAPT EST.DISP22(T) ENERGY. SAPT EST.DISP22(T)(CCD) ENERGY. SAPT EXCH ENERGY. SAPT EXCH-DISP20 ENERGY. SAPT EXCH-DISP20(S^INF) ENERGY. SAPT EXCH-DISP30 ENERGY. SAPT EXCH-IND-DISP30 ENERGY. SAPT EXCH-IND20,R ENERGY. SAPT EXCH-IND20,U ENERGY. SAPT EXCH-IND22 ENERGY. SAPT EXCH-IND30(S^INF) ENERGY. SAPT EXCH-IND30,R ENERGY. SAPT EXCH-IND30,R(S^INF) ENERGY. SAPT EXCH10 ENERGY. SAPT EXCH10(S^2) ENERGY. SAPT EXCH11(S^2) ENERGY. SAPT EXCH12(S^2) ENERGY. SAPT HF TOTAL ENERGY. SAPT HF(2) ENERGY A(0). SAPT HF(2) ENERGY A(HF). SAPT HF(2) ENERGY AB(HF). SAPT HF(2) ENERGY ABC(",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/genindex.html:98472,charge,charge-transfer,98472,psi4manual/1.7.x/genindex.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/genindex.html,1,['charge'],['charge-transfer']
Energy Efficiency,"method_list, basis_list. def cbs_text_parser(total_method_name: str, **kwargs) -> Dict:; """"""; A text based parser of the CBS method string. Provided to handle ""method/basis""; specification of the requested calculations. Also handles ""simple"" (i.e.; one-method and one-basis) calls. Parameters; ----------; total_method_name; String in a ``""method/basis""`` syntax. Simple calls (e.g. ``""blyp/sto-3g""``) are; bounced out of CBS. More complex calls (e.g. ``""mp2/cc-pv[tq]z""`` or; ``""mp2/cc-pv[tq]z+D:ccsd(t)/cc-pvtz""``) are expanded by `_parse_cbs_gufunc_string()`; and pushed through :py:func:`~psi4.cbs`. Returns; -------; dict of updated CBS keyword arguments; """""". ptype = kwargs.pop('ptype', None). # Sanitize total_method_name; total_method_name = total_method_name.lower(); total_method_name = total_method_name.replace(' ', ''). # Split into components; method_list, basis_list = _parse_cbs_gufunc_string(total_method_name). # Single energy call?; single_call = len(method_list) == 1; single_call &= '[' not in basis_list[0]; single_call &= ']' not in basis_list[0]. if single_call:; method_name = method_list[0]; basis = basis_list[0]. return {'method': method_name, 'basis': basis}. # Drop out for unsupported calls; if ptype is None:; raise ValidationError(""A CBS call was detected, but no ptype was passed in. Please alert a dev.""); elif ptype not in [""energy"", ""gradient"", ""hessian""]:; raise ValidationError(f""{ptype.title()}: Cannot extrapolate or delta correct {ptype} yet.""). # Catch kwarg issues for CBS methods only; user_dertype = kwargs.pop('dertype', None); cbs_verbose = kwargs.pop('cbs_verbose', False). # If we are not a single call, let CBS wrapper handle it!; cbs_kwargs = {}; cbs_kwargs['ptype'] = ptype; cbs_kwargs['verbose'] = cbs_verbose. if user_dertype is not None:; cbs_kwargs['dertype'] = user_dertype. # Find method and basis; metadata = []; if method_list[0] in ['scf', 'hf', 'c4-scf', 'c4-hf']:; stage = {}; stage['wfn'] = method_list[0]; stage['basis'] = basis_list",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html:40610,energy,energy,40610,psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html,2,['energy'],['energy']
Energy Efficiency,"methods can run with a minimal input and set symmetry. x2c3; Test of SFX2C-1e on Water uncontracted cc-pVDZ The reference numbers are from Lan Cheng’s implementation in Cfour. frac; Carbon/UHF Fractionally-Occupied SCF Test Case. sapt2; SAPT0 aug-cc-pVDZ computation of the benzene-methane interaction energy, using the aug-pVDZ-JKFIT DF basis for SCF, the aug-cc-pVDZ-RI DF basis for SAPT0 induction and dispersion, and the aug-pVDZ-JKFIT DF basis for SAPT0 electrostatics and induction. This example uses frozen core as well as asyncronous I/O while forming the DF integrals and CPHF coefficients. nbody-multi-level; Multilevel computation of water trimer energy (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). scf-ecp2; Water-Argon complex with ECP present; check of RHF Hessian. pywrap-align; apply linear fragmentation algorithm to a water cluster. scf-level-shift-rks; SCF level shift on an RKS computation. fci-coverage; 6-31G H2O Test for coverage. dfccsdat1; DF-CCSD(AT) cc-pVDZ energy for the H2O molecule. cc2; 6-31G** H2O CCSD optimization by energies, with Z-Matrix input. omp2-5; SOS-OMP2 cc-pVDZ geometry optimization for the H2O molecule. fsapt-d; Tests SAPT0-D corrections, with a variety of damping functions/parameters. matrix1; An example of using BLAS and LAPACK calls directly from the Psi input file, demonstrating matrix multiplication, eigendecomposition, Cholesky decomposition and LU decomposition. These operations are performed on vectors and matrices provided from the Psi library. mints-helper; A general test of the MintsHelper function. cc10; ROHF-CCSD cc-pVDZ energy for the \(^2\Sigma^+\) state of the CN radical. olccd3; OLCCD cc-pVDZ energy with ROHF initial guess for the NO radical. pywrap-freq-e-sowreap; Finite difference of energies frequency, run in sow/reap mode. dfmp2-3; DF-MP2 cc-pVDZ frozen core gradient of benzene, computed at the DF-SCF cc-pVDZ geometry. cepa2; cc-pvdz H2O Test ACPF Energy/Properties. cc34; RHF-CCSD/cc-pVDZ energy of",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html:44433,energy,energy,44433,psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"metrically displaced ozone, with Z-matrix input. tdscf-2; td-uhf test on triplet states of methylene (tda), wfn passing. mp2-h; check that methods can act on single atom. linK-2; RKS Linear Exchange Algorithm test for benzene. nbody-intermediates; HF/cc-pVDZ many body energies of an arbitrary noble gas trimer complex Size vs cost tradeoff is rough here. pywrap-checkrun-rohf; This checks that all energy methods can run with a minimal input and set symmetry. fsapt-ext-abc2; FSAPT with external charge on dimer. fd-freq-energy; SCF STO-3G finite-difference frequencies from energies for H2O. dft-grad1; DF-BP86-D2 cc-pVDZ frozen core gradient of S22 HCN update ref gradient due to new BraggSlater radii. opt-full-hess-every; SCF/sto-3g optimization with a hessian every step. fsaptd-terms; F-SAPT0/jun-cc-pvdz procedure for methane dimer. dft-jk; DFT JK on-disk test. fd-freq-gradient; SCF STO-3G finite-differences frequencies from gradients for H2O. cc15; RHF-B-CCD(T)/6-31G** H2O single-point energy (fzc, MO-basis \(\langle ab|cd \rangle\)). cc55; EOM-CCSD/6-31g excited state transition data for water with two excited states per irrep. cc13b; Tests RHF CCSD(T)gradients. freq-isotope2; Vibrational and thermo analysis of several water isotopologs. Demonstrates Hessian reuse for different temperatures, pressures, and isotopologs. cc26; Single-point gradient, analytic and via finite-differences of 2-1A1 state of H2O with EOM-CCSD. dct1; DC-06, DC-12, ODC-06 and ODC-12 calculation for the He dimer. This performs a simultaneous update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the MO Basis. olccd-grad2; OLCCD cc-pVDZ gradient for the NO radical. omp2-3; OMP2 cc-pVDZ energy for the NO radical. pywrap-basis; SAPT calculation on bimolecular complex where monomers are unspecified so driver auto-fragments it. Basis set and auxiliary basis sets are assigned by atom type. cbs-xtpl-energy; Extrapolated water energies - density-fitted versi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html:29352,energy,energy,29352,psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"metry Optimization, optimize() and gradient() — Psi4 [1.0.0 6a9a71b] Docs. Navigation. index. modules    . toc    . next    . previous    ; Psi4 [1.0.0 6a9a71b] » ; Psithon Functions: Invoking a Calculation ». Geometry Optimization, optimize() and gradient()¶. Psi4 Native Gradient Methods; Psi4 Native DFT Gradient Methods (excepting double-hybrids); CFOUR Interfaced Gradient Methods. For further discussion of geometry optimization, see; Sec. Geometry Optimization.; optimize() is the only command most users will ever; need to access directly to perform geometry optimizations. Behind; the scenes, optimize() is a wrapper that repeatedly; calls gradient() that computes the gradient then adds a; call to the geometry projection module. optimize(name[, molecule, return_wfn, func, mode, dertype, hessian_with])[source]¶; Function to perform a geometry optimization. Aliases:opt(). Returns:float – Total electronic energy of optimized structure in Hartrees. Returns:(float, Wavefunction) – energy and wavefunction when return_wfn specified. PSI variables:. CURRENT ENERGY. Parameters:; name (string) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || 'off' ; Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/opt-1.html:998,energy,energy,998,psi4manual/1.0.0/opt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/opt-1.html,2,['energy'],['energy']
Energy Efficiency,"metry Optimization.; optimize() is the only command most users will ever; need to access directly to perform geometry optimizations. Behind; the scenes, optimize() is a wrapper that repeatedly; calls gradient() that computes the gradient then adds a; call to the geometry projection module. optimize(name[, molecule, return_wfn, func, mode, dertype, hessian_with])[source]¶; Function to perform a geometry optimization. Aliases:opt(). Returns:float – Total electronic energy of optimized structure in Hartrees. Returns:(float, Wavefunction) – energy and wavefunction when return_wfn specified. PSI variables:. CURRENT ENERGY. Parameters:; name (string) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || 'off' ; Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. For maximum; flexibility, return_wfn is always on in 'reap' mode. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimiza",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/opt-1.html:1518,energy,energy,1518,psi4manual/1.0.0/opt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/opt-1.html,2,['energy'],['energy']
Energy Efficiency,"metry c2 # Two irreps is easier to comprehend; }. set {; s_tolerance 0.0001 # Set an unreasonably tight; # tolerance to force canonical; basis aug-cc-pv5z # This diffuse basis will have; # small-ish eigenvalues for even H2O; }. energy('scf'). Output:; ... Initialization ... ==> Pre-Iterations <==. Minimum eigenvalue in the overlap matrix is 1.6888059293E-05.; Using Canonical Orthogonalization with cutoff of 1.0000000000E-04.; Overall, 3 of 287 possible MOs eliminated. ... Initial Orbital Guess Information ... -------------------------------------------------------; Irrep Nso Nmo Nalpha Nbeta Ndocc Nsocc; -------------------------------------------------------; A 145 144 3 3 3 0; B 142 140 2 2 2 0; -------------------------------------------------------; Total 287 284 5 5 5 0; -------------------------------------------------------. In this example, there are 287 AO basis functions after spherical harmonics are; applied. These are used to produce 287 symmetry adapted USOs, 145 of which are; assigned to irrep A, and 142 of which are assigned to irrep B. Within irrep A,; 144 OSOs fall above the eigenvalue cutoff, and within irrep B 140 OSOs fall; above the eigenvalue cutoff. In total, 284 molecular orbitals are chosen from; 287 AOs/USOs. The table also shows the initial assignment of electrons to; irreps. Initial Guess/Convergence Stabilization¶; In each step of the SCF procedure, a new Fock or Kohn–Sham potential is built; according to the previous density, following which the potential is diagonalized; to produce new molecular orbitals, from which a new density is computed. This; procedure is continued until either convergence is reached or a preset maximum; number of iterations is exceeded. Convergence is determined by both change in; energy and root-mean-square change in density matrix values, which must be below; the user-specified E_CONVERGENCE and D_CONVERGENCE, respectively.; The maximum number of iterations is specified by the MAXITER option. It; should be not",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/scf-1.html:12757,adapt,adapted,12757,psi4manual/1.0.0/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/scf-1.html,10,['adapt'],['adapted']
Energy Efficiency,"metry is fully supported in PSI4 and can be used to; obtain physical interpretation of the molecular orbitals, to assist in difficult; convergence cases, and, in some methods, to obtain significant performance; gains. The point group of the molecule is inferred when reading the molecule; section, and may be overridden by the symmetry flag, as in:; molecule h {; 0 2; H; symmetry c1; }. or by the reset_point_group Python molecule attribute:; h.reset_point_group('c2v'). During the SCF procedure, the occupation of orbitals is typically determined by; the Aufbau principal across all spatial symmetries. This may result in the; occupation shifting between iterations. If the occupations are known a priori,; they may be clamped throughout the procedure by using the DOCC and; SOCC options. For instance, all good quantum chemists know that; \(C_{2v}\) water is; actually,:; molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; docc [3, 0, 1, 1] # 1A1 2A1 1B1 3A1 1B2; basis cc-pvdz; }. energy('scf'). Broken Symmetry¶; For certain problems, such diradicals, allowing the spin-up and spin-down; orbitals to differ in closed-shell computations can be advantageous;; this is known as symmetry breaking. The resulting unrestricted wavefunction; will often provide superior energetics, due to the increased flexibility,; but it will suffer non-physical spin contamination from higher multiplicity states.; A convenient approach to break symmetry is to perform a UHF or UKS calculation; with the guess HOMO and LUMO orbitals mixed.; Mixing of the guess orbitals can be requested by setting the GUESS_MIX; keyword to true:; set reference uhf; set guess_mix true; energy('scf'). Orthogonalization¶; One of the first steps in the SCF procedure is the determination of an; orthogonal basis (known as the OSO basis) from the atomic orbital; basis (known as the AO basis). The Molecular Orbital basis (MO basis); is then built as a particular unitary transformation of the OSO; basis. In PSI4, the determi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/scf-1.html:10648,energy,energy,10648,psi4manual/1.4.0/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/scf-1.html,9,['energy'],['energy']
Energy Efficiency,"metry optimzation, with Z-matrix input. pywrap-checkrun-convcrit; Advanced python example sets different sets of scf/post-scf conv crit and check to be sure computation has actually converged to the expected accuracy. cc13a; UHF-CCSD(T)/cc-pVDZ CH2 geometry optimization via analytic gradients. mints9; A test of the basis specification. Various basis sets are specified outright and in blocks, both orbital and auxiliary. Constructs libmints BasisSet objects through the constructor that calls qcdb.BasisSet infrastructure. Checks that the resulting bases are of the right size and checks that symmetry of the Molecule observes the basis assignment to atoms. dfccsdl1; DF-CCSDL cc-pVDZ energy for the H2O molecule. dfmp2-4; conventional and density-fitting mp2 test of mp2 itself and setting scs-mp2. tu2-ch2-energy; Sample UHF/6-31G** CH2 computation. mcscf2; TCSCF cc-pVDZ energy of asymmetrically displaced ozone, with Z-matrix input. mints6; Patch of a glycine with a methyl group, to make alanine, then DF-SCF energy calculation with the cc-pVDZ basis set. sapt3; SAPT2+3(CCD) aug-cc-pVDZ computation of the water dimer interaction energy, using the aug-cc-pVDZ-JKFIT DF basis for SCF and aug-cc-pVDZ-RI for SAPT. cc16; ROHF and UHF-B-CCD(T)/cc-pVDZ CH2 single-point energy (fzc, MO-basis ). dcft-grad4; Unrestricted DF-DCFT ODC-12 gradient for O2 with cc-pVTZ/cc-pVTZ-RI standard/auxiliary basis set. mints8; Patch of a glycine with a methyl group, to make alanine, then DF-SCF energy calculation with the cc-pVDZ basis set. ocepa-grad1; OCEPA cc-pVDZ gradient for the H2O molecule. fd-gradient; SCF STO-3G finite-difference tests. psimrcc-sp1; Mk-MRCCSD single point. O2 state described using the Ms = 0 component of the triplet. Uses ROHF triplet orbitals. pywrap-db3; Test that Python Molecule class processes geometry like psi4 Molecule class. cc44; Test case for some of the PSI4 out-of-core codes. The code is given only 2.0 MB of memory, which is insufficient to hold either the A1 or B",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html:8153,energy,energy,8153,psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"me}} \left(E_{\text{corl},\; \textbf{delta3_wfn}}^{\textbf{delta3_basis}}\right) - \mathcal{F}_{\textbf{delta3_scheme}} \left(E_{\text{corl},\; \textbf{delta3_wfn_lesser}}^{\textbf{delta3_basis}}\right)\]. \[\delta_{\textbf{delta4_wfn_lesser}}^{\textbf{delta4_wfn}} \; = \mathcal{F}_{\textbf{delta4_scheme}} \left(E_{\text{corl},\; \textbf{delta4_wfn}}^{\textbf{delta4_basis}}\right) - \mathcal{F}_{\textbf{delta4_scheme}} \left(E_{\text{corl},\; \textbf{delta4_wfn_lesser}}^{\textbf{delta4_basis}}\right)\]. \[\delta_{\textbf{delta5_wfn_lesser}}^{\textbf{delta5_wfn}} \; = \mathcal{F}_{\textbf{delta5_scheme}} \left(E_{\text{corl},\; \textbf{delta5_wfn}}^{\textbf{delta5_basis}}\right) - \mathcal{F}_{\textbf{delta5_scheme}} \left(E_{\text{corl},\; \textbf{delta5_wfn_lesser}}^{\textbf{delta5_basis}}\right)\]; A translation of this ungainly equation to example [5] below is as; follows. In words, this is a double- and triple-zeta 2-point; Helgaker-extrapolated CCSD(T) coupled-cluster correlation correction; appended to a triple- and quadruple-zeta 2-point; Helgaker-extrapolated MP2 correlation energy appended to a SCF/aug-cc-pVQZ; reference energy. \[E_{\text{total}}^{\text{CBS}} = \mathcal{F}_{\text{highest_1}} \left(E_{\text{total},\; \text{SCF}}^{\text{aug-cc-pVQZ}}\right) \; + \mathcal{F}_{\text{corl_xtpl_helgaker_2}} \left(E_{\text{corl},\; \text{MP2}}^{\text{aug-cc-pV[TQ]Z}}\right) \; + \delta_{\text{MP2}}^{\text{CCSD(T)}}\]. \[\delta_{\text{MP2}}^{\text{CCSD(T)}} \; = \mathcal{F}_{\text{corl_xtpl_helgaker_2}} \left(E_{\text{corl},\; \text{CCSD(T)}}^{\text{aug-cc-pV[DT]Z}}\right) - \mathcal{F}_{\text{corl_xtpl_helgaker_2}} \left(E_{\text{corl},\; \text{MP2}}^{\text{aug-cc-pV[DT]Z}}\right)\]. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Psithon Functions: Invoking a Calculation; Complete Basis Set. © Copyright 2019, The Psi4 Project.; Last updated on Wednesday, 15 May 2019 08:49PM.; Created using Sphinx 1.8.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/cbs_eqn-1.html:2600,energy,energy,2600,psi4manual/1.3.2/cbs_eqn-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/cbs_eqn-1.html,4,['energy'],['energy']
Energy Efficiency,"miniconda has; already been installed (instructions at Quick Installation),; the gcp executable can be obtained through conda install gcp -c psi4; or conda install gcp-correction -c conda-forge.; To remove a conda installation, conda remove gcp or conda remove gcp-correction. Source. If using PSI4 built from source and you want to build gCP from; from source also, follow the instructions provided with the source; (essentially, download the freely available tarball, unpack the source,; edit the Makefile to select a Fortran compiler, and run make). To be used by PSI4, the program binary (gcp or mctc-gcp) must be; found in your PATH so that QCEngine can detect it. Check if and where; found through qcengine info. If; PSI4 is unable to execute the binary, an error will be reported.; To preferentially use a particular gcp compilation, simply adjust its; position in the path environment variables. Running gCP¶; At present there is a limited interface to gCP that is used; only to implement the “HF-3c” [Sure:2013:1672] and “PBEh-3c”; [Grimme:2015:054107] methods (both energy and gradient). The interface; can use classic or mctc-gcp executables interchangeably and will prefer the latter.; A DFTD3 executable, classic or simple-dftd3,; must also be available for these methods to; run. Unlike every other method in PSI4, if a basis set has not been; set, these will default to their intended basis sets: MINIX for HF-3c; and def2-mSVP for PBEh-3c. If a basis has previously been set, but you; want to use the default basis, use the slash syntax to “empty” the basis; option for the scope of the current calculation, energy(""hf3c/"").; A few practical examples:. HF-3c single point with default minix basis; energy('hf3c'). PBEh-3c optimization with default def2-mSVP basis; optimize('pbeh3c'). HF-3c with non-standard basis; set basis cc-pvdz; energy('hf3c'). PBEh-3c with default basis after basis set; set basis cc-pvdz; energy('pbeh3c/'). If only BSSE/basis set corrections (rather than tot",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/gcp.html:2018,energy,energy,2018,psi4manual/1.7.x/gcp.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/gcp.html,2,['energy'],['energy']
Energy Efficiency,"minimum). Type: integer; Default: 0. STEP_TYPE¶. Geometry optimization step type, either Newton-Raphson or Rational Function Optimization. Type: string; Possible Values: RFO, NR, SD, LINESEARCH_STATIC; Default: RFO. Convergence Control¶. FLEXIBLE_G_CONVERGENCE¶. Even if a user-defined threshold is set, allow for normal, flexible convergence criteria. Type: boolean; Default: false. G_CONVERGENCE¶. Set of optimization criteria. Specification of any MAX_*_G_CONVERGENCE or RMS_*_G_CONVERGENCE options will append to overwrite the criteria set here unless FLEXIBLE_G_CONVERGENCE is also on. See Table Geometry Convergence for details. Type: string; Possible Values: QCHEM, MOLPRO, GAU, GAU_LOOSE, GAU_TIGHT, GAU_VERYTIGHT, TURBOMOLE, CFOUR, NWCHEM_LOOSE; Default: QCHEM. MAX_DISP_G_CONVERGENCE¶. Convergence criterion for geometry optmization: maximum displacement (internal coordinates, atomic units). Type: conv double; Default: 1.2e-3. MAX_ENERGY_G_CONVERGENCE¶. Convergence criterion for geometry optmization: maximum energy change. Type: conv double; Default: 1.0e-6. MAX_FORCE_G_CONVERGENCE¶. Convergence criterion for geometry optmization: maximum force (internal coordinates, atomic units). Type: conv double; Default: 3.0e-4. RMS_DISP_G_CONVERGENCE¶. Convergence criterion for geometry optmization: rms displacement (internal coordinates, atomic units). Type: conv double; Default: 1.2e-3. RMS_FORCE_G_CONVERGENCE¶. Convergence criterion for geometry optmization: rms force (internal coordinates, atomic units). Type: conv double; Default: 3.0e-4. Hessian Update¶. CART_HESS_READ¶. Do read Cartesian Hessian? Only for experts - use FULL_HESS_EVERY instead. Type: boolean; Default: false. FULL_HESS_EVERY¶. Frequency with which to compute the full Hessian in the course of a geometry optimization. 0 means to compute the initial Hessian only, 1 means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodir_options_c/module__optking-1.html:2822,energy,energy,2822,psi4manual/4.0b4/autodir_options_c/module__optking-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodir_options_c/module__optking-1.html,8,['energy'],['energy']
Energy Efficiency,"mints2; A test of the basis specification. A benzene atom is defined using a ZMatrix containing dummy atoms and various basis sets are assigned to different atoms. The symmetry of the molecule is automatically lowered to account for the different basis sets. adc2; ADC(2)/aug-cc-pVDZ on two water molecules that are distant from 1000 angstroms from each other. cc41; RHF-CC2-LR/cc-pVDZ optical rotation of H2O2. gauge = both, omega = (589 355 nm). mp2-def2; Test case for Binding Energy of C4H5N (Pyrrole) with CO2 using MP2/def2-TZVPP. dft-reference; MP2 with a PBE0 reference computation. pywrap-bfs; apply linear fragmentation algorithm to a water cluster. castup1; Test of SAD/Cast-up (mainly not dying due to file weirdness). mcscf1; ROHF 6-31G** energy of the \(^{3}B_1\) state of CH2, with Z-matrix input. The occupations are specified explicitly. cbs-xtpl-opt; Various extrapolated optimization methods for the H2 molecule. dft-jk; DFT JK on-disk test. sapt-dft-lrc; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. cbs-xtpl-alpha; Extrapolated water energies. dft-dldf; Dispersionless density functional (dlDF+D) internal match to Psi4 Extensive testing has been done to match supplemental info of Szalewicz et. al., Phys. Rev. Lett., 103, 263201 (2009) and Szalewicz et. al., J. Phys. Chem. Lett., 1, 550-555 (2010). opt3; SCF cc-pVDZ geometry optimzation, with Z-matrix input. mcscf3; RHF 6-31G** energy of water, using the MCSCF module and Z-matrix input. scf-dipder; Test SCF dipole derivatives against old Psi3 reference values. dfccsdat1; DF-CCSD(AT) cc-pVDZ energy for the H2O molecule. pywrap-checkrun-rohf; This checks that all energy methods can run with a minimal input and set symmetry. cc4a; RHF-CCSD(T) cc-pVQZ frozen-core energy of the BH molecule, with Cartesian input. This version tests the FROZEN_DOCC option explicitly. dft-psivar; HF and DFT variants single-points on zmat methane, mostly to test that PSI variables are set and computed correctly. Now a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html:14385,energy,energy,14385,psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"mistry, and complete lack of a derivative discontinuity in the; chemical potential as integer particle numbers are crossed. On the correlation; side, this is primarily observed in the inability of KS-DFT to treat dispersion; interactions.; Generalized Kohn-Sham (GKS) functionals incorporate long-range information into; the functional through orbital-dependent contributions, and are designed to; combat the failures of local KS-DFT, particularly the MSIE on the exchange side.; Note that these functionals are often referred to as “implicit” density; functionals, as the orbitals are themselves functionals of the Kohn-Sham; potential.; The simplest form of an exchange-side GKS is the global hybrid ansatz, in which; some fraction of the exact Hartree-Fock exchange of the noninteracting; quasiparticles is added to the functional, with the local part of the exchange; functional decreased by the corresponding amount. Note that the term; “exact-exchange” refers to the Hartree-Fock being the exact exchange energy of; the noninteracting quasiparticles, not the true electrons. Therefore, adding; 100% exact exchange is not physically reasonable, and will often lead to; extremely poor results. The fraction of exact-exchange, denoted ,; is often determined by adiabatic or heuristic arguments, and is typically around; 25%. The addition of exact exchange borrows another piece from an existing; Hartree-Fock code, with the caveat that Hartree-Fock exchange is often much more; costly to obtain than the Coulomb matrix. The global hybrid ansatz has become; exceedingly popular, with functionals such as the ubiquitous B3LYP often; producing absurdly accurate results.; A more advanced GKS functional technology which has developed enormous; popularity in recent years is the Long-Range Corrected (LRC) ansatz. LRC; recognizes that the local DFA is potentially exact at short range in the; exchange hole, and that the hybrid-exchange energy of the noninteracting; quasiparticles is also exact for tr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/dft-1.html:5549,energy,energy,5549,psi4manual/1.0.0/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/dft-1.html,10,['energy'],['energy']
Energy Efficiency,"mistry, and complete lack of a derivative discontinuity in the; chemical potential as integer particle numbers are crossed. On the correlation; side, this is primarily observed in the inability of KS-DFT to treat dispersion; interactions.; Generalized Kohn–Sham (GKS) functionals incorporate long-range information into; the functional through orbital-dependent contributions, and are designed to; combat the failures of local KS-DFT, particularly the MSIE on the exchange side.; Note that these functionals are often referred to as “implicit” density; functionals, as the orbitals are themselves functionals of the Kohn–Sham; potential.; The simplest form of an exchange-side GKS is the global hybrid ansatz, in which; some fraction of the exact Hartree–Fock exchange of the noninteracting; quasiparticles is added to the functional, with the local part of the exchange; functional decreased by the corresponding amount. Note that the term; “exact-exchange” refers to the Hartree–Fock being the exact exchange energy of; the noninteracting quasiparticles, not the true electrons. Therefore, adding; 100% exact exchange is not physically reasonable, and will often lead to; extremely poor results. The fraction of exact-exchange, denoted \(\alpha\),; is often determined by adiabatic or heuristic arguments and is typically around; 25%. The addition of exact exchange borrows another piece from an existing; Hartree–Fock code, with the caveat that Hartree–Fock exchange is often much more; costly to obtain than the Coulomb matrix. The global hybrid ansatz has become; exceedingly popular, with functionals such as the ubiquitous B3LYP often; producing absurdly accurate results.; A more advanced GKS functional technology which has developed enormous; popularity in recent years is the Long-Range Corrected (LRC) ansatz. LRC; recognizes that the local DFA is potentially exact at short range in the; exchange hole, and that the hybrid-exchange energy of the noninteracting; quasiparticles is also exa",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/dft-1.html:8051,energy,energy,8051,psi4manual/1.2.1/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/dft-1.html,15,['energy'],['energy']
Energy Efficiency,"mization — optimize() and gradient(). Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Psithon Functions: Invoking a Calculation; Geometry Optimization — optimize() and gradient(). Geometry Optimization — optimize() and gradient()¶. Psi4 Native Gradient Methods; Psi4 Native DFT Gradient Methods (excepting double-hybrids); CFOUR Interfaced Gradient Methods. For further discussion of geometry optimization, see; Sec. Geometry Optimization.; optimize() is the only command most users will ever; need to access directly to perform geometry optimizations. Behind; the scenes, optimize() is a wrapper that repeatedly; calls gradient() that computes the gradient then adds a; call to the geometry optimization module. psi4.optimize(name[, molecule, return_wfn, func, mode, dertype, hessian_with])[source]; Function to perform a geometry optimization. Aliases; opt(). Returns; float – Total electronic energy of optimized structure in Hartrees. Returns; (float, Wavefunction) – energy and wavefunction when return_wfn specified. Raises; psi4.OptimizationConvergenceError if GEOM_MAXITER exceeded without reaching geometry convergence. PSI variables. CURRENT ENERGY. Parameters. name (str) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; psi4.energy(). molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. return_history (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. engine (str) – \(\Rightarrow\) 'optking' \(\Leftarrow\) || 'geometric'; Indicates the optimization engine to use, which can be either",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/opt-1.html:1008,energy,energy,1008,psi4manual/1.4.0/opt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/opt-1.html,2,['energy'],['energy']
Energy Efficiency,"mization — optimize() and gradient(). Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Psithon Functions: Invoking a Calculation; Geometry Optimization — optimize() and gradient(). Geometry Optimization — optimize() and gradient()¶. Psi4 Native Gradient Methods; Psi4 Native DFT Gradient Methods (excepting double-hybrids); CFOUR Interfaced Gradient Methods. For further discussion of geometry optimization, see; Sec. Geometry Optimization.; optimize() is the only command most users will ever; need to access directly to perform geometry optimizations. Behind; the scenes, optimize() is a wrapper that repeatedly; calls gradient() that computes the gradient then adds a; call to the geometry optimization module. psi4.optimize(name[, molecule, return_wfn, func, mode, dertype, hessian_with])[source]; Function to perform a geometry optimization. Aliases; opt(). Returns; float – Total electronic energy of optimized structure in Hartrees. Returns; (float, Wavefunction) – energy and wavefunction when return_wfn specified. Raises; psi4.OptimizationConvergenceError if GEOM_MAXITER exceeded without reaching geometry convergence. PSI variables. CURRENT ENERGY. Parameters. name (str) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; psi4.energy(). molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. return_history (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. engine (str) – \(\Rightarrow\) 'optking' \(\Leftarrow\) || 'geometric'; Indicates the optimization engine to use, which can be either",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/opt-1.html:1008,energy,energy,1008,psi4manual/1.5.0/opt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/opt-1.html,2,['energy'],['energy']
Energy Efficiency,"mization — optimize() and gradient(). Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Psithon Functions: Invoking a Calculation; Geometry Optimization — optimize() and gradient(). Geometry Optimization — optimize() and gradient()¶. Psi4 Native Gradient Methods; Psi4 Native DFT Gradient Methods (excepting double-hybrids); CFOUR Interfaced Gradient Methods. For further discussion of geometry optimization, see; Sec. Geometry Optimization.; optimize() is the only command most users will ever; need to access directly to perform geometry optimizations. Behind; the scenes, optimize() is a wrapper that repeatedly; calls gradient() that computes the gradient then adds a; call to the geometry optimization module. psi4.optimize(name[, molecule, return_wfn, func, mode, dertype, hessian_with])[source]; Function to perform a geometry optimization. Aliases; opt(). Returns; float – Total electronic energy of optimized structure in Hartrees. Returns; (float, Wavefunction) – energy and wavefunction when return_wfn specified. Raises; psi4.OptimizationConvergenceError if GEOM_MAXITER exceeded without reaching geometry convergence. PSI variables. CURRENT ENERGY. Parameters. name (str) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; psi4.energy(). molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. return_history (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. engine (str) – \(\Rightarrow\) 'optking' \(\Leftarrow\) || 'geometric'; Indicates the optimization engine to use, which can be either",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/opt.html:1008,energy,energy,1008,psi4manual/1.6.x/opt.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/opt.html,1,['energy'],['energy']
Energy Efficiency,"mizations of HOOH with cc-pvdz RHF. For “fixed” coordinates, the final value is provided by the user. cc13a; UHF-CCSD(T)/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. fsapt2; A very quick correctness test of F-SAPT (see fsapt1 for a real example). pubchem1; Benzene vertical singlet-triplet energy difference computation, using the PubChem database to obtain the initial geometry, which is optimized at the HF/STO-3G level, before computing single point energies at the RHF, UHF and ROHF levels of theory. opt3; SCF cc-pVDZ geometry optimzation, with Z-matrix input. frac-traverse; Scan fractional occupation of electrons updated values due to new BraggSlater radii. nbody-convergence; Convergence of many-body gradients of different BSSE schemes. cbs-xtpl-alpha; Extrapolated water energies. extern3; External potential calculation with one Ghost atom and one point charge at the same position. sapt-exch-disp-inf; SAPT0 with S^inf exch-disp20. cbs-delta-energy; Extrapolated energies with delta correction. dft1; DFT Functional Test all values update for new BraggSlater radii. scf-coverage; Lithium test for coverage. soscf-dft; Triple and Singlet Oxygen energy SOSCF, also tests non-symmetric density matrices. dft-custom-mgga; updated dldf reference to new BraggSlater radii Dispersionless density functional (dlDF+D) internal match to Psi4 Extensive testing has been done to match supplemental info of Szalewicz et. al., Phys. Rev. Lett., 103, 263201 (2009) and Szalewicz et. al., J. Phys. Chem. Lett., 1, 550-555 (2010). dft-vv10; He Dimer VV10 functional test. notes: DFT_VV10_B/C overwrites the NL_DISPERSION_PARAMETERS tuple updated ‘bench’ reference values for new BraggSlater radii. fsapt1; This test case shows an example of running and analyzing a standard F-SAPT0/jun-cc-pvdz procedure for phenol dimer from the S22 database. dfccsd-grad1; DF-CCSD cc-pVDZ gradients for the H2O molecule. numpy-array-interface; Numpy interface testing. tu1-h2o-energy; Sample HF/",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html:36132,energy,energy,36132,psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"mizer.gradx.reshape(-1,3))). return_energy = optimizer.E; opt_geometry = core.Matrix.from_array(optimizer.X.reshape(-1,3)); molecule.set_geometry(opt_geometry); molecule.update_geometry(); core.print_out(f'\n Final Energy : {return_energy} \n'); core.print_out('\n Final Geometry : \n'); molecule.print_in_input_format(). if return_history:; history = {; 'energy': step_energies,; 'gradient': step_gradients,; 'coordinates': step_coordinates,; }. if return_wfn:; wfn = engine.p4_wfn. if return_wfn and return_history:; return (return_energy, wfn, history); elif return_wfn and not return_history:; return (return_energy, wfn); elif return_history and not return_wfn:; return (return_energy, history); else:; return return_energy. [docs]; def optimize(name, **kwargs):; r""""""Function to perform a geometry optimization. :aliases: opt(). :returns: *float* |w--w| Total electronic energy of optimized structure in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :raises: :py:class:`psi4.driver.OptimizationConvergenceError` if :term:`GEOM_MAXITER <GEOM_MAXITER (OPTKING)>` exceeded without reaching geometry convergence. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY`. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`psi4.driver.energy`. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple. :type return_history: :ref:`boolean <op_py_boolean>`; :param return_history: ``'on'`` || |dl| ``'off'`` |d",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:61148,energy,energy,61148,psi4manual/1.8.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html,6,['energy'],['energy']
Energy Efficiency,"mmetry type a zero must be entered. If the reference function is for an open-shell system, two strings of NIRREP occupation numbers separated by a slash are input for the \(\alpha\) and \(\beta\) sets of orbitals. An example of the use of the OCCUPATION keyword for the water molecule would be OCCUPATION=3-1-1-0. For the \(^2A_1\) water cation, an open-shell system, the keyword would be specified by OCCUPATION=3-1-1-0/2-1-1-0. It should be noted that the xvmol integral program orders the irreducible representations in a strange way, which most users do not perceive to be a logical order. Hence, it is usually advisable initially to run just a single point integral and HF-SCF calculation in order to determine the number and ordering of the irreducible representations. The occupation keyword may be omitted, in which case an initial orbital occupancy is determined by diagonalization of the core Hamiltonian. In many cases, HF-SCF calculations run with the core Hamiltonian guess will usually converge to the lowest energy HF-SCF solution, but this should not be blindly assumed. (Default: The occupation is given by the core Hamiltonian initial guess). Psi4 Interface: The arrays above are specified in PSI as (white space tolerant) [3,1,1,0] and [[3,1,1,0],[3,0,1,0]]. Type: array; Default: No Default. CFOUR_OMP_NUM_THREADS (CFOUR); CFOUR (Expert) — Sets the OMP_NUM_THREADS environment variable before calling CFOUR. If the environment variable OMP_NUM_THREADS is set prior to calling Psi4 then that value is used. When set, this option overrides everything. Be aware the -n command-line option described in section Threading does not affect CFOUR. Type: integer; Default: 1. CFOUR_OPEN-SHELL (CFOUR); CFOUR — Specifies which kind of open-shell CC treatment is employed. The default is a spin-orbital CC treatment (SPIN-ORBITAL =1) which is the only possible choice for UHF-CC schemes anyways. For ROHF-CC treatments, the possible options are beside the standard spin-orbital scheme a spin-",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html:60604,energy,energy,60604,psi4manual/1.2.1/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html,6,['energy'],['energy']
Energy Efficiency,"mmetry type a zero must be entered. If the reference function is for an open-shell system, two strings of NIRREP occupation numbers separated by a slash are input for the \(\alpha\) and \(\beta\) sets of orbitals. An example of the use of the OCCUPATION keyword for the water molecule would be OCCUPATION=3-1-1-0. For the \(^2A_1\) water cation, an open-shell system, the keyword would be specified by OCCUPATION=3-1-1-0/2-1-1-0. It should be noted that the xvmol integral program orders the irreducible representations in a strange way, which most users do not perceive to be a logical order. Hence, it is usually advisable initially to run just a single point integral and HF-SCF calculation in order to determine the number and ordering of the irreducible representations. The occupation keyword may be omitted, in which case an initial orbital occupancy is determined by diagonalization of the core Hamiltonian. In many cases, HF-SCF calculations run with the core Hamiltonian guess will usually converge to the lowest energy HF-SCF solution, but this should not be blindly assumed. (Default: The occupation is given by the core Hamiltonian initial guess). Psi4 Interface: The arrays above are specified in PSI as (white space tolerant) [3,1,1,0] and [[3,1,1,0],[3,0,1,0]]. Type: array; Default: No Default. CFOUR_OMP_NUM_THREADS (CFOUR)¶CFOUR (Expert) — Sets the OMP_NUM_THREADS environment variable before calling CFOUR. If the environment variable OMP_NUM_THREADS is set prior to calling Psi4 then that value is used. When set, this option overrides everything. Be aware the -n command-line option described in section Threading does not affect CFOUR. Type: integer; Default: 1. CFOUR_OPEN-SHELL (CFOUR)¶CFOUR — Specifies which kind of open-shell CC treatment is employed. The default is a spin-orbital CC treatment (SPIN-ORBITAL =1) which is the only possible choice for UHF-CC schemes anyways. For ROHF-CC treatments, the possible options are beside the standard spin-orbital scheme a spin-re",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html:60904,energy,energy,60904,psi4manual/1.4.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html,9,['energy'],['energy']
Energy Efficiency,"mmetry type a zero must be entered. If the reference function is for an open-shell system, two strings of NIRREP occupation numbers separated by a slash are input for the \(\alpha\) and \(\beta\) sets of orbitals. An example of the use of the OCCUPATION keyword for the water molecule would be OCCUPATION=3-1-1-0. For the \(^2A_1\) water cation, an open-shell system, the keyword would be specified by OCCUPATION=3-1-1-0/2-1-1-0. It should be noted that the xvmol integral program orders the irreducible representations in a strange way, which most users do not perceive to be a logical order. Hence, it is usually advisable initially to run just a single point integral and HF-SCF calculation in order to determine the number and ordering of the irreducible representations. The occupation keyword may be omitted, in which case an initial orbital occupancy is determined by diagonalization of the core Hamiltonian. In many cases, HF-SCF calculations run with the core Hamiltonian guess will usually converge to the lowest energy HF-SCF solution, but this should not be blindly assumed. (Default: The occupation is given by the core Hamiltonian initial guess). Psi4 Interface: The arrays above are specified in PSI as (white space tolerant) [3,1,1,0] and [[3,1,1,0],[3,0,1,0]]. Type: array; Default: No Default. CFOUR_OPEN-SHELL¶. Specifies which kind of open-shell CC treatment is employed. The default is a spin-orbital CC treatment (SPIN-ORBITAL =1) which is the only possible choice for UHF-CC schemes anyways. For ROHF-CC treatments, the possible options are beside the standard spin-orbital scheme a spin-restricted CC approach (SR-CC=3), as well as a corresponding linear approximation (which in the literature usually is referred to as partially-spin-adapted CC scheme) (PSA-CC=1). SR-CC and PSA-CC are within the CCSD approximation restricted to excitations defined by the first-order interacting space arguments. With the keywords PSA-CC_FULL (=2) or SR-CC_FULL (=6) inclusion of the so call",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__cfour-1.html:41909,energy,energy,41909,psi4manual/1.3.2/autodir_options_c/module__cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__cfour-1.html,24,['energy'],['energy']
Energy Efficiency,"mme’s J. Chem. Phys 124 034108 (2006) paper defining the functional. cc38; RHF-CC2-LR/cc-pVDZ static polarizabilities of HOF molecule. oremp-grad2; integral conventional OO-REMP/cc-pVDZ engrad single points for the H2O molecule. single point energies were independently checked using the original wavels code. cc37; CC2(UHF)/cc-pVDZ energy of H2O+. scf-uhf-grad-nobeta; UHF gradient for a one-electron system (no beta electrons). dft3; DFT integral algorithms test, performing w-B97 RKS and UKS computations on water and its cation, using all of the different integral algorithms. This tests both the ERI and ERF integrals. omp3-4; SCS-OMP3 cc-pVDZ geometry optimization for the H2O molecule. oremp-grad1; integral conventional OO-REMP/cc-pVDZ engrad single points for the H2O molecule. fnocc6; Test method/basis with disk_df. cisd-h2o+-1; 6-31G** H2O+ Test CISD Energy Point. ddd-function-kwargs; check distributed driver is correctly passing function kwargs. dfomp2p5-1; DF-OMP2.5 cc-pVDZ energy for the H2O molecule. opt9; Various constrained energy minimizations of HOOH with cc-pvdz RHF. Cartesian-coordinate constrained optimizations of HOOH in internals. cbs-xtpl-energy; Extrapolated water energies - density-fitted version. mints12; test roundtrip-ness of dict repr for psi4.core.Molecule and qcdb.Molecule. pywrap-all; Intercalls among python wrappers- database, cbs, optimize, energy, etc. Though each call below functions individually, running them all in sequence or mixing up the sequence is aspirational at present. Also aspirational is using the intended types of gradients. mbis-5; MBIS calculation on ZnO. sapt8; SAPT0(ROHF) open-shell computation of CN - Ne interaction energy First with jun-cc-pVDZ and density fitted integrals with ROHF Then with cc-pVDZ and direct integrals, except for dispersion that is computed with cc-pVDZ-ri density fitting with ROHF. cc24; Single point gradient of 1-2B1 state of H2O+ with EOM-CCSD. cc3; cc3: RHF-CCSD/6-31G** H2O geometry optimization a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html:10372,energy,energy,10372,psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"mme’s dispersion corrections are discussed here.; The corresponding method, termed SAPT0-D, thus relies on empirically fit parameters; specific to SAPT0/jun-cc-pVDZ. While SAPT0-D can be used with any of the -D; variants using default parameters optimized for Hartee–Fock interaction energies,; we recommend using the refit parameters with Becke-Johnson damping, as described in; [Schriber:2021:234107]. Again, use of SAPT0-D with a basis set other than; jun-cc-pVDZ is not tested and not guaranteed to give meaningful results without; refitting the dispersion parameters.; A simple water dimer computation using SAPT0-D may look like:; molecule water_dimer {; 0 1; O -1.551007 -0.114520 0.000000; H -1.934259 0.762503 0.000000; H -0.599677 0.040712 0.000000; --; 0 1; O 1.350625 0.111469 0.000000; H 1.680398 -0.373741 -0.758561; H 1.680398 -0.373741 0.758561. units angstrom; no_reorient; symmetry c1; }. set basis jun-cc-pvdz. energy('sapt0-d3mbj') # runs the recommended dispersion correction; energy('sapt0-d3') # tests an alternative damping scheme/parameterization. Given the naturally pairwise-atomic nature of these empirical dispersion corrections,; integration with existing FSAPT functionality is also available simply by calling; energy(""fsapt0-d3mbj""). See FSAPT documentation for more details on using FSAPT; for functional group analyses. table of contents. SAPT: Symmetry-Adapted Perturbation Theory; The S2 approximation and scaling; A First Example; Advanced example; SAPT0; Basic SAPT0 Keywords; SAPT_LEVEL; BASIS; DF_BASIS_SAPT; DF_BASIS_ELST; FREEZE_CORE; CPHF_R_CONVERGENCE; MAXITER; PRINT. Advanced SAPT0 Keywords; AIO_CPHF; AIO_DF_INTS; COUPLED_INDUCTION; EXCH_SCALE_ALPHA; INTS_TOLERANCE; DENOMINATOR_DELTA; DENOMINATOR_ALGORITHM; DEBUG. Specific open-shell SAPT0 keywords; SAPT_MEM_SAFETY; COUPLED_INDUCTION. SAPT(DFT); Basic Keywords for SAPT(DFT); SAPT_DFT_GRAC_SHIFT_A; SAPT_DFT_GRAC_SHIFT_B; SAPT_DFT_DO_DHF; SAPT_DFT_EXCH_DISP_SCALE_SCHEME. Advanced Keywords for SAPT(D",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/sapt.html:50034,energy,energy,50034,psi4manual/master/sapt.html,https://psicode.org,https://psicode.org/psi4manual/master/sapt.html,2,['energy'],['energy']
Energy Efficiency,"mme’s dispersion corrections are discussed here.; The corresponding method, termed SAPT0-D, thus relies on empirically fit parameters; specific to SAPT0/jun-cc-pVDZ. While SAPT0-D can be used with any of the -D; variants using default parameters optimized for Hartee–Fock interaction energies,; we recommend using the refit parameters with Becke-Johnson damping, as described in; [Schriber:2021:234107]. Again, use of SAPT0-D with a basis set other than; jun-cc-pVDZ is not tested and not guaranteed to give meaningful results without; refitting the dispersion parameters.; A simple water dimer computation using SAPT0-D may look like:; molecule water_dimer {; 0 1; O -1.551007 -0.114520 0.000000; H -1.934259 0.762503 0.000000; H -0.599677 0.040712 0.000000; --; 0 1; O 1.350625 0.111469 0.000000; H 1.680398 -0.373741 -0.758561; H 1.680398 -0.373741 0.758561. units angstrom; no_reorient; symmetry c1; }. set basis jun-cc-pvdz. energy('sapt0-d3mbj') # runs the recommended dispersion correction; energy('sapt0-d3') # tests an alternative damping scheme/parameterization. Given the naturally pairwise-atomic nature of these empirical dispersion corrections,; integration with existing FSAPT functionality is also available simply by calling; energy(""fsapt0-d3mbj""). See FSAPT documentation for more details on using FSAPT; for functional group analyses. table of contents. SAPT: Symmetry-Adapted Perturbation Theory; The S2 approximation and scaling; A First Example; Advanced example; SAPT0; Basic SAPT0 Keywords; SAPT_LEVEL; BASIS; DF_BASIS_SAPT; DF_BASIS_ELST; FREEZE_CORE; D_CONVERGENCE; E_CONVERGENCE; MAXITER; PRINT. Advanced SAPT0 Keywords; AIO_CPHF; AIO_DF_INTS; COUPLED_INDUCTION; EXCH_SCALE_ALPHA; INTS_TOLERANCE; DENOMINATOR_DELTA; DENOMINATOR_ALGORITHM; DEBUG. Specific open-shell SAPT0 keywords; SAPT_MEM_SAFETY; COUPLED_INDUCTION. SAPT(DFT); Basic Keywords for SAPT(DFT); SAPT_DFT_GRAC_SHIFT_A; SAPT_DFT_GRAC_SHIFT_B; SAPT_DFT_DO_DHF; SAPT_DFT_EXCH_DISP_SCALE_SCHEME. Advanced Keywords ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/sapt.html:49541,energy,energy,49541,psi4manual/1.7.x/sapt.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/sapt.html,6,['energy'],['energy']
Energy Efficiency,"mme’s dispersion corrections are discussed here.; The corresponding method, termed SAPT0-D, thus relies on empirically fit parameters; specific to SAPT0/jun-cc-pVDZ. While SAPT0-D can be used with any of the -D; variants using default parameters optimized for Hartee–Fock interaction energies,; we recommend using the refit parameters with Becke-Johnson damping, as described in; [Schriber:2021:234107]. Again, use of SAPT0-D with a basis set other than; jun-cc-pVDZ is not tested and not guaranteed to give meaningful results without; refitting the dispersion parameters.; A simple water dimer computation using SAPT0-D may look like:; molecule water_dimer {; 0 1; O -1.551007 -0.114520 0.000000; H -1.934259 0.762503 0.000000; H -0.599677 0.040712 0.000000; --; 0 1; O 1.350625 0.111469 0.000000; H 1.680398 -0.373741 -0.758561; H 1.680398 -0.373741 0.758561. units angstrom; no_reorient; symmetry c1; }. set basis jun-cc-pvdz. energy('sapt0-d3mbj') # runs the recommended dispersion correction; energy('sapt0-d3') # tests an alternative damping scheme/parameterization. Given the naturally pairwise-atomic nature of these empirical dispersion corrections,; integration with existing FSAPT functionality is also available simply by calling; energy(“fsapt0-d3mbj”). See FSAPT <fisapt> documentation for more details on using FSAPT; for functional group analyses. table of contents. SAPT: Symmetry-Adapted Perturbation Theory; The S2 approximation and scaling; A First Example; Advanced example; SAPT0; Basic SAPT0 Keywords; SAPT_LEVEL; BASIS; DF_BASIS_SAPT; DF_BASIS_ELST; FREEZE_CORE; D_CONVERGENCE; E_CONVERGENCE; MAXITER; PRINT. Advanced SAPT0 Keywords; AIO_CPHF; AIO_DF_INTS; COUPLED_INDUCTION; EXCH_SCALE_ALPHA; INTS_TOLERANCE; DENOMINATOR_DELTA; DENOMINATOR_ALGORITHM; DEBUG. Specific open-shell SAPT0 keywords; SAPT_MEM_SAFETY; COUPLED_INDUCTION. SAPT(DFT); Basic Keywords for SAPT(DFT); SAPT_DFT_GRAC_SHIFT_A; SAPT_DFT_GRAC_SHIFT_B; SAPT_DFT_DO_DHF; SAPT_DFT_EXCH_DISP_SCALE_SCHEME. Advanced ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/sapt-1.html:46244,energy,energy,46244,psi4manual/1.4.0/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/sapt-1.html,10,['energy'],['energy']
Energy Efficiency,"mmies). set_ghost_fragment(self: psi4.core.Molecule, arg0: int) → None; Sets the specified fragment arg0 to be Ghost. set_ghost_fragments(self: psi4.core.Molecule, arg0: List[int]) → None; Sets the specified list arg0 of fragments to be Ghost. set_input_units_to_au(self: psi4.core.Molecule, arg0: float) → None; Sets unit conversion to [a0] for geometry. set_mass(self: psi4.core.Molecule, atom: int, mass: float) → None; Sets mass of atom (0-indexed) to mass (good for isotopic substitutions). set_molecular_charge(self: psi4.core.Molecule, arg0: int) → None; Change the overall molecular charge. Setting in initial molecule string or constructor preferred. set_multiplicity(self: psi4.core.Molecule, arg0: int) → None; Change the multiplicity (defined as 2S + 1). Setting in initial molecule string or constructor preferred. set_name(self: psi4.core.Molecule, arg0: str) → None; Sets molecule name. set_nuclear_charge(self: psi4.core.Molecule, arg0: int, arg1: float) → None; Set the nuclear charge of the given atom arg0 to the value arg1 (primarily for ECP). set_point_group(self: psi4.core.Molecule, arg0: psi4.core.PointGroup) → None; Sets the molecular point group to the point group object arg0. set_provenance(self: psi4.core.Molecule, arg0: Dict[str, str]) → None; Sets molecule provenance. set_units(self: psi4.core.Molecule, arg0: psi4.core.GeometryUnits) → None; Sets units (Angstrom or Bohr) used to define the geometry. Imposes Psi4 physical constants conversion for input_units_to_au. set_variable(self: psi4.core.Molecule, arg0: str, arg1: float) → None; Sets the value arg1 to the variable arg0 in the list of structure variables, then calls update_geometry(). symbol(self: psi4.core.Molecule, atom: int) → str; Gets the cleaned up label of atom (C2 => C, H4 = H) (0-indexed without dummies). symmetrize(self: psi4.core.Molecule, arg0: float) → None; Finds the highest point Abelian point group within the specified tolerance, and forces the geometry to have that symmetry. symmetr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.molecule.html:59257,charge,charge,59257,psi4manual/1.3.2/api/psi4.core.molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.molecule.html,1,['charge'],['charge']
Energy Efficiency,"mmonett; Section author: Justin M. Turney; Module: Keywords, PSI Variables, MRCC, Samples; PSI4 contains code to interface to the MRCC program of M. Kállay; and J. Gauss. The license and source code of the MRCC program must be; obtained from Mihály Kállay (https://www.mrcc.hu/). Installation¶; Follow the instructions provided with the source to build the MRCC programs.; To be used by PSI4, ensure that the program binary (dmrcc) can be; found in your PATH. If PSI4 is unable to execute the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC.; Perturbative methods (ccsd(t), ccsdtqp(h)_l, etc.); are available with REFERENCE ROHF in versions of MRCC published; at least after July 1, 2014.; When using ROHF-CCSDT(Q), MRCC will compute and report two variants:; CCSDT(Q)/A and CCSDT(Q)/B. [Kallay:2008:144101] PSI4 will save both energies but will use; the CCSDT(Q)/B as the CCSDT(Q) energy. CCSDT(Q)/B has been found to be; more robust by Martin. [Martin:2014:785]. name; calls method in Kallay’s MRCC program [manual]. mrccsd; CC through doubles. mrccsdt; CC through triples. mr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/mrcc-1.html:1235,energy,energy,1235,psi4manual/1.4.0/mrcc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/mrcc-1.html,10,['energy'],['energy']
Energy Efficiency,"mmonett; Section author: Justin M. Turney; Module: Keywords, PSI Variables, MRCC, Samples; PSI4 contains code to interface to the MRCC program of M. Kállay; and J. Gauss. The license and source code of the MRCC program must be; obtained from Mihály Kállay (https://www.mrcc.hu/). Installation¶; Follow the instructions provided with the source to build the MRCC programs.; To be used by PSI4, ensure that the program binary (dmrcc) can be; found in your PATH. If PSI4 is unable to execute the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; To indicate MRCC as the target software, set QC_MODULE=MRCC.; This is a change as of October 2022; previously, one prefixed the method by “mr”; to indicate MRCC (e.g., energy('mrccsdt')).; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; qc_module mrcc; }; energy('ccsdt'). 'ccsdt' in the call to energy() plus qc_module=mrcc instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; Here the qc_module=mrcc is optional since PSI4 has no builtin module; that can perform CCSDT. For a method like CCSD, no specification of QC_MODULE; will default to the CCENERGY module, and specification with value mrcc is; required to route the computation to the MRCC program.; For a CCSDT(Q) energy, simply use 'ccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you can call it directly; For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC.; Perturbative methods (ccsd(t), ccsdtqp(h)_l, etc.); a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/mrcc.html:1271,energy,energy,1271,psi4manual/1.7.x/mrcc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/mrcc.html,4,['energy'],['energy']
Energy Efficiency,"mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) == 0):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; if (wfnname == 'scf'):; portion = 'tot'; else:; portion = 'corl'; NEED = {'HI': dict(zip(f_fields, [wfnname, portion, BSET[len(ZSET) - 1], ZSET[len(ZSET) - 1], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; # Compute extrapolated energy; energypiece = NEED['HI']['f_energy']. # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); if (NEED['HI']['f_wfn'] == 'scf'):; cbsscheme += """""" HI-zeta (%s) Total Energy: %16.8f\n"""""" % (str(NEED['HI']['f_zeta']), energypiece); else:; cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(NEED['HI']['f_zeta']), energypiece); PsiMod.print_out(cbsscheme). return energypiece. # Solution equation in LaTeX: $E_{corl}^{\infty} = \frac{E_{corl}^{X} X^3 - E_{corl}^{X-1} (X-1)^3}{X^3 - (X-1)^3}$; # Solution equation in LaTeX: $\beta = \frac{E_{corl}^{X} - E_{corl}^{X-1}}{X^{-3} - (X-1)^{-3}}$; [docs]def corl_xtpl_helgaker_2(**largs):; r""""""Extrapolation scheme for correlation energies with two adjacent zeta-level bases.; Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{corl}^X = E_{corl}^{\infty} + \beta X^{-3}. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 2):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:78572,energy,energypiece,78572,psi4manual/4.0b2/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html,6,['energy'],['energypiece']
Energy Efficiency,"modifications to existing methods. """"""; import PsiMod; import re; import os; import input; import math; import warnings; from driver import *; from wrappers import *; from molutil import *; from text import *; from procutil import *. # Python procedures like these can be run directly from the input file or integrated; # with the energy(), etc. routines by means of lines like those at the end of this file. [docs]def sherrillgroup_gold_standard(name='mp2', **kwargs):; r""""""Function to call the quantum chemical method known as 'Gold Standard'; in the Sherrill group. Uses :py:func:`~wrappers.complete_basis_set` to evaluateo; the following expression. Two-point extrapolation of the correlation energy; performed according to :py:func:`~wrappers.corl_xtpl_helgaker_2`. .. math:: E_{total}^{\text{Au\_std}} = E_{total,\; \text{SCF}}^{\text{aug-cc-pVQZ}} \; + E_{corl,\; \text{MP2}}^{\text{aug-cc-pV[TQ]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD(T)}}\big\vert_{\text{aug-cc-pVTZ}}. >>> energy('sherrillgroup_gold_standard'). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). if not ('func_cbs' in kwargs):; kwargs['func_cbs'] = energy. if not ('scf_basis' in kwargs):; kwargs['scf_basis'] = 'aug-cc-pVQZ'; if not ('scf_scheme' in kwargs):; kwargs['scf_scheme'] = highest_1. if not ('corl_wfn' in kwargs):; kwargs['corl_wfn'] = 'mp2'; if not ('corl_basis' in kwargs):; kwargs['corl_basis'] = 'aug-cc-pV[TQ]Z'; if not ('corl_scheme' in kwargs):; kwargs['corl_scheme'] = corl_xtpl_helgaker_2. if not ('delta_wfn' in kwargs):; kwargs['delta_wfn'] = 'ccsd(t)'; if not ('delta_wfn_lesser' in kwargs):; kwargs['delta_wfn_lesser'] = 'mp2'; if not ('delta_basis' in kwargs):; kwargs['delta_basis'] = 'aug-cc-pVTZ'; if not ('delta_scheme' in kwargs):; kwargs['delta_scheme'] = highest_1. return cbs(name, **kwargs). [docs]def run_mp2_5(name, **kwargs):; r""""""Function that computes MP2.5 energy from results of a DETCI; MP3 calculation. .. math:: E_{total}^{\text{MP2.5}} = E_{total,\; \text{SCF}} \; +",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/aliases.html:1323,energy,energy,1323,psi4manual/4.0b2/_modules/aliases.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/aliases.html,2,['energy'],['energy']
Energy Efficiency,"module_options() like below. Note that these values; should be of correct type, strings for strings, floats for floats like; convergences. The function ~psi4.core.clean_options that reinitializes; all options may also be useful to separate calculations in a PsiAPI; session.; 1; 2; 3; 4; 5; 6; 7; 8; 9psi4.set_options({; 'scf_type': 'pk',; 'e_convergence': 1.e-5,; 'soscf': True; }). psi4.set_module_options({; 'geom_maxiter': 50; }). Basis Sets¶. Basis Sets; Built-In Basis Sets; Mixing Basis Sets; Decontracted Basis Sets; User-Defined Basis Sets. PSI Variables¶; To harness the power of Python, PSI4 makes the most pertinent results; of each computation available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of; H2 and H atom:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19molecule h2 {; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h {; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol * (2*h_energy - h2_energy); print ""De=%f"" % D_e. The energy() function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation.; Generally, there are multiple quantities of interest. Appendix; PSI Variables by Module lists PSI variables variables set by each; module, and PSI Variables by Alpha defines them. These can be; accessed through the get_variable() function. For example, after; performing a density fitted MP2 computation, both the spin component; scaled energy and the unscaled MP2 energy are made available:; 1; 2e_mp2 = get_variable('MP2 TOTAL ENERGY'); e_scs_mp2 = get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the ou",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psithoninput-1.html:8885,energy,energy,8885,psi4manual/1.1.0/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psithoninput-1.html,2,['energy'],['energy']
Energy Efficiency,"mol, DD, G, H as available; * form model, including detailed dict at atomicresult.extras[""findif_record""]. * convert result to psi4.core.Matrix. _findif_schema_to_wfn(); -----------------------; * build wfn from findif mol and basis (if singular) and module (if singular); * push qcvars to P::e and wfn. gradient_write(); ----------------; * write .grad file if requested. hessian_write(); ---------------; * write .hess file if requested. * return dd/g/h and wfn. """""". import copy; import logging; from functools import partial; from typing import TYPE_CHECKING, Any, Callable, Dict, Iterator, List, Optional, Tuple, Union. import numpy as np. try:; from pydantic.v1 import Field, validator; except ImportError:; from pydantic import Field, validator. from qcelemental.models import AtomicResult, DriverEnum. from psi4 import core. from . import p4util, qcdb; from .constants import constants, nppp10, pp; from .p4util.exceptions import ValidationError; from .task_base import AtomicComputer, BaseComputer, EnergyGradientHessianWfnReturn. if TYPE_CHECKING:; import qcportal. logger = logging.getLogger(__name__). # CONVENTIONS:; # n_ at the start of a variable name is short for ""number of.""; # _pi at the end of a variable name is short for ""per irrep.""; # h is the index of an irrep. def _displace_cart(mass: np.ndarray, geom: np.ndarray, salc_list: core.CdSalcList, i_m: Iterator[Tuple], step_size: float) -> Tuple[np.ndarray, str]:; """"""Displace a geometry along the specified displacement SALCs. Parameters; ----------; mass; (nat, ) masses [u] of atoms of the molecule (const).; geom; (nat, 3) reference geometry [a0] of the molecule (const).; salc_list; A list of Cartesian displacement SALCs; i_m; An iterator containing tuples. Each tuple has the index of a salc in; salc_list and the number of steps (positive or negative) to displace; the salc at that index.; step_size; The size of a single ""step,"" i.e., the stencil size. Returns; -------; disp_geom; (nat, 3) Displaced geometry.; label;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/driver_findif.html:4961,Energy,EnergyGradientHessianWfnReturn,4961,psi4manual/1.9.x/_modules/psi4/driver/driver_findif.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/driver_findif.html,2,['Energy'],['EnergyGradientHessianWfnReturn']
Energy Efficiency,"molecular plane defining the mirror plane), the above; array will be automatically interpreted as:; 1SOCC = [0, 1]. Some caution is required, however. The \(^2A_1\) state can be obtained with; the; 1SOCC = [1, 0, 0, 0]. specification, which would become; 1SOCC = [1, 0]. under the above-mentioned reduction in symmetry. The \(^2B_2\) state,; whose singly-occupied orbitals are; 1SOCC = [0, 0, 0, 1]. would be mapped to; 1SOCC = [1, 0]. which is the same occupation as the \(^2A_1\) state. In this case, the; \(^2A_1\) state is lower in energy, and is not problematic. The distorted; geometries for the \(^2B_2\) state are excited states that are subject to; variational collapse. One way to obtain reliable energies for these states is; to use a multi-state method; in this case it’s easier to run the entire; computation in the lowest symmetry needed during the finite difference; procedure. Non-Covalently Bonded Molecule Fragments¶; PSI4 has an extensive range of tools for treating non-covalent; intermolecular forces, including counterpoise corrections and symmetry adapted; perturbation theory methods. These require the definition of which fragments; are interacting within the complex. PSI4 provides a very simple mechanism; for doing so: simply define the complex’s geometry using the standard; Cartesian, Z-matrix, or mixture thereof, specifications and then place two; dashes between nonbonded fragments. For example, to study the interaction; energy of ethane and ethyne molecules, we can use the following molecule; block:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15molecule eneyne {; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.923621 1.232253 -2.126185; --; 0 1; C 0.000000 0.000000 2.900503; C 0.000000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; }. In this case, the charge and multiplicity of each interacting fragm",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psithonmol-1.html:14571,adapt,adapted,14571,psi4manual/1.1.0/psithonmol-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psithonmol-1.html,6,['adapt'],['adapted']
Energy Efficiency,"molecular_charge(charge) ; mol.set_multiplicity(mult). # Determine HOMO; ref = PsiMod.reference_wavefunction(); eps_a = ref.epsilon_a(); eps_b = ref.epsilon_b(); if (Na == Nb):; HOMO = -Nb; elif (Nb == 0):; HOMO = Na; else:; E_a = eps_a[int(Na - 1)] ; E_b = eps_b[int(Nb - 1)] ; if (E_a >= E_b):; HOMO = Na; else: ; HOMO = -Nb. stats.append('\t%6d %6d %6d %6d %6d %6d\n' %(Nintegral-1, Na, Nb, charge, mult, HOMO)). if (HOMO > 0):; Na = Na - 1; else:; Nb = Nb - 1; charge = charge + 1; mult = Na - Nb + 1; ; PsiMod.set_global_option(""DF_INTS_IO"", ""NONE""). # => Print the results out <= #; E = {}; PsiMod.print_out('\n ==> Fractional Occupation Nuke Results <==\n\n'); PsiMod.print_out('\t%-11s %-24s %-24s %11s\n' %('N', 'Energy', 'HOMO Energy', 'Converged')); for k in range(len(Ns)):; PsiMod.print_out('\t%11.3E %24.16E %24.16E %11d\n' % (Ns[k], energies[k], potentials[k], convs[k])); E[Ns[k]] = energies[k]. PsiMod.print_out('\n'); PsiMod.print_out('\t%6s %6s %6s %6s %6s %6s\n' %('N', 'Na', 'Nb', 'Charge', 'Mult', 'HOMO')); for line in stats: ; PsiMod.print_out(line). PsiMod.print_out('\n\t""You shoot a nuke down a bug hole, you got a lot of dead bugs""\n'); PsiMod.print_out('\t\t\t-Starship Troopers\n'). # Drop the files out; fh = open(traverse_filename, 'w'); fh.write('\t%-11s %-24s %-24s %11s\n' %('N', 'Energy', 'HOMO Energy', 'Converged')); for k in range(len(Ns)):; fh.write('\t%11.3E %24.16E %24.16E %11d\n' % (Ns[k], energies[k], potentials[k], convs[k])); fh.close(). fh = open(stats_filename, 'w'); fh.write('\t%6s %6s %6s %6s %6s %6s\n' %('N', 'Na', 'Nb', 'Charge', 'Mult', 'HOMO')); for line in stats: ; fh.write(line); fh.close(). return E . [docs]def ip_fitting(mol, omega_l, omega_r, **kwargs):; kwargs = kwargs_lower(kwargs). # By default, zero the omega to 3 digits; omega_tol = 1.0E-3;; if (kwargs.has_key('omega_tolerance')): ; omega_tol = kwargs['omega_tolerance']. # By default, do up to twenty iterations; maxiter = 20;; if (kwargs.has_key('maxiter')): ; maxiter = kwarg",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/frac.html:10278,Charge,Charge,10278,psi4manual/4.0b2/_modules/frac.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/frac.html,2,['Charge'],['Charge']
Energy Efficiency,"molecule (triplet ground state). This performs geometry optimization using two-step and simultaneous solution of the response equations for the analytic gradient. dfscf-bz2; Benzene Dimer DF-HF/cc-pVDZ. cepa1; cc-pvdz H2O Test CEPA(1) Energy. tu1-h2o-energy; Sample HF/cc-pVDZ H2O computation. cc56; EOM-CCSD/6-31g excited state transition data for water cation. cc3; cc3: RHF-CCSD/6-31G** H2O geometry optimization and vibrational frequency analysis by finite-differences of gradients. dfmp2-grad1; DF-MP2 cc-pVDZ gradients for the H2O molecule. opt-irc-2; Compute the IRC for HCN <-> NCH interconversion at the RHF/DZP level of theory. dft-ghost; DFT Functional Test for Range-Seperated Hybrids and Ghost atoms. freq-isotope2; Vibrational and thermo analysis of several water isotopologs. Demonstrates Hessian reuse for different temperatures, pressures, and isotopologs. scf-hess1; RHF STO-3G (Cartesian) and cc-pVDZ (spherical) water Hessian test, against Psi3 reference values. fnocc5; Test FNO-DF-CCSD(T) energy. dfmp2-grad5; Tests DF-MP2 gradient in the presence of a dipole field. scf-uhf-grad-nobeta; UHF gradient for a one-electron system (no beta electrons). cc10; ROHF-CCSD cc-pVDZ energy for the \(^2\Sigma^+\) state of the CN radical. dft-smoke; DFT Functional Smoke Test. ao-casscf-sp; CASSCF/6-31G** energy point. cepa-module; routing check on lccd, lccsd, cepa(0). dfomp2p5-grad1; DF-OMP2.5 cc-pVDZ gradients for the H2O molecule. cbs-xtpl-alpha; Extrapolated water energies. omp2-4; SCS-OMP2 cc-pVDZ geometry optimization for the H2O molecule. frac; Carbon/UHF Fractionally-Occupied SCF Test Case. nbody-nocp-gradient; Computation of NoCP-corrected water trimer gradient (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). sapt2; SAPT0 aug-cc-pVDZ computation of the benzene-methane interaction energy, using the aug-pVDZ-JKFIT DF basis for SCF, the aug-cc-pVDZ-RI DF basis for SAPT0 induction and dispersion, and the aug-pVDZ-JKFIT DF basis for SAPT0 electrostatics and i",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html:7048,energy,energy,7048,psi4manual/master/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"molecule class.; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __setattr__ = new_set_attr(self, name, value); | Function to redefine set_attr method of molecule class.; | ; | activate_all_fragments(...); | activate_all_fragments( (Molecule)arg1) -> None :; | Sets all fragments in the molecule to be active; | ; | add_atom(...); | add_atom( (Molecule)arg1, (int)arg2, (float)arg3, (float)arg4, (float)arg5, (str)arg6, (float)arg7, (float)arg8, (int)arg9) -> None :; | Adds to Molecule arg1 an atom with atomic number arg2, Cartesian coordinates in Bohr (arg3, arg4, arg5), atomic symbol arg6, mass arg7, charge arg8 (optional), and lineno arg9 (optional); | ; | atom_at_position(...); | atom_at_position( (Molecule)arg1, (float)arg2, (float)arg3) -> int :; | Tests to see if an atom is at the position arg2 with a given tolerance arg3; | ; | center_of_mass(...); | center_of_mass( (Molecule)arg1) -> Vector3 :; | Computes center of mass of molecule (does not translate molecule); | ; | charge(...); | charge( (Molecule)arg1, (int)arg2) -> float :; | Gets charge of atom; | ; | clone(...); | clone( (Molecule)arg1) -> Molecule :; | Returns a new Molecule identical to arg1; | ; | deactivate_all_fragments(...); | deactivate_all_fragments( (Molecule)arg1) -> None :; | Sets all fragments in the molecule to be inactive; | ; | extract_subsets(...); | extract_subsets( (Molecule)arg1, (list)arg2, (list)arg3) -> Molecule :; | Returns copy of arg1 with arg2 fragments Real and arg3 fragments Ghost; | ; | extract_subsets( (Molecule)arg1, (list)arg2, (int)arg3) -> Molecule :; | Returns copy of arg1 with arg2 fragments Real and arg3 fragment Ghost; | ; | extract_subsets( (Molecule)arg1, (int)arg2, (list)arg3) -> Molecule :; | Returns copy of arg1 with arg2 fragment Real and arg3 fragments Ghost; | ; | extract_subsets( (Molecule)arg1, (int)arg2, (int)arg3) -> Molecule :; | Returns copy of arg1 with arg2 fragment Real and arg3 f",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/psimod-1.html:53113,charge,charge,53113,psi4manual/4.0b3/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html,4,['charge'],['charge']
Energy Efficiency,"molecule name. natom(self: psi4.core.Molecule) → int¶; Number of real atoms. nfragments(self: psi4.core.Molecule) → int¶; Gets the number of fragments in the molecule. nuclear_dipole(*args, **kwargs)¶; Overloaded function. nuclear_dipole(self: psi4.core.Molecule, arg0: psi4.core.Vector3) -> psi4.core.Vector3. Gets the nuclear contribution to the dipole, with respect to a specified origin atg0. nuclear_dipole(self: psi4.core.Molecule) -> psi4.core.Vector3. Gets the nuclear contribution to the dipole, with respect to the origin. nuclear_repulsion_energy(self: psi4.core.Molecule, dipole_field: List[float[3]] = [0.0, 0.0, 0.0]) → float¶; Computes nuclear repulsion energy. nuclear_repulsion_energy_deriv1(self: psi4.core.Molecule, dipole_field: List[float[3]] = [0.0, 0.0, 0.0]) → psi4.core.Matrix¶; Returns first derivative of nuclear repulsion energy as a matrix (natom, 3). nuclear_repulsion_energy_deriv2(self: psi4.core.Molecule) → psi4.core.Matrix¶; Returns second derivative of nuclear repulsion energy as a matrix (natom X 3, natom X 3). orientation_fixed(self: psi4.core.Molecule) → bool¶; Get whether or not orientation is fixed. point_group(self: psi4.core.Molecule) → psi4.core.PointGroup¶; Returns the current point group object. print_bond_angles(self: psi4.core.Molecule) → None¶; Print the bond angle geometrical parameters. print_cluster(self: psi4.core.Molecule) → None¶; Prints the molecule in Cartesians in input units adding fragment separators. print_distances(self: psi4.core.Molecule) → None¶; Print the interatomic distance geometrical parameters. print_in_input_format(self: psi4.core.Molecule) → None¶; Prints the molecule as Cartesian or ZMatrix entries, just as inputted. print_out(self: psi4.core.Molecule) → None¶; Prints the molecule in Cartesians in input units to output file. print_out_in_angstrom(self: psi4.core.Molecule) → None¶; Prints the molecule in Cartesians in Angstroms to output file. print_out_in_bohr(self: psi4.core.Molecule) → None¶; Prints the m",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.molecule.html:25408,energy,energy,25408,psi4manual/1.4.0/api/psi4.core.molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.molecule.html,10,['energy'],['energy']
Energy Efficiency,"molecule().reinterpret_coordentry(True). else: # Assume energy points; # If not, perform finite difference of energies; info = 'Performing finite difference calculations by energies'; print info. # Obtain list of displacements; displacements = PsiMod.fd_geoms_freq_0(irrep); molecule.fix_orientation(True); molecule.reinterpret_coordentry(False); # Make a note of the undisplaced molecule's symmetry; PsiMod.set_parent_symmetry(molecule.schoenflies_symbol()). ndisp = len(displacements). # This version is pretty dependent on the reference geometry being last (as it is now); print ' %d displacements needed.' % ndisp; energies = []; for n, displacement in enumerate(displacements):; # Print information to output.dat; PsiMod.print_out('\n'); banner('Loading displacement %d of %d' % (n + 1, ndisp)). # Print information to the screen; print ' %d' % (n + 1),; if (n + 1) == ndisp:; print '\n',. # Load in displacement into the active molecule; molecule.set_geometry(displacement); ; # Perform the energy calculation; E = func(lowername, **kwargs). # Save the energy; energies.append(E). # clean may be necessary when changing irreps of displacements; PsiMod.clean(). # Obtain the gradient. This function stores the gradient into the reference wavefunction.; PsiMod.fd_freq_0(energies, irrep). print ' Computation complete.'; ; # Clear the ""parent"" symmetry now; PsiMod.set_parent_symmetry(""""). # TODO: These need to be restored to the user specified setting; PsiMod.get_active_molecule().fix_orientation(False); # But not this one, it always goes back to True; PsiMod.get_active_molecule().reinterpret_coordentry(True). # The last item in the list is the reference energy, return it; return energies[-1]. ## Aliases ##; frequencies = frequency; freq = frequency. # hessian to be changed later to compute force constants; [docs]def hessian(name, **kwargs):; r""""""Function to compute force constants. Presently identical to frequency().""""""; lowername = name.lower(); kwargs = kwargs_lower(kwargs); frequ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/driver.html:47644,energy,energy,47644,psi4manual/4.0b2/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/driver.html,2,['energy'],['energy']
Energy Efficiency,"molecule(); efp_present = hasattr(mol, 'EFP'). translations_projection_sound = (not core.get_option('SCF', 'EXTERN') and not core.get_option('SCF', 'PERTURB_H'); and not efp_present); rotations_projection_sound = (translations_projection_sound and stationary_point). return translations_projection_sound, rotations_projection_sound. def _filter_renamed_methods(compute, method):; r""""""Raises UpgradeHelper when a method has been renamed.""""""; if method == ""dcft"":; raise UpgradeHelper(compute + ""('dcft')"", compute + ""('dct')"", 1.4,; "" All instances of 'dcft' should be replaced with 'dct'.""). [docs]def energy(name, **kwargs):; r""""""Function to compute the single-point electronic energy. :returns: *float* |w--w| Total electronic energy in Hartrees. SAPT & EFP return interaction energy. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY`; * :psivar:`CURRENT REFERENCE ENERGY`; * :psivar:`CURRENT CORRELATION ENERGY`. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple. :type write_orbitals: str, :ref:`boolean <op_py_boolean>`; :param write_orbitals: ``filename`` || |dl| ``'on'`` |dr| || ``'off'`` . (str) Save wfn containing current orbitals to the given file name after each SCF iteration; and retain after |PSIfour| finishes. (:ref:`boolean <op_py_boolean>`) Turns writing the orbitals after the converged SCF on/off.; Orbital file will be deleted ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html:3414,ENERGY,ENERGY,3414,psi4manual/1.6.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html,6,['ENERGY'],['ENERGY']
Energy Efficiency,"molecule. m = np.asarray([mol.mass(at) for at in range(mol.natom())]); irrep_labels = mol.irrep_labels(). vibinfo, vibtext = qcdb.vib.harmonic_analysis(nmwhess, geom, m, wfn.basisset(), irrep_labels,; project_trans=project_trans, project_rot=project_rot); vibrec.update({k: qca.to_dict() for k, qca in vibinfo.items()}). core.print_out(vibtext); core.print_out(qcdb.vib.print_vibs(vibinfo, shortlong=True, normco='x', atom_lbl=symbols)). if core.has_option_changed('THERMO', 'ROTATIONAL_SYMMETRY_NUMBER'):; rsn = core.get_option('THERMO', 'ROTATIONAL_SYMMETRY_NUMBER'); else:; rsn = mol.rotational_symmetry_number(). if irrep is None:; therminfo, thermtext = qcdb.vib.thermo(vibinfo,; T=core.get_option(""THERMO"", ""T""), # 298.15 [K]; P=core.get_option(""THERMO"", ""P""), # 101325. [Pa]; multiplicity=mol.multiplicity(),; molecular_mass=np.sum(m),; sigma=rsn,; rotor_type=mol.rotor_type(),; rot_const=np.asarray(mol.rotational_constants()),; E0=core.get_variable('CURRENT ENERGY')) # someday, wfn.energy(); vibrec.update({k: qca.to_dict() for k, qca in therminfo.items()}). core.set_variable(""ZPVE"", therminfo['ZPE_corr'].data); core.set_variable(""THERMAL ENERGY CORRECTION"", therminfo['E_corr'].data); core.set_variable(""ENTHALPY CORRECTION"", therminfo['H_corr'].data); core.set_variable(""GIBBS FREE ENERGY CORRECTION"", therminfo['G_corr'].data). core.set_variable(""ZERO K ENTHALPHY"", therminfo['ZPE_tot'].data); core.set_variable(""THERMAL ENERGY"", therminfo['E_tot'].data); core.set_variable(""ENTHALPY"", therminfo['H_tot'].data); core.set_variable(""GIBBS FREE ENERGY"", therminfo['G_tot'].data). core.print_out(thermtext); else:; core.print_out(' Thermochemical analysis skipped for partial frequency calculation.\n'). if core.get_option('FINDIF', 'HESSIAN_WRITE'):; filename = core.get_writer_file_prefix(mol.name()) + "".vibrec""; with open(filename, 'w') as handle:; json.dump(vibrec, handle, sort_keys=True, indent=4). if core.get_option('FINDIF', 'NORMAL_MODES_WRITE'):; filename = core.get_writer_file",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html:92322,energy,energy,92322,psi4manual/1.2.1/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html,1,['energy'],['energy']
Energy Efficiency,"molecule. pywrap-alias; Test parsed and exotic calls to energy() like zapt4, mp2.5, and cisd are working. fci-dipole; 6-31G H2O Test FCI Energy Point. sapt-dft1; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. cc2; 6-31G** H2O CCSD optimization by energies, with Z-Matrix input. dft1; DFT Functional Test. nbody-intermediates; HF/cc-pVDZ many body energies of an arbitrary noble gas trimer complex Size vs cost tradeoff is rough here. cc11; Frozen-core CCSD(ROHF)/cc-pVDZ on CN radical with disk-based AO algorithm. pywrap-cbs1; Various basis set extrapolation tests. x2c3; Test of SFX2C-1e on Water uncontracted cc-pVDZ The reference numbers are from Lan Cheng’s implementation in Cfour. cubeprop-esp; RHF orbitals and density for water. cc49; EOM-CC3(UHF) on CH radical with user-specified basis and properties for particular root. opt-multi-dimer-c1; Multi-fragment opt of C2h methane dimer with user-combined reference points. pywrap-checkrun-uhf; This checks that all energy methods can run with a minimal input and set symmetry. cc13c; Tests RHF CCSD(T)gradients. mom; Maximum Overlap Method (MOM) Test. MOM is designed to stabilize SCF convergence and to target excited Slater determinants directly. zaptn-nh2; ZAPT(n)/6-31G NH2 Energy Point, with n=2-25. omp2-grad1; OMP2 cc-pVDZ gradient for the H2O molecule. pywrap-checkrun-convcrit; Advanced python example sets different sets of scf/post-scf conv crit and check to be sure computation has actually converged to the expected accuracy. dfrasscf-sp; 6-31G** H2O Test RASSCF Energy Point will default to only singles and doubles in the active space. frac-traverse; Scan fractional occupation of electrons. ao-casscf-sp; CASSCF/6-31G** energy point. tu2-ch2-energy; Sample UHF/6-31G** CH2 computation. opt13; B3LYP cc-pVDZ geometry optimzation of phenylacetylene, starting from not quite linear structure. dft-b3lyp; Check flavors of B3LYP (b3lyp3/b3lyp5) against other programs. dfomp2-grad1; DF-OMP2 cc-pVDZ gradients for ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html:13572,energy,energy,13572,psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"molecule. pywrap-alias; Test parsed and exotic calls to energy() like zapt4, mp2.5, and cisd are working. fci-dipole; 6-31G H2O Test FCI Energy Point. sapt-dft1; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. cc2; 6-31G** H2O CCSD optimization by energies, with Z-Matrix input. dft1; DFT Functional Test. nbody-intermediates; HF/cc-pVDZ many body energies of an arbitrary noble gas trimer complex Size vs cost tradeoff is rough here. cc11; Frozen-core CCSD(ROHF)/cc-pVDZ on CN radical with disk-based AO algorithm. pywrap-cbs1; Various basis set extrapolation tests. x2c3; Test of SFX2C-1e on Water uncontracted cc-pVDZ The reference numbers are from Lan Cheng’s implementation in Cfour. cubeprop-esp; RHF orbitals and density for water. cc49; EOM-CC3(UHF) on CH radical with user-specified basis and properties for particular root. opt-multi-dimer-c1; Multi-fragment opt of C2h methane dimer with user-combined reference points. pywrap-checkrun-uhf; This checks that all energy methods can run with a minimal input and set symmetry. cc13c; Tests RHF CCSD(T)gradients. mom; Maximum Overlap Method (MOM) Test. MOM is designed to stabilize SCF convergence and to target excited Slater determinants directly. zaptn-nh2; ZAPT(n)/6-31G NH2 Energy Point, with n=2-25. omp2-grad1; OMP2 cc-pVDZ gradient for the H2O molecule. pywrap-checkrun-convcrit; Advanced python example sets different sets of scf/post-scf conv crit and check to be sure computation has actually converged to the expected accuracy. dfrasscf-sp; 6-31G** H2O Test RASSCF Energy Point will default to only singles and doubles in the active space. frac-traverse; Scan fractional occupation of electrons. ao-casscf-sp; CASSCF/6-31G** energy point. tu2-ch2-energy; Sample UHF/6-31G** CH2 computation. opt13; B3LYP cc-pVDZ geometry optimzation of phenylacetylene, starting from not quite linear structure. dft-bench-ionization; functionals ionization energies vs. other programs. dft-b3lyp; Check flavors of B3LYP (b3lyp3/b3",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html:12830,energy,energy,12830,psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"molecule.set_geometry(displacement). # Perform the energy calculation; func(lowername, **kwargs). # Save the energy; energies.append(psi4.get_variable('CURRENT ENERGY')). # clean may be necessary when changing irreps of displacements; psi4.clean(). # S/R: Write each displaced geometry to an input file; elif (freq_mode.lower() == 'sow'):; molecule.set_geometry(displacement). # S/R: Prepare molecule, options, and kwargs; freagent = open('%s.in' % (rfile), 'w'); freagent.write('# This is a psi4 input file auto-generated from the gradient() wrapper.\n\n'); freagent.write(p4util.format_molecule_for_input(molecule)); freagent.write(p4util.format_options_for_input()); p4util.format_kwargs_for_input(freagent, **kwargs). # S/R: Prepare function call and energy save; freagent.write(""""""electronic_energy = %s('%s', **kwargs)\n\n"""""" % (func.__name__, lowername)); freagent.write(""""""psi4.print_out('\\nHESSIAN RESULT: computation %d for item %d """""" % (os.getpid(), n + 1)); freagent.write(""""""yields electronic energy %20.12f\\n' % (electronic_energy))\n\n""""""); freagent.close(). # S/R: Read energy from each displaced geometry output file and save in energies array; elif (freq_mode.lower() == 'reap'):; exec(banners); psi4.set_variable('NUCLEAR REPULSION ENERGY', molecule.nuclear_repulsion_energy()); energies.append(p4util.extract_sowreap_from_output(rfile, 'HESSIAN', n, freq_linkage, True)). # S/R: Quit sow after writing files; if (freq_mode.lower() == 'sow'):; optstash.restore(); return None. # Obtain the gradient. This function stores the gradient in the wavefunction.; psi4.fd_freq_0(energies, irrep). print(' Computation complete.'). # Clear the ""parent"" symmetry now; psi4.set_parent_symmetry(""""). # TODO: These need to be restored to the user specified setting; psi4.get_active_molecule().fix_orientation(False); # But not this one, it always goes back to True; psi4.get_active_molecule().reinterpret_coordentry(True). # Clear the ""parent"" symmetry now; psi4.set_parent_symmetry(""""). # Th",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/driver.html:70013,energy,energy,70013,psi4manual/4.0b5/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/driver.html,2,['energy'],['energy']
Energy Efficiency,"molecule.set_multiplicity(multiplicity). # Respond to the EXIT command; def exit(self):; """""" Stop listening for MDI commands; """"""; self.stop_listening = True. # If a lattice of point charges was set, unset it now; if self.set_lattice:; self.kwargs.pop(""external_potentials"", None); . # Enter server mode, listening for commands from the driver; def listen_for_commands(self):; """""" Receive commands through MDI and respond to them as defined by the MDI Standard; """""". while not self.stop_listening:; if self.world_rank == 0:; command = MDI_Recv_Command(self.comm); else:; command = None; if use_mpi4py:; command = self.mpi_world.bcast(command, root=0); if self.world_rank == 0:; psi4.core.print_out('\nMDI command received: ' + str(command) + ' \n'). # Search for this command in self.commands; found_command = False; for supported_command in self.commands:; if not found_command and command == supported_command:; # Run the function corresponding to this command; self.commands[supported_command](); found_command = True; if not found_command:; raise Exception('Unrecognized command: ' + str(command)). def mdi_init(mdi_arguments):; """""" Initialize the MDI Library. Parameters; ----------; mdi_arguments; MDI configuration options. """"""; MDI_Init(mdi_arguments). [docs]; def mdi_run(scf_method: str, **kwargs):; """""" Begin functioning as an MDI (MolSSI driver interface) engine. Parameters; ----------; scf_method; Method (SCF or post-SCF) used when calculating energies or gradients.; molecule; The target molecule, if not the last molecule defined.; kwargs; Any additional arguments to pass to :func:`psi4.driver.energy` or; :func:`psi4.driver.gradient` computation. """"""; engine = MDIEngine(scf_method, **kwargs); engine.listen_for_commands(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.8.2;  · . PSI4. Module code; psi4.driver.mdi_engine. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:04AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html:13854,energy,energy,13854,psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html,2,['energy'],['energy']
Energy Efficiency,"molecule.set_multiplicity(multiplicity). # Respond to the EXIT command; def exit(self):; """""" Stop listening for MDI commands; """"""; self.stop_listening = True. # If a lattice of point charges was set, unset it now; if self.set_lattice:; self.kwargs.pop(""external_potentials"", None); . # Enter server mode, listening for commands from the driver; def listen_for_commands(self):; """""" Receive commands through MDI and respond to them as defined by the MDI Standard; """""". while not self.stop_listening:; if self.world_rank == 0:; command = MDI_Recv_Command(self.comm); else:; command = None; if use_mpi4py:; command = self.mpi_world.bcast(command, root=0); if self.world_rank == 0:; psi4.core.print_out('\nMDI command received: ' + str(command) + ' \n'). # Search for this command in self.commands; found_command = False; for supported_command in self.commands:; if not found_command and command == supported_command:; # Run the function corresponding to this command; self.commands[supported_command](); found_command = True; if not found_command:; raise Exception('Unrecognized command: ' + str(command)). def mdi_init(mdi_arguments):; """""" Initialize the MDI Library. Parameters; ----------; mdi_arguments; MDI configuration options. """"""; MDI_Init(mdi_arguments). [docs]; def mdi_run(scf_method: str, **kwargs):; """""" Begin functioning as an MDI (MolSSI driver interface) engine. Parameters; ----------; scf_method; Method (SCF or post-SCF) used when calculating energies or gradients.; molecule; The target molecule, if not the last molecule defined.; kwargs; Any additional arguments to pass to :func:`psi4.driver.energy` or; :func:`psi4.driver.gradient` computation. """"""; engine = MDIEngine(scf_method, **kwargs); engine.listen_for_commands(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.9.1;  · . PSI4. Module code; psi4.driver.mdi_engine. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/mdi_engine.html:13932,energy,energy,13932,psi4manual/1.9.x/_modules/psi4/driver/mdi_engine.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/mdi_engine.html,2,['energy'],['energy']
Energy Efficiency,"molparse/chgmult.py#L105-L136 .; Having defined a molecule containing fragments like eneyne above, it; is a simple matter to perform calculations on only a subset of the; fragments. For instance, the commands below run a scf first on the ethene; fragment alone (extract_subsets(1) pulls out fragment 1 as Real atoms; and discards remaining fragments) and next on the ethene fragment with the; ethyne fragment ghosted (extract_subsets(1,2) pulls out fragment 1 as; Real atoms and sets fragment 2 as Ghost atoms). For beyond bimolecular; complexes, arrays can be used, e.g. extract_subsets(2,[1,3]):; mA = eneyne.extract_subsets(1); energy('scf'). clean(). mAcp = eneyne.extract_subsets(1,2); energy('scf'). If the molecule contains fragments but is not conveniently ordered for the; -- marker, the auto_fragments() function can be applied, as shown in; pywrap-basis, to return as active molecule the previous; active molecule, only fragmented. Advanced Python¶; A named molecule in an input file is a full-fledged instance of the; powerful C++ Molecule class. Thus, all member; functions (that have been exported via pybind11) documented thereat; are accessible through the handle option_molecule_name in; molecule optional_molecule_name {...}. The molecular geometry can be got and set and manipulated as a; Matrix object. Below shows how to access; coordinates in an input file in Python.; molecule formaldehyde {; C 0.0 0.0 0.0; O 0.0 1.2 0.0; H -0.8 -0.3 0.0; H 0.8 -0.3 0.0 # set geometry in angstroms; }. formaldehyde.update_geometry() # update the molecule internals since pre-energy()-like call; formaldehyde.print_out() # print molecule to output file; geom1psi = formaldehyde.geometry() # get coordinates in bohr as a psi4.Matrix. geom1psi.print_out() # print coordinates array to output file; geom1py = mat2arr(geom1psi) # get coordinates as a Python array; print geom1py # print coordinates to screen. geom2py = [[ 0.0, 0.0, 0.0],; [ 0.0, 1.5, 0.0],; [-0.8, -0.3, 0.0],; [ 0.8, -0.3, 0.0]]",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/psithonmol.html:16924,power,powerful,16924,psi4manual/1.8.x/psithonmol.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/psithonmol.html,3,['power'],['powerful']
Energy Efficiency,"monomer molecular orbitals. Type: string; Possible Values: basis string; Default: No Default. DF_BASIS_SAPT¶. Auxiliary basis set for SAPT density fitting computations. Defaults to a RI basis. Type: string; Possible Values: basis string; Default: No Default. FREEZE_CORE¶. Specifies how many core orbitals to freeze in correlated computations. TRUE or 1 will default to freezing the previous noble gas shell on each atom. In case of positive charges on fragments, an additional shell may be unfrozen, to ensure there are valence electrons in each fragment. With FALSE or 0, no electrons are frozen (with the exception of electrons treated by an ECP). With -1, -2, and -3, the user might request strict freezing of the previous first/second/third noble gas shell on every atom. In this case, when there are no valence electrons, the code raises an exception. More precise control over the number of frozen orbitals can be attained by using the keywords NUM_FROZEN_DOCC (gives the total number of orbitals to freeze, program picks the lowest-energy orbitals) or FROZEN_DOCC (gives the number of orbitals to freeze per irreducible representation). Type: string; Possible Values: FALSE, TRUE, 1, 0, -1, -2, -3; Default: FALSE. PRINT¶. The amount of information to print to the output file for the sapt module. For 0, only the header and final results are printed. For 1, (recommended for large calculations) some intermediate quantities are also printed. Type: integer; Default: 1. Advanced Keywords for Higher-order SAPT¶. DO_CCD_DISP¶. Do CCD dispersion correction in SAPT2+, SAPT2+(3) or SAPT2+3?. Type: boolean; Default: false. DO_MBPT_DISP¶. Do MBPT dispersion correction in SAPT2+, SAPT2+(3) or SAPT2+3, if also doing CCD?. Type: boolean; Default: true. DO_THIRD_ORDER¶. Do compute third-order corrections?. Type: boolean; Default: false. INTS_TOLERANCE¶. Schwarz screening threshold. Minimum absolute value below which all three-index DF integrals and those contributing to four-index integrals are",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/sapt-1.html:22085,energy,energy,22085,psi4manual/1.3.2/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/sapt-1.html,7,['energy'],['energy']
Energy Efficiency,"monomerA'). core.IO.set_default_namespace('monomerA'); core.print_out('\n'); p4util.banner('Monomer A HF'); core.print_out('\n'). core.timer_on(""SAPT: Monomer A SCF""); monomerA_wfn = scf_helper('RHF', molecule=monomerA, **kwargs); core.timer_off(""SAPT: Monomer A SCF""). if do_delta_mp2:; select_mp2(""mp2"", ref_wfn=monomerA_wfn, **kwargs); mp2_corl_interaction_e -= core.variable('MP2 CORRELATION ENERGY'). # Compute Monomer B wavefunction; if (sapt_basis == 'dimer') and (ri == 'DF'):; core.IO.change_file_namespace(97, 'monomerA', 'monomerB'); core.IO.set_default_namespace('monomerB'); core.print_out('\n'); p4util.banner('Monomer B HF'); core.print_out('\n'). core.timer_on(""SAPT: Monomer B SCF""); monomerB_wfn = scf_helper('RHF', molecule=monomerB, **kwargs); core.timer_off(""SAPT: Monomer B SCF""). # Delta MP2; if do_delta_mp2:; select_mp2(""mp2"", ref_wfn=monomerB_wfn, **kwargs); mp2_corl_interaction_e -= core.variable('MP2 CORRELATION ENERGY'); core.set_variable(""SAPT MP2 CORRELATION ENERGY"", mp2_corl_interaction_e) # P::e SAPT; core.set_global_option('DF_INTS_IO', df_ints_io). if core.get_option('SCF', 'REFERENCE') == 'RHF':; core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERA, 'monomerA', 'dimer'); core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERB, 'monomerB', 'dimer'). core.IO.set_default_namespace('dimer'); core.set_local_option('SAPT', 'E_CONVERGENCE', 10e-10); core.set_local_option('SAPT', 'D_CONVERGENCE', 10e-10); if name in ['sapt0', 'ssapt0']:; core.set_local_option('SAPT', 'SAPT_LEVEL', 'SAPT0'); elif name == 'sapt2':; core.set_local_option('SAPT', 'SAPT_LEVEL', 'SAPT2'); elif name in ['sapt2+', 'sapt2+dmp2']:; core.set_local_option('SAPT', 'SAPT_LEVEL', 'SAPT2+'); core.set_local_option('SAPT', 'DO_CCD_DISP', False); elif name in ['sapt2+(3)', 'sapt2+(3)dmp2']:; core.set_local_option('SAPT', 'SAPT_LEVEL', 'SAPT2+3'); core.set_local_option('SAPT', 'DO_THIRD_ORDER', False); core.set_local_option('SAPT', 'DO_CCD_DISP', False); elif name in ['sapt2+3', 'sapt2+3",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:148987,ENERGY,ENERGY,148987,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,2,['ENERGY'],['ENERGY']
Energy Efficiency,"monomers.; Examples :; # Counterpoise corrected CCSD(T) energies for the Helium dimer; molecule mol {; He; --; He 1 3; }; # Calculate interaction energies only (skips monomers in monomer basis):; energy('CCSD(T)', bsse_type='cp'); # Calculate interaction and total energies, return interaction energies:; energy('CCSD(T)', bsse_type=['cp','nocp']); # Calculate and return counterpoise-corrected gradient; # Useful for e.g. CP-corrected geometry optimization; gradient('CCSD(T)', bsse_type='cp', return_total_data=True). # noCP, VMFC, and CP energy for a helium cluster, limited at 3 bodies; molecule mol {; He 0 0 0; --; He 0 0 4; --; He 0 4 0; --; He 4 0 0; }. # Returns the nocp energy as its first in the list; energy('CCSD(T)', bsse_type=['nocp', 'cp', 'vmfc'], max_nbody=3). class psi4.driver.driver_nbody.ManyBodyComputer(**data)[source]¶. Parameters. molecule (Any) – The target molecule, if not the last molecule defined.; basis (str, Default: (auto)) – ; method (str, Default: (auto)) – ; driver ({energy,gradient,hessian,properties}) – The computation driver; i.e., energy, gradient, hessian.; keywords (Dict[Any], Default: {}) – The computation keywords/options.; bsse_type ({nocp,cp,vmfc}, Default: [<BsseEnum.cp: 'cp'>]) – Requested BSSE treatments. First in list determines which interaction or total energy/gradient/Hessian returned.; nfragments (int, Default: -1) – Number of distinct fragments comprising full molecular supersystem.; max_nbody (int, Default: -1) – Maximum number of bodies to include in the many-body treatment. Possible: max_nbody <= nfragments. Default: max_nbody = nfragments.; nbodies_per_mc_level (List[List[Union[int, ]]], Default: []) – Distribution of active n-body levels among model chemistry levels. All bodies in range [1, self.max_nbody] must be present exactly once. Number of items in outer list is how many different modelchems. Each inner list specifies what n-bodies to be run at the corresponding modelchem (e.g., [[1, 2]] has max_nbody=2 and 1-bod",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/nbody.html:3946,energy,energy,3946,psi4manual/1.6.x/nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/nbody.html,1,['energy'],['energy']
Energy Efficiency,"most expensive terms). ccsdtqph-3; CC through quintuples with iterative sextuples (all but the most expensive terms). name; calls method in Stanton and Gauss’s CFOUR program [manual]. c4-scf; Hartree–Fock (HF). c4-mp2; 2nd-order Møller–Plesset perturbation theory (non-density-fitting) (MP2). c4-mp3; 3rd-order Møller–Plesset perturbation theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. >>> # [1] Coupled-cluster singles and doubles calculation with psi code; >>> energy('ccsd'). >>> # [2] Charge-transfer SAPT calculation with scf projection from small into; >>> # requested basis, with specified projection fitting basis; >>> set basis_guess true; >>> set df_basis_guess jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). >>> # [3] Arbitrary-order MPn calculation; >>> energy('mp7'). >>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> # Note that the integral transformation is not done automatically when detci is run in a separate step.; >>> molecule H2 {\n0 1\nH\nH 1 0.74\n}; >>> set basis cc-pVDZ; >>> set reference rohf; >>> scf_e, scf_wfn = energy('scf', return_wfn=True); >>> H2.set_multiplicity(3); >>> core.MintsHelper(scf_wfn.basisset()).integrals(); >>> energy('detci', ref_wfn=scf_wfn). >>> # [5] Run two CI calculations, keeping the integrals generated in the first one.; >>> molecule ne {\nNe\n}; >>> set basis cc-pVDZ; >>> cisd_e, cisd_wfn = energy('cisd', return_wfn=True); >>> energy('fci', ref_wfn=cisd_wfn). >>> # [6] Can automatically perform complete basis set extrapolations; >>> energy(""CCSD/cc-pV[DT]Z""). >>> # [7] Can automatically perform",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.energy.html:36405,energy,energy,36405,psi4manual/1.7.x/api/psi4.driver.energy.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.energy.html,16,"['Charge', 'energy']","['Charge-transfer', 'energy']"
Energy Efficiency,"most of the SAPT energy components are negative; this means those are attractive contributions (the zero of energy in a SAPT computation is defined as non-interacting monomers). The exchange contributions are positive (repulsive). In this example, the most attractive contribution between ethylene and acetylene is an electrostatic term of \(-2.12\) kcal/mol (Elst10,r where the 1 indicates the first-order perturbation theory result with respect to the; intermolecular interaction, and the 0 indicates zeroth-order with respect to the intramolecular electron correlation). The next most attractive contribution is the Disp20 term (second order intermolecular dispersion, which looks like MP2 in which one excitation is placed on each monomer), contributing an attraction of \(-1.21\) kcal/mol. It is not surprising that the electrostatic contribution is dominant, because the geometry chosen for this example has the acetylene perpendicular to; the ethylene, with the acetylene hydrogen pointing directly at the double bond in ethylene; this will be attractive because the H atoms in acetylene bear a partial positive charge, while the electron rich double bond in ethylene bears a partial negative charge. At the same time, the dispersion interaction should be smaller because the perpendicular geometry does not allow much overlap between the monomers. Hence, the SAPT analysis helps clarify (and quantify) our physical understanding about the; interaction between the two monomers. V. Potential Surface Scans and Counterpoise Correction Made Easy¶; Finally, let’s consider an example which highlights the advantages of being able to interact with Psi4 directly with Python.; Suppose you want to do a limited potential energy surface scan, such as computing the interaction energy between two neon atoms at various interatomic distances. One simple but unappealing way to do this is to generate separate geometries for each distance to be studied. Instead, we can leverage Python loops and string f",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psiapi-1.html:16581,charge,charge,16581,psi4manual/1.3.2/psiapi-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psiapi-1.html,22,['charge'],['charge']
Energy Efficiency,"mp2 correlation energy atop a T-zeta reference; >>> energy(cbs, corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> energy(cbs, corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> energy(cbs, corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> energy(cbs, corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] a Q5-zeta MP2 calculation, corrected by CCSD(T) at the TQ-zeta extrapolated level, and all-electron CCSD(T) correlation at T-zeta level; >>> energy(cbs, cbs_metadata=[{""wfn"": ""hf"", ""basis"": ""cc-pv5z""}, {""wfn"": ""mp2"", ""basis"": ""cc-pv[q5]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pv[tq]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pvtz"", ""options"": {""freeze_core"": ""False""}}]). >>> # [8] cbs() coupled with database(); >>> TODO database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='sto-3g'). >>> # [9] cbs() coupled with optimize(); >>> TODO optimize('mp2', corl_basis='cc-pV[DT]Z', corl_scheme=corl_xtpl_helgaker_2, func=cbs). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. PSI4 API: Linking C++ and Python; cbs. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.cbs-1.html:14102,energy,energy,14102,psi4manual/1.4.0/api/psi4.driver.cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.cbs-1.html,4,['energy'],['energy']
Energy Efficiency,"mp2 correlation energy atop a T-zeta reference; >>> energy(cbs, corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> energy(cbs, corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> energy(cbs, corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> energy(cbs, corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] a Q5-zeta MP2 calculation, corrected by CCSD(T) at the TQ-zeta extrapolated level, and all-electron CCSD(T) correlation at T-zeta level; >>> energy(cbs, cbs_metadata=[{""wfn"": ""hf"", ""basis"": ""cc-pv5z""}, {""wfn"": ""mp2"", ""basis"": ""cc-pv[q5]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pv[tq]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pvtz"", ""options"": {""freeze_core"": ""False""}}]). >>> # [8] cbs() coupled with database(); >>> TODO database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='sto-3g'). >>> # [9] cbs() coupled with optimize(); >>> TODO optimize('mp2', corl_basis='cc-pV[DT]Z', corl_scheme=corl_xtpl_helgaker_2, func=cbs). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. PSI4 API: Linking C++ and Python; cbs. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2021 02:41AM.; Created using Sphinx 4.3.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.driver.cbs-1.html:14102,energy,energy,14102,psi4manual/1.5.0/api/psi4.driver.cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.driver.cbs-1.html,4,['energy'],['energy']
Energy Efficiency,"mp2-3; OMP2 cc-pVDZ energy for the NO radical. mcscf1; ROHF 6-31G** energy of the \(^{3}B_1\) state of CH2, with Z-matrix input. The occupations are specified explicitly. cc29; CCSD/cc-pVDZ optical rotation calculation (both gauges) on Cartesian H2O2. dct4; DCT calculation for the HF+ using DC-06 functional. This performs both two-step and simultaneous update of the orbitals and cumulant using DIIS extrapolation. Four-virtual integrals are first handled in the MO Basis for the first two energy computations. In the next two the ao_basis=disk algorithm is used, where the transformation of integrals for four-virtual case is avoided. The computation is then repeated using the DC-12 functional with the same algorithms. pywrap-alias; Test parsed and exotic calls to energy() like zapt4, mp2.5, and cisd are working. scf-guess-read3; Test if the the guess read in the same basis converges. dfmp2-4; conventional and density-fitting mp2 test of mp2 itself and setting scs-mp2. ao-dfcasscf-sp; CASSCF/6-31G** energy point. dft-grad-lr1; wB97X-D cc-pVDZ gradient of S22 HCN update df/pk_ref values due to new BraggSlater radii. fsapt-d; Tests SAPT0-D corrections, with a variety of damping functions/parameters. cc52; CCSD Response for H2O2. cc44; Test case for some of the PSI4 out-of-core codes. The code is given only 2.0 MB of memory, which is insufficient to hold either the A1 or B2 blocks of an ovvv quantity in-core, but is sufficient to hold at least two copies of an oovv quantity in-core. cc13; UHF-CCSD/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. mbis-3; MBIS calculation on OH radical. cc4; RHF-CCSD(T) cc-pVQZ frozen-core energy of the BH molecule, with Cartesian input. After the computation, the checkpoint file is renamed, using the PSIO handler. dft-grad-disk; A range-seperated gradient for SO2 to test disk algorithms by explicitly setting low memory. mcscf3; RHF 6-31G** energy of water, using the MCSCF module and Z-matrix input. cisd-sp; 6-31G** H2O Te",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html:14729,energy,energy,14729,psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"mp25); # tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); # PsiMod.print_out(tables); #; # return e_mp25. # A direct translation of a plugin input file into a function call. Function calls are the only; # way to call plugins in sow/reap mode for db(), opt(), etc. This isn't best practices; # but is an example of what to do for a more complicated procedure where different options ; # are set for different qc steps.; #def run_plugin_omega(name, **kwargs):; # r""""""Function encoding sequence of PSI module and plugin calls, as well; # as typical options, to access Rob Parrish's omega plugin.; #; # >>> energy('plugin_omega'); #; # """"""; # lowername = name.lower(); # kwargs = kwargs_lower(kwargs); #; # plugfile = PsiMod.Process.environment[""PSIDATADIR""] + ""/../tests/plugin_omega/plugin_omega.so""; # PsiMod.plugin_load(""%s"" % (plugfile)); #; # PsiMod.set_global_option('BASIS', 'AUG-CC-PVDZ'); # PsiMod.set_global_option('DF_BASIS_SCF', 'AUG-CC-PVDZ-RI'); # PsiMod.set_global_option('REFERENCE', 'UHF'); # PsiMod.set_global_option('SCF_TYPE', 'DF'); # energy('scf', **kwargs); #; # PsiMod.set_global_option('dft_functional', 'wB97'); # PsiMod.set_global_option('dft_order_spherical', 25); # PsiMod.set_global_option('dft_num_radial', 35); # PsiMod.set_global_option('omega_procedure', 'ip'); # PsiMod.set_global_option('maxiter', 50); # PsiMod.set_global_option('d_convergence', 5); # PsiMod.set_global_option('e_convergence', 7); # PsiMod.plugin(""plugin_omega.so""); #; # return PsiMod.get_variable('SCF TOTAL ENERGY'). # Integration with driver routines; #procedures['energy']['mp2.5'] = run_mp2_5; procedures['energy']['sherrillgroup_gold_standard'] = sherrillgroup_gold_standard; #procedures['energy']['plugin_omega'] = run_plugin_omega. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; PSI4 [beta4] » ; Module code ». © Copyright 2013, The Psi4 Project.; Last updated on Mar 20, 2014.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/aliases.html:4981,energy,energy,4981,psi4manual/4.0b4/_modules/aliases.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/aliases.html,9,"['ENERGY', 'energy']","['ENERGY', 'energy']"
Energy Efficiency,"mp2; A special version of SCS-OMP2 (from S22 database); Y; N; RHF/UHF/RKS/UKS. scs-omp2-vdw; A special version of SCS-OMP2 (from ethene dimers); Y; N; RHF/UHF/RKS/UKS. sos-pi-omp2; A special version of SOS-OMP2 for -systems; Y; N; RHF/UHF/RKS/UKS. The orbital-optimized MP3 methods currently supported in PSI4 are outlined in Table OMP3 Methods. Name; Calls Method; Energy; Gradient; Reference. omp3; Orbital-Optimized MP3; Y; N; RHF/UHF/RKS/UKS. scs-omp3; Spin-Component Scaled Orbital-Optimized MP3; Y; N; RHF/UHF/RKS/UKS. sos-omp3; Spin-Opposite Scaled Orbital-Optimized MP3; Y; N; RHF/UHF/RKS/UKS. scsn-omp3; A special version of SCS-OMP3 for nucleobase interactions; Y; N; RHF/UHF/RKS/UKS. scs-mi-omp3; A special version of SCS-OMP3 (from S22 database); Y; N; RHF/UHF/RKS/UKS. scs-omp3-vdw; A special version of SCS-OMP3 (from ethene dimers); Y; N; RHF/UHF/RKS/UKS. sos-pi-omp3; A special version of SOS-OMP3 for -systems; Y; N; RHF/UHF/RKS/UKS. Basic Keywords¶. E_CONVERGENCE¶. Convergence criterion for energy. Type: conv double; Default: 1e-8. R_CONVERGENCE¶. Convergence criterion for amplitudes (residuals). Type: conv double; Default: 1e-5. RMS_MOGRAD_CONVERGENCE¶. Convergence criterion for RMS orbital gradient. Type: conv double; Default: 1e-5. MAX_MOGRAD_CONVERGENCE¶. Convergence criterion for maximum orbital gradient. Type: conv double; Default: 1e-4. MO_MAXITER¶. Maximum number of iterations to determine the orbitals. Type: integer; Default: 50. Advanced Keywords¶. OPT_METHOD¶. The optimization algorithm. Type: string; Possible Values: MSD, DIIS; Default: MSD. DIIS_MAX_VECS¶. Number of vectors used in DIIS. Type: integer; Default: 4. LINEQ_SOLVER¶. The solver will be used for simultaneous linear equations. Type: string; Possible Values: CDGESV, FLIN, POPLE; Default: CDGESV. ORTH_TYPE¶. The algorithm for orthogonalization of MOs. Type: string; Possible Values: GS, MGS; Default: MGS. MP2_OS_SCALE¶. MP2 opposite-spin scaling value. Type: double; Default: 6.0/5.0. MP2_SS_S",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/ompn-1.html:5710,energy,energy,5710,psi4manual/4.0b3/ompn-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/ompn-1.html,2,['energy'],['energy']
Energy Efficiency,"mp2_wfn.compute_energy(); vdh = ssuper.c_alpha() * dfmp2_wfn.variable('MP2 CORRELATION ENERGY'). # remove misleading MP2 psivars computed with DFT, not HF, reference; for var in dfmp2_wfn.variables():; if var.startswith('MP2 ') and ssuper.name() not in ['MP2D']:; scf_wfn.del_variable(var). scf_wfn.set_variable(""DOUBLE-HYBRID CORRECTION ENERGY"", vdh) # P::e SCF; scf_wfn.set_variable(""{} DOUBLE-HYBRID CORRECTION ENERGY"".format(ssuper.name()), vdh); returnvalue += vdh; scf_wfn.set_variable(""DFT TOTAL ENERGY"", returnvalue) # P::e SCF; for pv, pvv in scf_wfn.variables().items():; if pv.endswith('DISPERSION CORRECTION ENERGY') and pv.startswith(ssuper.name()):; fctl_plus_disp_name = pv.split()[0]; scf_wfn.set_variable(fctl_plus_disp_name + ' TOTAL ENERGY', returnvalue); break; else:; scf_wfn.set_variable('{} TOTAL ENERGY'.format(ssuper.name()), returnvalue). scf_wfn.set_variable('CURRENT ENERGY', returnvalue); scf_wfn.set_energy(returnvalue); core.print_out('\n\n'); core.print_out(' %s Energy Summary\n' % (name.upper())); core.print_out(' ' + '-' * (15 + len(name)) + '\n'); core.print_out(' DFT Reference Energy = %22.16lf\n' % (returnvalue - vdh)); core.print_out(' Scaled MP2 Correlation = %22.16lf\n' % (vdh)); core.print_out(' @Final double-hybrid DFT total energy = %22.16lf\n\n' % (returnvalue)); core.tstop(). if ssuper.name() == 'MP2D':; for pv, pvv in dfmp2_wfn.variables().items():; scf_wfn.set_variable(pv, pvv). # Conversely, remove DFT qcvars from MP2D; for var in scf_wfn.variables():; if 'DFT ' in var or 'DOUBLE-HYBRID ' in var:; scf_wfn.del_variable(var). # DFT groups dispersion with SCF. Reshuffle so dispersion with MP2 for MP2D.; for pv in ['SCF TOTAL ENERGY', 'SCF ITERATION ENERGY', 'MP2 TOTAL ENERGY']:; scf_wfn.set_variable(pv, scf_wfn.variable(pv) - scf_wfn.variable('DISPERSION CORRECTION ENERGY')). scf_wfn.set_variable('MP2D CORRELATION ENERGY', scf_wfn.variable('MP2 CORRELATION ENERGY') + scf_wfn.variable('DISPERSION CORRECTION ENERGY')); scf_wfn.set_variabl",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:77512,Energy,Energy,77512,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,7,['Energy'],['Energy']
Energy Efficiency,"mp3 = psi4.get_variable(""MP3 CORRELATION ENERGY""); psi4.set_variable(""CURRENT ENERGY"",emp3); psi4.set_variable(""CURRENT CORRELATION ENERGY"",cemp3); elif ( lowername == 'fno-mp3' ):; emp3 = psi4.get_variable(""MP3 TOTAL ENERGY""); cemp3 = psi4.get_variable(""MP3 CORRELATION ENERGY""); psi4.set_variable(""CURRENT ENERGY"",emp3); psi4.set_variable(""CURRENT CORRELATION ENERGY"",cemp3); elif ( lowername == 'mp4(sdq)'):; emp4sdq = psi4.get_variable(""MP4(SDQ) TOTAL ENERGY""); cemp4sdq = psi4.get_variable(""MP4(SDQ) CORRELATION ENERGY""); psi4.set_variable(""CURRENT ENERGY"",emp4sdq); psi4.set_variable(""CURRENT CORRELATION ENERGY"",cemp4sdq); elif ( lowername == 'fno-mp4(sdq)'):; emp4sdq = psi4.get_variable(""MP4(SDQ) TOTAL ENERGY""); cemp4sdq = psi4.get_variable(""MP4(SDQ) CORRELATION ENERGY""); psi4.set_variable(""CURRENT ENERGY"",emp4sdq); psi4.set_variable(""CURRENT CORRELATION ENERGY"",cemp4sdq); elif ( lowername == 'fno-mp4'):; emp4 = psi4.get_variable(""MP4 TOTAL ENERGY""); cemp4 = psi4.get_variable(""MP4 CORRELATION ENERGY""); psi4.set_variable(""CURRENT ENERGY"",emp4); psi4.set_variable(""CURRENT CORRELATION ENERGY"",cemp4); elif (lowername == 'fnocc-mp') and (level == 4):; emp4 = psi4.get_variable(""MP4 TOTAL ENERGY""); cemp4 = psi4.get_variable(""MP4 CORRELATION ENERGY""); psi4.set_variable(""CURRENT ENERGY"",emp4); psi4.set_variable(""CURRENT CORRELATION ENERGY"",cemp4). # restore options; optstash.restore(). return psi4.get_variable(""CURRENT ENERGY""). [docs]def run_cepa(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a cepa-like calculation. >>> energy('cepa(1)'). """"""; lowername = name.lower(); uppername = name.upper(); kwargs = p4util.kwargs_lower(kwargs). # save user options; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['FNOCC', 'NAT_ORBS'],; ['FNOCC', 'RUN_CEPA'],; ['FNOCC', 'USE_DF_INTS'],; ['FNOCC', 'CEPA_NO_SINGLES']). psi4.set_local_option('FNOCC','RUN_CEPA', True); psi4.set_local_option('FNOCC','USE_DF_INTS', False). # what type of cepa?; cepa_level = upp",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/proc.html:71708,ENERGY,ENERGY,71708,psi4manual/4.0b5/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/proc.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"mp3', **kwargs); e_scf = PsiMod.get_variable('SCF TOTAL ENERGY'); ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; PsiMod.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25); PsiMod.set_variable('MP2.5 TOTAL ENERGY', e_mp25); PsiMod.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); PsiMod.set_variable('CURRENT ENERGY', e_mp25). # build string of title banner and print results; banners = ''; banners += """"""PsiMod.print_out('\\n')\n""""""; banners += """"""banner(' MP2.5 ')\n""""""; banners += """"""PsiMod.print_out('\\n')\n\n""""""; exec(banners). tables = ''; tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); PsiMod.print_out(tables). return e_mp25. # A direct translation of a plugin input file into a function call. Function calls are the only; # way to call plugins in sow/reap mode for db(), opt(), etc. This isn't best practices; # but is an example of what to do for a more complicated procedure where different options ; # are set for different qc steps.; [docs]def run_plugin_omega(name, **kwargs):; r""""""Function encoding sequence of PSI module and plugin calls, as well; as typical options, to access Rob Parrish's omega plugin. >>> energy('plugin_omega'). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). plugfile = PsiMod.Process.environment[""PSIDATADIR""] + ""/../tests/plugin_omega/plugin_omega.so""; PsiMod.plugin_load(""%s"" % (plugfile)). PsiMod.set_global_option('BASIS', 'AUG-CC-PVDZ'); PsiMod.set_global_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/aliases.html:3723,energy,energy,3723,psi4manual/4.0b3/_modules/aliases.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/aliases.html,2,['energy'],['energy']
Energy Efficiency,"mp3-3; OMP3 cc-pCVDZ energy with B3LYP initial guess for the NO radical. sapt-ecp; sapt0 of charged system in ECP basis set. dct11; Restricted DF-DCT ODC-12 energies with linearly dependent basis functions. sapt3; SAPT2+3(CCD) aug-cc-pVDZ+midbond computation of the water dimer interaction energy, using the aug-cc-pVDZ-JKFIT DF basis for SCF and aug-cc-pVDZ-RI for SAPT. dft-grad-lr1; wB97X-D cc-pVDZ gradient of S22 HCN update df/pk_ref values due to new BraggSlater radii. opt-multi-frozen-dimer-c2h; Frozen-fragment opt of C2h methane dimer with user-combined reference points. casscf-sp; CASSCF/6-31G** energy point. mbis-3; MBIS calculation on OH radical. dfrasscf-sp; 6-31G** H2O Test RASSCF Energy Point will default to only singles and doubles in the active space. opt-multi-dimer-c1; Multi-fragment opt of C2h methane dimer with user-combined reference points. scf-hess1; RHF STO-3G (Cartesian) and cc-pVDZ (spherical) water Hessian test, against Psi3 reference values. ao-casscf-sp; CASSCF/6-31G** energy point. cisd-sp-2; 6-31G** H2O Test CISD Energy Point. omp2p5-1; OMP2.5 cc-pVDZ energy for the H2O molecule. fnocc6; Test method/basis with disk_df. cc43; RHF-CC2-LR/STO-3G optical rotation of (S)-methyloxirane. gauge = both, omega = (589 355 nm). nbody-vmfc-gradient; Computation of VMFC-corrected water trimer gradient (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). cc48; reproduces dipole moments in J.F. Stanton’s “biorthogonal” JCP paper. pywrap-opt-sowreap; Finite difference optimization, run in sow/reap mode. soscf-ref; Triple and Singlet Oxygen energy SOSCF, also tests non-symmetric density matrices. basis-ecp; check mixing ECP and non-ECP orbital/fitting basis sets in a session. dct2; DC-06 calculation for the He dimer. This performs a two-step update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the MO Basis. cc36; CC2(RHF)/cc-pVDZ energy of H2O. dct-grad1; Various DCT analytic gradients for the O2 molec",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html:38804,energy,energy,38804,psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"mp4':; core.set_local_option('FNOCC', 'RUN_MP4', True); core.set_local_option('FNOCC', 'COMPUTE_MP4_TRIPLES', True); core.set_local_option('FNOCC', 'COMPUTE_TRIPLES', True). # throw an exception for open-shells; if core.get_option('SCF', 'REFERENCE') != 'RHF':; raise ValidationError(""""""Error: %s requires 'reference rhf'."""""" % name). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if core.get_option('FNOCC', 'USE_DF_INTS') == False:; # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_option('SCF', 'SCF_TYPE'), ref_wfn); else:; scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). fnocc_wfn = core.fnocc(ref_wfn). # set current correlation energy and total energy. only need to treat mpn here.; if name == 'mp3':; emp3 = core.get_variable(""MP3 TOTAL ENERGY""); cemp3 = core.get_variable(""MP3 CORRELATION ENERGY""); core.set_variable(""CURRENT ENERGY"", emp3); core.set_variable(""CURRENT CORRELATION ENERGY"", cemp3); elif name == 'fno-mp3':; emp3 = core.get_variable(""MP3 TOTAL ENERGY""); cemp3 = core.get_variable(""MP3 CORRELATION ENERGY""); core.set_variable(""CURRENT ENERGY"", emp3); core.set_variable(""CURRENT CORRELATION ENERGY"", cemp3); elif name == 'mp4(sdq)':; emp4sdq = core.get_variable(""MP4(SDQ) TOTAL ENERGY""); cemp4sdq = core.get_variable(""MP4(SDQ) CORRELATION ENERGY""); core.set_variable(""CURRENT ENERGY"", emp4sdq); core.set_variable(""CURRENT CORRELATION ENERGY"", cemp4sdq); elif name == 'fno-mp4(sdq)':; emp4sdq = core.get_variable(""MP4(SDQ) TOTAL ENERGY""); cemp4sdq = core.get_variable(""MP4(SDQ) CORRELATION ENERGY""); core.set_variable(""CURRENT ENERGY"", emp4sdq); core.set_variable(""CURRENT CORRELATION ENERGY"", cemp4sdq); elif nam",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html:119837,energy,energy,119837,psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,2,['energy'],['energy']
Energy Efficiency,"mparison to castup2) that output file doesn’t depend on options (scf_type) being set global or local. This input uses local. pywrap-molecule; Check that C++ Molecule class and qcdb molecule class are reading molecule input strings identically. olccd-grad2; OLCCD cc-pVDZ gradient for the NO radical. sapt10; usapt example with empty beta due to frozen core. dft-ghost; DFT Functional Test for Range-Seperated Hybrids and Ghost atoms. cc-module; check that CC is returning the same values btwn CC*, FNOCC, and DFOCC modules. cc50; EOM-CC3(ROHF) on CH radical with user-specified basis and properties for particular root. nbody-vmfc-gradient; Computation of VMFC-corrected water trimer gradient (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). omp3-5; SOS-OMP3 cc-pVDZ geometry optimization for the H2O molecule. psimrcc-pt2; Mk-MRPT2 single point. \(^1A_1\) F2 state described using the Ms = 0 component of the singlet. Uses TCSCF singlet orbitals. fd-freq-energy; SCF STO-3G finite-difference frequencies from energies for H2O. cbs-xtpl-dict; Extrapolated water energies. dfomp3-2; DF-OMP3 cc-pVDZ energy for the H2O+ cation. dfremp-1; density fitted REMP/cc-pVDZ energies for the CO2 molecule. fci-dipole; 6-31G H2O Test FCI Energy Point. pywrap-align-chiral; testing aligner on enantiomers based on Table 1 of 10.1021/ci100219f aka J Chem Inf Model 2010 50(12) 2129-2140. opt-irc-1; Compute the IRC for HOOH torsional rotation at the RHF/DZP level of theory. cc19; CCSD/cc-pVDZ dipole polarizability at two frequencies. cbs-xtpl-freq; Various gradients for a strained helium dimer and water molecule. linK-1; RHF Linear Exchange Algorithm test for water. stability3; Test LDA stability analysis against QChem. freq-isotope2; Vibrational and thermo analysis of several water isotopologs. Demonstrates Hessian reuse for different temperatures, pressures, and isotopologs. cisd-h2o-clpse; 6-31G** H2O Test CISD Energy Point with subspace collapse. soscf-ref; Triple and Singlet Oxygen ene",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html:11325,energy,energy,11325,psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"mperature. ESP AT CENTER n¶; Property of electrostatic potential [E_h / e] at location, usually atom center, n. FCI TOTAL ENERGY¶. FCI CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the full configuration interaction level of theory. GIBBS FREE ENERGY¶; Total Gibbs free energy [E_h], free enthalpy at given temperature. GIBBS FREE ENERGY CORRECTION¶; Sum of electronic, translational, rotational, and vibrational corrections [E_h] to the free enthalpy at given temperature. GRID ELECTRONS TOTAL¶. GRID ELECTRONS ALPHA¶. GRID ELECTRONS BETA¶; The number of electrons integrated by the xc quadrature grid. HF TOTAL ENERGY¶; The total electronic energy [E_h] for the Hartree–Fock method, without; any dispersion correction; the first three (or four, since; \(E_{xc} = 0\)) terms in Eq. (4). Quantity \(E_{\text{HF}}\); in Eq. (4). HF KINETIC ENERGY¶; The total kinetic energy [E_h] of the Hartree–Fock method. HF POTENTIAL ENERGY¶; The total potential energy [E_h] of the Hartree–Fock method. HF VIRIAL RATIO¶; The virial ratio of the Hartree–Fock method. Only defined for a fully quantum mechanical computation, i.e., not QM/MM. HF TOTAL GRADIENT¶; The total electronic gradient [E_h/a0] of the Hartree–Fock method, ({nat}, 3). HF DIPOLE GRADIENT¶; The derivative of the Hartree–Fock method dipole [E_h a0/u] = [(e a0/a0)^2/u] with respect to nuclear perturbations; as a degree-of-freedom by dipole component array, (3 * {nat}, 3). HF TOTAL HESSIAN¶; The total electronic second derivative [E_h/a0/a0] for the Hartree-Fock method, (3 * {nat}, 3 * {nat}). LCCD TOTAL ENERGY¶. LCCD CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the linearized coupled cluster doubles level of theory. LCCSD TOTAL ENERGY¶. LCCSD CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the linearized coupled cluster singles and doubles level of theory. LCC2 (+LMP2) TOTAL EN",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html:32472,energy,energy,32472,psi4manual/1.7.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html,4,['energy'],['energy']
Energy Efficiency,"mple inputs are provided in; psi4/samples, in directories starting with the name adc. The most; important keyword is ROOTS_PER_IRREP, which is an array; giving the number of excited states desired for each irreducible; representation. Implementation¶; Some very essential points are emphasized for understanding of the; nature and the limitations of the theory. The ADC(2) response matrix,; denoted as , is expanded in the single (S) and double (D); excitation manifolds as. where the superscript on each matrix block indicates the order of; the fluctuation. Instead of solving the above equation explicitly,; the large D manifold is treated effectively as. This form of the ADC(2) equation requires 7 – 10 iterations for; convergence on only one root. But thanks to Newton-Raphson; acceleration,. the computational time reduces to shorter than half of the simple iterative; procedure. Construction of the denominator of the second term in the above; equation is less computationally expensive than contruction of one $sigma$-vector with respect to the effective response matrix. The non-iterative excitation energy stated above is calculated as a diagonal element of the Davidson mini-Hamiltonian matrix in the SEM as,. where and denote the CIS; excitation energy and wave function, respectively. The explicit form of the; σ-vector is provided in a note accompanying the source code,; in the file psi4/src/bin/adc/sigma.pdf. Table Of Contents. ADC: Ab Initio Polarization Propagator; Partial Renormalization Scheme; Using the ADC(2) code; Implementation. Previous topic; SAPT: Symmetry-Adapted Perturbation Theory; Next topic; Scalar relativistic Hamiltonians. This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; Psi4 [1.0.0 6a9a71b] » ; Theoretical Methods: SCF to FCI ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/adc-1.html:6163,energy,energy,6163,psi4manual/1.0.0/adc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/adc-1.html,4,['energy'],['energy']
Energy Efficiency,"mple, (1, 2)@(1, 2, 3, 4) indicates that the; fragments 1 and 2 are explicitly included in the energy computation,; with basis functions from each of fragments 1, 2, 3, & 4 included in; the basis set. Therefore, the basis functions from fragments 3 and 4; are included as ghost functions within the energy computation. NUCLEAR REPULSION ENERGY¶; The nuclear repulsion energy contribution [Eh] to the total SCF energy.; Quantity \(E_{NN}\) in Eq. (4). (3)¶\[E_{NN} = \sum_{i, j<i}^{N_{atom}}\frac{Z_i Z_j}{|\mathbf{R}_i - \mathbf{R}_j|}\]. OCEPA(0) TOTAL ENERGY¶. OCEPA(0) CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the orbital-optimized CEPA(0) level of theory. OLCCD TOTAL ENERGY¶. OLCCD CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the orbital-optimized linearized coupled cluster doubles level of theory. OLCCD REFERENCE CORRECTION ENERGY¶; The additional correction to the SCF reference energy [Eh]; for the orbital-optimized linearized coupled cluster doubles level of theory. OMP2 TOTAL ENERGY¶. OMP2 CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the orbital-optimized MP2 level of theory. OMP2.5 TOTAL ENERGY¶. OMP2.5 CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the orbital-optimized MP2.5 level of theory. OMP3 TOTAL ENERGY¶. OMP3 CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the orbital-optimized MP3 level of theory. ONE-ELECTRON ENERGY¶; The one-electron energy contribution [Eh] to the total SCF energy.; Quantity \(E_{1e^-}\) in Eq. (4). PCM POLARIZATION ENERGY¶; The energy contribution [Eh] from the polarizable continuum model for solvation. PE ENERGY¶; The energy contribution [Eh] from the polarizable embedding model for solvation. QCISD TOTAL ENERGY¶. QCISD CORRELATION ENERGY¶; The total electronic energy [Eh] and co",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html:33508,energy,energy,33508,psi4manual/1.4.0/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html,5,['energy'],['energy']
Energy Efficiency,"mple, setting; REFERENCE will appropriately set CFOUR_REFERENCE. For a; list of applicable keywords, see source of; muster_psi4options.; Consult Functionality for information on what Cfour; functionality is accessible through PSI4. PSI4 for Cfour Users¶; In the simplest use of the Psi4/Cfour interface, a PSI4 input file; can simply “wrap” a ZMAT file and execute xcfour. This is; illustrated in the following example:; cfour {; UHF-SCF energy calculation; N; H 1 R; H 1 R 2 A. R=1.008; A=105.0. *ACES2(CALC=HF,BASIS=qz2p; MULT=2,REF=UHF; OCCUPATION=3-1-1-0/3-0-1-0; SCF_CONV=12; MEMORY=20000000); }. energy('cfour'). Here, the contents of the cfour {...} block are written directly to a; ZMAT file. This is joined by a default GENBAS file; (psi4/psi4/share/psi4/basis/GENBAS). To preferentially use your own GENBAS,; place it in PATH or PSIPATH. The line calling; energy() with argument 'cfour' invokes; xcfour.; After execution of the energy('cfour') line completes, Cfour results; are read back into PSI4 format and are thereafter accessible for; further processing in the input file. See Output for; details. This storage of results in variables and arrays in memory for; the duration of the PSI4 instance (as opposed to solely in files); is the only advantage thus far incurred by the P4C4 interface. We’ll call; this mode of basic utility the “sandwich” mode.; Molecule specification in PSI4 allows Cartesians, Z-matrices, mixed; Cartesian/Z-matrix, negation of variables, delayed specification of; variables, specification of fragments, etc., all in a whitespace-tolerant; format. See Molecule and Geometry Specification for details and; cfour/mints5 for examples. When a PSI4-style molecule is; supplied, its geometry is written to ZMAT in Cartesian form and the; CFOUR_COORDINATES=CARTESIAN, CFOUR_UNITS=ANGSTROM,; CFOUR_CHARGE, and CFOUR_MULTIPLICITY keywords are set; appropriately in the *CFOUR(...) directive. Warning; There exist molecules (e.g., allene) where the; inertial frame is no",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/cfour-1.html:3583,energy,energy,3583,psi4manual/1.4.0/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/cfour-1.html,9,['energy'],['energy']
Energy Efficiency,"mples were simple single-point energy computations; (as specified by the energy() function). Of course there are other; kinds of computations to perform, such as geometry optimizations and; vibrational frequency computations. These can be specified by replacing; energy() with optimize() or frequency(), respectively.; Here’s an example of optimizing the H2O molecule using Hartree–Fock with; a cc-pVDZ basis set (located in; tu3-h2o-opt).; #! Optimize H2O HF/cc-pVDZ. memory 250 mb. molecule h2o {; O ; H 1 0.96; H 1 0.96 2 104.5; }. set basis cc-pVDZ; optimize('scf'). This should perform a series of gradient computations. The gradient points; which way is downhill in energy, and the optimizer then modifies the; geometry to follow the gradient. After a few cycles, the geometry should; converge with a message like Optimization is complete!. As indicated; in the following table (printed by the optimizer at the end of the; computation and grep-able with ~), the energy decreases with each step,; and the maximum force on each atom also decreases with each step (in; principle these numbers could increase in some iterations, but here they do; not).; --------------------------------------------------------------------------------------------------------------- ~; Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~; --------------------------------------------------------------------------------------------------------------- ~; 1 -76.026632734857 -76.026632734857 0.01523505 0.01245744 0.02742199 0.02277500 ~; 2 -76.027022668419 -0.000389933562 0.00178749 0.00142923 0.01007985 0.00594840 ~; 3 -76.027032729361 -0.000010060942 0.00014016 0.00008485 0.00077279 0.00044621 ~; --------------------------------------------------------------------------------------------------------------- ~. To get harmonic vibrational frequencies, first we must set up an input; using the OPTIMIZED GEOMETRY. We can easily get the optimized geometry; from the previous computation. Looking at",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/tutorial-1.html:5187,energy,energy,5187,psi4manual/4.0b4/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/tutorial-1.html,4,['energy'],['energy']
Energy Efficiency,"mples were simple single-point energy computations; (as specified by the energy() function). Of course there are other; kinds of computations to perform, such as geometry optimizations and; vibrational frequency computations. These can be specified by replacing; energy() with optimize() or frequency(), respectively.; Here’s an example of optimizing the H2O molecule using Hartree–Fock with; a cc-pVDZ basis set (located in; tu3-h2o-opt).; #! Optimize H2O HF/cc-pVDZ. memory 250 mb. molecule h2o {; O ; H 1 0.96; H 1 0.96 2 104.5; }. set basis cc-pVDZ; optimize('scf'). This should perform a series of gradient computations. The gradient points; which way is downhill in energy, and the optimizer then modifies the; geometry to follow the gradient. After a few cycles, the geometry should; converge with a message like Optimization is complete!. As indicated; in the following table (printed by the optimizer at the end of the; computation and grep-able with ~), the energy decreases with each step,; and the maximum force on each atom also decreases with each step (in; principle these numbers could increase in some iterations, but here they do; not).; --------------------------------------------------------------------------------------------------------------- ~; Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~; --------------------------------------------------------------------------------------------------------------- ~; 1 -76.026632734857 -76.026632734857 0.01523505 0.01245744 0.02742199 0.02277500 ~; 2 -76.027022668419 -0.000389933562 0.00178749 0.00142923 0.01007985 0.00594840 ~; 3 -76.027032729361 -0.000010060942 0.00014016 0.00008485 0.00077279 0.00044621 ~; --------------------------------------------------------------------------------------------------------------- ~. To get harmonic vibrational frequencies, it’s important to keep in mind that; the values of the vibrational frequencies are a function of the molecular; geometry. Therefore, it’s import",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/tutorial-1.html:5837,energy,energy,5837,psi4manual/1.0.0/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/tutorial-1.html,2,['energy'],['energy']
Energy Efficiency,"mponent-scaled OMP2 (SCS-OMP2)? In all computation, SCS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SCS-OMP2, one needs to set ‘DO_SCS’ to true. Type: boolean; Default: false. DO_SCS (OMP3); OMP3 — Do perform spin-component-scaled OMP3 (SCS-OMP3)? In all computation, SCS-OMP3 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SCS-OMP3, one needs to set ‘DO_SCS’ to true. Type: boolean; Default: false. DO_SINGLETS (CPHF); CPHF — Do singlet states? Default true. Type: boolean; Default: true. DO_SOS (OMP2); OMP2 — Do perform spin-opposite-scaled OMP2 (SOS-OMP2)? In all computation, SOS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SOS-OMP2, one needs to set ‘DO_SOS’ to true. Type: boolean; Default: false. DO_SOS (OMP3); OMP3 — Do perform spin-opposite-scaled OMP3 (SOS-OMP3)? In all computation, SOS-OMP3 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SOS-OMP3, one needs to set ‘DO_SOS’ to true. Type: boolean; Default: false. DO_THIRD_ORDER (SAPT); SAPT (Expert) — Do compute third-order corrections?. Type: boolean; Default: false. DO_TRIPLETS (CPHF); CPHF — Do triplet states? Default true. Type: boolean; Default: true. DOCC (GLOBALS); GLOBALS — An array containing the number of doubly-occupied orbitals per irrep (in Cotton order). Type: array; Default: No Default. DOCC (MCSCF); MCSCF — The number of doubly occupied orbitals, per irrep. Type: array; Default: No Default. DOMAIN_PRINT (CIS); CIS — Do print the domains?. Type: boolean; Default: false. DOMAIN_PRINT_EXIT (LMP2); LMP2 — Do exit after printing the domains?. Type: boolean; Default: false. DOMAINS (CIS); CIS —. Type: array; Default: No Default. E3_SCALE (OMP3); OMP3 — Scaling value for 3rd order energy correction (S. Grimme, V",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html:34529,energy,energy,34529,psi4manual/4.0b3/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html,2,['energy'],['energy']
Energy Efficiency,"mponents into a minimum number of calculations. Aliases:complete_basis_set(). Returns:(float) – Total electronic energy in Hartrees. PSI variables:. CBS TOTAL ENERGY; CBS REFERENCE ENERGY; CBS CORRELATION ENERGY; CURRENT ENERGY; CURRENT REFERENCE ENERGY; CURRENT CORRELATION ENERGY. Caution; Some features are not yet implemented. Buy a developer a coffee. No way to tell function to boost fitting basis size for all calculations.; Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in several; sequential stages (scf, corl, delta1, delta2, … ) covering treatment; of the reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction, etc.. Each is activated by its; stage_wfn keyword, or as a field in the `cbs_metadata` list, and is only; allowed if all preceding stages are active. Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy.; The cbs() function requires, at a minimum, name='scf' and scf_basis; keywords to be specified for reference-step only jobs and name and; corl_basis keywords for correlated jobs.; The following energy methods have been set up for cbs(). scf; hf; mp2; mp2.5; mp3; mp4(sdq); mp4; mpn. omp2; omp2.5; omp3; olccd; lccd; lccsd; cepa(0); cepa(1). cepa(3); acpf; aqcc; qcisd; cc2; ccsd; fno-ccsd; bccd. cc3; qcisd(t); ccsd(t); fno-ccsd(t); bccd(t); cisd; cisdt. cisdtq; cin; fci; mrccsd; mrccsd(t); mrccsdt; mrccsdt(q). Parameters:; name (str) – 'scf' || 'ccsd' || etc.; First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be 'scf'. Overruled if stage_wfn keywords supplied. scf_wfn (str) – \(\Rightarrow\) 'scf' \(\Leftarrow\) || 'c4-scf' || etc.; Indicates the energy method for which the referen",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/cbs-1.html:2895,energy,energy,2895,psi4manual/1.3.2/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/cbs-1.html,2,['energy'],['energy']
Energy Efficiency,"mport optproc. __all__ = ['free_atom_volumes']. [docs]; def free_atom_volumes(wfn: psi4.core.Wavefunction, **kwargs):; """""" ; Computes free-atom volumes using MBIS density partitioning.; The free-atom volumes are computed for all unique (inc. basis set); atoms in a molecule and stored as wavefunction variables, :psivar:`MBIS FREE ATOM n VOLUME`.; Free-atom densities are computed at the same level of theory as the molecule, ; and we use unrestricted references as needed in computing the ground-state. . The free-atom volumes are used to compute volume ratios in routine MBIS computations. Parameters; ----------; wfn; The wave function associated with the molecule, method, and basis for ; atomic computations; """""". # If we're already a free atom, break to avoid recursion; # We don't ever need volume ratios for free atoms since they; # are by definition 1.0; natom = wfn.molecule().natom(); if natom == 1:; return 0 ; . # the level of theory; current_en = wfn.scalar_variable('CURRENT ENERGY'); total_energies = [k for k, v in wfn.scalar_variables().items() if abs(v - current_en) <= 1e-12]; theory = """"; for var in total_energies:; if 'TOTAL ENERGY' in var:; var = var.split(); if var[0] == 'SCF':; continue; elif var[0] == 'DFT':; theory = wfn.functional().name(); else:; theory = var[0]. # list of reference number of unpaired electrons.; # Note that this is not the same as the; # total spin of the ground state atom; reference_S = [; 0, 1, 0, 1, 0, 1, 2, 3, 2, 1, 0, 1, 0, 1, 2, 3, 2, 1, 0, 1, 0, 1, 2, 3, 6, 5, 4, 3, 2, 1, 0, 1, 2, 3, 2, 1, 0,; 1, 0, 1, 2, 5, 6, 5, 4, 3, 0, 1, 0, 1, 2, 3, 2, 1, 0, 1, 0, 1, 0, 3, 4, 5, 6, 7, 8, 5, 4, 3, 2, 1, 0, 1, 2, 3,; 4, 5, 4, 3, 2, 1, 0, 1, 2, 3, 2, 1, 0; ]. # the parent molecule and reference type; mol = wfn.molecule(). # Get unique atoms by input symbol,; # Be to handle different basis sets; unq_atoms = set(); for atom in range(mol.natom()):; symbol = mol.symbol(atom); Z = int(mol.Z(atom)); basis = mol.basis_on_atom(atom); unq_atoms.add((symb",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/prop_util.html:2186,ENERGY,ENERGY,2186,psi4manual/1.8.x/_modules/psi4/driver/p4util/prop_util.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/prop_util.html,3,['ENERGY'],['ENERGY']
Energy Efficiency,"mport p4util. if TYPE_CHECKING:; import qcportal. logger = logging.getLogger(__name__). EnergyGradientHessianWfnReturn = Union[float, core.Matrix, Tuple[Union[float, core.Matrix], core.Wavefunction]]. [docs]; class BaseComputer(qcel.models.ProtoModel):; """"""Base class for ""computers"" that plan, run, and process QC tasks."""""". [docs]; @abc.abstractmethod; def compute(self):; pass. [docs]; @abc.abstractmethod; def plan(self):; pass. class Config(qcel.models.ProtoModel.Config):; extra = ""allow""; allow_mutation = True. [docs]; class AtomicComputer(BaseComputer):; """"""Computer for analytic single-geometry computations."""""". molecule: Any = Field(..., description=""The molecule to use in the computation.""); basis: str = Field(..., description=""The quantum chemistry basis set to evaluate (e.g., 6-31g, cc-pVDZ, ...).""); method: str = Field(..., description=""The quantum chemistry method to evaluate (e.g., B3LYP, MP2, ...).""); driver: DriverEnum = Field(..., description=""The resulting type of computation: energy, gradient, hessian, properties.""; ""Note for finite difference that this should be the target driver, not the means driver.""); keywords: Dict[str, Any] = Field(default_factory=dict, description=""The keywords to use in the computation.""); protocols: Optional[Union[AtomicResultProtocols, Dict[str, Any]]] = Field({""stdout"": True}, description=""Output modifications.""); tag: str = Field(""*"", description=""The tags to pass along to compute managers.""); priority: str = Field(1, description=""The priority of a Task; higher priority will be pulled first. {high:2, normal:1, low:0}""); owner_group: Optional[str] = Field(None, description=""group in the chown sense.""); computed: bool = Field(False, description=""Whether quantum chemistry has been run on this task.""); result: Any = Field(default_factory=dict, description="":py:class:`~qcelemental.models.AtomicResult` return.""); result_id: Optional[str] = Field(None, description=""The optional ID for the computation.""). class Config(qcel.models",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_base.html:2750,energy,energy,2750,psi4manual/1.8.x/_modules/psi4/driver/task_base.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_base.html,6,['energy'],['energy']
Energy Efficiency,"mpotent part of OPDM and the density cumulant; . As a result, the energy functional is Hermitian,; which is important for the evaluation of the molecular properties. The additive; separability of the density cumulant guarantees that all of the DCFT methods; are size-extensive and size-consistent. Furthermore, the N-representability; problem is now greatly simplified, because the idempotent part of the OPDM is; N-representable by construction. One only needs to worry about the; N-representability of the density cumulant, which is a relatively small part of; the TPDM.; In order to obtain the DCFT energy, two conditions must be satisfied:; 1) The energy must be stationary with respect to the variation of the; idempotent part of the one-particle density matrix . This is; achieved by the self-consistent diagonalization of the generalized Fock; operator matrix defined above, which introduces the relaxation of the orbitals.; 2) The energy must be stationary with respect to the variation of the density; cumulant , constrained to the N-representability conditions.; Making the energy stationary requires the solution of the two sets of coupled; equations for the orbital and cumulant updates, respectively (also known as; residual equations). At the present moment three different algorithms for the; solution of the system of coupled equations are available (see section; Iterative Algorithms for details).; Publications resulting from the use of the DCFT code should cite contributions; listed here. Methods¶; Currently two DCFT methods (functionals) are available: DC-06 and DC-12. Both; methods use approximate N-representability conditions derived from the; second-order perturbation theory, but differ in the description of the; correlated (non-idempotent) part of the one-particle density; matrix. While in the DC-06 method is derived from the density cumulant; in an approximate way, the DC-12 method derives this contribution exactly, and; therefore takes full advantage of the N-repre",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/dcft-1.html:3231,energy,energy,3231,psi4manual/4.0b4/dcft-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/dcft-1.html,4,['energy'],['energy']
Energy Efficiency,"mput. 11, 2126-2136 (2015)). scf-ecp2; Water-Argon complex with ECP present; check of RHF Hessian. pywrap-align; apply linear fragmentation algorithm to a water cluster. scf-level-shift-rks; SCF level shift on an RKS computation. fci-coverage; 6-31G H2O Test for coverage. dfccsdat1; DF-CCSD(AT) cc-pVDZ energy for the H2O molecule. cc2; 6-31G** H2O CCSD optimization by energies, with Z-Matrix input. omp2-5; SOS-OMP2 cc-pVDZ geometry optimization for the H2O molecule. fsapt-d; Tests SAPT0-D corrections, with a variety of damping functions/parameters. matrix1; An example of using BLAS and LAPACK calls directly from the Psi input file, demonstrating matrix multiplication, eigendecomposition, Cholesky decomposition and LU decomposition. These operations are performed on vectors and matrices provided from the Psi library. mints-helper; A general test of the MintsHelper function. cc10; ROHF-CCSD cc-pVDZ energy for the \(^2\Sigma^+\) state of the CN radical. olccd3; OLCCD cc-pVDZ energy with ROHF initial guess for the NO radical. pywrap-freq-e-sowreap; Finite difference of energies frequency, run in sow/reap mode. dfmp2-3; DF-MP2 cc-pVDZ frozen core gradient of benzene, computed at the DF-SCF cc-pVDZ geometry. cepa2; cc-pvdz H2O Test ACPF Energy/Properties. cc34; RHF-CCSD/cc-pVDZ energy of H2O partitioned into pair energy contributions. mints8; Patch of a glycine with a methyl group, to make alanine, then DF-SCF energy calculation with the cc-pVDZ basis set. psimrcc-sp1; Mk-MRCCSD single point. \(^3 \Sigma ^-\) O2 state described using the Ms = 0 component of the triplet. Uses ROHF triplet orbitals. density-screen-1; RHF Density Matrix based-Integral Screening Test for water. fnocc7; Test fnocc with linear dependencies. sapt5; SAPT0 aug-cc-pVTZ computation of the charge transfer energy of the water dimer. fsapt-ext-abc; FSAPT with external charge on trimer. isapt1; This test case shows an example of running and analyzing an FI-SAPT0/jun-cc-pvdz computation for 2,4-pentanedio",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html:45116,energy,energy,45116,psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"mputation has actually converged to the expected accuracy. dfremp-2; density fitted REMP/cc-pVDZ energies for the CH3 radical. opt1; SCF STO-3G geometry optimzation, with Z-matrix input. sapt-ecp; sapt0 of charged system in ECP basis set. cc41; RHF-CC2-LR/cc-pVDZ optical rotation of H2O2. gauge = both, omega = (589 355 nm). cbs-xtpl-energy; Extrapolated water energies - density-fitted version. sapt-dft-api; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. sapt-dft-lrc; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. cc2; 6-31G** H2O CCSD optimization by energies, with Z-Matrix input. cc27; Single point gradient of 1-1B2 state of H2O with EOM-CCSD. mp3-grad2; MP3 cc-pVDZ gradient for the NO radical. cc28; CCSD/cc-pVDZ optical rotation calculation (length gauge only) on Z-mat H2O2. dfccsdat2; DF-A-CCSD(T) cc-pVDZ energy for the NH molecule. props4; Electrostatic potential and electric field evaluated on a grid around water. dfccsdat1; DF-CCSD(AT) cc-pVDZ energy for the H2O molecule. dfmp2-2; Density fitted MP2 energy of H2, using density fitted reference and automatic looping over cc-pVDZ and cc-pVTZ basis sets. Results are tabulated using the built in table functions by using the default options and by specifiying the format. dfomp3-grad1; DF-OMP3 cc-pVDZ gradients for the H2O molecule. dfccd-grad1; DF-CCSD cc-pVDZ gradients for the H2O molecule. omp2-4; SCS-OMP2 cc-pVDZ geometry optimization for the H2O molecule. omp3-5; SOS-OMP3 cc-pVDZ geometry optimization for the H2O molecule. pywrap-align; apply linear fragmentation algorithm to a water cluster. cc50; EOM-CC3(ROHF) on CH radical with user-specified basis and properties for particular root. opt-irc-1; Compute the IRC for HOOH torsional rotation at the RHF/DZP level of theory. mp2-h; check that methods can act on single atom. nbody-he-4b; MP2/aug-cc-pvDZ many body energies of an arbitrary Helium complex, addressing 4-body formulas. dft-ghost; DFT Functional Test for Range-Sepera",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html:26170,energy,energy,26170,psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"mputation is run to get the natural orbitals; this allows a meaningful partitioning of the virtual orbitals into groups of different importance. Next, the RASCI is run. The split-virtual CISD[TQ] takes all singles and doubles, and all triples and quadruples with no more than 2 electrons in the secondary virtual subspace (RAS 3). If any electrons are present in the tertiary virtual subspace (RAS 4), then that excitation is only allowed if it is a single or double. omp2-1; OMP2 cc-pVDZ energy for the H2O molecule. scf-upcast-custom-basis; test scf castup with custom basis sets. matrix1; An example of using BLAS and LAPACK calls directly from the Psi input file, demonstrating matrix multiplication, eigendecomposition, Cholesky decomposition and LU decomposition. These operations are performed on vectors and matrices provided from the Psi library. opt2-fd; SCF DZ allene geometry optimzation, with Cartesian input. omp2p5-grad1; OMP2.5 cc-pVDZ gradient for the H2O molecule. fnocc5; Test FNO-DF-CCSD(T) energy. mints1; Symmetry tests for a range of molecules. This doesn’t actually compute any energies, but serves as an example of the many ways to specify geometries in Psi4. scf-ecp; Water-Argon complex with ECP present; check of energies and forces. olccd1; OLCCD cc-pVDZ energy for the H2O molecule. psithon2; Accesses basis sets, databases, plugins, and executables in non-install locations. dft-pruning; Tests all grid pruning options available and screening of small weights. Check against grid size. psimrcc-fd-freq2; Mk-MRCCSD frequencies. \(^1A_1\) O$_3` state described using the Ms = 0 component of the singlet. Uses TCSCF orbitals. rasci-c2-active; 6-31G* C2 Test RASCI Energy Point, testing two different ways of specifying the active space, either with the ACTIVE keyword, or with RAS1, RAS2, RESTRICTED_DOCC, and RESTRICTED_UOCC. cbs-xtpl-energy; Extrapolated water energies. dct2; DC-06 calculation for the He dimer. This performs a two-step update of the orbitals and cumul",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html:39348,energy,energy,39348,psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"mputation of the formamide dimer interaction energy, using the aug-cc-pVDZ-JKFIT DF basis for SCF and aug-cc-pVDZ-RI for SAPT. This example uses frozen core as well as MP2 natural orbital approximations. cc26; Single-point gradient, analytic and via finite-differences of 2-1A1 state of H2O with EOM-CCSD. scf-guess-read2; Test if the the guess read in the same basis converges. dft-pbe0-2; Internal match to psi4, test to match to literature values in litref.in/litref.out. gibbs; Test Gibbs free energies at 298 K of N2, H2O, and CH4. props2; DF-SCF cc-pVDZ of benzene-hydronium ion, scanning the dissociation coordinate with Python’s built-in loop mechanism. The geometry is specified by a Z-matrix with dummy atoms, fixed parameters, updated parameters, and separate charge/multiplicity specifiers for each monomer. One-electron properties computed for dimer and one monomer. cc50; EOM-CC3(ROHF) on CH radical with user-specified basis and properties for particular root. tu1-h2o-energy; Sample HF/cc-pVDZ H2O computation. opt3; SCF cc-pVDZ geometry optimzation, with Z-matrix input. psimrcc-pt2; Mk-MRPT2 single point. \(^1A_1\) F2 state described using the Ms = 0 component of the singlet. Uses TCSCF singlet orbitals. scf-bz2; Benzene Dimer Out-of-Core HF/cc-pVDZ. cisd-opt-fd; H2O CISD/6-31G** Optimize Geometry by Energies. rasci-ne; Ne atom RASCI/cc-pVQZ Example of split-virtual CISD[TQ] from Sherrill and Schaefer, J. Phys. Chem. XXX This uses a “primary” virtual space 3s3p (RAS 2), a “secondary” virtual space 3d4s4p4d4f (RAS 3), and a “tertiary” virtual space consisting of the remaining virtuals. First, an initial CISD computation is run to get the natural orbitals; this allows a meaningful partitioning of the virtual orbitals into groups of different importance. Next, the RASCI is run. The split-virtual CISD[TQ] takes all singles and doubles, and all triples and quadruples with no more than 2 electrons in the secondary virtual subspace (RAS 3). If any electrons are present in ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/testsuite-1.html:31618,energy,energy,31618,psi4manual/1.1.0/testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/testsuite-1.html,12,['energy'],['energy']
Energy Efficiency,"mputation, performed by applying a finite electric field and numerical differentiation. cbs-xtpl-gradient; Various gradients for a strained helium dimer and water molecule. dct-grad2; RHF-ODC-12 analytic gradient computations for H2O use AO_BASIS=DISK and AO_BASIS=NONE, respectively. RHF-ODC-06 analytic gradient computations for H2O use AO_BASIS=DISK and AO_BASIS=NONE, respectively. dfomp3-1; DF-OMP3 cc-pVDZ energy for the H2O molecule. scf3; File retention, docc, socc, and bond distances specified explicitly. scf-ecp3; Water-Argon complex with ECP present; check of UHF Hessian. opt13; B3LYP cc-pVDZ geometry optimzation of phenylacetylene, starting from not quite linear structure updated reference due to new BraggSlater radii. dfomp2p5-grad2; DF-OMP2.5 cc-pVDZ gradients for the H2O+ cation. cisd-h2o+-0; 6-31G** H2O+ Test CISD Energy Point. basis-ecp; check mixing ECP and non-ECP orbital/fitting basis sets in a session. dfmp2-1; Density fitted MP2 cc-PVDZ/cc-pVDZ-RI computation of formic acid dimer binding energy using automatic counterpoise correction. Monomers are specified using Cartesian coordinates. fci-coverage; 6-31G H2O Test for coverage. mints5; Tests to determine full point group symmetry. Currently, these only matter for the rotational symmetry number in thermodynamic computations. cc50; EOM-CC3(ROHF) on CH radical with user-specified basis and properties for particular root. cc30; CCSD/sto-3g optical rotation calculation (length gauge only) at two frequencies on methyloxirane. tu5-sapt; Example SAPT computation for ethene*ethine (i.e., ethylene*acetylene), test case 16 from the S22 database. explicit-am-basis; Check that basis sets can be input with explicit angular momentum format. omp2-grad2; OMP2 cc-pVDZ gradient for the NO radical. pywrap-checkrun-convcrit; Advanced python example sets different sets of scf/post-scf conv crit and check to be sure computation has actually converged to the expected accuracy. fsapt-ext; Quick test of external potential i",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html:26805,energy,energy,26805,psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"mputational chemistry directives; we’ve seen in the previous examples; we call this mixture Psithon.; The Python computer language is very easy to pick up, and even users; previously unfamiliar with Python can use it to simplify tasks by; modifying some of the example input files supplied with PSI4; in the psi4/samples directory.; Suppose you want to do a limited potential energy surface scan, such as; computing the interaction energy between two neon atoms at various; interatomic distances. One simple but unappealing way to do this is to; create separate input files for each distance to be studied. But most of; these input files are identical, except that the interatomic distance is; different. Psithon lets you specify all this in a single input file,; looping over the different distances with an array like this:; Rvals=[2.5, 3.0, 4.0].; Let’s also suppose you want to do counterpoise (CP) corrected energies.; Counterpoise correction involves computing the dimer energy and then; subtracting out the energies of the two monomers, each evaluated in the; dimer basis. Again, each of these computations could be run in a separate; input file, but because counterpoise correction is a fairly standard; procedure for intermolecular interactions, PSI4 knows about it and has; a built-in routine to perform counterpoise correction. It only needs to; know what method you want to do the counterpoise correction on (here, let’s; consider CCSD(T)), and it needs to know what’s monomer A and what’s monomer; B. This last issue of specifying the monomers separately was already dealt; with in the previous SAPT example, where we saw that two dashes in the; molecule block can be used to separate monomers.; So, we’re going to do counterpoise-corrected CCSD(T) energies for Ne2 at; a series of different interatomic distances. And let’s print out a table; of the interatomic distances we’ve considered, and the CP-corrected CCSD(T); interaction energies (in kcal mol-1) at each geometry. Doing all th",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/tutorial-1.html:14993,energy,energy,14993,psi4manual/4.0b2/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/tutorial-1.html,8,['energy'],['energy']
Energy Efficiency,"mputational method; for the correlation energy, unless only reference step to be performed,; in which case should be 'scf'. Overruled if stage_wfn keywords supplied. scf_wfn (string) – \(\Rightarrow\) 'scf' \(\Leftarrow\) || 'c4-scf' || etc.; Indicates the energy method for which the reference energy is to be; obtained. Generally unnecessary, as ‘scf’ is the scf in PSI4 but; can be used to direct lone scf components to run in PSI4 or Cfour; in a mixed-program composite method. corl_wfn (string) – 'mp2' || 'ccsd(t)' || etc.; Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with name or as the unlabeled; first argument to the function. delta_wfn (string) – 'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. delta_wfn_lesser (string) – \(\Rightarrow\) corl_wfn \(\Leftarrow\) || 'mp2' || etc.; Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. delta2_wfn (string) – 'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. delta2_wfn_lesser (string) – \(\Rightarrow\) delta_wfn \(\Leftarrow\) || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. delta3_wfn (string) – 'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a third delta correction; to the correlation energy is to be obtained. delta3_wfn_lesser (string) – \(\Rightarrow\) delta2_wfn \(\Leftarrow\) || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a third delta correction; to the correlation energy is to be obtained. delta4_wfn (string) – 'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a fourth delta correction; to the correlation energy is to be obtained. delta4",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/cbs-1.html:4361,energy,energy,4361,psi4manual/1.2.1/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/cbs-1.html,14,['energy'],['energy']
Energy Efficiency,"mputations on water and its cation, using all of the different integral algorithms. This tests both the ERI and ERF integrals. cbs-xtpl-freq; Various gradients for a strained helium dimer and water molecule. scf6; Tests RHF/ROHF/UHF SCF gradients. opt13; B3LYP cc-pVDZ geometry optimzation of phenylacetylene, starting from not quite linear structure updated reference due to new BraggSlater radii. scf1; RHF cc-pVQZ energy for the BH molecule, with Cartesian input. dfep2-2; Compute three IP and 2 EA’s for the PH3 molecule. dft-dldf; Dispersionless density functional (dlDF+D) internal match to Psi4 Extensive testing has been done to match supplemental info of Szalewicz et. al., Phys. Rev. Lett., 103, 263201 (2009) and Szalewicz et. al., J. Phys. Chem. Lett., 1, 550-555 (2010). cc13c; Tests RHF CCSD(T)gradients. omp2-grad2; OMP2 cc-pVDZ gradient for the NO radical. sapt8; SAPT0(ROHF) open-shell computation of CN - Ne interaction energy First with jun-cc-pVDZ and density fitted integrals with ROHF Then with cc-pVDZ and direct integrals, except for dispersion that is computed with cc-pVDZ-ri density fitting with ROHF. psimrcc-fd-freq1; Mk-MRCCSD single point. \(^3 \Sigma ^-\) O2 state described using the Ms = 0 component of the triplet. Uses ROHF triplet orbitals. mom; Maximum Overlap Method (MOM) Test. MOM is designed to stabilize SCF convergence and to target excited Slater determinants directly. props2; DF-SCF cc-pVDZ of benzene-hydronium ion, scanning the dissociation coordinate with Python’s built-in loop mechanism. The geometry is specified by a Z-matrix with dummy atoms, fixed parameters, updated parameters, and separate charge/multiplicity specifiers for each monomer. One-electron properties computed for dimer and one monomer. castup1; Test of SAD/Cast-up (mainly not dying due to file weirdness). fcidump; test FCIDUMP functionality for rhf/uhf. fnocc5; Test FNO-DF-CCSD(T) energy. cepa3; cc-pvdz H2O Test coupled-pair CISD against DETCI CISD. cc12; Single point energ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html:6996,energy,energy,6996,psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"mputations to perform, such as geometry optimizations and vibrational frequency computations. These can be specified by replacing psi4.energy() API with; psi4.optimize() API or psi4.frequency() API, respectively.; Let’s take a look at an example of optimizing the H\(_2\)O molecule using Hartree-Fock with a cc-pVDZ basis set.; Now, here comes the real beauty of running Psi4 interactively: above, when we computed the energy of H\(_2\)O with HF/cc-pVDZ, we defined the Psi4 molecule object h2o. Since we’re still in the Python shell, as long as you executed that block of code, we can reuse the h2o molecule object in our optimization without redefining it, by adding the molecule=h2o argument to the psi4.optimize(); API function:. [5]:. psi4.set_options({'reference': 'rhf'}); psi4.optimize('scf/cc-pvdz', molecule=h2o). Optimizer: Optimization complete!. [5]:. -76.02703272937504. This should perform a series of gradient computations. The gradient points which way is downhill in energy, and the optimizer then modifies the geometry to follow the gradient. After a few cycles, the geometry should converge with a message like Optimization complete!. As indicated in the following table (printed by the optimizer at the end of the computation and grep-able with ~), the energy decreases with each step, and the maximum force on each atom also decreases with each step (in; principle, these numbers could increase in some iterations, but here they do not).; --------------------------------------------------------------------------------------------------------------- ~  Step         Total Energy             Delta E       MAX Force       RMS Force        MAX Disp        RMS Disp  ~ --------------------------------------------------------------------------------------------------------------- ~     1     -76.026632734908    -76.026632734908      0.01523518      0.01245755      0.02742222      0.02277530  ~     2     -76.027022666011     -0.000389931104      0.00178779      0.00142946     ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psiapi-1.html:7583,energy,energy,7583,psi4manual/1.3.2/psiapi-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psiapi-1.html,9,['energy'],['energy']
Energy Efficiency,"mputations to perform, such as geometry optimizations and vibrational frequency computations. These can be specified by replacing psi4.energy() API with; psi4.optimize() API or psi4.frequency() API, respectively.; Let’s take a look at an example of optimizing the H\(_2\)O molecule using Hartree-Fock with a cc-pVDZ basis set.; Now, here comes the real beauty of running Psi4 interactively: above, when we computed the energy of H\(_2\)O with HF/cc-pVDZ, we defined the Psi4 molecule object h2o. Since we’re still in the Python shell, as long as you executed that block of code, we can reuse the h2o molecule object in our optimization without redefining it, by adding the molecule=h2o argument to the psi4.optimize(); API function:. [5]:. psi4.set_options({'reference': 'rhf'}); psi4.optimize('scf/cc-pvdz', molecule=h2o). Optimizer: Optimization complete!. [5]:. -76.02703272937504. This should perform a series of gradient computations. The gradient points which way is downhill in energy, and the optimizer then modifies the geometry to follow the gradient. After a few cycles, the geometry should converge with a message like Optimization complete!. As indicated in the following table (printed by the optimizer at the end of the computation and grep-able with ~), the energy decreases with each step, and the maximum force on each atom also decreases with each step; (in principle, these numbers could increase in some iterations, but here they do not).; --------------------------------------------------------------------------------------------------------------- ~; Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~; --------------------------------------------------------------------------------------------------------------- ~; 1 -76.026632734908 -76.026632734908 0.01523518 0.01245755 0.02742222 0.02277530 ~; 2 -76.027022666011 -0.000389931104 0.00178779 0.00142946 0.01008137 0.00594928 ~; 3 -76.027032729374 -0.000010063363 0.00014019 0.00008488 0.00077463 0.0004473",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/psiapi.html:7457,energy,energy,7457,psi4manual/1.9.x/psiapi.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/psiapi.html,2,['energy'],['energy']
Energy Efficiency,"mputations; in PSI4 use density-fitted SAPT0 as the underlying SAPT methodology. Interested; users should consult the manual page for Ed Hohenstein’s SAPT0 code; and the SAPT literature to understand the specifics of SAPT0 before beginning; with F/I-SAPT0.; F-SAPT is detailed over two papers: [Parrish:2014:044115] on our much-earlier; “atomic” SAPT (A-SAPT) and [Parrish:2014:4417] on the finished “functional; group” SAPT (F-SAPT). An additional paper describes how to use F-SAPT to analyze; differences under functional group substitutions [Parrish:2014:17386]. I-SAPT; is explained in [Parrish:2015:051103]. There is also a reasonably-detailed; review of the aims of A/F/I-SAPT and the existing state-of-the-art in the field; in the introduction chapter on partitioned SAPT methods in Parrish’s thesis.; The scripts discussed below are located in psi4/psi4/share/psi4/fsapt. F-SAPT: A Representative Example¶; Below, we show an example of using F-SAPT0/jun-cc-pVDZ to analyze the; distribution of the intermolecular interaction energy components between the; various hydroxyl and phenyl moieties of the phenol dimer. This example is; explicitly included in fsapt1. A video; lecture explaining this example is available F-SAPT#1,; while an additional video describing how to plot the order-1 F-SAPT analysis; with PyMol and perform a “difference F-SAPT”; analysis is available F-SAPT#2:; memory 1 GB. molecule mol {; 0 1; O -1.3885044 1.9298523 -0.4431206; H -0.5238121 1.9646519 -0.0064609; C -2.0071056 0.7638459 -0.1083509; C -1.4630807 -0.1519120 0.7949930; C -2.1475789 -1.3295094 1.0883677; C -3.3743208 -1.6031427 0.4895864; C -3.9143727 -0.6838545 -0.4091028; C -3.2370496 0.4929609 -0.7096126; H -0.5106510 0.0566569 1.2642563; H -1.7151135 -2.0321452 1.7878417; H -3.9024664 -2.5173865 0.7197947; H -4.8670730 -0.8822939 -0.8811319; H -3.6431662 1.2134345 -1.4057590; --; 0 1; O 1.3531168 1.9382724 0.4723133; H 1.7842846 2.3487495 1.2297110; C 2.0369747 0.7865043 0.1495491; C 1.590402",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/fisapt.html:2020,energy,energy,2020,psi4manual/1.8.x/fisapt.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/fisapt.html,3,['energy'],['energy']
Energy Efficiency,"mpute()[0]. [docs] def y(self, atom):; """"""y position of atom (0-indexed) in Bohr. >>> print H2OH2O.y(4); -0.706268134631. """"""; return self.input_units_to_au * self.atoms[atom].compute()[1]. [docs] def z(self, atom):; """"""z position of atom (0-indexed) in Bohr. >>> print H2OH2O.z(4); -1.43347254509. """"""; return self.input_units_to_au * self.atoms[atom].compute()[2]. [docs] def xyz(self, atom, posn=None):; """"""Returns a Vector3 with x, y, z position of atom (0-indexed); in Bohr or coordinate at *posn*. >>> print H2OH2O.xyz(4); [3.175492014248769, -0.7062681346308132, -1.4334725450878665]. """"""; temp = scale(self.atoms[atom].compute(), self.input_units_to_au); if posn >= 0:; return temp[posn]; else:; return temp. [docs] def mass(self, atom):; """"""Returns mass of atom (0-indexed). >>> print H2OH2O.mass(4); 1.00782503207. """"""; if self.atoms[atom].mass() != 0.0:; return self.atoms[atom].mass(). if math.fabs(self.atoms[atom].Z() - int(self.atoms[atom].Z())) > 0.0:; print ""WARNING: Obtaining masses from atom with fractional charge...may be incorrect!!!\n""; # TODO outfile; return an2masses[int(self.atoms[atom].Z())]. [docs] def symbol(self, atom):; """"""Returns the cleaned up label of the atom (C2 => C, H4 = H) (0-indexed). >>> print H2OH2O.symbol(4); H. """"""; return self.atoms[atom].symbol(). [docs] def label(self, atom):; """"""Returns the original label of the atom (0-indexed) as given in the input file (C2, H4). >>> print H2OH2O.label(4); H3. """"""; return self.atoms[atom].label(). [docs] def charge(self, atom):; """"""Returns charge of atom (0-indexed).; Related to SAD guess in libmints version. >>> print H2OH2O.charge(4); 1.0. """"""; return self.atoms[atom].charge(). [docs] def fZ(self, atom):; """"""Nuclear charge of atom (includes dummies). >>> print H2OH2O.fZ(4); 8. """"""; return self.full_atoms[atom].Z(). [docs] def fx(self, atom):; """"""x position of atom (0-indexed, includes dummies) in Bohr. >>> print H2OH2O.fx(4); 2.55231135823. """"""; return self.input_units_to_au * self.full_atoms[ato",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html:7097,charge,charge,7097,psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html,6,['charge'],['charge']
Energy Efficiency,"mpute_gradient; compute_gradient(...) unbound psi4.Wavefunction method. compute_gradient( (Wavefunction)arg1) -> Matrix :. docstring; C++ signature :. N5boost10shared_ptrIN3psi6MatrixEEE compute_gradient(N3psi12WavefunctionE {lvalue}). psi4.Wavefunction.deep_copy()¶; Python Library Documentation: method deep_copy; deep_copy(...) unbound psi4.Wavefunction method. deep_copy( (Wavefunction)arg1, (Wavefunction)arg2) -> None :. docstring; C++ signature :. void deep_copy(N3psi12WavefunctionE {lvalue},N5boost10shared_ptrIN3psi12WavefunctionEEE). psi4.Wavefunction.doccpi()¶; Python Library Documentation: method doccpi; doccpi(...) unbound psi4.Wavefunction method. doccpi( (Wavefunction)arg1) -> Dimension :. docstring; C++ signature :. N3psi9DimensionE doccpi(N3psi12WavefunctionE {lvalue}). psi4.Wavefunction.energy()¶; Python Library Documentation: method energy; energy(...) unbound psi4.Wavefunction method. energy( (Wavefunction)arg1) -> float :. docstring; C++ signature :. d energy(N3psi12WavefunctionE {lvalue}). psi4.Wavefunction.epsilon_a()¶; Python Library Documentation: method epsilon_a; epsilon_a(...) unbound psi4.Wavefunction method. epsilon_a( (Wavefunction)arg1) -> Vector :. docstring; C++ signature :. N5boost10shared_ptrIN3psi6VectorEEE epsilon_a(N3psi12WavefunctionE {lvalue}). psi4.Wavefunction.epsilon_a_subset()¶; Python Library Documentation: method epsilon_a_subset; epsilon_a_subset(...) unbound psi4.Wavefunction method. epsilon_a_subset( (Wavefunction)arg1, (str)arg2, (str)arg3) -> Vector :. docstring; C++ signature :. N5boost10shared_ptrIN3psi6VectorEEE epsilon_a_subset(N3psi12WavefunctionE {lvalue},Ss,Ss). psi4.Wavefunction.epsilon_b()¶; Python Library Documentation: method epsilon_b; epsilon_b(...) unbound psi4.Wavefunction method. epsilon_b( (Wavefunction)arg1) -> Vector :. docstring; C++ signature :. N5boost10shared_ptrIN3psi6VectorEEE epsilon_b(N3psi12WavefunctionE {lvalue}). psi4.Wavefunction.epsilon_b_subset()¶; Python Library Documentation: method eps",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:360023,energy,energy,360023,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['energy'],['energy']
Energy Efficiency,"mputed identically between cfour and psi4. cfour/sp-rohf-scf; single-point HF/qz2p on NH2. cfour/opt-rhf-scf; optimization HF/svp on water. cfour/psi-uhf-scsmp2; UHF MP2 energy components. Checks that computed identically between cfour and psi4. cfour/sp-rhf-ccsd; single point CCSD/qz2p on water. cfour/kw-2; testing best practices options, part ii. cfour/sp-rhf-ccsd_t_-ao-ecc; single-point CCSD(T)/qc2p on water with ecc, aobasis. cfour/psi-uhf-mp3; UHF MP3 energy components. Checks that converted identically between cfour and psi4. cfour/mp2-1; All-electron MP2 6-31G** geometry optimization of water. cfour/kw-1; testing best practices options, part i. cfour/sp-rohf-ccsd_t_; single-point CCSD(T)/qz2p on NH2. cfour/kw-5; Basis set spherical/Cartesian with basis and cfour_spherical. cfour/sp-rohf-ccsd_t_-ao-ecc; single-point CCSD(T)/qz2p on NH2 with ecc, aobasis. cfour/sp-uhf-ccsdt; single-point CCSDT/qz2p on NH2. cfour/sp-rohf-ccsd; single-point CCSD/qz2p on NH2. cfour/psi-rohf-scsmp2; ROHF MP2 energy components. Checks that computed identically between cfour and psi4. cfour/psi-rhf-scsmp2; MP2 energy components. Checks that computed identically between cfour and psi4. cfour/sp-rhf-ccsd_t_-fc; single-point CCSD(T)/qz2p on water with ecc, aobasis, and frozen-core. cfour/puream; Basis set spherical/Cartesian behavior in cfour. cfour/sp-uhf-ccsd_t_-ao; single-point CCSD(T)/qz2p on NH2 with aobasis. cfour/psi-a24-grad; geometry after three optimization cycles on A24 database, cfour matches psi4. cfour/sp-uhf-ccsd; single-point CCSD/qz2p on NH2. cfour/sp-rhf-ccsd_t_-ecc; single-point CCSD(T)/qz2p on water with ecc module. cfour/sp-rhf-cc3; single-point CC3/qz2p on water. cfour/scf4; RHF cc-pVDZ energy for water, automatically scanning the symmetric stretch and bending coordinates using Python’s built-in loop mechanisms. The geometry is apecified using a Z-matrix with variables that are updated during the potential energy surface scan, and then the same procedure is performe",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_cfour-1.html:3943,energy,energy,3943,psi4manual/1.4.0/autodoc_testsuite_cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_cfour-1.html,2,['energy'],['energy']
Energy Efficiency,"mputed wrt an old benchmark, S22A; >>> database('df-mp2','S22',cp=1,subset=[16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(); if not('db_name' in kwargs) and db_name:; kwargs['db_name'] = db_name. # Establish function to call; if not('db_func' in kwargs):; if ('func' in kwargs):; kwargs['db_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['db_func'] = energy; func = kwargs['db_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper database.' % (func.__name__)); if (func is cp):; raise ValidationError('Wrapper database is unhappy to be calling function \'%s\'. Use the cp keyword within database instead.' % (func.__name__)). # Define path and load module for requested database; sys.path.append('%sdatabases' % (PsiMod.Process.environment[""PSIDATADIR""])); sys.path.append('%s/lib/databases' % PsiMod.psi_top_srcdir()); database = import_ignorecase(db_name); if database is None:; PsiMod.print_out('\nPython module for database %s failed to load\n\n' % (db_name)); PsiMod.print_out('\nSearch path that was tried:\n'); PsiMod.print_out("", "".join(map(str, sys.path))); raise ValidationError(""Python module loading problem for database "" + str(db_name)); else:; dbse = database.dbse; HRXN = database.HRXN; ACTV = database.ACTV; RXNM = database.RXNM; BIND = database.BIND; TAGL = database.TAG",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:29605,energy,energy,29605,psi4manual/4.0b4/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html,2,['energy'],['energy']
Energy Efficiency,"mputer specifies a single model chemistry level (see self.nbodies_per_mc_level), the; return is a dictionary, nbody_results, described in the table below. Many of the items are actually filled; by successive calls to assemble_nbody_components(). When multiple model chemistry levels are specified, this; function diverts its return to driver_nbody_multilevel.prepare_results() wherein each mc level calls this; function again and collects separate nbody_results dictionaries and processes them into a final return that; is a small subset of the table below. Return type; nbody_results. ptype_size = (1,)/(nat, 3)/(3 * nat, 3 * nat)e/g/h := energy or gradient or Hessian; rtd := return_total_data. item; size; present / zeroed; contents / interpretation. ret_ptype; ptype_size; always. interaction data requested: IE or total (depending on return_total_data) e/g/h (depending on driver)with cp/nocp/vmfc treatment (depending on 1st of bsse_type). ret_energy; 1; always; interaction energy: IE or total (depending on return_total_data) w/ cp/nocp/vmfc treat. (dep. on 1st of bsse_type). ret_gradient; (nat, 3); when driver is g/h; interaction gradient: IE or total (depending on return_total_data) w/ cp/nocp/vmfc treat. (dep. on 1st of bsse_type. ret_hessian; (nat * 3, nat * 3); when driver is h; interaction Hessian: IE or total (depending on return_total_data) w/ cp/nocp/vmfc treat. (dep. on 1st of bsse_type). nbody; >=1; always; energy n-body QCVariables to be set.   CP-CORRECTED TOTAL ENERGY THROUGH 1-BODY;   1; when cp in bsse_type; MBE sum of subsystems of 1-body. summed are total energies with cp treatment.   CP-CORRECTED TOTAL ENERGY THROUGH 2-BODY;   1; when cp in bsse_type & max_nbody>=2; MBE sum of subsystems of 2-body or fewer (cumulative); summed are total energies with cp treatment.   CP-CORRECTED TOTAL ENERGY THROUGH {nb}-BODY;   1; when cp in bsse_type; MBE sum of subsystems of {max_nbody}-body or fewer (cumulative); summed are total energies w/ cp treatment.   CP-CORRECTE",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/nbody.html:10060,energy,energy,10060,psi4manual/1.6.x/nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/nbody.html,1,['energy'],['energy']
Energy Efficiency,"ms where diffuse basis sets are used. This problem may be avoided by using; canonical orthogonalization, in which an asymmetric inverse square root of the; overlap matrix is formed, with numerical stability enhanced by the elimination; of eigenvectors corresponding to very small eigenvalues. As a few combinations; of AO basis functions may be discarded, the number of canonical-orthogonalized; OSOs and MOs may be slightly smaller than the number of AOs. In PSI4,; symmetric orthogonalization is used by default, unless the smallest overlap; eigenvalue falls below the user-supplied double option S_TOLERANCE, which; defaults to 1E-7. If the smallest eigenvalue is below this cutoff, canonical; orthogonalization is forced, and all eigenvectors corresponding to eigenvalues; below the cutoff are eliminated. Use of canonical orthogonalization can be; forced by setting the S_ORTHOGONALIZATION option to CANONICAL. Note; that in practice, the MOs and OSOs are built separately within each irrep from; the symmetry-adapted combinations of AOs known as Unique Symmetry Orbitals; (USOs). For canonical orthogonalization, this implies that the number of MOs; and OSOs per irrep may be slightly smaller than the number of USOs per irrep.; A contrived example demonstrating OSOs/MOs vs. AOs with symmetry is shown; below:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; symmetry c2 # Two irreps is easier to comprehend; }. set {; s_tolerance 0.0001 # Set an unreasonably tight; # tolerance to force canonical; basis aug-cc-pv5z # This diffuse basis will have; # small-ish eigenvalues for even H2O; print 3; }. energy('scf'). Output:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18==> Pre-Iterations <==. -------------------------------------------------------; Irrep Nso Nmo Nalpha Nbeta Ndocc Nsocc; -------------------------------------------------------; A 145 145 0 0 0 0; B 142 142 0 0 0 0; ----------------------------------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/scf-1.html:13333,adapt,adapted,13333,psi4manual/1.1.0/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/scf-1.html,6,['adapt'],['adapted']
Energy Efficiency,"ms where diffuse basis sets are used. This problem may be avoided by using; canonical orthogonalization, in which an asymmetric inverse square root of the; overlap matrix is formed, with numerical stability enhanced by the elimination; of eigenvectors corresponding to very small eigenvalues. As a few combinations; of AO basis functions may be discarded, the number of canonical-orthogonalized; OSOs and MOs may be slightly smaller than the number of AOs. In PSI4,; symmetric orthogonalization is used by default, unless the smallest overlap; eigenvalue falls below the user-supplied double option S_TOLERANCE, which; defaults to 1E-7. If the smallest eigenvalue is below this cutoff, canonical; orthogonalization is forced, and all eigenvectors corresponding to eigenvalues; below the cutoff are eliminated. Use of canonical orthogonalization can be; forced by setting the S_ORTHOGONALIZATION option to CANONICAL. Note; that in practice, the MOs and OSOs are built separately within each irrep from; the symmetry-adapted combinations of AOs known as Unique Symmetry Orbitals; (USOs). For canonical orthogonalization, this implies that the number of MOs; and OSOs per irrep may be slightly smaller than the number of USOs per irrep.; A contrived example demonstrating OSOs/MOs vs. AOs with symmetry is shown; below:; molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; symmetry c2 # Two irreps is easier to comprehend; }. set {; s_tolerance 0.0001 # Set an unreasonably tight; # tolerance to force canonical; basis aug-cc-pv5z # This diffuse basis will have; # small-ish eigenvalues for even H2O; }. energy('scf'). Output:; ... Initialization ... ==> Pre-Iterations <==. Minimum eigenvalue in the overlap matrix is 1.6888059293E-05.; Using Canonical Orthogonalization with cutoff of 1.0000000000E-04.; Overall, 3 of 287 possible MOs eliminated. ... Initial Orbital Guess Information ... -------------------------------------------------------; Irrep Nso Nmo Nalpha Nbeta Ndocc Nsocc; -----------------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/scf-1.html:10077,adapt,adapted,10077,psi4manual/4.0b2/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf-1.html,8,['adapt'],['adapted']
Energy Efficiency,"ms where diffuse basis sets are used. This problem may be avoided by using; canonical orthogonalization, in which an asymmetric inverse square root of the; overlap matrix is formed, with numerical stability enhanced by the elimination; of eigenvectors corresponding to very small eigenvalues. As a few combinations; of AO basis functions may be discarded, the number of canonical-orthogonalized; OSOs and MOs may be slightly smaller than the number of AOs. In Psi4,; symmetric orthogonalization is used by default, unless the smallest overlap; eigenvalue falls below the user-supplied double option S_TOLERANCE, which; defaults to 1E-7. If the smallest eigenvalue is below this cutoff, canonical; orthogonalization is forced, and all eigenvectors corresponding to eigenvalues; below the cutoff are eliminated. Use of canonical orthogonalization can be; forced by setting the S_ORTHOGONALIZATION option to CANONICAL. Note; that in practice, the MOs and OSOs are built separately within each irrep from; the symmetry-adapted combinations of AOs known as Unique Symmetry Orbitals; (USOs). For canonical orthogonalization, this implies that the number of MOs; and OSOs per irrep may be slightly smaller than the number of USOs per irrep.; A contrived example demonstrating OSOs/MOs vs. AOs with symmetry is shown; below:; molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; symmetry c2 # Two irreps is easier to comprehend; }. set {; s_tolerance 0.0001 # Set an unreasonably tight; # tolerance to force canonical; basis aug-cc-pv5z # This diffuse basis will have; # small-ish eigenvalues for even H2O; }. energy('scf'). Output:; ... Initialization ... ==> Pre-Iterations <==. Minimum eigenvalue in the overlap matrix is 1.6888059293E-05.; Using Canonical Orthogonalization with cutoff of 1.0000000000E-04.; Overall, 3 of 287 possible MOs eliminated. ... Initial Orbital Guess Information ... -------------------------------------------------------; Irrep Nso Nmo Nalpha Nbeta Ndocc Nsocc; -----------------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/scf-1.html:11428,adapt,adapted,11428,psi4manual/1.0.0/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/scf-1.html,2,['adapt'],['adapted']
Energy Efficiency,"ms']). [docs] def print_out(self):; """"""Format dispersion parameters of `self` for output file."""""". text = []; text.append("" => {}: Empirical Dispersion <="".format(; (self.fctldash.upper() if self.fctldash.upper() else 'Custom'))); text.append(''); text.append(self.description); text.append(self.dashlevel_citation.rstrip()); if self.dashparams_citation:; text.append("" Parametrisation from:{}"".format(self.dashparams_citation.rstrip())); text.append(''); for op in self.ordered_params:; text.append("" %6s = %14.6f"" % (op, self.dashparams[op])); text.append('\n'). core.print_out('\n'.join(text)). [docs] def compute_energy(self, molecule: core.Molecule, wfn: core.Wavefunction = None) -> float:; """"""Compute dispersion energy based on engine, dispersion level, and parameters in `self`. Parameters; ----------; molecule; System for which to compute empirical dispersion correction.; wfn; Location to set QCVariables. Returns; -------; float; Dispersion energy [Eh]. Notes; -----; :psivar:`DISPERSION CORRECTION ENERGY`; Disp always set. Overridden in SCF finalization, but that only changes for ""-3C"" methods.; :psivar:`fctl DISPERSION CORRECTION ENERGY`; Set if :py:attr:`fctldash` nonempty. """"""; if self.engine in ['dftd3', 'mp2d', ""dftd4""]:; resi = AtomicInput(; **{; 'driver': 'energy',; 'model': {; 'method': self.fctldash,; 'basis': '(auto)',; },; 'keywords': {; 'level_hint': self.dashlevel,; 'params_tweaks': self.dashparams,; 'dashcoeff_supplement': self.dashcoeff_supplement,; 'pair_resolved': self.save_pairwise_disp,; 'verbose': 1,; },; 'molecule': molecule.to_schema(dtype=2),; 'provenance': p4util.provenance_stamp(__name__),; }); jobrec = qcng.compute(; resi,; self.engine,; raise_error=True,; local_options={""scratch_directory"": core.IOManager.shared_object().get_default_path(), ""ncores"": core.get_num_threads()}). dashd_part = float(jobrec.extras['qcvars']['DISPERSION CORRECTION ENERGY']); if wfn is not None:; for k, qca in jobrec.extras['qcvars'].items():; if (""CURRENT"" not in k)",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/empirical_dispersion.html:7326,ENERGY,ENERGY,7326,psi4manual/1.6.x/_modules/psi4/driver/procrouting/empirical_dispersion.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/empirical_dispersion.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"ms']). [docs] def print_out(self):; """"""Format dispersion parameters of `self` for output file."""""". text = []; text.append("" => {}: Empirical Dispersion <="".format(; (self.fctldash.upper() if self.fctldash.upper() else 'Custom'))); text.append(''); text.append(self.description); text.append(self.dashlevel_citation.rstrip()); if self.dashparams_citation:; text.append("" Parametrisation from:{}"".format(self.dashparams_citation.rstrip())); text.append(''); for op in self.ordered_params:; text.append("" %6s = %14.6f"" % (op, self.dashparams[op])); text.append('\n'). core.print_out('\n'.join(text)). [docs] def compute_energy(self, molecule: core.Molecule, wfn: core.Wavefunction = None) -> float:; """"""Compute dispersion energy based on engine, dispersion level, and parameters in `self`. Parameters; ----------; molecule; System for which to compute empirical dispersion correction.; wfn; Location to set QCVariables. Returns; -------; float; Dispersion energy [Eh]. Notes; -----; :psivar:`DISPERSION CORRECTION ENERGY`; Disp always set. Overridden in SCF finalization, but that only changes for ""-3C"" methods.; :psivar:`fctl DISPERSION CORRECTION ENERGY`; Set if :py:attr:`fctldash` nonempty. """"""; if self.engine in ['dftd3', 'mp2d', ""dftd4""]:; resi = AtomicInput(; **{; 'driver': 'energy',; 'model': {; 'method': self.fctldash,; 'basis': '(auto)',; },; 'keywords': {; 'level_hint': self.dashlevel,; 'params_tweaks': self.dashparams,; 'dashcoeff_supplement': self.dashcoeff_supplement,; 'pair_resolved': self.save_pairwise_disp,; 'verbose': 1,; },; 'molecule': molecule.to_schema(dtype=2),; 'provenance': p4util.provenance_stamp(__name__),; }); jobrec = qcng.compute(; resi,; self.engine,; raise_error=True,; local_options={""scratch_directory"": core.IOManager.shared_object().get_default_path()}). dashd_part = float(jobrec.extras['qcvars']['DISPERSION CORRECTION ENERGY']); if wfn is not None:; for k, qca in jobrec.extras['qcvars'].items():; if (""CURRENT"" not in k) and (""PAIRWISE"" not in k):; wfn.s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/procrouting/empirical_dispersion.html:7326,ENERGY,ENERGY,7326,psi4manual/1.5.0/_modules/psi4/driver/procrouting/empirical_dispersion.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/procrouting/empirical_dispersion.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"ms']). [docs] def print_out(self):; """"""Format dispersion parameters of `self` for output file."""""". text = []; text.append("" => {}: Empirical Dispersion <="".format(; (self.fctldash.upper() if self.fctldash.upper() else 'Custom'))); text.append(''); text.append(self.description); text.append(self.dashlevel_citation.rstrip()); if self.dashparams_citation:; text.append("" Parametrisation from:{}"".format(self.dashparams_citation.rstrip())); text.append(''); for op in self.ordered_params:; text.append("" %6s = %14.6f"" % (op, self.dashparams[op])); text.append('\n'). core.print_out('\n'.join(text)). [docs] def compute_energy(self, molecule: core.Molecule, wfn: core.Wavefunction = None) -> float:; """"""Compute dispersion energy based on engine, dispersion level, and parameters in `self`. Parameters; ----------; molecule; System for which to compute empirical dispersion correction.; wfn; Location to set QCVariables. Returns; -------; float; Dispersion energy [Eh]. Notes; -----; :psivar:`DISPERSION CORRECTION ENERGY`; Disp always set. Overridden in SCF finalization, but that only changes for ""-3C"" methods.; :psivar:`fctl DISPERSION CORRECTION ENERGY`; Set if :py:attr:`fctldash` nonempty. """"""; if self.engine in ['dftd3', 'mp2d']:; resi = AtomicInput(; **{; 'driver': 'energy',; 'model': {; 'method': self.fctldash,; 'basis': '(auto)',; },; 'keywords': {; 'level_hint': self.dashlevel,; 'params_tweaks': self.dashparams,; 'dashcoeff_supplement': self.dashcoeff_supplement,; 'pair_resolved': self.save_pairwise_disp,; 'verbose': 1,; },; 'molecule': molecule.to_schema(dtype=2),; 'provenance': p4util.provenance_stamp(__name__),; }); jobrec = qcng.compute(; resi,; self.engine,; raise_error=True,; local_options={""scratch_directory"": core.IOManager.shared_object().get_default_path()}). dashd_part = float(jobrec.extras['qcvars']['DISPERSION CORRECTION ENERGY']); if wfn is not None:; for k, qca in jobrec.extras['qcvars'].items():; if (""CURRENT"" not in k) and (""PAIRWISE"" not in k):; wfn.set_variab",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/empirical_dispersion.html:7267,ENERGY,ENERGY,7267,psi4manual/1.4.0/_modules/psi4/driver/procrouting/empirical_dispersion.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/empirical_dispersion.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"ms, GWH is not; see; [Lehtola:2019:1593]). HUCKELAn extended Hückel guess based on on-the-fly atomic UHF; calculations alike SAD, see [Lehtola:2019:1593]. READRead the previous orbitals from a wfn file, casting from; one basis to another if needed. Useful for starting anion; computations from neutral orbitals, or after small geometry; changes. At present, casting from a different molecular point; group is not supported. This becomes the default for the second; and later iterations of geometry optimizations. SAPSuperposition of Atomic Potentials. This is essentially a; modification of the core Hamiltonian, which includes screening; effects by using a radially screened effective atomic charge. The; screening effects have been calculated at the complete basis set; limit with finite-element calculations, see [Lehtola:2019:25945]; and [Lehtola:2020:012516]. The guess and its implementation have; been described in [Lehtola:2019:1593]. The guess is evaluated on a; DFT quadrature grid, so the guess energy depends slightly on the; used DFT quadrature. The current implementation is based on; exchange-only local density calculations that are but nanohartree; away from the complete basis set limit [Lehtola:2020:012516]. SAPGAUSuperposition of Atomic Potentials, but using error function based; fits to the atomic radial potentials as discussed in; [Lehtola:2020:144105]. The main difference to the SAP guess; discussed above [Lehtola:2019:25945] is that the SAPGAU scheme is; analytic, and can be efficiently formed in terms of three-center; two-electron integrals [Lehtola:2020:144105]. The potential in; the SAPGAU scheme is passed with the SAPGAU_BASIS; keyword. The default potential is given by the large fit to the; HelFEM potential, sap_helfem_large, described in; [Lehtola:2020:144105]. Note that this guess is known in the DIRAC; program as .SCRPOT and in the ERKALE program as SAPFIT. These are all set by the GUESS keyword. Also, an automatic Python; procedure has been developed f",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/scf.html:18867,energy,energy,18867,psi4manual/1.8.x/scf.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/scf.html,1,['energy'],['energy']
Energy Efficiency,"ms, GWH is not; see; [Lehtola:2019:1593]). HUCKELAn extended Hückel guess based on on-the-fly atomic UHF; calculations alike SAD, see [Lehtola:2019:1593]. READRead the previous orbitals from a wfn file, casting from; one basis to another if needed. Useful for starting anion; computations from neutral orbitals, or after small geometry; changes. At present, casting from a different molecular point; group is not supported. This becomes the default for the second; and later iterations of geometry optimizations. SAPSuperposition of Atomic Potentials. This is essentially a; modification of the core Hamiltonian, which includes screening; effects by using a radially screened effective atomic charge. The; screening effects have been calculated at the complete basis set; limit with finite-element calculations, see [Lehtola:2019:25945]; and [Lehtola:2020:012516]. The guess and its implementation have; been described in [Lehtola:2019:1593]. The guess is evaluated on a; DFT quadrature grid, so the guess energy depends slightly on the; used DFT quadrature. The current implementation is based on; exchange-only local density calculations that are but nanohartree; away from the complete basis set limit [Lehtola:2020:012516]. These are all set by the GUESS keyword. Also, an automatic Python; procedure has been developed for converging the SCF in a small basis, and then; casting up to the true basis. This can be done by adding; BASIS_GUESS = SMALL_BASIS to the options list. We recommend the; 3-21G or pcseg-0 basis for the small basis due to its efficient mix of flexibility and; compactness. An example of performing an RHF solution of water by SAD guessing; in a 3-21G basis and then casting up to cc-pVTZ is shown below:; molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; basis cc-pvtz; basis_guess 3-21G; guess sad; }. energy('scf'). Restarting the SCF¶; Reading orbital data from a previous calculations is done via the restart_file option,; where the actual file is a serialized",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/scf.html:18859,energy,energy,18859,psi4manual/1.6.x/scf.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/scf.html,2,['energy'],['energy']
Energy Efficiency,"ms. The geometry is specified using a Z-matrix with variables that are updated during the potential energy surface scan, and then the same procedure is performed using polar coordinates, converted to Cartesian coordinates. cc15; RHF-B-CCD(T)/6-31G** H2O single-point energy (fzc, MO-basis \(\langle ab|cd \rangle\)). fnocc2; Test G2 method for H2O. opt4; SCF cc-pVTZ geometry optimzation, with Z-matrix input. dfmp2-grad1; DF-MP2 cc-pVDZ gradients for the H2O molecule. props4; Electrostatic potential and electric field evaluated on a grid around water. psimrcc-ccsd_t-2; Mk-MRCCSD(T) single point. \(^1A_1\) CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. dft-grac; Gradient regularized asymptotic correction (GRAC) test. cbs-xtpl-freq; Various gradients for a strained helium dimer and water molecule. cisd-h2o-clpse; 6-31G** H2O Test CISD Energy Point with subspace collapse. rasci-h2o; RASCI/6-31G** H2O Energy Point. opt8; Various constrained energy minimizations of HOOH with cc-pvdz RHF. Cartesian-coordinate constrained optimizations of HOOH in Cartesians. dft-grad-disk; A range-seperated gradient for SO2 to test disk algorithms by explicitly setting low memory. opt6; Various constrained energy minimizations of HOOH with cc-pvdz RHF Internal-coordinate constraints in internal-coordinate optimizations. dfmp2-3; DF-MP2 cc-pVDZ frozen core gradient of benzene, computed at the DF-SCF cc-pVDZ geometry. cdomp2-1; OMP2 cc-pVDZ energy for the H2O molecule. fsapt-diff1; This test case shows an example of running and analyzing a difference F-SAPT0/jun-cc-pvdz procedure for phenol dimer from the S22 database. cc13a; UHF-CCSD(T)/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. cbs-xtpl-alpha; Extrapolated water energies. cc8c; ROHF-CCSD cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Cartesian input. props1; RHF STO-3G dipole moment computation, performed by applying a finite electric field a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html:30879,energy,energy,30879,psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"ms. The geometry is specified using a Z-matrix with variables that are updated during the potential energy surface scan, and then the same procedure is performed using polar coordinates, converted to Cartesian coordinates. cc15; RHF-B-CCD(T)/6-31G** H2O single-point energy (fzc, MO-basis \(\langle ab|cd \rangle\)). fnocc2; Test G2 method for H2O. opt4; SCF cc-pVTZ geometry optimzation, with Z-matrix input. dfmp2-grad1; DF-MP2 cc-pVDZ gradients for the H2O molecule. props4; Electrostatic potential and electric field evaluated on a grid around water. psimrcc-ccsd_t-2; Mk-MRCCSD(T) single point. \(^1A_1\) CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. dft-grac; Gradient regularized asymptotic correction (GRAC) test. cbs-xtpl-freq; Various gradients for a strained helium dimer and water molecule. cisd-h2o-clpse; 6-31G** H2O Test CISD Energy Point with subspace collapse. rasci-h2o; RASCI/6-31G** H2O Energy Point. opt8; Various constrained energy minimizations of HOOH with cc-pvdz RHF. Cartesian-coordinate constrained optimizations of HOOH in Cartesians. opt6; Various constrained energy minimizations of HOOH with cc-pvdz RHF Internal-coordinate constraints in internal-coordinate optimizations. dfmp2-3; DF-MP2 cc-pVDZ frozen core gradient of benzene, computed at the DF-SCF cc-pVDZ geometry. cdomp2-1; OMP2 cc-pVDZ energy for the H2O molecule. fsapt-diff1; This test case shows an example of running and analyzing a difference F-SAPT0/jun-cc-pvdz procedure for phenol dimer from the S22 database. cc13a; UHF-CCSD(T)/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. cbs-xtpl-alpha; Extrapolated water energies. cc8c; ROHF-CCSD cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Cartesian input. props1; RHF STO-3G dipole moment computation, performed by applying a finite electric field and numerical differentiation. cc45; RHF-EOM-CC2/cc-pVDZ lowest two states of each symmetry of H2O. soscf-lar",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html:29444,energy,energy,29444,psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"ms. This tests both the ERI and ERF integrals. cisd-h2o+-1; 6-31G** H2O+ Test CISD Energy Point. dft-grad; DF-BP86-D2 cc-pVDZ frozen core gradient of S22 HCN. mp2p5-grad1; MP2.5 cc-pVDZ gradient for the H2O molecule. mints1; Symmetry tests for a range of molecules. This doesn’t actually compute any energies, but serves as an example of the many ways to specify geometries in Psi4. omp2-2; OMP2 cc-pVDZ energy with ROHF initial guess orbitals for the NO radical. fci-h2o-2; 6-31G H2O Test FCI Energy Point. molden2; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. cc54; CCSD dipole with user-specified basis set. cc39; RHF-CC2-LR/cc-pVDZ dynamic polarizabilities of HOF molecule. cc34; RHF-CCSD/cc-pVDZ energy of H2O partitioned into pair energy contributions. opt-irc-1; Compute the IRC for HOOH torsional rotation at the RHF/DZP level of theory. cepa3; cc-pvdz H2O Test coupled-pair CISD against DETCI CISD. cc33; CC3(UHF)/cc-pVDZ H2O geom from Olsen et al., JCP 104, 8007 (1996). casscf-sp; CASSCF/6-31G** energy point. ocepa-freq1; OCEPA cc-pVDZ freqs for C2H2. opt1-fd; SCF STO-3G geometry optimzation, with Z-matrix input, by finite-differences. pywrap-cbs1; Various basis set extrapolation tests. dcft-grad3; Restricted DF-DCFT ODC-12 gradient for ethylene with cc-pVDZ/cc-pVDZ-RI standard/auxiliary basis set. cisd-h2o-clpse; 6-31G** H2O Test CISD Energy Point with subspace collapse. dfomp3-grad1; DF-OMP3 cc-pVDZ gradients for the H2O molecule. extern1; External potential calculation involving a TIP3P water and a QM water. Finite different test of the gradient is performed to validate forces. psimrcc-fd-freq2; Mk-MRCCSD frequencies. O$_3` state described using the Ms = 0 component of the singlet. Uses TCS",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html:25620,energy,energy,25620,psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html,8,['energy'],['energy']
Energy Efficiency,"ms. Type; str. dashparams_citation¶; Literature reference for dispersion parameters, if dashparams; corresponds to a defined, named, untweaked “functional-dashlevel”; set with a citation. Otherwise, empty string. Type; str. dashcoeff_supplement¶; See description in qcengine.programs.empirical_dispersion_resources.from_arrays. Used; here to “bless” the dispersion definitions attached to; the procedures/dft/<rung>_functionals-defined dictionaries; as legit, non-custom, and of equal validity to; qcengine.programs.empirical_dispersion_resources.dashcoeff itself for purposes of; validating fctldash. Type; dict. engine¶; {‘libdisp’, ‘dftd3’, ‘nl’, ‘mp2d’, “dftd4”}; Compute engine for dispersion. One of Psi4’s internal libdisp; library, external Grimme or Beran projects, or nl. Type; str. disp¶; Only present for engine =libdisp. Psi4 class instance prepared; to compute dispersion. Type; Dispersion. ordered_params¶; Fixed-order list of relevant parameters for dashlevel. Matches; DISPERSION CORRECTION ENERGY ordering. Used for printing. Type; list. Parameters. name_hint (Optional[str]) – Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Any or all parameters initialized from; dashcoeff[dashlevel][functional-without-dashlevel] or; dashcoeff_supplement[dashlevel][functional-with-dashlevel]; can be overwritten via param_tweaks.; level_hint (Optional[str]) – Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or “alias” or; “formal” to one.; param_tweaks (Union[Dict, List, None]) – Values for the same keys as dashcoeff[dashlevel][‘default’]; (and same order if list) used to override any or all values; initialized by name_hint. Extra parameters will error.; engine (Optional[str]) – Override which code computes dispersion. See above for allowed; values. Really only relevant for -D2, which can be computed by; libdisp or dftd3. Methods Summ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.driver.empiricaldispersion.html:2305,ENERGY,ENERGY,2305,psi4manual/1.5.0/api/psi4.driver.empiricaldispersion.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.driver.empiricaldispersion.html,2,['ENERGY'],['ENERGY']
Energy Efficiency,"ms_force_g_convergence 6; set cfour_abcdtype aobasis; set cfour_scf_conv 12; set cfour_cc_conv 12; set cfour_lineq_conv 12. optimize('c4-ccsd(t)'). The utility of this method specification is that examination can be made; of the reference, the derivative level, the excitation level, etc. and; some options can be set according to best practices. Practically speaking,; CFOUR_CC_PROGRAM (and eventually CFOUR_ABCDTYPE) will; always be set to the fastest safe value.; For example, the input above will run with CFOUR_CC_PROGRAM=ECC; unless explicitly set to VCC.; An advantage of PSI4‘s Python driver is that any number of common; work-up procedures can be automated and wrapped around the; conventional single-point and optimization procedures at the heart of all; quantum chemistry codes. Three core “wrappers” available in PSI4 are; nbody(),; database(), and; cbs(); read their respective sections; for details, but an overview is provided here. nbody(); computes the interaction energy of a bimolecular complex (counterpoise-corrected,; not, or both).; molecule dimer {; Ne; --; Ne 1 R; symmetry c1; }. Rvals=[2.5, 3.0, 4.0]; set basis aug-cc-pVDZ. for R in Rvals:; dimer.R = R; ecp = cp('c4-mp2'); print_stdout('R [A] = %.1f IE [kcal/mol] = %.3f\n' % (R, psi_hartree2kcalmol * ecp)). yields; R [A] = 2.5 IE [kcal/mol] = 0.804; R [A] = 3.0 IE [kcal/mol] = 0.030; R [A] = 4.0 IE [kcal/mol] = -0.014. Next, the database() wrapper allows any computational; model chemistry to be applied a predefined collection of molecules. Thus; an input; set {; basis jun-cc-pvdz; d_convergence 9; }. database('c4-mp2','nbc10',cp='on',subset='MeMe'). yields the counterpoise-corrected interaction energy for several points; along the dissociation curve of methane dimer, which is a member of the; NBC10 database:; //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>//; // Database nbc10 Results //; //<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<//. For each VARIABLE requested by tabulate, a 'Reaction Value' will be formed from; 'Reagent",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/cfour.html:12784,energy,energy,12784,psi4manual/1.6.x/cfour.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/cfour.html,5,['energy'],['energy']
Energy Efficiency,"mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp2_property(name, **kwargs):; """"""Function selecting the algorithm for a MP2 property call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP2_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only dfmp2 for now. func = None; if reference == 'RHF':; if mtd_type == 'DF':; #if module == 'OCC':; # func = run_dfocc_property; if module in ['', 'DFMP2']:; func = run_dfmp2_property; #elif reference == 'UHF':; # if mtd_type == 'DF':; # if module in ['', 'OCC']:; # func = run_dfocc_property. if func is None:; raise ManagedMethodError(['select_mp2_property', name, 'MP2_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp2(name, **kwargs):; """"""Function selecting the algorithm for an OMP2 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP2_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError(['select_omp2', name, 'MP2_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp2_gradient(name, **kwargs):; """"""Function selecting the algorithm for an OMP2 gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP2_TYPE'); module = core.get",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html:5460,energy,energy,5460,psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,3,['energy'],['energy']
Energy Efficiency,"multiplicity(3). """"""; self.PYmultiplicity_specified = True; self.PYmultiplicity = mult. [docs] def multiplicity_specified(self):; """"""Whether the multiplicity was given by the user. >>> print H2OH2O.multiplicity_specified(); True. """"""; return self.PYmultiplicity_specified. [docs] def units(self):; """"""Gets the geometry units. >>> print H2OH2O.units(); Angstrom. """"""; return self.PYunits. [docs] def set_units(self, units):; """"""Sets the geometry units. >>> H2OH2O.set_units('Angstom'). """"""; if units == 'Angstrom' or units == 'Bohr':; self.PYunits = units; else:; raise ValidationError(""""""Molecule::set_units: argument must be 'Angstrom' or 'Bohr'.""""""). [docs] def has_zmatrix(self):; """"""Gets the presence of any zmatrix entry. >>> print H2OH2O.has_zmatrix(); False. """"""; return self.zmat. [docs] def set_has_zmatrix(self, tf):; """"""Sets the presence of any zmatrix entry. >>> H2OH2O.set_has_zmatrix(True). """"""; self.zmat = tf. # <<< Simple Methods for Coordinates >>>. [docs] def Z(self, atom):; """"""Nuclear charge of atom (0-indexed). >>> print H2OH2O.Z(4); 1. """"""; return self.atoms[atom].Z(). [docs] def x(self, atom):; """"""x position of atom (0-indexed) in Bohr. >>> print H2OH2O.x(4); 3.17549201425. """"""; return self.input_units_to_au * self.atoms[atom].compute()[0]. [docs] def y(self, atom):; """"""y position of atom (0-indexed) in Bohr. >>> print H2OH2O.y(4); -0.706268134631. """"""; return self.input_units_to_au * self.atoms[atom].compute()[1]. [docs] def z(self, atom):; """"""z position of atom (0-indexed) in Bohr. >>> print H2OH2O.z(4); -1.43347254509. """"""; return self.input_units_to_au * self.atoms[atom].compute()[2]. [docs] def xyz(self, atom, posn=None):; """"""Returns a Vector3 with x, y, z position of atom (0-indexed); in Bohr or coordinate at *posn*. >>> print H2OH2O.xyz(4); [3.175492014248769, -0.7062681346308132, -1.4334725450878665]. """"""; temp = scale(self.atoms[atom].compute(), self.input_units_to_au); if posn is None:; return temp; else:; return temp[posn]. [docs] def mass(self, ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:7465,charge,charge,7465,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,1,['charge'],['charge']
Energy Efficiency,"mum number of calculations. compare_fchkfiles(expected, computed, ...); Comparison function for output data in FCHK (formatted checkpoint) file format. compare_fcidumps(expected, computed, label); Comparison function for FCIDUMP files. compare_moldenfiles(expected, computed[, ...]); Comparison function for output data in Molden file format. copy_file_from_scratch(filename, prefix, ...); Move a file out of scratch following the naming convention. copy_file_to_scratch(filename, prefix, ...); Move a file into scratch following the naming convention. create_plugin(name, template). rtype:; None. cubeprop(wfn, **kwargs); Evaluate properties on a grid and generate cube files. docs_table_link(name, mode); Compose a link to mode documentation table. dynamic_variable_bind(cls); Function to dynamically add extra members to the core.Molecule class. energies_from_fcidump(intdump); From integrals dictionary generated from fcidump_from_file(), compute energies. energy(name, **kwargs); Function to compute the single-point electronic energy. fchk(wfn, filename, *[, debug, strict_label]); Function to write wavefunction information in wfn to filename in Gaussian FCHK format. fcidump(wfn[, fname, oe_ints]); Save integrals to file in FCIDUMP format as defined in Comp. fcidump_from_file(fname); Function to read in a FCIDUMP file. find_approximate_string_matches(seq1, ...); Find list of approximate (within max_distance) matches to string seq1 among options. freq(name, **kwargs); Function to compute harmonic vibrational frequencies. frequencies(name, **kwargs); Function to compute harmonic vibrational frequencies. frequency(name, **kwargs); Function to compute harmonic vibrational frequencies. gdma(wfn[, datafile]); Function to use wavefunction information in wfn and, if specified, additional commands in filename to run GDMA analysis with A. geometry(geom[, name]); Function to create a molecule object of name name from the :rtype: Molecule. get_memory(); Return the total memory allocation ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/psi4api.html:17202,energy,energy,17202,psi4manual/1.9.x/psi4api.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/psi4api.html,2,['energy'],['energy']
Energy Efficiency,"mum number of calculations. compare_fchkfiles(expected, computed, ...); Comparison function for output data in FCHK (formatted checkpoint) file format. compare_fcidumps(expected, computed, label); Comparison function for FCIDUMP files. compare_moldenfiles(expected, computed[, ...]); Comparison function for output data in Molden file format. copy_file_from_scratch(filename, prefix, ...); Move a file out of scratch following the naming convention. copy_file_to_scratch(filename, prefix, ...); Move a file into scratch following the naming convention. create_plugin(name, template). rtype:; None. cubeprop(wfn, **kwargs); Evaluate properties on a grid and generate cube files. docs_table_link(name, mode); Compose a link to mode documentation table. dynamic_variable_bind(cls); Function to dynamically add extra members to the core.Molecule class. energies_from_fcidump(intdump); From integrals dictionary generated from fcidump_from_file(), compute energies. energy(name, **kwargs); Function to compute the single-point electronic energy. fchk(wfn, filename, *[, debug, strict_label]); Function to write wavefunction information in wfn to filename in Gaussian FCHK format. fcidump(wfn[, fname, oe_ints]); Save integrals to file in FCIDUMP format as defined in Comp. fcidump_from_file(fname); Function to read in a FCIDUMP file. find_approximate_string_matches(seq1, ...); Find list of approximate (within max_distance) matches to string seq1 among options. freq(name, **kwargs); Function to compute harmonic vibrational frequencies. frequencies(name, **kwargs); Function to compute harmonic vibrational frequencies. frequency(name, **kwargs); Function to compute harmonic vibrational frequencies. gdma(wfn[, datafile]); Function to use wavefunction information in wfn and, if specified, additional commands in filename to run GDMA analysis. geometry(geom[, name]); Function to create a molecule object of name name from the geometry in string geom. get_memory(); Return the total memory allocation ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/psi4api.html:17155,energy,energy,17155,psi4manual/1.7.x/psi4api.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/psi4api.html,4,['energy'],['energy']
Energy Efficiency,"must be set to NONE; (default). Evaluation of the analytic gradients requires the solution of the; coupled response equations. Two algorithms are available for their iterative; solution: two-step (default) and simultaneous. These algorithms are similar to those; described for the orbital and cumulant updates in the Iterative Algorithms; section and usually exhibit the similar efficiency. The choice of the algorithm can; be made using the RESPONSE_ALGORITHM option. For the DC-12 method the; analytic gradients are not yet available, one has to use numerical gradients to; perform the geometry optimizations. Minimal Input¶; Minimal input for the DCFT single-point computation looks like this:; molecule {; H; H 1 1.0; }. set basis 3-21G. energy('dcft'). The energy('dcft') call to energy() executes the DCFT module, which will first call the SCF module and perform the SCF computation with UHF reference to obtain the guess for the DCFT orbitals. After the SCF is converged, the program will perform the energy computation using the DC-06 method. By default, the two-step algorithm will be used for the solution of the equations. Note that while the default value for the option REFERENCE is RHF, this option is set to UHF before the DCFT module is executed. For the DC-06 method one can also request to perform the geometry optimization following the example below:; molecule {; H; H 1 1.0; }. set basis 3-21G. optimize('dcft'). The optimize('dcft') call will first perform all of the procedures; described above to obtain the DC-06 energy. After that the DC-06 analytic; gradients code will be executed to perform the solution of the DCFT response; equations, compute the analytic gradients of the DCFT energy and perform the; geometry optimization. Recommendations¶; Here is the list of the recommendations for the DCFT module:. For the computations of small systems (less than 150 basis; functions and high symmetry) the use of the default parameters is recommended,; including the choice of ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/dcft-1.html:10339,energy,energy,10339,psi4manual/4.0b4/dcft-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/dcft-1.html,2,['energy'],['energy']
Energy Efficiency,"mu} (\vec r_1); \phi_{\nu} (\vec r_1); \frac{1}{r_{12}}; \phi_{\lambda} (\vec r_2); \phi_{\sigma} (\vec r_2); \ \mathrm{d}^3 r_1; \ \mathrm{d}^3 r_2.\]; The MO coefficients are found as the generalized eigenvectors of the Fock Matrix,. \[F^\alpha C^\alpha = S C^\alpha \epsilon^\alpha\]; The eigenvalues \(\epsilon\) are the orbital energies, and the metric matrix; \(S\) is the AO-basis overlap matrix. \[S_{\mu\nu} = (\mu | \nu )\]; Note that the Fock Matrix depends on the density (both alpha and beta), and; therefore the orbitals. Because of this, SCF is a nonlinear procedure, which; terminates when the generating orbitals are self-consistent with the Fock matrix; they generate.; The formation of the Coulomb matrix \(J\) and the exchange matrix; \(K^{\alpha}\) dominate the computational effort of the SCF procedure. For; very large systems, diagonalization of the Fock matrix can also present a; significant hurdle. Minimal Input¶; Minimal input for a Hartree–Fock computation is a molecule block, basis set; option, and a call to energy('scf'):; molecule {; He; }. set basis sto-3g. energy('scf'). This will run a Restricted Hartree–Fock (RHF) on neutral singlet Helium in; \(D_{2h}\) spatial symmetry with a minimal STO-3G basis, 1.0E-6; energy and density convergence criteria (since single-point, see; SCF Convergence & Algorithm), a DF ERI algorithm, symmetric; orthogonalization, DIIS, and a core Hamiltonian guess. For more; information on any of these options, see the relevant section below. Spin/Symmetry Treatment¶; PSI4 implements the most popular spin specializations of Hartree–Fock; theory, including:. Restricted Hartree–Fock (RHF) [Default]Appropriate only for closed-shell singlet systems, but twice as efficient; as the other flavors, as the alpha and beta densities are constrained to be; identical. Unrestricted Hartree–Fock (UHF)Appropriate for most open-shell systems and fairly easy to converge.; The spatial parts of the alpha and beta orbitals are fully independen",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/scf-1.html:7496,energy,energy,7496,psi4manual/1.4.0/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/scf-1.html,9,['energy'],['energy']
Energy Efficiency,"n (GRAC) test. mbis-5; MBIS calculation on ZnO. soscf-large; Second-order SCF convergnece: Benzene. scf-property; UFH and B3LYP cc-pVQZ properties for the CH2 molecule. cc13c; Tests RHF CCSD(T)gradients. x2c-perturb-h; Test SFX2C-1e with a static electric field on He aug-cc-pVTZ. opt12; SCF cc-pVDZ geometry optimzation of ketene, starting from bent structure. cisd-sp-2; 6-31G** H2O Test CISD Energy Point. fsapt2; A very quick correctness test of F-SAPT (see fsapt1 for a real example). scf-dipder; Test SCF dipole derivatives against old Psi3 reference values. scf-uhf-grad-nobeta; UHF gradient for a one-electron system (no beta electrons). pywrap-align; apply linear fragmentation algorithm to a water cluster. dft-b2plyp; Double-hybrid density functional B2PYLP. Reproduces portion of Table I in S. Grimme’s J. Chem. Phys 124 034108 (2006) paper defining the functional. fnocc6; Test method/basis with disk_df. isapt-charged; This test case shows an example of running the I-SAPT0/aug-cc-pVDZ computation for a positively charged system, illustrating the cation-pi interaction. The SIAO1 link partitioning algorithm is used. The system is taken from http://dx.doi.org/10.1016/j.comptc.2014.02.008. cc13; UHF-CCSD/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. dft-freq; Frequencies for H2O B3LYP/6-31G* at optimized geometry. props2; DF-SCF cc-pVDZ of benzene-hydronium ion, scanning the dissociation coordinate with Python’s built-in loop mechanism. The geometry is specified by a Z-matrix with dummy atoms, fixed parameters, updated parameters, and separate charge/multiplicity specifiers for each monomer. One-electron properties computed for dimer and one monomer. dlpnomp2-2; comparison of DF-MP2 and DLPNO-MP2 with a CBS extrapolation. cepa-module; routing check on lccd, lccsd, cepa(0). dfccsd-t-grad1; DF-CCSD(T) cc-pVDZ gradients for the H2O molecule. olccd2; OLCCD cc-pVDZ energy with B3LYP initial guess for the NO radical. ao-casscf-sp; CASSCF/6-31G** energy ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html:37621,charge,charged,37621,psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,4,['charge'],['charged']
Energy Efficiency,"n (str) – 'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. delta_wfn_lesser (str) – \(\Rightarrow\) corl_wfn \(\Leftarrow\) || 'mp2' || etc.; Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. delta2_wfn (str) – 'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. delta2_wfn_lesser (str) – \(\Rightarrow\) delta_wfn \(\Leftarrow\) || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. Basis SetsCurrently, the basis set set through set commands have no influence; on a cbs calculation. Parameters:. scf_basis (basis string) – \(\Rightarrow\) corl_basis \(\Leftarrow\) || 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, scf_basis can default; to corl_basis. corl_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the correlation energy. delta_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. delta2_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. SchemesTransformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, 'xtpl_highest_1', which uses the best basis; set available. See Extrapolation Schemes for all a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.cbs.html:6815,energy,energy,6815,psi4manual/1.7.x/api/psi4.driver.cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.cbs.html,12,['energy'],['energy']
Energy Efficiency,"n - k); sign = ((-1) ** (n - k)); value = nocp_energy_by_level[k]; nocp_energy_body_dict[n] += take_nk * sign * value. if metadata['ptype'] != 'energy':; value = nocp_ptype_by_level[k]; nocp_ptype_body_dict[n] += take_nk * sign * value. _print_nbody_energy(nocp_energy_body_dict, ""Non-Counterpoise Corrected (NoCP)""); nocp_interaction_energy = nocp_energy_body_dict[metadata['max_nbody']] - nocp_energy_body_dict[1]; nbody_dict['Non-Counterpoise Corrected Total Energy'] = nocp_energy_body_dict[metadata['max_nbody']]; nbody_dict['Non-Counterpoise Corrected Interaction Energy'] = nocp_interaction_energy. for n in nbody_range[1:]:; var_key = 'NOCP-CORRECTED %d-BODY INTERACTION ENERGY' % n; nbody_dict[var_key] = nocp_energy_body_dict[n] - nocp_energy_body_dict[1]. # Compute vmfc energy and ptype; if 'vmfc' in metadata['bsse_type_list']:; _print_nbody_energy(vmfc_energy_body_dict, ""Valiron-Mayer Function Couterpoise (VMFC)""); vmfc_interaction_energy = vmfc_energy_body_dict[metadata['max_nbody']] - vmfc_energy_body_dict[1]; nbody_dict['Valiron-Mayer Function Couterpoise Total Energy'] = vmfc_energy_body_dict[metadata['max_nbody']]; nbody_dict['Valiron-Mayer Function Couterpoise Interaction Energy'] = vmfc_interaction_energy. for n in nbody_range[1:]:; var_key = 'VMFC-CORRECTED %d-BODY INTERACTION ENERGY' % n; nbody_dict[var_key] = vmfc_energy_body_dict[n] - vmfc_energy_body_dict[1]. # Returns; results = {}; results['nbody'] = nbody_dict. # Figure out and build return types; return_method = metadata['bsse_type_list'][0]. if return_method == 'cp':; results['ptype_body_dict'] = cp_ptype_body_dict; results['energy_body_dict'] = cp_energy_body_dict; elif return_method == 'nocp':; results['ptype_body_dict'] = nocp_ptype_body_dict; results['energy_body_dict'] = nocp_energy_body_dict; elif return_method == 'vmfc':; results['ptype_body_dict'] = vmfc_ptype_body_dict; results['energy_body_dict'] = vmfc_energy_body_dict; else:; raise ValidationError(""N-Body Wrapper: Invalid return type. ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver_nbody.html:23189,energy,energy,23189,psi4manual/1.2.1/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver_nbody.html,1,['energy'],['energy']
Energy Efficiency,"n <="".format(; (self.fctldash.upper() if self.fctldash.upper() else 'Custom'))); text.append(''); text.append(self.description); text.append(self.dashlevel_citation.rstrip()); if self.dashparams_citation:; text.append("" Parametrisation from:{}"".format(self.dashparams_citation.rstrip())); text.append(''); for op in self.ordered_params:; text.append("" %6s = %14.6f"" % (op, self.dashparams[op])); text.append('\n'). core.print_out('\n'.join(text)). [docs] def compute_energy(self, molecule: core.Molecule, wfn: core.Wavefunction = None) -> float:; """"""Compute dispersion energy based on engine, dispersion level, and parameters in `self`. Parameters; ----------; molecule; System for which to compute empirical dispersion correction.; wfn; Location to set QCVariables. Returns; -------; float; Dispersion energy [Eh]. Notes; -----; :psivar:`DISPERSION CORRECTION ENERGY`; Disp always set. Overridden in SCF finalization, but that only changes for ""-3C"" methods.; :psivar:`fctl DISPERSION CORRECTION ENERGY`; Set if :py:attr:`fctldash` nonempty. """"""; if self.engine in [""s-dftd3"", 'dftd3', 'mp2d', ""dftd4""]:; resi = AtomicInput(; **{; 'driver': 'energy',; 'model': {; 'method': self.fctldash,; 'basis': '(auto)',; },; 'keywords': {; 'level_hint': self.dashlevel,; 'params_tweaks': self.dashparams,; 'dashcoeff_supplement': self.dashcoeff_supplement,; 'pair_resolved': self.save_pairwise_disp,; 'apply_qcengine_aliases': True, # for s-dftd3; 'verbose': 1,; },; 'molecule': molecule.to_schema(dtype=2),; 'provenance': p4util.provenance_stamp(__name__),; }); jobrec = qcng.compute(; resi,; self.engine,; raise_error=True,; task_config={""scratch_directory"": core.IOManager.shared_object().get_default_path(), ""ncores"": core.get_num_threads()}). dashd_part = float(jobrec.extras['qcvars']['DISPERSION CORRECTION ENERGY']); if wfn is not None:; for k, qca in jobrec.extras['qcvars'].items():; if (""CURRENT"" not in k) and (""PAIRWISE"" not in k):; wfn.set_variable(k, float(qca) if isinstance(qca, str) else qca).",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/empirical_dispersion.html:9072,ENERGY,ENERGY,9072,psi4manual/1.7.x/_modules/psi4/driver/procrouting/empirical_dispersion.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/empirical_dispersion.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"n <="".format(; (self.fctldash.upper() if self.fctldash.upper() else 'Custom'))); text.append(''); text.append(self.description); text.append(self.dashlevel_citation.rstrip()); if self.dashparams_citation:; text.append("" Parametrisation from:{}"".format(self.dashparams_citation.rstrip())); text.append(''); for op in self.ordered_params:; text.append("" %6s = %14.6f"" % (op, self.dashparams[op])); text.append('\n'). core.print_out('\n'.join(text)). [docs] def compute_energy(self, molecule: core.Molecule, wfn: core.Wavefunction = None) -> float:; """"""Compute dispersion energy based on engine, dispersion level, and parameters in `self`. Parameters; ----------; molecule; System for which to compute empirical dispersion correction.; wfn; Location to set QCVariables. Returns; -------; float; Dispersion energy [Eh]. Notes; -----; :psivar:`DISPERSION CORRECTION ENERGY`; Disp always set. Overridden in SCF finalization, but that only changes for ""-3C"" methods.; :psivar:`fctl DISPERSION CORRECTION ENERGY`; Set if :py:attr:`fctldash` nonempty. """"""; if self.engine in ['dftd3', 'mp2d', ""dftd4""]:; resi = AtomicInput(; **{; 'driver': 'energy',; 'model': {; 'method': self.fctldash,; 'basis': '(auto)',; },; 'keywords': {; 'level_hint': self.dashlevel,; 'params_tweaks': self.dashparams,; 'dashcoeff_supplement': self.dashcoeff_supplement,; 'pair_resolved': self.save_pairwise_disp,; 'verbose': 1,; },; 'molecule': molecule.to_schema(dtype=2),; 'provenance': p4util.provenance_stamp(__name__),; }); jobrec = qcng.compute(; resi,; self.engine,; raise_error=True,; local_options={""scratch_directory"": core.IOManager.shared_object().get_default_path(), ""ncores"": core.get_num_threads()}). dashd_part = float(jobrec.extras['qcvars']['DISPERSION CORRECTION ENERGY']); if wfn is not None:; for k, qca in jobrec.extras['qcvars'].items():; if (""CURRENT"" not in k) and (""PAIRWISE"" not in k):; wfn.set_variable(k, float(qca) if isinstance(qca, str) else qca). # Pass along the pairwise dispersion decomposition if w",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/empirical_dispersion.html:7462,ENERGY,ENERGY,7462,psi4manual/1.6.x/_modules/psi4/driver/procrouting/empirical_dispersion.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/empirical_dispersion.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"n <="".format(; (self.fctldash.upper() if self.fctldash.upper() else 'Custom'))); text.append(''); text.append(self.description); text.append(self.dashlevel_citation.rstrip()); if self.dashparams_citation:; text.append("" Parametrisation from:{}"".format(self.dashparams_citation.rstrip())); text.append(''); for op in self.ordered_params:; text.append("" %6s = %14.6f"" % (op, self.dashparams[op])); text.append('\n'). core.print_out('\n'.join(text)). [docs] def compute_energy(self, molecule: core.Molecule, wfn: core.Wavefunction = None) -> float:; """"""Compute dispersion energy based on engine, dispersion level, and parameters in `self`. Parameters; ----------; molecule; System for which to compute empirical dispersion correction.; wfn; Location to set QCVariables. Returns; -------; float; Dispersion energy [Eh]. Notes; -----; :psivar:`DISPERSION CORRECTION ENERGY`; Disp always set. Overridden in SCF finalization, but that only changes for ""-3C"" methods.; :psivar:`fctl DISPERSION CORRECTION ENERGY`; Set if :py:attr:`fctldash` nonempty. """"""; if self.engine in ['dftd3', 'mp2d', ""dftd4""]:; resi = AtomicInput(; **{; 'driver': 'energy',; 'model': {; 'method': self.fctldash,; 'basis': '(auto)',; },; 'keywords': {; 'level_hint': self.dashlevel,; 'params_tweaks': self.dashparams,; 'dashcoeff_supplement': self.dashcoeff_supplement,; 'pair_resolved': self.save_pairwise_disp,; 'verbose': 1,; },; 'molecule': molecule.to_schema(dtype=2),; 'provenance': p4util.provenance_stamp(__name__),; }); jobrec = qcng.compute(; resi,; self.engine,; raise_error=True,; local_options={""scratch_directory"": core.IOManager.shared_object().get_default_path()}). dashd_part = float(jobrec.extras['qcvars']['DISPERSION CORRECTION ENERGY']); if wfn is not None:; for k, qca in jobrec.extras['qcvars'].items():; if (""CURRENT"" not in k) and (""PAIRWISE"" not in k):; wfn.set_variable(k, float(qca) if isinstance(qca, str) else qca). # Pass along the pairwise dispersion decomposition if we need it; if self.save_pairwise_d",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/procrouting/empirical_dispersion.html:7462,ENERGY,ENERGY,7462,psi4manual/1.5.0/_modules/psi4/driver/procrouting/empirical_dispersion.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/procrouting/empirical_dispersion.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"n <="".format(; (self.fctldash.upper() if self.fctldash.upper() else 'Custom'))); text.append(''); text.append(self.description); text.append(self.dashlevel_citation.rstrip()); if self.dashparams_citation:; text.append("" Parametrisation from:{}"".format(self.dashparams_citation.rstrip())); text.append(''); for op in self.ordered_params:; text.append("" %6s = %14.6f"" % (op, self.dashparams[op])); text.append('\n'). core.print_out('\n'.join(text)). [docs] def compute_energy(self, molecule: core.Molecule, wfn: core.Wavefunction = None) -> float:; """"""Compute dispersion energy based on engine, dispersion level, and parameters in `self`. Parameters; ----------; molecule; System for which to compute empirical dispersion correction.; wfn; Location to set QCVariables. Returns; -------; float; Dispersion energy [Eh]. Notes; -----; :psivar:`DISPERSION CORRECTION ENERGY`; Disp always set. Overridden in SCF finalization, but that only changes for ""-3C"" methods.; :psivar:`fctl DISPERSION CORRECTION ENERGY`; Set if :py:attr:`fctldash` nonempty. """"""; if self.engine in ['dftd3', 'mp2d']:; resi = AtomicInput(; **{; 'driver': 'energy',; 'model': {; 'method': self.fctldash,; 'basis': '(auto)',; },; 'keywords': {; 'level_hint': self.dashlevel,; 'params_tweaks': self.dashparams,; 'dashcoeff_supplement': self.dashcoeff_supplement,; 'pair_resolved': self.save_pairwise_disp,; 'verbose': 1,; },; 'molecule': molecule.to_schema(dtype=2),; 'provenance': p4util.provenance_stamp(__name__),; }); jobrec = qcng.compute(; resi,; self.engine,; raise_error=True,; local_options={""scratch_directory"": core.IOManager.shared_object().get_default_path()}). dashd_part = float(jobrec.extras['qcvars']['DISPERSION CORRECTION ENERGY']); if wfn is not None:; for k, qca in jobrec.extras['qcvars'].items():; if (""CURRENT"" not in k) and (""PAIRWISE"" not in k):; wfn.set_variable(k, float(qca) if isinstance(qca, str) else qca). # Pass along the pairwise dispersion decomposition if we need it; if self.save_pairwise_disp is Tr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/empirical_dispersion.html:7403,ENERGY,ENERGY,7403,psi4manual/1.4.0/_modules/psi4/driver/procrouting/empirical_dispersion.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/empirical_dispersion.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"n = $cgmp{MLPsyst} - 1;; # print $handle ""SET,CHARGE=$cgmp{CHGsyst}\nSET,SPIN=$spin\n"";; # print $handle ""{sapt; intermol,ca=\$ca,cb=\$cb,icpks=0}\n"";; # print $handle ""eeelst=E1pol\n"";; # print $handle ""eeexch=E1ex\n"";; # print $handle ""eeind=E2ind\n"";; # print $handle ""eeexind=E2exind\n"";; # print $handle ""eedisp=E2disp\n"";; # print $handle ""eeexdisp=E2exdisp\n\n"";; # ]; #'dft-sapt-pbe0acalda': [; #; # if ( ($asyA eq '') || ($asyB eq '') ) {; # print ""ERROR: asymptotic correction not defined for one or more monomers in index $system.\n"";; # close(DIOUT);; # unlink(""$pathDIOUT"");; # }; #; # print $handle ""ca=2101.2; cb=2102.2\n\n"";; #; # $spin = $cgmp{MLPmol1} - 1;; # print $handle ""SET,CHARGE=$cgmp{CHGmol1}\nSET,SPIN=$spin\ndummy"";; # foreach $at (@monoBreal) { print $handle "",$at""; }; # print $handle ""\n{ks,pbe0; asymp,$asyA; save,\$ca}\n"";; # print $handle ""eehfa=energy; sapt; monomerA\n\n"";; #; # $spin = $cgmp{MLPmol2} - 1;; # print $handle ""SET,CHARGE=$cgmp{CHGmol2}\nSET,SPIN=$spin\ndummy"";; # foreach $at (@monoAreal) { print $handle "",$at""; }; # print $handle ""\n{ks,pbe0; asymp,$asyB; save,\$cb}\n"";; # print $handle ""eehfb=energy; sapt; monomerB\n\n"";; #; # $spin = $cgmp{MLPsyst} - 1;; # print $handle ""SET,CHARGE=$cgmp{CHGsyst}\nSET,SPIN=$spin\n"";; # print $handle ""{sapt,sapt_level=3; intermol,ca=\$ca,cb=\$cb,icpks=0,fitlevel=3,nlexfac=0.0\n"";; # print $handle ""dfit,basis_coul=jkfit,basis_exch=jkfit,basis_mp2=mp2fit,cfit_scf=3}\n"";; # print $handle ""eeelst=E1pol\n"";; # print $handle ""eeexch=E1ex\n"";; # print $handle ""eeind=E2ind\n"";; # print $handle ""eeexind=E2exind\n"";; # print $handle ""eedisp=E2disp\n"";; # print $handle ""eeexdisp=E2exdisp\n\n"";; #; # print $handle ""show[1,20f20.12],ee*,ce*,te*\n"";; # print $handle ""show[1,60f20.12],_E*\n"";; # }; #. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; Psi4 [1.0.0 6a9a71b] » ; Module code ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesd",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro.html:11468,energy,energy,11468,psi4manual/1.0.0/_modules/qcdb/molpro.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro.html,2,['energy'],['energy']
Energy Efficiency,"n Bohr (arg3, arg4, arg5), atomic symbol arg6, mass arg7, charge arg8 (optional), and lineno arg9 (optional); C++ signature :. void add_atom(N3psi8MoleculeE {lvalue},i,d,d,d,PKc,d,d,i). psi4.Molecule.atom_at_position()¶; Python Library Documentation: method atom_at_position; atom_at_position(...) unbound psi4.Molecule method. atom_at_position( (Molecule)arg1, (float)arg2, (float)arg3) -> int :. Tests to see if an atom is at the position arg2 with a given tolerance arg3; C++ signature :. i atom_at_position(N3psi8MoleculeE {lvalue},Pd,d). psi4.Molecule.center_of_mass()¶; Python Library Documentation: method center_of_mass; center_of_mass(...) unbound psi4.Molecule method. center_of_mass( (Molecule)arg1) -> Vector3 :. Computes center of mass of molecule (does not translate molecule); C++ signature :. N3psi7Vector3E center_of_mass(N3psi8MoleculeE {lvalue}). psi4.Molecule.charge()¶; Python Library Documentation: method charge; charge(...) unbound psi4.Molecule method. charge( (Molecule)arg1, (int)arg2) -> float :. Gets charge of atom; C++ signature :. d charge(N3psi8MoleculeE {lvalue},i). psi4.Molecule.clone()¶; Python Library Documentation: method clone; clone(...) unbound psi4.Molecule method. clone( (Molecule)arg1) -> Molecule :. Returns a new Molecule identical to arg1; C++ signature :. N3psi8MoleculeE clone(N3psi8MoleculeE {lvalue}). psi4.Molecule.create_molecule_from_string()¶; Python Library Documentation: built-in function create_molecule_from_string; create_molecule_from_string(...). create_molecule_from_string( (str)arg1) -> Molecule :. Returns a new Molecule with member data from the geometry string arg1 in psi4 format; C++ signature :. N5boost10shared_ptrIN3psi8MoleculeEEE create_molecule_from_string(Ss). psi4.Molecule.create_psi4_string_from_molecule()¶; Python Library Documentation: method create_psi4_string_from_molecule; create_psi4_string_from_molecule(...) unbound psi4.Molecule method. create_psi4_string_from_molecule( (Molecule)arg1) -> str :. Gets a st",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:238059,charge,charge,238059,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['charge'],['charge']
Energy Efficiency,"n Dipole Moment. mints6; Patch of a glycine with a methyl group, to make alanine, then DF-SCF energy calculation with the cc-pVDZ basis set. opt10; 6-31G MP2 transition-state optimization with initial, computed Hessian. cbs-xtpl-gradient; Various gradients for a strained helium dimer and water molecule. mcscf3; RHF 6-31G** energy of water, using the MCSCF module and Z-matrix input. dft-grad-disk; A range-seperated gradient for SO2 to test disk algorithms by explicitly setting low memory. mints12; test roundtrip-ness of dict repr for psi4.core.Molecule and qcdb.Molecule. fd-gradient; SCF STO-3G finite-difference tests. lccd-grad2; LCCD cc-pVDZ gradient for the NO radical. fnocc2; Test G2 method for H2O. dfomp2-grad1; DF-OMP2 cc-pVDZ gradients for the H2O molecule. cc8b; ROHF-CCSD cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Cartesian input. scf-level-shift-rohf; SCF level shift on an ROHF computation. pywrap-checkrun-uhf; This checks that all energy methods can run with a minimal input and set symmetry. x2c3; Test of SFX2C-1e on Water uncontracted cc-pVDZ The reference numbers are from Lan Cheng’s implementation in Cfour. frac; Carbon/UHF Fractionally-Occupied SCF Test Case. sapt2; SAPT0 aug-cc-pVDZ computation of the benzene-methane interaction energy, using the aug-pVDZ-JKFIT DF basis for SCF, the aug-cc-pVDZ-RI DF basis for SAPT0 induction and dispersion, and the aug-pVDZ-JKFIT DF basis for SAPT0 electrostatics and induction. This example uses frozen core as well as asyncronous I/O while forming the DF integrals and CPHF coefficients. nbody-multi-level; Multilevel computation of water trimer energy (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). scf-ecp2; Water-Argon complex with ECP present; check of RHF Hessian. pywrap-align; apply linear fragmentation algorithm to a water cluster. scf-level-shift-rks; SCF level shift on an RKS computation. fci-coverage; 6-31G H2O Test for coverage. dfccsdat1; DF-CCSD(AT) cc-pVDZ ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html:43424,energy,energy,43424,psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"n HI-zeta ({zHI}) Data\n""""""; cbsscheme += nppp(valueHI). cbsscheme += f""""""\n Alpha (exponent) Value: {alpha:16.8f}""""""; cbsscheme += f""""""\n Beta Data\n""""""; cbsscheme += nppp(beta); cbsscheme += f""""""\n Extrapolated Data\n""""""; cbsscheme += nppp(value); cbsscheme += ""\n""; core.print_out(cbsscheme); logger.debug(cbsscheme). return value. else:; raise ValidationError(f""scf_xtpl_Karton_2: datatype is not recognized '{type(valueLO)}'.""). [docs]def scf_xtpl_helgaker_3(functionname: str, zLO: int, valueLO: Extrapolatable, zMD: int, valueMD: Extrapolatable, zHI: int, valueHI: Extrapolatable, verbose: int = 1, alpha: Optional[float] = None) -> Extrapolatable:; r""""""Extrapolation scheme for reference energies with three adjacent zeta-level bases.; Used by :py:func:`~psi4.driver.cbs`. Parameters; ----------; functionname; Name of the CBS component (e.g., 'HF') used in summary printing.; zLO; Zeta number of the smaller basis set in 3-point extrapolation.; valueLO; Energy, gradient, or Hessian value at the smaller basis set in 3-point; extrapolation.; zMD; Zeta number of the medium basis set in 3-point extrapolation.; Must be `zLO + 1`.; valueMD; Energy, gradient, or Hessian value at the medium basis set in 3-point; extrapolation.; zHI; Zeta number of the larger basis set in 3-point extrapolation.; Must be `zLO + 2`.; valueHI; Energy, gradient, or Hessian value at the larger basis set in 3-point; extrapolation.; verbose; Controls volume of printing.; alpha; Not used. Returns; -------; float or ~numpy.ndarray; Eponymous function applied to input zetas and values; type from `valueLO`. Notes; -----; The extrapolation is calculated according to [4]_:; :math:`E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}, \alpha = 3.0`. References; ----------. .. [4] Halkier, Helgaker, Jorgensen, Klopper, & Olsen, Chem. Phys. Lett. 302 (1999) 437-446,; DOI: 10.1016/S0009-2614(99)00179-7. Examples; --------; >>> # [1] Hartree-Fock extrapolation; >>> psi4.energy('cbs', scf_wfn='hf', scf_basis='cc-p",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_cbs_helper.html:13842,Energy,Energy,13842,psi4manual/1.7.x/_modules/psi4/driver/driver_cbs_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_cbs_helper.html,1,['Energy'],['Energy']
Energy Efficiency,"n Integral Algorithm Overview¶; The following table summarizes which implementation is used; for each type of one electron integral in PSI4. Algorithms used for One Electron Integrals¶. Integral; Class; Implementation; Comment. Three-Center Overlap; ThreeCenterOverlapInt; Libint2; using libint2::Operator::delta for 4-center integrals. Angular Momentum; AngularMomentumInt; M-D. Dipole; DipoleInt; Libint2; no derivatives supported. Electric Field; ElectricFieldInt; Libint2; using first derivative of libint2::Operator::nuclear. Coulomb Potential; ElectrostaticInt; Libint2; evaluated for a single origin and unity charge. Kinetic; KineticInt; Libint2. Multipole Potential; MultipolePotentialInt; M-D; arbitrary order derivative of 1/R supported. Multipole Moments; MultipoleInt; M-D; arbitrary order multipoles supported, including nuclear gradients. Nabla Operator; NablaInt; Libint2; using first derivative of libint2::Operator::overlap. Overlap; OverlapInt; Libint2. Nuclear Coulomb Potential; PotentialInt; Libint2; assumes nuclear centers/charges as the potential. PCM Potential; PCMPotentialInt; Libint2; parallelized over charge points. Quadrupole; QuadrupoleInt; Libint2. Traceless Quadrupole; TracelessQuadrupoleInt; Libint2. Relativistic Potential; RelPotentialInt; Libint2. table of contents. Integrals in PSI4; Introduction; The older style; The new syntax; Sieving; Buffer address; Density Screening; Shell blocking; Permutational symmetry; Using bra-ket symmetry; Instantiating integral objects. One Electron Integrals in PSI4; Calling compute_shell(int P, int Q); Accessing integrals; Derivative Integrals; Changes to External Potential Engines; New Operators Available; Shell Pairs; One Electron Integral Algorithm Overview. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Integrals in PSI4. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/prog_integrals.html:18545,charge,charges,18545,psi4manual/master/prog_integrals.html,https://psicode.org,https://psicode.org/psi4manual/master/prog_integrals.html,2,['charge'],"['charge', 'charges']"
Energy Efficiency,"n PSI4 is compiled; under these conditions, parallel runs of the FNOCC code have experienced; nonsensical CCSD correlation energies (often several Hartrees lower; than the starting guess). At the moment, the only confirmed solutions; are running serially, using a different BLAS implementation, or upgrading; to Intel 16.0.2 and MKL 11.3.2. Frozen natural orbitals (FNO)¶; The computational cost of the CCSD [Purvis:1982], CCSD(T); [Raghavachari:1989], and related methods be reduced by constructing a; compact representation of the virtual space based on the natural orbitals; of second-order perturbation theory [Sosa:1989:148]. The most demanding; steps in the CCSD and (T) algorithms scale as \({\cal{O}}(o^2v^4)\); and \({\cal{O}}(o^3v^4)\), where \(o\) and \(v\) represent the; number of oribitals that are occupied and unoccupied (virtual) in the; reference function, respectively. By reducing the the size of the virtual; space, the cost of evaluating these terms reduces by a factor of \((v; / v_{FNO})^4\), where \(v_{FNO}\) represents the number of virtual; orbitals retained after the FNO truncation.; The general outline for the FNO procedure in PSI4 is:. construct the virtual-virtual block of the unrelaxed MP2 one-particle density matrix (OPDM); diagonalize this block of the OPDM to obtain a set of natural virtual orbitals; based on some occupancy threshold, determine which orbitals are unimportant and may be discarded; project the virtual-virtual block of the Fock matrix onto the truncated space; construct semicanonical orbitals by diagonalizing the virtual-virtual block of the Fock matrix; proceed with the QCISD(T) / CCSD(T) / MP4 computation in the reduced virtual space. A second-order correction based upon the MP2 energies in the full and; truncated spaces captures much of the missing correlation effects. More; details on the implementation and numerical accuracy of FNO methods in; PSI4 can be found in [DePrince:2013:293]. FNO computations; are controlled through th",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/fnocc-1.html:1441,reduce,reduces,1441,psi4manual/1.1.0/fnocc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/fnocc-1.html,15,['reduce'],['reduces']
Energy Efficiency,"n SAPT2+, SAPT2+(3) or SAPT2+3, if also doing CCD?. Type: boolean; Default: true. DO_SCS (DFOCC)¶DFOCC — Do perform spin-component-scaled OMP2 (SCS-OMP2)? In all computation, SCS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SCS-OMP2, one needs to set ‘DO_SCS’ to true. Type: boolean; Default: false. DO_SCS (OCC)¶OCC — Removed in 1.4. Will raise an error in 1.5. Pass the method name, like scs-mp2, to energy instead. Type: boolean; Default: false. DO_SINGLETS (CPHF)¶CPHF — Do singlet states? Default true. Type: boolean; Default: true. DO_SOS (DFOCC)¶DFOCC — Do perform spin-opposite-scaled OMP2 (SOS-OMP2)? In all computation, SOS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SOS-OMP2, one needs to set ‘DO_SOS’ to true. Type: boolean; Default: false. DO_SOS (OCC)¶OCC — Removed in 1.4. Will raise an error in 1.5. Pass the method name, like scs-mp2, to energy instead. Type: boolean; Default: false. DO_THIRD_ORDER (SAPT)¶SAPT (Expert) — Do compute third-order corrections?. Type: boolean; Default: false. DO_TRIPLETS (CPHF)¶CPHF — Do triplet states? Default true. Type: boolean; Default: true. DOCC (GLOBALS)¶GLOBALS — An array containing the number of doubly-occupied orbitals per irrep (in Cotton order). Type: array; Default: No Default. DOCC (MCSCF)¶MCSCF — The number of doubly occupied orbitals, per irrep. Type: array; Default: No Default. DYNAMIC_LEVEL (OPTKING)¶OPTKING — Starting level for dynamic optimization (0=nondynamic, higher=>more conservative). Type: integer; Default: 0. E3_SCALE (DFOCC)¶DFOCC — CEPA opposite-spin scaling value from SCS-CCSD. Type: double; Default: 0.25. E3_SCALE (OCC)¶OCC — Scaling value for 3rd order energy correction (S. Grimme, Vol. 24, pp. 1529, J. Comput. Chem.). Type: double; Default: 0.25. E_CONVERGENCE (CCENERGY)¶CCENERGY — Convergence criterion for energy. See Table Post-SCF Convergence ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html:115632,energy,energy,115632,psi4manual/1.4.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html,2,['energy'],['energy']
Energy Efficiency,"n Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; #@END LICENSE; #. # Gn theory. import re; import os; import math; import warnings; import psi4; import p4const; import p4util; from driver import *; #from extend_Molecule import *; from molutil import *; from p4regex import *; # never import aliases into this file. [docs]def run_gaussian_2(name, **kwargs):. # throw an exception for open-shells; if (psi4.get_option('SCF','REFERENCE') != 'RHF' ):; raise ValidationError(""""""g2 computations require ""reference rhf"".""""""). # stash user options:; optstash = p4util.OptionsState(; ['FNOCC','COMPUTE_TRIPLES'],; ['FNOCC','COMPUTE_MP4_TRIPLES'],; ['FREEZE_CORE'],; ['SCF','SCF_TYPE']). # override default scf_type; psi4.set_local_option('SCF','SCF_TYPE','OUT_OF_CORE'). # optimize geometry at scf level; psi4.clean(); psi4.set_global_option('BASIS',""6-31G(D)""); optimize('scf'); psi4.clean(). # scf frequencies for zpe; frequency('scf'). # thermodynamic properties; du = psi4.get_variable('INTERNAL ENERGY CORRECTION'); dh = psi4.get_variable('ENTHALPY CORRECTION'); dg = psi4.get_variable('GIBBS FREE ENERGY CORRECTION'). ref = psi4.wavefunction(); freqs = ref.frequencies(); nfreq = freqs.dim(0); freqsum = 0.0; for i in range (0,nfreq):; freqsum += freqs.get(i); zpe = freqsum / p4const.psi_hartree2wavenumbers * 0.8929 * 0.5; psi4.clean(). # optimize geometry at mp2 (no frozen core) level; # note: freeze_core isn't an option in MP2; psi4.set_global_option('FREEZE_CORE',""FALSE""); optimize('conv-mp2'); psi4.clean(). # qcisd(t); psi4.set_local_option('FNOCC','COMPUTE_MP4_TRIPLES',""TRUE""); psi4.set_global_option('FREEZE_CORE',""TRUE""); psi4.set_global_option('BASIS',""6-311G(D_P)""); run_fnocc('qcisd(t)',**kwargs). # HLC: high-level correction based on number of valence electrons; ref = psi4.wavefunction(); nirrep = ref.nirrep(); frzcpi = ref.frzcpi(); nfzc = 0; for i in range (0,nirrep):; nfzc += frzcpi[i]; nalpha = ref.nalpha() - nfzc; nbeta = ref.nbeta() - nfzc; # hlc of gaussian-2; hlc = -",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/gaussian_n.html:1889,ENERGY,ENERGY,1889,psi4manual/4.0b5/_modules/gaussian_n.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/gaussian_n.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"n a guess for the DCT orbitals. After SCF is; converged, the program will perform the energy computation using the ODC-12; method. By default, simultaneous algorithm will be used for the solution of; the equations. One can also request to perform geometry; optimization following example below:; molecule {; H; H 1 1.0; }. set basis cc-pvdz. optimize('dct'). The optimize('dct') call will first perform all of the procedures; described above to obtain the ODC-12 energy. After that, the ODC-12 analytic; gradients code will be executed and geometry optimization will be performed. Recommendations¶; Here is a list of recommendations for the DCT module:. Generally, the use of the simultaneous algorithm together with the; AO_BASIS DISK option is recommended (set by default).; In cases when available memory is insufficient, the use of the AO_BASIS DISK option; is recommended. This will significantly reduce the memory requirements. However, when; used together with the two-step algorithm, this option can significantly; increase the cost of the energy computation.; In cases when the oscillatory convergence is observed before the DIIS; extrapolation is initialized, it is recommended to increase the threshold for; the RMS of the density cumulant or orbital update residual, below which the; DIIS extrapolation starts. This can be done by setting the; DIIS_START_CONVERGENCE option to the value greater than; \(10^{-3}\) by one or two orders of magnitude (e.g. \(10^{-2}\) or; \(10^{-1}\)). This can be particularly useful for computations using the; ODC methods, because it can greatly reduce the number of iterations.; If oscillatory convergence is observed for atoms or molecules with high; symmetry, it is recommended to use the quadratically-convergent algorithm.; When using the quadratically-convergent algorithm for the closed-shell molecules, it; is recommended to set the QC_COUPLING option to FALSE for efficiency; reasons (set by default).; For the ODC computations, the user has a ch",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/dct-1.html:14415,energy,energy,14415,psi4manual/1.4.0/dct-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/dct-1.html,9,['energy'],['energy']
Energy Efficiency,"n a regular array in later parts of the input; file.; The next section, beginning with for R in Rvals:, loops over the; interatomic distances, R, in our array Rvals. In Python,; loops need to be indented, and each line in the loop has to be indented; by the same amount. The first line in the loop, dimer.R = R,; sets the Z-matrix variable R of the molecule called dimer; to the R value extracted from the Rvals array. The next line,; ecp[R] = energy('ccsd(t)', bsse_type='cp'), computes the counterpoise-corrected; CCSD(T) energy and places it in the ecp dictionary with R as; the index. Note we didn’t need to specify ghost atoms, and we didn’t need; to call the monomer and dimer computations separately. The built-in; Psithon function _nbody_gufunc() does it all for us, automatically.; Near the very end of the output file, the counterpoise correction Python; function will print a nice summary of the results of the counterpoise; computation (the energies of the dimer, of monomer 1 with the ghost functions; of monomer 2, of monomer 2 with the ghost functions of monomer 1, and the; overall counterpoise-corrected interaction energy):; //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>//; // CP Computation: Results. //; //<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<//. ============= Hartree =============; System: Energy (full):; Complex -257.4186740329; Monomer 1 -128.7093240575; Monomer 2 -128.7093240575; Interaction -0.0000259178. =========== kcal*mol^-1 ===========; System: Energy (full):; Complex -161532.6634330375; Monomer 1 -80766.3235846726; Monomer 2 -80766.3235846725; Interaction -0.0162636924. And that’s it! The only remaining part of the example input is a little table; of the different R values and the CP-corrected CCSD(T) energies, converted from; atomic units (hartree) to kcal mol-1 by multiplying by the; automatically-defined conversion factor psi_hartree2kcalmol. Psi4; provides several built-in physical constants and conversion factors, as; described in section Physical Constants.; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/tutorial-1.html:20263,energy,energy,20263,psi4manual/1.0.0/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/tutorial-1.html,2,['energy'],['energy']
Energy Efficiency,"n a regular array in later parts of the input; file.; The next section, beginning with for R in Rvals:, loops over the; interatomic distances, R, in our array Rvals. In Python,; loops need to be indented, and each line in the loop has to be indented; by the same amount. The first line in the loop, dimer.R = R,; sets the Z-matrix variable R of the molecule called dimer; to the R value extracted from the Rvals array. The next line,; ecp[R] = energy('ccsd(t)', bsse_type='cp'), computes the counterpoise-corrected; CCSD(T) energy and places it in the ecp dictionary with R as; the index. Note we didn’t need to specify ghost atoms, and we didn’t need; to call the monomer and dimer computations separately. The built-in; Psithon function nbody() does it all for us, automatically.; Near the very end of the output file, the counterpoise correction Python; function will print a nice summary of the results of the counterpoise; computation (the energies of the dimer, of monomer 1 with the ghost functions; of monomer 2, of monomer 2 with the ghost functions of monomer 1, and the; overall counterpoise-corrected interaction energy):; N-Body: Computing complex (1/2) with fragments (2,) in the basis of fragments (1, 2).; ...; N-Body: Complex Energy (fragments = (2,), basis = (1, 2): -128.70932405488924); ...; N-Body: Computing complex (2/2) with fragments (1,) in the basis of fragments (1, 2).; ...; N-Body: Complex Energy (fragments = (1,), basis = (1, 2): -128.70932405488935); ...; N-Body: Computing complex (1/1) with fragments (1, 2) in the basis of fragments (1, 2).; ...; N-Body: Complex Energy (fragments = (1, 2), basis = (1, 2): -257.41867403127321); ...; ==> N-Body: Counterpoise Corrected (CP) energies <==. n-Body Total Energy [Eh] I.E. [kcal/mol] Delta [kcal/mol]; 1 -257.418648109779 0.000000000000 0.000000000000; 2 -257.418674031273 -0.016265984132 -0.016265984132. And that’s it! The only remaining part of the example input is a little table; of the different R values and the C",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/tutorial.html:20897,energy,energy,20897,psi4manual/1.6.x/tutorial.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/tutorial.html,5,['energy'],['energy']
Energy Efficiency,"n a small basis, and then; casting up to the true basis. This can be done by adding; BASIS_GUESS = SMALL_BASIS to the options list. We recommend the; 3-21G or pcseg-0 basis for the small basis due to its efficient mix of flexibility and; compactness. An example of performing an RHF solution of water by SAD guessing; in a 3-21G basis and then casting up to cc-pVTZ is shown below:; molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; basis cc-pvtz; basis_guess 3-21G; guess sad; }. energy('scf'). Restarting the SCF¶; Reading orbital data from a previous calculations is done via the restart_file option,; where the actual file is a serialized wfn object (see saving the wfn); By default, the orbital data file of the converged SCF(psi.PID.name.180.npy) is deleted; after PSI4 exits or the clean() function is called. The orbital guess is automatically; set to READ when restart_file is given a wfn file.; To write the orbitals after every iteration and keep the orbitals from the last iteration, the write_orbitals options is available:; energy('scf', write_orbitals='my_mos'),. which writes a Wavefunction object converted (serialized) to a numpy file called my_mos.npy.; The restart can then be done as follows:; energy('scf', restart_file='my_mos'). Specifying the .npy suffix when writing and reading restart files is optional.; Alternatively, the restart can also be done from any previously saved wfn object.; energy, scf_wfn = energy('scf',return_wfn=True); scf_wfn.to_file('my_wfn'); energy('scf', restart_file='my_wfn'). For advanced users manipulating or writing custom wavefunction files, note; that PSI4 expects the numpy file on disk to have the .npy extension, not, e.g., .npz. Convergence Stabilization¶; A summary of Psi’s supported convergence stabilization techniques is presented below:. DIIS [On by Default]DIIS uses previous iterates of the Fock matrix together; with an error criterion based on the orbital gradient to produce an informed; estimate of the next Fock Mat",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/scf.html:20249,energy,energy,20249,psi4manual/1.6.x/scf.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/scf.html,5,['energy'],['energy']
Energy Efficiency,"n a small basis, and then; casting up to the true basis. This can be done by adding; BASIS_GUESS = SMALL_BASIS to the options list. We recommend the; 3-21G or pcseg-0 basis for the small basis due to its efficient mix of flexibility and; compactness. An example of performing an RHF solution of water by SAD guessing; in a 3-21G basis and then casting up to cc-pVTZ is shown below:; molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; basis cc-pvtz; basis_guess 3-21G; guess sad; }. energy('scf'). Restarting the SCF¶; Reading orbital data from a previous calculations is done via the restart_file option,; where the actual file is a serialized wfn object (see saving the wfn); By default, the orbital data file of the converged SCF(psi.PID.name.180.npy) is deleted; after PSI4 exits or the clean() function is called. The orbital guess is automatically; set to READ when restart_file is given a wfn file.; To write the orbitals after every iteration and keep the orbitals from the last iteration, the write_orbitals options is available:; energy('scf', write_orbitals='my_mos'),. which writes a Wavefunction object converted (serialized) to a numpy file called my_mos.npy.; The restart can then be done as follows:; energy('scf', restart_file='my_mos'). Specifying the .npy suffix when writing and reading restart files is optional.; Alternatively, the restart can also be done from any previously saved wfn object.; energy, scf_wfn = energy('scf',return_wfn=True); scf_wfn.to_file('my_wfn'); energy('scf', restart_file='my_wfn'). For advanced users manipulating or writing custom wavefunction files, note; that PSI4 expects the numpy file on disk to have the .npy extension, not, e.g., .npz. Convergence Stabilization¶; With regard to convergence stabilization, Pulay’s Direct Inversion of the; Iterative Subspace (DIIS) extrapolation, Gill’s Maximum Overlap Method (MOM),; and damping are all implemented. A summary of each is presented below,. DIIS [On by Default]DIIS uses previous iterat",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/scf-1.html:20233,energy,energy,20233,psi4manual/1.4.0/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/scf-1.html,4,['energy'],['energy']
Energy Efficiency,"n addition, the Wavefunction density attributes; (Da and Db) return the SO density and must be transformed to the MO basis; to use with this function. .. versionadded:: 0.5; *wfn* parameter passed explicitly. :returns: None. :type wfn: :py:class:`~psi4.core.Wavefunction`; :param wfn: set of molecule, basis, orbitals from which to generate cube files. :type filename: str; :param filename: destination file name for MOLDEN file (optional). :type density_a: :py:class:`~psi4.core.Matrix`; :param density_a: density in the MO basis to build alpha NO's from (optional). :type density_b: :py:class:`~psi4.core.Matrix`; :param density_b: density in the MO basis to build beta NO's from, assumes restricted if not supplied (optional). :type dovirtual: bool; :param dovirtual: do write all the MOs to the MOLDEN file (true) or discard the unoccupied MOs, not valid for NO's (false) (optional). :examples:. 1. Molden file with the Kohn-Sham orbitals of a DFT calculation. >>> E, wfn = energy('b3lyp', return_wfn=True); >>> molden(wfn, 'mycalc.molden'). 2. Molden file for CI/MCSCF computation using NO roots.; Any method returning a ``CIWavefunction`` object will work: ``detci``,; ``fci``, ``casscf``, etc. The first two arguments of ``get_opdm`` can be; set to ``n, n`` where n => 0 selects the root to write out, provided; these roots were computed, see :term:`NUM_ROOTS <NUM_ROOTS (DETCI)>`. The; third argument controls the spin (``""A""``, ``""B""`` or ``""SUM""``) and the final; boolean option determines whether inactive orbitals are included. >>> E, wfn = energy('detci', return_wfn=True); >>> molden(wfn, 'no_root1.molden', density_a=wfn.get_opdm(0, 0, ""A"", True)). 3. The following produces **an INCORRECT Molden file**, because the; ``molden`` function needs orbitals in the MO basis (which are internally; converted and written to the Molden file in the AO basis). The correct; usage is given in the next point. >>> E, wfn = energy('ccsd', return_wfn=True); >>> molden(wfn, 'ccsd_no.molden', density",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:99413,energy,energy,99413,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,14,['energy'],['energy']
Energy Efficiency,"n additional thread. Type: boolean; Default: false. AIO_DF_INTS¶. Do use asynchronous disk I/O in the formation of the DF integrals? Use may speed up the computation slightly at the cost of spawning an additional thread. Type: boolean; Default: false. BASIS¶. Primary basis set, describes the monomer molecular orbitals. Type: string; Possible Values: basis string; Default: No Default. CCD_E_CONVERGENCE¶. E converge value for CCD. Type: conv double; Default: 1e-8. CCD_MAXITER¶. Max CCD iterations. Type: integer; Default: 50. CCD_T_CONVERGENCE¶. Convergence tolerance for CCD amplitudes. Type: conv double; Default: 1e-8. CPHF_R_CONVERGENCE¶. Convergence criterion for residual of the CPHF/CPKS coefficients in the SAPT \(E_{ind,resp}^{(20)}\) term. This applies to wavefunction-based SAPT or SAPT(DFT). See CPHF_R_CONVERGENCE for fragment-partitioned or intramolecular SAPT. Type: conv double; Default: 1e-8. DENOMINATOR_ALGORITHM¶. Denominator algorithm for PT methods. Laplace transformations are slightly more efficient. Type: string; Possible Values: LAPLACE, CHOLESKY; Default: LAPLACE. DENOMINATOR_DELTA¶. Maximum error allowed (Max error norm in Delta tensor) in the approximate energy denominators employed for most of the \(E_{disp}^{(20)}\) and \(E_{exch-disp}^{(20)}\) evaluation. Type: double; Default: 1.0e-6. DF_BASIS_ELST¶. Auxiliary basis set for SAPT Elst10 and Exch10 density fitting computations, may be important if heavier elements are involved. Defaults to a JKFIT basis. Previous to v1.6, defaulted to DF_BASIS_SAPT See fitting notes . Type: string; Possible Values: basis string; Default: No Default. DF_BASIS_SAPT¶. Auxiliary basis set for SAPT density fitting computations. Defaults to a RI basis. Type: string; Possible Values: basis string; Default: No Default. EXCH_SCALE_ALPHA¶. Whether or not to perform exchange scaling for SAPT exchange components. Default is false, i.e. no scaling. If set to true, performs scaling with \(Exch10 / Exch10(S^2)\). If set to a valu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodir_options_c/module__sapt.html:1420,efficient,efficient,1420,psi4manual/master/autodir_options_c/module__sapt.html,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/module__sapt.html,2,['efficient'],['efficient']
Energy Efficiency,"n all PSI4 input files. # Do not modify this file! It is auto-generated by the document_options_and_tests; # script, from psi4topdir/psi4/include/psi4/physconst.h; h = 6.62606896E-34 # The Planck constant (Js) ; c = 2.99792458E8 # Speed of light (ms$^{-1}$) ; kb = 1.3806504E-23 # The Boltzmann constant (JK$^{-1}$) ; R = 8.314472 # Universal gas constant (JK$^{-1}$mol$^{-1}$) ; bohr2angstroms = 0.52917720859 # Bohr to Angstroms conversion factor ; bohr2m = 0.52917720859E-10 # Bohr to meters conversion factor ; bohr2cm = 0.52917720859E-8 # Bohr to centimeters conversion factor ; amu2g = 1.660538782E-24 # Atomic mass units to grams conversion factor ; amu2kg = 1.660538782E-27 # Atomic mass units to kg conversion factor ; au2amu = 5.485799097E-4 # Atomic units (m$@@e$) to atomic mass units conversion factor ; hartree2J = 4.359744E-18 # Hartree to joule conversion factor ; hartree2aJ = 4.359744 # Hartree to attojoule (10$^{-18}$J) conversion factor ; cal2J = 4.184 # Calorie to joule conversion factor ; dipmom_au2si = 8.47835281E-30 # Atomic units to SI units (Cm) conversion factor for dipoles ; dipmom_au2debye = 2.54174623 # Atomic units to Debye conversion factor for dipoles ; dipmom_debye2si = 3.335640952E-30 # Debye to SI units (Cm) conversion factor for dipoles ; c_au = 137.035999679 # Speed of light in atomic units ; hartree2ev = 27.21138 # Hartree to eV conversion factor ; hartree2wavenumbers = 219474.6 # Hartree to cm$^{-1}$ conversion factor ; hartree2kcalmol = 627.5095 # Hartree to kcal mol$^{-1}$ conversion factor ; hartree2kJmol = 2625.500 # Hartree to kilojoule mol$^{-1}$ conversion factor ; hartree2MHz = 6.579684E9 # Hartree to MHz conversion factor ; kcalmol2wavenumbers = 349.7551 # kcal mol$^{-1}$ to cm$^{-1}$ conversion factor ; e0 = 8.854187817E-12 # Vacuum permittivity (Fm$^{-1}$) ; na = 6.02214179E23 # Avagadro's number ; me = 9.10938215E-31 # Electron rest mass (in kg) . In Psithon input files, prepend physical constants with psi_ to; prevent clashes ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psithoninput-1.html:2745,joule,joule,2745,psi4manual/1.1.0/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psithoninput-1.html,4,['joule'],['joule']
Energy Efficiency,"n an RKS computation. dfccsd-t-grad1; DF-CCSD(T) cc-pVDZ gradients for the H2O molecule. cc13a; UHF-CCSD(T)/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. sapt-exch-disp-inf; SAPT0 with S^inf exch-disp20. props1; RHF STO-3G dipole moment computation, performed by applying a finite electric field and numerical differentiation. cbs-parser; mtd/basis syntax examples. pubchem1; Benzene vertical singlet-triplet energy difference computation, using the PubChem database to obtain the initial geometry, which is optimized at the HF/STO-3G level, before computing single point energies at the RHF, UHF and ROHF levels of theory. basis-ecp; check mixing ECP and non-ECP orbital/fitting basis sets in a session. dfremp-1; density fitted REMP/cc-pVDZ energies for the CO2 molecule. psithon1; Spectroscopic constants of H2, and the full ci cc-pVTZ level of theory. pywrap-alias; Test parsed and exotic calls to energy() like zapt4, mp2.5, and cisd are working. omp2-1; OMP2 cc-pVDZ energy for the H2O molecule. sapt4; SAPT2+(3) aug-cc-pVDZ computation of the formamide dimer interaction energy, using the aug-cc-pVDZ-JKFIT DF basis for SCF and aug-cc-pVDZ-RI for SAPT. This example uses frozen core as well as MP2 natural orbital approximations. dct5; DC-06 calculation for the O2 molecule (triplet ground state). This performs geometry optimization using two-step and simultaneous solution of the response equations for the analytic gradient. cc15; RHF-B-CCD(T)/6-31G** H2O single-point energy (fzc, MO-basis \(\langle ab|cd \rangle\)). psimrcc-sp1; Mk-MRCCSD single point. \(^3 \Sigma ^-\) O2 state described using the Ms = 0 component of the triplet. Uses ROHF triplet orbitals. tu3-h2o-opt; Optimize H2O HF/cc-pVDZ. dft-custom-dhdf; DSD-PBEP86 S22 Ammonia test. cc30; CCSD/sto-3g optical rotation calculation (length gauge only) at two frequencies on methyloxirane. tu2-ch2-energy; Sample UHF/6-31G** CH2 computation. mp2-property; MP2 cc-pvDZ properties for Nitrogen oxide. cdremp",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html:9404,energy,energy,9404,psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"n array of bases. Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{total}^X = E_{total}^X. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) == 0):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; if (wfnname == 'scf'):; portion = 'tot'; else:; portion = 'corl'; NEED = {'HI': dict(zip(f_fields, [wfnname, portion, BSET[len(ZSET) - 1], ZSET[len(ZSET) - 1], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; # Compute extrapolated energy; energypiece = NEED['HI']['f_energy']. # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); if (NEED['HI']['f_wfn'] == 'scf'):; cbsscheme += """""" HI-zeta (%s) Total Energy: %16.8f\n"""""" % (str(NEED['HI']['f_zeta']), energypiece); else:; cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(NEED['HI']['f_zeta']), energypiece); PsiMod.print_out(cbsscheme). return energypiece. # Solution equation in LaTeX: $E_{corl}^{\infty} = \frac{E_{corl}^{X} X^3 - E_{corl}^{X-1} (X-1)^3}{X^3 - (X-1)^3}$; # Solution equation in LaTeX: $\beta = \frac{E_{corl}^{X} - E_{corl}^{X-1}}{X^{-3} - (X-1)^{-3}}$; [docs]def corl_xtpl_helgaker_2(**largs):; r""""""Extrapolation scheme for correlation energies with two adjacent zeta-level bases.; Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{corl}^X = E_{corl}^{\infty} + \beta X^{-3}. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'r",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:78409,Energy,Energy,78409,psi4manual/4.0b2/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html,3,['Energy'],['Energy']
Energy Efficiency,"n array of bases. Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{total}^X = E_{total}^X. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) == 0):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; if (wfnname == 'scf'):; portion = 'tot'; else:; portion = 'corl'; NEED = {'HI': dict(zip(f_fields, [wfnname, portion, BSET[len(ZSET) - 1], ZSET[len(ZSET) - 1], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; # Compute extrapolated energy; energypiece = NEED['HI']['f_energy']. # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); if (NEED['HI']['f_wfn'] == 'scf'):; cbsscheme += """""" HI-zeta (%s) Total Energy: %16.8f\n"""""" % (str(NEED['HI']['f_zeta']), energypiece); else:; cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(NEED['HI']['f_zeta']), energypiece); psi4.print_out(cbsscheme). return energypiece. # Solution equation in LaTeX: $E_{corl}^{\infty} = \frac{E_{corl}^{X} X^3 - E_{corl}^{X-1} (X-1)^3}{X^3 - (X-1)^3}$; # Solution equation in LaTeX: $\beta = \frac{E_{corl}^{X} - E_{corl}^{X-1}}{X^{-3} - (X-1)^{-3}}$; [docs]def corl_xtpl_helgaker_2(**largs):; r""""""Extrapolation scheme for correlation energies with two adjacent zeta-level bases.; Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{corl}^X = E_{corl}^{\infty} + \beta X^{-3}. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'req",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:94192,Energy,Energy,94192,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,1,['Energy'],['Energy']
Energy Efficiency,"n atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('conv-mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] cbs() coupled with database(); >>> database('conv-mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='sto-3g'). Output¶; At the beginning of a cbs() job is printed a listing of the individual; energy calculations which will be performed. The output snippet below is; from the example job [2] above. It shows first each model chemistry needed; to compute the aggregate model chemistry requested through cbs(). Then,; since, for example, an energy('ccsd(t)') yields CCSD(T), CCSD, MP2,; and SCF energy values, the wrapper condenses this task list into the second; list of minimum number of calculations which will actually be run.; Naive listing of computations required.; scf / aug-cc-pvqz for SCF TOTAL ENERGY; mp2 / aug-cc-pvtz for MP2 CORRELATION ENERGY; mp2 / aug-cc-pvqz for MP2 CORRELATION ENERGY; ccsd(t) / aug-cc-pvdz for CCSD(T) CORRELATION ENERGY; ccsd(t) / aug-cc-pvtz for CCSD(T) CORRELATION ENERGY; mp2 / aug-cc-pvdz for MP2 CORRELATION ENERGY; mp2 / aug-cc-pvtz for MP2 CORRELATION ENERGY. Enlightened listing of computations required.; mp2 / aug-cc-pvqz for MP2 CORRELATION ENERGY; ccsd(t) / aug-cc-pvdz for CCSD(T) CORRELATION ENERGY; ccsd(t) / aug-cc-pvtz for CCSD(T) CORRELATION ENERGY. At the end of a cbs() job is printed a summary section like the one below. First,; in the components section, are listed the results for each model chemistry available, whether; required for the cbs job (*) or not. Next, in the stages section, are listed the results for; each extrapolation. The energies of this s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/cbs-1.html:7804,energy,energy,7804,psi4manual/4.0b3/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/cbs-1.html,4,['energy'],['energy']
Energy Efficiency,"n be controlled through the keyword; CHOLESKY_TOLERANCE.; The following input file sets up a DF-CCSD(T); computation using CD integrals; molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; scf_type cd; cc_type cd; basis aug-cc-pvdz; freeze_core true; }; energy('ccsd(t)'). The resulting CCSD(T) correlation energy will be equivalent to that; obtained from a conventional computation if CHOLESKY_TOLERANCE is; sufficiently small (e.g. 1e-9). Gn theory¶; The FNOCC module contains all the components that comprise the Gn family; of composite methods. Currently, only the G2 method is supported; [Curtiss:1991:7221]. The G2 procedure may be called through the; energy() wrapper:; energy('gaussian-2'). Supported methods¶; The various methods supported by the FNOCC module in PSI4 are detailed; in Table FNOCC Methods. Note that these methods; are implemented for closed-shell references only. For open-shell references,; the calls energy('mp2.5'), energy('mp3'), and energy('mp4') will; default to implementations of these methods in other modules. name; calls method; type select. qcisd; quadratic configuration interaction singles doubles; CI_TYPE CONV. qcisd(t); qcisd with perturbative triples; CI_TYPE CONV. mp2.5; average of second- and third-order perturbation theories; MP_TYPE CONV. mp3; third-order perturbation theory; MP_TYPE CONV. mp4(sdq); fourth-order perturbation theory, minus triples contribution; MP_TYPE CONV. mp4; full fourth-order perturbation theory; MP_TYPE CONV. lccd; linear ccd; CC_TYPE CONV. cepa(0), lccsd; coupled electron pair approximation, variant 0; CC_TYPE CONV. cepa(1); coupled electron pair approximation, variant 1; CC_TYPE CONV. cepa(3); coupled electron pair approximation, variant 3; CC_TYPE CONV. acpf; averaged coupled-pair functional; CC_TYPE CONV. aqcc; averaged quadratic coupled-cluster; CC_TYPE CONV. cisd; configuration interaction with single and double excitations; CI_TYPE CONV. fno-qcisd; qcisd with frozen natural orbitals; CI_TYPE CONV. fno",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/fnocc-1.html:12822,energy,energy,12822,psi4manual/1.4.0/fnocc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/fnocc-1.html,10,['energy'],['energy']
Energy Efficiency,n be used to direct lone scf components to run in PSI4 or Cfour; in a mixed-program composite method. corl_wfn (string) – 'mp2' || 'ccsd(t)' || etc.; Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with name or as the unlabeled; first argument to the function. delta_wfn (string) – 'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. delta_wfn_lesser (string) – \(\Rightarrow\) corl_wfn \(\Leftarrow\) || 'mp2' || etc.; Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. delta2_wfn (string) – 'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. delta2_wfn_lesser (string) – \(\Rightarrow\) delta_wfn \(\Leftarrow\) || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. delta3_wfn (string) – 'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a third delta correction; to the correlation energy is to be obtained. delta3_wfn_lesser (string) – \(\Rightarrow\) delta2_wfn \(\Leftarrow\) || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a third delta correction; to the correlation energy is to be obtained. delta4_wfn (string) – 'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a fourth delta correction; to the correlation energy is to be obtained. delta4_wfn_lesser (string) – \(\Rightarrow\) delta3_wfn \(\Leftarrow\) || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a fourth delta correction; to the correlation energy is to be obtained. delta5_wfn (string) – 'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a fifth delta correction; to the correlation energy is to be obtained. de,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/cbs-1.html:4737,energy,energy,4737,psi4manual/1.2.1/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/cbs-1.html,14,['energy'],['energy']
Energy Efficiency,"n coordinates. cfour/sp-rhf-ccsd_t_; single-point CCSD(T)/qz2p on water. cfour/sp-rohf-ccsd_t_-ao; single-point CCSD(T)/qz2p on NH2 with aobasis. cfour/sp-rhf-cc3; single-point CC3/qz2p on water. cfour/sp-rhf-ccsd_t_-ao-ecc; single-point CCSD(T)/qc2p on water with ecc, aobasis. cfour/psi-rhf-scsmp2; MP2 energy components. Checks that computed identically between cfour and psi4. cfour/sp-rhf-ccsdt; single-point CCSDT/qz2p on water. cfour/sp-rohf-ccsdt; single-point CCSDT/qz2p on NH2. cfour/psi-mp4; MP4 energy components. Checks that computed identically between cfour and psi4. cfour/sp-rhf-ccsd_t_-fc; single-point CCSD(T)/qz2p on water with ecc, aobasis, and frozen-core. cfour/psi-ghost-grad; MP2 optimization of dimers with one momomer ghosted. Gradients after three opt cycles are compared with those from psi4. cfour/sp-rohf-scf; single-point HF/qz2p on NH2. cfour/psi-rohf-scsmp2; ROHF MP2 energy components. Checks that computed identically between cfour and psi4. cfour/psi-uhf-mp3; UHF MP3 energy components. Checks that converted identically between cfour and psi4. cfour/opt-rhf-mp2; optimization MP2/cc-pvtz on water. cfour/sp-uhf-ccsd_t_; single-point CCSD(T)/qz2p. cfour/sp-uhf-ccsd_t_-ao; single-point CCSD(T)/qz2p on NH2 with aobasis. cfour/pywrap-basis; SAPT calculation on bimolecular complex where monomers are unspecified so driver auto-fragments it. Basis set and auxiliary basis sets are assigned by atom type. cfour/pywrap-db1; Database calculation, so no molecule section in input file. Portions of the full databases, restricted by subset keyword, are computed by sapt0 and dfmp2 methods. cfour/kw-5; Basis set spherical/Cartesian with basis and cfour_spherical. cfour/sp-rohf-ccsd; single-point CCSD/qz2p on NH2. cfour/sp-uhf-ccsd_t_-ecc; single-point CCSD(T)/qz2p on NH2 with ecc. cfour/kw-1; testing best practices options, part i. cfour/mints5; geometries from a variety of input formats. references from psi4, testing whether geometry strings read identically for ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_cfour.html:2808,energy,energy,2808,psi4manual/1.6.x/autodoc_testsuite_cfour.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_cfour.html,1,['energy'],['energy']
Energy Efficiency,"n dertype is unspecified, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; research site: https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/dft-d3; Psi4 mode: When psi4 the python module is importable at import qcdb. time, Psi4 mode is activated, with the following alterations:; * output goes to output file; * gradient returned as psi4.core.Matrix, not list o’lists; * scratch is written to randomly named subdirectory of psi scratch; * psivar “DISPERSION CORRECTION ENERGY” is set; * verbose triggered when PRINT keywork of SCF module >=3. run_gcp(func=None, dertype=None, verbose=False); Function to call Grimme’s dftd3 program (http://toc.uni-muenster.de/DFTD3/); to compute the -D correction of level dashlvl using parameters for; the functional func. The dictionary dashparam can be used to supply; a full set of dispersion parameters in the absense of func or to supply; individual overrides in the presence of func. Returns energy if dertype is 0,; gradient if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The dftd3 executable must be independently compiled and found in; PATH or PSIPATH.; self may be either a qcdb.Molecule (sensibly) or a psi4.Molecule; (works b/c psi4.Molecule has been extended by this method py-side and; only public interface fns used) or a string that can be instantiated; into a qcdb.Molecule. save_string_xyz(self: psi4.core.Molecule) → str; Saves the string of an XYZ file to arg2. save_string_xyz_file(self: psi4.core.Molecule) → str; Saves an XYZ file to arg2. save_xyz_file(self: psi4.core.Molecule, arg0: str, arg1: bool) → None; Saves an XYZ file to arg2. schoenflies_symbol(self: psi4.core.Molecule) → str; Returns the Schoenflies symbol. scramble(do_shift=True, do_rotate=True, do_resort=True, deflection=1.0, do_mirror=False, do_plot=False, run_to_completion=False, run_resorting=False, verbose=1); Tester for B787 by shifting, rotating, and atom shuffling ref_mol and; checking that the aligner returns the opp",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/api/psi4.core.molecule.html:50299,energy,energy,50299,psi4manual/1.2.1/api/psi4.core.molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/api/psi4.core.molecule.html,2,['energy'],['energy']
Energy Efficiency,"n directory, substitute; objdir/stage/prefix for prefix.); # csh, tcsh: add to shell or ~/.tcshrc file; setenv PYTHONPATH {prefix}/lib:$PYTHONPATH; setenv PSI_SCRATCH /path/to/existing/writable/local-not-network/directory/for/scratch/files. # sh, bash: add to shell or ~/.bashrc (Linux/Windows) or ~/.bash_profile (Mac) file; export PYTHONPATH={prefix}/lib:$PYTHONPATH; export PSI_SCRATCH=/path/to/existing/writable/local-not-network/directory/for/scratch/files. Note; If you know the location of the PSI4 executable; (bin/psi4) and want to know the corresponding location to add to; PYTHONPATH, execute psi4 --psiapi-path. It will return; bash commands to set PATH (for correct python interpreter); and PYTHONPATH (to find psi4 module) correctly, after which; python -c ""import psi4"" will work. Run PSI4.; 1; 2; 3; 4; 5; 6; 7; 8; 9>>> cat sample.py; import psi4; mol = psi4.geometry(""""""; He; """"""); psi4.energy('hf/cc-pvdz'); psi4.compare_values(-2.85518839, psi4.core.get_variable('current energy'), 5, 'SCF E'); >>> python sample.py; SCF E.............................................................PASSED. How to run Psi4 as executable or Python module from conda installation¶; The configuration commands below are generic versions of the ones printed; to your screen as advice upon installing PSI4 into a Anaconda,; Miniconda, or Psi4conda distribution, condadist =; ana|mini|psi4conda. If which conda python psi4 points to your; condadist and echo $PSI_SCRATCH is set, skip ahead to the; “Run PSI4” commands below. Otherwise, issue the following; commands directly in your terminal or place them into your “rc” file and; open a new terminal.; If you installed the Psi4conda distribution or installed the PSI4; conda package into the main environment of an Anaconda or Miniconda; distribution and added that to your PATH, as prompted, then; which psi4 likely yields condadist/bin/psi4 and the PATH; setting lines below are redundant.; If you installed into a conda environment p4env and performe",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/build_planning-1.html:20996,energy,energy,20996,psi4manual/1.1.0/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/build_planning-1.html,2,['energy'],['energy']
Energy Efficiency,"n energies. Use this option and NOT the ``bsse_type=""cp""``; function for BSSE correction in database(). Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes. :type rlxd: :ref:`boolean <op_py_boolean>`; :param rlxd: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether correction for deformation energy is; employed in computing interaction energies. Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes; with non-frozen monomers, e.g., HBC6. :type symm: :ref:`boolean <op_py_boolean>`; :param symm: |dl| ``'on'`` |dr| || ``'off'``. Indicates whether the native symmetry of the database reagents is; employed (``'on'``) or whether it is forced to :math:`C_1` symmetry; (``'off'``). Some computational methods (e.g., SAPT) require no; symmetry, and this will be set by database(). :type zpe: :ref:`boolean <op_py_boolean>`; :param zpe: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether zero-point-energy corrections are appended to; single-point energy values. Option valid only for certain; thermochemical databases. Disabled until Hessians ready. :type benchmark: str; :param benchmark: |dl| ``'default'`` |dr| || ``'S22A'`` || etc. Indicates whether a non-default set of reference energies, if; available (See :ref:`sec:availableDatabases`), are employed for the; calculation of error statistics. :type tabulate: List[str]; :param tabulate: |dl| ``[]`` |dr| || ``['scf total energy', 'natom']`` || etc. Indicates whether to form tables of variables other than the; primary requested energy. Available for any PSI variable. :type subset: Union[str, List[str]]; :param subset:. Indicates a subset of the full database to run. This is a very; flexible option and can be used in three distinct ways, outlined; below. Note that two take a string and the last takes an array.; See :ref:`sec:availableDatabases` for available values. * ``'small'`` || ``'large'`` || ``'equilibrium'``; Calls predefined subsets of the r",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html:5318,energy,energy,5318,psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,28,['energy'],['energy']
Energy Efficiency,"n energy component [H]; for the MP2 level of theory. MP2.5 TOTAL ENERGY¶. MP2.5 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2.5 level of theory. MP3 TOTAL ENERGY¶. MP3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP3 level of theory. MP4(SDQ) TOTAL ENERGY¶. MP4(SDQ) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP4 singles, doubles, quadruples level of theory. Quantity; MP4(SDQ) CORRELATION ENERGY is; first right-hand term in Eq. (2). MP4 TOTAL ENERGY¶. MP4 CORRELATION ENERGY¶. MP4(SDTQ) TOTAL ENERGY¶. MP4(SDTQ) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the full MP4 level of theory. Quantity MP4 CORRELATION; ENERGY / MP4(SDTQ) CORRELATION ENERGY is left-hand term in Eq. (2). (2). MPn TOTAL ENERGY¶. MPn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled Möller–Plesset perturbation theory level.; n is MP perturbation order. NUCLEAR REPULSION ENERGY¶; The nuclear repulsion energy contribution [H] to the total SCF energy.; Quantity in Eq. (4). (3). OCEPA(0) TOTAL ENERGY¶. OCEPA(0) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the orbital-optimized CEPA(0) level of theory. OMP2 TOTAL ENERGY¶. OMP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the orbital-optimized MP2 level of theory. OMP3 TOTAL ENERGY¶. OMP3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the orbital-optimized MP3 level of theory. ONE-ELECTRON ENERGY¶; The one-electron energy contribution [H] to the total SCF energy.; Quantity in Eq. (4). QCISD TOTAL ENERGY¶. QCISD CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the quadratic configuration interact",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/glossary_psivariables-1.html:13051,energy,energy,13051,psi4manual/1.0.0/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/glossary_psivariables-1.html,12,['energy'],['energy']
Energy Efficiency,"n energy component [H]; for the full configuration interaction level of theory. HF TOTAL ENERGY¶; The total electronic energy [H] for the Hartree–Fock method, without; any dispersion correction; the first three (or four, since; ) terms in Eq. (4). Quantity ; in Eq. (4). LCC2 (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CC2 level of theory. LCCSD (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CCSD level of theory. MP2 TOTAL ENERGY¶. MP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2 level of theory. MP2.5 TOTAL ENERGY¶. MP2.5 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2.5 level of theory. MP3 TOTAL ENERGY¶. MP3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP3 level of theory. MP4(SDQ) TOTAL ENERGY¶. MP4(SDQ) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP4 singles, doubles, quadruples level of theory. Quantity; MP4(SDQ) CORRELATION ENERGY is; first right-hand term in Eq. (2). MP4 TOTAL ENERGY¶. MP4 CORRELATION ENERGY¶. MP4(SDTQ) TOTAL ENERGY¶. MP4(SDTQ) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the full MP4 level of theory. Quantity MP4 CORRELATION; ENERGY / MP4(SDTQ) CORRELATION ENERGY is left-hand term in Eq. (2). (2). MPn TOTAL ENERGY¶. MPn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled Möller–Plesset perturbation theory level.; n is MP perturbation order. NUCLEAR REPULSION ENERGY¶; The nuclear repulsion energy contribution [H] to the total SCF energy.; Quantity in Eq. (4). (3). OCEPA(0) TOTAL ENERGY¶. OCEPA(0) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the orbital-optimized CEPA(0) level of theory. OMP2 TOTAL ENERGY¶. OMP2 CORRELATION ENE",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/glossary_psivariables-1.html:12500,energy,energy,12500,psi4manual/1.0.0/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/glossary_psivariables-1.html,12,['energy'],['energy']
Energy Efficiency,"n energy. Schemes; Transformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, 'xtpl_highest_1', which uses the best basis; set available. See sec:cbs_xtpl for all available schemes. Parameters:; scf_scheme (function) – \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || scf_xtpl_helgaker_3 || etc.; Indicates the basis set extrapolation scheme to be applied to the reference energy.; Defaults to scf_xtpl_helgaker_3() if three valid basis sets; present in scf_basis, scf_xtpl_helgaker_2() if two valid basis; sets present in scf_basis, and xtpl_highest_1() otherwise. xtpl_highest_1; scf_xtpl_helgaker_3; scf_xtpl_helgaker_2; scf_xtpl_truhlar_2; scf_xtpl_karton_2. corl_scheme (function) – \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in corl_basis and xtpl_highest_1() otherwise. xtpl_highest_1; corl_xtpl_helgaker_2. delta_scheme (function) – \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the delta correction; to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in delta_basis and xtpl_highest_1() otherwise. xtpl_highest_1; corl_xtpl_helgaker_2. delta2_scheme (function) – \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the second delta correction; to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in delta2_basis and xtpl_highest_1() otherwise. xtpl_highest_1; corl_xtpl_helgaker_2. Combined interface. Others. Parameters:molecule (molec",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.driver.cbs-1.html:8457,energy,energy,8457,psi4manual/1.3.2/api/psi4.driver.cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.driver.cbs-1.html,4,['energy'],['energy']
Energy Efficiency,"n energy. Schemes; Transformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, 'xtpl_highest_1', which uses the best basis; set available. See sec:cbs_xtpl for all available schemes. Parameters:; scf_scheme (function) – \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || scf_xtpl_helgaker_3 || etc.; Indicates the basis set extrapolation scheme to be applied to the reference energy.; Defaults to scf_xtpl_helgaker_3() if three valid basis sets; present in scf_basis, scf_xtpl_helgaker_2() if two valid basis; sets present in scf_basis, and xtpl_highest_1() otherwise. xtpl_highest_1; scf_xtpl_helgaker_3; scf_xtpl_helgaker_2; scf_xtpl_truhlar_2; scf_xtpl_karton_2. corl_scheme (function) – \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in corl_basis and xtpl_highest_1() otherwise. xtpl_highest_1; corl_xtpl_helgaker_2. delta_scheme (function) – \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the delta correction; to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in delta_basis and xtpl_highest_1() otherwise. xtpl_highest_1; corl_xtpl_helgaker_2. delta2_scheme (function) – \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the second delta correction; to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in delta2_basis and xtpl_highest_1() otherwise. xtpl_highest_1; corl_xtpl_helgaker_2. delta3_scheme (function) – \(\Rightarrow\) xtpl_highes",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/cbs-1.html:8504,energy,energy,8504,psi4manual/1.2.1/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/cbs-1.html,4,['energy'],['energy']
Energy Efficiency,"n enumerate(displacements):; # Print information to output.dat; PsiMod.print_out('\n'); banner('Loading displacement %d of %d' % (n + 1, ndisp)). # Print information to the screen; print ' %d' % (n + 1),; if (n + 1) == ndisp:; print '\n',. # Load in displacement into the active molecule (xyz coordinates only); molecule.set_geometry(displacement). # Perform the gradient calculation; func(lowername, **kwargs). # Save the gradient; G = PsiMod.get_gradient(); gradients.append(G). # clean may be necessary when changing irreps of displacements; PsiMod.clean(). PsiMod.fd_freq_1(gradients, irrep). print ' Computation complete.'; ; # Clear the ""parent"" symmetry now; PsiMod.set_parent_symmetry(""""). # TODO: These need to be restored to the user specified setting; PsiMod.get_active_molecule().fix_orientation(False); # But not this one, it always goes back to True; PsiMod.get_active_molecule().reinterpret_coordentry(True). else: # Assume energy points; # If not, perform finite difference of energies; info = 'Performing finite difference calculations by energies'; print info. # Obtain list of displacements; displacements = PsiMod.fd_geoms_freq_0(irrep); molecule.fix_orientation(True); molecule.reinterpret_coordentry(False); # Make a note of the undisplaced molecule's symmetry; PsiMod.set_parent_symmetry(molecule.schoenflies_symbol()). ndisp = len(displacements). # This version is pretty dependent on the reference geometry being last (as it is now); print ' %d displacements needed.' % ndisp; energies = []; for n, displacement in enumerate(displacements):; # Print information to output.dat; PsiMod.print_out('\n'); banner('Loading displacement %d of %d' % (n + 1, ndisp)). # Print information to the screen; print ' %d' % (n + 1),; if (n + 1) == ndisp:; print '\n',. # Load in displacement into the active molecule; molecule.set_geometry(displacement); ; # Perform the energy calculation; E = func(lowername, **kwargs). # Save the energy; energies.append(E). # clean may be necessary when c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/driver.html:46703,energy,energy,46703,psi4manual/4.0b2/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/driver.html,2,['energy'],['energy']
Energy Efficiency,"n enumerate(eigs):; for idx, x in np.ndenumerate(block):; eigs_dump += '{:29.20E}{:4d}{:4d}{:4d}{:4d}\n'.format(x, mo_idx(iorb), 0, 0, 0); iorb += 1; return eigs_dump. def _irrep_map(wfn):; """"""Returns an array of irrep indices that maps from Psi4's ordering convention to the standard FCIDUMP convention.; """"""; symm = wfn.molecule().point_group().symbol(); psi2dump = {'c1' : [1], # A; 'ci' : [1,2], # Ag Au; 'c2' : [1,2], # A B; 'cs' : [1,2], # A' A""; 'd2' : [1,4,3,2], # A B1 B2 B3; 'c2v' : [1,4,2,3], # A1 A2 B1 B2; 'c2h' : [1,4,2,3], # Ag Bg Au Bu; 'd2h' : [1,4,6,7,8,5,3,2] # Ag B1g B2g B3g Au B1u B2u B3u; }. irrep_map = psi2dump[symm]; return np.array(irrep_map, dtype='int'). [docs]def fcidump_from_file(fname):; """"""Function to read in a FCIDUMP file. :returns: a dictionary with FCIDUMP header and integrals; - 'norb' : number of basis functions; - 'nelec' : number of electrons; - 'ms2' : spin polarization of the system; - 'isym' : symmetry of state (if present in FCIDUMP); - 'orbsym' : list of symmetry labels of each orbital; - 'uhf' : whether restricted or unrestricted; - 'enuc' : nuclear repulsion plus frozen core energy; - 'epsilon' : orbital energies; - 'hcore' : core Hamiltonian; - 'eri' : electron-repulsion integrals. :param fname: FCIDUMP file name; """"""; intdump = {}; with open(fname, 'r') as handle:; assert '&FCI' == handle.readline().strip(). skiplines = 1; read = True; while True:; skiplines += 1; line = handle.readline(); if 'END' in line:; break. key, value = line.split('='); value = value.strip().rstrip(','); if key == 'UHF':; value = 'TRUE' in value; elif key == 'ORBSYM':; value = [int(x) for x in value.split(',')]; else:; value = int(value.replace(',', '')). intdump[key.lower()] = value. # Read the data and index, skip header; raw_ints = np.genfromtxt(fname, skip_header=skiplines). # Read last line, i.e. Enuc + Efzc; intdump['enuc'] = raw_ints[-1, 0]. # Read in integrals and indices; ints = raw_ints[:-1, 0]. # Get dimensions and indices; nbf = intdump['",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/p4util/fcidump.html:9755,energy,energy,9755,psi4manual/1.5.0/_modules/psi4/driver/p4util/fcidump.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/p4util/fcidump.html,2,['energy'],['energy']
Energy Efficiency,"n extensions to the MoleculeLibmints class.; Multiple classes allows separation of libmints and extension methods. """""". def __init__(self, psi4molstr=None):; """"""Initialize Molecule object from LibmintsMolecule""""""; LibmintsMolecule.__init__(self, psi4molstr). # The comment line; self.tagline = """". def __str__(self):; text = """""" ==> qcdb Molecule %s <==\n\n"""""" % (self.name()); text += """""" => %s <=\n\n"""""" % (self.tagline); text += self.create_psi4_string_from_molecule(); return text. # def __getstate__(self):; # print 'im being pickled'; # return self.__dict__. # def __setstate__(self, d):; # print 'im being unpickled with these values', d; # self.__dict__ = d. @classmethod; [docs] def init_with_xyz(cls, xyzfilename, no_com=False, no_reorient=False, contentsNotFilename=False):; """"""Pull information from an XYZ file. No fragment info detected.; Bohr/Angstrom pulled from first line if available. Charge,; multiplicity, tagline pulled from second line if available. Body; accepts atom symbol or atom charge in first column. Arguments; *no_com* and *no_reorient* can be used to turn off shift and; rotation. If *xyzfilename* is a string of the contents of an XYZ; file, rather than the name of a file, set *contentsNotFilename*; to ``True``. >>> H2O = qcdb.Molecule.init_with_xyz('h2o.xyz'). """"""; instance = cls(); instance.lock_frame = False; instance.PYmove_to_com = not no_com; instance.PYfix_orientation = no_reorient. if contentsNotFilename:; text = xyzfilename.splitlines(); else:; try:; infile = open(xyzfilename, 'r'); except IOError:; raise ValidationError(""""""Molecule::init_with_xyz: given filename '%s' does not exist."""""" % (xyzfilename)); if os.stat(xyzfilename).st_size == 0:; raise ValidationError(""""""Molecule::init_with_xyz: given filename '%s' is blank."""""" % (xyzfilename)); text = infile.readlines(). xyz1 = re.compile(r""^\s*(\d+)\s*(bohr|au)?\s*$"", re.IGNORECASE); xyz2 = re.compile(r'^\s*(-?\d+)\s+(\d+)\s+(.*)\s*$'); NUMBER = ""((?:[-+]?\\d*\\.\\d+(?:[DdEe][-+]?\\d+)?)|(?:[-+",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molecule.html:2446,charge,charge,2446,psi4manual/1.0.0/_modules/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molecule.html,1,['charge'],['charge']
Energy Efficiency,"n for the O2 molecule (triplet ground state). This performs geometry optimization using two-step and simultaneous solution of the response equations for the analytic gradient. opt2; SCF DZ allene geometry optimzation, with Cartesian input. scf11-freq-from-energies; Test frequencies by finite differences of energies for planar C4NH4 TS. opt5; 6-31G** UHF CH2 3B1 optimization. cc23; ROHF-EOM-CCSD/DZ analytic gradient lowest state of H2O+ (A1 excitation). cc26; Single-point gradient, analytic and via finite-differences of 2-1A1 state of H2O with EOM-CCSD. fci-tdm; He2+ FCI/cc-pVDZ Transition Dipole Moment. rasci-c2-active; 6-31G* C2 Test RASCI Energy Point, testing two different ways of specifying the active space, either with the ACTIVE keyword, or with RAS1, RAS2, RESTRICTED_DOCC, and RESTRICTED_UOCC. docs_dft; This test is used to construct the documentation; it is not suitable for emulation by users. tu2-ch2-energy; Sample UHF/6-31G** CH2 computation. cc16; UHF-B-CCD(T)/cc-pVDZ CH2 single-point energy (fzc, MO-basis ). sapt4; SAPT2+(3) aug-cc-pVDZ computation of the formamide dimer interaction energy, using the aug-cc-pVDZ-JKFIT DF basis for SCF and aug-cc-pVDZ-RI for SAPT. This example uses frozen core as well as MP2 natural orbital approximations. cc47; EOM-CCSD/cc-pVDZ on H2O2 with two excited states in each irrep. scf3; are specified explicitly. cc52; CCSD Response for H2O2. cc50; EOM-CC3(ROHF) on CH radical with user-specified basis and properties for particular root. cc12; Single point energies of multiple excited states with EOM-CCSD. cisd-sp; 6-31G** H2O Test CISD Energy Point. mrcc4; CCSDT cc-pVDZ optimization and frequencies for the H2O molecule using MRCC. props1; RHF STO-3G dipole moment computation, performed by applying a finite electric field and numerical differentiation. cc42; RHF-CC2-LR/STO-3G optical rotation of (S)-methyloxirane. gauge = length, omega = (589 355 nm). fci-dipole; 6-31G H2O Test FCI Energy Point. docs_psimod; This test is used to c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodoc_testsuite-1.html:8331,energy,energy,8331,psi4manual/4.0b2/autodoc_testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodoc_testsuite-1.html,4,['energy'],['energy']
Energy Efficiency,"n in Cfour. cubeprop-esp; RHF orbitals and density for water. cc49; EOM-CC3(UHF) on CH radical with user-specified basis and properties for particular root. opt-multi-dimer-c1; Multi-fragment opt of C2h methane dimer with user-combined reference points. pywrap-checkrun-uhf; This checks that all energy methods can run with a minimal input and set symmetry. cc13c; Tests RHF CCSD(T)gradients. mom; Maximum Overlap Method (MOM) Test. MOM is designed to stabilize SCF convergence and to target excited Slater determinants directly. zaptn-nh2; ZAPT(n)/6-31G NH2 Energy Point, with n=2-25. omp2-grad1; OMP2 cc-pVDZ gradient for the H2O molecule. pywrap-checkrun-convcrit; Advanced python example sets different sets of scf/post-scf conv crit and check to be sure computation has actually converged to the expected accuracy. dfrasscf-sp; 6-31G** H2O Test RASSCF Energy Point will default to only singles and doubles in the active space. ao-casscf-sp; CASSCF/6-31G** energy point. tu2-ch2-energy; Sample UHF/6-31G** CH2 computation. opt13; B3LYP cc-pVDZ geometry optimzation of phenylacetylene, starting from not quite linear structure. dft-b3lyp; Check flavors of B3LYP (b3lyp3/b3lyp5) against other programs. dfomp2-grad1; DF-OMP2 cc-pVDZ gradients for the H2O molecule. psimrcc-fd-freq1; Mk-MRCCSD single point. \(^3 \Sigma ^-\) O2 state described using the Ms = 0 component of the triplet. Uses ROHF triplet orbitals. cbs-xtpl-energy; Extrapolated water energies. soscf1; Second-order SCF convergnece: Benzene. mints6; Patch of a glycine with a methyl group, to make alanine, then DF-SCF energy calculation with the cc-pVDZ basis set. isapt2; This is a shorter version if isapt1 - does not do cube plots. See isapt1 for full details. casscf-sa-sp; Example of state-averaged CASSCF for the C2 molecule see C. D. Sherrill and P. Piecuch, J. Chem. Phys. 122, 124104 (2005). cbs-xtpl-wrapper; RHF aug-cc-pVQZ energy for the BH molecule, with Cartesian input. Various gradients for a strained helium dimer a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/testsuite-1.html:12480,energy,energy,12480,psi4manual/1.1.0/testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/testsuite-1.html,4,['energy'],['energy']
Energy Efficiency,"n in; Psi4, the SCF computations should also be performed with density-fitted; (DF) integrals.; set globals {; basis aug-cc-pvdz; df_basis_scf aug-cc-pvdz-jkfit; df_basis_sapt aug-cc-pvdz-ri; guess sad; scf_type df; }. set sapt {; print 1; }. These options will perform the SAPT computation with DF-HF and a; superposition-of-atomic-densities guess. This is the preferred method of; running the SAPT module. SAPT0¶; Generally speaking, SAPT0 should be applied to large systems or large data; sets. The performance of SAPT0 relies entirely on error cancellation, which; seems to be optimal with a truncated aug-cc-pVDZ basis, namely,; jun-cc-pVDZ (which we have referred to in previous work as; aug-cc-pVDZ’). We do not recommend using SAPT0 with large basis sets; like aug-cc-pVTZ. A systematic study of the accuracy of SAPT0 and other SAPT; truncations, using different basis sets, is reported in; [Parker:2014:094106]. In particular, an empirical recipe for scaled SAPT0; can yield improved performance and has been included in the output file as; the sSAPT0 interaction energy. sSAPT0 is a free by-product and is automatically; computed when SAPT0 is requested (see above for more details).; The SAPT module has been used to perform SAPT0 computations with over; 200 atoms and 2800 basis functions; this code should be scalable to 4000; basis functions. Publications resulting from the use of the SAPT0 code; should cite the following publications: [Hohenstein:2010:184111] and; [Hohenstein:2011:174107]. Basic SAPT0 Keywords¶. SAPT_LEVEL¶. The level of theory for SAPT. Type: string; Possible Values: SAPT0, SAPT2, SAPT2+, SAPT2+3; Default: SAPT0. BASIS¶. Primary basis set, describes the monomer molecular orbitals. Type: string; Possible Values: basis string; Default: No Default. DF_BASIS_SAPT¶. Auxiliary basis set for SAPT density fitting computations. Defaults to a RI basis. Type: string; Possible Values: basis string; Default: No Default. DF_BASIS_ELST¶. Auxiliary basis set for SAPT Els",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/sapt-1.html:7934,energy,energy,7934,psi4manual/1.0.0/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/sapt-1.html,2,['energy'],['energy']
Energy Efficiency,"n interaction (CI) computations of various types, including restricted-active-space (RAS) CI, full CI, the CI component of multi-configuration self-consistent-field (MCSCF) and complete-active-space self-consistent-field (CASSCF) computations, and arbitrary-order perturbation theory and arbitrary-order coupled-cluster computations for small molecules. General Options¶. AVG_STATES¶. Array giving the root numbers of the states to average in a state-averaged procedure such as SA-CASSCF. Root numbering starts from 1. Type: array; Default: No Default. AVG_WEIGHTS¶. Array giving the weights for each state in a state-averaged procedure. Type: array; Default: No Default. CIBLKS_PRINT¶. Do print a summary of the CI blocks?. Type: boolean; Default: false. CI_NUM_THREADS¶. Number of threads for DETCI. Type: integer; Default: 1. DETCI_FREEZE_CORE¶. Do freeze core orbitals?. Type: boolean; Default: true. EX_LEVEL¶. The CI excitation level. Type: integer; Default: 2. E_CONVERGENCE¶. Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. FCI¶. Do a full CI (FCI)? If TRUE, overrides the value of EX_LEVEL. Type: boolean; Default: false. ICORE¶. Specifies how to handle buffering of CI vectors. A value of 0 makes the program perform I/O one RAS subblock at a time; 1 uses entire CI vectors at a time; and 2 uses one irrep block at a time. Values of 0 or 2 cause some inefficiency in the I/O (requiring multiple reads of the C vector when constructing H in the iterative subspace if DIAG_METHOD = SEM), but require less core memory. Type: integer; Default: 1. ISTOP¶. Do stop DETCI after string information is formed and before integrals are read?. Type: boolean; Default: false. MAXITER¶. Maximum number of iterations to diagonalize the Hamiltonian. Type: integer; Default: 12. NUM_DETS_PRINT¶. Number of important determinants to print. Type: integer; Default: 20. NUM_ROOTS¶. number of C",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodir_options_c/module__detci-1.html:1196,energy,energy,1196,psi4manual/4.0b5/autodir_options_c/module__detci-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/module__detci-1.html,4,['energy'],['energy']
Energy Efficiency,"n interaction (CI) computations of various types, including restricted-active-space (RAS) CI, full CI, the CI component of multi-configuration self-consistent-field (MCSCF) and complete-active-space self-consistent-field (CASSCF) computations, and arbitrary-order perturbation theory and arbitrary-order coupled-cluster computations for small molecules. General Options¶. AVG_STATES¶. Array giving the root numbers of the states to average in a state-averaged procedure such as SA-CASSCF. Root numbering starts from 1. Type: array; Default: No Default. AVG_WEIGHTS¶. Array giving the weights for each state in a state-averaged procedure. Type: array; Default: No Default. CIBLKS_PRINT¶. Do print a summary of the CI blocks?. Type: boolean; Default: false. CI_NUM_THREADS¶. Number of threads for DETCI. Type: integer; Default: 1. DETCI_FREEZE_CORE¶. Do freeze core orbitals?. Type: boolean; Default: true. EX_LEVEL¶. The CI excitation level. Type: integer; Default: 2. E_CONVERGENCE¶. Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-8. FCI¶. Do a full CI (FCI)? If TRUE, overrides the value of EX_LEVEL. Type: boolean; Default: false. ICORE¶. Specifies how to handle buffering of CI vectors. A value of 0 makes the program perform I/O one RAS subblock at a time; 1 uses entire CI vectors at a time; and 2 uses one irrep block at a time. Values of 0 or 2 cause some inefficiency in the I/O (requiring multiple reads of the C vector when constructing H in the iterative subspace if DIAG_METHOD = SEM), but require less core memory. Type: integer; Default: 1. ISTOP¶. Do stop DETCI after string information is formed and before integrals are read?. Type: boolean; Default: false. MAXITER¶. Maximum number of iterations to diagonalize the Hamiltonian. Type: integer; Default: 12. NUM_DETS_PRINT¶. Number of important determinants to print. Type: integer; Default: 20. NUM_ROOTS¶. number of C",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodir_options_c/module__detci-1.html:1196,energy,energy,1196,psi4manual/4.0b4/autodir_options_c/module__detci-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodir_options_c/module__detci-1.html,4,['energy'],['energy']
Energy Efficiency,"n interaction (CI) computations of various types, including restricted-active-space (RAS) CI, full CI, the CI component of multi-configuration self-consistent-field (MCSCF) and complete-active-space self-consistent-field (CASSCF) computations, and arbitrary-order perturbation theory and arbitrary-order coupled-cluster computations for small molecules. General Options¶. AVG_STATES¶. Array giving the root numbers of the states to average in a state-averaged procedure such as SA-CASSCF. Root numbering starts from 1. Type: array; Default: No Default. AVG_WEIGHTS¶. Array giving the weights for each state in a state-averaged procedure. Type: array; Default: No Default. CIBLKS_PRINT¶. Do print a summary of the CI blocks?. Type: boolean; Default: false. CI_NUM_THREADS¶. Number of threads for DETCI. Type: integer; Default: 1. DETCI_FREEZE_CORE¶. Do freeze core orbitals?. Type: boolean; Default: true. EX_LEVEL¶. The CI excitation level. Type: integer; Default: 2. E_CONVERGENCE¶. Convergence criterion for energy. Type: conv double; Default: 1e-6. FCI¶. Do a full CI (FCI)? If TRUE, overrides the value of EX_LEVEL. Type: boolean; Default: false. ICORE¶. Specifies how to handle buffering of CI vectors. A value of 0 makes the program perform I/O one RAS subblock at a time; 1 uses entire CI vectors at a time; and 2 uses one irrep block at a time. Values of 0 or 2 cause some inefficiency in the I/O (requiring multiple reads of the C vector when constructing H in the iterative subspace if DIAG_METHOD = SEM), but require less core memory. Type: integer; Default: 1. ISTOP¶. Do stop DETCI after string information is formed and before integrals are read?. Type: boolean; Default: false. MAXITER¶. Maximum number of iterations to diagonalize the Hamiltonian. Type: integer; Default: 12. NUM_DETS_PRINT¶. Number of important determinants to print. Type: integer; Default: 20. NUM_ROOTS¶. number of CI roots to find. Type: integer; Default: 1. REFERENCE¶. Reference wavefunction type. Type: string",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodir_options_c/module__detci-1.html:1181,energy,energy,1181,psi4manual/4.0b2/autodir_options_c/module__detci-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodir_options_c/module__detci-1.html,8,['energy'],['energy']
Energy Efficiency,"n interaction level of; theory. CI ROOT n DIPOLE X¶. CI ROOT n DIPOLE Y¶. CI ROOT n DIPOLE Z¶; The three components of the dipole [Debye] for the requested; configuration interaction level of theory and root n. CI ROOT n QUADRUPOLE XX¶. CI ROOT n QUADRUPOLE XY¶. CI ROOT n QUADRUPOLE XZ¶. CI ROOT n QUADRUPOLE YY¶. CI ROOT n QUADRUPOLE YZ¶. CI ROOT n QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; configuration interaction level of theory and root n. CI ROOT n TOTAL ENERGY¶. CI ROOT n CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root; n (numbering starts at 0). CI STATE-AVERAGED TOTAL ENERGY¶. CI STATE-AVERAGED CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for state-averaged CI/CASSCF levels of theory. CI TOTAL ENERGY¶. CI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root. CISD DIPOLE X¶. CISD DIPOLE Y¶. CISD DIPOLE Z¶; The three components of the dipole [Debye] for the; configuration interaction singles and doubles level of theory and root. CISD QUADRUPOLE XX¶. CISD QUADRUPOLE XY¶. CISD QUADRUPOLE XZ¶. CISD QUADRUPOLE YY¶. CISD QUADRUPOLE YZ¶. CISD QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; configuration interaction singles and doubles level of theory and root. CISD TOTAL ENERGY¶. CISD CORRELATION ENERGY¶. CISDT TOTAL ENERGY¶. CISDT CORRELATION ENERGY¶. CISDTQ CORRELATION ENERGY¶. CISDTQ TOTAL ENERGY¶. CIn CORRELATION ENERGY¶. CIn TOTAL ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled configuration interaction level of theory and root.; n is CI order for n > 4. CP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [H] considering only two-body interactions,; computed with counterpoise c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/glossary_psivariables-1.html:8524,energy,energy,8524,psi4manual/1.1.0/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/glossary_psivariables-1.html,12,['energy'],['energy']
Energy Efficiency,"n interaction level of; theory. CI ROOT n DIPOLE X¶. CI ROOT n DIPOLE Y¶. CI ROOT n DIPOLE Z¶; The three components of the dipole [Debye] for the requested; configuration interaction level of theory and root n. CI ROOT n QUADRUPOLE XX¶. CI ROOT n QUADRUPOLE XY¶. CI ROOT n QUADRUPOLE XZ¶. CI ROOT n QUADRUPOLE YY¶. CI ROOT n QUADRUPOLE YZ¶. CI ROOT n QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; configuration interaction level of theory and root n. CI ROOT n TOTAL ENERGY¶. CI ROOT n CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root; n (numbering starts at 1). CI STATE-AVERAGED TOTAL ENERGY¶. CI STATE-AVERAGED CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for state-averaged CI/CASSCF levels of theory. CI TOTAL ENERGY¶. CI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root. CISD DIPOLE X¶. CISD DIPOLE Y¶. CISD DIPOLE Z¶; The three components of the dipole [Debye] for the; configuration interaction singles and doubles level of theory and root. CISD QUADRUPOLE XX¶. CISD QUADRUPOLE XY¶. CISD QUADRUPOLE XZ¶. CISD QUADRUPOLE YY¶. CISD QUADRUPOLE YZ¶. CISD QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; configuration interaction singles and doubles level of theory and root. CISD TOTAL ENERGY¶. CISD CORRELATION ENERGY¶. CISDT TOTAL ENERGY¶. CISDT CORRELATION ENERGY¶. CISDTQ CORRELATION ENERGY¶. CISDTQ TOTAL ENERGY¶. CIn CORRELATION ENERGY¶. CIn TOTAL ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled configuration interaction level of theory and root.; n is CI order for n > 4. CP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [H] considering only two-body interactions,; computed with counterpoise c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/glossary_psivariables-1.html:8016,energy,energy,8016,psi4manual/1.0.0/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/glossary_psivariables-1.html,16,['energy'],['energy']
Energy Efficiency,"n interaction level of; theory. CI ROOT n DIPOLE X¶. CI ROOT n DIPOLE Y¶. CI ROOT n DIPOLE Z¶; The three components of the dipole [Debye] for the requested; configuration interaction level of theory and root n. CI ROOT n QUADRUPOLE XX¶. CI ROOT n QUADRUPOLE XY¶. CI ROOT n QUADRUPOLE XZ¶. CI ROOT n QUADRUPOLE YY¶. CI ROOT n QUADRUPOLE YZ¶. CI ROOT n QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; configuration interaction level of theory and root n. CI ROOT n TOTAL ENERGY¶. CI ROOT n CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root; n (numbering starts at 1). CI STATE-AVERAGED TOTAL ENERGY¶. CI STATE-AVERAGED CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for state-averaged CI/CASSCF levels of theory. CI TOTAL ENERGY¶. CI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root. CISD TOTAL ENERGY¶. CISD CORRELATION ENERGY¶. CISDT TOTAL ENERGY¶. CISDT CORRELATION ENERGY¶. CISDTQ CORRELATION ENERGY¶. CISDTQ TOTAL ENERGY¶. CIn CORRELATION ENERGY¶. CIn TOTAL ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled configuration interaction level of theory and root.; n is CI order for n > 4. CP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [H] considering only two-body interactions,; computed with counterpoise correction.; Related variable UNCP-CORRECTED 2-BODY INTERACTION ENERGY. CURRENT CORRELATION ENERGY¶; The correlation energy [H] corresponding to the CURRENT ENERGY variable. CURRENT ENERGY¶; The total electronic energy [H] of the most recent stage of a; calculation (frequently overwritten). This is the quantity tracked by; the geometry optimizer. CURRENT REFERENCE ENERGY¶; The total electronic energy [H] of the reference stag",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/glossary_psivariables-1.html:3623,energy,energy,3623,psi4manual/4.0b2/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/glossary_psivariables-1.html,4,['energy'],['energy']
Energy Efficiency,"n is calculated according to [4]_:; :math:`E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}, \alpha = 3.0`. References; ----------. .. [4] Halkier, Helgaker, Jorgensen, Klopper, & Olsen, Chem. Phys. Lett. 302 (1999) 437-446,; DOI: 10.1016/S0009-2614(99)00179-7. """""". if (type(valueLO) != type(valueMD)) or (type(valueMD) != type(valueHI)):; raise ValidationError(""scf_xtpl_helgaker_3: Inputs must be of the same datatype! (%s, %s, %s)"" %; (type(valueLO), type(valueMD), type(valueHI))). if isinstance(valueLO, float):. ratio = (valueHI - valueMD) / (valueMD - valueLO); alpha = -1 * math.log(ratio); beta = (valueHI - valueMD) / (math.exp(-1 * alpha * zMD) * (ratio - 1)); value = valueHI - beta * math.exp(-1 * alpha * zHI). if verbose:; # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> Helgaker 3-point SCF extrapolation for method: %s <==\n\n"""""" % (; functionname.upper()); cbsscheme += """""" LO-zeta (%s) Energy: % 16.12f\n"""""" % (str(zLO), valueLO); cbsscheme += """""" MD-zeta (%s) Energy: % 16.12f\n"""""" % (str(zMD), valueMD); cbsscheme += """""" HI-zeta (%s) Energy: % 16.12f\n"""""" % (str(zHI), valueHI); cbsscheme += """""" Alpha (exponent) Value: % 16.12f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: % 16.12f\n\n"""""" % (beta). name_str = ""%s/(%s,%s,%s)"" % (functionname.upper(), _zeta_val2sym[zLO].upper(), _zeta_val2sym[zMD].upper(),; _zeta_val2sym[zHI].upper()); cbsscheme += """""" @Extrapolated """"""; cbsscheme += name_str + ':'; cbsscheme += "" "" * (18 - len(name_str)); cbsscheme += """"""% 16.12f\n\n"""""" % value; core.print_out(cbsscheme). return value. elif isinstance(valueLO, (core.Matrix, core.Vector)):; valueLO = np.array(valueLO); valueMD = np.array(valueMD); valueHI = np.array(valueHI). nonzero_mask = np.abs(valueHI) > 1.e-14; top = (valueHI - valueMD)[nonzero_mask]; bot = (valueMD - valueLO)[nonzero_mask]. ratio = top / bot; alpha = -1 * np.log(np.abs(ratio)); beta = top / (np.exp(-1 * alpha * zMD) * (ratio - 1)); np_value = valueHI.c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:18349,Energy,Energy,18349,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,2,['Energy'],['Energy']
Energy Efficiency,"n is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; elif ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" DLPNO-MP2 does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). if core.get_global_option('REFERENCE') != ""RHF"":; raise ValidationError(""DLPNO-MP2 is not available for %s references."",; core.get_global_option('REFERENCE')). core.tstart(); core.print_out('\n'); p4util.banner('DLPNO-MP2'); core.print_out('\n'). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DLPNO"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dlpnomp2_wfn = core.dlpno(ref_wfn); dlpnomp2_wfn.compute_energy(). if name == 'scs-dlpno-mp2':; dlpnomp2_wfn.set_variable('CURRENT ENERGY', dlpnomp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dlpnomp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dlpnomp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')). elif name == 'dlpno-mp2':; dlpnomp2_wfn.set_variable('CURRENT ENERGY', dlpnomp2_wfn.variable('MP2 TOTAL ENERGY')); dlpnomp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dlpnomp2_wfn.variable('MP2 CORRELATION ENERGY')). # Shove variables into global space; for k, v in dlpnomp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dlpnomp2_wfn. def run_dmrgscf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an DMRG calculation. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE'],; ['DMRG', 'DMRG_CASPT2_CALC']). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). if 'CASPT2' in name.upper():; core.set_local_option(""DMRG"", ""DMRG_CASPT",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/procrouting/proc.html:132034,ENERGY,ENERGY,132034,psi4manual/1.5.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/procrouting/proc.html,6,['ENERGY'],['ENERGY']
Energy Efficiency,"n kwargs:; BSTR, ZETR = _expand_bracketed_basis(kwargs['scf_basis'].lower(), molecule=molstr); elif do_corl:; BSTR = BSTC[:]; ZETR = ZETC[:]; else:; raise ValidationError(""""""SCF basis sets through keyword '%s' are required. Or perhaps you forgot the '%s'."""""" % ('scf_basis', 'corl_wfn')). # Establish list of valid basis sets for delta correction energy; if do_delta:; if 'delta_basis' in kwargs:; BSTD, ZETD = _expand_bracketed_basis(kwargs['delta_basis'].lower(), molecule=molstr); else:; raise ValidationError(""""""DELTA basis sets through keyword '%s' are required."""""" % ('delta_basis')). # Establish list of valid basis sets for second delta correction energy; if do_delta2:; if 'delta2_basis' in kwargs:; BSTD2, ZETD2 = _expand_bracketed_basis(kwargs['delta2_basis'].lower(), molecule=molstr); else:; raise ValidationError(""""""DELTA2 basis sets through keyword '%s' are required."""""" % ('delta2_basis')). # # Establish list of valid basis sets for third delta correction energy; # if do_delta3:; # if 'delta3_basis' in kwargs:; # BSTD3, ZETD3 = validate_bracketed_basis(kwargs['delta3_basis'].lower()); # else:; # raise ValidationError('DELTA3 basis sets through keyword \'%s\' are required.' % ('delta3_basis')); #; # # Establish list of valid basis sets for fourth delta correction energy; # if do_delta4:; # if 'delta4_basis' in kwargs:; # BSTD4, ZETD4 = validate_bracketed_basis(kwargs['delta4_basis'].lower()); # else:; # raise ValidationError('DELTA4 basis sets through keyword \'%s\' are required.' % ('delta4_basis')); #; # # Establish list of valid basis sets for fifth delta correction energy; # if do_delta5:; # if 'delta5_basis' in kwargs:; # BSTD5, ZETD5 = validate_bracketed_basis(kwargs['delta5_basis'].lower()); # else:; # raise ValidationError('DELTA5 basis sets through keyword \'%s\' are required.' % ('delta5_basis')). # Establish treatment for scf energy (validity check useless since python will catch it long before here); if (len(BSTR) == 3) and ('scf_basis' in kwargs):; cbs",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:37187,energy,energy,37187,psi4manual/1.0.0/_modules/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html,3,['energy'],['energy']
Energy Efficiency,"n may be made even more; efficient by means of the Density-Fitting (DF) approximation (also known as; Resolution-of-the-Identity or RI), wherein the quadratic products in the; bra- and ket- of the -type Electron Repulsion Integrals (ERIs); appearing in MP2 are cast onto a linear-scaling auxiliary basis by least-squares; fitting. Substitution of the DF factorization into the MP2 equations results in; a formal scaling and prefactor reduction of MP2, and further speed gains are; possible due to heavy utilization of matrix-multiplication kernels and minimal; storage requirements in a DF approach. The method has been found to be quite; robust and accurate, and it should be preferred unless extreme accuracy is required; or a fitting basis is not defined for the primary basis and atom type; encountered. In particular, we have found excellent efficiency and tractability; gains when using DF-MP2 in concert with a DF-SCF reference. An efficient,; threaded, disk-based DF-MP2 code is available in PSI4 for all single; reference types available in the SCF module.; An example utilization of the code is:; molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; }. set basis cc-pvdz; set scf_type df; set freeze_core True. energy('df-mp2'). The energy('df-mp2') call to energy() executes; the predefined DF-MP2 procedure, first calling; the SCF module with a default RHF reference and DF algorithm for the; two-electron integrals. When the orbitals are converged, the DF-MP2 module is; launched, which forms the density-fitted integrals and then builds the; full tensor in blocks, evaluating the contributions to the MP2 energy; as it goes. A RHF-MP2 wavefunction is selected automatically due to the RHF; reference. In this example, we freeze the core, both for efficiency and; because split-valence bases like cc-pVDZ do not contain core correlation; functions. The result looks something like:; ----------------------------------------------------------; ====================> MP2 Energies <===========",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/dfmp2-1.html:1558,efficient,efficient,1558,psi4manual/4.0b2/dfmp2-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/dfmp2-1.html,8,['efficient'],['efficient']
Energy Efficiency,"n may be made even more; efficient by means of the Density-Fitting (DF) approximation (also known as; Resolution-of-the-Identity or RI), wherein the quadratic products in the; bra- and ket- of the -type Electron Repulsion Integrals (ERIs); appearing in MP2 are cast onto a linear-scaling auxiliary basis by least-squares; fitting. Substitution of the DF factorization into the MP2 equations results in; a formal scaling and prefactor reduction of MP2, and further speed gains are; possible due to heavy utilization of matrix-multiplication kernels and minimal; storage requirements in a DF approach. The method has been found to be quite; robust and accurate, and it should be preferred unless extreme accuracy is required; or a fitting basis is not defined for the primary basis and atom type; encountered. In particular, we have found excellent efficiency and tractability; gains when using DF-MP2 in concert with a DF-SCF reference. An efficient,; threaded, disk-based DF-MP2 code is available in Psi4 for all single; reference types available in the SCF module.; MP2 defaults in Psi4 to the density-fitted code. See; MP2_TYPE for performing a MP2 with conventional integrals.; An example utilization of the code is:; molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; }. set basis cc-pvdz; set scf_type df; set freeze_core True. energy('mp2'). The energy('mp2') call to energy() executes; the predefined DF-MP2 procedure, first calling; the SCF module with a default RHF reference and DF algorithm for the; two-electron integrals. When the orbitals are converged, the DF-MP2 module is; launched, which forms the density-fitted integrals and then builds the; full tensor in blocks, evaluating the contributions to the MP2 energy; as it goes. A RHF-MP2 wavefunction is selected automatically due to the RHF; reference. In this example, we freeze the core, both for efficiency and; because split-valence bases like cc-pVDZ do not contain core correlation; functions. The result looks something like:;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/dfmp2-1.html:1596,efficient,efficient,1596,psi4manual/1.0.0/dfmp2-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/dfmp2-1.html,2,['efficient'],['efficient']
Energy Efficiency,"n module qcdb.Molecule). (psi4.core.Molecule method). run_gcp() (in module qcdb.Molecule). (psi4.core.Molecule method). RUN_MP2 (FNOCC). RUN_MP3 (FNOCC). RUN_MP4 (FNOCC). S. S (DETCI). s (psi4.core.AOShellCombinationsIterator attribute). S() (psi4.core.Wavefunction method). s6() (psi4.core.Dispersion method). s8() (psi4.core.Dispersion method). S_CHOLESKY_TOLERANCE (SCF). S_CUT (DLPNO). S_ORTHOGONALIZATION (SCF). S_TOLERANCE (SCF). sad_ (psi4.core.HF attribute). SAD_CHOL_TOLERANCE (SCF). SAD_D_CONVERGENCE (SCF). SAD_E_CONVERGENCE (SCF). SAD_FRAC_OCC (SCF). SAD_MAXITER (SCF). SAD_PRINT (SCF). SAD_SCF_TYPE (SCF). SAD_SPIN_AVERAGE (SCF). SADGuess (class in psi4.core). salc_name() (psi4.core.CdSalcList method). SalcComponent (class in psi4.core). same_a_b_dens() (psi4.core.Wavefunction method). same_a_b_orbs() (psi4.core.Wavefunction method). sanitize_method() (in module psi4.driver). (in module psi4.driver.p4util). sanitize_name() (in module psi4.driver). SAPGAU_BASIS (SCF). SAPT. charge-transfer. higher-order. output. SAPT(DFT). SAPT0. theory. SAPT (SCF). SAPT ALPHA. SAPT CT ENERGY. SAPT DISP ENERGY. SAPT DISP2(CCD) ENERGY. SAPT DISP20 ENERGY. SAPT DISP21 ENERGY. SAPT DISP22(S)(CCD) ENERGY. SAPT DISP22(SDQ) ENERGY. SAPT DISP22(T) ENERGY. SAPT DISP22(T)(CCD) ENERGY. SAPT DISP30 ENERGY. SAPT ELST ENERGY. SAPT ELST EXTERN-EXTERN ENERGY. SAPT ELST10,R ENERGY. SAPT ELST12,R ENERGY. SAPT ELST13,R ENERGY. SAPT ENERGY. SAPT EST.DISP22(T) ENERGY. SAPT EST.DISP22(T)(CCD) ENERGY. SAPT EXCH ENERGY. SAPT EXCH-DISP20 ENERGY. SAPT EXCH-DISP20(S^INF) ENERGY. SAPT EXCH-DISP30 ENERGY. SAPT EXCH-IND-DISP30 ENERGY. SAPT EXCH-IND20,R ENERGY. SAPT EXCH-IND20,U ENERGY. SAPT EXCH-IND22 ENERGY. SAPT EXCH-IND30(S^INF) ENERGY. SAPT EXCH-IND30,R ENERGY. SAPT EXCH-IND30,R(S^INF) ENERGY. SAPT EXCH10 ENERGY. SAPT EXCH10(S^2) ENERGY. SAPT EXCH11(S^2) ENERGY. SAPT EXCH12(S^2) ENERGY. SAPT HF TOTAL ENERGY. SAPT HF(2) ENERGY A(0). SAPT HF(2) ENERGY A(HF). SAPT HF(2) ENERGY AB(HF). SAPT HF(2) ENERGY ABC(",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/genindex.html:101939,charge,charge-transfer,101939,psi4manual/1.9.x/genindex.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/genindex.html,2,['charge'],['charge-transfer']
Energy Efficiency,"n module. psi4.optimize(name[, molecule, return_wfn, func, mode, dertype, hessian_with])[source]¶; Function to perform a geometry optimization. Aliases:opt(). Returns:float – Total electronic energy of optimized structure in Hartrees. Returns:(float, Wavefunction) – energy and wavefunction when return_wfn specified. Raises:psi4.ConvergenceError if GEOM_MAXITER exceeded without reaching geometry convergence. PSI variables:. CURRENT ENERGY. Parameters:; name (string) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. For maximum; flexibility, return_wfn is always on in 'reap' mode. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (string) – 'scf' || 'mp2' || etc.; Indicates the comp",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/opt-1.html:1679,energy,energy,1679,psi4manual/1.1.0/opt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/opt-1.html,2,['energy'],['energy']
Energy Efficiency,"n must come before the ZMatrix entries because the former define absolute positions, while the latter are relative. tu4-h2o-freq; Optimization followed by frequencies H2O HF/cc-pVDZ. mp2p5-grad1; MP2.5 cc-pVDZ gradient for the H2O molecule. dfmp2-grad3; DF-MP2 cc-pVDZ gradients for the H2O molecule. dfomp2p5-1; DF-OMP2.5 cc-pVDZ energy for the H2O molecule. omp3-3; OMP3 cc-pVDZ energy with B3LYP initial guess for the NO radical. dfomp3-2; DF-OMP3 cc-pVDZ energy for the H2O+ cation. pubchem1; Benzene vertical singlet-triplet energy difference computation, using the PubChem database to obtain the initial geometry, which is optimized at the HF/STO-3G level, before computing single point energies at the RHF, UHF and ROHF levels of theory. opt2; SCF DZ allene geometry optimization, with Cartesian input, first in c2v symmetry, then in Cs symmetry from a starting point with a non-linear central bond angle. dfomp2-3; OMP2 cc-pVDZ energy for the H2O molecule. omp3-2; OMP3 cc-pVDZ energy with ROHF initial guess for the NO radical. ocepa3; OCEPA cc-pVDZ energy with ROHF initial guess for the NO radical. cisd-h2o+-1; 6-31G** H2O+ Test CISD Energy Point. mcscf1; ROHF 6-31G** energy of the \(^{3}B_1\) state of CH2, with Z-matrix input. The occupations are specified explicitly. dfomp2p5-grad2; DF-OMP2.5 cc-pVDZ gradients for the H2O+ cation. props3; DF-SCF cc-pVDZ multipole moments of benzene, up to 7th order and electrostatic potentials evaluated at the nuclear coordinates. scf11-freq-from-energies; Test frequencies by finite differences of energies for planar C4NH4 TS. stability1; UHF->UHF stability analysis test for BH with cc-pVDZ Test direct SCF with and without symmetry, test PK without symmetry. cc29; CCSD/cc-pVDZ optical rotation calculation (both gauges) on Cartesian H2O2. ci-property; CI/MCSCF cc-pvDZ properties for Potassium nitrate (rocket fuel!). cc37; CC2(UHF)/cc-pVDZ energy of H2O+. sapt8; SAPT0(ROHF) open-shell computation of CN - Ne interaction energy First with j",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/testsuite-1.html:19516,energy,energy,19516,psi4manual/1.1.0/testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/testsuite-1.html,4,['energy'],['energy']
Energy Efficiency,"n natural orbitals. fno-cepa(3); cepa(3) with frozen natural orbitals. fno-acpf; acpf with frozen natural orbitals. fno-aqcc; aqcc with frozen natural orbitals. fno-sdci; sdci with frozen natural orbitals. fno-dci; dci with frozen natural orbitals. df-ccsd; ccsd with density fitting. df-ccsd(t); ccsd(t) with density fitting. fno-df-ccsd; ccsd with density fitting and frozen natural orbitals. fno-df-ccsd(t); ccsd(t) with density fitting and frozen natural orbitals. Basic FNOCC Keywords¶. BASIS¶. Primary basis set. Type: string; Possible Values: basis string; Default: No Default. FREEZE_CORE¶. Specifies how many core orbitals to freeze in correlated computations. TRUE will default to freezing the standard default number of core orbitals. For PSI, the standard number of core orbitals is the number of orbitals in the nearest previous noble gas atom. More precise control over the number of frozen orbitals can be attained by using the keywords NUM_FROZEN_DOCC (gives the total number of orbitals to freeze, program picks the lowest-energy orbitals) or FROZEN_DOCC (gives the number of orbitals to freeze per irreducible representation). Type: string; Possible Values: FALSE, TRUE; Default: FALSE. R_CONVERGENCE¶. Convergence for the CC amplitudes. Note that convergence is met only when E_CONVERGENCE and R_CONVERGENCE are satisfied. Type: conv double; Default: 1.0e-7. E_CONVERGENCE¶. Convergence criterion for CC energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Note that convergence is met only when E_CONVERGENCE and R_CONVERGENCE are satisfied. Type: conv double; Default: 1.0e-6. MAXITER¶. Maximum number of CC iterations. Type: integer; Default: 100. DIIS_MAX_VECS¶. Desired number of DIIS vectors. Type: integer; Default: 8. NAT_ORBS¶. Do use MP2 NOs to truncate virtual space for QCISD/CCSD and (T)?. Type: boolean; Default: false. OCC_TOLERANCE¶. Cutoff for occupation of MP2 NO orbitals in FNO-QCISD/CCSD(T) ( only valid if NA",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/fnocc-1.html:12568,energy,energy,12568,psi4manual/4.0b5/fnocc-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/fnocc-1.html,2,['energy'],['energy']
Energy Efficiency,"n natural orbitals. fno-cepa(3); cepa(3) with frozen natural orbitals. fno-acpf; acpf with frozen natural orbitals. fno-aqcc; aqcc with frozen natural orbitals. fno-sdci; sdci with frozen natural orbitals. fno-dci; dci with frozen natural orbitals. df-ccsd; ccsd with density fitting. df-ccsd(t); ccsd(t) with density fitting. fno-df-ccsd; ccsd with density fitting and frozen natural orbitals. fno-df-ccsd(t); ccsd(t) with density fitting and frozen natural orbitals. Basic FNOCC Keywords¶. BASIS¶. Primary basis set. Type: string; Possible Values: basis string; Default: No Default. FREEZE_CORE¶. Specifies how many core orbitals to freeze in correlated computations. TRUE will default to freezing the standard default number of core orbitals. For PSI, the standard number of core orbitals is the number of orbitals in the nearest previous noble gas atom. More precise control over the number of frozen orbitals can be attained by using the keywords NUM_FROZEN_DOCC (gives the total number of orbitals to freeze, program picks the lowest-energy orbitals) or FROZEN_DOCC (gives the number of orbitals to freeze per irreducible representation). Type: string; Possible Values: FALSE, TRUE; Default: FALSE. R_CONVERGENCE¶. Convergence for the CC amplitudes. Note that convergence is met only when E_CONVERGENCE and R_CONVERGENCE are satisfied. Type: conv double; Default: 1.0e-7. E_CONVERGENCE¶. Convergence criterion for CC energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Note that convergence is met only when E_CONVERGENCE and R_CONVERGENCE are satisfied. Type: conv double; Default: 1.0e-8. MAXITER¶. Maximum number of CC iterations. Type: integer; Default: 100. DIIS_MAX_VECS¶. Desired number of DIIS vectors. Type: integer; Default: 8. NAT_ORBS¶. Do use MP2 NOs to truncate virtual space for QCISD/CCSD and (T)?. Type: boolean; Default: false. OCC_TOLERANCE¶. Cutoff for occupation of MP2 NO orbitals in FNO-QCISD/CCSD(T) ( only valid if NA",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/fnocc-1.html:12057,energy,energy,12057,psi4manual/4.0b4/fnocc-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/fnocc-1.html,2,['energy'],['energy']
Energy Efficiency,"n nbody_range}. cp_ptype_body_dict = {n: np.zeros(arr_shape) for n in nbody_range}; nocp_ptype_body_dict = {n: np.zeros(arr_shape) for n in nbody_range}; vmfc_ptype_body_dict = {n: np.zeros(arr_shape) for n in nbody_range}; else:; cp_ptype_by_level, cp_ptype_body_dict = None, None; nocp_ptype_by_level, nocp_ptype_body_dict = None, None; vmfc_ptype_body_dict = None. # Sum up all of the levels; for n in nbody_range:. # Energy; cp_energy_by_level[n] = sum(energies_dict[v] for v in cp_compute_list[n]); nocp_energy_by_level[n] = sum(energies_dict[v] for v in nocp_compute_list[n]). # Special vmfc case; if n > 1:; vmfc_energy_body_dict[n] = vmfc_energy_body_dict[n - 1]; for tup in vmfc_level_list[n]:; vmfc_energy_body_dict[n] += ((-1) ** (n - len(tup[0]))) * energies_dict[tup]. # Do ptype; if ptype != 'energy':; _sum_cluster_ptype_data(ptype, ptype_dict, cp_compute_list[n],; fragment_slice_dict, fragment_size_dict,; cp_ptype_by_level[n]); _sum_cluster_ptype_data(ptype, ptype_dict, nocp_compute_list[n],; fragment_slice_dict, fragment_size_dict,; nocp_ptype_by_level[n]); _sum_cluster_ptype_data(ptype, ptype_dict, vmfc_level_list[n],; fragment_slice_dict, fragment_size_dict,; vmfc_ptype_by_level[n], vmfc=True). # Compute cp energy and ptype; if do_cp:; for n in nbody_range:; if n == max_frag:; cp_energy_body_dict[n] = cp_energy_by_level[n]; if ptype != 'energy':; cp_ptype_body_dict[n][:] = cp_ptype_by_level[n]; continue. for k in range(1, n + 1):; take_nk = nCr(max_frag - k - 1, n - k); sign = ((-1) ** (n - k)); value = cp_energy_by_level[k]; cp_energy_body_dict[n] += take_nk * sign * value. if ptype != 'energy':; value = cp_ptype_by_level[k]; cp_ptype_body_dict[n] += take_nk * sign * value. _print_nbody_energy(cp_energy_body_dict, ""Counterpoise Corrected (CP)""); cp_interaction_energy = cp_energy_body_dict[max_nbody] - cp_energy_body_dict[1]; core.set_variable('Counterpoise Corrected Total Energy', cp_energy_body_dict[max_nbody]); core.set_variable('Counterpoise Corrected Inte",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver_nbody.html:11852,energy,energy,11852,psi4manual/1.1.0/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver_nbody.html,1,['energy'],['energy']
Energy Efficiency,"n nbody_range}. cp_ptype_body_dict = {n: np.zeros(arr_shape) for n in nbody_range}; nocp_ptype_body_dict = {n: np.zeros(arr_shape) for n in nbody_range}; vmfc_ptype_body_dict = {n: np.zeros(arr_shape) for n in nbody_range}; else:; cp_ptype_by_level, cp_ptype_body_dict = None, None; nocp_ptype_by_level, nocp_ptype_body_dict = None, None; vmfc_ptype_body_dict = None. # Sum up all of the levels; for n in nbody_range:. # Energy; cp_energy_by_level[n] = sum(energies_dict[v] for v in cp_compute_list[n]); nocp_energy_by_level[n] = sum(energies_dict[v] for v in nocp_compute_list[n]). # Special vmfc case; if n > 1:; vmfc_energy_body_dict[n] = vmfc_energy_body_dict[n - 1]; for tup in vmfc_level_list[n]:; vmfc_energy_body_dict[n] += ((-1) ** (n - len(tup[0]))) * energies_dict[tup]. # Do ptype; if ptype != 'energy':; _sum_cluster_ptype_data(ptype, ptype_dict, cp_compute_list[n],; fragment_slice_dict, fragment_size_dict,; cp_ptype_by_level[n]); _sum_cluster_ptype_data(ptype, ptype_dict, nocp_compute_list[n],; fragment_slice_dict, fragment_size_dict,; nocp_ptype_by_level[n]); _sum_cluster_ptype_data(ptype, ptype_dict, vmfc_level_list[n],; fragment_slice_dict, fragment_size_dict,; vmfc_ptype_by_level[n], vmfc=True). # Compute cp energy and ptype; if do_cp:; for n in nbody_range:; if n == max_frag:; cp_energy_body_dict[n] = cp_energy_by_level[n]; if ptype != 'energy':; cp_ptype_body_dict[n][:] = cp_ptype_by_level[n]; continue. for k in range(1, n + 1):; take_nk = nCr(max_frag - k - 1, n - k); sign = ((-1) ** (n - k)); value = cp_energy_by_level[k]; cp_energy_body_dict[n] += take_nk * sign * value. if ptype != 'energy':; value = cp_ptype_by_level[k]; cp_ptype_body_dict[n] += take_nk * sign * value. _print_nbody_energy(cp_energy_body_dict, ""Counterpoise Corrected (CP)""); cp_interaction_energy = cp_energy_body_dict[max_nbody] - cp_energy_body_dict[1]; psi4.set_variable('Counterpoise Corrected Total Energy', cp_energy_body_dict[max_nbody]); psi4.set_variable('Counterpoise Corrected Inte",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver_nbody.html:11789,energy,energy,11789,psi4manual/1.0.0/_modules/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_nbody.html,1,['energy'],['energy']
Energy Efficiency,"n not reading a previous guess; frac_start = kwargs.get('frac_start', 25). # By default, we occupy by tenths of electrons; foccs = kwargs.get('foccs', [1.0, 0.9, 0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2, 0.1, 0.0]). # By default, HOMO and LUMO are both in alpha; N = 0;; for A in range(molecule.natom()):; N += molecule.Z(A); N -= charge0; N = int(N); Nb = int((N - mult0 + 1) / 2); Na = int(N - Nb). charge = charge0; mult = mult0. # By default, nuke all the electrons; Nmin = 0;; if ('nmax' in kwargs):; Nmin = N - int(kwargs['nmax']). # By default, DIIS in FRAC (1.0 occupation is always DIIS'd); frac_diis = kwargs.get('frac_diis', True). # By default, drop the files to the molecule's name; root = kwargs.get('filename', molecule.name()); traverse_filename = root + '.traverse.dat'; stats_filename = root + '.stats.dat'. # => Traverse <= #; psi4.set_global_option(""DF_INTS_IO"", ""SAVE""). Ns = []; energies = []; potentials = []; convs = []; stats = []. # Run one SCF to burn things in; E, wfn= energy('scf', return_wfn=True, molecule=molecule, **kwargs). # Determine HOMO; eps_a = wfn.epsilon_a(); eps_b = wfn.epsilon_b(); if Na == Nb:; HOMO = -Nb; elif Nb == 0:; HOMO = Na; else:; E_a = eps_a[int(Na - 1)]; E_b = eps_b[int(Nb - 1)]; if E_a >= E_b:; HOMO = Na; else:; HOMO = -Nb. stats.append(""""""\t%6d %6d %6d %6d %6d %6d\n"""""" % (N, Na, Nb, charge, mult, HOMO)). if HOMO > 0:; Na = Na - 1; else:; Nb = Nb - 1; charge = charge + 1; mult = Na - Nb + 1. psi4.set_global_option(""DF_INTS_IO"", ""LOAD""); psi4.set_global_option(""FRAC_START"", frac_start); psi4.set_global_option(""FRAC_RENORMALIZE"", True). # Nuke 'em Rico!; for Nintegral in range(N, Nmin, -1):. # Nuke the current HOMO; for occ in foccs:. psi4.set_global_option(""FRAC_OCC"", [HOMO]); psi4.set_global_option(""FRAC_VAL"", [occ]). E, wfn = energy('scf', return_wfn=True, molecule=molecule, **kwargs); C = 1; if E == 0.0:; E = psi4.get_variable('SCF ITERATION ENERGY'); C = 0. if HOMO > 0:; eps = wfn.epsilon_a(); potentials.append(eps[HOMO - 1]); els",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/frac.html:8396,energy,energy,8396,psi4manual/1.0.0/_modules/frac.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/frac.html,1,['energy'],['energy']
Energy Efficiency,"n of CN - Ne interaction energy First with jun-cc-pVDZ and density fitted integrals with ROHF Then with cc-pVDZ and direct integrals, except for dispersion that is computed with cc-pVDZ-ri density fitting with ROHF. cc24; Single point gradient of 1-2B1 state of H2O+ with EOM-CCSD. cc3; cc3: RHF-CCSD/6-31G** H2O geometry optimization and vibrational frequency analysis by finite-differences of gradients. cc6; Frozen-core CCSD(T)/cc-pVDZ on C4H4N anion with disk ao algorithm. dft-custom-mgga; updated dldf reference to new BraggSlater radii Dispersionless density functional (dlDF+D) internal match to Psi4 Extensive testing has been done to match supplemental info of Szalewicz et. al., Phys. Rev. Lett., 103, 263201 (2009) and Szalewicz et. al., J. Phys. Chem. Lett., 1, 550-555 (2010). omp3-grad2; OMP3 cc-pVDZ gradient for the NO radical. isapt2; This is a shorter version if isapt1 - does not do cube plots. See isapt1 for full details. decontract; RHF/cc-pvdz-decontract HCl single-point energy Testing the in line -decontract option for basis sets. psimrcc-ccsd_t-2; Mk-MRCCSD(T) single point. \(^1A_1\) CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. cc22; ROHF-EOM-CCSD/DZ on the lowest two states of each irrep in \(^{3}B_1\) CH2. scf-bz2; Benzene Dimer Out-of-Core HF/cc-pVDZ. fd-freq-energy; SCF STO-3G finite-difference frequencies from energies for H2O. dct4; DCT calculation for the HF+ using DC-06 functional. This performs both two-step and simultaneous update of the orbitals and cumulant using DIIS extrapolation. Four-virtual integrals are first handled in the MO Basis for the first two energy computations. In the next two the ao_basis=disk algorithm is used, where the transformation of integrals for four-virtual case is avoided. The computation is then repeated using the DC-12 functional with the same algorithms. castup1; Test of SAD/Cast-up (mainly not dying due to file weirdness). cc29; CCSD/cc-pVDZ optical rotation calculati",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html:12041,energy,energy,12041,psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"n of Normal Modes — frequency() and hessian(). Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Psithon Functions: Invoking a Calculation; Harmonic Vibrational Analysis and Visualization of Normal Modes — frequency() and hessian(). Harmonic Vibrational Analysis and Visualization of Normal Modes — frequency() and hessian()¶. Psi4 Native Hessian Methods. For further discussion of vibrational and thermochemical analysis,; see Sec. Vibrational and Thermochemical Analysis.; frequency() is the only command most users will ever; need to access directly to perform frequency calculations. Behind; the scenes, frequency() is a light wrapper over; hessian() that computes the Hessian then adds a; thermochemical analysis. psi4.frequency(name[, molecule, return_wfn, func, mode, dertype, irrep])[source]; Function to compute harmonic vibrational frequencies. Aliases; frequencies(), freq(). Returns; float – Total electronic energy in Hartrees. Returns; (float, Wavefunction) – energy and wavefunction when return_wfn specified. Parameters. name (str) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. dertype (dertype) – \(\Rightarrow\) 'hessian' \(\Left",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/freq-1.html:1041,energy,energy,1041,psi4manual/1.4.0/freq-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/freq-1.html,2,['energy'],['energy']
Energy Efficiency,"n of Normal Modes — frequency() and hessian(). Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Psithon Functions: Invoking a Calculation; Harmonic Vibrational Analysis and Visualization of Normal Modes — frequency() and hessian(). Harmonic Vibrational Analysis and Visualization of Normal Modes — frequency() and hessian()¶. Psi4 Native Hessian Methods. For further discussion of vibrational and thermochemical analysis,; see Sec. Vibrational and Thermochemical Analysis.; frequency() is the only command most users will ever; need to access directly to perform frequency calculations. Behind; the scenes, frequency() is a light wrapper over; hessian() that computes the Hessian then adds a; thermochemical analysis. psi4.frequency(name[, molecule, return_wfn, func, mode, dertype, irrep])[source]; Function to compute harmonic vibrational frequencies. Aliases; frequencies(), freq(). Returns; float – Total electronic energy in Hartrees. Returns; (float, Wavefunction) – energy and wavefunction when return_wfn specified. Parameters. name (str) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. dertype (dertype) – \(\Rightarrow\) 'hessian' \(\Left",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/freq-1.html:1041,energy,energy,1041,psi4manual/1.5.0/freq-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/freq-1.html,2,['energy'],['energy']
Energy Efficiency,"n of Normal Modes — frequency() and hessian(). Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Psithon Functions: Invoking a Calculation; Harmonic Vibrational Analysis and Visualization of Normal Modes — frequency() and hessian(). Harmonic Vibrational Analysis and Visualization of Normal Modes — frequency() and hessian()¶. Psi4 Native Hessian Methods. For further discussion of vibrational and thermochemical analysis,; see Sec. Vibrational and Thermochemical Analysis.; frequency() is the only command most users will ever; need to access directly to perform frequency calculations. Behind; the scenes, frequency() is a light wrapper over; hessian() that computes the Hessian then adds a; thermochemical analysis. psi4.frequency(name[, molecule, return_wfn, func, mode, dertype, irrep])[source]; Function to compute harmonic vibrational frequencies. Aliases; frequencies(), freq(). Returns; float – Total electronic energy in Hartrees. Returns; (float, Wavefunction) – energy and wavefunction when return_wfn specified. Parameters. name (str) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. dertype (dertype) – \(\Rightarrow\) 'hessian' \(\Left",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/freq.html:1041,energy,energy,1041,psi4manual/1.6.x/freq.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/freq.html,1,['energy'],['energy']
Energy Efficiency,"n of active n-body levels among model chemistry levels. All bodies in range [1, self.max_nbody] must be present exactly once. Number of items in outer list is how many different modelchems. Each inner list specifies what n-bodies to be run at the corresponding modelchem (e.g., [[1, 2]] has max_nbody=2 and 1-body and 2-body contributions computed at the same level of theory; [[1], [2]] has max_nbody=2 and 1-body and 2-body contributions computed at different levels of theory. An entry ‘supersystem’ means all higher order n-body effects up to the number of fragments. The n-body levels are effectively sorted in the outer list, and any ‘supersystem’ element is at the end.; embedding_charges (Dict[List[float]], Default: {}) – Atom-centered point charges to be used on molecule fragments whose basis sets are not included in the computation. Keys: 1-based index of fragment. Values: list of atom charges for that fragment.; return_total_data (bool, Optional) – When True, returns the total data (energy/gradient/Hessian) of the system, otherwise returns interaction data. Default is False for energies, True for gradients and Hessians. Note that the calculation of total counterpoise corrected energies implies the calculation of the energies of monomers in the monomer basis, hence specifying return_total_data = True may carry out more computations than return_total_data = False.; quiet (bool, Default: False) – Whether to print/log formatted n-body energy analysis. Presently used by multi to suppress output. Candidate for removal from class once in-class/out-of-class functions sorted.; task_list (Dict[Union[, , ]], Default: {}) – ; extra_data (Any) – . Return type; None. build_tasks(mb_computer, mc_level_idx, **kwargs)[source]¶; Adds to the task_list as many new unique tasks as necessary to treat a single model chemistry level at one or several n-body levels.; New tasks are of type mb_computer with model chemistry level specified in kwargs and n-body levels accessed through mc_level",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/nbody.html:5628,energy,energy,5628,psi4manual/1.6.x/nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/nbody.html,1,['energy'],['energy']
Energy Efficiency,"n of geometry optimization, see; Sec. Geometry Optimization.; optimize() is the only command most users will ever; need to access directly to perform geometry optimizations. Behind; the scenes, optimize() is a wrapper that repeatedly; calls gradient() that computes the gradient then adds a; call to the geometry optimization module. psi4.optimize(name[, molecule, return_wfn, func, mode, dertype, hessian_with])[source]; Function to perform a geometry optimization. Aliases:; opt(). Returns:; float – Total electronic energy of optimized structure in Hartrees. Returns:; (float, Wavefunction) – energy and wavefunction when return_wfn specified. Raises:; psi4.driver.OptimizationConvergenceError if GEOM_MAXITER exceeded without reaching geometry convergence. PSI variables:. CURRENT ENERGY. Parameters:. name (str) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; psi4.driver.energy(). molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. return_history (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. engine (str) – \(\Rightarrow\) 'optking' \(\Leftarrow\) || 'geometric'; Indicates the optimization engine to use, which can be either Psi4’s; native Optking optimizer or the GeomeTRIC program. optimizer_keywords (dict) – Extra options passed to the GeomeTRIC or optking optimizers; Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. Alternatively, can be used to set optking options; that are not currently recognized by Psi4. func (function) – \(\Rightarr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/opt.html:1411,energy,energy,1411,psi4manual/1.7.x/opt.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/opt.html,4,['energy'],['energy']
Energy Efficiency,"n of the CPHF equations. Type: conv double; Default: 1e-10. MAXITER¶. Maximum number of CPHF iterations. Type: integer; Default: 50. PRINT¶. The amount of information to print to the output file for the sapt module. For 0, only the header and final results are printed. For 1, (recommended for large calculations) some intermediate quantities are also printed. Type: integer; Default: 1. Advanced SAPT0 Keywords¶. AIO_CPHF¶. Do use asynchronous disk I/O in the solution of the CPHF equations? Use may speed up the computation slightly at the cost of spawning an additional thread. Type: boolean; Default: false. AIO_DF_INTS¶. Do use asynchronous disk I/O in the formation of the DF integrals? Use may speed up the computation slightly at the cost of spawning an additional thread. Type: boolean; Default: false. NO_RESPONSE¶. Don’t solve the CPHF equations? Evaluate \(E_{ind}^{(20)}\) and \(E_{exch-ind}^{(20)}\) instead of their response-including counterparts. Only turn on this option if the induction energy is not going to be used. Type: boolean; Default: false. EXCH_SCALE_ALPHA¶. Whether or not to perform exchange scaling for SAPT exchange components. Default is false, i.e. no scaling. If set to true, performs scaling with \(Exch10 / Exch10(S^2)\). If set to a value \(\alpha\), performs scaling with \((Exch10 / Exch10(S^2))^{\alpha}\). Type: string; Default: FALSE. INTS_TOLERANCE¶. Minimum absolute value below which all three-index DF integrals and those contributing to four-index integrals are neglected. The default is conservative, but there isn’t much to be gained from loosening it, especially for higher-order SAPT. Type: conv double; Default: 1.0e-12. DENOMINATOR_DELTA¶. Maximum error allowed (Max error norm in Delta tensor) in the approximate energy denominators employed for most of the \(E_{disp}^{(20)}\) and \(E_{exch-disp}^{(20)}\) evaluation. Type: double; Default: 1.0e-6. DENOMINATOR_ALGORITHM¶. Denominator algorithm for PT methods. Laplace transformations are slig",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/sapt-1.html:16693,energy,energy,16693,psi4manual/1.1.0/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/sapt-1.html,2,['energy'],['energy']
Energy Efficiency,"n of the CPHF- and/or Z-vector equations. Type: integer; Default: 64. CFOUR_CURVILINEAR¶. Specifies whether or not Hessian matrix is transformed (nonlinearly) to curvilinear internal coordinates. A value of 0 (or OFF) turns the transformation off if the analytic force constants are not available, while it is always performed if CURVILINEAR=1 (or ON). Values higher than 1 (or NO) unconditionally turn the transformation off.(Default: ON if analytic Hessian is available, OFF otherwise). Type: boolean; Default: true. CFOUR_DBOC¶. Specifies whether the diagonal Born-Oppenheimer correction (DBOC) to the energy is evaluated (ON =1) or not (OFF =0). DBOC calculations are currently only available for HF-SCF and CCSD using RHF or UHF reference functions. Type: boolean; Default: false. CFOUR_DCT¶. Specifies whether the Dipole Coupling Tensor (DCT) is calculated (ON =1) or not (OFF =0). Type: boolean; Default: false. CFOUR_DERIV_LEVEL¶. Specifies whether or not energy derivatives are to be calculated and if so whether first or second derivatives are computed. ZERO (= 0) derivatives are not calculated, FIRST (=1) first derivatives are calculated, SECOND (=2) second derivatives are calculated. Note that this keyword usually needs not be set in any calculation since it is automatically set if the appropriate other options in the CFOUR namelist are turned on. Psi4 Interface: Keyword set from type of computation command: ZERO if energy(), FIRST if gradient() or optimization(), etc. Type: string; Possible Values: ZERO, FIRST, SECOND; Default: ZERO. CFOUR_DIFF_TYPE¶. Specifies whether orbital-relaxed (RELAXED =0) or orbital-unrelaxed (UNRELAXED =1) derivatives are computed in the CC calculation. Type: string; Possible Values: RELAXED, UNRELAXED; Default: RELAXED. CFOUR_DROPMO¶. Specifies which molecular orbitals will be dropped from the post-SCF calculation. The orbitals are numbered in ascending order from the most stable (negative energy) to the most unstable (largest positive energy",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__cfour-1.html:14096,energy,energy,14096,psi4manual/1.3.2/autodir_options_c/module__cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__cfour-1.html,8,['energy'],['energy']
Energy Efficiency,"n of the CPHF- and/or Z-vector equations. Type: integer; Default: 64. CFOUR_CURVILINEAR¶. Specifies whether or not Hessian matrix is transformed (nonlinearly) to curvilinear internal coordinates. A value of 0 (or OFF) turns the transformation off if the analytic force constants are not available, while it is always performed if CURVILINEAR=1 (or ON). Values higher than 1 (or NO) unconditionally turn the transformation off.(Default: ON if analytic Hessian is available, OFF otherwise). Type: boolean; Default: true. CFOUR_DBOC¶. Specifies whether the diagonal Born-Oppenheimer correction (DBOC) to the energy is evaluated (ON =1) or not (OFF =0). DBOC calculations are currently only available for HF-SCF and CCSD using RHF or UHF reference functions. Type: boolean; Default: false. CFOUR_DCT¶. Specifies whether the Dipole Coupling Tensor (DCT) is calculated (ON =1) or not (OFF =0). Type: boolean; Default: false. CFOUR_DERIV_LEVEL¶. Specifies whether or not energy derivatives are to be calculated and if so whether first or second derivatives are computed. ZERO (= 0) derivatives are not calculated, FIRST (=1) first derivatives are calculated, SECOND (=2) second derivatives are calculated. Note that this keyword usually needs not be set in any calculation since it is automatically set if the appropriate other options in the CFOUR namelist are turned on. Psi4 Interface: Keyword set from type of computation command: ZERO if energy(), FIRST if gradient() or optimize(), etc. Type: string; Possible Values: ZERO, FIRST, SECOND; Default: ZERO. CFOUR_DIFF_TYPE¶. Specifies whether orbital-relaxed (RELAXED =0) or orbital-unrelaxed (UNRELAXED =1) derivatives are computed in the CC calculation. Type: string; Possible Values: RELAXED, UNRELAXED; Default: RELAXED. CFOUR_DROPMO¶. Specifies which molecular orbitals will be dropped from the post-SCF calculation. The orbitals are numbered in ascending order from the most stable (negative energy) to the most unstable (largest positive energy). I",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodir_options_c/module__cfour-1.html:14101,energy,energy,14101,psi4manual/1.4.0/autodir_options_c/module__cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/module__cfour-1.html,18,['energy'],['energy']
Energy Efficiency,"n polarization. KS-DFT with; the true functional is expected to be the final step, thus restricting the; solution to positive definite spin polarization is not physical. See the; section in [Szabo:1982] on methyl radical for an example. Functional Selection¶; PSI4 features an extensive list of LSDA, GGA, Meta, Hybrid, LRC, and -D; functionals. These can be specified by a variety of means. Perhaps the simplest; is to use the functional name as the energy procedure call:; 1energy('b3lyp'). Note that if you are running an unrestricted computation, you should set the; REFERENCE option before the call to energy:; 1; 2set reference uks; energy('b3lyp'). The functional may also be manually specified by calling energy (or any other keyword); with a dft_functional argument:; 1energy('scf', dft_functional = 'b3lyp'). Another alternative is providing a specially crafted dict-ionary to the dft_functional; argument:; 1; 2custom_functional = { ""name"": ""my_unique_name"", ... }; energy('scf', dft_functional = custom_functional). For further details about this so called dict_func syntax, see; :ref: Advanced Functional Use and Manipulation.; For hybrid functionals, the fraction of exact exchange is controlled by the; DFT_ALPHA option. For the LRC functionals, the fraction of long-range; Hartree–Fock and short-range DFA is controlled by the DFT_OMEGA option.; Changing these will override the default behavior of the requested functional.; A brief summary of some of the more notable functionals in PSI4, and links; to the complete listing of all functionals of each class are presented below:. All Functionals; All functionals, including LSDA-only functionals. Note that here and; throughout, functionals which end in _X or _C are exchange or; correlation only, and should not be used for most production-level; computations. Examples include PBE_X and PBE_C, which contain the; separate definitions of the PBE exchange and correlation holes. In most cases,; the united PBE functional should be us",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/dft-1.html:15190,energy,energy,15190,psi4manual/1.2.1/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/dft-1.html,2,['energy'],['energy']
Energy Efficiency,"n properties computed for dimer and one monomer. castup1; Test of SAD/Cast-up (mainly not dying due to file weirdness). fcidump; test FCIDUMP functionality for rhf/uhf. fnocc5; Test FNO-DF-CCSD(T) energy. cepa3; cc-pvdz H2O Test coupled-pair CISD against DETCI CISD. cc12; Single point energies of multiple excited states with EOM-CCSD. extern1; External potential calculation involving a TIP3P water and a QM water. Finite different test of the gradient is performed to validate forces. fnocc4; Test FNO-DF-CCSD(T) energy. fd-freq-energy-large; SCF DZ finite difference frequencies by energies for C4NH4. cc54; CCSD dipole with user-specified basis set. dft-grad-lr2; Tests CAM gradients with and without XC pieces to narrow grid error. sapt-dft1; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. fci-h2o-fzcv; 6-31G H2O Test FCI Energy Point. pywrap-alias; Test parsed and exotic calls to energy() like zapt4, mp2.5, and cisd are working. cc4a; RHF-CCSD(T) cc-pVQZ frozen-core energy of the BH molecule, with Cartesian input. This version tests the FROZEN_DOCC option explicitly. sad1; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. psimrcc-pt2; Mk-MRPT2 single point. \(^1A_1\) F2 state described using the Ms = 0 component of the singlet. Uses TCSCF singlet orbitals. dfmp2-freq1; DF-MP2 frequency by difference of energies for H2O. cc51; EOM-CC3/cc-pVTZ on H2O. rasci-h2o; RASCI/6-31G** H2O Energy Point. ddd-deriv; Sample HF/cc-pVDZ H2O computation all derivatives. scf-auto-cholesky; Cholesky filter a complete basis. sapt-dft-lrc; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. castup3; SCF with various combinations of pk/density-fitting, castup/no-castup, and spherical/cart",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html:8763,energy,energy,8763,psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"n range(len(self.hrxn)):; text += """""" %20s"""""" % (str(self.hrxn[ix])); for ax in self.axis.values():; text += """""" %8.3f"""""" % (ax[ix]); text += """"""\n""""""; text += """"""\n""""""; return text. [docs]class Reagent(object):; """"""Chemical entity only slightly dresed up from qcdb.Molecule. """""". def __init__(self, name, mol, tagl=None, comment=None):; # full name, e.g., 'S22-2-dimer' or 'NBC1-BzMe-8.0-monoA-CP' or 'HTBH-HCl-reagent'; self.name = name; # qcdb.Molecule; try:; self.NRE = mol.nuclear_repulsion_energy(); except AttributeError:; raise ValidationError(""""""Reagent must be instantiated with qcdb.Molecule object.""""""); else:; self.mol = mol.create_psi4_string_from_molecule(); # description line; self.tagl = tagl; # # addl comments; # self.comment = comment; # # fragmentation; # self.fragments = mol.fragments; # # frag activation; # self.frtype = mol.fragment_types; # # frag charge; # self.frchg = mol.fragment_charges; # # frag multiplicity; # self.frmult = mol.fragment_multiplicities; self.charge = mol.molecular_charge(). def __str__(self):; text = ''; text += """""" ==> %s Reagent <==\n\n"""""" % (self.name); text += """""" Tagline: %s\n"""""" % (self.tagl); # text += """""" Comment: %s\n"""""" % (self.comment); text += """""" NRE: %f\n"""""" % (self.NRE); # text += """""" Charge: %+d\n""""""; # text += """""" Fragments: %d\n"""""" % (len(self.fragments)); # text += """""" FrgNo Actv Chg Mult AtomRange\n""""""; # for fr in range(len(self.fragments)):; # text += """""" %-4d %1s %+2d %2d %s\n"""""" % (fr + 1,; # '*' if self.frtype[fr] == 'Real' else '',; # self.frchg[fr], self.frmult[fr], self.fragments[fr]); text += """""" Molecule: \n%s"""""" % (self.mol); text += """"""\n""""""; return text. [docs]class Reaction(object):; """""". """""". def __init__(self, name, dbse, indx, tagl=None, latex=None, color='black', comment=None):; # name, e.g., '2' or 'BzMe-8.0'; self.name = name; # database reaction name, e.g., 'S22-2' or 'NBC1-BzMe-8.0'; self.dbrxn = dbse + '-' + str(name); # numerical index of reaction; self.indx = indx; # description line; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:13418,charge,charge,13418,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html,1,['charge'],['charge']
Energy Efficiency,"n same strand). S22¶. Database (Hobza) of interaction energies for bimolecular complexes.; Geometries from Jurecka et al. PCCP 8 1985 (2006).; First revision to interaction energies (S22A) from Takatani et al. JCP 132 144104 (2010).; Second revision to interaction energies (S22B) from Marshall et al. JCP 135 194102 (2011). cp 'off' || 'on'; rlxd 'off'; benchmark; 'S220' Jurecka et al. PCCP 8 1985 (2006).; 'S22A' Takatani et al. JCP 132 144104 (2010).; 'S22B' Marshall et al. JCP 135 194102 (2011). subset; 'small' water dimer, methane dimer, ethene-ethine; 'large' adenine-thymine; 'HB' hydrogen-bonded systems; 'MX' mixed-influence systems; 'DD' dispersion-dominated systems; 'S11' smaller systems in S22. HTBH¶. Database (Truhlar) of hydrogen-transfer barrier height reactions.; Geometries from Truhlar and coworkers at site http://t1.chem.umn.edu/misc/database_group/database_therm_bh/raw_geom.cgi .; Reference energies from Zhao et al. JPCA, 109 2012-2018 (2005) doi: 10.1021/jp045141s [in supporting information]. cp 'off'; rlxd 'off'; subset; 'small'; 'large'. NCB31¶. Database of <description of members and reference energy type>.; Geometries from <Reference>.; Reference interaction energies from <Reference>. cp 'off' || 'on'; rlxd 'off' || 'on'; benchmark; '<benchmark_name>' <Reference>.; '<default_benchmark_name>' <Reference>. subset; 'small'; 'large'; 'HB6' hydrogen-bonded; 'CT7' charge-transfer; 'DI6'; 'WI7' weakly interacting; 'PPS5'. Table Of Contents. BAKERJCC96; ACENES; NBC10; S22by5; BENCH12; RSE42; BAKERJCC93; RGC10; S66; CORE; BASIC; NHTBH; HBC6; HSG; JSCH; S22; HTBH; NCB31. Previous topic; Database; Next topic; Complete Basis Set; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Psithon Functions: Invoking a Calculation »; Database ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 05, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodoc_available_databases-1.html:8622,energy,energy,8622,psi4manual/4.0b4/autodoc_available_databases-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodoc_available_databases-1.html,4,"['charge', 'energy']","['charge-transfer', 'energy']"
Energy Efficiency,"n set appropriately when return_wfn specified. Parameters. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element of a tuple. bsse_type (str or list) – 'cp' || ['nocp', 'vmfc'] || \(\Rightarrow\) None \(\Leftarrow\) || etc.; Type of BSSE correction to compute: CP for counterpoise correction, NoCP; for plain supramolecular interaction energy, or VMFC for Valiron-Mayer; Function Counterpoise correction. If a list is provided, the first string in; the list determines which interaction or total energies/gradients/Hessians are; returned by this function. By default, many-body treatments are inactive. max_nbody (int) – 3 || etc.; Maximum n-body to compute, cannot exceed the number of fragments in the molecule. return_total_data (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); If True returns the total data (energy/gradient/Hessian) of the system,; otherwise returns interaction data. Default is 'off' for energies,; 'on' for gradients and Hessians. Note that the calculation of total; counterpoise corrected energies implies the calculation of the energies of; monomers in the monomer basis, hence specifying return_total_data = True; may carry out more computations than return_total_data = False.; For gradients and Hessians, return_total_data = False is rarely useful. levels (dict) – {1: 'ccsd(t)', 2: 'mp2', 'supersystem': 'scf'} || {1: 2, 2: 'ccsd(t)', 3: 'mp2'} || etc; Dictionary of different levels of theory for different levels of expansion; Note that method_string is not used in this case. supersystem computes; all higher order n-body effects up to the number of fragments. embedding_charges (dict) – {1: [-0.834, 0.417, 0.417], ..}; Dictionary of atom-centered point charges. keys: 1-based index of fragment, values: list of charges for each fragment.; Add atom-centered point",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/nbody.html:1691,energy,energy,1691,psi4manual/1.6.x/nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/nbody.html,1,['energy'],['energy']
Energy Efficiency,"n the conversion factor between the geometry specification units and bohr. :returns: *unit_conv* Conversion factor between the geometry specification units and bohr; """"""; unit_name = self.molecule.units(); if unit_name == ""Angstrom"":; unit_conv = qcel.constants.bohr2angstroms; elif unit_name == ""Bohr"":; unit_conv = 1.0; else:; raise Exception('Unrecognized unit type: ' + str(unit_name)). return unit_conv. # Respond to the <NATOMS command; def send_natoms(self):; """""" Send the number of atoms through MDI; """"""; natom = self.molecule.natom(); MDI_Send(natom, 1, MDI_INT, self.comm); return natom. # Respond to the <COORDS command; def send_coords(self):; """""" Send the nuclear coordinates through MDI; """"""; coords = self.molecule.geometry().np.ravel(); MDI_Send(coords, len(coords), MDI_DOUBLE, self.comm); return coords. # Respond to the <CHARGES command; def send_charges(self):; """""" Send the nuclear charges through MDI. :returns: *charges* Atomic charges; """"""; natom = self.molecule.natom(); charges = [self.molecule.charge(iatom) for iatom in range(natom)]; MDI_Send(charges, natom, MDI_DOUBLE, self.comm); return charges. # Respond to the <MASSES command; def send_masses(self):; """""" Send the nuclear masses through MDI. :returns: *masses* Atomic masses; """"""; natom = self.molecule.natom(); molecule_dict = self.molecule.to_dict(); masses = molecule_dict['mass']; MDI_Send(masses, natom, MDI_DOUBLE, self.comm); return masses. # Respond to the <ELEMENTS command; def send_elements(self):; """""" Send the atomic number of each nucleus through MDI. :returns: *elements* Element of each atom; """"""; natom = self.molecule.natom(); elements = [self.molecule.true_atomic_number(iatom) for iatom in range(natom)]; MDI_Send(elements, natom, MDI_INT, self.comm); return elements. # Respond to the <ENERGY command; def send_energy(self):; """""" Send the total energy through MDI. :returns: *energy* Energy of the system; """"""; self.run_scf(); MDI_Send(self.energy, 1, MDI_DOUBLE, self.comm); return self.energy",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html:5187,charge,charges,5187,psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html,10,['charge'],['charges']
Energy Efficiency,"n the iterative subspace that will; be stored before a collapse is done.; maxiter (int) – The maximum number of iterations; verbose (int) – The amount of logging info to print (0 -> none, 1 -> some, 2 -> all but matrices, >2 -> everything). Returns:. best_values (numpy.ndarray) – (nroots, ) The best approximation of the eigenvalues of w, computed on the last iteration of the solver; best_R (List[vector]) – (nroots) The best approximation of the right hand eigenvectors, \(X+Y\), computed on the last iteration of the solver.; best_L (List[vector]) – (nroots) The best approximation of the left hand eigenvectors, \(X-Y\), computed on the last iteration of the solver.; stats (List[Dict]) – Statistics collected on each iteration. count : int, iteration number; res_norm : np.ndarray (nroots, ), the norm of residual vector for each roots; val : np.ndarray (nroots, ), the eigenvalue corresponding to each root; delta_val : np.ndarray (nroots, ), the change in eigenvalue from the last iteration to this ones; collapse : bool, if a subspace collapse was performed; product_count : int, the running total of product evaluations that was performed; done : bool, if all roots were converged. Notes; The solution vector is normalized to 1/2; The solver will return even when maxiter iterations are performed without convergence.; The caller must check stats[-1]['done'] for failure and handle each case accordingly.; References; R. Eric Stratmann, G. E. Scuseria, and M. J. Frisch, “An efficient; implementation of time-dependent density-functional theory for the; calculation of excitation energies of large molecules.” J. Chem. Phys.,; 109, 8218 (1998). table of contents. hamiltonian_solver; hamiltonian_solver(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; hamiltonian_solver. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.p4util.hamiltonian_solver.html:3417,efficient,efficient,3417,psi4manual/1.8.x/api/psi4.driver.p4util.hamiltonian_solver.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.p4util.hamiltonian_solver.html,2,['efficient'],['efficient']
Energy Efficiency,"n the iterative subspace that will; be stored before a collapse is done.; maxiter (int) – The maximum number of iterations; verbose (int) – The amount of logging info to print (0 -> none, 1 -> some, 2 -> all but matrices, >2 -> everything). Returns:. best_values (numpy.ndarray) – (nroots, ) The best approximation of the eigenvalues of w, computed on the last iteration of the solver; best_R (List[vector]) – (nroots) The best approximation of the right hand eigenvectors, \(X+Y\), computed on the last iteration of the solver.; best_L (List[vector]) – (nroots) The best approximation of the left hand eigenvectors, \(X-Y\), computed on the last iteration of the solver.; stats (List[Dict]) – Statistics collected on each iteration. count : int, iteration number; res_norm : np.ndarray (nroots, ), the norm of residual vector for each roots; val : np.ndarray (nroots, ), the eigenvalue corresponding to each root; delta_val : np.ndarray (nroots, ), the change in eigenvalue from the last iteration to this ones; collapse : bool, if a subspace collapse was performed; product_count : int, the running total of product evaluations that was performed; done : bool, if all roots were converged. Notes; The solution vector is normalized to 1/2; The solver will return even when maxiter iterations are performed without convergence.; The caller must check stats[-1]['done'] for failure and handle each case accordingly.; References; R. Eric Stratmann, G. E. Scuseria, and M. J. Frisch, “An efficient; implementation of time-dependent density-functional theory for the; calculation of excitation energies of large molecules.” J. Chem. Phys.,; 109, 8218 (1998). table of contents. hamiltonian_solver; hamiltonian_solver(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. PSI4 API: Linking C++ and Python; hamiltonian_solver. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/api/psi4.driver.p4util.hamiltonian_solver.html:3417,efficient,efficient,3417,psi4manual/1.9.x/api/psi4.driver.p4util.hamiltonian_solver.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.driver.p4util.hamiltonian_solver.html,2,['efficient'],['efficient']
Energy Efficiency,"n the next RHF-ODC-12 computation, AO_BASIS=NONE is used, where four-virtual integrals are transformed into MO basis. freq-masses; check nonphysical masses possible. castup3; SCF with various combinations of pk/density-fitting, castup/no-castup, and spherical/cartesian settings. Demonstrates that puream setting is getting set by orbital basis for all df/castup parts of calc. Demonstrates that answer doesn’t depend on presence/absence of castup. Demonstrates (by comparison to castup2) that output file doesn’t depend on options (scf_type) being set global or local. This input uses local. dfomp2p5-grad2; DF-OMP2.5 cc-pVDZ gradients for the H2O+ cation. decontract; RHF/cc-pvdz-decontract HCl single-point energy Testing the in line -decontract option for basis sets. mp3-grad1; MP3 cc-pVDZ gradient for the H2O molecule. psimrcc-fd-freq1; Mk-MRCCSD single point. \(^3 \Sigma ^-\) O2 state described using the Ms = 0 component of the triplet. Uses ROHF triplet orbitals. sapt-ecp; sapt0 of charged system in ECP basis set. dft-ghost; DFT Functional Test for Range-Seperated Hybrids and Ghost atoms. tu6-cp-ne2; Example potential energy surface scan and CP-correction for Ne2. opt-multi-dimer-c2h; Multi-fragment opt of C2h methane dimer with user-combined reference points. gibbs; Test Gibbs free energies at 298 K of N2, H2O, and CH4. mints2; A test of the basis specification. A benzene atom is defined using a ZMatrix containing dummy atoms and various basis sets are assigned to different atoms. The symmetry of the molecule is automatically lowered to account for the different basis sets. adc2; ADC(2)/aug-cc-pVDZ on two water molecules that are distant from 1000 angstroms from each other. cc41; RHF-CC2-LR/cc-pVDZ optical rotation of H2O2. gauge = both, omega = (589 355 nm). mp2-def2; Test case for Binding Energy of C4H5N (Pyrrole) with CO2 using MP2/def2-TZVPP. dft-reference; MP2 with a PBE0 reference computation. pywrap-bfs; apply linear fragmentation algorithm to a water cluster. ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html:13030,charge,charged,13030,psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,4,['charge'],['charged']
Energy Efficiency,"n this case, the; \(^2A_1\) state is lower in energy, and is not problematic. The distorted; geometries for the \(^2B_2\) state are excited states that are subject to; variational collapse. One way to obtain reliable energies for these states is; to use a multi-state method; in this case it’s easier to run the entire; computation in the lowest symmetry needed during the finite difference; procedure. Non-Covalently Bonded Molecule Fragments¶; PSI4 has an extensive range of tools for treating non-covalent; intermolecular forces, including counterpoise corrections and symmetry adapted; perturbation theory methods. These require the definition of which fragments; are interacting within the complex. PSI4 provides a very simple mechanism; for doing so: simply define the complex’s geometry using the standard; Cartesian, Z-matrix, or mixture thereof, specifications and then place two; dashes between nonbonded fragments. For example, to study the interaction; energy of ethane and ethyne molecules, we can use the following molecule; block:; molecule eneyne {; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.923621 1.232253 -2.126185; --; 0 1; C 0.000000 0.000000 2.900503; C 0.000000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; }. In this case, the charge and multiplicity of each interacting fragment is; explicitly specified. If the charge and multiplicity are specified for the; first fragment, it is assumed to be the same for all fragments. When; considering interacting fragments, the overall charge is simply the sum of all; fragment charges, and any unpaired electrons are assumed to be coupled to; yield the highest possible \(M_s\) value.; Having defined a molecule containing fragments like eneyne above, it; is a simple matter to perform calculations on only a subset of the; fragments. For instance, the commands below run a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/psithonmol-1.html:14365,energy,energy,14365,psi4manual/1.4.0/psithonmol-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/psithonmol-1.html,6,['energy'],['energy']
Energy Efficiency,"n this case, the; \(^2A_1\) state is lower in energy, and is not problematic. The distorted; geometries for the \(^2B_2\) state are excited states that are subject to; variational collapse. One way to obtain reliable energies for these states is; to use a multi-state method; in this case it’s easier to run the entire; computation in the lowest symmetry needed during the finite difference; procedure. Non-Covalently Bonded Molecule Fragments¶; PSI4 has an extensive range of tools for treating non-covalent; intermolecular forces, including counterpoise corrections and symmetry adapted; perturbation theory methods. These require the definition of which fragments; are interacting within the complex. PSI4 provides a very simple mechanism; for doing so: simply define the complex’s geometry using the standard; Cartesian, Z-matrix, or mixture thereof, specifications and then place two; dashes between nonbonded fragments. For example, to study the interaction; energy of ethane and ethyne molecules, we can use the following molecule; block:; molecule eneyne {; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.923621 1.232253 -2.126185; --; 0 1; C 0.000000 0.000000 2.900503; C 0.000000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; }. This specifies that there are two neutral, spin-singlet fragments. It is; possible to further specify that the overall complex is neutral and spin-singlet; by inserting another charge multiplicity line, separated from the first; molecule block by a – line. If any information is missing, PSI4 will set the; unprovided charges and multiplicities to be consistent with those that are given.; For example, the overall charge must be simply the sum of all fragment charges.; PSI4 further assumes that any unpaired electrons are coupled to yield the highest; possible \(M_s\) value. Psi will also favor neutral,",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/psithonmol.html:14572,energy,energy,14572,psi4manual/1.8.x/psithonmol.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/psithonmol.html,3,['energy'],['energy']
Energy Efficiency,"n this value DIIS starts. Type: double; Default: 1e-2. DMRG_SCF_GRAD_THR¶. The density RMS convergence to stop an instruction during successive DMRG instructions. Type: double; Default: 1.e-6. DMRG_SCF_MAX_ITER¶. Maximum number of DMRG iterations. Type: integer; Default: 100. DMRG_SCF_STATE_AVG¶. Whether or not to use state-averaging for roots >=2 with DMRG-SCF. Type: boolean; Default: true. DMRG_SWEEP_DVDSON_RTOL¶. The residual tolerances for the Davidson diagonalization during DMRG instructions. Type: array; Default: No Default. DMRG_SWEEP_ENERGY_CONV¶. The energy convergence to stop an instruction during successive DMRG instructions. Type: array; Default: No Default. DMRG_SWEEP_MAX_SWEEPS¶. The maximum number of sweeps to stop an instruction during successive DMRG instructions. Type: array; Default: No Default. DMRG_SWEEP_NOISE_PREFAC¶. The noise prefactors for successive DMRG instructions. Type: array; Default: No Default. DMRG_SWEEP_STATES¶. The number of reduced renormalized basis states to be retained during successive DMRG instructions. Type: array; Default: No Default. DMRG_UNITARY_WRITE¶. Whether or not to store the unitary on disk (convenient for restarting). Type: boolean; Default: true. table of contents. DMRG; General; DMRG_CASPT2_CALC; DMRG_CASPT2_IMAG; DMRG_CASPT2_IPEA; DMRG_CASPT2_ORBS; DMRG_DIIS; DMRG_DIIS_WRITE; DMRG_EXCITATION; DMRG_IRREP; DMRG_LOCAL_INIT; DMRG_MOLDEN_WRITE; DMRG_MPS_WRITE; DMRG_MULTIPLICITY; DMRG_OPDM_AO_PRINT; DMRG_PRINT_CORR; DMRG_SCF_ACTIVE_SPACE; DMRG_SCF_DIIS_THR; DMRG_SCF_GRAD_THR; DMRG_SCF_MAX_ITER; DMRG_SCF_STATE_AVG; DMRG_SWEEP_DVDSON_RTOL; DMRG_SWEEP_ENERGY_CONV; DMRG_SWEEP_MAX_SWEEPS; DMRG_SWEEP_NOISE_PREFAC; DMRG_SWEEP_STATES; DMRG_UNITARY_WRITE. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; DMRG. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodir_options_c/module__dmrg.html:3437,reduce,reduced,3437,psi4manual/master/autodir_options_c/module__dmrg.html,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/module__dmrg.html,2,['reduce'],['reduced']
Energy Efficiency,"n to filename in; molden format. Will write natural orbitals from density (MO basis) if supplied.; Warning! Most post-SCF Wavefunctions do not build the density as this is often; much more costly than the energy. In addition, the Wavefunction density attributes; (Da and Db) return the SO density and must be transformed to the MO basis; to use with this function. New in version 0.5: wfn parameter passed explicitly. Returns:None. Parameters:; wfn (Wavefunction) – set of molecule, basis, orbitals from which to generate cube files; filename (string) – destination file name for MOLDEN file (optional); density_a (Matrix) – density in the MO basis to build alpha NO’s from (optional); density_b (Matrix) – density in the MO basis to build beta NO’s from, assumes restricted if not supplied (optional); dovirtual (bool) – do write all the MOs to the MOLDEN file (true) or discard the unoccupied MOs, not valid for NO’s (false) (optional). Examples:. >>> # [1] Molden file for DFT calculation; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> molden(wfn, 'mycalc.molden'). >>> # [2] Molden file for CI/MCSCF computation using NO roots; >>> E, wfn = energy('ci', return_wfn=True); >>> molden(wfn, 'no_root1.molden', density_a=wfn.opdm(0, 0, ""A"", True)). >>> # [3] The following does NOT work, please see below; >>> E, wfn = energy('ccsd', return_wfn=True); >>> molden(wfn, 'ccsd_no.molden', density_a=wfn.Da()). >>> # [4] This WILL work, note the transformation of Da (SO->MO); >>> E, wfn = properties('ccsd', properties=['dipole'], return_wfn=True); >>> Da_so = wfn.Da(); >>> SCa = core.doublet(wfn.S(), wfn.Ca(), False, False); >>> Da_mo = core.triplet(SCa, Da_so, SCa, True, False, False); >>> molden(wfn, 'ccsd_no.molden', density_a=Da_mo). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. PSI4 API: Linking C++ and Python. © Copyright 2019, The Psi4 Project.; Last updated on Wednesday, 15 May 2019 08:49PM.; Created using Sphinx 1.8.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.driver.molden-1.html:1275,energy,energy,1275,psi4manual/1.3.2/api/psi4.driver.molden-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.driver.molden-1.html,6,['energy'],['energy']
Energy Efficiency,"n to perform a general fit of diffuse charges; to wavefunction density. """"""; core.print_out("" => Diffuse Charge Fitting (Determines da) <=\n\n""); self.Da = self.wfn.Da(); self.basis = self.wfn.basisset(); parser = core.Gaussian94BasisSetParser(); self.ribasis = core.BasisSet.construct(parser, self.molecule, ""DF_BASIS_SCF""). fitter = core.DFChargeFitter(); fitter.setPrimary(self.basis); fitter.setAuxiliary(self.ribasis); fitter.setD(self.Da); self.da = fitter.fit(); self.da.scale(2.0). def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]class QMMM():; """"""Hold charges and :py:class:`psi4.core.ExternalPotential`. Use :py:class:`psi4.driver.QMMMbohr` instead."""""". def __init__(self):; raise UpgradeHelper(self.__class__.__name__, ""QMMMbohr"", 1.6, ' Replace object with a list of charges and locations in Bohr passed as keyword argument, e.g., `energy(..., external_potentials=[[0.5, [0, 0, 1]], [-0.5, [0, 0, -1]]])`.'). [docs]class QMMMbohr():; """"""Hold charges and :py:class:`psi4.core.ExternalPotential`. To add external charges to a calculation, prefer; passing the array of charges with kwarg ``external_potentials``, as in extern2 example."""""". def __init__(self):; self.charges = []; self.diffuses = []; self.extern = core.ExternalPotential(). [docs] def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs] def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs] def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / constants.bohr2angstroms, y / constants.bohr2angstroms, z / constants.bo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qmmm.html:3706,charge,charges,3706,psi4manual/1.6.x/_modules/psi4/driver/qmmm.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qmmm.html,4,['charge'],['charges']
Energy Efficiency,"n was introduced in [Grimme:2011:1456]. The parameters; fit for individual functionals are now \(s_6\), \(s_8\),; \(a_1\), and \(a_2\). \[E_{disp}^{\text{D3BJ}}=-\sum_{n=6,8} s_n \sum_{i,j>i}^{N_{at}}; \frac{C_n^{ij}}{(R_{ij})^n + (f_{damp})^n}\]. \[f_{damp} = a_1 \sqrt{\frac{C_8^{ij}}{C_6^{ij}}} + a_2\]; All parameters characterizing the dispersion correction are taken from; Grimme’s website; or else from the literature. Running DFTD3 or DFTD4¶; A number of a posteriori dispersion corrections are available in; PSI4. While some are computed within PSI4‘s codebase (-D1, -D2,; -CHG, -DAS2009, -DAS2010), the -D3 or -D4 corrections and their variants are; available only through the DFTD3 or DFTD4 programs. Once installed, the; dftd3/PSI4 and dftd4/PSI4 interfaces are transparent, and all corrections are; interfaced exactly alike.; Dispersion corrections are built into DFT functionals, so appending an a; posteriori correction to a computation is as simple as; energy('b2plyp-d') vs. energy('b2plyp'). For example, the; following input file computes (with much redundant work) for water a; B3LYP, a B3LYP-D2, a B3LYP-D3 (zero-damping), and a B3LYP-D4 (Becke-Johnson damping) energy.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('b3lyp'); energy('b3lyp-d'); energy('b3lyp-d3'); energy('b3lyp-d4'). Consult the table -D Functionals to see for each; functional what corrections are available and what default parameters; define them. The dispersion correction is available after a calculation in; the PSI variable DISPERSION CORRECTION ENERGY.; By default, the output from the dftd3; program is suppressed; to see it in the output file, set print > 2.; No text output is available from the dftd4 program. Variants of dispersion corrections¶. Extension 1; Variant; Computing Program (engine); DFT_DISPERSION_PARAMETERS 11. -D; alias to -D2. -D1; -D1 2; PSI4‘s libdisp; [\(s_6\)]. -D2; -D2 3; PSI4‘s libdisp OR dftd3; [\(s_6\), \(\alpha_6\), \(s_{r,6}\)]. -D3; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/dftd3-1.html:4934,energy,energy,4934,psi4manual/1.5.0/dftd3-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/dftd3-1.html,3,['energy'],['energy']
Energy Efficiency,"n within irrep i. DFT; functional labeled if canonical. TD-fctl ROOT 0 (h) -> ROOT n (i) RIGHT EIGENVECTOR BETA¶; The right beta spin eigenvectors of the named method; from ground state, which is in irrep h, to root n, which is in irrep i. DFT; functional labeled if canonical. TD-fctl ROOT 0 -> ROOT n RIGHT EIGENVECTOR BETA - h TRANSITION¶; The right alpha and beta spin eigenvectors of the named method; from ground state to root n, and the transition is of irrep h. DFT; functional labeled if canonical. THERMAL ENERGY¶; Total thermal energy E [E_h] at given temperature. THERMAL ENERGY CORRECTION¶; Sum of electronic, translational, rotational, and vibrational corrections [E_h] to the thermal energy at given temperature. TWO-ELECTRON ENERGY¶; The two-electron energy contribution [E_h] to the total SCF energy.; Quantity \(E_{2e^-}\) in Eq. (4). UNCP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [E_h] considering only two-body interactions,; computed without counterpoise correction.; Related variable CP-CORRECTED 2-BODY INTERACTION ENERGY. \[E_{\text{IE}} = E_{dimer} - \sum_{monomer}^{n}{E_{monomer}^{\text{unCP}}}\]. WIBERG LOWDIN INDICES¶; Property of Wiberg bond indices using orthogonal Löwdin orbitals, (nat, nat). ZAPTn TOTAL ENERGY¶. ZAPTn CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the labeled Z-averaged perturbation theory level.; n is ZAPT perturbation order. ZERO K ENTHALPY¶; Total electronic and zero-point energy [E_h] at 0 [K]. ZPVE¶; Vibrational zero-point energy [E_h] at 0 [K]. 2-BODY PAIRWISE DISPERSION CORRECTION ANALYSIS¶; The interatomic contributions to the dispersion correction [E_h].; Sums to the dispersion energy. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; PSI Variables by Alpha. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/glossary_psivariables.html:63978,energy,energy,63978,psi4manual/master/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/master/glossary_psivariables.html,5,['energy'],['energy']
Energy Efficiency,"n"" % "" "".join([str(r) for r in radii])); f.write(""Limit %d\n"" % core.get_option('GDMA', 'GDMA_LIMIT')); f.write(""Start\n""); f.write(""Finish\n""); core.run_gdma(wfn, commands). os.remove(fchkfile); # If we generated the DMA control file, we should clean up here; if not datafile:; os.remove(commands). [docs]def fchk(wfn, filename):; """"""Function to write wavefunction information in *wfn* to *filename* in; Gaussian FCHK format. .. versionadded:: 0.6. :returns: None. :type filename: string; :param filename: destination file name for FCHK file. :type wfn: :py:class:`~psi4.core.Wavefunction`; :param wfn: set of molecule, basis, orbitals from which to generate fchk file. Notes; -----; * A description of the FCHK format is http://wild.life.nctu.edu.tw/~jsyu/compchem/g09/g09ur/f_formchk.htm; * The allowed headers for methods are general and limited, i.e., ""Total SCF|MP2|CI|CC Density"",; so ""CC"" is always used for the post-HF case. :examples:. >>> # [1] FCHK file for DFT calculation; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> fchk(wfn, 'mycalc.fchk'). """"""; fw = core.FCHKWriter(wfn); fw.write(filename). [docs]def molden(wfn, filename=None, density_a=None, density_b=None, dovirtual=None):; """"""Function to write wavefunction information in *wfn* to *filename* in; molden format. Will write natural orbitals from *density* (MO basis) if supplied.; Warning! Most post-SCF Wavefunctions do not build the density as this is often; much more costly than the energy. In addition, the Wavefunction density attributes; (Da and Db) return the SO density and must be transformed to the MO basis; to use with this function. .. versionadded:: 0.5; *wfn* parameter passed explicitly. :returns: None. :type wfn: :py:class:`~psi4.core.Wavefunction`; :param wfn: set of molecule, basis, orbitals from which to generate cube files. :type filename: string; :param filename: destination file name for MOLDEN file (optional). :type density_a: :py:class:`~psi4.core.Matrix`; :param density_a: density in the MO",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html:81283,energy,energy,81283,psi4manual/1.3.2/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html,1,['energy'],['energy']
Energy Efficiency,"n""""""). if not core.get_local_option(""DFOCC"", ""CHOLESKY""):; core.print_out("" Constructing Basis Sets for DFOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()). ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_CC"",; core.get_global_option(""DF_BASIS_CC""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_CC"", aux_basis). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(). dfocc_wfn = core.dfocc(ref_wfn). # Shove variables into global space; if name in ['mp2', 'omp2', 'mp2.5', 'mp3', 'lccd',]:; for k, v in dfocc_wfn.variables().items():; core.set_variable(k, v). if name == ""a-ccsd(t)"":; # temporary until dfocc can be edited and qcvar name changed; core.set_variable(""A-CCSD(T) TOTAL ENERGY"", core.variables()[""CCSD(AT) TOTAL ENERGY""]); core.set_variable(""A-(T) CORRECTION ENERGY"", core.variables()[""(AT) CORRECTION ENERGY""]); core.del_variable(""CCSD(AT) TOTAL ENERGY""); core.del_variable(""(AT) CORRECTION ENERGY""). optstash.restore(); return dfocc_wfn. def run_dfocc_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted (non-)orbital-optimized MPN or CC computation. """"""; optstash = p4util.OptionsState(; ['SCF', 'DF_INTS_IO'],; ['REFERENCE'],; ['DFOCC', 'WFN_TYPE'],; ['DFOCC', 'ORB_OPT'],; ['DFOCC', 'CC_LAMBDA'],; ['GLOBALS', 'DERTYPE']). proc_util.check_disk_df(name.upper(), optstash). if core.get_global_option('SCF_TYPE') != 'DISK_DF':; raise ValidationError('DFOCC gradients need DF-SCF reference.'). if name in ['mp2', 'omp2']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP2'); corl_type = core.get_global_option('MP2_TYPE'); elif name in ['mp2.5']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP2.5'); corl_type = core.get_global_option('MP_TYPE') if c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:58410,ENERGY,ENERGY,58410,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,3,['ENERGY'],['ENERGY']
Energy Efficiency,"n""); raise TestComparisonError(header_diff). ref_energies = _energies_from_fcidump(ref_intdump); energies = _energies_from_fcidump(intdump). pass_1el = compare_values(ref_energies['ONE-ELECTRON ENERGY'], energies['ONE-ELECTRON ENERGY'], 7, label + '. 1-electron energy'); pass_2el = compare_values(ref_energies['TWO-ELECTRON ENERGY'], energies['TWO-ELECTRON ENERGY'], 7, label + '. 2-electron energy'); pass_scf = compare_values(ref_energies['SCF TOTAL ENERGY'], energies['SCF TOTAL ENERGY'], 10, label + '. SCF total energy'); pass_mp2 = compare_values(ref_energies['MP2 CORRELATION ENERGY'], energies['MP2 CORRELATION ENERGY'], 10, label + '. MP2 correlation energy'). if (pass_1el and pass_2el and pass_scf and pass_mp2):; success(label). return True. def _energies_from_fcidump(intdump):; energies = {}; energies['NUCLEAR REPULSION ENERGY'] = intdump['enuc']; epsilon = intdump['epsilon']; Hcore = intdump['hcore']; eri = intdump['eri']. # Compute SCF energy; energies['ONE-ELECTRON ENERGY'], energies['TWO-ELECTRON ENERGY'] = _scf_energy(Hcore, eri,; np.where(epsilon < 0)[0],; intdump['uhf']); # yapf: disable; energies['SCF TOTAL ENERGY'] = energies['ONE-ELECTRON ENERGY'] + energies['TWO-ELECTRON ENERGY'] + energies['NUCLEAR REPULSION ENERGY']; # yapf: enable. # Compute MP2 energy; energies['MP2 CORRELATION ENERGY'] = _mp2_energy(eri, epsilon, intdump['uhf']). return energies. def _scf_energy(Hcore, ERI, occ_sl, unrestricted):; scf_1el_e = np.einsum('ii->', Hcore[np.ix_(occ_sl, occ_sl)]); if not unrestricted:; scf_1el_e *= 2; coulomb = np.einsum('iijj->', ERI[np.ix_(occ_sl, occ_sl, occ_sl, occ_sl)]); exchange = np.einsum('ijij->', ERI[np.ix_(occ_sl, occ_sl, occ_sl, occ_sl)]); if unrestricted:; scf_2el_e = 0.5 * (coulomb - exchange); else:; scf_2el_e = 2.0 * coulomb - exchange. return scf_1el_e, scf_2el_e. def _mp2_energy(ERI, epsilon, unrestricted):; # Occupied and virtual slices; occ_sl = np.where(epsilon < 0)[0]; vir_sl = np.where(epsilon > 0)[0]; eocc = epsilon[occ_sl]; evi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/p4util/fcidump.html:13427,energy,energy,13427,psi4manual/1.2.1/_modules/psi4/driver/p4util/fcidump.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/p4util/fcidump.html,1,['energy'],['energy']
Energy Efficiency,"n""], NEED, +1, 0.0, None, None,; metadata[0][""alpha""]; ]))); if len(metadata) > 1:; for delta in metadata[1:]:; NEED = _expand_scheme_orders(delta[""scheme""], delta[""basis""][0], delta[""basis""][1], delta[""wfn""],; delta[""options""], natom); GRAND_NEED.append(; dict(; zip(d_fields, [; delta[""stage""], delta[""scheme""],; _contract_bracketed_basis(delta[""basis""][0]), delta[""wfn""], NEED, +1, 0.0, None, None,; delta[""alpha""]; ]))); NEED = _expand_scheme_orders(delta[""scheme""], delta[""basis_lo""][0], delta[""basis_lo""][1], delta[""wfn_lo""],; False, natom); GRAND_NEED.append(; dict(; zip(d_fields, [; delta[""stage""], delta[""scheme""],; _contract_bracketed_basis(delta[""basis_lo""][0]), delta[""wfn_lo""], NEED, -1, 0.0, None, None,; delta[""alpha""]; ]))). for stage in GRAND_NEED:; for lvl in stage['d_need'].items():; MODELCHEM.append(lvl[1]). # Apply chemical reasoning to choose the minimum computations to run; JOBS = MODELCHEM[:]. addlremark = {'energy': '', 'gradient': ', GRADIENT', 'hessian': ', HESSIAN'}; instructions = ''; instructions += """""" Naive listing of computations required.\n""""""; for mc in JOBS:; instructions += """""" %12s / %-24s for %s%s\n"""""" % \; (mc['f_wfn'], mc['f_basis'] + "" + options""*bool(mc['f_options']),; VARH[mc['f_wfn']][mc['f_wfn']], addlremark[ptype]). # Remove duplicate modelchem portion listings; for mc in MODELCHEM:; dups = -1; for indx_job, job in enumerate(JOBS):; if (job['f_wfn'] == mc['f_wfn']) and (job['f_basis'] == mc['f_basis']) and \; (job['f_options'] == mc['f_options']) and (job['f_options'] != False):; dups += 1; if dups >= 1:; del JOBS[indx_job]. # Remove chemically subsumed modelchem portion listings; if ptype == 'energy':; for mc in MODELCHEM:; for wfn in VARH[mc['f_wfn']]:; for indx_job, job in enumerate(JOBS):; if (VARH[mc['f_wfn']][wfn] == VARH[job['f_wfn']][job['f_wfn']]) and \; (mc['f_basis'] == job['f_basis']) and not \; (mc['f_wfn'] == job['f_wfn']) and \; (mc['f_options'] == False):; del JOBS[indx_job]. instructions += """"""\n Enlightened lis",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html:49226,energy,energy,49226,psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html,1,['energy'],['energy']
Energy Efficiency,"n' % (el, mline[-3], mline[-2], mline[-1]); lline = grd[at + 1 + Nat].split(); grad.append([float(lline[-3]), float(lline[-2]), float(lline[-1])]); mol = Molecule.init_with_xyz(molxyz, no_com=True, no_reorient=True, contentsNotFilename=True). return mol, grad. [docs]def harvest_zmat(zmat):; """"""Parses the contents of the Cfour ZMAT file into array and; coordinate information. The coordinate info is converted into a; rather dinky Molecule (no fragment, but does read charge, mult,; unit). Return qcdb.Molecule. Written for findif zmat* where; geometry always Cartesian and Bohr. """"""; zmat = zmat.splitlines()[1:] # skip comment line; Nat = 0; readCoord = True; isBohr = ''; charge = 0; mult = 1; molxyz = ''; cgeom = []; for line in zmat:; if line.strip() == '':; readCoord = False; elif readCoord:; lline = line.split(); molxyz += line + '\n'; Nat += 1; else:; if line.find('CHARGE') > -1:; idx = line.find('CHARGE'); charge = line[idx + 7:]; idxc = charge.find(','); if idxc > -1:; charge = charge[:idxc]; charge = int(charge); if line.find('MULTIPLICITY') > -1:; idx = line.find('MULTIPLICITY'); mult = line[idx + 13:]; idxc = mult.find(','); if idxc > -1:; mult = mult[:idxc]; mult = int(mult); if line.find('UNITS=BOHR') > -1:; isBohr = ' bohr'. molxyz = '%d%s\n%d %d\n' % (Nat, isBohr, charge, mult) + molxyz; mol = Molecule.init_with_xyz(molxyz, no_com=True, no_reorient=True, contentsNotFilename=True). return mol. [docs]def harvest_FCM(fcm):; """"""Parses the contents *fcm* of the Cfour FCMFINAL file into a hessian array. """"""; fcm = fcm.splitlines(); Nat = int(fcm[0].split()[0]); Ndof = int(fcm[0].split()[1]). empty = True; hess = []; for df in range(Ndof):; for at in range(Nat):; lline = fcm[Ndof * at + at + 1].split(); if empty:; if (abs(float(lline[0])) > 1.0e-8) or \; (abs(float(lline[1])) > 1.0e-8) or \; (abs(float(lline[2])) > 1.0e-8):; empty = False; fcm.append([float(lline[0]), float(lline[1]), float(lline[2])]). return None if empty else hess. [docs]def harvest_DIPOL(dipol",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/cfour.html:25444,charge,charge,25444,psi4manual/1.0.0/_modules/qcdb/cfour.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/cfour.html,4,['charge'],['charge']
Energy Efficiency,"n' % msg. [docs]class ConvergenceError(PsiException):; """"""Error called for problems with converging and iterative method. Parameters; ----------; eqn_description : str; Type of QC routine that has failed (e.g., SCF); iteration : int; What iteration we failed on. """""". def __init__(self, eqn_description, iteration):; msg = ""Could not converge %s in %d iterations."" % (eqn_description, iteration); PsiException.__init__(self, msg); self.iteration = iteration; self.message = msg; core.print_out('\nPsiException: %s\n\n' % (msg)). [docs]class OptimizationConvergenceError(ConvergenceError):; """"""Error called for problems with geometry optimizer."""""". def __init__(self, eqn_description, iteration, wfn):; ConvergenceError.__init__(self, eqn_description, iteration); self.wfn = wfn. [docs]class SCFConvergenceError(ConvergenceError):; """"""Error called for problems with SCF iterations. Parameters; ----------; wfn : psi4.core.Wavefunction; Wavefunction at time of exception; e_conv : float; Change in energy for last iteration; d_conv : float; RMS change in density for last iteration. """""". def __init__(self, eqn_description, iteration, wfn, e_conv, d_conv):; ConvergenceError.__init__(self, eqn_description, iteration); self.e_conv = e_conv; self.d_conv = d_conv; self.wfn = wfn. [docs]class CSXError(PsiException):; """"""Error called when CSX generation fails. """""". def __init__(self, msg):; PsiException.__init__(self, msg); self.message = '\nCSXException: %s\n\n' % msg. [docs]class ManagedMethodError(PsiException):; def __init__(self, circs):; if circs[5] == '':; msg = """"""{0}: Method '{1}' with {2} '{3}' and REFERENCE '{4}' not available{5}"""""".format(*circs); else:; msg = """"""{0}: Method '{1}' with {2} '{3}' and REFERENCE '{4}' not directable to QC_MODULE '{5}'"""""".format(; *circs); PsiException.__init__(self, msg); self.message = '\nPsiException: %s\n\n' % msg. [docs]class Dftd3Error(PsiException):; """""". """""". def __init__(self, msg):; PsiException.__init__(self, msg); self.message = '\nDftd3Er",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/exceptions.html:3459,energy,energy,3459,psi4manual/1.3.2/_modules/psi4/driver/p4util/exceptions.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/exceptions.html,1,['energy'],['energy']
Energy Efficiency,"n'); sup.set_x_alpha(0.25); return sup. [docs]def build_b3lyp_superfunctional(name, npoints, deriv):. # Call this first; sup = PsiMod.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('B3LYP'); # Tab in, trailing newlines; sup.set_description(' B3LYP Hybrid-GGA Exchange-Correlation Functional\n'); # Tab in, trailing newlines; sup.set_citation(' P.J. Stephens et. al., J. Phys. Chem., 98, 11623-11627, 1994\n'). # Add member functionals; b3 = build_functional('B3_X'); b3.set_alpha(1.0); sup.add_x_functional(b3); lyp = build_functional('LYP_C'); lyp.set_alpha(0.81); vwn = build_functional('VWN3RPA_C'); vwn.set_alpha(0.19); sup.add_c_functional(vwn); sup.add_c_functional(lyp). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.2); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_b3lyp5_superfunctional(name, npoints, deriv):. # Call this first; sup = PsiMod.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('B3LYP5'); # Tab in, trailing newlines; sup.set_description(' B3LYP5 Hybrid-GGA Exchange-Correlation Functional\n'); # Tab in, trailing newlines; sup.set_citation(' P.J. Stephens et. al., J. Phys. Chem., 98, 11623-11627, 1994\n'). # Add member functionals; b3 = build_functional('B3_X'); b3.set_alpha(1.0); sup.add_x_functional(b3); lyp = build_functional('LYP_C'); lyp.set_alpha(0.81); vwn = build_functional('VWN5RPA_C'); vwn.set_alpha(0.19); sup.add_c_functional(lyp); sup.add_c_functional(vwn). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.2); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def bu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/functional.html:25959,allocate,allocate,25959,psi4manual/4.0b2/_modules/functional.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/functional.html,2,['allocate'],['allocate']
Energy Efficiency,"n'] + ' - ' + GRAND_NEED[11]['d_wfn'],; # '/', GRAND_NEED[10]['d_basis'], '', GRAND_NEED[10]['d_energy'] - GRAND_NEED[11]['d_energy'], GRAND_NEED[10]['d_scheme'].__name__); tables += """""" %6s %20s %1s %-27s %2s %16.8f %-s\n"""""" % ('total', 'CBS', '', '', '', finalenergy, ''); tables += table_delimit. psi4.print_out(tables). psi4.set_variable('CBS REFERENCE ENERGY', GRAND_NEED[0]['d_energy']); psi4.set_variable('CBS CORRELATION ENERGY', finalenergy - GRAND_NEED[0]['d_energy']); psi4.set_variable('CBS TOTAL ENERGY', finalenergy); psi4.set_variable('CURRENT REFERENCE ENERGY', GRAND_NEED[0]['d_energy']); psi4.set_variable('CURRENT CORRELATION ENERGY', finalenergy - GRAND_NEED[0]['d_energy']); psi4.set_variable('CURRENT ENERGY', finalenergy); psi4.set_variable('CBS NUMBER', Njobs). # new skeleton wavefunction w/mol, highest-SCF basis (just to choose one), & not energy; wfn = psi4.new_wavefunction(molecule, BSTR[-1]). optstash.restore(). if ptype == 'energy':; finalquantity = finalenergy; elif ptype == 'gradient':; finalquantity = finalgradient; wfn.set_gradient(finalquantity); if finalquantity.rows(0) < 20:; psi4.print_out('CURRENT GRADIENT'); finalquantity.print_out(); elif ptype == 'hessian':; finalquantity = finalhessian; wfn.set_hessian(finalquantity); if finalquantity.rows(0) < 20:; psi4.print_out('CURRENT HESSIAN'); finalquantity.print_out(). if return_wfn:; return (finalquantity, wfn); else:; return finalquantity. _lmh_labels = {1: ['HI'],; 2: ['LO', 'HI'],; 3: ['LO', 'MD', 'HI'],; 4: ['LO', 'MD', 'M2', 'HI'],; 5: ['LO', 'MD', 'M2', 'M3', 'HI']}. def _expand_scheme_orders(scheme, basisname, basiszeta, wfnname, natom):; """"""Check that the length of *basiszeta* array matches the implied degree of; extrapolation in *scheme* name. Return a dictionary of same length as; basiszeta, with *basisname* and *basiszeta* distributed therein. """"""; Nxtpl = len(basiszeta). if int(scheme.__name__.split('_')[-1]) != Nxtpl:; raise ValidationError(""""""Call to '%s' not valid with '%s' basi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:53969,energy,energy,53969,psi4manual/1.0.0/_modules/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html,1,['energy'],['energy']
Energy Efficiency,"n(""BASIS"")); dimer_wfn.set_basisset(""DF_BASIS_ELST"", aux_basis). core.print_out('\n'); p4util.banner(name.upper()); core.print_out('\n'); e_sapt = core.sapt(dimer_wfn, monomerA_wfn, monomerB_wfn). from psi4.driver.qcdb.psivardefs import sapt_psivars; p4util.expand_psivars(sapt_psivars()); optstash.restore(). # Make sure we got induction, otherwise replace it with uncoupled induction; which_ind = 'IND'; target_ind = 'IND'; if not core.has_variable(' '.join([name.upper(), which_ind, 'ENERGY'])):; which_ind='IND,U'. for term in ['ELST', 'EXCH', 'DISP', 'TOTAL']:; core.set_variable(' '.join(['SAPT', term, 'ENERGY']),; core.get_variable(' '.join([name.upper(), term, 'ENERGY']))); # Special induction case; core.set_variable(' '.join(['SAPT', target_ind, 'ENERGY']),; core.get_variable(' '.join([name.upper(), which_ind, 'ENERGY']))); core.set_variable('CURRENT ENERGY', core.get_variable('SAPT TOTAL ENERGY')). return dimer_wfn. def run_sapt_ct(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a charge-transfer SAPT calcuation of any level. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE']). if 'ref_wfn' in kwargs:; core.print_out('\nWarning! Argument ref_wfn is not valid for sapt computations\n'). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). # Get the molecule of interest; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; sapt_dimer = kwargs.pop('molecule', core.get_active_molecule()); else:; core.print_out('Warning! SAPT argument ""ref_wfn"" is only able to use molecule information.'); sapt_dimer = ref_wfn.molecule(). sapt_dimer, monomerA, monomerB = proc_util.prepare_sapt_molecule(sapt_dimer, ""dimer""); monomerAm = sapt_dimer.extract_subsets(1); monomerAm.set_name('monomerAm'); monomerBm = sapt_dimer.extract_subsets(2); monomerBm.set_name('monomerBm'). if core.get_option('SCF', 'REFERENCE') != 'RHF':; raise ValidationError('SAPT requires requires \""reference rhf\"".'). ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html:106074,charge,charge-transfer,106074,psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html,1,['charge'],['charge-transfer']
Energy Efficiency,"n(""DF_BASIS_ELST"") == """":; dimer_wfn.set_basisset(""DF_BASIS_ELST"", aux_basis); else:; aux_basis = core.BasisSet.build(dimer_wfn.molecule(), ""DF_BASIS_ELST"", core.get_global_option(""DF_BASIS_ELST""),; ""RIFIT"", core.get_global_option(""BASIS"")); dimer_wfn.set_basisset(""DF_BASIS_ELST"", aux_basis). core.print_out('\n'); p4util.banner(name.upper()); core.print_out('\n'); e_sapt = core.sapt(dimer_wfn, monomerA_wfn, monomerB_wfn); dimer_wfn.set_module(""sapt""). from psi4.driver.qcdb.psivardefs import sapt_psivars; p4util.expand_psivars(sapt_psivars()); optstash.restore(). # Get the SAPT name right if doing empirical dispersion; if do_empirical_disp:; sapt_name = ""sapt0""; else:; sapt_name = name. # Make sure we got induction, otherwise replace it with uncoupled induction; which_ind = 'IND'; target_ind = 'IND'; if not core.has_variable(' '.join((sapt_name.upper(), which_ind, 'ENERGY'))):; which_ind = 'IND,U'. for term in ['ELST', 'EXCH', 'DISP', 'TOTAL']:; core.set_variable(' '.join(['SAPT', term, 'ENERGY']),; core.variable(' '.join([sapt_name.upper(), term, 'ENERGY']))); # Special induction case; core.set_variable(' '.join(['SAPT', target_ind, 'ENERGY']),; core.variable(' '.join([sapt_name.upper(), which_ind, 'ENERGY']))); core.set_variable('CURRENT ENERGY', core.variable('SAPT TOTAL ENERGY')). # Empirical dispersion; if do_empirical_disp:; proc_util.sapt_empirical_dispersion(name, dimer_wfn). return dimer_wfn. def run_sapt_ct(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a charge-transfer SAPT calcuation of any level. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE']). if 'ref_wfn' in kwargs:; core.print_out('\nWarning! Argument ref_wfn is not valid for sapt computations\n'). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). # Get the molecule of interest; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; sapt_dimer = kwargs.pop('molecule', core.get_active_molecule());",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:138895,ENERGY,ENERGY,138895,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,2,['ENERGY'],['ENERGY']
Energy Efficiency,"n(""SCF"", ""GUESS"", ""READ""); core.set_local_option(""SCF"", ""FRAC_DIIS"", frac_diis); core.set_local_option(""SCF"", ""DF_INTS_IO"", ""LOAD""). # => Run the neutral next <= #. molecule.set_molecular_charge(charge0); molecule.set_multiplicity(mult0). # Burn the neutral in with hf, if requested <= #. if not continuous_guess:; core.set_local_option(""SCF"", ""GUESS"", old_guess); if hf_guess:; core.set_local_option(""SCF"", ""FRAC_START"", 0); core.set_local_option(""SCF"", ""REFERENCE"", ""UHF""); driver.energy('scf', dft_functional=name, molecule=molecule, **kwargs); core.set_local_option(""SCF"", ""REFERENCE"", ""UKS""); core.set_local_option(""SCF"", ""GUESS"", ""READ""); # NYI core.set_local_option(""SCF"", ""FRAC_LOAD"", False). core.set_local_option(""SCF"", ""FRAC_START"", frac_start); core.set_local_option(""SCF"", ""FRAC_RENORMALIZE"", True). for occ in HOMO_occs:. core.set_local_option(""SCF"", ""FRAC_OCC"", [HOMO]); core.set_local_option(""SCF"", ""FRAC_VAL"", [occ]). E, wfn = driver.energy('scf', dft_functional=name, return_wfn=True, molecule=molecule, **kwargs); C = 1; if E == 0.0:; E = core.variable('SCF ITERATION ENERGY'); C = 0. if LUMO > 0:; eps = wfn.epsilon_a(); potentials.append(eps.get(int(HOMO) - 1)); else:; eps = wfn.epsilon_b(); potentials.append(eps.get(-int(HOMO) - 1)). occs.append(occ - 1.0); energies.append(E); convs.append(C). core.set_local_option(""SCF"", ""FRAC_START"", 2); # NYI core.set_local_option(""SCF"", ""FRAC_LOAD"", True); core.set_local_option(""SCF"", ""GUESS"", ""READ""); core.set_local_option(""SCF"", ""FRAC_DIIS"", frac_diis); core.set_local_option(""SCF"", ""DF_INTS_IO"", ""LOAD""). # => Print the results out <= #; E = {}; core.print_out(""""""\n ==> Fractional Occupation Traverse Results <==\n\n""""""); core.print_out("""""" %-11s %-24s %-24s %11s\n"""""" % ('N', 'Energy', 'HOMO Energy', 'Converged')); for k in range(len(occs)):; core.print_out("""""" %11.3E %24.16E %24.16E %11d\n"""""" % (occs[k], energies[k], potentials[k], convs[k])); E[occs[k]] = energies[k]. core.print_out(""""""; You trying to be a hero Watkins?; Ju",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/frac.html:7748,energy,energy,7748,psi4manual/1.7.x/_modules/psi4/driver/frac.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/frac.html,8,['energy'],['energy']
Energy Efficiency,"n(' TODO\n'). # Add member functionals; sup.add_c_functional(build_functional('wPW92_C')). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.3); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_wpbe_c_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('wPBE_C'); # Tab in, trailing newlines; sup.set_description(' Short-Range PBE Correlation Functional\n'); # Tab in, trailing newlines; sup.set_citation(' TODO\n'). # Add member functionals; sup.add_c_functional(build_functional('wPBE_C')). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.5); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_wpbe2_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('wPBE2'); # Tab in, trailing newlines; sup.set_description(' Double-Hybrid PBE LRC Functional\n'); # Tab in, trailing newlines; sup.set_citation(' TODO\n'). # Add member functionals; sup.add_x_functional(build_functional('wPBE_X')); sup.add_c_functional(build_functional('wPBE_C')). # Set GKS up after adding functionals; sup.set_x_omega(0.3); sup.set_c_omega(0.5); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_wb88_x_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/procedures/functional.html:24408,allocate,allocate,24408,psi4manual/1.0.0/_modules/procedures/functional.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/functional.html,1,['allocate'],['allocate']
Energy Efficiency,"n('FREEZE_CORE',""FALSE""); optimize('conv-mp2'); psi4.clean(). # qcisd(t); psi4.set_local_option('FNOCC','COMPUTE_MP4_TRIPLES',""TRUE""); psi4.set_global_option('FREEZE_CORE',""TRUE""); psi4.set_global_option('BASIS',""6-311G(D_P)""); run_fnocc('qcisd(t)',**kwargs). # HLC: high-level correction based on number of valence electrons; ref = psi4.wavefunction(); nirrep = ref.nirrep(); frzcpi = ref.frzcpi(); nfzc = 0; for i in range (0,nirrep):; nfzc += frzcpi[i]; nalpha = ref.nalpha() - nfzc; nbeta = ref.nbeta() - nfzc; # hlc of gaussian-2; hlc = -0.00481 * nalpha -0.00019 * nbeta; # hlc of gaussian-1; hlc1 = -0.00614 * nalpha. eqci_6311gdp = psi4.get_variable(""QCISD(T) TOTAL ENERGY""); emp4_6311gd = psi4.get_variable(""MP4 TOTAL ENERGY""); emp2_6311gd = psi4.get_variable(""MP2 TOTAL ENERGY""); psi4.clean(). # correction for diffuse functions; psi4.set_global_option('BASIS',""6-311+G(D_P)""); energy('mp4'); emp4_6311pg_dp = psi4.get_variable(""MP4 TOTAL ENERGY""); emp2_6311pg_dp = psi4.get_variable(""MP2 TOTAL ENERGY""); psi4.clean(). # correction for polarization functions; psi4.set_global_option('BASIS',""6-311G(2DF_P)""); energy('mp4'); emp4_6311g2dfp = psi4.get_variable(""MP4 TOTAL ENERGY""); emp2_6311g2dfp = psi4.get_variable(""MP2 TOTAL ENERGY""); psi4.clean(). # big basis mp2; psi4.set_global_option('BASIS',""6-311+G(3DF_2P)""); run_fnocc('_mp2',**kwargs); emp2_big = psi4.get_variable(""MP2 TOTAL ENERGY""); psi4.clean(). eqci = eqci_6311gdp; e_delta_g2 = emp2_big + emp2_6311gd - emp2_6311g2dfp - emp2_6311pg_dp; e_plus = emp4_6311pg_dp - emp4_6311gd; e_2df = emp4_6311g2dfp - emp4_6311gd. eg2 = eqci + e_delta_g2 + e_plus + e_2df; eg2_mp2_0k = eqci + (emp2_big - emp2_6311gd) + hlc + zpe. psi4.print_out('\n'); psi4.print_out(' ==> G1/G2 Energy Components <==\n'); psi4.print_out('\n'); psi4.print_out(' QCISD(T): %20.12lf\n' % eqci); psi4.print_out(' E(Delta): %20.12lf\n' % e_delta_g2); psi4.print_out(' E(2DF): %20.12lf\n' % e_2df); psi4.print_out(' E(+): %20.12lf\n' % e_plus); psi4.print_out(' E(",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/gaussian_n.html:3355,ENERGY,ENERGY,3355,psi4manual/4.0b5/_modules/gaussian_n.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/gaussian_n.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"n('SCF', 'GUESS', 'SAD'); else:; core.set_local_option('SCF', 'GUESS', 'CORE'). if core.get_global_option('BASIS') in ['', '(AUTO)']:; if name in ['hf3c', 'hf-3c']:; core.set_global_option('BASIS', 'minix'); elif name in ['pbeh3c', 'pbeh-3c']:; core.set_global_option('BASIS', 'def2-msvp'). # the FIRST scf call; if cast or do_broken:; # Cast or broken are special cases; base_wfn = core.Wavefunction.build(scf_molecule, core.get_global_option('BASIS')); core.print_out(""\n ---------------------------------------------------------\n"");; if banner:; core.print_out("" "" + banner.center(58));; if cast:; core.print_out("" "" + ""SCF Castup computation"".center(58));; ref_wfn = scf_wavefunction_factory(name, base_wfn, core.get_option('SCF', 'REFERENCE'), **kwargs); core.set_legacy_wavefunction(ref_wfn). # Compute additive correction: dftd3, mp2d, dftd4, etc.; if hasattr(ref_wfn, ""_disp_functor""):; disp_energy = ref_wfn._disp_functor.compute_energy(ref_wfn.molecule()); ref_wfn.set_variable(""-D Energy"", disp_energy); ref_wfn.compute_energy(). # broken clean-up; if do_broken:; raise ValidationError(""Broken Symmetry computations are temporarily disabled.""); scf_molecule.set_multiplicity(1); core.set_local_option('SCF', 'GUESS', 'READ'); core.print_out('\n'); p4util.banner(' Computing broken symmetry solution from high-spin triplet guess '); core.print_out('\n'). # cast clean-up; if cast:. # Move files to proper namespace; core.IO.change_file_namespace(180, guesspace, namespace); core.IO.set_default_namespace(namespace). optstash2.restore(). # Print the banner for the standard operation; core.print_out('\n'); p4util.banner(bannername.upper()); core.print_out('\n'). # the SECOND scf call; base_wfn = core.Wavefunction.build(scf_molecule, core.get_global_option('BASIS')); if banner:; core.print_out(""\n ---------------------------------------------------------\n"");; core.print_out("" "" + banner.center(58));. scf_wfn = scf_wavefunction_factory(name, base_wfn, core.get_option('SCF', 'REFERENC",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/procrouting/proc.html:43111,Energy,Energy,43111,psi4manual/1.5.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/procrouting/proc.html,1,['Energy'],['Energy']
Energy Efficiency,"n(). # Build string of title banner; cbsbanners = ''; cbsbanners += """"""PsiMod.print_out('\\n')\n""""""; cbsbanners += """"""banner(' CBS Results ')\n""""""; cbsbanners += """"""PsiMod.print_out('\\n')\n\n""""""; exec cbsbanners. # Insert obtained energies into the array that stores the cbs stages; for stage in GRAND_NEED:; for lvl in stage['d_need'].iteritems():; MODELCHEM.append(lvl[1]). for job in JOBS_EXT:; if ((lvl[1]['f_wfn'] == job['f_wfn']) and (lvl[1]['f_portion'] == job['f_portion']) and; (lvl[1]['f_basis'] == job['f_basis'])):; lvl[1]['f_energy'] = job['f_energy']. for stage in GRAND_NEED:; stage['d_energy'] = call_function_in_1st_argument(stage['d_scheme'], needname=stage['d_need'], mode='evaluate'); finalenergy += stage['d_energy'] * stage['d_coef']. # Build string of results table; table_delimit = ' ' + '-' * 105 + '\n'; tables = ''; tables += """"""\n ==> %s <==\n\n"""""" % ('Components'); tables += table_delimit; tables += """""" %6s %20s %1s %-26s %3s %16s %-s\n"""""" % ('', 'Method', '/', 'Basis', 'Rqd', 'Energy [H]', 'Variable'); tables += table_delimit; for job in JOBS_EXT:; star = ''; for mc in MODELCHEM:; if (job['f_wfn'] == mc['f_wfn']) and (job['f_basis'] == mc['f_basis']):; star = '*'; tables += """""" %6s %20s %1s %-27s %2s %16.8f %-s\n"""""" % ('', job['f_wfn'],; '/', job['f_basis'], star, job['f_energy'], VARH[job['f_wfn']][job['f_wfn'] + job['f_portion']]); tables += table_delimit. tables += """"""\n ==> %s <==\n\n"""""" % ('Stages'); tables += table_delimit; tables += """""" %6s %20s %1s %-27s %2s %16s %-s\n"""""" % ('Stage', 'Method', '/', 'Basis', 'Wt', 'Energy [H]', 'Scheme'); tables += table_delimit; for stage in GRAND_NEED:; tables += """""" %6s %20s %1s %-27s %2d %16.8f %-s\n"""""" % (stage['d_stage'], stage['d_wfn'],; '/', stage['d_basis'], stage['d_coef'], stage['d_energy'], stage['d_scheme'].__name__); tables += table_delimit. tables += """"""\n ==> %s <==\n\n"""""" % ('CBS'); tables += table_delimit; tables += """""" %6s %20s %1s %-27s %2s %16s %-s\n"""""" % ('Stage', 'Method', '/', 'Basis",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:71576,Energy,Energy,71576,psi4manual/4.0b2/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html,1,['Energy'],['Energy']
Energy Efficiency,"n(dashdderiv) != self.natom():; raise ValidationError('Program dftd3 gradient file has %d atoms- %d expected.' % \; (len(dashdderiv), self.natom())); psi_dashdderiv = psi4.Matrix(self.natom(), 3); psi_dashdderiv.set(dashdderiv). # Print program output to file if verbose; verbose = psi4.get_option('SCF', 'PRINT'); if verbose >= 3:; psi4.print_out('\n ==> DFTD3 Output <==\n'); psi4.print_out(out); dfile = open(derivfile, 'r'); psi4.print_out(dfile.read().replace('D', 'E')); dfile.close(); psi4.print_out('\n'). # Clean up files and remove scratch directory; os.unlink(paramfile); os.unlink(geomfile); os.unlink(derivfile); if defmoved is True:; os.rename(defaultfile + '_hide', defaultfile). os.chdir('..'); try:; shutil.rmtree(dftd3_tmpdir); except OSError as e:; ValidationError('Unable to remove dftd3 temporary directory %s' % e, file=sys.stderr); os.chdir(current_directory). # return -D & d(-D)/dx; psi4.set_variable('DISPERSION CORRECTION ENERGY', dashd); if dertype == -1:; return dashd, dashdderiv; elif dertype == 0:; return dashd; elif dertype == 1:; return psi_dashdderiv. [docs]def dynamic_variable_bind(cls):; """"""Function to dynamically add extra members to; the psi4.Molecule class. """"""; cls.__setattr__ = new_set_attr; cls.__getattr__ = new_get_attr; cls.BFS = BFS; cls.run_dftd3 = run_dftd3. dynamic_variable_bind(psi4.Molecule) # pass class type, not class instance. #; # Define geometry to be used by PSI4.; # The molecule created by this will be set in options.; #; # geometry(""; # O 1.0 0.0 0.0; # H 0.0 1.0 0.0; # H 0.0 0.0 0.0; #; [docs]def geometry(geom, name=""default""):; """"""Function to create a molecule object of name *name*; from the geometry in string *geom*. """"""; molecule = psi4.Molecule.create_molecule_from_string(geom); molecule.set_name(name). activate(molecule). return molecule. [docs]def activate(mol):; """"""Function to set molecule object *mol* as the current active molecule.""""""; psi4.set_active_molecule(mol); #psi4.IO.set_default_namespace(mol.get_name()).",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/molutil.html:12761,ENERGY,ENERGY,12761,psi4manual/4.0b5/_modules/molutil.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/molutil.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"n(indexlines)); print(""""""\n LaTeX index written to {filename}_index.tex\n""""""; """""" LaTeX table written to {filename}.tex\n""""""; """""" >>> pdflatex {filename}\n""""""; """""" >>> open /Applications/Preview.app {filename}.pdf\n"""""".format(filename=filename)); filedict = {'data': os.path.abspath(filename) + '.tex',; 'index': os.path.abspath(filename + '_index.tex')}; return filedict. [docs] def table_scrunch(self, plotpath, subjoin):; rowplan = ['mtd']; columnplan = [; ['l', r'Method', '', textables.label, {}],; ['c', r'Description', '', textables.empty, {}],; ['d', r'aug-cc-pVDZ', 'unCP', textables.val, {'bas': 'adz', 'opt': 'unCP'}],; ['d', r'aug-cc-pVDZ', 'CP', textables.val, {'bas': 'adz', 'opt': 'CP'}],; ['d', r'aug-cc-pVTZ', 'unCP', textables.val, {'bas': 'atz', 'opt': 'unCP'}],; ['d', r'aug-cc-pVTZ', 'CP', textables.val, {'bas': 'atz', 'opt': 'CP'}]]. footnotes = []; landscape = False; theme = 'summavg'; title = r""""""Classification and Performance of model chemistries. Interaction energy [kcal/mol] {{err}} statistics."""""".format(); return rowplan, columnplan, landscape, footnotes, title, theme. [docs] def table_merge_abbr(self, plotpath, subjoin):; """"""Specialization of table_generic into table with minimal statistics; (three S22 and three overall) plus embedded slat diagram as suitable; for main paper. A single table is formed in sections by *bas* with; lines *mtd* within each section. """"""; rowplan = ['bas', 'mtd']; columnplan = [; ['l', r""""""Method \& Basis Set"""""", '', textables.label, {}],; ['d', r'S22', 'HB', textables.val, {'sset': 'hb', 'dbse': 'S22'}],; ['d', r'S22', 'MX/DD', textables.val, {'sset': 'mxdd', 'dbse': 'S22'}],; ['d', r'S22', 'TT', textables.val, {'sset': 'tt', 'dbse': 'S22'}],; ['d', r'Overall', 'HB', textables.val, {'sset': 'hb', 'dbse': 'DB4'}],; ['d', r'Overall', 'MX/DD', textables.val, {'sset': 'mxdd', 'dbse': 'DB4'}],; ['d', r'Overall', 'TT', textables.val, {'sset': 'tt', 'dbse': 'DB4'}],; ['l', r""""""Error Distribution\footnotemark[1]"""""",; r""""""\include",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:102462,energy,energy,102462,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html,1,['energy'],['energy']
Energy Efficiency,"n(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]; class QMMM():; """"""Hold charges and :py:class:`psi4.core.ExternalPotential`. Use :py:class:`psi4.driver.QMMMbohr` instead."""""". def __init__(self):; raise UpgradeHelper(self.__class__.__name__, ""QMMMbohr"", 1.6, ' Replace object with a list of charges and locations in Bohr passed as keyword argument, e.g., `energy(..., external_potentials=[[0.5, [0, 0, 1]], [-0.5, [0, 0, -1]]])`.'). [docs]; class QMMMbohr():; """"""Hold charges and :py:class:`psi4.core.ExternalPotential`. To add external charges to a calculation, prefer; passing the array of charges with kwarg ``external_potentials``, as in extern2 example."""""". def __init__(self):; self.charges = []; self.diffuses = []; self.extern = core.ExternalPotential(). [docs]; def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs]; def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs]; def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / constants.bohr2angstroms, y / constants.bohr2angstroms, z / constants.bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(0, len(self.diffuses)):; s = s + str(self.diffuses[k]). return s. [docs]; def populateExtern(self):; """"""Function to defin",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qmmm.html:4245,charge,charge,4245,psi4manual/1.8.x/_modules/psi4/driver/qmmm.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qmmm.html,6,['charge'],['charge']
Energy Efficiency,"n(self: psi4.core.Molecule) → str; Gets point group name such as Cnv or Sn. get_variable(self: psi4.core.Molecule, arg0: str) → float; Returns the value of variable arg0 in the structural variables list. inertia_tensor(self: psi4.core.Molecule) → psi4.core.Matrix; Returns intertial tensor. input_units_to_au(self: psi4.core.Molecule) → float; Returns unit conversion to [a0] for geometry. irrep_labels(self: psi4.core.Molecule) → List[str]; Returns Irreducible Representation symmetry labels. is_variable(self: psi4.core.Molecule, arg0: str) → bool; Checks if variable arg0 is in the structural variables list. label(self: psi4.core.Molecule, atom: int) → str; Gets the original label of the atom as given in the input file (C2, H4)(0-indexed without dummies). mass(self: psi4.core.Molecule, atom: int) → float; Returns mass of atom (0-indexed). mass_number(self: psi4.core.Molecule, arg0: int) → int; Mass number (A) of atom if known, else -1. molecular_charge(self: psi4.core.Molecule) → int; Gets the molecular charge. move_to_com(self: psi4.core.Molecule) → None; Moves molecule to center of mass. multiplicity(self: psi4.core.Molecule) → int; Gets the multiplicity (defined as 2Ms + 1). nallatom(self: psi4.core.Molecule) → int; Number of real and dummy atoms. name(self: psi4.core.Molecule) → str; Gets molecule name. natom(self: psi4.core.Molecule) → int; Number of real atoms. nfragments(self: psi4.core.Molecule) → int; Gets the number of fragments in the molecule. nuclear_dipole(*args, **kwargs); Overloaded function. nuclear_dipole(self: psi4.core.Molecule, arg0: psi4.core.Vector3) -> psi4.core.Vector3. Gets the nuclear contribution to the dipole, with respect to a specified origin atg0. nuclear_dipole(self: psi4.core.Molecule) -> psi4.core.Vector3. Gets the nuclear contribution to the dipole, with respect to the origin. nuclear_repulsion_energy(self: psi4.core.Molecule, dipole_field: List[float[3]]=[0.0, 0.0, 0.0]) → float; Computes nuclear repulsion energy. nuclear_repulsion_en",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.molecule.html:49816,charge,charge,49816,psi4manual/1.3.2/api/psi4.core.molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.molecule.html,1,['charge'],['charge']
Energy Efficiency,"n) represent what we; regard as the best estimate available at a given level of SAPT computed; from a subset of the terms of that grouping. The groupings shown above are; not unique and are certainly not rigorously defined. We regard the groupings; used in Psi4 as a “chemist’s grouping” as opposed to a more; mathematically based grouping, which would group all exchange terms; (i.e. , , etc.) in; the exchange component. A final note is that both Disp22(T); and Est.Disp22(T) results appear if MP2 natural orbitals are; used to evaluate the triples correction to dispersion. The Disp22(T); result is the triples correction as computed in the truncated NO basis;; Est.Disp22(T) is a scaled result that attempts to recover; the effect of the truncated virtual space and is our best estimate. The Est.Disp22(T); value is used in the SAPT energy and dispersion component (see [Hohenstein:2010:104107]; for details). Finally, this part of the output file contains sSAPT0, a special scaling; scheme of the SAPT0 energy that can yield improved results and was described in more details; above. The corresponding scaled total component energies are printed as well.; As mentioned above, SAPT results with scaled exchange are also optionally available; by setting the EXCH_SCALE_ALPHA keyword. When activated, the unscaled results are; printed first as reported above, and then repeated with exchange scaling for all; relevant terms:; SAPT Results ==> ALL S2 TERMS SCALED (see Manual) <==. Scaling factor (Exch10/Exch10(S^2))^{Alpha} = 1.007200; with Alpha = 1.000000; --------------------------------------------------------------------------------------------------------; Electrostatics -13.06509118 [mEh] -8.19846883 [kcal/mol] -34.30239689 [kJ/mol]; Elst10,r -13.37542977 [mEh] -8.39320925 [kcal/mol] -35.11719087 [kJ/mol]; Elst12,r 0.04490350 [mEh] 0.02817737 [kcal/mol] 0.11789413 [kJ/mol]; Elst13,r 0.26543510 [mEh] 0.16656305 [kcal/mol] 0.69689985 [kJ/mol]. Exchange sc. 13.43351854 [mEh] 8.42966050",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/sapt-1.html:24862,energy,energy,24862,psi4manual/1.0.0/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/sapt-1.html,2,['energy'],['energy']
Energy Efficiency,"n) → psi4.core.Vector¶; Returns the set atomic point charges. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.Wavefunction, basis: psi4.core.BasisSet) → psi4.core.Wavefunction¶; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet basis. ci_nat_orbs(self: psi4.core.CIWavefunction) → None¶; docstring. cleanup_ci(self: psi4.core.CIWavefunction) → None¶; docstring. cleanup_dpd(self: psi4.core.CIWavefunction) → None¶; docstring. compute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. compute_state_transfer(self: psi4.core.CIWavefunction, arg0: psi::detci::CIvect, arg1: int, arg2: psi4.core.Matrix, arg3: psi::detci::CIvect) → None¶; docstring. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Deep copies the internal data. del_array_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) Matrix QC variable. del_scalar_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) double QC variable. del_variable(key)¶. density_fitted(self: psi4.core.Wavefunction) → bool¶; Returns whether this wavefunction was obtained using density fitting or not. diag_h(self: psi4.core.CIWavefunction, arg0: float, arg1: float) ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psi4api-1.html:24550,energy,energy,24550,psi4manual/1.3.2/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psi4api-1.html,2,['energy'],['energy']
Energy Efficiency,"n, & Wilson,; Chem. Phys. Lett. 286 (1998) 243-252,; DOI: 10.1016/S0009-2614(99)00179-7. """"""; if type(valueLO) != type(valueHI):; raise ValidationError(; ""corl_xtpl_helgaker_2: Inputs must be of the same datatype! (%s, %s)"" % (type(valueLO), type(valueHI))). if alpha is None:; alpha = 3.0. if isinstance(valueLO, float):; value = (valueHI * zHI**alpha - valueLO * zLO**alpha) / (zHI**alpha - zLO**alpha); beta = (valueHI - valueLO) / (zHI**(-alpha) - zLO**(-alpha)). # final = valueSCF + value; final = value; if verbose:; # Output string with extrapolation parameters; cbsscheme = """"""\n\n ==> Helgaker 2-point correlated extrapolation for method: %s <==\n\n"""""" % (; functionname.upper()); # cbsscheme += """""" HI-zeta (%1s) SCF Energy: % 16.12f\n"""""" % (str(zHI), valueSCF); cbsscheme += """""" LO-zeta (%s) Energy: % 16.12f\n"""""" % (str(zLO), valueLO); cbsscheme += """""" HI-zeta (%s) Energy: % 16.12f\n"""""" % (str(zHI), valueHI); cbsscheme += """""" Alpha (exponent) Value: % 16.12f\n"""""" % alpha; cbsscheme += """""" Extrapolated Energy: % 16.12f\n\n"""""" % value; #cbsscheme += """""" LO-zeta (%s) Correlation Energy: % 16.12f\n"""""" % (str(zLO), valueLO); #cbsscheme += """""" HI-zeta (%s) Correlation Energy: % 16.12f\n"""""" % (str(zHI), valueHI); #cbsscheme += """""" Beta (coefficient) Value: % 16.12f\n"""""" % beta; #cbsscheme += """""" Extrapolated Correlation Energy: % 16.12f\n\n"""""" % value. name_str = ""%s/(%s,%s)"" % (functionname.upper(), _zeta_val2sym[zLO].upper(), _zeta_val2sym[zHI].upper()); cbsscheme += """""" @Extrapolated """"""; cbsscheme += name_str + ':'; cbsscheme += "" "" * (19 - len(name_str)); cbsscheme += """"""% 16.12f\n\n"""""" % final; core.print_out(cbsscheme). return final. elif isinstance(valueLO, (core.Matrix, core.Vector)):. beta = valueHI.clone(); beta.subtract(valueLO); beta.scale(1 / (zHI**(-alpha) - zLO**(-alpha))); beta.name = 'Helgaker Corl (%s, %s) beta' % (zLO, zHI). value = valueHI.clone(); value.scale(zHI**alpha). tmp = valueLO.clone(); tmp.scale(zLO**alpha); value.subtract(tmp). value.scale(1",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:21611,Energy,Energy,21611,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,2,['Energy'],['Energy']
Energy Efficiency,"n, IJQC 98, 601-611 (1998). casscf-fzc-sp; CASSCF/6-31G** energy point. scf-coverage; Lithium test for coverage. olccd3; OLCCD cc-pVDZ energy with ROHF initial guess for the NO radical. mp2-grad1; MP2 cc-pVDZ gradient for the H2O molecule. dfmp2-2; Density fitted MP2 energy of H2, using density fitted reference and automatic looping over cc-pVDZ and cc-pVTZ basis sets. Results are tabulated using the built in table functions by using the default options and by specifiying the format. opt12; SCF cc-pVDZ geometry optimzation of ketene, starting from bent structure. dfmp2-4; conventional and density-fitting mp2 test of mp2 itself and setting scs-mp2. cisd-sp; 6-31G** H2O Test CISD Energy Point. sapt5; SAPT0 aug-cc-pVTZ computation of the charge transfer energy of the water dimer. dct4; DCT calculation for the HF+ using DC-06 functional. This performs both two-step and simultaneous update of the orbitals and cumulant using DIIS extrapolation. Four-virtual integrals are first handled in the MO Basis for the first two energy computations. In the next two the ao_basis=disk algorithm is used, where the transformation of integrals for four-virtual case is avoided. The computation is then repeated using the DC-12 functional with the same algorithms. props4; Electrostatic potential and electric field evaluated on a grid around water. sapt3; SAPT2+3(CCD) aug-cc-pVDZ+midbond computation of the water dimer interaction energy, using the aug-cc-pVDZ-JKFIT DF basis for SCF and aug-cc-pVDZ-RI for SAPT. mp2-1; All-electron MP2 6-31G** geometry optimization of water. sapt1; SAPT0 cc-pVDZ computation of the ethene-ethyne interaction energy, using the cc-pVDZ-JKFIT RI basis for SCF and cc-pVDZ-RI for SAPT. Monomer geometries are specified using Cartesian coordinates. tdscf-3; td-wb97x excitation energies of singlet states of h2o, wfn passing. dft2; DFT Functional Test. dfomp2-grad2; OMP2 cc-pVDZ energy for the NO molecule. aediis-1; ADIIS test case, from 10.1063/1.3304922. soscf-dft; Tri",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html:25266,energy,energy,25266,psi4manual/master/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"n, Z-matrix, or mixture thereof, specifications and then place two; dashes between nonbonded fragments. For example, to study the interaction; energy of ethane and ethyne molecules, we can use the following molecule; block:; molecule eneyne {; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.923621 1.232253 -2.126185; --; 0 1; C 0.000000 0.000000 2.900503; C 0.000000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; }. This specifies that there are two neutral, spin-singlet fragments. It is; possible to further specify that the overall complex is neutral and spin-singlet; by inserting another charge multiplicity line, separated from the first; molecule block by a – line. If any information is missing, PSI4 will set the; unprovided charges and multiplicities to be consistent with those that are given.; For example, the overall charge must be simply the sum of all fragment charges.; PSI4 further assumes that any unpaired electrons are coupled to yield the highest; possible \(M_s\) value. Psi will also favor neutral, spin-singlet fragments.; For anything complicated, we strongly suggest explicitly providing the charge; and multiplicity of each fragment as well as the total molecular charge and multiplicity. For details and examples, see https://github.com/MolSSI/QCElemental/blob/master/qcelemental/molparse/chgmult.py#L105-L136 .; Having defined a molecule containing fragments like eneyne above, it; is a simple matter to perform calculations on only a subset of the; fragments. For instance, the commands below run a scf first on the ethene; fragment alone (extract_subsets(1) pulls out fragment 1 as Real atoms; and discards remaining fragments) and next on the ethene fragment with the; ethyne fragment ghosted (extract_subsets(1,2) pulls out fragment 1 as; Real atoms and sets fragment 2 as Ghost atoms). For beyond bimolecular; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/psithonmol.html:15416,charge,charge,15416,psi4manual/1.8.x/psithonmol.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/psithonmol.html,6,['charge'],"['charge', 'charges']"
Energy Efficiency,"n, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.CUHF, basis: psi4.core.BasisSet) → psi4.core.CUHF; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet basis. check_phases(self: psi4.core.HF) → None¶; docstring. clear_external_potentials(self: psi4.core.HF) → None¶; Clear private external_potentials list. compute_E(self: psi4.core.HF) → float¶; docstring. compute_energy()¶; Base class Wavefunction requires this function. Here it is; simply a wrapper around initialize(), iterations(), finalize_energy(). It; returns the SCF energy computed by finalize_energy(). compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. compute_initial_E(self: psi4.core.HF) → float¶; docstring. compute_orbital_gradient(self: psi4.core.HF, arg0: bool, arg1: int) → float¶; docstring. compute_spin_contamination(self: psi4.core.HF) → None¶; docstring. cphf_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix]) → List[psi4.core.Matrix]¶; CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self: psi4.core.HF) → bool¶; Adds occupied guess alpha orbitals. cphf_solve(self: psi4.core.HF, x_vec: List[psi4.core.Matrix], conv_tol: float, max_iter: int, print_lvl: int=2) → List[psi4.core.Matrix]¶; Solves the CPHF equations for a given set of x vectors. damping_update(self: psi4.core.HF, arg0: float) → None¶; docstring. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wav",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.cuhf.html:4298,energy,energy,4298,psi4manual/1.3.2/api/psi4.core.cuhf.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.cuhf.html,1,['energy'],['energy']
Energy Efficiency,"n, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.ROHF, basis: psi4.core.BasisSet) → psi4.core.ROHF; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet basis. check_phases(self: psi4.core.HF) → None¶; docstring. clear_external_potentials(self: psi4.core.HF) → None¶; Clear private external_potentials list. compute_E(self: psi4.core.HF) → float¶; docstring. compute_energy()¶; Base class Wavefunction requires this function. Here it is; simply a wrapper around initialize(), iterations(), finalize_energy(). It; returns the SCF energy computed by finalize_energy(). compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. compute_initial_E(self: psi4.core.HF) → float¶; docstring. compute_orbital_gradient(self: psi4.core.HF, arg0: bool, arg1: int) → float¶; docstring. compute_spin_contamination(self: psi4.core.HF) → None¶; docstring. cphf_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix]) → List[psi4.core.Matrix]¶; CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self: psi4.core.HF) → bool¶; Adds occupied guess alpha orbitals. cphf_solve(self: psi4.core.HF, x_vec: List[psi4.core.Matrix], conv_tol: float, max_iter: int, print_lvl: int=2) → List[psi4.core.Matrix]¶; Solves the CPHF equations for a given set of x vectors. damping_update(self: psi4.core.HF, arg0: float) → None¶; docstring. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wav",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.rohf.html:4548,energy,energy,4548,psi4manual/1.3.2/api/psi4.core.rohf.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.rohf.html,1,['energy'],['energy']
Energy Efficiency,"n, arg0: psi4.core.Wavefunction) → None¶; Deep copies the internal data. del_array_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) Matrix QC variable. del_potential_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) ExternalPotential QC variable. (This function is provisional and might be removed in the future.). del_scalar_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) double QC variable. del_variable(key)¶; Removes scalar or array QCVariable key from cls if present. Return type; None. Parameters. cls (psi4.core.Wavefunction) – ; key (str) – . density_fitted(self: psi4.core.Wavefunction) → bool¶; Returns whether this wavefunction was obtained using density fitting or not. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. efzc(self: psi4.core.Wavefunction) → float¶; Returns the frozen-core energy. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunction’s energy. epsilon_a(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Alpha Eigenvalues subset. epsilon_b(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Beta Eigenvalues subset. esp_at_nuclei(self: psi4.core.Wavefunction) → psi4.core.Vector¶; returns electrostatic potentials at nuclei. external_pot(self: psi4.core.Wavefunction) → psi4.core.ExternalPotential¶; Gets the requested external potential. force_doccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶; Specialized expert use only. Sets the number of doubly occupied oribtals per irrep. Note that this results in inconsistent Wavefun",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ccwavefunction.html:13860,energy,energy,13860,psi4manual/1.4.0/api/psi4.core.ccwavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ccwavefunction.html,4,['energy'],['energy']
Energy Efficiency,"n, arg0: psi4.core.Wavefunction) → None¶; Deep copies the internal data. del_array_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) Matrix QC variable. del_potential_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) ExternalPotential QC variable. (This function is provisional and might be removed in the future.). del_scalar_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) double QC variable. del_variable(key)¶; Removes scalar or array QCVariable key from cls if present. Return type; None. Parameters. cls (psi4.core.Wavefunction) – ; key (str) – . density_fitted(self: psi4.core.Wavefunction) → bool¶; Returns whether this wavefunction was obtained using density fitting or not. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. efzc(self: psi4.core.Wavefunction) → float¶; Returns the frozen-core energy. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunction’s energy. epsilon_a(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, basis: str, subset: str) → psi4.core.Vector¶; Returns the requested Alpha orbital energies subset. Parameters. basis – {‘AO’, ‘SO’, ‘MO’}; MO or SO select for Pitzer-ordering the return vector in the full computational point group symmetry.; AO selects for Pitzer-ordering the return vector without point group symmetry.; subset – {‘ALL’, ‘ACTIVE’, ‘FROZEN’, ‘OCC’, ‘VIR’, ‘FROZEN_OCC’, ‘ACTIVE_OCC’, ‘ACTIVE_VIR’, ‘FROZEN_VIR’}; Which subspace of orbital energies should be returned?. Returns; A Pitzer-ordered vector of the orbitals. Return type; Vector. epsilon_b(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, basis: str, subset: str) → psi4.core.Vector¶; Returns th",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.core.ccwavefunction.html:13934,energy,energy,13934,psi4manual/1.5.0/api/psi4.core.ccwavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.core.ccwavefunction.html,12,['energy'],['energy']
Energy Efficiency,"n, scanning the dissociation coordinate with Python’s built-in loop mechanism. The geometry is specified by a Z-matrix with dummy atoms, fixed parameters, updated parameters, and separate charge/multiplicity specifiers for each monomer. One-electron properties computed for dimer and one monomer. cc12; Single point energies of multiple excited states with EOM-CCSD. rasci-c2-active; 6-31G* C2 Test RASCI Energy Point, testing two different ways of specifying the active space, either with the ACTIVE keyword, or with RAS1, RAS2, RESTRICTED_DOCC, and RESTRICTED_UOCC. dfccsd-grad1; DF-CCSD cc-pVDZ gradients for the H2O molecule. cc7; Tests CCENERGY’s CCSD gradient in the presence of a dipole field. cc25; Single point gradient of 1-2B2 state of H2O+ with EOM-CCSD. opt-freeze-coords; SCF/cc-pVDZ optimization example with frozen cartesian. sapt0-d; Tests SAPT0-D corrections, with a variety of damping functions/parameters. omp2-1; OMP2 cc-pVDZ energy for the H2O molecule. tu1-h2o-energy; Sample HF/cc-pVDZ H2O computation. opt-multi-frozen-dimer-c2h; Frozen-fragment opt of C2h methane dimer with user-combined reference points. dct1; DC-06, DC-12, ODC-06 and ODC-12 calculation for the He dimer. This performs a simultaneous update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the MO Basis. cc16; ROHF and UHF-B-CCD(T)/cc-pVDZ \(^{3}B_1\) CH2 single-point energy (fzc, MO-basis \(\langle ab|cd \rangle\) ). x2c3; Test of SFX2C-1e on Water uncontracted cc-pVDZ The reference numbers are from Lan Cheng’s implementation in Cfour. mp2-h; check that methods can act on single atom. sapt3; SAPT2+3(CCD) aug-cc-pVDZ+midbond computation of the water dimer interaction energy, using the aug-cc-pVDZ-JKFIT DF basis for SCF and aug-cc-pVDZ-RI for SAPT. fci-dipole; 6-31G H2O Test FCI Energy Point. dfomp2p5-1; DF-OMP2.5 cc-pVDZ energy for the H2O molecule. sapt-dft-api; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. cbs-xtpl-wrapper; RH",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html:18194,energy,energy,18194,psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"n-OO theoretical methods accessible through OCC/DFOCC¶. name; calls method; plain; FNO. mp2; second-order MP perturbation theory; E/G; n/a. mp2.5; average of MP2 and MP3; E/G. mp3; third-order MP perturbation theory; E/G. remp2; second-order retaining-the-excitation-degree MP hybrid PT; E. lccd; linear coupled cluster doubles; E/G. ccd; coupled cluster doubles; E/G. ccsd; coupled cluster singles and doubles; E/G. ccsd(t); coupled cluster singles and doubles with perturbative triples; E/G. a-ccsd(t); CCSD with asymmetric perturbative triples; E. Detailed non-orbital-optimized capabilities of the OCC module. “✓” runs analytically. Single underline “✓̲” is default module when QC_MODULE unspecified. Double underline “✓̳” is default algorithm type when type selector (e.g., CC_TYPE) unspecified.¶. ◻; ◻; name ↓ →; ◻; ◻. ◻; REFERENCE →; ◻; type[5] ↓ →; FREEZE_CORE[6]→. QC_MODULE=OCC Capabilities. Restricted (RHF); Unrestricted (UHF); Restricted Open (ROHF). energy(); gradient()[7]; energy(); gradient()[7]; energy(); gradient()[7]. CV; DF; CD; CV; DF; CD; CV; DF; CD; CV; DF; CD; CV; DF; CD; CV; DF; CD. A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F. mp2; MP2_TYPE; ✓̲; ✓̲; ✓; ✓; ✓̲; ✓̲; ✓̲. ✓; ✓. ✓̲; ✓̲; ✓; ✓; ✓̲; ✓̲; ✓̲. ✓̳; ✓̳. ✓̲; ✓̲; ✓; ✓; ✓̲; ✓̲. mp2.5; MP_TYPE; ✓̲; ✓̲; ✓̳; ✓̳; ✓̲; ✓̲; ✓̲. ✓̳; ✓̳. ✓̲; ✓̲; ✓̳; ✓̳; ✓̲; ✓̲; ✓̲. ✓̳; ✓̳. mp3; MP_TYPE; ✓̲; ✓̲; ✓̳; ✓̳; ✓̲; ✓̲; ✓̲. ✓̳; ✓̳. ✓̲; ✓̲; ✓̳; ✓̳; ✓̲; ✓̲; ✓̲. ✓̳; ✓̳. remp2; CC_TYPE; ✓̳; ✓̳; ✓̲; ✓̲; ✓̲; ✓̲. ✓̳; ✓̳; ✓̲; ✓̲; ✓̲; ✓̲. lccd; CC_TYPE; ✓; ✓; ✓̲; ✓̲; ✓̲; ✓̲; ✓̳. ✓̲; ✓̲. ✓̳; ✓̳; ✓̲; ✓̲; ✓̲; ✓̲; ✓̳. ✓̲; ✓̲. ccd; CC_TYPE. ✓̲; ✓̲; ✓̲; ✓̲. ✓̲; ✓̲. ✓̲; ✓̲; ✓̲; ✓̲. ✓̲; ✓̲. ccsd; CC_TYPE. ✓; ✓; ✓; ✓. ✓̲; ✓̲. ✓̲; ✓̲; ✓̲; ✓̲. ✓̲; ✓̲. ccsd(t); CC_TYPE. ✓; ✓; ✓; ✓. ✓̲; ✓̲. a-ccsd(t)[8]; CC_TYPE. ✓̲; ✓̲; ✓̲; ✓̲. [5]; Algorithm type selection keyword below. Values to the right: conventional CV, density-fitted DF, and Cholesky-decomposed CD. [6]; Active orbital values t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/occ.html:20155,energy,energy,20155,psi4manual/1.7.x/occ.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/occ.html,12,['energy'],['energy']
Energy Efficiency,"n-convcrit; Advanced python example sets different sets of scf/post-scf conv crit and check to be sure computation has actually converged to the expected accuracy. dfomp3-grad2; DF-OMP3 cc-pVDZ gradients for the H2O+ cation. mbis-6; MBIS calculation on H2O. omp2-3; OMP2 cc-pVDZ energy for the NO radical. castup1; Test of SAD/Cast-up (mainly not dying due to file weirdness). mp2p5-grad2; MP2.5 cc-pVDZ gradient for the NO radical. cbs-xtpl-gradient; Various gradients for a strained helium dimer and water molecule. psithon1; Spectroscopic constants of H2, and the full ci cc-pVTZ level of theory. cdoremp-energy1; Cholesky decomposed OO-REMP/cc-pVDZ energy for the H2O molecule. density-screen-1; RHF Density Matrix based-Integral Screening Test for water. numpy-array-interface; Numpy interface testing. mints1; Symmetry tests for a range of molecules. This doesn’t actually compute any energies, but serves as an example of the many ways to specify geometries in Psi4. dfomp2-grad2; OMP2 cc-pVDZ energy for the NO molecule. linK-3; UHF and ROHF Linear Exchange Algorithm test for benzyl cation. cc13d; Tests analytic CC2 gradients. cc49; EOM-CC3(UHF) on CH radical with user-specified basis and properties for particular root. cc13a; UHF-CCSD(T)/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. scf3; File retention, docc, socc, and bond distances specified explicitly. phi-ao; Test computing values of basis functions (puream and non-puream) at points. fsaptd-terms; F-SAPT0/jun-cc-pvdz procedure for methane dimer. omp3-4; SCS-OMP3 cc-pVDZ geometry optimization for the H2O molecule. scf-hess5; DF SCF 6-31G analytical vs finite-difference tests Tests DF UHF hessian code for Ca != Cb. fisapt-siao1; This test case shows an example of running the I-SAPT0/jun-cc-pVDZ computation for 2,4-pentanediol (targeting the intramolecular hydrogen bond between the two hydroxyl groups) The SIAO1 link partitioning algorithm is used. An F-SAPT partitioning follows I-SAPT. cc42; RHF-C",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html:41533,energy,energy,41533,psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"n-shell computation of CN - Ne interaction energy First with jun-cc-pVDZ and density fitted integrals with ROHF Then with cc-pVDZ and direct integrals, except for dispersion that is computed with cc-pVDZ-ri density fitting with ROHF. psimrcc-fd-freq1; Mk-MRCCSD single point. \(^3 \Sigma ^-\) O2 state described using the Ms = 0 component of the triplet. Uses ROHF triplet orbitals. mom; Maximum Overlap Method (MOM) Test. MOM is designed to stabilize SCF convergence and to target excited Slater determinants directly. props2; DF-SCF cc-pVDZ of benzene-hydronium ion, scanning the dissociation coordinate with Python’s built-in loop mechanism. The geometry is specified by a Z-matrix with dummy atoms, fixed parameters, updated parameters, and separate charge/multiplicity specifiers for each monomer. One-electron properties computed for dimer and one monomer. castup1; Test of SAD/Cast-up (mainly not dying due to file weirdness). fcidump; test FCIDUMP functionality for rhf/uhf. fnocc5; Test FNO-DF-CCSD(T) energy. cepa3; cc-pvdz H2O Test coupled-pair CISD against DETCI CISD. cc12; Single point energies of multiple excited states with EOM-CCSD. extern1; External potential calculation involving a TIP3P water and a QM water. Finite different test of the gradient is performed to validate forces. fnocc4; Test FNO-DF-CCSD(T) energy. fd-freq-energy-large; SCF DZ finite difference frequencies by energies for C4NH4. cc54; CCSD dipole with user-specified basis set. dft-grad-lr2; Tests CAM gradients with and without XC pieces to narrow grid error. sapt-dft1; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. fci-h2o-fzcv; 6-31G H2O Test FCI Energy Point. pywrap-alias; Test parsed and exotic calls to energy() like zapt4, mp2.5, and cisd are working. cc4a; RHF-CCSD(T) cc-pVQZ frozen-core energy of the BH molecule, with Cartesian input. This version tests the FROZEN_DOCC option explicitly. sad1; Test of the superposition of atomic densities (SAD) guess, using a highly distort",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html:7964,energy,energy,7964,psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"n. Return type; float or numpy.ndarray or Matrix. Parameters. cls (psi4.core.Wavefunction) – ; key (str) – . Example; >>> g, wfn = psi4.gradient(""hf/cc-pvdz"", return_wfn=True); >>> wfn.variable(""CURRENT ENERGY""); -100.00985995185668; >>> wfn.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> wfn.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> wfn.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). variables(include_deprecated_keys=False)¶; Return all scalar or array QCVariables from cls. Return type; Dict[str, Union[float, Matrix, ndarray]]. Parameters; include_deprecated_keys (bool) – . write_molden(filename=None, do_virtual=None, use_natural=False)¶; Function to write wavefunction information in wfn to filename in; molden format. Will write natural orbitals from density (MO basis) if supplied.; Warning! Most post-SCF Wavefunctions do not build the density as this is often; much more costly than the energy. In addition, the Wavefunction density attributes; (Da and Db) return the SO density and must be transformed to the MO basis; to use with this function. New in version 0.5: wfn parameter passed explicitly. Returns; None. Parameters. filename (string) – destination file name for MOLDEN file (optional); do_virtual (bool) – do write all the MOs to the MOLDEN file (true) or discard the unoccupied MOs, not valid for NO’s (false) (optional); use_natural (bool) – write natural orbitals determined from density on wavefunction. Examples. Molden file with the Kohn-Sham orbitals of a DFT calculation.; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> wfn.molden('mycalc.molden'). Molden file with the natural orbitals of a CCSD computation. For correlated methods, an energy call will not compute the density.; “properties” or “gradient” must be called.; >>> E, wfn = properties('ccsd', return_wfn=True); >>> wfn.molden('ccsd_no.molden', use_nat",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ccwavefunction.html:25575,energy,energy,25575,psi4manual/1.4.0/api/psi4.core.ccwavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ccwavefunction.html,49,['energy'],['energy']
Energy Efficiency,"n. The split-virtual CISD[TQ] takes all singles and doubles, and all triples and quadruples with no more than 2 electrons in the secondary virtual subspace (RAS 3). If any electrons are present in the tertiary virtual subspace (RAS 4), then that excitation is only allowed if it is a single or double. cc5a; RHF CCSD(T) STO-3G frozen-core energy of C4NH4 Anion. pywrap_cbs1; Various basis set extrapolation tests. mcscf3; RHF 6-31G** energy of water, using the MCSCF module and Z-matrix input. frac; Carbon/UHF Fractionally-Occupied SCF Test Case. psimrcc-sp1; Mk-MRCCSD single point. O2 state described using the Ms = 0 component of the triplet. Uses ROHF triplet orbitals. fd-freq-gradient; STO-3G frequencies for H2O by finite-differences of gradients. cc13; UHF-CCSD/cc-pVDZ CH2 geometry optimization via analytic gradients. cc34; RHF-CCSD/cc-pVDZ energy of H2O partitioned into pair energy contributions. cisd-opt-fd; H2O CISD/6-31G** Optimize Geometry by Energies. mrcc1; CCSDT cc-pVDZ energy for the H2O molecule using MRCC. cc49; EOM-CC3(UHF) on CH radical with user-specified basis and properties for particular root. cc41; RHF-CC2-LR/cc-pVDZ optical rotation of H2O2. gauge = both, omega = (589 355 nm). sapt1; SAPT0 cc-pVDZ computation of the ethene-ethyne interaction energy, using the cc-pVDZ-JKFIT RI basis for SCF and cc-pVDZ-RI for SAPT. Monomer geometries are specified using Cartesian coordinates. cc39; RHF-CC2-LR/cc-pVDZ dynamic polarizabilities of HOF molecule. cisd-h2o+-2; 6-31G** H2O+ Test CISD Energy Point. mints2; A test of the basis specification. A benzene atom is defined using a ZMatrix containing dummy atoms and various basis sets are assigned to different atoms. The symmetry of the molecule is automatically lowered to account for the different basis sets. pywrap_db1; Database calculation, so no molecule section in input file. Portions of the full databases, restricted by subset keyword, are computed by sapt0 and dfmp2 methods. opt2-fd; SCF DZ allene geometry op",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodoc_testsuite-1.html:4464,energy,energy,4464,psi4manual/4.0b2/autodoc_testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodoc_testsuite-1.html,4,['energy'],['energy']
Energy Efficiency,"n. These are in the case of RHF/UHF the usual canonical HF orbitals and in the case of ROHF calculations the standard ROHF-orbitals with equal spatial parts for both the and the spin orbitals. SEMICANONICAL (=1) forces in ROHF type calculations a transformation to so-called semicanonical orbitals which diagonalize the occupied-occupied and virtual-virtual blockes of the usual Fock-matrices. The use of semicanonical orbitals is, for example, required for ROHF-CCSD(T) calculations and for those calculations also automatically set. LOCAL requests a localization of the HF orbitals and this is currently done according to the Pipek-Mezey localization criterion. Note that it is strongly recommended not to use this keyword unless you know what are you doing. Default: STANDARD except for ROHF-CCSD(T) and ROHF-MP4 calculations for which SEMICANONICAL is the default. Type: string; Possible Values: STANDARD, SEMICANONICAL; Default: STANDARD. CFOUR_PERT_ORB¶. Specifies the type of perturbed orbitals used in energy derivative calculations. STANDARD means that the gradient formulation assumes that the perturbed orbitals are not those in which the (perturbed) Fock matrix is diagonal. CANONICAL means that the perturbed orbitals are assumed to be canonical. This keyword is set automatically to CANONICAL in derivative calculations with methods which include triple excitations (MBPT[4]/MP4, CCSD+T[CCSD], CCSD[T], QCISD[T] and all iterative schemes like CCSDT-n and CC3) apart from CCSDT. IJ_CANONICAL requests a canonical perturbed-orbital treatment only for the occupied-occupied block of the unperturbed density matrix in analytic derivative calculations. For testing purposes, it is possible to force the use standard perturbed orbitals even in case of iterative triple excitations via the option FORCE_STANDA (dne?). Note also that in case of unrelaxed derivatives standard orbitals must be used. Default : STANDARD for all methods without triples (except CCSDT), CANONICAL for all methods wit",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__cfour-1.html:44482,energy,energy,44482,psi4manual/1.0.0/autodir_options_c/module__cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__cfour-1.html,2,['energy'],['energy']
Energy Efficiency,"n. cbs-xtpl-opt; Various extrapolated optimization methods for the H2 molecule. dct-grad4; Unrestricted DF-DCT ODC-12 gradient for O2 with cc-pVTZ/cc-pVTZ-RI standard/auxiliary basis set. dfomp2-grad1; DF-OMP2 cc-pVDZ gradients for the H2O molecule. dfomp2-4; OMP2 cc-pVDZ energy for the NO molecule. mbis-3; MBIS calculation on OH radical. dfccd1; DF-CCD cc-pVDZ energy for the H2O molecule. props4; Electrostatic potential and electric field evaluated on a grid around water. fnocc4; Test FNO-DF-CCSD(T) energy. omp2-grad2; OMP2 cc-pVDZ gradient for the NO radical. omp2-1; OMP2 cc-pVDZ energy for the H2O molecule. opt7; Various constrained energy minimizations of HOOH with cc-pvdz RHF. For “fixed” coordinates, the final value is provided by the user. dft-omega; Test omega is setable updated wb97x_20,wb97x_03 to account for new BraggSlater radii. mp2-grad2; MP2 cc-pVDZ gradient for the NO radical. fsapt-ext-abc2; FSAPT with external charge on dimer. sapt-dft2; SAPT(DFT) aug-cc-pVDZ computation for the water dimer interaction energy. dfmp2-grad2; DF-MP2 cc-pVDZ gradient for the NO molecule. dft-freq-analytic2; Analytic UKS SVWN frequencies, compared to finite difference values. sapt-exch-ind30-inf; SAPT2+3 with S^inf exch-ind30 Geometries taken from the S66x10 database, the shortest-range point (R = 0.7 R_e). cc7; Tests CCENERGY’s CCSD gradient in the presence of a dipole field. sapt-exch-disp-inf; SAPT0 with S^inf exch-disp20. omp2p5-grad2; OMP2.5 cc-pVDZ gradient for the NO radical. nbody-hessian; Computation of VMFC-corrected HF dimer Hessian. isapt-siao1; This test case shows an example of running the I-SAPT0/jun-cc-pVDZ computation for 2,4-pentanediol (targeting the intramolecular hydrogen bond between the two hydroxyl groups) The SIAO1 link partitioning algorithm is used. sapt-sf1; Tests the Psi4 SF-SAPT code. dft-jk; DFT JK on-disk test. omp2p5-grad1; OMP2.5 cc-pVDZ gradient for the H2O molecule. scf-auto-cholesky; Cholesky filter a complete basis. cc38; RHF-CC2-LR/",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html:45798,energy,energy,45798,psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"n.; fix_com (bool) – Whether translation of geom is allowed or disallowed.; fix_orientation (bool) – Whether rotation of geom is allowed or disallowed.; fix_symmetry (str, optional) – Maximal point group symmetry which geom should be treated. Lowercase.; geom (ndarray of float) – (3 * nat, ) Cartesian coordinates in units.; elea (ndarray of int) – (nat, ) Mass number for atoms, if known isotope, else -1.; elez (ndarray of int) – (nat, ) Number of protons, nuclear charge for atoms.; elem (ndarray of str) – (nat, ) Element symbol for atoms.; mass (ndarray of float) – (nat, ) Atomic mass [u] for atoms.; real (ndarray of bool) – (nat, ) Real/ghostedness for atoms.; elbl (ndarray of str) – (nat, ) Label with any tagging information from element spec.; fragment_separators (list of int) – (nfr - 1, ) list of atom indices at which to split geom into fragments.; fragment_charges (list of float) – (nfr, ) list of charge allocated to each fragment.; fragment_multiplicities (list of int) – (nfr, ) list of multiplicity allocated to each fragment.; molecular_charge (float) – total charge on system.; molecular_multiplicity (int) – total multiplicity on system.; comment (str, optional) – Additional comment for molecule.; provenance (dict of str) – Accumulated history of molecule, with fields “creator”, “version”, “routine”.; connectivity (list of tuples of int, optional) – (nbond, 3) list of (0-indexed) (atomA, atomB, bond_order) (int, int, double) tuples; EFP extension (this + units is minimal); fragment_files (list of str) – (nfr, ) lowercased names of efp meat fragment files.; hint_types ({‘xyzabc’, ‘points’}) – (nfr, ) type of fragment orientation hint.; geom_hints (list of lists of float) – (nfr, ) inner lists have length 6 (xyzabc; to orient the center) or; 9 (points; to orient the first three atoms) of the EFP fragment.; QMVZ extension (geom_unsettled replaces geom); geom_unsettled (list of lists of str) – (nat, ) all-string Cartesian and/or zmat anchor and value contents; m",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/external_apis-1.html:9183,allocate,allocated,9183,psi4manual/1.4.0/external_apis-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/external_apis-1.html,5,['allocate'],['allocated']
Energy Efficiency,"n.; set {; basis cc-pvdz-dk; rel_basis cc-pvtz-dk; relativistic x2c; }. It is recommended that when employing the X2C relativistic Hamiltonian, that you use a fully; decontracted basis set. This can be done simply in the input by adding “-decontract” to the; name of the primary basis you want to use for the calculation as detailed in; Decontracted Basis Sets. Publications resulting from the use; of X2C should cite the following publication: [Verma:2015]. Theory¶; X2C is based on exact decoupling of; positive-energy ( ; ) and negative-energy ( ); blocks of the Dirac Hamiltonian (). The transformation ( ) is obtained from the solutions of the Dirac equation in kinetically balanced basis [Kutzelnigg:1984] treatment.; In the X2C treatment, the positive-energy block of the Hamiltonian ( ); is given by the sum; of a transformed kinetic () and potential energy ( ) contribution.; Relativistic kinetic energy ( ) and nuclear-electron interaction potential ( ) is given interms of non-relativisitc kinetic () energy and nuclear-electron interaction potential (), coupling matrix ( ) and renormalization matrix ( ). The coupling matrix ( ) is obtained from the large () and small () components of the positive energy solutions of the Dirac equation.; The renormalization matrix; ,; depends on the modified overlap matrix; . The integrals can be easily computed as derivatives of the nuclear-electron attraction integrals with respect to nuclear coordinates.; Existing nonrelativistic electronic structure code can be extended to include scalar relativistic effects; treated with the X2C method by replacing nonrelativistic kinetic and potential energy with the corresponding; X2C operators and . It is important to note that fully uncontracted basis in needed for the construction of X2C Hamiltonian as Foldy-Wouthuysen (FW [FW:1950]) transformation is obtained in kinetically balance basis. Keywords¶. RELATIVISTIC¶. Relativistic Hamiltonian type. Type: string; Possible Values: NO, X2C; Default: ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/relativistic-1.html:3293,energy,energy,3293,psi4manual/1.0.0/relativistic-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/relativistic-1.html,4,['energy'],['energy']
Energy Efficiency,"n.Da(); self.basis = self.wfn.basisset(); parser = core.Gaussian94BasisSetParser(); self.ribasis = core.BasisSet.construct(parser, self.molecule, ""DF_BASIS_SCF""). fitter = core.DFChargeFitter(); fitter.setPrimary(self.basis); fitter.setAuxiliary(self.ribasis); fitter.setD(self.Da); self.da = fitter.fit(); self.da.scale(2.0). def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]; class QMMM():; """"""Hold charges and :py:class:`psi4.core.ExternalPotential`. Use :py:class:`psi4.driver.QMMMbohr` instead."""""". def __init__(self):; raise UpgradeHelper(self.__class__.__name__, ""QMMMbohr"", 1.6, ' Replace object with a list of charges and locations in Bohr passed as keyword argument, e.g., `energy(..., external_potentials=[[0.5, [0, 0, 1]], [-0.5, [0, 0, -1]]])`.'). [docs]; class QMMMbohr():; """"""Hold charges and :py:class:`psi4.core.ExternalPotential`. To add external charges to a calculation, prefer; passing the array of charges with kwarg ``external_potentials``, as in extern2 example."""""". def __init__(self):; self.charges = []; self.diffuses = []; self.extern = core.ExternalPotential(). [docs]; def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs]; def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs]; def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / constants.bohr2angstroms, y / constants.bohr2angstroms, z / constants.bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qmmm.html:3881,charge,charges,3881,psi4manual/1.8.x/_modules/psi4/driver/qmmm.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qmmm.html,6,['charge'],['charges']
Energy Efficiency,"n.build(self.dashlevel, **resolved['dashparams']). if gcp_engine is None:; self.gcp_engine = capable_engines_for_disp[""3c""][0]; else:; if ""3c"" in _engine_can_do[gcp_engine]:; self.gcp_engine = gcp_engine; else:; raise ValidationError(f""This little engine ({engine}) can't (3c)""). [docs]; def print_out(self):; """"""Format dispersion parameters of `self` for output file."""""". text = []; text.append("" => {}: Empirical Dispersion <="".format(; (self.fctldash.upper() if self.fctldash.upper() else 'Custom'))); text.append(''); text.append(self.description); text.append(self.dashlevel_citation.rstrip()); if self.dashparams_citation:; text.append("" Parametrisation from:{}"".format(self.dashparams_citation.rstrip())); text.append(''); for op in self.ordered_params:; text.append("" %6s = %14.6f"" % (op, self.dashparams[op])); text.append('\n'). core.print_out('\n'.join(text)). [docs]; def compute_energy(self, molecule: core.Molecule, wfn: core.Wavefunction = None) -> float:; """"""Compute dispersion energy based on engine, dispersion level, and parameters in `self`. Parameters; ----------; molecule; System for which to compute empirical dispersion correction.; wfn; Location to set QCVariables. Returns; -------; float; Dispersion energy [Eh]. Notes; -----; :psivar:`DISPERSION CORRECTION ENERGY`; Disp always set. Overridden in SCF finalization, but that only changes for ""-3C"" methods.; :psivar:`fctl DISPERSION CORRECTION ENERGY`; Set if :py:attr:`fctldash` nonempty. """"""; if self.engine in [""s-dftd3"", 'dftd3', 'mp2d', ""dftd4""]:; resi = AtomicInput(; **{; 'driver': 'energy',; 'model': {; 'method': self.fctldash,; 'basis': '(auto)',; },; 'keywords': {; 'level_hint': self.dashlevel,; 'params_tweaks': self.dashparams,; 'dashcoeff_supplement': self.dashcoeff_supplement,; 'pair_resolved': self.save_pairwise_disp,; 'apply_qcengine_aliases': True, # for s-dftd3; 'verbose': 1,; },; 'molecule': molecule.to_schema(dtype=2),; 'provenance': p4util.provenance_stamp(__name__),; }); jobrec = qcng.compute(;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/empirical_dispersion.html:9155,energy,energy,9155,psi4manual/1.8.x/_modules/psi4/driver/procrouting/empirical_dispersion.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/empirical_dispersion.html,6,['energy'],['energy']
Energy Efficiency,"n.molecule(), ref_wfn.basisset()); adc_wfn.shallow_copy(ref_wfn); adc_wfn.set_reference_wavefunction(ref_wfn); adc_wfn.set_name(name); adc_wfn.set_module(""adcc""). # MP(3) energy for CVS-ADC(3) calculations is still a missing feature in adcc; # ... we store this variant here to be able to fall back to MP(2) energies.; is_cvs_adc3 = state.method.level >= 3 and state.ground_state.has_core_occupied_space. # Ground-state energies; mp = state.ground_state; mp_energy = mp.energy(state.method.level if not is_cvs_adc3 else 2); mp_corr = 0.0; if state.method.level > 1:; core.print_out(""Ground state energy breakdown:\n""); core.print_out("" Energy SCF {0:15.8g} [Eh]\n"".format(ref_wfn.energy())); for level in range(2, state.method.level + 1):; if level >= 3 and is_cvs_adc3:; continue; energy = mp.energy_correction(level); mp_corr += energy; adc_wfn.set_variable(f""MP{level} CORRELATION ENERGY"", energy); adc_wfn.set_variable(f""MP{level} TOTAL ENERGY"", mp.energy(level)); core.print_out(f"" Energy correlation MP{level} {energy:15.8g} [Eh]\n""); core.print_out("" Energy total {0:15.8g} [Eh]\n"".format(mp_energy)); adc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", mp_corr) # P::e ADC; adc_wfn.set_variable(""CURRENT ENERGY"", mp_energy) # P::e ADC. # Set results of excited-states computation; # TODO Does not work: Can't use strings; # adc_wfn.set_variable(""excitation kind"", state.kind); adc_wfn.set_variable(""ADC ITERATIONS"", state.n_iter) # P::e ADC; adc_wfn.set_variable(name + "" excitation energies"",; core.Matrix.from_array(state.excitation_energy.reshape(-1, 1))); adc_wfn.set_variable(""number of excited states"", len(state.excitation_energy)). core.print_out(""\n\n ==> Excited states summary <== \n""); core.print_out(""\n"" + state.describe(oscillator_strengths=False) + ""\n""). # TODO Setting the excitation amplitude elements inside the wavefunction is a little; # challenging, since for each excitation vector one needs to extract the elements; # and map the indices from the adcc to the Psi4 conve",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:116007,energy,energy,116007,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,6,"['Energy', 'energy']","['Energy', 'energy']"
Energy Efficiency,"n.molecule(), ref_wfn.basisset()); adc_wfn.shallow_copy(ref_wfn); adc_wfn.set_reference_wavefunction(ref_wfn); adc_wfn.set_name(name); adc_wfn.set_module(""adcc""). # MP(3) energy for CVS-ADC(3) calculations is still a missing feature in adcc; # ... we store this variant here to be able to fall back to MP(2) energies.; is_cvs_adc3 = state.method.level >= 3 and state.ground_state.has_core_occupied_space. # Ground-state energies; mp = state.ground_state; mp_energy = mp.energy(state.method.level if not is_cvs_adc3 else 2); mp_corr = 0.0; if state.method.level > 1:; core.print_out(""Ground state energy breakdown:\n""); core.print_out("" Energy SCF {0:15.8g} [Eh]\n"".format(ref_wfn.energy())); for level in range(2, state.method.level + 1):; if level >= 3 and is_cvs_adc3:; continue; energy = mp.energy_correction(level); mp_corr += energy; adc_wfn.set_variable(f""MP{level} CORRELATION ENERGY"", energy); adc_wfn.set_variable(f""MP{level} TOTAL ENERGY"", mp.energy(level)); core.print_out(f"" Energy correlation MP{level} {energy:15.8g} [Eh]\n""); core.print_out("" Energy total {0:15.8g} [Eh]\n"".format(mp_energy)); adc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", mp_corr) # P::e ADC; adc_wfn.set_variable(""CURRENT ENERGY"", mp_energy) # P::e ADC. # Set results of excited-states computation; # TODO Does not work: Can't use strings; # adc_wfn.set_variable(""excitation kind"", state.kind); adc_wfn.set_variable(""number of excited states"", len(state.excitation_energy)); adc_wfn.set_variable(""ADC ITERATIONS"", state.n_iter) # P::e ADC; methods = [name.upper(), 'ADC']; for excitation in state.excitations:; root_index = excitation.index + 1; for method in methods:; adc_wfn.set_variable(f""{method} ROOT 0 (A) -> ROOT {root_index} (A) EXCITATION ENERGY"",; excitation.excitation_energy); adc_wfn.set_variable(f""{method} ROOT 0 (IN A) -> ROOT {root_index} (IN A) EXCITATION ENERGY"",; excitation.excitation_energy); adc_wfn.set_variable(f""{method} ROOT 0 -> ROOT {root_index} EXCITATION ENERGY"",; excitation.exci",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:118284,energy,energy,118284,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,15,"['Energy', 'energy']","['Energy', 'energy']"
Energy Efficiency,"n.set_hessian(core.Matrix.from_array(H)); wfn.set_gradient(G0). # Explicitly set the current energy..; if isinstance(lowername, str) and lowername in procedures['energy']:; # this correctly filters out cbs fn and ""hf/cc-pvtz""; # it probably incorrectly filters out mp5, but reconsider in DDD; core.set_variable(f""CURRENT HESSIAN"", H); core.set_variable(f""{lowername.upper()} TOTAL HESSIAN"", H); core.set_variable(f""{lowername.upper()} TOTAL GRADIENT"", G0); wfn.set_variable(f""{lowername.upper()} TOTAL HESSIAN"", H); wfn.set_variable(f""{lowername.upper()} TOTAL GRADIENT"", G0); core.set_variable('CURRENT ENERGY', findif_meta_dict[""reference""][""energy""]); wfn.set_variable('CURRENT ENERGY', findif_meta_dict[""reference""][""energy""]). core.set_global_option(""PARENT_SYMMETRY"", """"); optstash.restore(); optstash_conv.restore(). else:; core.print_out(""""""hessian() will perform frequency computation by finite difference of analytic energies.\n""""""). # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash.restore(); optstash_conv.restore(); optstash_conv = driver_util._set_convergence_criterion('energy', lowername, 10, 11, 10, 11, 10). # Obtain list of displacements; findif_meta_dict = driver_findif.hessian_from_energies_geometries(molecule, irrep). # Record undisplaced symmetry for projection of diplaced point groups; core.set_global_option(""PARENT_SYMMETRY"", molecule.schoenflies_symbol()). ndisp = len(findif_meta_dict[""displacements""]) + 1. print(' %d displacements needed.' % ndisp). wfn = _process_displacement(energy, lowername, molecule, findif_meta_dict[""reference""], 1, ndisp,; **kwargs); var_dict = core.variables(). for n, displacement in enumerate(findif_meta_dict[""displacements""].values(), start=2):; _process_displacement(; energy, lowername, molecule, displacement, n, ndisp, write_orbitals=False, **kwargs). # Reset variables; for key, val in var_dict.items():; core.set_variable(key, val). # Assemble Hessian from energies;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/driver.html:81060,energy,energy,81060,psi4manual/1.5.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/driver.html,2,['energy'],['energy']
Energy Efficiency,"n; A simple hf/cc-pvdz water calculation. The resulting wavefunction is written to a file, and then a new wavefunction is generated from that file. The member variables of both wavefunctions should be identical in value. psimrcc-ccsd_t-4; Mk-MRCCSD(T) single point. \(^1A_1\) O$_3` state described using the Ms = 0 component of the singlet. Uses TCSCF orbitals. casscf-semi; CASSCF/6-31G** energy point. Check energy with frozen core/virtual orbs. after semicanonicalization. mp2-grad1; MP2 cc-pVDZ gradient for the H2O molecule. omp3-grad2; OMP3 cc-pVDZ gradient for the NO radical. fsapt1; This test case shows an example of running and analyzing a standard F-SAPT0/jun-cc-pvdz procedure for phenol dimer from the S22 database. extern1; External potential calculation involving a TIP3P water and a QM water. Finite different test of the gradient is performed to validate forces. cisd-h2o+-2; 6-31G** H2O+ Test CISD Energy Point. sapt1; SAPT0 cc-pVDZ computation of the ethene-ethyne interaction energy, using the cc-pVDZ-JKFIT RI basis for SCF and cc-pVDZ-RI for SAPT. Monomer geometries are specified using Cartesian coordinates. scf-upcast-custom-basis; test scf castup with custom basis sets. cc52; CCSD Response for H2O2. decontract; RHF/cc-pvdz-decontract HCl single-point energy Testing the in line -decontract option for basis sets. nbody-multi-level; Multilevel computation of water trimer energy (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). cc55; EOM-CCSD/6-31g excited state transition data for water with two excited states per irrep. dft-ghost; DFT Functional Test for Range-Seperated Hybrids and Ghost atoms. dft-b2plyp; Double-hybrid density functional B2PYLP. Reproduces portion of Table I in S. Grimme’s J. Chem. Phys 124 034108 (2006) paper defining the functional. stability2; ROHF stability analysis check for CN with cc-pVDZ. This test corresponds to the rohf-stab test from Psi3. psimrcc-ccsd_t-1; Mk-MRCCSD(T) single point. \(^1A_1\) CH2 state described using",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html:3799,energy,energy,3799,psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"n; Computation of VMFC-corrected water trimer Hessian (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). dct3; DC-06 calculation for the He dimer. This performs a simultaneous update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the AO Basis, using integrals stored on disk. omp2-2; OMP2 cc-pVDZ energy with ROHF initial guess orbitals for the NO radical. omp2-5; SOS-OMP2 cc-pVDZ geometry optimization for the H2O molecule. cc22; ROHF-EOM-CCSD/DZ on the lowest two states of each irrep in \(^{3}B_1\) CH2. scf-hess3; CONV SCF 6-31G analytical vs finite-difference tests Tests UHF hessian code for Ca != Cb. mom-h2o-4; MOM excitation from LUMO HOMO+4. fci-h2o; 6-31G H2O Test FCI Energy Point. dct1; DC-06, DC-12, ODC-06 and ODC-12 calculation for the He dimer. This performs a simultaneous update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the MO Basis. opt9; Various constrained energy minimizations of HOOH with cc-pvdz RHF. Cartesian-coordinate constrained optimizations of HOOH in internals. cbs-xtpl-energy-conv; Extrapolated water energies - conventional integrals version. cc10; ROHF-CCSD cc-pVDZ energy for the \(^2\Sigma^+\) state of the CN radical. frac-ip-fitting; Omega optimization for LRC functional wB97 on water. cc3; cc3: RHF-CCSD/6-31G** H2O geometry optimization and vibrational frequency analysis by finite-differences of gradients. fsapt-ext-abc-au; analog of fsapt-ext-abc with molecule and external potentials in Bohr. sapt-exch-ind30-inf; SAPT2+3 with S^inf exch-ind30 Geometries taken from the S66x10 database, the shortest-range point (R = 0.7 R_e). dlpnomp2-2; comparison of DF-MP2 and DLPNO-MP2 with a CBS extrapolation. stability3; Test LDA stability analysis against QChem. dfmp2-grad3; DF-MP2 cc-pVDZ gradients for the H2O molecule. options1; check all variety of options parsing. scf4; RHF cc-pVDZ energy for water, automatically scanning the symmetric stret",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html:40704,energy,energy,40704,psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"n; Default: false. DOMAINS (CIS); CIS —. Type: array; Default: No Default. E_CONVERGENCE (CCEOM); CCEOM — Convergence criterion for excitation energy (change) in the Davidson algorithm for CC-EOM. Type: conv double; Default: 1e-8. E_CONVERGENCE (DETCI); DETCI — Convergence criterion for energy. Type: conv double; Default: 1e-6. E_CONVERGENCE (LMP2); LMP2 — Convergence criterion for energy (change). Type: conv double; Default: 1e-7. E_CONVERGENCE (MCSCF); MCSCF — Convergence criterion for energy. Type: conv double; Default: 1e-8. E_CONVERGENCE (MRCC); MRCC — This becomes tol (option #16) in fort.56. Type: conv double; Default: 1e-8. E_CONVERGENCE (OMP2); OMP2 —. Type: conv double; Default: 1e-8. E_CONVERGENCE (PSIMRCC); PSIMRCC — Convergence criterion for energy. Type: conv double; Default: 1e-9. E_CONVERGENCE (SAPT); SAPT — Convergence criterion for energy (change) in the SAPT term during solution of the CPHF equations. Type: conv double; Default: 1e-10. E_CONVERGENCE (SCF); SCF — Convergence criterion for SCF energy. Type: conv double; Default: 1e-8. EOM_GUESS (CCEOM); CCEOM — Specifies a set of single-excitation guess vectors for the EOM-CC procedure. If EOM_GUESS = SINGLES, the guess will be taken from the singles-singles block of the similarity-transformed Hamiltonian, Hbar. If EOM_GUESS = DISK, guess vectors from a previous computation will be read from disk. If EOM_GUESS = INPUT, guess vectors will be specified in user input. The latter method is not currently available. Type: string; Possible Values: SINGLES, DISK, INPUT; Default: SINGLES. EOM_REFERENCE (CCEOM); CCEOM —. Type: string; Possible Values: RHF, ROHF, UHF; Default: RHF. EOM_REFERENCE (CCHBAR); CCHBAR —. Type: string; Default: RHF. EOM_REFERENCE (CCSORT); CCSORT —. Type: string; Default: RHF. EX_ALLOW (DETCI); DETCI (Expert) — An array of length EX_LEVEL specifying whether each excitation type (S,D,T, etc.) is allowed (1 is allowed, 0 is disallowed). Used to specify non-standard CI spaces such as CIS",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodoc_glossary_options_c-1.html:28315,energy,energy,28315,psi4manual/4.0b2/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodoc_glossary_options_c-1.html,2,['energy'],['energy']
Energy Efficiency,"n; Default: false. DO_DIIS (DFOCC); DFOCC — Do apply DIIS extrapolation?. Type: boolean; Default: true. DO_DIIS (OCC); OCC — Do apply DIIS extrapolation?. Type: boolean; Default: true. DO_IND_EXCH_SINF (SAPT); SAPT (Expert) — For SAPT(DFT) computes the S^inf Exchange-Induction terms. Type: boolean; Default: false. DO_LEVEL_SHIFT (DFOCC); DFOCC — Do apply level shifting?. Type: boolean; Default: true. DO_LEVEL_SHIFT (OCC); OCC — Do apply level shifting?. Type: boolean; Default: true. DO_MBPT_DISP (SAPT); SAPT (Expert) — Do MBPT dispersion correction in SAPT2+, SAPT2+(3) or SAPT2+3, if also doing CCD?. Type: boolean; Default: true. DO_SCS (DFOCC); DFOCC — Do perform spin-component-scaled OMP2 (SCS-OMP2)? In all computation, SCS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SCS-OMP2, one needs to set ‘DO_SCS’ to true. Type: boolean; Default: false. DO_SCS (OCC); OCC — Do perform spin-component-scaled OMP2 (SCS-OMP2)? In all computation, SCS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SCS-OMP2, one needs to set ‘DO_SCS’ to true. Type: boolean; Default: false. DO_SINGLETS (CPHF); CPHF — Do singlet states? Default true. Type: boolean; Default: true. DO_SOS (DFOCC); DFOCC — Do perform spin-opposite-scaled OMP2 (SOS-OMP2)? In all computation, SOS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SOS-OMP2, one needs to set ‘DO_SOS’ to true. Type: boolean; Default: false. DO_SOS (OCC); OCC — Do perform spin-opposite-scaled OMP2 (SOS-OMP2)? In all computation, SOS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SOS-OMP2, one needs to set ‘DO_SOS’ to true. Type: boolean; Default: false. DO_THIRD_ORDER (SAPT); SAPT (Expert) — Do compute third-order corrections?. Type: boolean; Defa",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodoc_glossary_options_c-1.html:112368,energy,energy,112368,psi4manual/1.3.2/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodoc_glossary_options_c-1.html,2,['energy'],['energy']
Energy Efficiency,"n; Default: false. QRHF¶. Do form quasi RHF (QRHF) orbitals?. Type: boolean; Default: false. REFERENCE¶. Reference wavefunction type. Type: string; Default: RHF. REORDER¶. Do reorder MOs?. Type: boolean; Default: false. RESTRICTED_DOCC¶. An array giving the number of restricted doubly-occupied orbitals per irrep (not excited in CI wavefunctions, but orbitals can be optimized in MCSCF). Type: array; Default: No Default. RESTRICTED_UOCC¶. An array giving the number of restricted unoccupied orbitals per irrep (not occupied in CI wavefunctions, but orbitals can be optimized in MCSCF). Type: array; Default: No Default. SORTED_TEI_FILE¶. MO-basis sorted two-electron integrals file. Type: integer; Default: PSIF_MO_TEI. SO_S_FILE¶. SO basis overlap matrix file. Type: integer; Default: PSIF_OEI. SO_TEI_FILE¶. SO basis two-electron integrals file. Type: integer; Default: PSIF_SO_TEI. SO_T_FILE¶. SO basis kinetic energy matrix file. Type: integer; Default: PSIF_OEI. SO_V_FILE¶. SO basis potential energy matrix file. Type: integer; Default: PSIF_OEI. TPDM_ADD_REF¶. Do add reference contribution to TPDM?. Type: boolean; Default: false. TPDM_FILE¶. MO-basis two-particle density matrix file. Type: integer; Default: PSIF_MO_TPDM. Expert¶. RAS1¶. An array giving the number of orbitals per irrep for RAS1. Type: array; Default: No Default. RAS2¶. An array giving the number of orbitals per irrep for RAS2. Type: array; Default: No Default. RAS3¶. An array giving the number of orbitals per irrep for RAS3. Type: array; Default: No Default. RAS4¶. An array giving the number of orbitals per irrep for RAS4. Type: array; Default: No Default. WFN¶. Wavefunction type. Type: string; Default: CCSD. Table Of Contents. TRANSQT; General; AA_M_FILE; AB_M_FILE; AO_BASIS; BB_M_FILE; CHECK_C_ORTHONORM; DELETE_AO; DELETE_RESTR_DOCC; DELETE_TPDM; DO_ALL_TEI; FIRST_TMP_FILE; FZC_A_FILE; FZC_B_FILE; FZC_FILE; INTS_TOLERANCE; IVO; J_FILE; KEEP_J; KEEP_PRESORT; LAGRAN_DOUBLE; LAGRAN_HALVE; LAG_IN_FILE; MAX_BUC",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodir_options_c/module__transqt-1.html:4908,energy,energy,4908,psi4manual/4.0b3/autodir_options_c/module__transqt-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/module__transqt-1.html,12,['energy'],['energy']
Energy Efficiency,"n; Default: false. T3_WS_INCORE (CCEOM)¶CCEOM — Do build W intermediates required for eom_cc3 in core memory?. Type: boolean; Default: false. T_AMPS (CCHBAR)¶CCHBAR — Do compute the T amplitude equation matrix elements?. Type: boolean; Default: false. T_CUT_CLMO (DLPNO)¶DLPNO (Expert) — Basis set coefficient threshold for including basis function (m) in domain of LMO (i). Type: double; Default: 1e-2. T_CUT_CPAO (DLPNO)¶DLPNO (Expert) — Basis set coefficient threshold for including basis function (n) in domain of PAO (u). Type: double; Default: 1e-3. T_CUT_DO (DLPNO)¶DLPNO (Expert) — DOI threshold for including PAO (u) in domain of LMO (i). Type: double; Default: 1e-2. T_CUT_DO_IJ (DLPNO)¶DLPNO (Expert) — DOI threshold for treating LMOs (i,j) as interacting. Type: double; Default: 1e-5. T_CUT_DO_PRE (DLPNO)¶DLPNO (Expert) — DOI threshold for including PAO (u) in domain of LMO (i) during pre-screening. Type: double; Default: 3e-2. T_CUT_MKN (DLPNO)¶DLPNO (Expert) — Mulliken charge threshold for including aux BFs on atom (a) in domain of LMO (i). Type: double; Default: 1e-3. T_CUT_PNO (DLPNO)¶DLPNO (Expert) — Occupation number threshold for removing PNOs. Type: double; Default: 1e-8. T_CUT_PRE (DLPNO)¶DLPNO (Expert) — Pair energy threshold (dipole approximation) for treating LMOs (i, j) as interacting. Type: double; Default: 1e-6. TDM (DETCI)¶DETCI — Do compute the transition density? Note: only transition densities between roots of the same symmetry will be evaluated. DETCI does not compute states of different irreps within the same computation; to do this, lower the symmetry of the computation. Type: boolean; Default: false. TDSCF_COEFF_CUTOFF (SCF)¶SCF — Cutoff for printing excitations and de-excitations contributing to each excited state. Type: double; Default: 0.1. TDSCF_GUESS (SCF)¶SCF — Guess type, only ‘denominators’ currently supported. Type: string; Default: DENOMINATORS. TDSCF_MAXITER (SCF)¶SCF — Maximum number of TDSCF solver iterations. Type: integer; Defau",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodoc_glossary_options_c.html:229403,charge,charge,229403,psi4manual/1.7.x/autodoc_glossary_options_c.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodoc_glossary_options_c.html,4,['charge'],['charge']
Energy Efficiency,"n; Default: false. T3_WS_INCORE (CCEOM)¶CCEOM — Do build W intermediates required for eom_cc3 in core memory?. Type: boolean; Default: false. T_AMPS (CCHBAR)¶CCHBAR — Do compute the T amplitude equation matrix elements?. Type: boolean; Default: false. T_CUT_CLMO (DLPNO)¶DLPNO (Expert) — Basis set coefficient threshold for including basis function (m) in domain of LMO (i). Type: double; Default: 1e-2. T_CUT_CPAO (DLPNO)¶DLPNO (Expert) — Basis set coefficient threshold for including basis function (n) in domain of PAO (u). Type: double; Default: 1e-3. T_CUT_DO (DLPNO)¶DLPNO (Expert) — DOI threshold for including PAO (u) in domain of LMO (i). Type: double; Default: 1e-2. T_CUT_DO_IJ (DLPNO)¶DLPNO (Expert) — DOI threshold for treating LMOs (i,j) as interacting. Type: double; Default: 1e-5. T_CUT_DO_PRE (DLPNO)¶DLPNO (Expert) — DOI threshold for including PAO (u) in domain of LMO (i) during pre-screening. Type: double; Default: 3e-2. T_CUT_MKN (DLPNO)¶DLPNO (Expert) — Mulliken charge threshold for including aux BFs on atom (a) in domain of LMO (i). Type: double; Default: 1e-3. T_CUT_PNO (DLPNO)¶DLPNO (Expert) — Occupation number threshold for removing PNOs. Type: double; Default: 1e-8. T_CUT_PRE (DLPNO)¶DLPNO (Expert) — Pair energy threshold (dipole approximation) for treating LMOs (i, j) as interacting. Type: double; Default: 1e-6. TDM (DETCI)¶DETCI — Do compute the transition density? Note: only transition densities between roots of the same symmetry will be evaluated. DETCI does not compute states of different irreps within the same computation; to do this, lower the symmetry of the computation. Type: boolean; Default: false. TDSCF_COEFF_CUTOFF (SCF)¶SCF — Cutoff for printing excitations and de-excitations icontributing to each excited state. Type: double; Default: 0.1. TDSCF_GUESS (SCF)¶SCF — Guess type, only ‘denominators’ currently supported. Type: string; Default: DENOMINATORS. TDSCF_MAXITER (SCF)¶SCF — Maximum number of TDSCF solver iterations. Type: integer; Defa",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodoc_glossary_options_c-1.html:224771,charge,charge,224771,psi4manual/1.5.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodoc_glossary_options_c-1.html,3,['charge'],['charge']
Energy Efficiency,"n; to the correlation energy. :type delta4_scheme: function; :param delta4_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the fourth delta correction; to the correlation energy. :type delta5_scheme: function; :param delta5_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the fifth delta correction; to the correlation energy. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> cbs('scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> cbs('mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> cbs('scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> cbs('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] cbs() coupled with database(); >>> database('mp2', 'BASIC', subset=",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:62167,energy,energy,62167,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,2,['energy'],['energy']
Energy Efficiency,"n='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] cbs() coupled with database(); >>> TODO database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='sto-3g'). >>> # [8] cbs() coupled with optimize(); >>> TODO optimize('mp2', corl_basis='cc-pV[DT]Z', corl_scheme=corl_xtpl_helgaker_2, func=cbs). """"""; kwargs = p4util.kwargs_lower(kwargs); return_wfn = kwargs.pop('return_wfn', False); verbose = kwargs.pop('verbose', 0); ptype = kwargs.pop('ptype'); cbs_alpha = {; 'scf': kwargs.get('cbs_scf_alpha', kwargs.get('scf_alpha', None)),; 'corl': kwargs.get('cbs_corl_alpha', kwargs.get('corl_alpha', None)),; 'delta': kwargs.get('cbs_delta_alpha', kwargs.get('delta_alpha', None)),; 'delta2': kwargs.get('cbs_delta2_alpha', kwargs.get('delta2_alpha', None)),; }. # Establish function to call (only energy makes sense for cbs); if ptype not in ['energy', 'gradient', 'hessian']:; raise ValidationError(""""""Wrapper complete_basis_set is unhappy to be calling function '%s' instead of 'energy'."""""" % ptype). optstash = p4util.OptionsState(; ['BASIS'],; ['WFN'],; ['WRITER_FILE_LABEL']). # Define some quantum chemical knowledge, namely what methods are subsumed in others. do_scf = True; do_corl = False; do_delta = False; do_delta2 = False; do_delta3 = False; do_delta4 = False; do_delta5 = False. user_writer_file_label = core.get_global_option('WRITER_FILE_LABEL'). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(); molstr = molecule.create_psi4_string_from_molecule(); natom = molecule.natom(). # Establish method for correlation energy; cbs_corl_wfn = kwargs.pop('corl_wfn', '').lower(); if cbs_corl_wfn:; do_corl = True. # Establish method for reference energy; if do_corl and cbs_corl_wfn.startswith('c4-'):; default_scf = 'c4-hf'; else:; default_scf = 'hf'; cbs_scf_wfn",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html:38237,energy,energy,38237,psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html,3,['energy'],['energy']
Energy Efficiency,"n=True); >>> cubeprop(wfn). 1; 2; 3; 4; 5; 6>>> # [2] Cube files for density (alpha, beta, total, spin) and four orbitals; >>> # (two alpha, two beta); >>> set cubeprop_tasks ['orbitals', 'density']; >>> set cubeprop_orbitals [5, 6, -5, -6]; >>> E, wfn = energy('scf', return_wfn=True); >>> cubeprop(wfn). Introduction¶; PSI4 has the ability to export cube files that store information about; basis functions, molecular orbitals, the electron density, and; the electrostatic potential (ESP). Cube files store the value of a scalar; quantity on a regular Cartesian grid, and can be visualized with several; visualization programs, some of which are free, like VMD; (http://www.ks.uiuc.edu/Research/vmd/).; An example utilization of the code is:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; }. set basis cc-pvdz; set scf_type df; set freeze_core True; set cubeprop_tasks ['orbitals']; set cubeprop_orbitals [5,6,-5,-6]. E, wfn = energy('scf', return_wfn=True); cubeprop(wfn). In this example, the cubeprop(); call after the energy('scf') command; executes the cubeprop code. The array CUBEPROP_TASKS specifies which; tasks should be executed. In this case the task 'orbitals' generates cube; files for orbitals. The CUBEPROP_ORBITALS option specifies that cube files; should be generated only for alpha orbitals 5 (HOMO) and 6 (LUMO) and; beta orbitals 5 (indicated as -5) and 6.; If the option CUBEPROP_ORBITALS is not provided, then cube files are; generated for all orbitals.; After running, the above input will generate four files: Psi_a_5.cube,; Psi_a_6.cube, Psi_b_5.cube, and Psi_b_6.cube. Note; If your cube plots are too coarse, try to decrease the grid spacing via; the option CUBIC_GRID_SPACING. If the edges of your plot are cut then; increase the size of the grid via the option CUBIC_GRID_OVERAGE. Cubeprop Tasks¶; The cubeprop utility can be provided a list of tasks to perform.; Tasks are specified by the CUBEPROP_TASKS option, w",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/cubeprop-1.html:1624,energy,energy,1624,psi4manual/1.1.0/cubeprop-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/cubeprop-1.html,2,['energy'],['energy']
Energy Efficiency,"n=True); >>> cubeprop(wfn). 1; 2; 3; 4; 5; 6>>> # [2] Cube files for density (alpha, beta, total, spin) and four orbitals; >>> # (two alpha, two beta); >>> set cubeprop_tasks ['orbitals', 'density']; >>> set cubeprop_orbitals [5, 6, -5, -6]; >>> E, wfn = energy('scf', return_wfn=True); >>> cubeprop(wfn). Introduction¶; PSI4 has the ability to export cube files that store information about; basis functions, molecular orbitals, the electron density, and; the electrostatic potential (ESP). Cube files store the value of a scalar; quantity on a regular Cartesian grid, and can be visualized with several; visualization programs, some of which are free, like VMD; (http://www.ks.uiuc.edu/Research/vmd/).; An example utilization of the code is:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; }. set basis cc-pvdz; set scf_type df; set freeze_core True; set cubeprop_tasks ['orbitals']; set cubeprop_orbitals [5,6,-5,-6]. E, wfn = energy('scf', return_wfn=True); cubeprop(wfn). In this example, the cubeprop(); call after the energy('scf') command; executes the cubeprop code. The array CUBEPROP_TASKS specifies which; tasks should be executed. In this case the task 'orbitals' generates cube; files for orbitals. The CUBEPROP_ORBITALS option specifies that cube files; should be generated only for alpha orbitals 5 (HOMO) and 6 (LUMO) and; beta orbitals 5 (indicated as -5) and 6.; If the option CUBEPROP_ORBITALS is not provided, then cube files are; generated for all orbitals.; After running, the above input will generate four files: Psi_a_5_1-B1.cube,; Psi_a_6_4-A1.cube, Psi_a_5_1-B1.cube, and Psi_a_6_4-A1.cube. The subscript a in; Psi_a_5_1-B1.cube indicates an alpha orbital. The first number (5) is the index of the; orbital while 1-B1 indicates that this is the first orbital that belongs to the B1 irrep.; The file Psi_a_5_1-B1.cube begins with two comment lines:; 1; 2Psi4 Gaussian Cube File.; Property: Psi_a_5_1-B1. Isocontour range ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/cubeprop-1.html:1626,energy,energy,1626,psi4manual/1.2.1/cubeprop-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/cubeprop-1.html,2,['energy'],['energy']
Energy Efficiency,"n?. Type: boolean; Default: true. DO_IND_EXCH_SINF (SAPT); SAPT (Expert) — For SAPT(DFT) computes the S^inf Exchange-Induction terms. Type: boolean; Default: false. DO_LEVEL_SHIFT (DFOCC); DFOCC — Do apply level shifting?. Type: boolean; Default: true. DO_LEVEL_SHIFT (OCC); OCC — Do apply level shifting?. Type: boolean; Default: true. DO_MBPT_DISP (SAPT); SAPT (Expert) — Do MBPT dispersion correction in SAPT2+, SAPT2+(3) or SAPT2+3, if also doing CCD?. Type: boolean; Default: true. DO_QQR_SIEVE (CPHF); CPHF — Do we do the QQR integral sieve of Maurer et al. When false, just uses * the Schwarz sieve. Type: boolean; Default: false. DO_SCS (DFOCC); DFOCC — Do perform spin-component-scaled OMP2 (SCS-OMP2)? In all computation, SCS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SCS-OMP2, one needs to set ‘DO_SCS’ to true. Type: boolean; Default: false. DO_SCS (OCC); OCC — Do perform spin-component-scaled OMP2 (SCS-OMP2)? In all computation, SCS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SCS-OMP2, one needs to set ‘DO_SCS’ to true. Type: boolean; Default: false. DO_SINGLETS (CPHF); CPHF — Do singlet states? Default true. Type: boolean; Default: true. DO_SOS (DFOCC); DFOCC — Do perform spin-opposite-scaled OMP2 (SOS-OMP2)? In all computation, SOS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SOS-OMP2, one needs to set ‘DO_SOS’ to true. Type: boolean; Default: false. DO_SOS (OCC); OCC — Do perform spin-opposite-scaled OMP2 (SOS-OMP2)? In all computation, SOS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SOS-OMP2, one needs to set ‘DO_SOS’ to true. Type: boolean; Default: false. DO_THIRD_ORDER (SAPT); SAPT (Expert) — Do compute third-order corrections?. Type: boolean; Defa",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html:113623,energy,energy,113623,psi4manual/1.2.1/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html,2,['energy'],['energy']
Energy Efficiency,"nError('INTEGRAL_PACKAGE ERD does not play nicely with derivatives, so stopping.'). # Summary validation; if (dertype == 2) and (method_name in procedures['hessian']):; pass; elif (dertype == 1) and (method_name in procedures['gradient']):; pass; elif (dertype == 0) and (method_name in procedures['energy']):; pass; else:; alternatives = ''; alt_method_name = p4util.text.find_approximate_string_matches(method_name, procedures['energy'].keys(), 2); if len(alt_method_name) > 0:; alternatives = """""" Did you mean? %s"""""" % (' '.join(alt_method_name)). raise ValidationError(""""""Derivative method 'name' %s and derivative level 'dertype' %s are not available.%s""""""; % (method_name, str(dertype), alternatives)). return dertype. [docs]def energy(name, **kwargs):; r""""""Function to compute the single-point electronic energy. :returns: *float* |w--w| Total electronic energy in Hartrees. SAPT & EFP return interaction energy. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY <CURRENTENERGY>`; * :psivar:`CURRENT REFERENCE ENERGY <CURRENTREFERENCEENERGY>`; * :psivar:`CURRENT CORRELATION ENERGY <CURRENTCORRELATIONENERGY>`. :type name: string; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple. :type restart_file: string; :param restart_file: ``['file.1, file.32]`` || ``./file`` || etc. Binary data files to be renamed for calculation restart. .. _`table:energy_gen`:. +--",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html:4074,energy,energy,4074,psi4manual/1.1.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html,1,['energy'],['energy']
Energy Efficiency,"n\n"""""" % value; core.print_out(cbsscheme); logger.debug(cbsscheme). return value. elif isinstance(valueLO, np.ndarray):. beta = (valueHI - valueLO) * beta_division; value = valueHI - beta * beta_mult. if verbose > 2:; cbsscheme = f""""""\n ==> Truhlar 2-point power SCF extrapolation for method: {functionname.upper()} <==\n""""""; cbsscheme += f""""""\n LO-zeta ({zLO}) Data\n""""""; cbsscheme += nppp(valueLO); cbsscheme += f""""""\n HI-zeta ({zHI}) Data\n""""""; cbsscheme += nppp(valueHI). cbsscheme += f""""""\n Alpha (exponent) Value: {alpha:16.8f}""""""; cbsscheme += f""""""\n Beta Data\n""""""; cbsscheme += nppp(beta); cbsscheme += f""""""\n Extrapolated Data\n""""""; cbsscheme += nppp(value); cbsscheme += ""\n""; core.print_out(cbsscheme); logger.debug(cbsscheme). return value. else:; raise ValidationError(f""scf_xtpl_truhlar_2: datatype is not recognized '{type(valueLO)}'.""). [docs]; def scf_xtpl_karton_2(functionname: str, zLO: int, valueLO: Extrapolatable, zHI: int, valueHI: Extrapolatable, verbose: int = 1, alpha: Optional[float] = None) -> Extrapolatable:; r""""""Extrapolation scheme using root-power form for reference energies with two adjacent; zeta-level bases. Used by :py:func:`~psi4.driver.cbs`. Parameters; ----------; functionname; Name of the CBS component (e.g., 'HF') used in summary printing.; zLO; Zeta number of the smaller basis set in 2-point extrapolation.; valueLO; Energy, gradient, or Hessian value at the smaller basis set in 2-point; extrapolation.; zHI; Zeta number of the larger basis set in 2-point extrapolation; Must be `zLO + 1`.; valueHI; Energy, gradient, or Hessian value at the larger basis set in 2-point; extrapolation.; verbose; Controls volume of printing.; alpha; Overrides the default :math:`\alpha = 6.3`. Returns; -------; float or ~numpy.ndarray; Eponymous function applied to input zetas and values; type from `valueLO`. Notes; -----; The extrapolation is calculated according to [3]_:; :math:`E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha\sqrt{X}}, \alpha = 6.3`. Refe",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html:10100,power,power,10100,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html,6,['power'],['power']
Energy Efficiency,"n_eom_cc_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an EOM-CCSD gradient calculation. """"""; PsiMod.set_global_option('DERTYPE', 'FIRST'). if (name.lower() == 'eom-ccsd'):; PsiMod.set_global_option('WFN', 'EOM_CCSD'); energy = run_eom_cc(name, **kwargs); PsiMod.set_global_option('WFN', 'EOM_CCSD'). PsiMod.set_global_option('WFN', 'EOM_CCSD'); PsiMod.set_global_option('ZETA', 'FALSE'); PsiMod.cclambda(); PsiMod.set_global_option('XI', 'TRUE'); PsiMod.ccdensity(); PsiMod.set_global_option('ZETA', 'TRUE'); PsiMod.cclambda(); PsiMod.set_global_option('XI', 'FALSE'); PsiMod.ccdensity(); PsiMod.deriv(). PsiMod.set_global_option('WFN', 'SCF'); PsiMod.revoke_global_option_changed('WFN'); PsiMod.set_global_option('DERTYPE', 'NONE'); PsiMod.revoke_global_option_changed('DERTYPE'). [docs]def run_adc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an algebraic diagrammatic construction calculation. .. caution:: Get rid of active molecule lines- should be handled in energy. """"""; molecule = PsiMod.get_active_molecule(); if 'molecule' in kwargs:; molecule = kwargs.pop('molecule'). if not molecule:; raise ValueNotSet('no molecule found'). PsiMod.scf(). return PsiMod.adc(). [docs]def run_dft(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-functional-theory calculation. """"""; lowername = name.lower(). user_fctl = PsiMod.get_local_option('SCF', 'DFT_FUNCTIONAL'); b_user_fctl = PsiMod.has_option_changed('DFT_FUNCTIONAL'); user_ref = PsiMod.get_local_option('SCF', 'REFERENCE'); b_user_ref = PsiMod.has_option_changed('REFERENCE'). PsiMod.set_global_option('DFT_FUNCTIONAL', lowername). if (user_ref == 'RHF'):; PsiMod.set_global_option('REFERENCE', 'RKS'); elif (user_ref == 'UHF'):; PsiMod.set_global_option('REFERENCE', 'UKS'); elif (user_ref == 'ROHF'):; raise ValidationError('ROHF reference for DFT is not available.'); elif (user_ref == 'CUHF'):; raise ValidationError('CUHF reference for DFT is",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/proc.html:16236,energy,energy,16236,psi4manual/4.0b2/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/proc.html,2,['energy'],['energy']
Energy Efficiency,n_lesser = kwargs['delta_wfn_lesser'].lower(); else:; cbs_delta_wfn_lesser = 'mp2'; if not (cbs_delta_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta_wfn_lesser)). # Establish method for second delta correction energy; if 'delta2_wfn' in kwargs:; do_delta2 = 1; cbs_delta2_wfn = kwargs['delta2_wfn'].lower(); if not (cbs_delta2_wfn in VARH.keys()):; raise ValidationError('Requested DELTA2 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta2_wfn)). if 'delta2_wfn_lesser' in kwargs:; cbs_delta2_wfn_lesser = kwargs['delta2_wfn_lesser'].lower(); else:; cbs_delta2_wfn_lesser = 'mp2'; if not (cbs_delta2_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA2 method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta2_wfn_lesser)). # Establish method for third delta correction energy; if 'delta3_wfn' in kwargs:; do_delta3 = 1; cbs_delta3_wfn = kwargs['delta3_wfn'].lower(); if not (cbs_delta3_wfn in VARH.keys()):; raise ValidationError('Requested DELTA3 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta3_wfn)). if 'delta3_wfn_lesser' in kwargs:; cbs_delta3_wfn_lesser = kwargs['delta3_wfn_lesser'].lower(); else:; cbs_delta3_wfn_lesser = 'mp2'; if not (cbs_delta3_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA3 method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta3_wfn_lesser)). # Establish method for fourth delta correction energy; if 'delta4_wfn' in kwargs:; do_delta4 = 1; cbs_delta4_wfn = kwargs['delta4_wfn'].lower(); if not (cbs_delta4_wfn in VARH.keys()):; raise ValidationError('Requested DELTA4 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta4_wfn)). if 'delta4_wfn_lesser' in kwargs:; cbs_delta4_wfn_lesser = kwargs['delta4_wfn_lesser'].lower,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:72215,energy,energy,72215,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,2,['energy'],['energy']
Energy Efficiency,n_mass_ratio; 16.8167; tau-muon mass ratio [] uncertainty=0.0015. tau_neutron_mass_ratio; 1.89111; tau-neutron mass ratio [] uncertainty=0.000 17. tau_proton_mass_ratio; 1.89372; tau-proton mass ratio [] uncertainty=0.000 17. Thomson_cross_section; 6.6524587158E-29; Thomson cross section [m^2] uncertainty=0.000 000 000 91 e-28. triton_electron_mass_ratio; 5496.92153588; triton-electron mass ratio [] uncertainty=0.000 000 26. triton_g_factor; 5.957924920; triton g factor [] uncertainty=0.000 000 028. triton_mag_mom; 1.504609503E-26; triton mag. mom. [J T^{-1}] uncertainty=0.000 000 012 e-26. triton_mag_mom_to_Bohr_magneton_ratio; 0.0016223936616; triton mag. mom. to Bohr magneton ratio [] uncertainty=0.000 000 0076 e-3. triton_mag_mom_to_nuclear_magneton_ratio; 2.978962460; triton mag. mom. to nuclear magneton ratio [] uncertainty=0.000 000 014. triton_mass; 5.007356665E-27; triton mass [kg] uncertainty=0.000 000 062 e-27. triton_mass_energy_equivalent; 4.500387735E-10; triton mass energy equivalent [J] uncertainty=0.000 000 055 e-10. triton_mass_energy_equivalent_in_MeV; 2808.921112; triton mass energy equivalent in MeV [MeV] uncertainty=0.000 017. triton_mass_in_u; 3.01550071632; triton mass in u [u] uncertainty=0.000 000 000 11. triton_molar_mass; 0.00301550071632; triton molar mass [kg mol^{-1}] uncertainty=0.000 000 000 11 e-3. triton_proton_mass_ratio; 2.99371703348; triton-proton mass ratio [] uncertainty=0.000 000 000 22. unified_atomic_mass_unit; 1.660539040E-27; unified atomic mass unit [kg] uncertainty=0.000 000 020 e-27. von_Klitzing_constant; 25812.8074555; von Klitzing constant [ohm] uncertainty=0.000 0059. weak_mixing_angle; 0.2223; weak mixing angle [] uncertainty=0.0021. Wien_frequency_displacement_law_constant; 5.8789238E+10; Wien frequency displacement law constant [Hz K^{-1}] uncertainty=0.000 0034 e10. Wien_wavelength_displacement_law_constant; 0.0028977729; Wien wavelength displacement law constant [m K] uncertainty=0.000 0017 e-3. calorie_joule_,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodoc_physconst-1.html:35860,energy,energy,35860,psi4manual/1.3.2/autodoc_physconst-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodoc_physconst-1.html,11,['energy'],['energy']
Energy Efficiency,"n_wfn=True); >>> H2.set_multiplicity(3); >>> core.MintsHelper(scf_wfn.basisset()).integrals(); >>> energy('detci', ref_wfn=scf_wfn). >>> # [5] Run two CI calculations, keeping the integrals generated in the first one.; >>> molecule ne {\nNe\n}; >>> set basis cc-pVDZ; >>> cisd_e, cisd_wfn = energy('cisd', return_wfn=True); >>> energy('fci', ref_wfn=cisd_wfn). >>> # [6] Can automatically perform complete basis set extrapolations; >>> energy(""CCSD/cc-pV[DT]Z""). >>> # [7] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> energy(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). """"""; kwargs = p4util.kwargs_lower(kwargs). # Bounce to CP if bsse kwarg; if kwargs.get('bsse_type', None) is not None:; return driver_nbody.nbody_gufunc(energy, name, ptype='energy', **kwargs). # Bounce if name is function; if hasattr(name, '__call__'):; return name(energy, kwargs.pop('label', 'custom function'), ptype='energy', **kwargs). # Allow specification of methods to arbitrary order; lowername = name.lower(); lowername, level = driver_util.parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. # Bounce to CBS if ""method/basis"" name; if ""/"" in lowername:; return driver_cbs._cbs_gufunc(energy, name, ptype='energy', **kwargs). # Commit to procedures['energy'] call hereafter; return_wfn = kwargs.pop('return_wfn', False); core.clean_variables(). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). #for precallback in hooks['energy']['pre']:; # precallback(lowername, **kwargs). optstash = driver_util._set_convergence_criterion('energy', lowername, 6, 8, 6, 8, 6). # Before invoking the procedure, we rename any file that should be read.; # This is a workaround to do restarts with the current PSI4 capabilit",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html:33078,energy,energy,33078,psi4manual/1.3.2/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html,1,['energy'],['energy']
Energy Efficiency,"nagedMethodError(['select_olccd', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_olccd_gradient(name, **kwargs):; """"""Function selecting the algorithm for an OLCCD gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('CC_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError(['select_olccd_gradient', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_fnoccsd(name, **kwargs):; """"""Function selecting the algorithm for a FNO-CCSD energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('CC_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only fnocc. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in ['', 'FNOCC']:; func = run_fnocc; elif mtd_type == 'DF':; if module in ['', 'FNOCC']:; func = run_fnodfcc; elif mtd_type == 'CD':; if module in ['', 'FNOCC']:; func = run_fnodfcc. if func is None:; raise ManagedMethodError(['select_fnoccsd', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_ccsd(name, **kwargs):; """"""Function selecting the algorithm for a CCSD energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('CC_TYPE'); module = core.get_global_option('QC_MODULE'); #",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html:17942,energy,energy,17942,psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,9,['energy'],['energy']
Energy Efficiency,"nagers."",; ""default"": ""*"",; ""type"": ""string""; },; ""priority"": {; ""title"": ""Priority"",; ""description"": ""The priority of a Task; higher priority will be pulled first. {high:2, normal:1, low:0}"",; ""default"": 1,; ""type"": ""string""; },; ""owner_group"": {; ""title"": ""Owner Group"",; ""description"": ""group in the chown sense."",; ""type"": ""string""; },; ""computed"": {; ""title"": ""Computed"",; ""description"": ""Whether quantum chemistry has been run on this task."",; ""default"": false,; ""type"": ""boolean""; },; ""result"": {; ""title"": ""Result"",; ""description"": "":py:class:`~qcelemental.models.AtomicResult` return.""; },; ""result_id"": {; ""title"": ""Result Id"",; ""description"": ""The optional ID for the computation."",; ""type"": ""string""; }; },; ""required"": [; ""molecule"",; ""basis"",; ""method"",; ""driver""; ],; ""definitions"": {; ""DriverEnum"": {; ""title"": ""DriverEnum"",; ""description"": ""Allowed computation driver values."",; ""enum"": [; ""energy"",; ""gradient"",; ""hessian"",; ""properties""; ],; ""type"": ""string""; },; ""WavefunctionProtocolEnum"": {; ""title"": ""WavefunctionProtocolEnum"",; ""description"": ""Wavefunction to keep from a computation."",; ""enum"": [; ""all"",; ""orbitals_and_eigenvalues"",; ""occupations_and_eigenvalues"",; ""return_results"",; ""none""; ],; ""type"": ""string""; },; ""ErrorCorrectionProtocol"": {; ""title"": ""ErrorCorrectionProtocol"",; ""description"": ""Configuration for how QCEngine handles error correction\n\nWARNING: These protocols are currently experimental and only supported by NWChem tasks"",; ""type"": ""object"",; ""properties"": {; ""default_policy"": {; ""title"": ""Default Policy"",; ""description"": ""Whether to allow error corrections to be used if not directly specified in `policies`"",; ""default"": true,; ""type"": ""boolean""; },; ""policies"": {; ""title"": ""Policies"",; ""description"": ""Settings that define whether specific error corrections are allowed. Keys are the name of a known error and values are whether it is allowed to be used."",; ""type"": ""object"",; ""additionalProperties"": {; ""type"": ""boolean""; }; }; },; ""additio",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/api/psi4.driver.AtomicComputer.html:2368,energy,energy,2368,psi4manual/1.9.x/api/psi4.driver.AtomicComputer.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.driver.AtomicComputer.html,4,['energy'],['energy']
Energy Efficiency,"nagers."",; ""default"": ""*"",; ""type"": ""string""; },; ""priority"": {; ""title"": ""Priority"",; ""description"": ""The priority of a Task; higher priority will be pulled first. {high:2, normal:1, low:0}"",; ""default"": 1,; ""type"": ""string""; },; ""owner_group"": {; ""title"": ""Owner Group"",; ""description"": ""group in the chown sense."",; ""type"": ""string""; },; ""computed"": {; ""title"": ""Computed"",; ""description"": ""Whether quantum chemistry has been run on this task."",; ""default"": false,; ""type"": ""boolean""; },; ""result"": {; ""title"": ""Result"",; ""description"": "":py:class:`~qcelemental.models.AtomicResult` return.""; },; ""result_id"": {; ""title"": ""Result Id"",; ""description"": ""The optional ID for the computation."",; ""type"": ""string""; }; },; ""required"": [; ""molecule"",; ""basis"",; ""method"",; ""driver""; ],; ""definitions"": {; ""DriverEnum"": {; ""title"": ""DriverEnum"",; ""description"": ""Allowed computation driver values."",; ""enum"": [; ""energy"",; ""gradient"",; ""hessian"",; ""properties""; ],; ""type"": ""string""; },; ""WavefunctionProtocolEnum"": {; ""title"": ""WavefunctionProtocolEnum"",; ""description"": ""Wavefunction to keep from a computation."",; ""enum"": [; ""all"",; ""orbitals_and_eigenvalues"",; ""return_results"",; ""none""; ],; ""type"": ""string""; },; ""ErrorCorrectionProtocol"": {; ""title"": ""ErrorCorrectionProtocol"",; ""description"": ""Configuration for how QCEngine handles error correction\n\nWARNING: These protocols are currently experimental and only supported by NWChem tasks"",; ""type"": ""object"",; ""properties"": {; ""default_policy"": {; ""title"": ""Default Policy"",; ""description"": ""Whether to allow error corrections to be used if not directly specified in `policies`"",; ""default"": true,; ""type"": ""boolean""; },; ""policies"": {; ""title"": ""Policies"",; ""description"": ""Settings that define whether specific error corrections are allowed. Keys are the name of a known error and values are whether it is allowed to be used."",; ""type"": ""object"",; ""additionalProperties"": {; ""type"": ""boolean""; }; }; },; ""additionalProperties"": false; },; ""Nati",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.AtomicComputer.html:2368,energy,energy,2368,psi4manual/1.8.x/api/psi4.driver.AtomicComputer.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.AtomicComputer.html,2,['energy'],['energy']
Energy Efficiency,"nal and Thermochemical Analysis. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Theoretical Methods: SCF to FCI. Vibrational and Thermochemical Analysis¶; Code author: Rollin A. King and Lori A. Burns; Section author: Lori A. Burns; Module: Keywords, PSI Variables, THERMO. Caution; It is important to know that PSI4, like any other; quantum chemistry program, does not compute the usual enthalpies,; entropies, or Gibbs free energies of formation provided by most; reference books. Instead, quantum chemistry programs compute “absolute”; thermodynamic properties relative to infinitely separated nuclei and; electrons, not “formation” values relative to elements in their standard; states. If you are computing thermodynamic differences, like a reaction; enthalpy computed as the enthalpy of the products minus the enthalpy; of the reactants, then these “absolute” enthalpies are perfectly valid; and usable. However, they cannot be mixed and matched with enthalpies of; formation from reference books, since the zero of energy is not the same.; Additionally, the “thermal energies” reported in kcal/mol are the; finite-temperature corrections to the electronic total energy, and; not the overall thermal energies themselves. If in doubt, use the; reported Total Energies in Hartree/particle. Keywords¶. T¶. Temperature in Kelvin for thermodynamic analysis. Note that 273.15 is the value for IUPAC STP. Type: double; Default: 298.15. P¶. Pressure in Pascal for thermodynamic analysis. Note that 100000. is the value for IUPAC STP. Type: double; Default: 101325. ROTATIONAL_SYMMETRY_NUMBER¶. Rotational symmetry number for thermodynamic analysis. Default is set from the full point group (e.g., Td for methane) as opposed to the computational point group (e.g., C2v for methane). Default takes into account symmetry reduction through asymmetric isotopic substitution and is unaffected by user-set symmetry on molecule, so this option is the sole way to influence the symmetry-d",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/thermo-1.html:1056,energy,energy,1056,psi4manual/1.2.1/thermo-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/thermo-1.html,2,['energy'],['energy']
Energy Efficiency,"nal and Thermochemical Analysis. Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Theoretical Methods: SCF to FCI. Vibrational and Thermochemical Analysis¶; Code author: Rollin A. King and Lori A. Burns; Section author: Lori A. Burns; Module: Keywords, PSI Variables, THERMO. Caution; It is important to know that PSI4, like any other; quantum chemistry program, does not compute the usual enthalpies,; entropies, or Gibbs free energies of formation provided by most; reference books. Instead, quantum chemistry programs compute “absolute”; thermodynamic properties relative to infinitely separated nuclei and; electrons, not “formation” values relative to elements in their standard; states. If you are computing thermodynamic differences, like a reaction; enthalpy computed as the enthalpy of the products minus the enthalpy; of the reactants, then these “absolute” enthalpies are perfectly valid; and usable. However, they cannot be mixed and matched with enthalpies of; formation from reference books, since the zero of energy is not the same.; Additionally, the “thermal energies” reported in kcal/mol are the; finite-temperature corrections to the electronic total energy, and; not the overall thermal energies themselves. If in doubt, use the; reported Total Energies in Hartree/particle. Keywords¶. T¶. Temperature in Kelvin for thermodynamic analysis. Note that 273.15 is the value for IUPAC STP. Type: double; Default: 298.15. P¶. Pressure in Pascal for thermodynamic analysis. Note that 100000. is the value for IUPAC STP. Type: double; Default: 101325. ROTATIONAL_SYMMETRY_NUMBER¶. Rotational symmetry number for thermodynamic analysis. Default is set from the full point group (e.g., Td for methane) as opposed to the computational point group (e.g., C2v for methane). Default takes into account symmetry reduction through asymmetric isotopic substitution and is unaffected by user-set symmetry on molecule, so this option is the sole way to influence the symmetry-d",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/thermo-1.html:1056,energy,energy,1056,psi4manual/1.3.2/thermo-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/thermo-1.html,2,['energy'],['energy']
Energy Efficiency,"nal expense and completeness of the; model space are nontrivial. Hence, the user is advised to develop; a good working knowledge of multi-reference and RAS CI methods before; attempting to use the program for a production-level project. This user’s; manual will provide only an elementary introduction to the most; important keywords. Additional information is available in the complete; list of keywords for DETCI provided in Appendix DETCI.; For single-reference CI computations, the easiest way to invoke a CI; computation with DETCI is simply to call energy(), optimize(), etc.,; with the common name for that CI wavefunction, like energy('cisd'); for a CISD single-point energy. The Python driver; recognizes cisd, cisdt, and cisdtq. Higher order; single-reference CI wavefunctions, like those including singles through; 6-fold excitations, can be invoked using numbers, like ci6. A full; CI can be specified by fci. More complicated CI computations, like; RASCI, can be performed by setting the appropriate keywords and calling the; module generically like energy('detci'). The latter approach; will also work for any of the previously-mentioned CI wavefunctions for; which the driver has built-in shortcuts, so long as the relevant options; (especially EX_LEVEL) are set appropriately. Some; examples of single-refence CI, RASCI, and full CI computations are provided; in psi4/samples. Orbital spaces for CI computations¶. CI (e.g., CISD, FCI); RASCI; CASCI. FROZEN_UOCC; FROZEN_UOCC; FROZEN_UOCC [1]. (all orbitals not in; FROZEN_UOCC; or FROZEN_DOCC; are included in CI); RAS4; ACTIVE. RAS3. RAS2. RAS1. FROZEN_DOCC; FROZEN_DOCC; FROZEN_DOCC. [1]FROZEN_UOCC is not required and will be inferred if; ACTIVE is provided. However, if it is easier to specify; FROZEN_UOCC, then this may be provided and ACTIVE can; be inferred. The table above shows the relevant orbitals spaces for CI computations (an; analogous table for MCSCF is also available).; The third column of the; table refers to CAS",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/detci-1.html:4989,energy,energy,4989,psi4manual/1.2.1/detci-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/detci-1.html,6,['energy'],['energy']
Energy Efficiency,"nal frequency analysis by finite-differences of gradients. fsapt-diff1; This test case shows an example of running and analyzing a difference F-SAPT0/jun-cc-pvdz procedure for phenol dimer from the S22 database. cbs-parser; mtd/basis syntax examples. cc9a; ROHF-CCSD(T) cc-pVDZ energy for the \(^2\Sigma^+\) state of the CN radical, with Z-matrix input. dct7; DCT calculation for the triplet O2 using ODC-06 and ODC-12 functionals. Only simultaneous algorithm is tested. fci-dipole; 6-31G H2O Test FCI Energy Point. scf-response3; UHF Dipole Polarizability Test. opt7; Various constrained energy minimizations of HOOH with cc-pvdz RHF. For “fixed” coordinates, the final value is provided by the user. cc13a; UHF-CCSD(T)/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. fsapt2; A very quick correctness test of F-SAPT (see fsapt1 for a real example). pubchem1; Benzene vertical singlet-triplet energy difference computation, using the PubChem database to obtain the initial geometry, which is optimized at the HF/STO-3G level, before computing single point energies at the RHF, UHF and ROHF levels of theory. opt3; SCF cc-pVDZ geometry optimzation, with Z-matrix input. frac-traverse; Scan fractional occupation of electrons updated values due to new BraggSlater radii. nbody-convergence; Convergence of many-body gradients of different BSSE schemes. cbs-xtpl-alpha; Extrapolated water energies. extern3; External potential calculation with one Ghost atom and one point charge at the same position. sapt-exch-disp-inf; SAPT0 with S^inf exch-disp20. cbs-delta-energy; Extrapolated energies with delta correction. dft1; DFT Functional Test all values update for new BraggSlater radii. scf-coverage; Lithium test for coverage. soscf-dft; Triple and Singlet Oxygen energy SOSCF, also tests non-symmetric density matrices. dft-custom-mgga; updated dldf reference to new BraggSlater radii Dispersionless density functional (dlDF+D) internal match to Psi4 Extensive testing has been don",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html:35467,energy,energy,35467,psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"nal method, [1], [2]. Isotopes. ISTOP (DETCI). iteration_ psi4.core.CUHF attribute, [1]. psi4.core.HF attribute, [1], [2]. psi4.core.RHF attribute, [1]. psi4.core.ROHF attribute, [1]. psi4.core.UHF attribute, [1]. iterations() psi4.core.CUHF method, [1]. psi4.core.HF method, [1], [2]. psi4.core.RHF method, [1]. psi4.core.ROHF method, [1]. psi4.core.UHF method, [1]. IWLAndDPD psi4.core.IntegralTransform.OutputType attribute, [1]. IWLOnly psi4.core.IntegralTransform.OutputType attribute, [1]. J. J() psi4.core.JK method, [1], [2]. psi4.core.MemDFJK method, [1]. JK class in psi4.core, [1]. jk() psi4.core.CUHF method, [1]. psi4.core.HF method, [1], [2]. psi4.core.RHF method, [1]. psi4.core.ROHF method, [1]. psi4.core.UHF method, [1]. JOBTYPE (CCLAMBDA). join_path() in module psi4.driver. JSCH module, [1]. K. K() psi4.core.JK method, [1], [2]. psi4.core.MemDFJK method, [1]. KEEP_INTCOS (OPTKING). keywords. ; anharmonicity(), setting. cbs(), setting. cp, setting. database(), setting. energy(), setting. frequency(), setting. general, setting. molecule, setting. optimize(), setting. properties(), setting. vmfc, setting. kinetic() psi4.core.FISAPT method, [1], [2]. kinetic_grad() psi4.core.MintsHelper method, [1], [2]. KineticInt class in psi4.core, [1]. L. L psi4.core.BoysLocalizer attribute, [1]. psi4.core.Localizer attribute, [1], [2]. psi4.core.PMLocalizer attribute, [1]. label() psi4.core.Molecule method, [1], [2]. psi4.core.MOSpace method, [1], [2]. LaplaceDenominator class in psi4.core, [1]. LCC2(+LMP2)TOTALENERGY. LCCSD. LCCSD(+LMP2)TOTALENERGY. legacy_frequencies() psi4.core.CCWavefunction method, [1]. psi4.core.CIWavefunction method, [1]. psi4.core.CUHF method, [1]. psi4.core.DFEP2Wavefunction method, [1]. psi4.core.HF method, [1]. psi4.core.RHF method, [1]. psi4.core.ROHF method, [1]. psi4.core.UHF method, [1]. psi4.core.Wavefunction method, [1], [2]. legacy_wavefunction() in module psi4.core, [1]. LEVEL_SHIFT (DFOCC). (MCSCF). (OCC). levenshtein() in module psi4.dr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/genindex-1.html:83180,energy,energy,83180,psi4manual/1.3.2/genindex-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/genindex-1.html,2,['energy'],['energy']
Energy Efficiency,"nal of the one-particle electronic density and B) there exists a set of; noninteracting quasiparticles with the same density as the true set of; electrons, with the quasiparticle states determined as eigenvectors of an; effective one-body potential encapsulating the true \(N\)-body quantum; effects. The former idea allows the electronic density to be dealt with instead; of the much more complicated wavefunction, while the latter allows for the; treatment of the troublesome kinetic energy term via the implicit one-body; Kohn–Sham orbitals. KS-DFT borrows much of the machinery of Hartree–Fock, as is; evident by looking at the energy expression,. \[\begin{split}E_{\mathrm{KS}}; &= \sum_{i} \langle i | \hat h | i \rangle; + \frac 1 2 \sum_{i,j} [ii|jj] + E_{\mathrm{xc}} [\rho_\alpha, \rho_\beta] \\; &= D_{\mu\nu}^{\mathrm{T}}\left(T_{\mu\nu} +; V_{\mu\nu}\right) + \frac{1}{2} D_{\mu\nu}^{\mathrm{T}}; D_{\lambda\sigma}^{\mathrm{T}} (\mu\nu|\lambda\sigma) + E_{\mathrm{xc}} [\rho_\alpha, \rho_\beta]\end{split}\]; Here, \(T\) is the noninteracting quasiparticle kinetic energy operator,; \(V\) is the nucleus-electron attraction potential, \(D^{\mathrm{T}}\); is the total electron density matrix, and \(E_{\mathrm{xc}} [\rho_\alpha,; \rho_\beta]\) is the (potentially nonlocal) exchange, correlation, and residual; kinetic energy functional. The residual kinetic energy term is usually quite; small, and is often ignored, hence \(E_{\mathrm{xc}}\) is often referred to; as simply the exchange-correlation functional (exchange and correlation, not; just exchange-type correlation).; In practice, the first few generations of KS-DFT functionals were chosen to be; local, meaning that the form of the exchange correlation energy is an integral; over all of space of a function depending only on local information in the; density, such as the density value or derivatives. The simplest variants are; Local Spin-Density Approximations (LSDA), which depend only on the spin density; \(\rho_\alpha\)",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/dft-1.html:2174,energy,energy,2174,psi4manual/1.2.1/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/dft-1.html,30,['energy'],['energy']
Energy Efficiency,"nal(name, npoints, deriv):. sup = build_pbe0_superfunctional(name, npoints, deriv); sup.set_name('PBE0-D3BJ'). # => -D3 <= #; sup.set_dispersion(PsiMod.Dispersion.build(*dash_server('pbe0', 'd3bj'))). return sup. [docs]def build_wsvwn_superfunctional(name, npoints, deriv):. # Call this first; sup = PsiMod.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('wSVWN'); # Tab in, trailing newlines; sup.set_description(' LSDA SR-XC Functional\n'); # Tab in, trailing newlines; sup.set_citation(' Adamson et. al., J. Comput. Chem., 20(9), 921-927, 1999\n'). # Add member functionals; sup.add_x_functional(build_functional('wS_X')); sup.add_c_functional(build_functional('VWN3RPA_C')). # Set GKS up after adding functionals; sup.set_x_omega(0.3); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_wpbe_superfunctional(name, npoints, deriv):. # Call this first; sup = PsiMod.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('wPBE'); # Tab in, trailing newlines; sup.set_description(' PBE SR-XC Functional (HJS Model)\n'); # Tab in, trailing newlines; sup.set_citation(' Henderson et. al., J. Chem. Phys., 128, 194105, 2008\n Weintraub, Henderson, and Scuseria, J. Chem. Theory. Comput., 5, 754 (2009)\n'). # Add member functionals; sup.add_x_functional(build_functional('wPBE_X')); sup.add_c_functional(build_functional('PBE_C')). # Set GKS up after adding functionals; sup.set_x_omega(0.4); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_wpbe0_superfunctional(name, npoints, deriv):. sup = build_wpbe_superfunctional(name, npoin",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/functional.html:52188,allocate,allocate,52188,psi4manual/4.0b4/_modules/functional.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/functional.html,2,['allocate'],['allocate']
Energy Efficiency,"nal[str]) – Destination file name for MOLDEN file. If unspecified (None), a file; name will be generated from the molecule name.; do_virtual (Optional[bool]) – Do write all the MOs to the MOLDEN file (True) or discard the unoccupied; MOs (False). Not valid for NO’s. If unspecified (None), value taken from; MOLDEN_WITH_VIRTUAL.; use_natural (bool) – Write natural orbitals determined from density on wavefunction.; self (Wavefunction) – . Examples:. Molden file with the Kohn-Sham orbitals of a DFT calculation.; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> wfn.molden('mycalc.molden'). Molden file with the natural orbitals of a CCSD computation. For correlated methods, an energy call will not compute the density.; “properties” or “gradient” must be called.; >>> E, wfn = properties('ccsd', return_wfn=True); >>> wfn.molden('ccsd_no.molden', use_natural=True). To supply a custom density matrix, manually set the Da and Db of the wavefunction.; This is used, for example, to write natural orbitals coming from a root computed; by a CIWavefunction computation, e.g., detci, fci, casscf.; The first two arguments of get_opdm(); can be set to n, n where n => 0 selects the root to; write out, provided these roots were computed, see NUM_ROOTS. The; third argument controls the spin (""A"", ""B"" or ""SUM"") and the final; boolean option determines whether inactive orbitals are included.; >>> E, wfn = energy('detci', return_wfn=True); >>> wfn.Da() = wfn.get_opdm(0, 0, ""A"", True); >>> wfn.Db() = wfn.get_opdm(0, 0, ""B"", True); >>> molden(wfn, 'no_root1.molden', use_natural=True). write_nbo(name)¶; Write wavefunction information in wfn to name in NBO format. Parameters:; name (str) – Destination file name for NBO file. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. PSI4 API: Linking C++ and Python; Wavefunction. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Wavefunction.html:28981,energy,energy,28981,psi4manual/1.7.x/api/psi4.core.Wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Wavefunction.html,2,['energy'],['energy']
Energy Efficiency,"nallatom(self: psi4.core.Molecule) → int¶; Number of real and dummy atoms. name(self: psi4.core.Molecule) → str¶; Gets molecule name. natom(self: psi4.core.Molecule) → int¶; Number of real atoms. nfragments(self: psi4.core.Molecule) → int¶; Gets the number of fragments in the molecule. nuclear_dipole(*args, **kwargs)¶; Overloaded function. nuclear_dipole(self: psi4.core.Molecule, arg0: psi4.core.Vector3) -> psi4.core.Vector3. Gets the nuclear contribution to the dipole, with respect to a specified origin atg0. nuclear_dipole(self: psi4.core.Molecule) -> psi4.core.Vector3. Gets the nuclear contribution to the dipole, with respect to the origin. nuclear_repulsion_energy(self: psi4.core.Molecule, dipole_field: Annotated[List[float], FixedSize(3)] = [0.0, 0.0, 0.0]) → float¶; Computes nuclear repulsion energy. nuclear_repulsion_energy_deriv1(self: psi4.core.Molecule, dipole_field: Annotated[List[float], FixedSize(3)] = [0.0, 0.0, 0.0]) → psi4.core.Matrix¶; Returns first derivative of nuclear repulsion energy as a matrix (natom, 3). nuclear_repulsion_energy_deriv2(self: psi4.core.Molecule) → psi4.core.Matrix¶; Returns second derivative of nuclear repulsion energy as a matrix (natom X 3, natom X 3). orientation_fixed(self: psi4.core.Molecule) → bool¶; Get whether or not orientation is fixed. point_group(self: psi4.core.Molecule) → psi4.core.PointGroup¶; Returns the current point group object. print_bond_angles(self: psi4.core.Molecule) → None¶; Print the bond angle geometrical parameters. print_cluster(self: psi4.core.Molecule) → None¶; Prints the molecule in Cartesians in input units adding fragment separators. print_distances(self: psi4.core.Molecule) → None¶; Print the interatomic distance geometrical parameters. print_in_input_format(self: psi4.core.Molecule) → None¶; Prints the molecule as Cartesian or ZMatrix entries, just as inputted. print_out(self: psi4.core.Molecule) → None¶; Prints the molecule in Cartesians in input units to output file. print_out_in_angstrom(s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html:25927,energy,energy,25927,psi4manual/1.9.x/api/psi4.core.Molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html,2,['energy'],['energy']
Energy Efficiency,"nallatom(self: psi4.core.Molecule) → int¶; Number of real and dummy atoms. name(self: psi4.core.Molecule) → str¶; Gets molecule name. natom(self: psi4.core.Molecule) → int¶; Number of real atoms. nfragments(self: psi4.core.Molecule) → int¶; Gets the number of fragments in the molecule. nuclear_dipole(*args, **kwargs)¶; Overloaded function. nuclear_dipole(self: psi4.core.Molecule, arg0: psi4.core.Vector3) -> psi4.core.Vector3. Gets the nuclear contribution to the dipole, with respect to a specified origin atg0. nuclear_dipole(self: psi4.core.Molecule) -> psi4.core.Vector3. Gets the nuclear contribution to the dipole, with respect to the origin. nuclear_repulsion_energy(self: psi4.core.Molecule, dipole_field: Annotated[list[float], FixedSize(3)] = [0.0, 0.0, 0.0]) → float¶; Computes nuclear repulsion energy. nuclear_repulsion_energy_deriv1(self: psi4.core.Molecule, dipole_field: Annotated[list[float], FixedSize(3)] = [0.0, 0.0, 0.0]) → psi4.core.Matrix¶; Returns first derivative of nuclear repulsion energy as a matrix (natom, 3). nuclear_repulsion_energy_deriv2(self: psi4.core.Molecule) → psi4.core.Matrix¶; Returns second derivative of nuclear repulsion energy as a matrix (natom X 3, natom X 3). orientation_fixed(self: psi4.core.Molecule) → bool¶; Get whether or not orientation is fixed. point_group(self: psi4.core.Molecule) → psi4.core.PointGroup¶; Returns the current point group object. print_bond_angles(self: psi4.core.Molecule) → None¶; Print the bond angle geometrical parameters. print_cluster(self: psi4.core.Molecule) → None¶; Prints the molecule in Cartesians in input units adding fragment separators. print_distances(self: psi4.core.Molecule) → None¶; Print the interatomic distance geometrical parameters. print_in_input_format(self: psi4.core.Molecule) → None¶; Prints the molecule as Cartesian or ZMatrix entries, just as inputted. print_out(self: psi4.core.Molecule) → None¶; Prints the molecule in Cartesians in input units to output file. print_out_in_angstrom(s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/api/psi4.core.Molecule.html:25928,energy,energy,25928,psi4manual/master/api/psi4.core.Molecule.html,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.Molecule.html,2,['energy'],['energy']
Energy Efficiency,"nally run an energy and gradient calculation for geometric ; """"""; def __init__(self, p4_name, p4_mol, p4_return_wfn, **p4_kwargs):; ; self.p4_name = p4_name; self.p4_mol = p4_mol; self.p4_return_wfn = p4_return_wfn; self.p4_kwargs = p4_kwargs; ; molecule = geometric.molecule.Molecule(); molecule.elem = [p4_mol.symbol(i).capitalize() for i in range(p4_mol.natom())]; # beware if geomeTRIC and psi4 choose different sets of constants; molecule.xyzs = [p4_mol.geometry().np * constants.bohr2angstroms]; molecule.build_bonds(); ; super(Psi4NativeEngine, self).__init__(molecule); ; def calc(self, coords, dirname, read_data=False):; self.p4_mol.set_geometry(core.Matrix.from_array(coords.reshape(-1,3))); self.p4_mol.update_geometry(); if self.p4_return_wfn:; g, wfn = gradient(self.p4_name, return_wfn=True, molecule=self.p4_mol, **self.p4_kwargs); self.p4_wfn = wfn; else:; g = gradient(self.p4_name, return_wfn=False, molecule=self.p4_mol, **self.p4_kwargs); e = core.variable('CURRENT ENERGY'); return {'energy': e, 'gradient': g.np.ravel()}. return_wfn = kwargs.pop('return_wfn', False); return_history = kwargs.pop('return_history', False). if return_history:; step_energies = []; step_gradients = []; step_coordinates = []. # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()). # Do not change orientation or COM; molecule.fix_orientation(True); molecule.fix_com(True); molecule.update_geometry(). # Get geometric-specific options; optimizer_keywords = {k.lower(): v for k, v in kwargs.get(""optimizer_keywords"", {}).items()}. core.print_out('\n'); core.print_out(""\n ==> GeomeTRIC Optimizer <== ~\n""); ; # Default to Psi4 maxiter unless overridden; if 'maxiter' not in optimizer_keywords:; optimizer_keywords['maxiter'] = core.get_global_option('GEOM_MAXITER'). # Default to Psi4 geometry convergence criteria unless overridden ; if 'convergence_set' not in optimizer_keywords:; optimizer_keywords['convergence_set'] = core.g",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/driver.html:55430,energy,energy,55430,psi4manual/1.9.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/driver.html,6,"['ENERGY', 'energy']","['ENERGY', 'energy']"
Energy Efficiency,"name ROOT m (IN h) -> ROOT n (IN i) ROTATORY STRENGTH (VEL)¶. TD-fctl ROOT 0 (IN h) -> ROOT n (IN i) ROTATORY STRENGTH (VEL)¶; The velocity-gauge oscillator strength of the transition from root m within irrep h; to root n within irrep i.; DFT functional labeled if canonical. ADC ROOT 0 (h) -> ROOT n (i) ROTATORY STRENGTH (VEL)¶. CCname ROOT m (h) -> ROOT n (i) ROTATORY STRENGTH (VEL)¶. TD-fctl ROOT 0 (h) -> ROOT n (i) ROTATORY STRENGTH (VEL)¶; The velocity-gauge oscillator strength of the transition from root m to root n,; which are in irreps h and i, respectively..; DFT functional labeled if canonical. ADC ROOT 0 -> ROOT n ROTATORY STRENGTH (VEL) - h TRANSITION¶. CCname ROOT m -> ROOT n ROTATORY STRENGTH (VEL) - h TRANSITION¶. TD-fctl ROOT 0 -> ROOT n ROTATORY STRENGTH (VEL) - h TRANSITION¶; The velocity-gauge oscillator strength of the transition from root m to root n,; and the transition is of irrep h.; DFT functional labeled if canonical. ADC ROOT n TOTAL ENERGY - h TRANSITION¶; The total ADC energy of root n within irrep h. This variable is only defined for Psi’s; built-in ADC and will be removed for 1.7. ADC ROOT 0 -> ROOT n CORRELATION ENERGY - h TRANSITION¶; The correlation energy contribution to the excitation energy from the ground state to; root n within irrep h. This variable is only defined for Psi’s built-in ADC and will be removed for 1.7. AQCC DIPOLE¶; Dipole array [e a0] for the averaged quadratic coupled-cluster level of theory, (3,). AQCC QUADRUPOLE¶; Redundant quadrupole array [e a0^2] for the averaged quadratic coupled-cluster level of theory, (3, 3). AQCC TOTAL ENERGY¶. AQCC CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the averaged quadratic coupled-cluster level of theory. BRUECKNER CONVERGED¶; Value 1 (0) when the Brueckner orbitals have (have not) converged. CBS NUMBER¶. NBODY NUMBER¶. FINDIF NUMBER¶; Number of tasks [] the named procedure performs. These are immediate; tasks, so if procedu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/glossary_psivariables.html:7207,energy,energy,7207,psi4manual/1.6.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/glossary_psivariables.html,1,['energy'],['energy']
Energy Efficiency,"name of the; Molden file ends in ”.molden”, and the prefix is determined by; WRITER_FILE_LABEL (if set), or else by the name of the output; file plus the name of the current molecule. molden(wfn, filename)[source]¶; Function to write wavefunction information in wfn to filename in; molden format. Will write natural orbitals from density (MO basis) if supplied. New in version 0.5: wfn parameter passed explicitly. Returns:None. Parameters:; wfn (Wavefunction) – set of molecule, basis, orbitals from which to generate cube files; filename (string) – destination file name for MOLDEN file; density_a (psi4.Matrix) – density in the MO basis to build alpha NO’s from (optional); density_b (psi4.Matrix) – density in the MO basis to build beta NO’s from, assumes restricted if not supplied (optional). Examples:. >>> # [1] Molden file for DFT calculation; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> molden(wfn, 'mycalc.molden'). >>> # [2] Molden file for CI/MCSCF computation using NO roots; >>> E, wfn = energy('ci', return_wfn=True); >>> molden(wfn, 'no_root1.molden', density_a=wfn.opdm(0, 0, ""A"", True)). Options¶. MOLDEN_WRITE¶. Do write a MOLDEN output file? If so, the filename will end in .molden, and the prefix is determined by WRITER_FILE_LABEL (if set), or else by the name of the output file plus the name of the current molecule. Type: boolean; Default: false. WRITER_FILE_LABEL¶. Base filename for text files written by PSI, such as the MOLDEN output file, the Hessian file, the internal coordinate file, etc. Use the add_str_i function to make this string case sensitive. Type: string; Default: No Default. Table Of Contents. Interface to Molden, molden(); Options; MOLDEN_WRITE; WRITER_FILE_LABEL. Previous topic; Interface to PCMSolver; Next topic; Interface to MRCC by M. Kállay. This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; Psi4 [1.0.0 6a9a71b] » ; Interface",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/molden-1.html:2003,energy,energy,2003,psi4manual/1.0.0/molden-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/molden-1.html,2,['energy'],['energy']
Energy Efficiency,"name'), while; optimize perfoms a geometry optimization on each reagent, and; cbs performs a compound single-point energy. If a nested series; of python functions is intended (see Function Intercalls), use; keyword db_func instead of func. mode (string) – \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; Indicates whether the calculations required to complete the; database are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. cp (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicates whether counterpoise correction is employed in computing; interaction energies. Use this option and NOT the cp(); function for BSSE correction in database(). Option available; (See Available Databases) only for databases of bimolecular complexes. rlxd (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicates whether correction for deformation energy is; employed in computing interaction energies. Option available; (See Available Databases) only for databases of bimolecular complexes; with non-frozen monomers, e.g., HBC6. symm (boolean) – \(\Rightarrow\) 'on' \(\Leftarrow\) || 'off'; Indicates whether the native symmetry of the database reagents is; employed ('on') or whether it is forced to \(C_1\) symmetry; ('off'). Some computational methods (e.g., SAPT) require no; symmetry, and this will be set by database(). zpe (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicates whether zero-point-energy corrections are appended to; single-point energy values. Option valid only for certain; thermochemical databases. Disabled until Hessians ready. benchmark (string) – \(\Rightarrow\) 'default' \(\Leftarrow\) || 'S22A' || etc.; Indicates whether a non-default set of reference energies, if; available (See Available Databases), are employed for the; calculation of error statistics. tabulate (arra",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/db-1.html:2994,energy,energy,2994,psi4manual/1.2.1/db-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/db-1.html,6,['energy'],['energy']
Energy Efficiency,"name* values of the energy(), optimize(),; response(), and frequency() function. *name* can be assumed lowercase by here. """"""; import os; import sys; import shutil; import subprocess; import warnings. import numpy as np; from qcelemental import constants. from psi4 import extras; from psi4 import core; from psi4.driver import p4util; from psi4.driver import qcdb; from psi4.driver import psifiles as psif; from psi4.driver.p4util.exceptions import ManagedMethodError, PastureRequiredError, ValidationError; #from psi4.driver.molutil import *; from psi4.driver.qcdb.basislist import corresponding_basis; # never import driver, wrappers, or aliases into this file. from .roa import run_roa; from . import proc_util; from . import empirical_dispersion; from . import dft; from . import mcscf; from . import response; from . import solvent. # ATTN NEW ADDITIONS!; # consult http://psicode.org/psi4manual/master/proc_py.html. def select_mp2(name, **kwargs):; """"""Function selecting the algorithm for a MP2 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP2_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only [df]occ/dfmp2/detci/fnocc. # MP2_TYPE exists largely for py-side reasoning, so must manage it; # here rather than passing to c-side unprepared for validation. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'DFMP2']:; func = run_dfmp2; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'DFMP2']:; func = run_dfmp2; elif mtd_type == 'CD",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:2209,energy,energy,2209,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,4,['energy'],['energy']
Energy Efficiency,"name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_fnoccsd_t_(name, **kwargs):; """"""Function selecting the algorithm for a FNO-CCSD(T) energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('CC_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only fnocc. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in ['', 'FNOCC']:; func = run_fnocc; elif mtd_type == 'DF':; if module in ['', 'FNOCC']:; func = run_fnodfcc; elif mtd_type == 'CD':; if module in ['', 'FNOCC']:; func = run_fnodfcc. if func is None:; raise ManagedMethodError(['select_fnoccsd_t_', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_ccsd_t_(name, **kwargs):; """"""Function selecting the algorithm for a CCSD(T) energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('CC_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ/ccenergy/fnocc. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'FNOCC':; func = run_fnocc; elif module in ['', 'CCENERGY']:; func = run_ccenergy; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'FNOCC']:; func = run_fnodfcc; elif mtd_type == 'CD':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'FNOCC']:; func = run_fnodfcc; elif reference in ['UHF', 'ROHF']:; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy. if func is None:; raise ManagedMethodError(['select_ccsd_t_', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_ccsd_t__gradient(name, *",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:21929,energy,energy,21929,psi4manual/1.0.0/_modules/procedures/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html,1,['energy'],['energy']
Energy Efficiency,"name, **kwargs); E = PsiMod.get_variable('CURRENT ENERGY'); #E = func(**kwargs). # Save the energy; energies.append(E). # S/R: Write each displaced geometry to an input file; elif (opt_mode.lower() == 'sow'):; PsiMod.get_active_molecule().set_geometry(displacement). # S/R: Prepare molecule, options, and kwargs; freagent = open('%s.in' % (rfile), 'w'); freagent.write('# This is a psi4 input file auto-generated from the gradient() wrapper.\n\n'); freagent.write(format_molecule_for_input(molecule)); freagent.write(format_options_for_input()); format_kwargs_for_input(freagent, **kwargs). # S/R: Prepare function call and energy save; freagent.write(""""""electronic_energy = %s('%s', **kwargs)\n\n"""""" % (func.__name__, lowername)); freagent.write(""""""PsiMod.print_out('\\nGRADIENT RESULT: computation %d for item %d """""" % (os.getpid(), n + 1)); freagent.write(""""""yields electronic energy %20.12f\\n' % (electronic_energy))\n\n""""""); freagent.close(). # S/R: Read energy from each displaced geometry output file and save in energies array; elif (opt_mode.lower() == 'reap'):; E = 0.0; exec banners. try:; freagent = open('%s.out' % (rfile), 'r'); except IOError:; ValidationError('Aborting upon output file \'%s.out\' not found.\n' % (rfile)); return 0.0; else:; while 1:; line = freagent.readline(); if not line:; if E == 0.0:; ValidationError('Aborting upon output file \'%s.out\' has no %s RESULT line.\n' % (rfile, 'GRADIENT')); break; s = line.split(); if (len(s) != 0) and (s[0:3] == ['GRADIENT', 'RESULT:', 'computation']):; if int(s[3]) != opt_linkage:; raise ValidationError('Output file \'%s.out\' has linkage %s incompatible with master.in linkage %s.'; % (rfile, str(s[3]), str(opt_linkage))); if s[6] != str(n + 1):; raise ValidationError('Output file \'%s.out\' has nominal affiliation %s incompatible with item %s.'; % (rfile, s[6], str(n + 1))); if (s[8:10] == ['electronic', 'energy']):; E = float(s[10]); PsiMod.print_out('%s RESULT: electronic energy = %20.12f\n' % ('GRADIENT', E)); ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/driver.html:28557,energy,energy,28557,psi4manual/4.0b2/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/driver.html,2,['energy'],['energy']
Energy Efficiency,"name, **kwargs); E = PsiMod.get_variable('CURRENT ENERGY'); #E = func(**kwargs). # Save the energy; energies.append(E). # S/R: Write each displaced geometry to an input file; elif (opt_mode.lower() == 'sow'):; PsiMod.get_active_molecule().set_geometry(displacement). # S/R: Prepare molecule, options, and kwargs; freagent = open('%s.in' % (rfile), 'w'); freagent.write('# This is a psi4 input file auto-generated from the gradient() wrapper.\n\n'); freagent.write(format_molecule_for_input(molecule)); freagent.write(format_options_for_input()); format_kwargs_for_input(freagent, **kwargs). # S/R: Prepare function call and energy save; freagent.write(""""""electronic_energy = %s('%s', **kwargs)\n\n"""""" % (func.__name__, lowername)); freagent.write(""""""PsiMod.print_out('\\nGRADIENT RESULT: computation %d for item %d """""" % (os.getpid(), n + 1)); freagent.write(""""""yields electronic energy %20.12f\\n' % (electronic_energy))\n\n""""""); freagent.close(). # S/R: Read energy from each displaced geometry output file and save in energies array; elif (opt_mode.lower() == 'reap'):; E = 0.0; exec(banners). try:; freagent = open('%s.out' % (rfile), 'r'); except IOError:; ValidationError('Aborting upon output file \'%s.out\' not found.\n' % (rfile)); return 0.0; else:; while 1:; line = freagent.readline(); if not line:; if E == 0.0:; ValidationError('Aborting upon output file \'%s.out\' has no %s RESULT line.\n' % (rfile, 'GRADIENT')); break; s = line.split(); if (len(s) != 0) and (s[0:3] == ['GRADIENT', 'RESULT:', 'computation']):; if int(s[3]) != opt_linkage:; raise ValidationError('Output file \'%s.out\' has linkage %s incompatible with master.in linkage %s.'; % (rfile, str(s[3]), str(opt_linkage))); if s[6] != str(n + 1):; raise ValidationError('Output file \'%s.out\' has nominal affiliation %s incompatible with item %s.'; % (rfile, s[6], str(n + 1))); if (s[8:10] == ['electronic', 'energy']):; E = float(s[10]); PsiMod.print_out('%s RESULT: electronic energy = %20.12f\n' % ('GRADIENT', E));",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/driver.html:31051,energy,energy,31051,psi4manual/4.0b3/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/driver.html,4,['energy'],['energy']
Energy Efficiency,"name, molecule=molecule, **kwargs); translations_projection_sound, rotations_projection_sound = _energy_is_invariant(G0); core.print_out('\n Based on options and gradient (rms={:.2E}), recommend {}projecting translations and {}projecting rotations.\n'.; format(G0.rms(), '' if translations_projection_sound else 'not ',; '' if rotations_projection_sound else 'not ')); if not core.has_option_changed('FINDIF', 'FD_PROJECT'):; core.set_local_option('FINDIF', 'FD_PROJECT', rotations_projection_sound). # Does an analytic procedure exist for the requested method?; if dertype == 2:; core.print_out(""""""hessian() will perform analytic frequency computation.\n""""""). # We have the desired method. Do it.; wfn = procedures['hessian'][lowername](lowername, molecule=molecule, **kwargs); wfn.set_gradient(G0); optstash.restore(); optstash_conv.restore(). # TODO: check that current energy's being set to the right figure when this code is actually used; core.set_variable('CURRENT ENERGY', wfn.energy()); _hessian_write(wfn). if return_wfn:; return (wfn.hessian(), wfn); else:; return wfn.hessian(). elif dertype == 1:; core.print_out(""""""hessian() will perform frequency computation by finite difference of analytic gradients.\n""""""). # Shifting the geometry so need to copy the active molecule; moleculeclone = molecule.clone(). # Obtain list of displacements; displacements = core.fd_geoms_freq_1(moleculeclone, irrep); moleculeclone.reinterpret_coordentry(False); moleculeclone.fix_orientation(True). # Record undisplaced symmetry for projection of displaced point groups; core.set_parent_symmetry(molecule.schoenflies_symbol()). ndisp = len(displacements); print("""""" %d displacements needed."""""" % ndisp); gradients = []; energies = []. # S/R: Write instructions for sow/reap procedure to output file and reap input file; if freq_mode == 'sow':; instructionsO = """"""\n# The frequency sow/reap procedure has been selected through mode='sow'. In addition\n""""""; instructionsO += """"""# to this output file (which c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html:71053,energy,energy,71053,psi4manual/1.2.1/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html,1,['energy'],['energy']
Energy Efficiency,"name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_lccd_gradient(name, **kwargs):; """"""Function selecting the algorithm for a LCCD gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'); all_electron = (core.get_global_option('FREEZE_CORE') == ""FALSE""). func = None; if reference in ['RHF', 'UHF']:; if mtd_type == 'CONV':; if all_electron:; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module, all_electron]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_olccd(name, **kwargs):; """"""Function selecting the algorithm for an OLCCD energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_olccd_gradient(name, **kwargs):; """"""Function selecting the algorithm for an OLCCD gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_M",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:19895,energy,energy,19895,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,8,['energy'],['energy']
Energy Efficiency,"names that could be split into multiple words are staying as one.; Use MAXITER, CACHELEVEL, PUREAM, DERTYPE.; INTS (not integrals), also OEI (not oe_integrals) for; one-electron integrals and TEI (not te_integrals) for two-electron; integrals; PERTURB (not pert) for perturbation; Use PRINT options to indicate printing to output file. Use WRITE; options to indicate printing to another file. This probably isn’t; entirely valid now but should be observed in future. The complement to; WRITE is READ. PRINT, READ, and WRITE will usually; be the last words in an option name.; Use FOLLOW_ROOT for the state to be followed in geometry optimizations; WFN (not wavefunction); You’re welcome to use WFN and DERTYPE as internal options, but; plan to have these set by the python driver and mark them as !expert; options. Really avoid using JOBTYPE.; You’re not welcome to add CHARGE or MULTP options. Plan to get; these quantities from the molecule object. Since we frequently use subsets; of systems (with their own charge and multiplicity), this is safer.; Conform. Just grep 'add' psi4/src/read_options.cc to get a list of; all the option names in PSI4 and try to match any conventions you; find.; If you have a quantity you’d like to call a cutoff, a threshold, a; tolerance, or a convergence, consider the following guidelines in naming; it. If its value is typically greater than ~0.001, give it a name with CUTOFF.; If its value is typically less than ~0.001 and quantities being tested; against the option are more valuable with larger values (e.g.,; integrals, occupations, eigenvectors), give it a name with TOLERANCE.; If its value is typically less than ~0.001 and quantities being tested; against the option are more valuable with smaller values (e.g., energy; changes, residual errors, gradients), give it a name with; CONVERGENCE. In deciding how to arrange words in an option name, place the context; first (e.g., MP2_AMPS_PRINT, TRIPLES_DIIS). This means PRINT; will generally be at the end",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/manage_addon-1.html:8177,charge,charge,8177,psi4manual/1.4.0/manage_addon-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/manage_addon-1.html,9,['charge'],['charge']
Energy Efficiency,"names that could be split into multiple words are staying as one.; Use MAXITER, CACHELEVEL, PUREAM, DERTYPE.; INTS (not integrals), also OEI (not oe_integrals) for; one-electron integrals and TEI (not te_integrals) for two-electron; integrals; PERTURB (not pert) for perturbation; Use PRINT options to indicate printing to output file. Use WRITE; options to indicate printing to another file. This probably isn’t; entirely valid now but should be observed in future. The complement to; WRITE is READ. PRINT, READ, and WRITE will usually; be the last words in an option name.; Use FOLLOW_ROOT for the state to be followed in geometry optimizations; WFN (not wavefunction); You’re welcome to use WFN and DERTYPE as internal options, but; plan to have these set by the python driver and mark them as !expert; options. Really avoid using JOBTYPE.; You’re not welcome to add CHARGE or MULTP options. Plan to get; these quantities from the molecule object. Since we frequently use subsets; of systems (with their own charge and multiplicity), this is safer.; Conform. Just grep 'add' psi4/src/read_options.cc to get a list of; all the option names in PSI4 and try to match any conventions you; find.; If you have a quantity you’d like to call a cutoff, a threshold, a; tolerance, or a convergence, consider the following guidelines in naming; it.; If its value is typically greater than ~0.001, give it a name with CUTOFF.; If its value is typically less than ~0.001 and quantities being tested; against the option are more valuable with larger values (e.g.,; integrals, occupations, eigenvectors), give it a name with TOLERANCE.; If its value is typically less than ~0.001 and quantities being tested; against the option are more valuable with smaller values (e.g., energy; changes, residual errors, gradients), give it a name with; CONVERGENCE. In deciding how to arrange words in an option name, place the context; first (e.g., MP2_AMPS_PRINT, TRIPLES_DIIS). This means PRINT; will generally be at the en",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/manage_addon-1.html:8170,charge,charge,8170,psi4manual/1.2.1/manage_addon-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/manage_addon-1.html,4,['charge'],['charge']
Energy Efficiency,"nar C4NH4 TS. opt5; 6-31G** UHF CH2 3B1 optimization. Uses a Z-Matrix with dummy atoms, just for demo and testing purposes. cc23; ROHF-EOM-CCSD/DZ analytic gradient lowest state of H2O+ (A1 excitation). cc54; CCSD dipole with user-specified basis set. cc26; Single-point gradient, analytic and via finite-differences of 2-1A1 state of H2O with EOM-CCSD. fci-tdm; He2+ FCI/cc-pVDZ Transition Dipole Moment. rasci-c2-active; 6-31G* C2 Test RASCI Energy Point, testing two different ways of specifying the active space, either with the ACTIVE keyword, or with RAS1, RAS2, RESTRICTED_DOCC, and RESTRICTED_UOCC. dft3; DFT integral algorithms test, performing w-B97 RKS and UKS computations on water and its cation, using all of the different integral algorithms. This tests both the ERI and ERF integrals. tu2-ch2-energy; Sample UHF/6-31G** CH2 computation. cc16; UHF-B-CCD(T)/cc-pVDZ CH2 single-point energy (fzc, MO-basis ). sapt4; SAPT2+(3) aug-cc-pVDZ computation of the formamide dimer interaction energy, using the aug-cc-pVDZ-JKFIT DF basis for SCF and aug-cc-pVDZ-RI for SAPT. This example uses frozen core as well as MP2 natural orbital approximations. cc47; EOM-CCSD/cc-pVDZ on H2O2 with two excited states in each irrep. scf3; are specified explicitly. dftd3-energy; Exercises the various DFT-D corrections, both through python directly and through c++. pywrap-db1; Database calculation, so no molecule section in input file. Portions of the full databases, restricted by subset keyword, are computed by sapt0 and dfmp2 methods. cc52; CCSD Response for H2O2. pywrap-db2; Database calculation, run in sow/reap mode. cc50; EOM-CC3(ROHF) on CH radical with user-specified basis and properties for particular root. omp2-2; SCS-OMP2 cc-pVDZ geometry optimization for the H2O molecule. cc12; Single point energies of multiple excited states with EOM-CCSD. cisd-sp; 6-31G** H2O Test CISD Energy Point. mrcc4; CCSDT cc-pVDZ optimization and frequencies for the H2O molecule using MRCC. props1; RHF STO-",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_testsuite-1.html:10492,energy,energy,10492,psi4manual/4.0b3/autodoc_testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_testsuite-1.html,4,['energy'],['energy']
Energy Efficiency,"nary and NumPy representation of the Wavefunction. Return type; dict. tpdm(self: psi4.core.CIWavefunction, arg0: psi4.core.CIVector, arg1: psi4.core.CIVector, arg2: int, arg3: int) → List[psi4.core.Matrix]¶; docstring. transform_ci_integrals(self: psi4.core.CIWavefunction) → None¶; Transforms the one- and two-electron integrals for a CI computation. transform_mcscf_integrals(self: psi4.core.CIWavefunction, arg0: bool) → None¶; docstring. variable(key)¶; Return copy of scalar or array QCVariable key from self psi4.core.Wavefunction. Returns; Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles) are returned as numpy.ndarray of natural dimensionality.; Other array variables are returned as Matrix and may have an extra dimension with symmetry information. Return type; float or numpy.ndarray or Matrix. Parameters. cls (psi4.core.Wavefunction) – ; key (str) – . Example; >>> g, wfn = psi4.gradient(""hf/cc-pvdz"", return_wfn=True); >>> wfn.variable(""CURRENT ENERGY""); -100.00985995185668; >>> wfn.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> wfn.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> wfn.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). variables(include_deprecated_keys=False)¶; Return all scalar or array QCVariables from cls. Return type; Dict[str, Union[float, Matrix, ndarray]]. Parameters; include_deprecated_keys (bool) – . write_molden(filename=None, do_virtual=None, use_natural=False)¶; Function to write wavefunction information in wfn to filename in; molden format. Will write natural orbitals from density (MO basis) if supplied.; Warning! Most post-SCF Wavefunctions do not build the density as this is often; much more costly than the energy. In addition, the Wavefunction density attributes; (Da and Db) return the SO density and must be transformed to the MO basis; to use with this f",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.core.ciwavefunction.html:30843,ENERGY,ENERGY,30843,psi4manual/1.5.0/api/psi4.core.ciwavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.core.ciwavefunction.html,2,['ENERGY'],['ENERGY']
Energy Efficiency,"nary. PATH pointing to bin; PYTHONPATH pointing to lib (ordinary) or lib/pythonX.X/site-packages (conda); PSIDATADIR pointing to share/psi4. How to run Psi4 as executable after compilation¶; Substituting the full installation directory prefix and a; suitable scratch directory, issue the following commands directly in your; terminal or place them into your “rc” file and open a new terminal. (To; use a staged installation directory, substitute; objdir/stage for prefix.); # csh, tcsh: add to shell or ~/.tcshrc file; setenv PATH {prefix}/bin:$PATH; setenv PSI_SCRATCH /path/to/existing/writable/local-not-network/directory/for/scratch/files. # sh, bash: add to shell or ~/.bashrc (Linux/Windows) or ~/.bash_profile (Mac) file; export PATH={prefix}/bin:$PATH; export PSI_SCRATCH=/path/to/existing/writable/local-not-network/directory/for/scratch/files. Run PSI4.; 1; 2; 3; 4; 5; 6; 7; 8>>> cat sample.in; molecule {; He; }; energy('hf/cc-pvdz'); compare_values(-2.85518839, get_variable('current energy'), 5, 'SCF E'); >>> psi4 sample.in; SCF E.............................................................PASSED. todo how to check if current py is compatible with compilation. How to solve ModuleNotFoundError: No module named 'psi4'¶; You’re using PSI4 in PsiAPI mode (python input.py where; input.py contains import psi4) but the Python interpreter; can’t find the PSI4 Python module. Follow the directions at; How to configure paths for PsiAPI. How to configure paths for PsiAPI¶; If you know the location of the PSI4 executable (bin/psi4); for Psithon mode and want to know the corresponding location to add to; PYTHONPATH for PsiAPI mode, execute psi4 --psiapi-path. It; will return bash commands to set PATH (for correct python; interpreter) and PYTHONPATH (to find psi4 module) correctly,; after which import psi4 will work.; >>> psi4 --psiapi-path; export PATH=/path/to/dir/of/python/interpreter/against/which/psi4/compiled:$PATH; export PYTHONPATH=/path/to/dir/of/psi4/core-dot-so:$PYTHONPAT",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/build_planning-1.html:23422,energy,energy,23422,psi4manual/1.3.2/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/build_planning-1.html,2,['energy'],['energy']
Energy Efficiency,"nat_orbs"": True, ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""cepa(1)"", ""cepa_no_singles"": False,},. ""cepa(3)"": { ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""cepa(3)"", ""cepa_no_singles"": False,},; ""fno-cepa(3)"": {""nat_orbs"": True, ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""cepa(3)"", ""cepa_no_singles"": False,},. ""acpf"": { ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""acpf"", ""cepa_no_singles"": False,},; ""fno-acpf"": {""nat_orbs"": True, ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""acpf"", ""cepa_no_singles"": False,},. ""aqcc"": { ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""aqcc"", ""cepa_no_singles"": False,},; ""fno-aqcc"": {""nat_orbs"": True, ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""aqcc"", ""cepa_no_singles"": False,},. ""cisd"": { ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""cisd"", ""cepa_no_singles"": False,},; ""fno-cisd"": {""nat_orbs"": True, ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""cisd"", ""cepa_no_singles"": False,},; }. if name not in director:; raise ValidationError(f""Invalid method {name} for FNOCC energy""). # throw exception for open-shells; if (ref := core.get_option(""SCF"", ""REFERENCE"")) != ""RHF"":; raise ValidationError(f""Invalid reference type {ref} != RHF for FNOCC energy. See Capabilities Table at {dtl}""). # throw exception for DF/CD. some of these pre-trapped by select_* functions but others escape, incl. cepa variants; if (corl_type := method_algorithm_type(name).now) != ""CONV"":; raise ValidationError(f""Invalid type {corl_type} for FNOCC energy through `run_cepa`. See Capabilities Table at {dtl}""). for k, v in director[name].items():; core.set_local_option(""FNOCC"", k.upper(), v). ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if not core.get_option('FNOCC', 'USE_DF_INTS'):; # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn); else:; core.print_out("" Constructing Basis Sets for FISAPT...\n\n""); scf_aux_b",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:177526,energy,energy,177526,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,8,['energy'],['energy']
Energy Efficiency,"nations(cp_combos, interior_nbody):; combo_tuple = (x, basis_tuple); vmfc_compute_list[interior_nbody].add(combo_tuple); vmfc_level_list[len(basis_tuple)].add(combo_tuple). # Build a comprehensive compute_range; compute_list = {x: set() for x in nbody_range}; for n in nbody_range:; compute_list[n] |= cp_compute_list[n]; compute_list[n] |= nocp_compute_list[n]; compute_list[n] |= vmfc_compute_list[n]; core.print_out("" Number of %d-body computations: %d\n"" % (n, len(compute_list[n]))). metadata['compute_dict'] = {; 'all': compute_list,; 'cp': cp_compute_list,; 'nocp': nocp_compute_list,; 'vmfc_compute': vmfc_compute_list,; 'vmfc_levels': vmfc_level_list; }. return metadata. def compute_nbody_components(func, method_string, metadata):; """"""Computes requested N-body components. Performs requested computations for psi4::Molecule object `molecule` according to; `compute_list` with function `func` at `method_string` level of theory. Parameters; ----------; func : str; {'energy', 'gradient', 'hessian'}; Function object to be called within N-Body procedure.; method_string : str; Indicates level of theory to be passed to function `func`.; metadata : dict of str; Dictionary of N-body metadata. Required ``'key': value`` pairs:; ``'compute_list'``: dict of int: set; List of computations to perform. Keys indicate body-levels, e.g,. `compute_list[2]` is the; list of all 2-body computations required.; ``'kwargs'``: dict; Arbitrary keyword arguments to be passed to function `func`. Returns; -------; dict of str: dict; Dictionary containing computed N-body components. Contents:; ``'energies'``: dict of set: float64; Dictionary containing all energy components required for given N-body procedure.; ``'ptype'``: dict of set: float64 or dict of set: psi4.Matrix; Dictionary of returned quantities from calls of function `func` during N-body computations; ``'intermediates'``: dict of str: float64; Dictionary of psivars for intermediate N-body computations to be set at the end of the; N-body p",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html:15791,energy,energy,15791,psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html,4,['energy'],['energy']
Energy Efficiency,"nature :; | d get(N3psi6MatrixE {lvalue},i,i [,i]); | ; | identity(...); | identity( (Matrix)arg1) -> None :; | docstring; | ; | C++ signature :; | void identity(N3psi6MatrixE {lvalue}); | ; | invert(...); | invert( (Matrix)arg1) -> None :; | docstring; | ; | C++ signature :; | void invert(N3psi6MatrixE {lvalue}); | ; | load(...); | load( (Matrix)arg1, (str)arg2) -> None :; | docstring; | ; | C++ signature :; | void load(N3psi6MatrixE {lvalue},Ss); | ; | load_mpqc(...); | load_mpqc( (Matrix)arg1, (str)arg2) -> None :; | docstring; | ; | C++ signature :; | void load_mpqc(N3psi6MatrixE {lvalue},Ss); | ; | name(...); | name( (Matrix)arg1) -> str :; | docstring; | ; | C++ signature :; | Ss name(N3psi6MatrixE {lvalue}); | ; | nirrep(...); | nirrep( (Matrix)arg1) -> int :; | docstring; | ; | C++ signature :; | i nirrep(N3psi6MatrixE {lvalue}); | ; | partial_cholesky_factorize(...); | partial_cholesky_factorize( (Matrix)arg1, (float)arg2, (bool)arg3) -> Matrix :; | docstring; | ; | C++ signature :; | N5boost10shared_ptrIN3psi6MatrixEEE partial_cholesky_factorize(N3psi6MatrixE {lvalue},d,b); | ; | power(...); | power( (Matrix)arg1, (float)arg2, (float)arg3) -> Dimension :; | docstring; | ; | C++ signature :; | N3psi9DimensionE power(N3psi6MatrixE {lvalue},d,d); | ; | print_out(...); | print_out( (Matrix)arg1) -> None :; | docstring; | ; | C++ signature :; | void print_out(N3psi6MatrixE {lvalue}); | ; | project_out(...); | project_out( (Matrix)arg1, (Matrix)arg2) -> None :; | docstring; | ; | C++ signature :; | void project_out(N3psi6MatrixE {lvalue},N3psi6MatrixE {lvalue}); | ; | remove_symmetry(...); | remove_symmetry( (Matrix)arg1, (Matrix)arg2, (Matrix)arg3) -> None :; | docstring; | ; | C++ signature :; | void remove_symmetry(N3psi6MatrixE {lvalue},N5boost10shared_ptrIN3psi6MatrixEEE,N5boost10shared_ptrIN3psi6MatrixEEE); | ; | rms(...); | rms( (Matrix)arg1) -> float :; | docstring; | ; | C++ signature :; | d rms(N3psi6MatrixE {lvalue}); | ; | rowdim(...); | rowdim( (Mat",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:518407,power,power,518407,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['power'],['power']
Energy Efficiency,"nbodies for this level; # * modelchem level label (mc_level_lbl) used in qcvars and dict keys is 1-indexed counterpart to 0-indexed modelchem level position (mc_level_idx) used to navigate self.nbodies_per_mc_level; mc_level_lbl = list(mc_level_labels)[0]; nbodies = metadata['nbodies_per_mc_level'][mc_level_lbl - 1]; if nbodies[0] == 'supersystem':; # range for supersystem sub-components; nbodies = metadata['nbodies_per_mc_level'][mc_level_lbl]; metadata['bsse_type'] = ['nocp']. # regenerate per-bsse required calcs list; compute_dict = build_nbody_compute_list(; metadata['bsse_type'], nbodies, metadata['nfragments'], metadata[""return_total_data""], verbose=0; ). # Build size and slices dictionaries; fragment_size_dict = {}; fragment_slice_dict = {}; iat = 0; for ifr in range(1, metadata[""nfragments""] + 1):; nat = metadata[""molecule""].extract_subsets(ifr).natom(); fragment_size_dict[ifr] = nat; fragment_slice_dict[ifr] = slice(iat, iat + nat); iat += nat. def shaped_zero(der: DriverEnum):; if der == ""energy"":; return 0.0; elif der == ""gradient"":; arr_shape = (nat, 3); return np.zeros(arr_shape); elif der == 'hessian':; arr_shape = (nat * 3, nat * 3); return np.zeros(arr_shape). # Final dictionaries; if ptype == ""energy"":; cp_by_level = {n: 0.0 for n in range(1, nbodies[-1] + 1)}; nocp_by_level = {n: 0.0 for n in range(1, nbodies[-1] + 1)}; vmfc_by_level = {n: 0.0 for n in range(1, nbodies[-1] + 1)}. cp_body_dict = {n: 0.0 for n in range(1, nbodies[-1] + 1)}; nocp_body_dict = {n: 0.0 for n in range(1, nbodies[-1] + 1)}; vmfc_body_dict = {n: 0.0 for n in range(1, nbodies[-1] + 1)}. else:; nat = sum(fragment_size_dict.values()); if ptype == 'gradient':; arr_shape = (nat, 3); elif ptype == 'hessian':; arr_shape = (nat * 3, nat * 3). cp_by_level = {n: np.zeros(arr_shape) for n in range(1, nbodies[-1] + 1)}; nocp_by_level = {n: np.zeros(arr_shape) for n in range(1, nbodies[-1] + 1)}; vmfc_by_level = {n: np.zeros(arr_shape) for n in range(1, nbodies[-1] + 1)}. cp_body_dict =",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html:23413,energy,energy,23413,psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html,10,['energy'],['energy']
Energy Efficiency,"nbody']]; nbody_dict['Non-Counterpoise Corrected Interaction Energy'] = nocp_interaction_energy. for n in nbody_range[1:]:; var_key = 'NOCP-CORRECTED %d-BODY INTERACTION ENERGY' % n; nbody_dict[var_key] = nocp_energy_body_dict[n] - nocp_energy_body_dict[1]. # Compute vmfc ptype; if 'vmfc' in metadata['bsse_type_list']:; if metadata['ptype'] != 'energy':; for n in nbody_range:; if n > 1:; vmfc_ptype_body_dict[n] = vmfc_ptype_by_level[n - 1]; vmfc_ptype_body_dict[n] += vmfc_ptype_by_level[n]. _print_nbody_energy(vmfc_energy_body_dict, ""Valiron-Mayer Function Couterpoise (VMFC)"",; metadata['embedding_charges']); vmfc_interaction_energy = vmfc_energy_body_dict[metadata['max_nbody']] - vmfc_energy_body_dict[1]; nbody_dict['Valiron-Mayer Function Couterpoise Total Energy'] = vmfc_energy_body_dict[metadata['max_nbody']]; nbody_dict['Valiron-Mayer Function Couterpoise Interaction Energy'] = vmfc_interaction_energy. for n in nbody_range[1:]:; var_key = 'VMFC-CORRECTED %d-BODY INTERACTION ENERGY' % n; nbody_dict[var_key] = vmfc_energy_body_dict[n] - vmfc_energy_body_dict[1]. # Returns; results = {}; results['nbody'] = nbody_dict; for b in ['cp', 'nocp', 'vmfc']:; if monomer_energies != 0.0:; results['%s_energy_body_dict' % b] = eval('%s_energy_body_dict' % b); results['%s_energy_body_dict' % b] = {str(i) + b: j for i, j in results['%s_energy_body_dict' % b].items()}; else:; results['%s_energy_body_dict' % b] = {}. # Figure out and build return types; return_method = metadata['bsse_type_list'][0]. if return_method == 'cp':; results['ptype_body_dict'] = cp_ptype_body_dict; results['energy_body_dict'] = cp_energy_body_dict; elif return_method == 'nocp':; results['ptype_body_dict'] = nocp_ptype_body_dict; results['energy_body_dict'] = nocp_energy_body_dict; elif return_method == 'vmfc':; results['ptype_body_dict'] = vmfc_ptype_body_dict; results['energy_body_dict'] = vmfc_energy_body_dict; else:; raise ValidationError(; ""N-Body Wrapper: Invalid return type. Should never be here, p",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html:28731,ENERGY,ENERGY,28731,psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html,2,['ENERGY'],['ENERGY']
Energy Efficiency,"nbody>=2; zeroed if vmfc not in bsse_type; cumulative through 2-body total gradients with vmfc treatment.   {max_nbody}vmfc;   (nat, 3); when driver is g/h; zeroed if vmfc not in bsse_type; cumulative through {max_nbody}-body total gradients with vmfc treatment. vmfc_hessian_body_dict; max_nbody; when driver is h; zeroed if vmfc not in bsse_type; total Hessians at each n-body level with vmfc treatment.   1vmfc;   (nat*3, nat*3); when driver is h; zeroed if vmfc not in bsse_type; cumulative through 1-body total Hessians with vmfc treatment.   2vmfc;   (nat*3, nat*3); when driver is h & max_nbody>=2; zeroed if vmfc not in bsse_type; cumulative through 2-body total Hessians with vmfc treatment.   {max_nbody}vmfc;   (nat*3, nat*3); when driver is h; zeroed if vmfc not in bsse_type; cumulative through {max_nbody}-body total Hessians with vmfc treatment. intermediates; ntasks; always; all individual energies with nice labels.   N-BODY (1, 2)@(1, 2) TOTAL ENERGY;   1; always; total energy for 1st modelchem, 1st & 2nd fragments in basis of 1st & 2nd fragments.   N-BODY (3)@(2, 3) TOTAL ENERGY;   1; always; total energy for 2nd modelchem, 3rd fragment in basis of 2nd and 3rd fragments.   …. intermediates_energy; ntasks; always; all individual energies.   1_((1, 2), (1, 2));   1; always; total energy for 1st modelchem, 1st & 2nd fragments in basis of 1st & 2nd fragments.   2_((3,), (2, 3));   1; always; total energy for 2nd modelchem, 3rd fragment in basis of 2nd and 3rd fragments.   …. intermediates_gradient; ntasks; when driver is g/h; all individual gradients.   1_((1, 2), (1, 2));   (nat, 3); when driver is g/h; total gradient for 1st modelchem, 1st & 2nd fragments in basis of 1st & 2nd fragments.   2_((3,), (2, 3));   (nat, 3); when driver is g/h; total gradient for 2nd modelchem, 3rd fragment in basis of 2nd and 3rd fragments.   …. intermediates_hessian; ntasks; when driver is h; all individual Hessians.   1_((1, 2), (1, 2));   (nat*3, nat*3); when driver is h; total Hes",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/nbody.html:22162,energy,energy,22162,psi4manual/1.6.x/nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/nbody.html,5,['energy'],['energy']
Energy Efficiency,"nbody] must be present exactly once. Number of items in outer list is how many different modelchems. Each inner list specifies what n-bodies to be run at the corresponding modelchem (e.g., [[1, 2]] has max_nbody=2 and 1-body and 2-body contributions computed at the same level of theory; [[1], [2]] has max_nbody=2 and 1-body and 2-body contributions computed at different levels of theory. An entry ‘supersystem’ means all higher order n-body effects up to the number of fragments. The n-body levels are effectively sorted in the outer list, and any ‘supersystem’ element is at the end. field nfragments: int = -1¶; Number of distinct fragments comprising full molecular supersystem. Validated by:. set_nfragments. field quiet: bool = False¶; Whether to print/log formatted n-body energy analysis. Presently used by multi to suppress output. Candidate for removal from class once in-class/out-of-class functions sorted. field return_total_data: Optional[bool] = None¶; When True, returns the total data (energy/gradient/Hessian) of the system, otherwise returns interaction data. Default is False for energies, True for gradients and Hessians. Note that the calculation of total counterpoise corrected energies implies the calculation of the energies of monomers in the monomer basis, hence specifying return_total_data = True may carry out more computations than return_total_data = False. Validated by:. set_return_total_data. field task_list: Dict[str, Union[AtomicComputer, CompositeComputer, FiniteDifferenceComputer]] = {}¶. build_tasks(mb_computer, mc_level_idx, **kwargs)[source]¶; Adds to the task_list as many new unique tasks as necessary to treat a single model chemistry level at one or several n-body levels.; New tasks are of type mb_computer with model chemistry level specified in kwargs and n-body levels accessed through mc_level_idx. Parameters:. mb_computer (Union[AtomicComputer, CompositeComputer, FiniteDifferenceComputer]) – Class of task computers to instantiate and add to",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/nbody.html:14599,energy,energy,14599,psi4manual/1.7.x/nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/nbody.html,4,['energy'],['energy']
Energy Efficiency,"nc = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'MRCC' and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif module in ['', 'CCENERGY']:; func = run_ccenergy; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == ""UHF"":; if mtd_type == 'CONV':; if module in ['', 'MRCC'] and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif mtd_type == ""DF"":; if module in [""OCC""]: # SOON """",; func = run_dfocc; elif mtd_type == ""CD"":; if module in [""OCC""]: # SOON """",; func = run_dfocc; elif reference == ""ROHF"":; if mtd_type == 'CONV':; if module in ['', 'MRCC'] and which(""dmrcc"", return_bool=True):; func = run_mrcc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_cisd(name, **kwargs):; """"""Function selecting the algorithm for a CISD energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module in ['', 'FNOCC']:; func = run_cepa; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['', 'DETCI']:; func = run_detci. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp4(name, **kwargs):; """"""Function selecting the algorithm for a MP4 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:29354,energy,energy,29354,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,8,['energy'],['energy']
Energy Efficiency,"nc']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper complete_basis_set.' % (func.__name__)); if not(func is energy):; raise ValidationError('Wrapper complete_basis_set is unhappy to be calling function \'%s\' instead of \'energy\'.' % (func.__name__)). # Define some quantum chemical knowledge, namely what methods are subsumed in others; VARH = {}; VARH['scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['df-scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY'}; VARH['df-mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'df-mp2corl': 'DF-MP2 CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORRELATION ENERGY'}; VARH['ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['bccd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'bccdcorl': 'CCSD CORRELATION ENERGY'}; VARH['cc3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc3corl': 'CC3 CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['cisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdcorl': 'CISD CORRELATION ENERGY'}; VARH['cisdt'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdtcorl': 'CISDT CORRELATION ENERGY'}; VARH['cisdtq'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdtqcorl': 'CISDTQ CORRELATION ENERGY'}; VARH['fci'] = { 'scftot': 'SCF TOTAL ENERGY',; 'fcicorl': 'FCI CORRELATION ENERGY'}. for cilevel in range(2, 99):; VARH['ci%s' % (str(cilevel))] = {; 'scftot': 'SCF TOTAL ENERGY',; 'ci%scorl' % (str(cilevel)): 'CI CORRELATION ENERGY'}. finalenergy = 0.0; do_scf = 1; do_corl = 0; do_delta = 0; do_delta2 = 0. # Must collect (here) and set (below) basis sets after every new molecule",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html:60320,ENERGY,ENERGY,60320,psi4manual/4.0b3/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html,30,['ENERGY'],['ENERGY']
Energy Efficiency,"ncalled function; return [t.plan() for t in self.task_list.values()]. [docs]; def compute(self, client: Optional[""qcportal.FractalClient""] = None):; """"""Run each job in task list.""""""; instructions = ""\n"" + p4util.banner(f"" FiniteDifference Computations"", strNotOutfile=True) + ""\n""; logger.debug(instructions); core.print_out(instructions). with p4util.hold_options_state():; for t in self.task_list.values():; t.compute(client=client). def _prepare_results(self, client: Optional[""qcportal.FractalClient""] = None):; results_list = {k: v.get_results(client=client) for k, v in self.task_list.items()}. # load AtomicComputer results into findifrec[reference]; reference = self.findifrec[""reference""]; task = results_list[""reference""]; response = task.return_result; reference[""module""] = getattr(task.provenance, ""module"", None). if task.driver == 'energy':; reference['energy'] = response. elif task.driver == 'gradient':; reference['gradient'] = response; reference['energy'] = task.extras['qcvars']['CURRENT ENERGY']. elif task.driver == 'hessian':; reference['hessian'] = response; reference['energy'] = task.extras['qcvars']['CURRENT ENERGY']; if 'CURRENT GRADIENT' in task.extras['qcvars']:; reference['gradient'] = task.extras['qcvars']['CURRENT GRADIENT']. dipole_available = False; if 'CURRENT DIPOLE' in task.extras['qcvars']:; reference['dipole'] = task.extras['qcvars']['CURRENT DIPOLE']; dipole_available = True. # load AtomicComputer results into findifrec[displacements]; for label, displacement in self.findifrec[""displacements""].items():; task = results_list[label]; response = task.return_result. if task.driver == 'energy':; displacement['energy'] = response. elif task.driver == 'gradient':; displacement['gradient'] = response; displacement['energy'] = task.extras['qcvars']['CURRENT ENERGY']. elif task.driver == 'hessian':; displacement['hessian'] = response; displacement['energy'] = task.extras['qcvars']['CURRENT ENERGY']; if 'CURRENT GRADIENT' in task.extras['qcvars']:; displ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html:47260,ENERGY,ENERGY,47260,psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,3,['ENERGY'],['ENERGY']
Energy Efficiency,"nce computation, using the PubChem database to obtain the initial geometry, which is optimized at the HF/STO-3G level, before computing single point energies at the RHF, UHF and ROHF levels of theory. dcft8; DCFT calculation for the NH3+ radical using the ODC-12 and ODC-13 functionals. This performs both simultaneous and QC update of the orbitals and cumulant using DIIS extrapolation. Four-virtual integrals are first handled in the MO Basis for the first two energy computations. In the next computation ao_basis=disk algorithm is used, where the transformation of integrals for four-virtual case is avoided. fci-h2o; 6-31G H2O Test FCI Energy Point. opt2-fd; SCF DZ allene geometry optimzation, with Cartesian input. scf5; Test of all different algorithms and reference types for SCF, on singlet and triplet O2, using the cc-pVTZ basis set. fnocc4; Test FNO-DF-CCSD(T) energy. cc40; RHF-CC2-LR/cc-pVDZ optical rotation of H2O2. gauge = length, omega = (589 355 nm). dfccsdat1; DF-CCSD(AT) cc-pVDZ energy for the H2O molecule. opt10; 6-31G MP2 transition-state optimization with initial, computed Hessian. dcft5; DC-06 calculation for the O2 molecule (triplet ground state). This performs geometry optimization using two-step and simultaneous solution of the response equations for the analytic gradient. stability2; ROHF stability analysis check for CN with cc-pVDZ. This test corresponds to the rohf-stab test from Psi3. cc42; RHF-CC2-LR/STO-3G optical rotation of (S)-methyloxirane. gauge = length, omega = (589 355 nm). scf2; RI-SCF cc-pVTZ energy of water, with Z-matrix input and cc-pVTZ-RI auxilliary basis. cbs-xtpl-opt; Various extrapolated optimization methods for the H2 molecule. dfmp2-2; Density fitted MP2 energy of H2, using density fitted reference and automatic looping over cc-pVDZ and cc-pVTZ basis sets. Results are tabulated using the built in table functions by using the default options and by specifiying the format. cbs-xtpl-wrapper; RHF aug-cc-pVQZ energy for the BH mol",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html:3015,energy,energy,3015,psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"nce criteria for different calculation types. Type: conv double; Default: 1e-8. E_CONVERGENCE (MCSCF); MCSCF — Convergence criterion for energy. Type: conv double; Default: 1e-8. E_CONVERGENCE (MRCC); MRCC — Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. This becomes tol (option #16) in fort.56. Type: conv double; Default: 1e-8. E_CONVERGENCE (OCC); OCC — Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-8. E_CONVERGENCE (PSIMRCC); PSIMRCC — Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-8. E_CONVERGENCE (SAPT); SAPT — Convergence criterion for energy (change) in the SAPT term during solution of the CPHF equations. Type: conv double; Default: 1e-10. E_CONVERGENCE (SCF); SCF — Convergence criterion for SCF energy. See Table SCF Convergence & Algorithm for default convergence criteria for different calculation types. Type: conv double; Default: 1e-8. EA_POLES (OCC); OCC — Do compute OCC poles for electron affinities? Only valid for OMP2. Type: boolean; Default: false. EKT_EA (OCC); OCC — Do compute virtual orbital energies based on extended Koopmans’ theorem?. Type: boolean; Default: false. EKT_IP (OCC); OCC — Do compute occupied orbital energies based on extended Koopmans’ theorem?. Type: boolean; Default: false. EOM_GUESS (CCEOM); CCEOM — Specifies a set of single-excitation guess vectors for the EOM-CC procedure. If EOM_GUESS = SINGLES, the guess will be taken from the singles-singles block of the similarity-transformed Hamiltonian, Hbar. If EOM_GUESS = DISK, guess vectors from a previous computation will be read from disk. If EOM_GUESS = INPUT, guess vectors will be specified in user input. The latter method is not currently available. Type: string; Possible V",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodoc_glossary_options_c-1.html:38896,energy,energy,38896,psi4manual/4.0b4/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodoc_glossary_options_c-1.html,2,['energy'],['energy']
Energy Efficiency,"nce criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. E_CONVERGENCE (DFOCC)¶DFOCC — Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. E_CONVERGENCE (FNOCC)¶FNOCC — Convergence criterion for CC energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Note that convergence is met only when E_CONVERGENCE and R_CONVERGENCE are satisfied. Type: conv double; Default: 1.0e-6. E_CONVERGENCE (MCSCF)¶MCSCF — Convergence criterion for energy. Type: conv double; Default: 1e-6. E_CONVERGENCE (MRCC)¶MRCC — Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. This becomes tol (option #16) in fort.56. Type: conv double; Default: 1e-6. E_CONVERGENCE (OCC)¶OCC — Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. E_CONVERGENCE (PSIMRCC)¶PSIMRCC — Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. E_CONVERGENCE (SAPT)¶SAPT — Convergence criterion for energy (change) in the SAPT \(E_{ind,resp}^{(20)}\) term during solution of the CPHF equations. Type: conv double; Default: 1e-10. E_CONVERGENCE (SCF)¶SCF — Convergence criterion for SCF energy. See Table SCF Convergence & Algorithm for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. EA_POLES (OCC)¶OCC — Do compute OCC poles for electron affinities? Only valid for OMP2. Type: boolean; Default: false. EFP_DISP (EFP)¶EFP — Do include dispersion energy term in EFP computation?. Type: boolean; Default: true. EFP_DISP_DAMPING (EFP)¶EFP ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html:118225,energy,energy,118225,psi4manual/1.4.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html,2,['energy'],['energy']
Energy Efficiency,"nce criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. E_CONVERGENCE (FNOCC)¶FNOCC — Convergence criterion for CC energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Note that convergence is met only when E_CONVERGENCE and R_CONVERGENCE are satisfied. Type: conv double; Default: 1.0e-6. E_CONVERGENCE (MCSCF)¶MCSCF — Convergence criterion for energy. Type: conv double; Default: 1e-6. E_CONVERGENCE (MRCC)¶MRCC — Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. This becomes tol (option #16) in fort.56. Type: conv double; Default: 1e-6. E_CONVERGENCE (OCC)¶OCC — Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. E_CONVERGENCE (PSIMRCC)¶PSIMRCC — Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. E_CONVERGENCE (SAPT)¶SAPT — Convergence criterion for energy (change) in the SAPT \(E_{ind,resp}^{(20)}\) term during solution of the CPHF equations. Type: conv double; Default: 1e-10. E_CONVERGENCE (SCF)¶SCF — Convergence criterion for SCF energy. See Table SCF Convergence & Algorithm for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. EA_POLES (OCC)¶OCC — Do compute OCC poles for electron affinities? Only valid for OMP2. Type: boolean; Default: false. EFP_DISP (EFP)¶EFP — Do include dispersion energy term in EFP computation?. Type: boolean; Default: true. EFP_DISP_DAMPING (EFP)¶EFP — Fragment-fragment dispersion damping type. TT is a damping formula by Tang and Toennies. OVERLAP is overlap-based dispersion damping. Type: string; Possible Values: TT, OVERLAP, OFF; Default: O",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html:118424,energy,energy,118424,psi4manual/1.4.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html,2,['energy'],['energy']
Energy Efficiency,"nce of castup. Demonstrates (by comparison to castup2) that output file doesn’t depend on options (scf_type) being set global or local. This input uses local. cc50; EOM-CC3(ROHF) on CH radical with user-specified basis and properties for particular root. sapt-dft-api; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. freq-isotope1; Vibrational and thermo analysis of several water isotopologs. Demonstrates Hessian reuse for different temperatures and pressures but not for different isotopologs. dft-pbe0-2; Internal match to psi4, test to match to literature values in litref.in/litref.out. dft-grad-meta; meta-GGA gradients of water and ssh molecules reference gradients updated due to new BraggSlater radii. dft-freq; Frequencies for H2O B3LYP/6-31G* at optimized geometry. pywrap-cbs1; Various basis set extrapolation tests. mp2p5-grad2; MP2.5 cc-pVDZ gradient for the NO radical. dct10; The multiple guesses for DCT amplitudes for ODC-12. tu6-cp-ne2; Example potential energy surface scan and CP-correction for Ne2. dct-grad4; Unrestricted DF-DCT ODC-12 gradient for O2 with cc-pVTZ/cc-pVTZ-RI standard/auxiliary basis set. fsapt-ext; Quick test of external potential in F-SAPT (see fsapt1 for a real example). props4; Electrostatic potential and electric field evaluated on a grid around water. cc4; RHF-CCSD(T) cc-pVQZ frozen-core energy of the BH molecule, with Cartesian input. After the computation, the checkpoint file is renamed, using the PSIO handler. cc38; RHF-CC2-LR/cc-pVDZ static polarizabilities of HOF molecule. cc5; RHF CCSD(T) aug-cc-pvtz frozen-core energy of C4NH4 Anion. ghosts; Density fitted MP2 cc-PVDZ/cc-pVDZ-RI computation of formic acid dimer binding energy using explicit specification of ghost atoms. This is equivalent to the dfmp2_1 sample but uses both (equivalent) specifications of ghost atoms in a manual counterpoise correction. mom-h2o-3; MOM excitation from LUMO HOMO+3. psimrcc-ccsd_t-4; Mk-MRCCSD(T) single point. \(^1A_1\) O$_3` state d",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html:10931,energy,energy,10931,psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"nce the monomer whose energy will be subtracted from each of the three dimers.; RGC1-HeHe-0.85-dimer; RGC1-He-mono-unCP; RGC1-HeHe-1.0-dimer; RGC1-HeHe-1.5-dimer. At the end of the job, the Requested Energy table is printed that gives the total; energies for the requested model chemistry for each reagent and each reaction, as; well as the stoichoimetric weights by which the reagent energies are transfromed; into the reaction energy. In this case, the dimer is +1 and the monomer is -2,; indicating the the interaction energy is computed from dimer less first monomer; less second (identical) monomer. Error statistics are computed with respect to the reference; energies stored in the database. One of these, the mean absolute deviation, is; returned by the wrapper as an ordinary Python variable. (For databases; without a stored reference energy, e.g., BASIC, large and meaningless numbers are; printed for error.) The other two tables tabulate the PSI variables requested; through keyword tabulate, in this case the total SCF energy and the number; of atoms in each reagent.; ==> Mp2 Total Energy <==. ------------------------------------------------------------------------------------------------------; Reaction Reaction Value Reagent 1 Reagent 2; Value Wt Value Wt; ------------------------------------------------------------------------------------------------------; RGC1-HeHe-0.85 0.00004802 -5.69430495 1 -2.84717649 -2; RGC1-HeHe-1.0 -0.00000064 -5.69435362 1 -2.84717649 -2; ------------------------------------------------------------------------------------------------------. ==> Requested Energy <==. ------------------------------------------------------------------------------------------------------; Reaction Reaction Energy Reaction Error Reagent 1 Reagent 2; Ref Calc [kcal/mol] [kJ/mol] [Eh] Wt [Eh] Wt; ------------------------------------------------------------------------------------------------------; RGC1-HeHe-0.85 0.0376 0.0301 -0.0075 -0.0312 -5.69430495 1 -2.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/db-1.html:7391,energy,energy,7391,psi4manual/1.0.0/db-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/db-1.html,2,['energy'],['energy']
Energy Efficiency,"nce the monomer whose energy will be subtracted from each of the three dimers.; RGC1-HeHe-0.85-dimer; RGC1-He-mono-unCP; RGC1-HeHe-1.0-dimer; RGC1-HeHe-1.5-dimer. At the end of the job, the Requested Energy table is printed that gives the total; energies for the requested model chemistry for each reagent and each reaction, as; well as the stoichoimetric weights by which the reagent energies are transfromed; into the reaction energy. In this case, the dimer is +1 and the monomer is -2,; indicating the the interaction energy is computed from dimer less first monomer; less second (identical) monomer. Error statistics are computed with respect to the reference; energies stored in the database. One of these, the mean absolute deviation, is; returned by the wrapper as an ordinary Python variable. (For databases; without a stored reference energy, e.g., BASIC, large and meaningless numbers are; printed for error.) The other two tables tabulate the PSI variables requested; through keyword tabulate, in this case the total SCF energy and the number; of atoms in each reagent.; ==> Scf Total Energy <==. -----------------------------------------------------------------------------------; Reaction Reaction Value Reagent 1 Reagent 2; Value Wt Value Wt; -----------------------------------------------------------------------------------; RGC1-HeHe-0.85 0.00011520 -5.71020576 1 -2.85516048 -2; RGC1-HeHe-1.0 0.00000153 -5.71031943 1 -2.85516048 -2; RGC1-HeHe-1.5 -0.00000000 -5.71032096 1 -2.85516048 -2; -----------------------------------------------------------------------------------. ==> Natom <==. -----------------------------------------------------------------------------------; Reaction Reaction Value Reagent 1 Reagent 2; Value Wt Value Wt; -----------------------------------------------------------------------------------; RGC1-HeHe-0.85 0.00000000 2.00000000 1 1.00000000 -2; RGC1-HeHe-1.0 0.00000000 2.00000000 1 1.00000000 -2; RGC1-HeHe-1.5 0.00000000 2.00000000 1 1.00000000 ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/db-1.html:7054,energy,energy,7054,psi4manual/4.0b2/db-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/db-1.html,8,['energy'],['energy']
Energy Efficiency,"nce theories. MULLIKEN CHARGES¶; Property of partial atomic charges [e] by the method of Mulliken, (nat,). NAUX (SCF)¶. NAUX (CC)¶; Convenience storage of number of functions [] in the auxiliary basis; set for named stage of the calculation. NBODY (i, j, ..., k)@(a, b, ..., c) TOTAL ENERGY¶; The total energy [Eh] of a component of the requested N-Body energy.; The first parenthetical list over i, j, …, k enumerates; molecular fragments included in the computation in 1-indexed,; input-file order, while the second enumerates list over a, b,; …, c enumerates which fragments contribute basis functions to the; computation. For example, (1, 2)@(1, 2, 3, 4) indicates that the; fragments 1 and 2 are explicitly included in the energy computation,; with basis functions from each of fragments 1, 2, 3, & 4 included in; the basis set. Therefore, the basis functions from fragments 3 and 4; are included as ghost functions within the energy computation. NUCLEAR REPULSION ENERGY¶; The nuclear repulsion energy contribution [Eh] to the total SCF energy.; Quantity \(E_{NN}\) in Eq. (4). (3)¶\[E_{NN} = \sum_{i, j<i}^{N_{atom}}\frac{Z_i Z_j}{|\mathbf{R}_i - \mathbf{R}_j|}\]. OCEPA(0) TOTAL ENERGY¶. OCEPA(0) CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the orbital-optimized CEPA(0) level of theory. OLCCD TOTAL ENERGY¶. OLCCD CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the orbital-optimized linearized coupled cluster doubles level of theory. OLCCD REFERENCE CORRECTION ENERGY¶; The additional correction to the SCF reference energy [Eh]; for the orbital-optimized linearized coupled cluster doubles level of theory. OMP2 TOTAL ENERGY¶. OMP2 CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the orbital-optimized MP2 level of theory. OMP2.5 TOTAL ENERGY¶. OMP2.5 CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html:32879,energy,energy,32879,psi4manual/1.4.0/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html,10,['energy'],['energy']
Energy Efficiency,"nce with many computational details. # simple returns; E = energy(...); E = optimize(...); E = frequency(...); G = gradient(...) # used by optimize(); H = hessian(...) # used by frequency(). For more elaborate post-processing of computations, adding; return_wfn=True keyword argument additionally returns; Wavefunction.; # power user returns; E, wfn = energy(..., return_wfn=True); E, wfn = optimize(..., return_wfn=True); E, wfn = frequency(..., return_wfn=True); G, wfn = gradient(..., return_wfn=True) # used by optimize(); H, wfn = hessian(..., return_wfn=True) # used by frequency(). # print gradient array and its rms; wfn.gradient.print_out(); print wfn.gradient().rms(). # format output for other programs; molden(wfn, 'mycalc.molden'). # access array in another format; np.array(wfn.hessian()). Loops¶; Python provides many control structures, any of which can be used within PSI4; input files. For example, to loop over three basis sets, the following code can; be used:; basis_sets = [""cc-pVDZ"", ""cc-pVTZ"", ""cc-pVQZ""]; for basis_set in basis_sets:; set basis = $basis_set; energy('scf'). The declaration of basis_sets is completely standard Python, as is the next; line, which iterates over the list. However, because the Psithon preprocessor; wraps strings in quotes by default, we have to tell it that basis_set is a; Python variable, not a string, by prefixing it with a dollar sign.; The geometry specification supports delayed initialization of variable,; which permits potential energy scans. As an example, we can scan both the; angle and bond length in water:; molecule h2o{; O; H 1 R; H 1 R 2 A; }. Rvals = [0.9, 1.0, 1.1]; Avals = range(102, 106, 2). set basis cc-pvdz; set scf e_convergence=11; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('scf'). The declarations of Rvals and Avals are both completely standard Python syntax.; Having named our molecule h2o we can then set the values of R and A within; the loops. Note that we do not need the dollar sign to a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/psithoninput-1.html:10631,energy,energy,10631,psi4manual/1.4.0/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/psithoninput-1.html,8,['energy'],['energy']
Energy Efficiency,"nce with many computational details. # simple returns; E = energy(...); E = optimize(...); E = frequency(...); G = gradient(...) # used by optimize(); H = hessian(...) # used by frequency(). For more elaborate post-processing of computations, adding; return_wfn=True keyword argument additionally returns; Wavefunction.; # power user returns; E, wfn = energy(..., return_wfn=True); E, wfn = optimize(..., return_wfn=True); E, wfn = frequency(..., return_wfn=True); G, wfn = gradient(..., return_wfn=True) # used by optimize(); H, wfn = hessian(..., return_wfn=True) # used by frequency(). # print gradient array and its rms; wfn.gradient.print_out(); print wfn.gradient().rms(). # format output for other programs; molden(wfn, 'mycalc.molden'). # access array in another format; np.array(wfn.hessian()). Loops¶; Python provides many control structures, any of which can be used within Psi4; input files. For example, to loop over three basis sets, the following code can; be used:; basis_sets = [""cc-pVDZ"", ""cc-pVTZ"", ""cc-pVQZ""]; for basis_set in basis_sets:; set basis = $basis_set; energy('scf'). The declaration of basis_sets is completely standard Python, as is the next; line, which iterates over the list. However, because the Psithon preprocessor; wraps strings in quotes by default, we have to tell it that basis_set is a; Python variable, not a string, by prefixing it with a dollar sign.; The geometry specification supports delayed initialization of variable,; which permits potential energy scans. As an example, we can scan both the; angle and bond length in water:; molecule h2o{; O; H 1 R; H 1 R 2 A; }. Rvals = [0.9, 1.0, 1.1]; Avals = range(102, 106, 2). set basis cc-pvdz; set scf e_convergence=11; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('scf'). The declarations of Rvals and Avals are both completely standard Python syntax.; Having named our molecule h2o we can then set the values of R and A within; the loops. Note that we do not need the dollar sign to a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/psithoninput-1.html:11199,energy,energy,11199,psi4manual/1.0.0/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/psithoninput-1.html,2,['energy'],['energy']
Energy Efficiency,"ncies (roundoff errors of around 0.1 cm-1 may exist):; Irrep Harmonic Frequency; (cm-1); -----------------------------------------------; A1 1776.2423; A1 4113.7717; B2 4211.8290; -----------------------------------------------. Notice that the symmetry type of the normal modes is specified (A1, A1,; B2). The program also prints out the normal modes in terms of Cartesian; coordinates of each atom. For example, the normal mode at 1776 cm-1; is:; Frequency: 1776.24; Force constant: 0.1194; X Y Z mass; O 0.000 0.000 -0.270 15.994915; H 0.000 0.418 0.538 1.007825; H 0.000 -0.418 0.538 1.007825. where the table shows the displacements in the X, Y, and Z dimensions for; each atom along the normal mode coordinate. (This information could be used; to animate the vibrational frequency using visualization software.). Analysis of Intermolecular Interactions¶; Now let’s consider something a little more interesting. PSI4; contains code to analyze the nature of intermolecular interactions; between two molecules, via symmetry-adapted perturbation theory; (SAPT) [Jeziorski:1994:1887]. This kind of analysis gives a lot; of insight into the nature of intermolecular interactions, and PSI4; makes these computations easier than ever.; For a SAPT computation, the input needs to provide information on two; distinct molecules. This is very easy, we just give a Z-matrix or set of; Cartesian coordinates for each molecule, and separate the two with two; dashes, like this:; # Example SAPT computation for ethene*ethine (i.e., ethylene*acetylene),; # test case 16 from the S22 database. molecule dimer {; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.923621 1.232253 -2.126185; --; 0 1; C 0.000000 0.000000 2.900503; C 0.000000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; units angstrom. no_reorient; symmetry c1; }. Notice we have a couple of new",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/tutorial-1.html:8396,adapt,adapted,8396,psi4manual/4.0b4/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/tutorial-1.html,2,['adapt'],['adapted']
Energy Efficiency,"ncies (roundoff errors of around 0.1 cm-1 may exist):; Irrep Harmonic Frequency; (cm-1); -----------------------------------------------; A1 1776.2423; A1 4113.7717; B2 4211.8290; -----------------------------------------------. Notice that the symmetry type of the normal modes is specified (A1, A1,; B2). The program also prints out the normal modes in terms of Cartesian; coordinates of each atom. For example, the normal mode at 1776 cm-1; is:; Frequency: 1776.24; Force constant: 0.1194; X Y Z mass; O 0.000 0.000 -0.270 15.994915; H 0.000 0.418 0.538 1.007825; H 0.000 -0.418 0.538 1.007825. where the table shows the displacements in the X, Y, and Z dimensions for; each atom along the normal mode coordinate. (This information could be used; to animate the vibrational frequency using visualization software.). Analysis of Intermolecular Interactions¶; Now let’s consider something a little more interesting. PSI4; contains code to analyze the nature of intermolecular interactions; between two molecules, via symmetry-adapted perturbation theory; (SAPT) [Jeziorski:1994:1887]. This kind of analysis gives a lot; of insight into the nature of intermolecular interactions, and PSI4; makes these computations easier than ever.; For a SAPT computation, the input needs to provide information on two; distinct molecules. This is very easy, we just give a Z-matrix or set of; Cartesian coordinates for each molecule, and separate the two with two; dashes, like this:; # Example SAPT computation for ethene*ethine (i.e., ethylene*acetylene),; # test case 16 from the S22 database. molecule dimer {; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.923621 1.232253 -2.126185; --; 0 1; C 0.000000 0.000000 2.900503; C 0.000000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; units angstrom. }. Here’s the second half of the input, where we specify th",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/tutorial-1.html:8396,adapt,adapted,8396,psi4manual/4.0b5/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/tutorial-1.html,2,['adapt'],['adapted']
Energy Efficiency,"ncies. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; frequencies. frequencies¶. psi4.driver.frequencies(name, **kwargs)¶; Function to compute harmonic vibrational frequencies. Aliases:; frequencies(), freq(). Returns:; float – Total electronic energy in Hartrees. Returns:; (float, Wavefunction) – energy and wavefunction when return_wfn specified. Parameters:. name (str) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. dertype (dertype) – \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- they’re not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or str) – \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences acc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.frequencies.html:1000,energy,energy,1000,psi4manual/1.8.x/api/psi4.driver.frequencies.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.frequencies.html,2,['energy'],['energy']
Energy Efficiency,"ncies. Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. PSI4 API: Linking C++ and Python; frequencies. frequencies¶. psi4.driver.frequencies(name, **kwargs)¶; Function to compute harmonic vibrational frequencies. Aliases:; frequencies(), freq(). Returns:; float – Total electronic energy in Hartrees. Returns:; (float, Wavefunction) – energy and wavefunction when return_wfn specified. Parameters:. name (str) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. dertype (dertype) – \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- they’re not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or str) – \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences acc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/api/psi4.driver.frequencies.html:1000,energy,energy,1000,psi4manual/1.9.x/api/psi4.driver.frequencies.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.driver.frequencies.html,2,['energy'],['energy']
Energy Efficiency,"ncing PSI4 Capabilities. Interface to programs through FCHK files — fchk()¶; Code author: Andrew C. Simmonett; Section author: Andrew C. Simmonett; Many post-processing tools can read information from Gaussian’s formatted; checkpoint (FCHK) files.; To allow interoperability with such tools, PSI4 includes a utility to; generate FCHK files. Wavefunction information, such as orbitals, densities,; orbital energies and basis set information is currently supported, but geometry; optimization and vibrational frequency information are not supported at this; time. To generate a FCHK file, simply store the wavefunction from the energy; calculation, and use it to create an FCHK writer:; 1; 2; 3energy, wfn = energy('scf', return_wfn=True); fchk_writer = psi4.FCHKWriter(wfn); fchk_writer.write('output.fchk'). The file will be written to the name passed to the FCHK writer’s write(); method. Note that for MP2 and CCSD methods, the energy can be computed without; the expensive steps required to compute the density, so energy calls for these; methods will return a wavefunction that has the Hartree–Fock density. If a; density is required for these methods, the user should instead request a; gradient computation, to ensure that the density is updated appropriately:; 1; 2; 3grad, wfn = gradient('mp2', return_wfn=True); fchk_writer = psi4.FCHKWriter(wfn); fchk_writer.write('output.fchk'). psi4.fchk(wfn, filename)[source]¶; Function to write wavefunction information in wfn to filename in; Gaussian FCHK format. New in version 0.6. Returns:None. Parameters:; filename (string) – destination file name for FCHK file; wfn (Wavefunction) – set of molecule, basis, orbitals from which to generate fchk file. Examples:. 1; 2; 3>>> # [1] FCHK file for DFT calculation; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> fchk(wfn, 'mycalc.fchk'). Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. © Copyright 2017, The Psi4 Project.; Last updated",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/fchk-1.html:1068,energy,energy,1068,psi4manual/1.1.0/fchk-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/fchk-1.html,4,['energy'],['energy']
Energy Efficiency,ncluding perturbative triples :ref:`[manual] <sec:sapt>` |; +-------------------------+---------------------------------------------------------------------------------------+; | sapt2+3 | SAPT including all 3rd-order terms :ref:`[manual] <sec:sapt>` |; +-------------------------+---------------------------------------------------------------------------------------+; | sapt2+(ccd) | SAPT2+ with CC-based dispersion :ref:`[manual] <sec:sapt>` |; +-------------------------+---------------------------------------------------------------------------------------+; | sapt2+(3)(ccd) | SAPT2+(3) with CC-based dispersion :ref:`[manual] <sec:sapt>` |; +-------------------------+---------------------------------------------------------------------------------------+; | sapt2+3(ccd) | SAPT2+3 with CC-based dispersion :ref:`[manual] <sec:sapt>` |; +-------------------------+---------------------------------------------------------------------------------------+; | sapt0-ct | 0th-order SAPT plus charge transfer (CT) calculation :ref:`[manual] <sec:saptct>` |; +-------------------------+---------------------------------------------------------------------------------------+; | sapt2-ct | SAPT2 plus CT :ref:`[manual] <sec:saptct>` |; +-------------------------+---------------------------------------------------------------------------------------+; | sapt2+-ct | SAPT2+ plus CT :ref:`[manual] <sec:saptct>` |; +-------------------------+---------------------------------------------------------------------------------------+; | sapt2+(3)-ct | SAPT2+(3) plus CT :ref:`[manual] <sec:saptct>` |; +-------------------------+---------------------------------------------------------------------------------------+; | sapt2+3-ct | SAPT2+3 plus CT :ref:`[manual] <sec:saptct>` |; +-------------------------+---------------------------------------------------------------------------------------+; | sapt2+(ccd)-ct | SAPT2+(CCD) plus CT :ref:`[manual] <sec:saptct>` |; +-------------------------+------,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/driver.html:17165,charge,charge,17165,psi4manual/4.0b4/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/driver.html,4,['charge'],['charge']
Energy Efficiency,"nction encoding sequence of module calls for a pure EFP; computation (ignore any QM atoms). """""". efp_molecule = kwargs.get('molecule', core.get_active_molecule()); try:; efpobj = efp_molecule.EFP; except AttributeError:; raise ValidationError(""""""Method 'efp' not available without EFP fragments in molecule""""""). # print efp geom in [A]; core.print_out(efpobj.banner()); core.print_out(efpobj.geometry_summary(units_to_bohr=constants.bohr2angstroms)). # set options; # * 'chtr', 'qm_exch', 'qm_disp', 'qm_chtr' may be enabled in a future libefp release; efpopts = {}; for opt in ['elst', 'exch', 'ind', 'disp',; 'elst_damping', 'ind_damping', 'disp_damping']:; psiopt = 'EFP_' + opt.upper(); if core.has_option_changed('EFP', psiopt):; efpopts[opt] = core.get_option('EFP', psiopt); efpopts['qm_elst'] = False; efpopts['qm_ind'] = False; efpobj.set_opts(efpopts, label='psi', append='psi'); do_gradient = core.get_option('EFP', 'DERTYPE') == 'FIRST'. # compute and report; efpobj.compute(do_gradient=do_gradient); core.print_out(efpobj.energy_summary(label='psi')). ene = efpobj.get_energy(label='psi'); core.set_variable('EFP ELST ENERGY', ene['electrostatic'] + ene['charge_penetration'] + ene['electrostatic_point_charges']); core.set_variable('EFP IND ENERGY', ene['polarization']); core.set_variable('EFP DISP ENERGY', ene['dispersion']); core.set_variable('EFP EXCH ENERGY', ene['exchange_repulsion']); core.set_variable('EFP TOTAL ENERGY', ene['total']); core.set_variable('CURRENT ENERGY', ene['total']). if do_gradient:; core.print_out(efpobj.gradient_summary()). torq = efpobj.get_gradient(); torq = core.Matrix.from_array(np.asarray(torq).reshape(-1, 6)); core.set_variable(""EFP TORQUE"", torq) # P::e EFP. return ene['total']. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.8.2;  · . PSI4. Module code; psi4.driver.procrouting.proc. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:04AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:184509,ENERGY,ENERGY,184509,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,6,['ENERGY'],['ENERGY']
Energy Efficiency,"nction encoding sequence of module calls for a pure EFP; computation (ignore any QM atoms). """""". efp_molecule = kwargs.get('molecule', core.get_active_molecule()); try:; efpobj = efp_molecule.EFP; except AttributeError:; raise ValidationError(""""""Method 'efp' not available without EFP fragments in molecule""""""). # print efp geom in [A]; core.print_out(efpobj.banner()); core.print_out(efpobj.geometry_summary(units_to_bohr=constants.bohr2angstroms)). # set options; # * 'chtr', 'qm_exch', 'qm_disp', 'qm_chtr' may be enabled in a future libefp release; efpopts = {}; for opt in ['elst', 'exch', 'ind', 'disp',; 'elst_damping', 'ind_damping', 'disp_damping']:; psiopt = 'EFP_' + opt.upper(); if core.has_option_changed('EFP', psiopt):; efpopts[opt] = core.get_option('EFP', psiopt); efpopts['qm_elst'] = False; efpopts['qm_ind'] = False; efpobj.set_opts(efpopts, label='psi', append='psi'); do_gradient = core.get_option('EFP', 'DERTYPE') == 'FIRST'. # compute and report; efpobj.compute(do_gradient=do_gradient); core.print_out(efpobj.energy_summary(label='psi')). ene = efpobj.get_energy(label='psi'); core.set_variable('EFP ELST ENERGY', ene['electrostatic'] + ene['charge_penetration'] + ene['electrostatic_point_charges']); core.set_variable('EFP IND ENERGY', ene['polarization']); core.set_variable('EFP DISP ENERGY', ene['dispersion']); core.set_variable('EFP EXCH ENERGY', ene['exchange_repulsion']); core.set_variable('EFP TOTAL ENERGY', ene['total']); core.set_variable('CURRENT ENERGY', ene['total']). if do_gradient:; core.print_out(efpobj.gradient_summary()). torq = efpobj.get_gradient(); torq = core.Matrix.from_array(np.asarray(torq).reshape(-1, 6)); core.set_variable(""EFP TORQUE"", torq) # P::e EFP. return ene['total']. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.9.1;  · . PSI4. Module code; psi4.driver.procrouting.proc. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/procrouting/proc.html:185023,ENERGY,ENERGY,185023,psi4manual/1.9.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/procrouting/proc.html,6,['ENERGY'],['ENERGY']
Energy Efficiency,"nction is not called. :type max_nbody: int; :param max_nbody: ``3`` || etc. Maximum n-body to compute, cannot exceed the number of fragments in the moleucle. :type ptype: string; :param ptype: ``'energy'`` || ``'gradient'`` || ``'hessian'``. Type of the procedure passed in. :type return_total_data: :ref:`boolean <op_py_boolean>`; :param return_total_data: ``'on'`` || |dl| ``'off'`` |dr|. If True returns the total data (energy/gradient/etc) of the system,; otherwise returns interaction data. :type levels: dict; :param levels: ``{1: 'ccsd(t)', 2: 'mp2', 'supersystem': 'scf'}`` || ``{1: 2, 2: 'ccsd(t)', 3: 'mp2'}`` || etc. Dictionary of different levels of theory for different levels of expansion; Note that method_string is not used in this case.; supersystem computes all higher order n-body effects up to nfragments. :type embedding_charges: dict; :param embedding_charges: ``{1: [-0.834, 0.417, 0.417], ..}``. Dictionary of atom-centered point charges. keys: 1-based index of fragment, values: list of charges for each fragment. :type charge_method: string; :param charge_method: ``scf/6-31g`` || ``b3lyp/6-31g*`` || etc. Method to compute point charges for monomers. Overridden by embedding_charges if both are provided. :type charge_type: string; :param charge_type: ``MULLIKEN_CHARGES`` || ``LOWDIN_CHARGES`` . Default is ``MULLIKEN_CHARGES``; """""". # Initialize dictionaries for easy data passing; metadata, component_results, nbody_results = {}, {}, {}. # Parse some kwargs; kwargs = p4util.kwargs_lower(kwargs); if kwargs.get('levels', False):; return driver_nbody_helper.multi_level(func, **kwargs); metadata['ptype'] = kwargs.pop('ptype', None); metadata['return_wfn'] = kwargs.pop('return_wfn', False); metadata['return_total_data'] = kwargs.pop('return_total_data', False); metadata['molecule'] = kwargs.pop('molecule', core.get_active_molecule()); metadata['molecule'].update_geometry(); metadata['molecule'].fix_com(True); metadata['molecule'].fix_orientation(True); metadata['em",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_nbody.html:5953,charge,charges,5953,psi4manual/1.3.2/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_nbody.html,1,['charge'],['charges']
Energy Efficiency,"nction) – highest_1 || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the second delta correction; to the correlation energy. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> cbs('scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> cbs('mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> cbs('scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> cbs('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] cbs() coupled with database(); >>> database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='sto-3g'). Output¶; At the beginning of a cbs() job is printed a listing of the individual; energy calculations which will be performed. The output snippet below is; from the example job [2] above. It shows first each model chemistry needed",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/cbs-1.html:6480,energy,energy,6480,psi4manual/4.0b2/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/cbs-1.html,4,['energy'],['energy']
Energy Efficiency,"nction) → psi4.core.Vector¶; Returns the set atomic point charges. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.Wavefunction, basis: psi4.core.BasisSet) → psi4.core.Wavefunction¶; Returns a new wavefunction with internal data converted to \(C_1\) symmetry, using pre-c1-constructed basis. ci_nat_orbs(self: psi4.core.CIWavefunction) → None¶; docstring. cleanup_ci(self: psi4.core.CIWavefunction) → None¶; docstring. cleanup_dpd(self: psi4.core.CIWavefunction) → None¶; docstring. compute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. compute_state_transfer(self: psi4.core.CIWavefunction, arg0: psi4.core.CIVector, arg1: int, arg2: psi4.core.Matrix, arg3: psi4.core.CIVector) → None¶; docstring. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Deep copies the internal data. del_array_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) Matrix QC variable. del_potential_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) ExternalPotential QC variable. (This function is provisional and might be removed in the future.). del_scalar_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) double QC variable. del_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ciwavefunction.html:14134,energy,energy,14134,psi4manual/1.4.0/api/psi4.core.ciwavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ciwavefunction.html,3,['energy'],['energy']
Energy Efficiency,"nction, which takes either a string like '30 GB' (with units!) or; an integer number of bytes of memory as its argument. Next, our; molecular geometry is passed as a string into psi4.geometry(); API.; We may input this geometry in either Z-matrix or Cartesian format; to; allow the string to break over multiple lines, use Python’s triple-quote; """"""string"""""" syntax. Finally, we will compute the Hartree-Fock SCF; energy with the cc-pVDZ basis set by passing the method/basis set as a; string ('scf/cc-pvdz') into the function psi4.energy(); API:. In [3]:. #! Sample HF/cc-pVDZ H2O Computation. psi4.set_memory('500 MB'). h2o = psi4.geometry(""""""; O; H 1 0.96; H 1 0.96 2 104.5; """"""). psi4.energy('scf/cc-pvdz'). Out[3]:. -76.02663273488399. If everything goes well, the computation should complete and should; report a final restricted Hartree-Fock energy in the output file; output.dat in a section like this:; Energy converged. @DF-RHF Final Energy: -76.02663273486682. By default, the energy should be converged to about; \(1.0\times 10^{-6}\), so agreement is only expected for about the; first 6 digits after the decimal. If the computation does not complete,; there is probably a problem with the compilation or installation of the; program (see the installation instructions in the main Psi4 manual; section Compiling and Installing from; Source).; This very simple input is sufficient to run the requested information.; Notice we didn’t tell the program some otherwise useful information like; the charge of the molecule (0, it’s neutral), the spin multiplicity (1; for a closed-shell molecule with all electrons paired), or the reference; wavefunction to use (restricted Hartree-Fock, or RHF, is usually; appropriate for a closed-shell molecule). The program correctly guessed; all of these options for us. We can change the default behavior through; additional keywords.; Let’s consider what we would do for an open-shell molecule, where not; all the electrons are paired. For example, let’",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psiapi-1.html:3785,energy,energy,3785,psi4manual/1.1.0/psiapi-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psiapi-1.html,4,['energy'],['energy']
Energy Efficiency,"nction. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. mode (string) – \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies or gradients frequency, indicates; whether the calculations required to complete the frequency are to be run; in one file ('continuous') or are to be farmed out in an; embarrassingly parallel fashion ('sow'/'reap')/ For the latter,; run an initial job with 'sow' and follow instructions in its output file.; For maximum flexibility, return_wfn is always on in 'reap' mode. dertype (dertype) – \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- they’re not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or string) – \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. name; calls method. scf; Hartree–Fock (HF) [manual]. Examples:. 1; 2>>> # [1] Frequency calculation for all modes through highest available derivatives; >>> frequency('ccsd'). 1; 2; 3; 4; 5>>> # [2] Frequency calculation for b2 modes through finite difference of gradients; >>> # printing lowest mode frequency to screen and Hessian to output; >>> E, wfn = frequencies('scf', dertype=1, ir",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/freq-1.html:2473,energy,energy,2473,psi4manual/1.1.0/freq-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/freq-1.html,13,['energy'],['energy']
Energy Efficiency,"nction>(...); | ; | __setattr__ = new_set_attr(self, name, value); | Function to redefine __setattr__ method of molecule class.; | ; | activate_all_fragments(...); | activate_all_fragments( (Molecule)arg1) -> None :; | Sets all fragments in the molecule to be active; | ; | add_atom(...); | add_atom( (Molecule)arg1, (int)arg2, (float)arg3, (float)arg4, (float)arg5, (str)arg6, (float)arg7, (float)arg8, (int)arg9) -> None :; | Adds to Molecule arg1 an atom with atomic number arg2, Cartesian coordinates in Bohr (arg3, arg4, arg5), atomic symbol arg6, mass arg7, charge arg8 (optional), and lineno arg9 (optional); | ; | atom_at_position(...); | atom_at_position( (Molecule)arg1, (float)arg2, (float)arg3) -> int :; | Tests to see if an atom is at the position arg2 with a given tolerance arg3; | ; | center_of_mass(...); | center_of_mass( (Molecule)arg1) -> Vector3 :; | Computes center of mass of molecule (does not translate molecule); | ; | charge(...); | charge( (Molecule)arg1, (int)arg2) -> float :; | Gets charge of atom; | ; | clone(...); | clone( (Molecule)arg1) -> Molecule :; | Returns a new Molecule identical to arg1; | ; | create_psi4_string_from_molecule(...); | create_psi4_string_from_molecule( (Molecule)arg1) -> str :; | Gets a string reexpressing in input format the current states of the molecule; | ; | deactivate_all_fragments(...); | deactivate_all_fragments( (Molecule)arg1) -> None :; | Sets all fragments in the molecule to be inactive; | ; | extract_subsets(...); | extract_subsets( (Molecule)arg1, (list)arg2, (list)arg3) -> Molecule :; | Returns copy of arg1 with arg2 fragments Real and arg3 fragments Ghost; | ; | extract_subsets( (Molecule)arg1, (list)arg2, (int)arg3) -> Molecule :; | Returns copy of arg1 with arg2 fragments Real and arg3 fragment Ghost; | ; | extract_subsets( (Molecule)arg1, (int)arg2, (list)arg3) -> Molecule :; | Returns copy of arg1 with arg2 fragment Real and arg3 fragments Ghost; | ; | extract_subsets( (Molecule)arg1, (int)arg2, (int)arg",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/psimod-1.html:84551,charge,charge,84551,psi4manual/4.0b5/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/psimod-1.html,4,['charge'],['charge']
Energy Efficiency,"nctional technology to use. The world; contains far too many papers using B3LYP on noncovalent interactions without a -D. The “best-practice” input file for KS-DFT is:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14memory 1 GB # As much as you've got, the DF algorithm can use. molecule {; H; H 1 0.7; }. set {; basis cc-pvdz; scf_type df; guess sad; }. energy('b3lyp'). Advanced Functional Use and Manipulation¶; New DFT functionals can be created from scratch from within the input; file and accessed using the dft_functional keyword argument in the; energy call:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28# DFT Custom Functional. molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; basis sto-3g; dft_spherical_points 302; dft_radial_points 99; reference rks; }. pbe0 = {; ""name"": ""my_PBE0"",; ""x_functionals"": {""GGA_X_PBE"": {""alpha"": 0.75}},; ""x_hf"": {""alpha"": 0.25},; ""c_functionals"": {""GGA_C_PBE"": {}}; }. func_call = energy('SCF', dft_functional=pbe0). # as PBE0 is a pre-defined functional, the call above is equivalent to both below:; func_call = energy('SCF', dft_functional=""PBE0""); func_call = energy('PBE0'). Supported keywords include:. name: string, name of the functional. for custom defined functionals used for printing only.; xc_functionals: dict, definition of a complete (X + C) functional based in LibXC name; x_functionals: dict, definition of exchange functionals using LibXC names; c_functionals: dict, definition of correlation functionals using LibXC names; x_hf: dict, parameters dealing with exact (HF) exchange settings for hybrid DFT; c_mp2: dict, parameters dealing with MP2 correlation for double hybrid DFT; dispersion: dict, definition of dispersion corrections; citation: string, citation for the method, for printing purposes; description: string, description of the method, for printing purposes. The full interface is defined in; psi4/psi4/driver/procrouting/dft/dft_builder.py. All; standard fun",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/dft-1.html:27775,energy,energy,27775,psi4manual/1.3.2/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/dft-1.html,2,['energy'],['energy']
Energy Efficiency,"nctional(). if ssuper.is_c_hybrid():; core.tstart(); aux_basis = core.BasisSet.build(scf_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS'),; puream=-1); scf_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis); if ssuper.is_c_scs_hybrid():; core.set_local_option('DFMP2', 'MP2_OS_SCALE', ssuper.c_os_alpha()); core.set_local_option('DFMP2', 'MP2_SS_SCALE', ssuper.c_ss_alpha()); dfmp2_wfn = core.dfmp2(scf_wfn); dfmp2_wfn.compute_energy(). vdh = dfmp2_wfn.variable('CUSTOM SCS-MP2 CORRELATION ENERGY'). else:; dfmp2_wfn = core.dfmp2(scf_wfn); dfmp2_wfn.compute_energy(); vdh = ssuper.c_alpha() * dfmp2_wfn.variable('MP2 CORRELATION ENERGY'). # remove misleading MP2 psivars computed with DFT, not HF, reference; for var in dfmp2_wfn.variables():; if var.startswith('MP2 ') and ssuper.name() not in ['MP2D']:; scf_wfn.del_variable(var). scf_wfn.set_variable(""DOUBLE-HYBRID CORRECTION ENERGY"", vdh) # P::e SCF; scf_wfn.set_variable(""{} DOUBLE-HYBRID CORRECTION ENERGY"".format(ssuper.name()), vdh); returnvalue += vdh; scf_wfn.set_variable(""DFT TOTAL ENERGY"", returnvalue) # P::e SCF; for pv, pvv in scf_wfn.variables().items():; if pv.endswith('DISPERSION CORRECTION ENERGY') and pv.startswith(ssuper.name()):; fctl_plus_disp_name = pv.split()[0]; scf_wfn.set_variable(fctl_plus_disp_name + ' TOTAL ENERGY', returnvalue); break; else:; scf_wfn.set_variable('{} TOTAL ENERGY'.format(ssuper.name()), returnvalue). scf_wfn.set_variable('CURRENT ENERGY', returnvalue); scf_wfn.set_energy(returnvalue); core.print_out('\n\n'); core.print_out(' %s Energy Summary\n' % (name.upper())); core.print_out(' ' + '-' * (15 + len(name)) + '\n'); core.print_out(' DFT Reference Energy = %22.16lf\n' % (returnvalue - vdh)); core.print_out(' Scaled MP2 Correlation = %22.16lf\n' % (vdh)); core.print_out(' @Final double-hybrid DFT total energy = %22.16lf\n\n' % (returnvalue)); core.tstop(). if ssuper.name() == 'MP2D':; for pv, pvv in dfmp2_wfn.variables().ite",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:76931,ENERGY,ENERGY,76931,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,3,['ENERGY'],['ENERGY']
Energy Efficiency,"nctional\n'); # Tab in, trailing newlines; sup.set_citation(' F.A. Hamprecht et. al., J. Chem. Phys., 109(15), 6264-6271, 1998\n'). # Add member functionals; X = build_functional('B97_X'); X.set_name('B97-1_X'); X.set_alpha(1.0 / 0.79). X.set_parameter('B97_gamma', 0.004); X.set_parameter('B97_a0', 0.789518); X.set_parameter('B97_a1', 0.573805); X.set_parameter('B97_a2', 0.660975). C = build_functional('B_C'); C.set_name('B97-1_C'). C.set_parameter('B97_os_gamma', 0.006); C.set_parameter('B97_os_a0', 0.955689); C.set_parameter('B97_os_a1', 0.788552); C.set_parameter('B97_os_a2', -5.47869). C.set_parameter('B97_ss_gamma', 0.2); C.set_parameter('B97_ss_a0', 0.0820011); C.set_parameter('B97_ss_a1', 2.71681); C.set_parameter('B97_ss_a2', -2.87103). sup.add_x_functional(X); sup.add_c_functional(C). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.21); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_b972_superfunctional(name, npoints, deriv):. # Call this first; sup = PsiMod.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('B97-2'); # Tab in, trailing newlines; sup.set_description(' B97-2 Hybrid-GGA Exchange-Correlation Functional\n'); # Tab in, trailing newlines; sup.set_citation(' P.J. Wilson et. al., J. Chem. Phys., 115(20), 9233-9242, 2001\n'). # Add member functionals; X = build_functional('B97_X'); X.set_name('B97-2_X'); X.set_alpha(1.0 / 0.79). X.set_parameter('B97_gamma', 0.004); X.set_parameter('B97_a0', 0.827642); X.set_parameter('B97_a1', 0.047840); X.set_parameter('B97_a2', 1.761250). C = build_functional('B_C'); C.set_name('B97-2_C'). C.set_parameter('B97_os_gamma', 0.006); C.set_parameter('B97_os_a0', 0.999849); C.set_parameter('B97_os_a1', 1.40626); C.set_parameter('B97_os_a2', -7.44060). C.set_parameter('B97_ss_ga",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/functional.html:29675,allocate,allocate,29675,psi4manual/4.0b2/_modules/functional.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/functional.html,6,['allocate'],['allocate']
Energy Efficiency,"nctional\n'); # Tab in, trailing newlines; sup.set_citation(' F.A. Hamprecht et. al., J. Chem. Phys., 109(15), 6264-6271, 1998\n'). # Add member functionals; X = build_functional('B97_X'); X.set_name('B97-1_X'); X.set_alpha(1.0 / 0.79). X.set_parameter('B97_gamma', 0.004); X.set_parameter('B97_a0', 0.789518); X.set_parameter('B97_a1', 0.573805); X.set_parameter('B97_a2', 0.660975). C = build_functional('B_C'); C.set_name('B97-1_C'). C.set_parameter('B97_os_gamma', 0.006); C.set_parameter('B97_os_a0', 0.955689); C.set_parameter('B97_os_a1', 0.788552); C.set_parameter('B97_os_a2', -5.47869). C.set_parameter('B97_ss_gamma', 0.2); C.set_parameter('B97_ss_a0', 0.0820011); C.set_parameter('B97_ss_a1', 2.71681); C.set_parameter('B97_ss_a2', -2.87103). sup.add_x_functional(X); sup.add_c_functional(C). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.21); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_b972_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('B97-2'); # Tab in, trailing newlines; sup.set_description(' B97-2 Hybrid-GGA Exchange-Correlation Functional\n'); # Tab in, trailing newlines; sup.set_citation(' P.J. Wilson et. al., J. Chem. Phys., 115(20), 9233-9242, 2001\n'). # Add member functionals; X = build_functional('B97_X'); X.set_name('B97-2_X'); X.set_alpha(1.0 / 0.79). X.set_parameter('B97_gamma', 0.004); X.set_parameter('B97_a0', 0.827642); X.set_parameter('B97_a1', 0.047840); X.set_parameter('B97_a2', 1.761250). C = build_functional('B_C'); C.set_name('B97-2_C'). C.set_parameter('B97_os_gamma', 0.006); C.set_parameter('B97_os_a0', 0.999849); C.set_parameter('B97_os_a1', 1.40626); C.set_parameter('B97_os_a2', -7.44060). C.set_parameter('B97_ss_gamm",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/functional.html:33727,allocate,allocate,33727,psi4manual/4.0b5/_modules/functional.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/functional.html,3,['allocate'],['allocate']
Energy Efficiency,"nctional_list():; if ssuper.name().lower() == name.lower():; dfun = ssuper. if dfun.is_c_hybrid():. # if the df_basis_mp2 basis is not set, pick a sensible one.; if psi4.get_global_option('DF_BASIS_MP2') == '':; ribasis = p4util.corresponding_rifit(psi4.get_global_option('BASIS')); if ribasis:; psi4.set_global_option('DF_BASIS_MP2', ribasis); psi4.print_out(' No DF_BASIS_MP2 auxiliary basis selected, defaulting to %s\n' % (ribasis)); else:; raise ValidationError('Keyword DF_BASIS_MP2 is required.'). if dfun.is_c_scs_hybrid():; psi4.set_local_option('DFMP2', 'MP2_OS_SCALE', dfun.c_os_alpha()); psi4.set_local_option('DFMP2', 'MP2_SS_SCALE', dfun.c_ss_alpha()); psi4.dfmp2(); vdh = dfun.c_alpha() * psi4.get_variable('SCS-MP2 CORRELATION ENERGY'). else:; psi4.dfmp2(); vdh = dfun.c_alpha() * psi4.get_variable('MP2 CORRELATION ENERGY'). psi4.set_variable('DOUBLE-HYBRID CORRECTION ENERGY', vdh); returnvalue += vdh; psi4.set_variable('DFT TOTAL ENERGY', returnvalue); psi4.set_variable('CURRENT ENERGY', returnvalue). optstash.restore(). [docs]def run_dft_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-functional-theory gradient calculation. """"""; optstash = p4util.OptionsState(; ['SCF', 'DFT_FUNCTIONAL'],; ['SCF', 'REFERENCE'],; ['SCF', 'SCF_TYPE']). # Alter default algorithm; if not psi4.has_option_changed('SCF', 'SCF_TYPE'):; psi4.set_local_option('SCF', 'SCF_TYPE', 'DF'). psi4.set_local_option('SCF', 'DFT_FUNCTIONAL', name). user_ref = psi4.get_option('SCF', 'REFERENCE'); if (user_ref == 'RHF'):; psi4.set_local_option('SCF', 'REFERENCE', 'RKS'); elif (user_ref == 'UHF'):; psi4.set_local_option('SCF', 'REFERENCE', 'UKS'); elif (user_ref == 'ROHF'):; raise ValidationError('ROHF reference for DFT is not available.'); elif (user_ref == 'CUHF'):; raise ValidationError('CUHF reference for DFT is not available.'). run_scf_gradient(name, **kwargs). optstash.restore(). [docs]def run_detci(name, **kwargs):; """"""Function encoding sequence of ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/proc.html:39334,ENERGY,ENERGY,39334,psi4manual/4.0b5/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/proc.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"ncy. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; frequency. frequency¶. psi4.driver.frequency(name, **kwargs)[source]¶; Function to compute harmonic vibrational frequencies. Aliases:; frequencies(), freq(). Returns:; float – Total electronic energy in Hartrees. Returns:; (float, Wavefunction) – energy and wavefunction when return_wfn specified. Parameters:. name (str) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. dertype (dertype) – \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- they’re not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or str) – \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences acc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.frequency.html:1000,energy,energy,1000,psi4manual/1.8.x/api/psi4.driver.frequency.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.frequency.html,2,['energy'],['energy']
Energy Efficiency,"ncy. Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. PSI4 API: Linking C++ and Python; frequency. frequency¶. psi4.driver.frequency(name, **kwargs)[source]¶; Function to compute harmonic vibrational frequencies. Aliases:; frequencies(), freq(). Returns:; float – Total electronic energy in Hartrees. Returns:; (float, Wavefunction) – energy and wavefunction when return_wfn specified. Parameters:. name (str) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. dertype (dertype) – \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- they’re not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or str) – \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences acc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/api/psi4.driver.frequency.html:1000,energy,energy,1000,psi4manual/1.9.x/api/psi4.driver.frequency.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.driver.frequency.html,2,['energy'],['energy']
Energy Efficiency,"nd (func is energy) and (lowername in procedures['energy']):; pass; elif (dertype == 0) and not(func is energy):; pass; else:; raise ValidationError('Requested method \'name\' %s and derivative level \'dertype\' %s are not available.'; % (lowername, dertype)). # Make sure the molecule the user provided is the active one; if ('molecule' in kwargs):; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); PsiMod.set_global_option('BASIS', PsiMod.get_global_option('BASIS')). # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); if not PsiMod.has_option_changed('SCF', 'E_CONVERGENCE'):; if procedures['energy'][lowername] == run_scf or procedures['energy'][lowername] == run_dft:; PsiMod.set_local_option('SCF', 'E_CONVERGENCE', 8); else:; PsiMod.set_local_option('SCF', 'E_CONVERGENCE', 10); if not PsiMod.has_option_changed('SCF', 'D_CONVERGENCE'):; if procedures['energy'][lowername] == run_scf or procedures['energy'][lowername] == run_dft:; PsiMod.set_local_option('SCF', 'D_CONVERGENCE', 8); else:; PsiMod.set_local_option('SCF', 'D_CONVERGENCE', 10). # Set post-scf convergence criteria (global will cover all correlated modules); if not PsiMod.has_global_option_changed('E_CONVERGENCE'):; if not procedures['energy'][lowername] == run_scf and not procedures['energy'][lowername] == run_dft:; PsiMod.set_global_option('E_CONVERGENCE', 8). # Select certain irreps; if 'irrep' in kwargs:; irrep = parse_cotton_irreps(kwargs['irrep']) - 1 # externally, A1 irrep is 1, internally 0; else:; irrep = -1 # -1 implies do all irreps. # Does an analytic procedure exist for the requested method?; if (dertype == 2):; # We have the desired method. Do it.; procedures['hessian'][lowername](lowername, **kwargs); optstash.restore(). # call thermo module; PsiMod.thermo(). return PsiMod.wavefunction().energy(). elif (dertype == 1):; # Ok, we're doing frequencies by gradients; info = 'P",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/driver.html:62055,energy,energy,62055,psi4manual/4.0b4/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/driver.html,4,['energy'],['energy']
Energy Efficiency,"nd AO_BASIS=NONE, respectively. cc40; RHF-CC2-LR/cc-pVDZ optical rotation of H2O2. gauge = length, omega = (589 355 nm). cubeprop-esp; RHF orbitals and density for water. frac; Carbon/UHF Fractionally-Occupied SCF Test Case. cepa3; cc-pvdz H2O Test coupled-pair CISD against DETCI CISD. pywrap-opt-sowreap; Finite difference optimization, run in sow/reap mode. cc15; RHF-B-CCD(T)/6-31G** H2O single-point energy (fzc, MO-basis \(\langle ab|cd \rangle\)). castup2; SCF with various combinations of pk/density-fitting, castup/no-castup, and spherical/cartesian settings. Demonstrates that puream setting is getting set by orbital basis for all df/castup parts of calc. Demonstrates that answer doesn’t depend on presence/absence of castup. Demonstrates (by comparison to castup3) that output file doesn’t depend on options (scf_type) being set global or local. This input uses global. opt1-fd; SCF STO-3G geometry optimzation, with Z-matrix input, by finite-differences. dfmp2-2; Density fitted MP2 energy of H2, using density fitted reference and automatic looping over cc-pVDZ and cc-pVTZ basis sets. Results are tabulated using the built in table functions by using the default options and by specifiying the format. dft-grac; Gradient regularized asymptotic correction (GRAC) test. dct7; DCT calculation for the triplet O2 using ODC-06 and ODC-12 functionals. Only simultaneous algorithm is tested. dft-b2plyp; Double-hybrid density functional B2PYLP. Reproduces portion of Table I in S. Grimme’s J. Chem. Phys 124 034108 (2006) paper defining the functional. pywrap-db1; Database calculation, so no molecule section in input file. Portions of the full databases, restricted by subset keyword, are computed by sapt0 and dfmp2 methods. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Appendices; Test Suite and Sample Inputs. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2021 02:41AM.; Created using Sphinx 4.3.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/testsuite-1.html:45178,energy,energy,45178,psi4manual/1.5.0/testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/testsuite-1.html,2,['energy'],['energy']
Energy Efficiency,"nd CCSD(T) methods are implemented for closed-shell references; in the FNOCC module. Many-body perturbation theory¶; QCI and CC methods are closely related to perturbation theory, and the; MP2, MP3, and MP4(SDQ) correlation energies can be obtained as a free; by-product of a CCSD or QCISD computation. The following is an; example of the results for a computation run with the call; energy('fno-qcisd') to energy():; QCISD iterations converged!. OS MP2 FNO correction: -0.000819116338; SS MP2 FNO correction: -0.000092278158; MP2 FNO correction: -0.000911394496. OS MP2 correlation energy: -0.166478414245; SS MP2 correlation energy: -0.056669079827; MP2 correlation energy: -0.223147494072; * MP2 total energy: -76.258836941658. OS MP2.5 correlation energy: -0.171225850256; SS MP2.5 correlation energy: -0.054028401038; MP2.5 correlation energy: -0.225254251294; * MP2.5 total energy: -76.260943698880. OS MP3 correlation energy: -0.175973286267; SS MP3 correlation energy: -0.051387722248; MP3 correlation energy: -0.227361008515; * MP3 total energy: -76.263050456101. OS MP4(SDQ) correlation energy: -0.180324322304; SS MP4(SDQ) correlation energy: -0.048798468084; MP4(SDQ) correlation energy: -0.230995119324; * MP4(SDQ) total energy: -76.266684566910. OS QCISD correlation energy: -0.181578117924; SS QCISD correlation energy: -0.049853548145; QCISD correlation energy: -0.231431666069; * QCISD total energy: -76.267121113654. The first set of energies printed corresponds to the second-order FNO; correction mentioned previously. Results for many-body perturbation; theory through partial fourth order are then provided.; The notation MP4(SDQ) indicates that we have included all contributions to; the correlation energy through fourth order, with the exception of that; from connected triple excitations.; One need not run a full QCISD or CCSD computation to obtain these; perturbation theory results. The keywords for invoking perturbation; theory computations are given below in; Table FNO",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/fnocc-1.html:5873,energy,energy,5873,psi4manual/1.4.0/fnocc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/fnocc-1.html,15,['energy'],['energy']
Energy Efficiency,"nd Gauss’s CFOUR program [manual]. c4-scf; Hartree–Fock (HF). c4-mp2; 2nd-order Moller-Plesset perturbation theory (non-density-fitting) (MP2). c4-mp3; 3rd-order Moller-Plesset perturbation theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. >>> # [1] Coupled-cluster singles and doubles calculation with psi code; >>> energy('ccsd'). >>> # [2] Charge-transfer SAPT calculation with scf projection from small into; >>> # requested basis, with specified projection fitting basis; >>> set basis_guess true; >>> set df_basis_guess jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). >>> # [3] Arbitrary-order MPn calculation; >>> energy('mp7'). >>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> # Note that the integral transformation is not done automatically when detci is run in a separate step.; >>> molecule H2 {\n0 1\nH\nH 1 0.74\n}; >>> set global basis cc-pVDZ; >>> set global reference rohf; >>> scf_e, scf_wfn = energy('scf', return_wfn = True); >>> H2.set_multiplicity(3); >>> psi4.MintsHelper(scf_wfn.basisset()).integrals(); >>> energy('detci', ref_wfn=scf_wfn). >>> # [5] Run two CI calculations, keeping the integrals generated in the first one.; >>> molecule ne {\nNe\n}; >>> set globals basis cc-pVDZ; >>> cisd_e, cisd_wfn = energy('cisd', return_wfn = True); >>> energy('fci', ref_wfn=cisd_wfn). >>> # [6] Can automatically perform complete basis set extrapolations; >>> energy(""MP2/cc-pV[DT]Z""). Previous topic; Notes on Options; Next topic; Property. This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Naviga",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/energy-1.html:19242,energy,energy,19242,psi4manual/1.0.0/energy-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/energy-1.html,2,['energy'],['energy']
Energy Efficiency,"nd Gauss’s CFOUR program [manual]. c4-scf; Hartree–Fock (HF). c4-mp2; 2nd-order Møller–Plesset perturbation theory (non-density-fitting) (MP2). c4-mp3; 3rd-order Møller–Plesset perturbation theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. >>> # [1] Coupled-cluster singles and doubles calculation with psi code; >>> energy('ccsd'). >>> # [2] Charge-transfer SAPT calculation with scf projection from small into; >>> # requested basis, with specified projection fitting basis; >>> set basis_guess true; >>> set df_basis_guess jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). >>> # [3] Arbitrary-order MPn calculation; >>> energy('mp7'). >>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> # Note that the integral transformation is not done automatically when detci is run in a separate step.; >>> molecule H2 {\n0 1\nH\nH 1 0.74\n}; >>> set basis cc-pVDZ; >>> set reference rohf; >>> scf_e, scf_wfn = energy('scf', return_wfn=True); >>> H2.set_multiplicity(3); >>> core.MintsHelper(scf_wfn.basisset()).integrals(); >>> energy('detci', ref_wfn=scf_wfn). >>> # [5] Run two CI calculations, keeping the integrals generated in the first one.; >>> molecule ne {\nNe\n}; >>> set basis cc-pVDZ; >>> cisd_e, cisd_wfn = energy('cisd', return_wfn=True); >>> energy('fci', ref_wfn=cisd_wfn). >>> # [6] Can automatically perform complete basis set extrapolations; >>> energy(""CCSD/cc-pV[DT]Z""). >>> # [7] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for mo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.driver.energy-1.html:20536,energy,energy,20536,psi4manual/1.3.2/api/psi4.driver.energy-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.driver.energy-1.html,14,['energy'],['energy']
Energy Efficiency,"nd Python; fchk. fchk¶. psi4.driver.fchk(wfn, filename, *, debug=False, strict_label=True)[source]¶; Function to write wavefunction information in wfn to filename in; Gaussian FCHK format. New in version 0.6. Returns; None. Parameters. wfn (Wavefunction) – set of molecule, basis, orbitals from which to generate fchk file; filename (str) – destination file name for FCHK file; debug (bool) – returns a dictionary to aid with debugging; strict_label (bool) – If true set a density label compliant with what Gaussian would write. A warning will be printed if this is not possible.; Otherwise set the density label according to the method name. Notes. A description of the FCHK format is http://wild.life.nctu.edu.tw/~jsyu/compchem/g09/g09ur/f_formchk.htm; The allowed headers for methods are general and limited, i.e., “Total SCF|MP2|CI|CC Density”,; PSI4 will try to find the right one for the current calculation. If strict_label=False the PSI4 method name will be used as label.; Not all theory modules in PSI4 are compatible with the FCHK writer.; A warning will be printed if a theory module is not supported.; Caution! For orbital-optimized correlated methods (e.g. DCT, OMP2) the ‘Orbital Energy’ field contains ambiguous data. Examples. Parameters. wfn (psi4.core.Wavefunction) – ; filename (str) – ; debug (bool) – ; strict_label (bool) – . >>> # [1] FCHK file for DFT calculation; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> fchk(wfn, 'mycalc.fchk'). >>> # [2] FCHK file for correlated densities; >>> E, wfn = gradient('ccsd', return_wfn=True); >>> fchk(wfn, 'mycalc.fchk'). >>> # [2] Write FCHK file with non-standard label.; >>> E, wfn = gradient('mp2.5', return_wfn=True); >>> fchk(wfn, 'mycalc.fchk', strict_label=False). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. PSI4 API: Linking C++ and Python; fchk. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.driver.fchk.html:1503,energy,energy,1503,psi4manual/1.6.x/api/psi4.driver.fchk.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.driver.fchk.html,3,"['Energy', 'energy']","['Energy', 'energy']"
Energy Efficiency,"nd UHF reference (and only for HF, not DFT).; To turn on, simply set; the option SOSCF to true. Additional options to modify the number of; microiterations taken are as follows:. SOSCF_START_CONVERGENCE: when to start SOSCF based on the current density RMS; SOSCF_MAX_ITER: the maximum number of SOSCF microiterations per macroiteration; SOSCF_CONV: the relative convergence tolerance of the SOSCF microiterations; SOSCF_PRINT: option to print the microiterations or not. Stability Analysis¶; SCF algorithms attempt to minimize the gradient of the energy with respect; to orbital variation parameters. At convergence, the gradient should be approximately zero; given a convergence criterion. Although this is enough to make sure the SCF converged to a; stationary point, this is not a sufficient condition for a minimal SCF solution. It may be; a saddle point or a maximum.; To ensure that a minimum has been found, the electronic Hessian, i.e. the matrix of second; derivatives of the energy with respect to orbital variation parameters, must be computed.; If one or more eigenvalues of the electronic Hessian are negative, the SCF solution is not a minimum.; In that case, orbital parameters can be varied along the lowest Hessian eigenvector to lower the energy.; Orbital variation parameters are usually constrained. For example, in RHF the; spatial parts of the \(\alpha\) and \(\beta\) orbitals are the same. In; UHF, the orbital coefficients are usually constrained to be real. A stability analysis; can check whether a lower SCF solution exists while respecting the constraints of the original; solution; this is an internal instability. If one or more constraints have to be relaxed to reach; a lower-energy solution, there is an external instability. In PSI4, the only external instability; that can be checked at present is the RHF \(\rightarrow\) UHF one.; Currently, two algorithms exist in PSI4 for stability analysis: the original; Direct Inversion and the newly implemented Davidson a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/scf-1.html:25850,energy,energy,25850,psi4manual/1.1.0/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/scf-1.html,4,['energy'],['energy']
Energy Efficiency,"nd a brief description are provided below.; Sample inputs accessible through interfaced executables are bulleted below. BRIANQC; CFOUR; CHEMPS2; COOKBOOK; DFTD3; DFTD4; DKH; LIBEFP; ERD; GCP; GDMA; GPU_DFCC; JSON; MRCC; PCMSOLVER; PSI4NUMPY; PYTHON; SIMINT; SNSMP2; V2RDM_CASSCF. Sample inputs for PSI4 as distributed are below. Input File; Description. omp3-grad2; OMP3 cc-pVDZ gradient for the NO radical. dct5; DC-06 calculation for the O2 molecule (triplet ground state). This performs geometry optimization using two-step and simultaneous solution of the response equations for the analytic gradient. tdscf-7; TD-HF test variable access. nbody-freq; Vibrational and thermo analysis of water trimer (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). tdscf-4; td-wb97x singlet excitation energies of methylene (tda). fnocc1; Test QCISD(T) for H2O/cc-pvdz Energy. fd-freq-gradient-large; SCF DZ finite difference frequencies by gradients for C4NH4. dfomp2p5-2; DF-OMP2.5 cc-pVDZ energy for the H2O+ cation. tdscf-1; td-uhf test on triplet states of methylene (rpa). zaptn-nh2; ZAPT(n)/6-31G NH2 Energy Point, with n=2-25. cubeprop; RHF orbitals and density for water. cc40; RHF-CC2-LR/cc-pVDZ optical rotation of H2O2. gauge = length, omega= (589 355 nm). cc39; RHF-CC2-LR/cc-pVDZ dynamic polarizabilities of HOF molecule. cc35; CC3(ROHF)/cc-pVDZ H2O \(R_e\) geom from Olsen et al., JCP 104, 8007 (1996). pywrap-checkrun-convcrit; Advanced python example sets different sets of scf/post-scf conv crit and check to be sure computation has actually converged to the expected accuracy. cc-module; check that CC is returning the same values btwn CC*, FNOCC, and DFOCC modules. cdomp2-2; OMP2 cc-pVDZ energy for the NO molecule. fsapt-ext-abc-au; analog of fsapt-ext-abc with molecule and external potentials in Bohr. opt2-fd; SCF DZ allene geometry optimzation, with Cartesian input. mints3; Test individual integral objects for correctness. tdscf-5; td-camb3lyp with DiskDF and method/basis ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/testsuite.html:1522,energy,energy,1522,psi4manual/1.6.x/testsuite.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/testsuite.html,1,['energy'],['energy']
Energy Efficiency,"nd cbs() should not be accessed directly. Instead, use the; cp kwarg and/or the extended method syntax like; 'mp3/aug-cc-pv[dt]z' to energy(), opt(), etc., respectively.; For many of the PSI4 Python functions described above, it makes scientific; sense that they could be called in combination. For instance, one could; optimize all the reagents in a database or compute a; counterpoise-corrected interaction energy with an extrapolated method. The; table below outlines permitted intercalls between functions, showing that; db(opt(cbs(energy()))) is allowed, while db(cp(energy())) is not. This; table is not yet validated for calls with cp(). Permitted nesting of Psithon functions¶. Caller; Callee.  ; cp; db; opt; cbs; energy. Basis Set Superposition Corrections;  ; —; Y; Y; Y. Database — database(); —;  ; Y; Y; Y. Geometry Optimization — optimize() and gradient(); —; —;  ; Y; Y. Complete Basis Set; —; —; —;  ; Y. Single-Point Energy — energy(); —; —; —; —;  . The command db(opt(cbs(energy()))) is actually expressed as db(...,; db_func=opt, opt_func=cbs). The perhaps expected final argument of; cbs_func=energy is not necessary since energy() is always the function; called by default. Also, the outermost internal function call (db_func; above can be called as just func. Several examples of intercalls; between Python functions can be found in sample input pywrap-all.; All keyword arguments are passed along to each function traversed in the; Python driver, so there should be no concern for separating them, grouping; them, or designating them for a particular function when undertaking a; nested calculation. Where the same keyword is used by multiple functions,; prefixes are added, e.g., db_mode and opt_mode.; Function intercalls should not be used in sow/reap mode. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Psithon Functions: Invoking a Calculation. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/intercalls-1.html:1226,energy,energy,1226,psi4manual/1.1.0/intercalls-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/intercalls-1.html,2,['energy'],['energy']
Energy Efficiency,"nd cbs() should not be accessed directly. Instead, use the; cp kwarg and/or the extended method syntax like; 'mp3/aug-cc-pv[dt]z' to energy(), opt(), etc., respectively.; For many of the PSI4 Python functions described above, it makes scientific; sense that they could be called in combination. For instance, one could; optimize all the reagents in a database or compute a; counterpoise-corrected interaction energy with an extrapolated method. The; table below outlines permitted intercalls between functions, showing that; db(opt(cbs(energy()))) is allowed, while db(cp(energy())) is not. This; table is not yet validated for calls with cp(). Permitted nesting of Psithon functions¶. Caller; Callee.  ; cp; db; opt; cbs; energy. Basis Set Superposition Corrections;  ; —; Y; Y; Y. Database — database(); —;  ; Y; Y; Y. Geometry Optimization — optimize() and gradient(); —; —;  ; Y; Y. Complete Basis Set; —; —; —;  ; Y. Single-Point Energy — energy(); —; —; —; —;  . The command db(opt(cbs(energy()))) is actually expressed as db(...,; db_func=opt, opt_func=cbs). The perhaps expected final argument of; cbs_func=energy is not necessary since energy() is always the function; called by default. Also, the outermost internal function call (db_func; above can be called as just func. Several examples of intercalls; between Python functions can be found in sample input pywrap-all.; All keyword arguments are passed along to each function traversed in the; Python driver, so there should be no concern for separating them, grouping; them, or designating them for a particular function when undertaking a; nested calculation. Where the same keyword is used by multiple functions,; prefixes are added, e.g., db_mode and opt_mode.; Function intercalls should not be used in sow/reap mode. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Psithon Functions: Invoking a Calculation. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 J",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/intercalls-1.html:1228,energy,energy,1228,psi4manual/1.2.1/intercalls-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/intercalls-1.html,2,['energy'],['energy']
Energy Efficiency,"nd cbs() should not be accessed directly. Instead, use the; cp kwarg and/or the extended method syntax like; 'mp3/aug-cc-pv[dt]z' to energy(), opt(), etc., respectively.; For many of the PSI4 Python functions described above, it makes scientific; sense that they could be called in combination. For instance, one could; optimize all the reagents in a database or compute a; counterpoise-corrected interaction energy with an extrapolated method. The; table below outlines permitted intercalls between functions, showing that; db(opt(cbs(energy()))) is allowed, while db(cp(energy())) is not. This; table is not yet validated for calls with cp(). Permitted nesting of Psithon functions¶. Caller; Callee.  ; cp; db; opt; cbs; energy. Basis Set Superposition Corrections;  ; —; Y; Y; Y. Database — database(); —;  ; Y; Y; Y. Geometry Optimization — optimize() and gradient(); —; —;  ; Y; Y. Complete Basis Set; —; —; —;  ; Y. Single-Point Energy — energy(); —; —; —; —;  . The command db(opt(cbs(energy()))) is actually expressed as db(...,; db_func=opt, opt_func=cbs). The perhaps expected final argument of; cbs_func=energy is not necessary since energy() is always the function; called by default. Also, the outermost internal function call (db_func; above can be called as just func. Several examples of intercalls; between Python functions can be found in sample input pywrap-all.; All keyword arguments are passed along to each function traversed in the; Python driver, so there should be no concern for separating them, grouping; them, or designating them for a particular function when undertaking a; nested calculation. Where the same keyword is used by multiple functions,; prefixes are added, e.g., db_mode and opt_mode.; Function intercalls should not be used in sow/reap mode. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Psithon Functions: Invoking a Calculation. © Copyright 2019, The Psi4 Project.; Last updated on Wednesday, 15 M",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/intercalls-1.html:1228,energy,energy,1228,psi4manual/1.3.2/intercalls-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/intercalls-1.html,2,['energy'],['energy']
Energy Efficiency,"nd correlation energy component [E_h]; for the MP2-like method formed by reweighting MP2 DOUBLES ENERGY; by 0 opposite-spin and 1.76 same-spin contributions, with; any singles carried along. doi: 10.1021/ct6002737. SCS(N)-OMP2 CORRELATION ENERGY¶. SCS(N)-OMP2 TOTAL ENERGY¶. SCSN-OMP2 CORRELATION ENERGY¶. SCSN-OMP2 TOTAL ENERGY¶; Two spellings of a discontinued QCVariable that may still appear; because the code is frozen pending an update. SCS-OMP2 TOTAL ENERGY¶. SCS-OMP2 CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the OMP2-like method formed by reweighting OMP2 DOUBLES ENERGY; by 6/5 opposite-spin and 1/3 same-spin contributions, with; any singles carried along. SCS-MP3 TOTAL ENERGY¶. SCS-MP3 CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the MP3-like method formed by reweighting the difference between; MP3 DOUBLES ENERGY and MP2 DOUBLES ENERGY; by 0.25, atop the SCS-MP2 energy, with any singles carried along. SCS-OMP3 TOTAL ENERGY¶. SCS-OMP3 CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the OMP3-like method formed by reweighting the difference between; OMP3 DOUBLES ENERGY and OMP2 DOUBLES ENERGY; by 0.25, atop the SCS-OMP2 energy, with any singles carried along. SOS-MP2 TOTAL ENERGY¶. SOS-MP2 CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the MP2-like method formed by reweighting MP2 DOUBLES ENERGY; by 1.3 opposite-spin and 0 same-spin contributions, with; any singles carried along. SOS-OMP2 TOTAL ENERGY¶. SOS-OMP2 CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the OMP2-like method formed by reweighting OMP2 DOUBLES ENERGY; by 1.2 opposite-spin and 0 same-spin contributions, with; any singles carried along. SOS-OMP3 TOTAL ENERGY¶. SOS-OMP3 CORRELATION ENERGY¶; The total electronic energy [E_h] and correlat",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html:56222,energy,energy,56222,psi4manual/1.7.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html,4,['energy'],['energy']
Energy Efficiency,"nd density fitted integrals with ROHF Then with cc-pVDZ and direct integrals, except for dispersion that is computed with cc-pVDZ-ri density fitting with ROHF. cc42; RHF-CC2-LR/STO-3G optical rotation of (S)-methyloxirane. gauge = length, omega = (589 355 nm). opt-irc-2; Compute the IRC for HCN <-> NCH interconversion at the RHF/DZP level of theory. cc3; cc3: RHF-CCSD/6-31G** H2O geometry optimization and vibrational frequency analysis by finite-differences of gradients. dft-freq; Frequencies for H2O B3LYP/6-31G* at optimized geometry. cc23; ROHF-EOM-CCSD/DZ analytic gradient lowest \(^{2}B_1\) state of H2O+ (A1 excitation). fnocc3; Test FNO-QCISD(T) computation. scf3; File retention, docc, socc, and bond distances specified explicitly. adc2; ADC/aug-cc-pVDZ on two water molecules that are distant from 1000 angstroms from each other. dfcasscf-sp; CASSCF/6-31G** energy point. opt10; 6-31G MP2 transition-state optimization with initial, computed Hessian. scf1; RHF cc-pVQZ energy for the BH molecule, with Cartesian input. pubchem2; Superficial test of PubChem interface. omp2p5-1; OMP2 cc-pVDZ energy for the H2O molecule. ao-dfcasscf-sp; CASSCF/6-31G** energy point. omp2-grad2; OMP2 cc-pVDZ gradient for the NO radical. dcft7; DCFT calculation for the triplet O2 using ODC-06 and ODC-12 functionals. Only simultaneous algorithm is tested. scf-guess-read1; Sample UHF/cc-pVDZ H2O computation on a doublet cation, using RHF/cc-pVDZ orbitals for the closed-shell neutral as a guess. cc43; RHF-CC2-LR/STO-3G optical rotation of (S)-methyloxirane. gauge = both, omega = (589 355 nm). cc41; RHF-CC2-LR/cc-pVDZ optical rotation of H2O2. gauge = both, omega = (589 355 nm). molden2; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/testsuite-1.html:21527,energy,energy,21527,psi4manual/1.1.0/testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/testsuite-1.html,4,['energy'],['energy']
Energy Efficiency,"nd density fitted integrals with ROHF Then with cc-pVDZ and direct integrals, except for dispersion that is computed with cc-pVDZ-ri density fitting with ROHF. dft-custom-dhdf; DSD-PBEP86 S22 Ammonia test. omp2-3; OMP2 cc-pVDZ energy for the NO radical. castup3; SCF with various combinations of pk/density-fitting, castup/no-castup, and spherical/cartesian settings. Demonstrates that puream setting is getting set by orbital basis for all df/castup parts of calc. Demonstrates that answer doesn’t depend on presence/absence of castup. Demonstrates (by comparison to castup2) that output file doesn’t depend on options (scf_type) being set global or local. This input uses local. scf-response2; Compute the dipole polarizability for water with custom basis set. scf-guess-read3; Test if the the guess read in the same basis converges. scf-level-shift-uhf; SCF level shift on a UHF computation. nbody-convergence; Convergence of many-body gradients of different BSSE schemes. omp3-1; OMP3 cc-pVDZ energy for the H2O molecule. dfccsd-grad1; DF-CCSD cc-pVDZ gradients for the H2O molecule. soscf-ref; Triple and Singlet Oxygen energy SOSCF, also tests non-symmetric density matrices. cbs-xtpl-nbody; RHF interaction energies using nbody and cbs parts of the driver Ne dimer with mp2/v[dt]z + d:ccsd(t)/vdz. freq-masses; check nonphysical masses possible. scf-level-shift-cuhf; SCF level shift on a CUHF computation. dft-freq-analytic1; Analytic SVWN frequencies, compared to finite difference values. density-screen-1; RHF Density Matrix based-Integral Screening Test for water. frac-ip-fitting; Omega optimization for LRC functional wB97 on water. mbis-2; MBIS calculation on OH- (Expanded Arrays). sapt-sf1; Tests the Psi4 SF-SAPT code. cc4; RHF-CCSD(T) cc-pVQZ frozen-core energy of the BH molecule, with Cartesian input. After the computation, the checkpoint file is renamed, using the PSIO handler. cc50; EOM-CC3(ROHF) on CH radical with user-specified basis and properties for particular root. df",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html:14057,energy,energy,14057,psi4manual/master/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"nd don’t usually work when run “by hand” from the objdir via stage/bin/psi4 ../tests/directory_name/input.dat.; If a test is multiple minutes long, load-balancing a parallel CTest run requires the test to be started early. Use the COST line as shown above to set a weighting to about the number of seconds the test takes. input.dat¶; The other necessary file is the input file itself, input.dat. The input file should be just a simple input file to run the test, with small additions.; #! RI-SCF cc-pVTZ energy of water, with Z-matrix input and cc-pVTZ-RI auxiliary basis.; #! Also a bit more to force a second line. nucenergy = 8.801466202085710 #TEST; refenergy = -76.05098402733282 #TEST. molecule h2o {; symmetry c1; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; basis cc-pVTZ; scf_type df; df_basis_scf cc-pVTZ-RI; e_convergence 10; }. thisenergy = energy(""hf""). compare_values(nucenergy, h2o.nuclear_repulsion_energy(), 9, ""Nuclear repulsion energy"") #TEST; compare_values(refenergy, thisenergy, 9, ""Reference energy"") #TEST; compare_values(refenergy, variable('scf total energy'), 9, ""Reference energy"") #TEST. Of those small modifications, first, note the special comment at the top (starting with the #! comment marker). This should be descriptive since it is inlined into the manual (unless !nosample in the comment) as a sample input.; Reference values are often assigned to variables for later use.; The compare_values function (along with several relatives in psi4/psi4/driver/p4util/testing.py for comparing strings, matrices, etc.) checks that the computed values match these reference values to suitable precision. This function prints an error message and signals that the test failed to the make system, if the values don’t match. Any lines of the input associated with the validation process should be flagged with #TEST at the end of each line, so that they can be removed when copying from the tests to the samples directory. output.ref¶; When your test case is in final form, run it loc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/add_tests.html:7352,energy,energy,7352,psi4manual/1.6.x/add_tests.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/add_tests.html,20,['energy'],['energy']
Energy Efficiency,"nd doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. >>> # [1] Coupled-cluster singles and doubles calculation with psi code; >>> energy('ccsd'). >>> # [2] Charge-transfer SAPT calculation with scf projection from small into; >>> # requested basis, with specified projection fitting basis; >>> set basis_guess true; >>> set df_basis_guess jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). >>> # [3] Arbitrary-order MPn calculation; >>> energy('mp7'). >>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> # Note that the integral transformation is not done automatically when detci is run in a separate step.; >>> molecule H2 {\n0 1\nH\nH 1 0.74\n}; >>> set basis cc-pVDZ; >>> set reference rohf; >>> scf_e, scf_wfn = energy('scf', return_wfn=True); >>> H2.set_multiplicity(3); >>> core.MintsHelper(scf_wfn.basisset()).integrals(); >>> energy('detci', ref_wfn=scf_wfn). >>> # [5] Run two CI calculations, keeping the integrals generated in the first one.; >>> molecule ne {\nNe\n}; >>> set basis cc-pVDZ; >>> cisd_e, cisd_wfn = energy('cisd', return_wfn=True); >>> energy('fci', ref_wfn=cisd_wfn). >>> # [6] Can automatically perform complete basis set extrapolations; >>> energy(""CCSD/cc-pV[DT]Z""). >>> # [7] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> energy(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. PSI4 API: Linking C++ and Python; energy. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.energy.html:36907,energy,energy,36907,psi4manual/1.7.x/api/psi4.driver.energy.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.energy.html,12,['energy'],['energy']
Energy Efficiency,"nd incremental Fock builds (set INCFOCK to TRUE), which decrease the number of significant two-electron integrals to calculate.; NOTE: Turning on LinK is currently only recommended for research and development purposes, and not for performance,; since a fast J matrix build compatible to use with LinK has not been developed yet.; To turn on and control the LinK algorithm, here are the list of options provided. DO_LINK: Defaults to false. If turned on, the K matrix will be built using the algorithm described in [Ochsenfeld:1998:1663].; LINK_INTS_TOLERANCE: The integral screening tolerance used for sparsity-prep in the LinK algorithm. Defaults to the INTS_TOLERANCE option. Second-order Convergence¶; Second-order convergence takes into account both the gradient and Hessian to; take a full Newton step with respect to the orbital parameters. This results in; quadratic convergence with respect to density for SCF methods. For cases where; normal acceleration methods either fail or take many iterations to converge,; second-order can reduce the total time to solution.; Solving second-order (SO) methods exactly would require an inversion of the; orbital Hessian (an expensive \(\mathbb{N}^6\) operation); however, these; equations are normally solved iteratively where each iteration costs the same; as a normal Fock build (\(\mathbb{N}^4\)). The overall SOSCF operation is; thus broken down into micro- and macroiterations where the microiterations; refer to solving the SOSCF equations and macroiterations are the construction; of a new Fock matrix based on the orbitals from a SOSCF step.; SOSCF requires that all elements of the gradient to be less than one before the; method is valid. To this end, pre-SOSCF SCF iterations use normal; gradient-based extrapolation procedures (e.g., DIIS) until the gradient; conditions are met. Note that while the total number of macroiterations will be; less for SOSCF than gradient-based convergence acceleration, the cost of solving; the microiteratio",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/scf.html:34421,reduce,reduce,34421,psi4manual/1.6.x/scf.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/scf.html,1,['reduce'],['reduce']
Energy Efficiency,"nd multiplicity (), respectively. The symmetry; can be specified by a line reading symmetry symbol, where; symbol is the Schönflies symbol of the; (Abelian) point group to use for the computation. This need not be; specified, as the molecular symmetry is automatically detected by; PSI4. Certain computations require that the molecule is not; reoriented; this can be achieved by adding either no_reorient or; noreorient. By default, Ångström units are used; this is changed by; adding a line that reads units spec, where spec is one; of ang, angstrom, a.u., au, or bohr. Ghost Atoms¶; While many common computations, such as SAPT and counterpoise corrections, can; be greatly simplified using the notation described in Non-Covalently Bonded Molecule Fragments,; manual specification of ghost atoms is sometimes required. Either; molecule he2 {; He; Gh(He) 1 2.0; }. or; molecule he2 {; He; @He 1 2.0; }. will generate a helium dimer, with the second atom ghosted, i.e., possessing; basis functions but no electrons or nuclear charge. See dfmp2_1; and ghosts for a demonstration of both mechanisms for specifying; ghost atoms. Geometries from the PubChem Database¶; Obtaining rough starting guess geometries can be burdensome. The Z-matrix; coordinate system was designed to provide chemists with an intuitive method for; guessing structures in terms of bond lengths and angles. While Z-matrix input is; intuitive for small molecules with few degrees of freedom, it quickly becomes; laborious as the system size grows. To obtain a reasonable starting guess; geometry, PSI4 can take a chemical name as input; this is then used; to attempt to retrieve Cartesian coordinates from the [PubChem] database.; For example, to run a computation on benzene, we can use the following molecule specification:; molecule benzene {; pubchem:benzene; }. If the computer is connected to the internet, the above code will instruct; PSI4 to search PubChem for a starting structure. The search is actually; performed for c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:8802,charge,charge,8802,psi4manual/4.0b4/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html,4,['charge'],['charge']
Energy Efficiency,"nd of analysis gives a lot; of insight into the nature of intermolecular interactions, and PSI4; makes these computations easier than ever.; For a SAPT computation, the input needs to provide information on two; distinct molecules. This is very easy, we just give a Z-matrix or set of; Cartesian coordinates for each molecule, and separate the two with two; dashes, like this:; # Example SAPT computation for ethene*ethine (i.e., ethylene*acetylene),; # test case 16 from the S22 database. molecule dimer {; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.923621 1.232253 -2.126185; --; 0 1; C 0.000000 0.000000 2.900503; C 0.000000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; units angstrom. }. Here’s the second half of the input, where we specify the computation; options:; set {; basis jun-cc-pVDZ; scf_type DF; freeze_core True; }. energy('sapt0'). Before, we have been setting keywords individually with commands like; set basis cc-pVDZ. Because we have a few more options now, it’s; convenient to place them together into the set or set globals; block, bounded by {...}. This; will set all of these options as “global” options (meaning that they are; visible to all parts of the program). Most common PSI4 options can be; set in a globals section like this. If an option needs to be visible; only to one part of the program (e.g., we only want to increase the; energy convergence in the SCF code, but not the rest of the; code), it can be placed in a section of input visible to that part of the; program (e.g., set scf e_convergence 1.0E-8).; Back to our SAPT example, we have found that for basic-level SAPT; computations (i.e., SAPT0), a good error cancellation is found; [Hohenstein:2012:WIREs] with the jun-cc-pVDZ basis (this is the; usual aug-cc-pVDZ basis, but without diffuse functions on hydrogen and; without diffuse functions ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/tutorial-1.html:9455,energy,energy,9455,psi4manual/4.0b5/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/tutorial-1.html,2,['energy'],['energy']
Energy Efficiency,"nd of analysis gives a lot; of insight into the nature of intermolecular interactions, and Psi4; makes these computations easier than ever.; For a SAPT computation, the input needs to provide information on two; distinct molecules. This is very easy, we just give a Z-matrix or set of; Cartesian coordinates for each molecule, and separate the two with two; dashes, like this:; # Example SAPT computation for ethene*ethine (i.e., ethylene*acetylene),; # test case 16 from the S22 database. molecule dimer {; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.923621 1.232253 -2.126185; --; 0 1; C 0.000000 0.000000 2.900503; C 0.000000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; units angstrom. }. Here’s the second half of the input, where we specify the computation; options:; set {; basis jun-cc-pVDZ; scf_type DF; freeze_core True; }. energy('sapt0'). Before, we have been setting keywords individually with commands like; set basis cc-pVDZ. Because we have a few more options now, it’s; convenient to place them together into the set; block, bounded by {...}. This; will set all of these options as “global” options (meaning that they are; visible to all parts of the program). Most common Psi4 options can be; set in a globals section like this. If an option needs to be visible; only to one part of the program (e.g., we only want to increase the; energy convergence in the SCF code, but not the rest of the; code), it can be placed in a section of input visible to that part of the; program (e.g., set scf e_convergence 1.0E-8).; Back to our SAPT example, we have found that for basic-level SAPT; computations (i.e., SAPT0), a good error cancellation is found; [Hohenstein:2012:WIREs] with the jun-cc-pVDZ basis (this is the; usual aug-cc-pVDZ basis, but without diffuse functions on hydrogen and; without diffuse functions on heavy atoms)",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/tutorial-1.html:10711,energy,energy,10711,psi4manual/1.0.0/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/tutorial-1.html,2,['energy'],['energy']
Energy Efficiency,"nd their irreducible representations. The occupancy is specified by either NIRREP or 2*NIRREP integers specifying the number of occupied orbitals of each symmetry type, where NIRREP is the number of irreducible representations in the computational point group. If there are no orbitals of a particular symmetry type a zero must be entered. If the reference function is for an open-shell system, two strings of NIRREP occupation numbers separated by a slash are input for the and sets of orbitals. An example of the use of the OCCUPATION keyword for the water molecule would be OCCUPATION=3-1-1-0. For the water cation, an open-shell system, the keyword would be specified by OCCUPATION=3-1-1-0/2-1-1-0. It should be noted that the xvmol integral program orders the irreducible representations in a strange way, which most users do not perceive to be a logical order. Hence, it is usually advisable initially to run just a single point integral and HF-SCF calculation in order to determine the number and ordering of the irreducible representations. The occupation keyword may be omitted, in which case an initial orbital occupancy is determined by diagonalization of the core Hamiltonian. In many cases, HF-SCF calculations run with the core Hamiltonian guess will usually converge to the lowest energy HF-SCF solution, but this should not be blindly assumed. (Default: The occupation is given by the core Hamiltonian initial guess). Psi4 Interface: The arrays above are specified in PSI as (whitespace-tolerant) [3,1,1,0] and [[3,1,1,0],[3,0,1,0]]. Type: array; Default: No Default. Previous topic; CFOUR_NTOP_TAMP; Next topic; CFOUR_OMP_NUM_THREADS. This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; Psi4 [1.0.0 6a9a71b] » ; Appendices »; Keywords by Module »; CFOUR ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodir_options_c/cfour__cfour_occupation-1.html:1608,energy,energy,1608,psi4manual/1.0.0/autodir_options_c/cfour__cfour_occupation-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodir_options_c/cfour__cfour_occupation-1.html,2,['energy'],['energy']
Energy Efficiency,"nd their variants are; available only through the DFTD3 or DFTD4 programs. Once installed, the; dftd3/PSI4 and dftd4/PSI4 interfaces are transparent, and all corrections are; interfaced exactly alike.; The -D3 interface can use classic or simple-dftd3 programs interchangeably and will prefer the latter.; Despite different defaults in these programs when run independently,; when run through PSI4 as EmpiricalDispersion engine, each should; produce the same result. Moreover, PSI4‘s own defaults and aliases; are unchanged by the new engines, so -D continues to mean -D2,; -D3 continues to mean zero-damping without 3-body correction,; and input files should continue producing the same results. Please file; an issue if found otherwise.; Dispersion corrections are built into DFT functionals, so appending an a; posteriori correction to a computation is as simple as; energy('b2plyp-d') vs. energy('b2plyp'). For example, the; following input file computes (with much redundant work) for water a; B3LYP, a B3LYP-D2, a B3LYP-D3 (zero-damping), and a B3LYP-D4 (Becke-Johnson damping) energy.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('b3lyp'); energy('b3lyp-d'); energy('b3lyp-d3'); energy('b3lyp-d4'). Consult the table -D Functionals to see for each; functional what corrections are available and what default parameters; define them. The dispersion correction is available after a calculation in; the PSI variable DISPERSION CORRECTION ENERGY.; By default, the output from the dftd3; program is suppressed; to see it in the output file, set print > 2.; No text output is available from the dftd4 or s-dftd3 programs. Variants of dispersion corrections¶. Extension [1] and Aliases; Variant; Computing Program (engine); DFT_DISPERSION_PARAMETERS [11]. -D; alias to -D2. -D1; -D1 [2]; PSI4‘s libdisp; [\(s_6\)]. -D2; -D2 [3]; PSI4‘s libdisp OR dftd3; [\(s_6\), \(\alpha_6\), \(s_{r,6}\)]. -D3ZERO2B, -D3ZERO, -D32B, -D3; -D3 [4] w/ original zero-damping w/o 3-bo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/dftd3.html:7204,energy,energy,7204,psi4manual/1.7.x/dftd3.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/dftd3.html,2,['energy'],['energy']
Energy Efficiency,"nd to allow all options to be used in the presence of all other; options. Below are some rough words of advice about using the SCF code for; practical calculations:. For GUESS, the SAD guess is usually your; friend, even for open-shell systems (at the very least, it gets the right; number of electrons, unlike some other programs). For instance, we have found; that a simple SAD guess is often as good as doing a full SCF in a 3-21G basis; and then performing a cast-up, at a fraction of the cost. However, SAD and; DOCC/SOCC arrays do not play very well together at the moment.; For wall time, DF may be a factor of ten or more faster than the exact; integral technologies available in PSI4.; Use DF unless you need absolute accuracy or do not; have a -JKFIT auxiliary set for your orbital basis/atom type. Then use; DIRECT.; Don’t mess with the DIIS convergence options unless convergence is a problem.; We have optimized the parameters for efficiency over a wide array of system; types.; Buy a developer a beer!. The “best-practice” input file for HF is:; memory 1 GB # As much as you've got, the DF algorithm can use. molecule {; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; basis cc-pvdz; scf_type df; guess sad; ints_tolerance 1.0E-10 # Even this is epically tight, 1.0E-8 is OK; }. energy('scf'). table of contents. HF: Hartree–Fock Theory; Introduction; Theory; Minimal Input; Spin/Symmetry Treatment; Broken Symmetry; Orthogonalization; Initial Guess; Restarting the SCF; Convergence Stabilization; ERI Algorithms; COSX Exchange; Linear Exchange; Second-order Convergence; Stability Analysis; Effective core potentials (ECPs); External potentials and QM/MM; Convergence and Algorithm Defaults; Recommendations. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Theoretical Methods: SCF to FCI; HF: Hartree–Fock Theory. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/scf.html:49876,energy,energy,49876,psi4manual/1.7.x/scf.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/scf.html,1,['energy'],['energy']
Energy Efficiency,"nd(E); convs.append(C). core.set_local_option(""SCF"", ""FRAC_START"", 2); # NYI core.set_local_option(""SCF"", ""FRAC_LOAD"", True); core.set_local_option(""SCF"", ""FRAC_DIIS"", frac_diis); core.set_local_option(""SCF"", ""GUESS"", ""READ""). # Set the next charge/mult; molecule.set_molecular_charge(charge); molecule.set_multiplicity(mult). # Determine HOMO; print('DGAS: What ref should this point to?'); eps_a = wfn.epsilon_a(); eps_b = wfn.epsilon_b(); if Na == Nb:; HOMO = -Nb; elif Nb == 0:; HOMO = Na; else:; E_a = eps_a.np[int(Na - 1)]; E_b = eps_b.np[int(Nb - 1)]; if E_a >= E_b:; HOMO = Na; else:; HOMO = -Nb. stats.append("""""" %6d %6d %6d %6d %6d %6d\n"""""" % (Nintegral-1, Na, Nb, charge, mult, HOMO)). if HOMO > 0:; Na -= 1; else:; Nb -= 1; charge += 1; mult = Na - Nb + 1. core.set_local_option(""SCF"", ""DF_INTS_IO"", ""NONE""). # => Print the results out <= #; E = {}; core.print_out(""""""\n ==> Fractional Occupation Nuke Results <==\n\n""""""); core.print_out("""""" %-11s %-24s %-24s %11s\n"""""" % ('N', 'Energy', 'HOMO Energy', 'Converged')); for k in range(len(Ns)):; core.print_out("""""" %11.3E %24.16E %24.16E %11d\n"""""" % (Ns[k], energies[k], potentials[k], convs[k])); E[Ns[k]] = energies[k]. core.print_out('\n'); core.print_out("""""" %6s %6s %6s %6s %6s %6s\n"""""" % ('N', 'Na', 'Nb', 'Charge', 'Mult', 'HOMO')); for line in stats:; core.print_out(line). core.print_out('\n ""You shoot a nuke down a bug hole, you got a lot of dead bugs""\n'); core.print_out(' -Starship Troopers\n'). # Drop the files out; with open(traverse_filename, 'w') as fh:; fh.write("""""" %-11s %-24s %-24s %11s\n"""""" % ('N', 'Energy', 'HOMO Energy', 'Converged')); for k in range(len(Ns)):; fh.write("""""" %11.3E %24.16E %24.16E %11d\n"""""" % (Ns[k], energies[k], potentials[k], convs[k])). with open(stats_filename, 'w') as fh:; fh.write("""""" %6s %6s %6s %6s %6s %6s\n"""""" % ('N', 'Na', 'Nb', 'Charge', 'Mult', 'HOMO')); for line in stats:; fh.write(line). optstash.restore(); return E. [docs]; def ip_fitting(name: Union[str, Callable], omega_l: f",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/frac.html:13470,Energy,Energy,13470,psi4manual/1.8.x/_modules/psi4/driver/frac.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/frac.html,6,['Energy'],['Energy']
Energy Efficiency,"nd(E); convs.append(C). core.set_local_option(""SCF"", ""FRAC_START"", 2); # NYI core.set_local_option(""SCF"", ""FRAC_LOAD"", True); core.set_local_option(""SCF"", ""FRAC_DIIS"", frac_diis); core.set_local_option(""SCF"", ""GUESS"", ""READ""). # Set the next charge/mult; molecule.set_molecular_charge(charge); molecule.set_multiplicity(mult). # Determine HOMO; print('DGAS: What ref should this point to?'); eps_a = wfn.epsilon_a(); eps_b = wfn.epsilon_b(); if Na == Nb:; HOMO = -Nb; elif Nb == 0:; HOMO = Na; else:; E_a = eps_a.np[int(Na - 1)]; E_b = eps_b.np[int(Nb - 1)]; if E_a >= E_b:; HOMO = Na; else:; HOMO = -Nb. stats.append("""""" %6d %6d %6d %6d %6d %6d\n"""""" % (Nintegral-1, Na, Nb, charge, mult, HOMO)). if HOMO > 0:; Na -= 1; else:; Nb -= 1; charge += 1; mult = Na - Nb + 1. core.set_local_option(""SCF"", ""DF_INTS_IO"", ""NONE""). # => Print the results out <= #; E = {}; core.print_out(""""""\n ==> Fractional Occupation Nuke Results <==\n\n""""""); core.print_out("""""" %-11s %-24s %-24s %11s\n"""""" % ('N', 'Energy', 'HOMO Energy', 'Converged')); for k in range(len(Ns)):; core.print_out("""""" %11.3E %24.16E %24.16E %11d\n"""""" % (Ns[k], energies[k], potentials[k], convs[k])); E[Ns[k]] = energies[k]. core.print_out('\n'); core.print_out("""""" %6s %6s %6s %6s %6s %6s\n"""""" % ('N', 'Na', 'Nb', 'Charge', 'Mult', 'HOMO')); for line in stats:; core.print_out(line). core.print_out('\n ""You shoot a nuke down a bug hole, you got a lot of dead bugs""\n'); core.print_out(' -Starship Troopers\n'). # Drop the files out; with open(traverse_filename, 'w') as fh:; fh.write("""""" %-11s %-24s %-24s %11s\n"""""" % ('N', 'Energy', 'HOMO Energy', 'Converged')); for k in range(len(Ns)):; fh.write("""""" %11.3E %24.16E %24.16E %11d\n"""""" % (Ns[k], energies[k], potentials[k], convs[k])). with open(stats_filename, 'w') as fh:; fh.write("""""" %6s %6s %6s %6s %6s %6s\n"""""" % ('N', 'Na', 'Nb', 'Charge', 'Mult', 'HOMO')); for line in stats:; fh.write(line). optstash.restore(); return E. [docs]def ip_fitting(name: Union[str, Callable], omega_l: flo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/frac.html:13464,Energy,Energy,13464,psi4manual/1.7.x/_modules/psi4/driver/frac.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/frac.html,2,['Energy'],['Energy']
Energy Efficiency,"ndent polarizability,; or optical rotation angles) for some models. Excited states can; also be computed by the CC2 and CC3 models, or by EOM-CCSD. Table; CC Methods summarizes these capabilities. This section; describes how to carry out coupled cluster calculations within PSI4.; For higher-order coupled-cluster methods like CCSDT and CCSDTQ, PSI4; can interface to Kállay’s MRCC code (see MRCC). Current coupled cluster capabilities of PSI4. Reference; Method; Energy; Gradient; Exc. Energies; LR Props. RHF; CC2; Y; N; Y; Y. UHF; CC2; Y; N; Y; N. ROHF; CC2; Y; N; Y; N. RHF; CCSD; Y; Y; Y; Y. RHF; CCSD(T); Y; N; —; —. ROHF; CCSD; Y; Y; Y; N. ROHF; CCSD(T); Y; N; —; —. UHF; CCSD; Y; Y; Y; N. UHF; CCSD(T); Y; Y; —; —. RHF; CC3; Y; N; Y; N. UHF; CC3; Y; N; Y; N. ROHF; CC3; Y; N; Y; N. Brueckner; CCD; Y; N; N; N. Brueckner; CCD(T); Y; N; —; —. The following wavefunctions are currently recognized by PSI4 as arguments; to functions like energy(): 'ccsd', 'ccsd(t)', 'cc2',; 'cc3', 'bccd' (CCD with Brueckner orbitals), 'bccd(t)' (CCD(T) with; Brueckner orbitals), 'eom-ccsd', 'eom-cc2' (CC2 for excited states),; 'eom-cc3' (CC3 for excited states). Response properties can be obtained; by calling the function property() (instead of, for example, energy(),; e.g., property('ccsd'). There are many sample; coupled cluster inputs provided in psi4/samples. Basic Keywords¶; A complete list of keywords related to coupled-cluster computations is; provided in the appendices, with the majority of the relevant; keywords appearing in Appendix CCENERGY. For a standard ground-state; CCSD or CCSD(T) computation, the following keywords are common:. REFERENCE¶. Reference wavefunction type. Type: string; Possible Values: RHF, ROHF, UHF; Default: RHF. R_CONVERGENCE¶. Convergence criterion for wavefunction (change) in CC amplitude equations. Type: conv double; Default: 1e-7. MAXITER¶. Maximum number of iterations to solve the CC equations. Type: integer; Default: 50. BRUECKNER_ORBS_R_CONVERGENCE¶. Con",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/cc-1.html:3146,energy,energy,3146,psi4manual/4.0b2/cc-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/cc-1.html,4,['energy'],['energy']
Energy Efficiency,"ndex. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Introduction¶. Overview¶; PSI4 provides a wide variety of quantum chemical methods using; state-of-the-art numerical methods and algorithms. Several parts of; the code feature shared-memory parallelization to run efficiently on; multi-core machines (see Sec. Threading).; An advanced parser written in Python allows the user; input to have a very simple style for routine computations, but it can also; automate very complex tasks with ease.; PSI4 is, in many ways, a whole new package compared to Psi3.; While some libraries and modules remain the same, the majority of the code has; been rewritten from scratch based on a powerful set of new libraries written; in C++. A totally new Python front-end makes PSI4 incredibly user-friendly; and automates many common tasks such as basis set extrapolation, composite; methods, running the same computation on every molecule in a test set, etc.; Density-functional theory, absent in Psi3, is quite efficient; in PSI4, with many functionals available. Density fitting is ubiquitous in; PSI4, leading to some of the most efficient MP2 and CCSD(T) code available.; PSI4 also introduces extensive,; powerful features for energy component analysis of non-covalent interactions; via symmetry-adapted perturbation theory. Orbital-optimized versions of; perturbation theory and coupled-cluster methods, and their analytic gradients,; have also been added. Through external libraries, PSI4 gains access to implicit; solvent (PCM) capabilities, density-matrix renormalization group CI, effective; fragment potentials, Grimme dispersion corrections, and high-order; coupled-cluster theory.; In this section, we provide an overview of some of the features of; PSI4 along with the prerequisite steps for running calculations.; Sec. Tutorial provides a brief tutorial to help new users; get started. Section Psithon offers further details into the; structure of PSI4 input files and how Python can be mixed with",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/introduction-1.html:1031,efficient,efficient,1031,psi4manual/1.2.1/introduction-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/introduction-1.html,2,['efficient'],['efficient']
Energy Efficiency,"ndex. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Introduction¶. Overview¶; PSI4 provides a wide variety of quantum chemical methods using; state-of-the-art numerical methods and algorithms. Several parts of; the code feature shared-memory parallelization to run efficiently on; multi-core machines (see Sec. Threading).; An advanced parser written in Python allows the user; input to have a very simple style for routine computations, but it can also; automate very complex tasks with ease.; PSI4 is, in many ways, a whole new package compared to Psi3.; While some libraries and modules remain the same, the majority of the code has; been rewritten from scratch based on a powerful set of new libraries written; in C++. A totally new Python front-end makes PSI4 incredibly user-friendly; and automates many common tasks such as basis set extrapolation, composite; methods, running the same computation on every molecule in a test set, etc.; Density-functional theory, absent in Psi3, is quite efficient; in PSI4, with many functionals available. Density fitting is ubiquitous in; PSI4, leading to some of the most efficient MP2 and CCSD(T) code available.; PSI4 also introduces extensive,; powerful features for energy component analysis of non-covalent interactions; via symmetry-adapted perturbation theory. Orbital-optimized versions of; perturbation theory and coupled-cluster methods, and their analytic gradients,; have also been added. Through external libraries, PSI4 gains access to implicit; solvent (PCM) capabilities, density-matrix renormalization group CI, effective; fragment potentials, Grimme dispersion corrections, and high-order; coupled-cluster theory.; In this section, we provide an overview of some of the features of; PSI4 along with the prerequisite steps for running calculations.; Sec. Tutorial provides a brief tutorial to help new users; get started. Section Psithon offers further details into the; structure of PSI4 input files and how Python can be mixed with",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/introduction-1.html:1031,efficient,efficient,1031,psi4manual/1.3.2/introduction-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/introduction-1.html,2,['efficient'],['efficient']
Energy Efficiency,"ndicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. delta2_wfn (str) – 'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. delta2_wfn_lesser (str) – \(\Rightarrow\) delta_wfn \(\Leftarrow\) || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. Basis Sets; Currently, the basis set set through set commands have no influence; on a cbs calculation. Parameters:; scf_basis (basis string) – \(\Rightarrow\) corl_basis \(\Leftarrow\) || 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, scf_basis can default; to corl_basis. corl_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the correlation energy. delta_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. delta2_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. Schemes; Transformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, 'xtpl_highest_1', which uses the best basis; set available. See sec:cbs_xtpl for all available schemes. Parameters:; scf_scheme (function) – \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || scf_xtpl_helgaker_3 || etc.; Indicates the basis set extrapolation scheme to be applied to the reference energy.; Defaults to scf_xtpl_hel",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.driver.cbs-1.html:7048,energy,energy,7048,psi4manual/1.3.2/api/psi4.driver.cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.driver.cbs-1.html,4,['energy'],['energy']
Energy Efficiency,"ndices' : [0, 1],; 'value' : 2.0 },; {'type' : 'angle',; 'indices' : [1, 0, 2],; 'value' : 104.5 }]; }; }. optimize('hf/cc-pvdz', engine='geometric', optimizer_keywords=geometric_keywords). Optimize the benzene/water dimer using GeomeTRIC, with the 6 carbon atoms of benzene frozen in; place:; molecule h2o {; C 0.833 1.221 -0.504; H 1.482 2.086 -0.518; C 1.379 -0.055 -0.486; H 2.453 -0.184 -0.483; C 0.546 -1.167 -0.474; H 0.971 -2.162 -0.466; C -0.833 -1.001 -0.475; H -1.482 -1.867 -0.468; C -1.379 0.275 -0.490; H -2.453 0.404 -0.491; C -0.546 1.386 -0.506; H -0.971 2.381 -0.524; --; O 0.000 0.147 3.265; H 0.000 -0.505 2.581; H 0.000 0.965 2.790; no_com; no_reorient; }. set {; maxiter 100; g_convergence gau; }. geometric_keywords = {; 'coordsys' : 'tric',; 'constraints' : {; 'freeze' : [{'type' : 'xyz',; 'indices' : [0, 2, 4, 6, 8, 10]}]; }; }. optimize('hf/cc-pvdz', engine='geometric', optimizer_keywords=geometric_keywords). Output¶; The progress of a geometry optimization can be monitored by grepping the output file for the; tilde character (~). This produces a table like the one below that shows; for each iteration the value for each of the five quantities and whether the criterion; is active and fulfilled (*), active and unfulfilled ( ), or inactive (o).; --------------------------------------------------------------------------------------------- ~; Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~; --------------------------------------------------------------------------------------------- ~; Convergence Criteria 1.00e-06 * 3.00e-04 * o 1.20e-03 * o ~; --------------------------------------------------------------------------------------------- ~; 1 -38.91591820 -3.89e+01 6.91e-02 5.72e-02 o 1.42e-01 1.19e-01 o ~; 2 -38.92529543 -9.38e-03 6.21e-03 3.91e-03 o 2.00e-02 1.18e-02 o ~; 3 -38.92540669 -1.11e-04 4.04e-03 2.46e-03 o 3.63e-02 2.12e-02 o ~; 4 -38.92548668 -8.00e-05 2.30e-04 * 1.92e-04 o 1.99e-03 1.17e-03 o ~; 5 -38.92548698 -2.98e-07 * 3",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/optking-1.html:16231,monitor,monitored,16231,psi4manual/1.4.0/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/optking-1.html,9,['monitor'],['monitored']
Energy Efficiency,"ndices. As the potential energy scan is performed, the results are stored; (line 22) and the final table is printed to the output file (line 24). The; table is converted from absolute energies to relative energies (in kcal mol-1); on line 26, before being printed again. The relative energies are reported with; respect to the lowest value in each column. More examples of how to control the; formatting of the tables can be found in the sample input files provided; see; Appendix Test Suite and Sample Inputs for a complete listing. Python Wrappers¶; The Python foundations of the PSI4 driver and Psithon syntax permit; many commonly performed post-processing procedures to be integrated into; the PSI4 suite.; As seen in the neon dimer example from the tutorial section,; the nbody_gufunc() wrapper provides automatic computation of; counterpoise-corrected interaction energies between two molecules. For; example,; 1energy('mp2', bsse_type='cp'). will compute the counterpoise-corrected density-fitted MP2 interaction energy; between two molecules.; PSI4 also provides the cbs() wrapper,; which automatically computes a complete-basis-set extrapolation (and; automatically sets up the computations with different basis sets required to; do the extrapolation). For example,:; 1; 2; 3; 4; 5# all equivalent. cbs('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). energy('mp2/cc-pv[dt]z'). will compute a 2-point Helgaker extrapolation of the correlation energy; using the cc-pVDZ and cc-pVTZ basis sets (with method MP2) and add this; extrapolated correlation energy to the Hartree–Fock energy in the; largest basis (cc-pVTZ). cbs() can; either be called directly, as in the first example, or the convenience; syntax of the equivalent second example can be used.; Another very useful and powerful feature of PSI4 is the ability; to compute results on entire databases of molecules at a time,; as provided by the database() wrapper. For example,:; 1database('mp2', 'S22', cp=1, benchm",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psithoninput-1.html:15206,energy,energy,15206,psi4manual/1.1.0/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psithoninput-1.html,6,['energy'],['energy']
Energy Efficiency,"ndif_meta_dict = driver_findif.hessian_from_energies_geometries(molecule, irrep). # Record undisplaced symmetry for projection of diplaced point groups; core.set_global_option(""PARENT_SYMMETRY"", molecule.schoenflies_symbol()). ndisp = len(findif_meta_dict[""displacements""]) + 1. print(' %d displacements needed.' % ndisp). wfn = _process_displacement(energy, lowername, molecule, findif_meta_dict[""reference""], 1, ndisp,; **kwargs); var_dict = core.variables(). for n, displacement in enumerate(findif_meta_dict[""displacements""].values(), start=2):; _process_displacement(; energy, lowername, molecule, displacement, n, ndisp, write_orbitals=False, **kwargs). # Reset variables; for key, val in var_dict.items():; core.set_variable(key, val). # Assemble Hessian from energies; H = driver_findif.assemble_hessian_from_energies(findif_meta_dict, irrep); wfn.set_hessian(core.Matrix.from_array(H)); wfn.set_gradient(G0). # Explicitly set the current energy..; core.set_variable('CURRENT ENERGY', findif_meta_dict[""reference""][""energy""]); wfn.set_variable('CURRENT ENERGY', findif_meta_dict[""reference""][""energy""]). core.set_global_option(""PARENT_SYMMETRY"", """"); optstash.restore(); optstash_conv.restore(). _hessian_write(wfn). if return_wfn:; return (wfn.hessian(), wfn); else:; return wfn.hessian(). [docs]def frequency(name, **kwargs):; r""""""Function to compute harmonic vibrational frequencies. :aliases: frequencies(), freq(). :returns: *float* |w--w| Total electronic energy in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` ||",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:81598,energy,energy,81598,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,3,"['ENERGY', 'energy']","['ENERGY', 'energy']"
Energy Efficiency,"ndifrec['reference']['energy']. properties = {; ""calcinfo_natom"": self.molecule.natom(),; ""nuclear_repulsion_energy"": self.molecule.nuclear_repulsion_energy(),; ""return_energy"": E0,; }. qcvars['FINDIF NUMBER'] = len(self.task_list); qcvars['NUCLEAR REPULSION ENERGY'] = self.molecule.nuclear_repulsion_energy(); qcvars['CURRENT ENERGY'] = E0. DD0 = self.findifrec['reference'].get('dipole derivative'); if DD0 is not None:; qcvars['CURRENT DIPOLE GRADIENT'] = DD0; qcvars[f""{self.method.upper()} DIPOLE GRADIENT""] = DD0. G0 = self.findifrec['reference'].get('gradient'); if G0 is not None:; qcvars['CURRENT GRADIENT'] = G0; qcvars[f""{self.method.upper()} TOTAL GRADIENT""] = G0; properties[""return_gradient""] = G0. H0 = self.findifrec['reference'].get('hessian'); if H0 is not None:; qcvars['CURRENT HESSIAN'] = H0; qcvars[f""{self.method.upper()} TOTAL HESSIAN""] = H0; properties[""return_hessian""] = H0. # if isinstance(lowername, str) and lowername in procedures['energy']:; # # this correctly filters out cbs fn and ""hf/cc-pvtz""; # # it probably incorrectly filters out mp5, but reconsider in DDD. findif_model = AtomicResult(; **{; 'driver': self.driver,; 'model': {; ""basis"": self.basis,; 'method': self.method,; },; 'molecule': self.molecule.to_schema(dtype=2),; 'properties': properties,; 'provenance': p4util.provenance_stamp(__name__, module=self.findifrec[""reference""][""module""]),; 'extras': {; 'qcvars': qcvars,; 'findif_record': copy.deepcopy(self.findifrec),; },; 'return_result': self.findifrec['reference'][self.driver.name],; 'success': True,; }). logger.debug('\nFINDIF QCSchema:\n' + pp.pformat(findif_model)). return findif_model. [docs] def get_psi_results(self, return_wfn: bool = False) -> EnergyGradientHessianWfnReturn:; """"""Called by driver to assemble results into FiniteDifference-flavored QCSchema,; then reshape and return them in the customary Psi4 driver interface: ``(e/g/h, wfn)``. Parameters; ----------; return_wfn; Whether to additionally return the dummy :py:class:`",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_findif.html:51292,energy,energy,51292,psi4manual/1.7.x/_modules/psi4/driver/driver_findif.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_findif.html,2,['energy'],['energy']
Energy Efficiency,"ndifrec['reference']['energy']. properties = {; ""calcinfo_natom"": self.molecule.natom(),; ""nuclear_repulsion_energy"": self.molecule.nuclear_repulsion_energy(),; ""return_energy"": E0,; }. qcvars['FINDIF NUMBER'] = len(self.task_list); qcvars['NUCLEAR REPULSION ENERGY'] = self.molecule.nuclear_repulsion_energy(); qcvars['CURRENT ENERGY'] = E0. DD0 = self.findifrec['reference'].get('dipole derivative'); if DD0 is not None:; qcvars['CURRENT DIPOLE GRADIENT'] = DD0; qcvars[f""{self.method.upper()} DIPOLE GRADIENT""] = DD0. G0 = self.findifrec['reference'].get('gradient'); if G0 is not None:; qcvars['CURRENT GRADIENT'] = G0; qcvars[f""{self.method.upper()} TOTAL GRADIENT""] = G0; properties[""return_gradient""] = G0. H0 = self.findifrec['reference'].get('hessian'); if H0 is not None:; qcvars['CURRENT HESSIAN'] = H0; qcvars[f""{self.method.upper()} TOTAL HESSIAN""] = H0; properties[""return_hessian""] = H0. # if isinstance(lowername, str) and lowername in procedures['energy']:; # # this correctly filters out cbs fn and ""hf/cc-pvtz""; # # it probably incorrectly filters out mp5, but reconsider in DDD. findif_model = AtomicResult(; **{; 'driver': self.driver,; 'model': {; ""basis"": self.basis,; 'method': self.method,; },; 'molecule': self.molecule.to_schema(dtype=2),; 'properties': properties,; 'provenance': p4util.provenance_stamp(__name__, module=self.findifrec[""reference""][""module""]),; 'extras': {; 'qcvars': qcvars,; 'findif_record': copy.deepcopy(self.findifrec),; },; 'return_result': self.findifrec['reference'][self.driver.name],; 'success': True,; }). logger.debug('\nFINDIF QCSchema:\n' + pp.pformat(findif_model.dict())). return findif_model. [docs]; def get_psi_results(; self,; client: Optional[""qcportal.FractalClient""] = None,; *,; return_wfn: bool = False) -> EnergyGradientHessianWfnReturn:; """"""Called by driver to assemble results into FiniteDifference-flavored QCSchema,; then reshape and return them in the customary Psi4 driver interface: ``(e/g/h, wfn)``. Parameters; ---------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html:51533,energy,energy,51533,psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,6,['energy'],['energy']
Energy Efficiency,"nding speed and efficiency of the available BLAS and LAPACK libraries; (especially the former). In addition, the most common compilation problems; involve these libraries. Users may therefore wish to consider the following; BLAS and LAPACK recommendations when building PSI4:. It is NOT wise to use the stock BLAS library provided with many; Linux distributions like RedHat. This library is usually just the; netlib distribution and is completely unoptimized. PSI4’s; performance will suffer if you choose this route.; The choice of LAPACK is less critical, and so the unoptimized; netlib distribution is acceptable. If you do choose to use the; RedHat/Fedora stock BLAS and LAPACK, make sure that the blas-devel; and lapack-devel packages are installed. Perhaps the best choice, if you have it available, is; Intel’s MKL library, which includes BLAS and LAPACK (note: use; version 11 or later, we had difficulty with version 10 for very; large coupled-cluster computations). MKL is efficient and works; well in threaded mode.; Otherwise, the simplest choice is to use ATLAS; (http://math-atlas.sourceforge.net/), which is readily available; on all Linux distributions. Another alternative is OpenBLAS; (https://github.com/xianyi/OpenBLAS, formerly GotoBLAS). These; work well on nearly every achitecture to which the PSI4 developers; have access, though we have identified at least one case in which; the Goto libraries yielded faulty DGEMM calls. On Mac OS X; systems, the vecLib package that comes with Xcode works well. PSI4 does not require a Fortran compiler, unless the resident BLAS; and LAPACK libraries require Fortran-based system libraries. If you see; compiler complaints about missing symbols like “do_fio” or “e_wsfe”, then; your libraries were most likely compiled with g77 or gfortran, which; require -lg2c to resolve the Fortran I/O calls. Use of the same gcc; package for PSI4 should normally resolve this problem. The PSI4 configure script can often identify and use several; diffe",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/installfile.html:21426,efficient,efficient,21426,psi4manual/4.0b3/installfile.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html,2,['efficient'],['efficient']
Energy Efficiency,"nding speed and efficiency of the available BLAS and LAPACK libraries; (especially the former). In addition, the most common compilation problems; involve these libraries. Users may therefore wish to consider the following; BLAS and LAPACK recommendations when building PSI4:. It is NOT wise to use the stock BLAS library provided with many; Linux distributions like RedHat. This library is usually just the; netlib distribution and is completely unoptimized. PSI4’s; performance will suffer if you choose this route.; The choice of LAPACK is less critical, and so the unoptimized; netlib distribution is acceptable. If you do choose to use the; RedHat/Fedora stock BLAS and LAPACK, make sure that the blas-devel; and lapack-devel packages are installed. Perhaps the best choice, if you have it available, is; Intel’s MKL library, which includes BLAS and LAPACK (note: use; version 11 or later, we had difficulty with version 10 for very; large coupled-cluster computations). MKL is efficient and works; well in threaded mode.; Otherwise, the simplest choice is to use ATLAS; (http://math-atlas.sourceforge.net/), which is readily available; on all Linux distributions. Another alternative is OpenBLAS; (https://github.com/xianyi/OpenBLAS, formerly GotoBLAS). These; work well on nearly every achitecture to which the PSI4 developers; have access, though we have identified at least one case in which; the Goto libraries yielded faulty DGEMM calls. On Mac OS X; systems, the vecLib package that comes with Xcode works well.; If you prefer to use the ACML; (http://developer.amd.com/tools/cpu-development/amd-core-math-library-acml/); we highly recommend using the latest version. Older versions; of ACML have been known to cause problems. PSI4 does not require a Fortran compiler, unless the resident BLAS; and LAPACK libraries require Fortran-based system libraries. If you see; compiler complaints about missing symbols like “do_fio” or “e_wsfe”, then; your libraries were most likely compiled with ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/installfile.html:21192,efficient,efficient,21192,psi4manual/4.0b5/installfile.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/installfile.html,1,['efficient'],['efficient']
Energy Efficiency,"nds to the second-order FNO; correction mentioned previously. Results for many-body perturbation; theory through partial fourth order are then provided.; The notation MP4(SDQ) indicates that we have included all contributions to; the correlation energy through fourth order, with the exception of that; from connected triple excitations.; One need not run a full QCISD or CCSD computation to obtain these; perturbation theory results. The keywords for invoking perturbation; theory computations are given below in; Table FNOCC Methods. Full MP4 correlation; energies are also available. Coupled electron pair approximation¶; Coupled-pair methods can be viewed as approximations to CCSD or as; size-extensive modifications of CISD. The methods have the same; complexity as CISD, and solving the CISD or coupled-pair equations; requires fewer floating point operations than solving the CCSD. CISD,; CCSD, and the coupled-pair methods discussed below all scale formally with; the sixth power of system size, and, as with the QCISD method, CEPA; methods retain \({\cal{O}}(o^2v^4)\) complexity of the CCSD equations.; For a detailed discussion of the properties of various coupled-pair; methods, see [Wennmohs:2008:217].; What follows is a very basic description of the practical differences in; the equations that define each of the coupled-pair methods implemented in; PSI4. We begin with the CISD wave function. (3)¶\[| \Psi \rangle = | \Psi_0 \rangle + \sum_i^{occ} \sum_a^{vir} t_i^a | \Psi_i^a\rangle + \frac{1}{4}\sum_{ij}^{occ} \sum_{ab}^{vir} t_{ij}^{ab} | \Psi_{ij}^{ab}\rangle,\]; where we have chosen the intermediate normalization, \(\langle \Psi_0; | \Psi \rangle = 1\). The CISD correlation energy is given by. (4)¶\[E_c = \langle \Psi_0 | \hat{H} - E_0 | \Psi \rangle,\]; and the amplitudes can be determined by the solution to the coupled set of; equations:. (5)¶\[\begin{split}0 &= \langle \Psi_{ij}^{ab} | \hat{H} - E_0 - E_c | \Psi \rangle, \\; 0 &= \langle \Psi_{i}^{a} | \hat{H} - E_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/fnocc-1.html:7364,power,power,7364,psi4manual/1.1.0/fnocc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/fnocc-1.html,15,['power'],['power']
Energy Efficiency,"nduction-classified correction from MP2 implemented for SAPT2.; Value varies by SAPT level. SAPT0 DISP ENERGY¶. SAPT0 ELST ENERGY¶. SAPT0 EXCH ENERGY¶. SAPT0 IND ENERGY¶. SSAPT0 DISP ENERGY¶. SSAPT0 ELST ENERGY¶. SSAPT0 EXCH ENERGY¶. SSAPT0 IND ENERGY¶. SAPT2 DISP ENERGY¶. SAPT2 ELST ENERGY¶. SAPT2 EXCH ENERGY¶. SAPT2 IND ENERGY¶. SAPT2+ DISP ENERGY¶. SAPT2+ ELST ENERGY¶. SAPT2+ EXCH ENERGY¶. SAPT2+ IND ENERGY¶. SAPT2+(3) DISP ENERGY¶. SAPT2+(3) ELST ENERGY¶. SAPT2+(3) EXCH ENERGY¶. SAPT2+(3) IND ENERGY¶. SAPT2+3 DISP ENERGY¶. SAPT2+3 ELST ENERGY¶. SAPT2+3 EXCH ENERGY¶. SAPT2+3 IND ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total electronic interaction energy [E_h] for the; given SAPT level of theory. The sum of these four components yields; the SAPT Level TOTAL ENERGY. SAPT0 TOTAL ENERGY¶. SSAPT0 TOTAL ENERGY¶. SAPT2 TOTAL ENERGY¶. SAPT2+ TOTAL ENERGY¶. SAPT2+(3) TOTAL ENERGY¶. SAPT2+3 TOTAL ENERGY¶; The total electronic interaction energy [E_h] for the labeled SAPT level; of theory. SAPT2+(CCD) DISP ENERGY¶. SAPT2+(CCD) ELST ENERGY¶. SAPT2+(CCD) EXCH ENERGY¶. SAPT2+(CCD) IND ENERGY¶. SAPT2+(3)(CCD) DISP ENERGY¶. SAPT2+(3)(CCD) ELST ENERGY¶. SAPT2+(3)(CCD) EXCH ENERGY¶. SAPT2+(3)(CCD) IND ENERGY¶. SAPT2+3(CCD) DISP ENERGY¶. SAPT2+3(CCD) ELST ENERGY¶. SAPT2+3(CCD) EXCH ENERGY¶. SAPT2+3(CCD) IND ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total electronic interaction energy [E_h] for the; given SAPT level of theory that incorporates coupled-cluster dispersion.; The sum of these four components yields the SAPT Level TOTAL ENERGY. SAPT2+(CCD) TOTAL ENERGY¶. SAPT2+(3)(CCD) TOTAL ENERGY¶. SAPT2+3(CCD) TOTAL ENERGY¶; The total electronic interaction energy [E_h] for the labeled SAPT level; of theory that incorporates coupled-cluster dispersion. SAPT2+DMP2 DISP ENERGY¶. SAPT2+DMP2 ELST ENERGY¶. SAPT2+DMP2 EXCH ENERGY¶. SAPT2+DMP2 IND ENERGY¶. SAPT2+(3)DMP2 DISP ENER",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html:50602,energy,energy,50602,psi4manual/1.7.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html,4,['energy'],['energy']
Energy Efficiency,"nd{split}\]; QCISD is slightly cheaper that CCSD computationally, but it retains the; \({\cal{O}}(o^2v^4)\) complexity of the original equations. Just as in; the familiar CCSD(T) method, the effects of connected triple excitations; may be included noniteratively to yield the QCISD(T) method. Both the; QCISD(T) and CCSD(T) methods are implemented for closed-shell references; in the FNOCC module. Many-body perturbation theory¶; QCI and CC methods are closely related to perturbation theory, and the; MP2, MP3, and MP4(SDQ) correlation energies can be obtained as a free; by-product of a CCSD or QCISD computation. The following is an; example of the results for a computation run with the call; energy('fno-qcisd') to energy():; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30QCISD iterations converged!. OS MP2 FNO correction: -0.000819116338; SS MP2 FNO correction: -0.000092278158; MP2 FNO correction: -0.000911394496. OS MP2 correlation energy: -0.166478414245; SS MP2 correlation energy: -0.056669079827; MP2 correlation energy: -0.223147494072; * MP2 total energy: -76.258836941658. OS MP2.5 correlation energy: -0.171225850256; SS MP2.5 correlation energy: -0.054028401038; MP2.5 correlation energy: -0.225254251294; * MP2.5 total energy: -76.260943698880. OS MP3 correlation energy: -0.175973286267; SS MP3 correlation energy: -0.051387722248; MP3 correlation energy: -0.227361008515; * MP3 total energy: -76.263050456101. OS MP4(SDQ) correlation energy: -0.180324322304; SS MP4(SDQ) correlation energy: -0.048798468084; MP4(SDQ) correlation energy: -0.230995119324; * MP4(SDQ) total energy: -76.266684566910. OS QCISD correlation energy: -0.181578117924; SS QCISD correlation energy: -0.049853548145; QCISD correlation energy: -0.231431666069; * QCISD total energy: -76.267121113654. The first set of energies printed corresponds to the second-order FNO; correction mentioned previously. Results for many-body perturbation; theo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/fnocc-1.html:5487,energy,energy,5487,psi4manual/1.1.0/fnocc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/fnocc-1.html,6,['energy'],['energy']
Energy Efficiency,"ne :; Closes the output file.; ; dcft(...); dcft() -> float :; Runs the density cumulant functional theory code.; ; deriv(...); deriv() -> int :; Runs deriv, which contracts density matrices with derivative integrals, to compute gradients.; ; detci(...); detci() -> float :; Runs the determinant-based configuration interaction code.; ; dfmp2(...); dfmp2() -> float :; Runs the DF-MP2 code.; ; dfmp2grad(...); dfmp2grad() -> float :; Runs the DF-MP2 gradient.; ; fd_1_0(...); fd_1_0( (list)arg1) -> PsiReturnType :; Performs a finite difference gradient computation, from energy points.; ; fd_freq_0(...); fd_freq_0( (list)arg1, (int)arg2) -> PsiReturnType :; Performs a finite difference frequency computation, from energy points, for a given irrep.; ; fd_freq_1(...); fd_freq_1( (list)arg1, (int)arg2) -> PsiReturnType :; Performs a finite difference frequency computation, from gradients, for a given irrep.; ; fd_geoms_1_0(...); fd_geoms_1_0() -> matrix_vector :; Gets the list of displacements needed for a finite difference gradient computation, from energy points.; ; fd_geoms_freq_0(...); fd_geoms_freq_0( (int)arg1) -> matrix_vector :; Gets the list of displacements needed for a finite difference frequency computation, from energy points, for a given irrep.; ; fd_geoms_freq_1(...); fd_geoms_freq_1( (int)arg1) -> matrix_vector :; Gets the list of displacements needed fof a finite difference frequency computation, from gradients, for a given irrep; ; fd_geoms_hessian_0(...); fd_geoms_hessian_0() -> matrix_vector :; Gets the list of displacements needed fof a finite difference frequency computation, from energy points.; ; fd_hessian_0(...); fd_hessian_0( (list)arg1) -> PsiReturnType :; Performs a finite difference frequency computation, from energy points.; ; flush_outfile(...); flush_outfile() -> None :; Flushes the output file.; ; get_active_molecule(...); get_active_molecule() -> Molecule :; Returns the currently active molecule object.; ; get_global_option(...); get_global_o",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/psimod-1.html:106256,energy,energy,106256,psi4manual/4.0b3/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html,2,['energy'],['energy']
Energy Efficiency,"ne Cartesian coordinates; which is much easier to visualize than the corresponding Cartesian-only; approach. Multiple Molecules¶; To facilitate more elaborate computations, it is possible to provide a name for; each molecule, and tell PSI4 which one should be used in a given; calculation. For example, consider the following input file:; molecule h2{; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; energy('scf'). molecule h{; H; }. set basis cc-pvdz; set reference uhf; energy('scf'). Here, two separate jobs are performed on two different molecules; the first is; performed on H2, while the second is for H atom. The last molecule to be; specified is the “active” molecule by default. To explicitly activate a named; molecule, the activate keyword is provided. Using this keyword, the above input; file can be equivalently written as follows:; molecule h2{; H; H 1 0.9; }. molecule h{; H; }. activate(h2); set basis cc-pvdz; set reference rhf; energy('scf'). activate(h); set basis cc-pvdz; set reference uhf; energy('scf'). Note that whenever the molecule is changed, the basis set must be specified; again. The following section provides more details about the job control; keywords used in the above examples. Molecule Keywords¶; In addition to specifying the geometry, additional information can be; provided in the molecule optional_molecule_name {...} block.; If two integers charge multiplicity are encountered on any; line of the molecule block, they are interpreted as the molecular charge; and multiplicity (), respectively. The symmetry; can be specified by a line reading symmetry symbol, where; symbol is the Schönflies symbol of the; (Abelian) point group to use for the computation. This need not be; specified, as the molecular symmetry is automatically detected by; PSI4. Certain computations require that the molecule is not; reoriented; this can be achieved by adding either no_reorient or; noreorient. By default, Ångström units are used; this is changed by; adding a lin",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:7285,energy,energy,7285,psi4manual/4.0b4/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html,4,['energy'],['energy']
Energy Efficiency,"ne Electron Integral Algorithm Overview¶; The following table summarizes which implementation is used; for each type of one electron integral in PSI4. Algorithms used for One Electron Integrals¶. Integral; Class; Implementation; Comment. Three-Center Overlap; ThreeCenterOverlapInt; Libint2; using libint2::Operator::delta for 4-center integrals. Angular Momentum; AngularMomentumInt; M-D. Dipole; DipoleInt; Libint2; no derivatives supported. Electric Field; ElectricFieldInt; Libint2; using first derivative of libint2::Operator::nuclear. Coulomb Potential; ElectrostaticInt; Libint2; evaluated for a single origin and unity charge. Kinetic; KineticInt; Libint2. Multipole Potential; MultipolePotentialInt; M-D; arbitrary order derivative of 1/R supported. Multipole Moments; MultipoleInt; M-D; arbitrary order multipoles supported, including nuclear gradients. Nabla Operator; NablaInt; Libint2; using first derivative of libint2::Operator::overlap. Overlap; OverlapInt; Libint2. Nuclear Coulomb Potential; PotentialInt; Libint2; assumes nuclear centers/charges as the potential. PCM Potential; PCMPotentialInt; Libint2; parallelized over charge points. Quadrupole; QuadrupoleInt; Libint2. Traceless Quadrupole; TracelessQuadrupoleInt; Libint2. Relativistic Potential; RelPotentialInt; Libint2. table of contents. Integrals in PSI4; Introduction; The older style; The new syntax; Sieving; Buffer address; Density Screening; Shell blocking; Permutational symmetry; Using bra-ket symmetry; Instantiating integral objects. One Electron Integrals in PSI4; Calling compute_shell(int P, int Q); Accessing integrals; Derivative Integrals; Changes to External Potential Engines; New Operators Available; Shell Pairs; One Electron Integral Algorithm Overview. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Integrals in PSI4. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/prog_integrals.html:18493,charge,charges,18493,psi4manual/1.7.x/prog_integrals.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/prog_integrals.html,2,['charge'],"['charge', 'charges']"
Energy Efficiency,"ne job or files farmed out; opt_mode = 'continuous'; if ('mode' in kwargs) and (dertype == 0):; opt_mode = kwargs['mode']. if (opt_mode.lower() == 'continuous'):; pass; elif (opt_mode.lower() == 'sow'):; pass; elif (opt_mode.lower() == 'reap'):; if('linkage' in kwargs):; opt_linkage = kwargs['linkage']; else:; raise ValidationError('Optimize execution mode \'reap\' requires a linkage option.'); else:; raise ValidationError('Optimize execution mode \'%s\' not valid.' % (opt_mode)). # Does dertype indicate an analytic procedure both exists and is wanted?; if (dertype == 1):; # Nothing to it but to do it. Gradient information is saved; # into the current reference wavefunction; procedures['gradient'][lowername](lowername, **kwargs). if 'mode' in kwargs and kwargs['mode'].lower() == 'sow':; raise ValidationError('Optimize execution mode \'sow\' not valid for analytic gradient calculation.'); PsiMod.reference_wavefunction().energy(); return PsiMod.get_variable('CURRENT ENERGY'); else:; # If not, perform finite difference of energies. opt_iter = 1; if ('opt_iter' in kwargs):; opt_iter = kwargs['opt_iter']. if opt_iter == 1:; print 'Performing finite difference calculations'. # Obtain list of displacements; displacements = PsiMod.fd_geoms_1_0(); ndisp = len(displacements). # This version is pretty dependent on the reference geometry being last (as it is now); print ' %d displacements needed ...' % (ndisp),; energies = []. # S/R: Write instructions for sow/reap procedure to output file and reap input file; if (opt_mode.lower() == 'sow'):; instructionsO = """"""\n The optimization sow/reap procedure has been selected through mode='sow'. In addition\n""""""; instructionsO += """""" to this output file (which contains no quantum chemical calculations), this job\n""""""; instructionsO += """""" has produced a number of input files (OPT-%s-*.in) for individual components\n"""""" % (str(opt_iter)); instructionsO += """""" and a single input file (OPT-master.in) with an optimize(mode='reap') command.\n",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/driver.html:23510,ENERGY,ENERGY,23510,psi4manual/4.0b2/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/driver.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"ne job or files farmed out; opt_mode = 'continuous'; if ('mode' in kwargs) and (dertype == 0):; opt_mode = kwargs['mode']. if (opt_mode.lower() == 'continuous'):; pass; elif (opt_mode.lower() == 'sow'):; pass; elif (opt_mode.lower() == 'reap'):; if('linkage' in kwargs):; opt_linkage = kwargs['linkage']; else:; raise ValidationError('Optimize execution mode \'reap\' requires a linkage option.'); else:; raise ValidationError('Optimize execution mode \'%s\' not valid.' % (opt_mode)). # Does dertype indicate an analytic procedure both exists and is wanted?; if (dertype == 1):; # Nothing to it but to do it. Gradient information is saved; # into the current reference wavefunction; procedures['gradient'][lowername](lowername, **kwargs). if 'mode' in kwargs and kwargs['mode'].lower() == 'sow':; raise ValidationError('Optimize execution mode \'sow\' not valid for analytic gradient calculation.'); PsiMod.reference_wavefunction().energy(); return PsiMod.get_variable('CURRENT ENERGY'); else:; # If not, perform finite difference of energies. opt_iter = 1; if ('opt_iter' in kwargs):; opt_iter = kwargs['opt_iter']. if opt_iter == 1:; print('Performing finite difference calculations'). # Obtain list of displacements; displacements = PsiMod.fd_geoms_1_0(); ndisp = len(displacements). # This version is pretty dependent on the reference geometry being last (as it is now); print(' %d displacements needed ...' % (ndisp), end=""""); energies = []. # S/R: Write instructions for sow/reap procedure to output file and reap input file; if (opt_mode.lower() == 'sow'):; instructionsO = """"""\n The optimization sow/reap procedure has been selected through mode='sow'. In addition\n""""""; instructionsO += """""" to this output file (which contains no quantum chemical calculations), this job\n""""""; instructionsO += """""" has produced a number of input files (OPT-%s-*.in) for individual components\n"""""" % (str(opt_iter)); instructionsO += """""" and a single input file (OPT-master.in) with an optimize(mode='reap') c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/driver.html:25979,ENERGY,ENERGY,25979,psi4manual/4.0b3/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/driver.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"ne) as opposed to the computational point group (e.g., C2v for methane). Default takes into account symmetry reduction through asymmetric isotopic substitution and is unaffected by user-set symmetry on molecule, so this option is the sole way to influence the symmetry-dependent aspects of the thermodynamic analysis. Type: integer; Default: 1. RSRFO_ALPHA_MAX (OPTKING); OPTKING — Absolute maximum value of RS-RFO. Type: double; Default: 1e8. RUN_CCSD (FNOCC); FNOCC (Expert) — do ccsd rather than qcisd?. Type: boolean; Default: false. RUN_CCTRANSORT (CCTRANSORT); CCTRANSORT — Use cctransort module NOTE: Turning this option off requires separate * installation of ccsort and transqt2 modules, see http://github.com/psi4/psi4pasture. Type: boolean; Default: true. RUN_CEPA (FNOCC); FNOCC (Expert) — Is this a CEPA job? This parameter is used internally by the pythond driver. Changing its value won’t have any effect on the procedure. Type: boolean; Default: false. RUN_MP2 (FNOCC); FNOCC (Expert) — do only evaluate mp2 energy?. Type: boolean; Default: false. RUN_MP3 (FNOCC); FNOCC (Expert) — do only evaluate mp3 energy?. Type: boolean; Default: false. RUN_MP4 (FNOCC); FNOCC (Expert) — do only evaluate mp4 energy?. Type: boolean; Default: false. S (DETCI); DETCI — The value of the spin quantum number \(S\) is given by this option. The default is determined by the value of the multiplicity. This is used for two things: (1) determining the phase of the redundant half of the CI vector when the \(M_s = 0\) component is used (i.e., MS0 = TRUE), and (2) making sure the guess vector has the desired value of \(\langle S^2\rangle\) (if CALC_S_SQUARED is TRUE and ICORE = 1). Type: double; Default: 0.0. S_ORTHOGONALIZATION (SCF); SCF — SO orthogonalization: symmetric or canonical?. Type: string; Possible Values: SYMMETRIC, CANONICAL; Default: SYMMETRIC. S_TOLERANCE (SCF); SCF — Minimum S matrix eigenvalue to be used before compensating for linear dependencies. Type: conv double; Default: ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodoc_glossary_options_c-1.html:199413,energy,energy,199413,psi4manual/1.1.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodoc_glossary_options_c-1.html,2,['energy'],['energy']
Energy Efficiency,"ne)[source]¶; Available basis-set superposition error (BSSE) treatments. cp = 'cp'¶. nocp = 'nocp'¶. vmfc = 'vmfc'¶. pydantic model psi4.driver.driver_nbody.ManyBodyComputer[source]¶. Show JSON schema{; ""title"": ""ManyBodyComputer"",; ""description"": ""Base class for \""computers\"" that plan, run, and process QC tasks."",; ""type"": ""object"",; ""properties"": {; ""molecule"": {; ""title"": ""Molecule"",; ""description"": ""The target molecule, if not the last molecule defined.""; },; ""basis"": {; ""title"": ""Basis"",; ""default"": ""(auto)"",; ""type"": ""string""; },; ""method"": {; ""title"": ""Method"",; ""default"": ""(auto)"",; ""type"": ""string""; },; ""driver"": {; ""description"": ""The computation driver; i.e., energy, gradient, hessian."",; ""allOf"": [; {; ""$ref"": ""#/definitions/DriverEnum""; }; ]; },; ""keywords"": {; ""title"": ""Keywords"",; ""description"": ""The computation keywords/options."",; ""default"": {},; ""type"": ""object""; },; ""bsse_type"": {; ""description"": ""Requested BSSE treatments. First in list determines which interaction or total energy/gradient/Hessian returned."",; ""default"": [; ""cp""; ],; ""type"": ""array"",; ""items"": {; ""$ref"": ""#/definitions/BsseEnum""; }; },; ""nfragments"": {; ""title"": ""Nfragments"",; ""description"": ""Number of distinct fragments comprising full molecular supersystem."",; ""default"": -1,; ""type"": ""integer""; },; ""max_nbody"": {; ""title"": ""Max Nbody"",; ""description"": ""Maximum number of bodies to include in the many-body treatment. Possible: max_nbody <= nfragments. Default: max_nbody = nfragments."",; ""default"": -1,; ""type"": ""integer""; },; ""nbodies_per_mc_level"": {; ""title"": ""Nbodies Per Mc Level"",; ""description"": ""Distribution of active n-body levels among model chemistry levels. All bodies in range [1, self.max_nbody] must be present exactly once. Number of items in outer list is how many different modelchems. Each inner list specifies what n-bodies to be run at the corresponding modelchem (e.g., `[[1, 2]]` has max_nbody=2 and 1-body and 2-body contributions computed at the same level of the",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/nbody.html:4861,energy,energy,4861,psi4manual/1.8.x/nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/nbody.html,1,['energy'],['energy']
Energy Efficiency,"ne-Electron Properties — oeprop(); Vibrational and Thermochemical Analysis. Interfaces: Enhancing PSI4 Capabilities; Interface to NumPy; Interface to CFOUR by J. Stanton & J. Gauss; Interface to CheMPS2 by S. Wouters; Interface to DFTD3 by S. Grimme; Interface to DKH by A. Wolf, M. Reiher, and B. A. Hess; Interface to LIBEFP by I. Kaliman; Interface to ERD by N. Flocke and V. Lotrich; Interface to programs through FCHK files — fchk(); Interface to gCP by S. Grimme; Interface to GDMA Distributed Multipole Analysis by A. J. Stone — gdma(); Interface to Libint by E. Valeev; Interface to Molden — molden(); Interface to MRCC by M. Kállay; Interface to PCMSolver by R. Di Remigio; Plugin v2rdm_casscf by A. E. DePrince; Interface to SIMINT by B. Pritchard. Psithon Functions: Invoking a Calculation; Notes on Options; Single-Point Energy — energy(); Property; Basis Set Superposition Corrections; Geometry Optimization — optimize() and gradient(); Harmonic Vibrational Analysis and Visualization of Normal Modes — frequency() and hessian(); Database — database(); Complete Basis Set; Spectroscopic Constants for Diatomics; Function Intercalls; Embarrassing Parallelism; Generation of Cube Files — cubeprop(); Orbital Visualization with VMD. Customization: Adding Simple Extensions; Defining a Method Alias; Creating a Database. Appendices; Keywords; Keywords by Alpha; Keywords by Module. Basis Sets; Basis Sets by Family; Basis Sets by Element; Auxiliary Basis Sets. PSI Variables; PSI Variables by Alpha; PSI Variables by Module. Miscellaneous; Test Suite and Sample Inputs; DFT Functionals; PSIOH Intermediate Files; Physical Constants; Bibliography. Programmers’ Manual¶. Contributions: Intro to Programming in PSI4; Plugins: Adding New Functionality to PSI4; Documentation; PsiPEP: Plans and Practices to Organize PSI4. Programming: Using the Core Libraries; LibOptions: globals, locals, has_changed and all that; Adding Methods to Driver. Managing: Git, Conda, CMake and all that; FAQ; Adding",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/index.html:2376,energy,energy,2376,psi4manual/1.1.0/index.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/index.html,1,['energy'],['energy']
Energy Efficiency,"ne-methane; 'MeMe' dissociation curve for methane dimer; 'PyPy_S2' dissociation curve for pyridine dimer, sandwich; 'PyPy_T3' dissociation curve for pyridine dimer, t-shaped; 'BzBz_PD32' dissociation curve for benzene dimer, parallel displaced by 3.2A; 'BzBz_PD36' dissociation curve for benzene dimer, parallel displaced by 3.6A. S22by5¶. Database (Hobza) of interaction energies for dissociation curves of bimolecular complexes.; Geometries and reference interaction energies from Grafova et al. JCTC 6 2365 (2010).; Note that the S22by5-N-1.0 members are essentially the same geometries as S22-N (there’s trivial round-off error) but the reference interaction energies for S22by5 are of lower quality than those of S22. cp 'off' || 'on'; rlxd 'off'; subset; 'small'; 'large'; 'equilibrium'; 'mol1' five-point (0.9, 1.0, 1.2, 1.5, 2.0) dissociation curve for molecule 1; ...; 'mol22' five-point (0.9, 1.0, 1.2, 1.5, 2.0) dissociation curve for molecule 22. BENCH12¶. Database of <description of members and reference energy type>.; Geometries from <Reference>.; Reference interaction energies from <Reference>. benchmark; '<benchmark_name>' <Reference>.; '<default_benchmark_name>' <Reference>. subset; 'small'; 'large'; 'alkenes'; 'alkanes'; 'acenes'; 'thiophenes'; 'h2o_size'; 'h2o_shape'; 'atoms'; 'S22_HB'; 'S22_MX'; 'S22_DD'. BAKERJCC93¶. Database of molecules that are challenging to optimize.; Geometries from Baker J. Comput. Chem. 14 1085 (1993), as reported; in Bakken and Helgaker, J. Chem. Phys. 117, 9160 (2002), with a few; further corrections.; No reference energies defined. cp 'off'; rlxd 'off'; subset; 'small'; 'large'. RGC10¶. Database (Sherrill) of interaction energies for dissociation curves of rare-gas biatomic complexes.; Geometries and reference interaction energies from Tang et al. JCP 118 4976 (2003). cp 'off' || 'on'; rlxd 'off'; subset; 'small'; 'large'; 'equilibrium'; 'HeHe' 18-point dissociation curve for helium dimer; 'HeNe' 18-point dissociation curve for hel",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_available_databases-1.html:2823,energy,energy,2823,psi4manual/4.0b3/autodoc_available_databases-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_available_databases-1.html,4,['energy'],['energy']
Energy Efficiency,"ne-methane; 'MeMe' dissociation curve for methane dimer; 'PyPy_S2' dissociation curve for pyridine dimer, sandwich; 'PyPy_T3' dissociation curve for pyridine dimer, t-shaped; 'BzBz_PD32' dissociation curve for benzene dimer, parallel displaced by 3.2A; 'BzBz_PD36' dissociation curve for benzene dimer, parallel displaced by 3.6A. S22by5¶. Database (Hobza) of interaction energies for dissociation curves of bimolecular complexes.; Geometries and reference interaction energies from Grafova et al. JCTC 6 2365 (2010).; Note that the S22by5-N-1.0 members are essentially the same geometries as S22-N (there’s trivial round-off error) but the reference interaction energies for S22by5 are of lower quality than those of S22. cp 'off' || 'on'; rlxd 'off'; subset; 'small'; 'large'; 'equilibrium'; 'mol1' five-point (0.9, 1.0, 1.2, 1.5, 2.0) dissociation curve for molecule 1; ...; 'mol22' five-point (0.9, 1.0, 1.2, 1.5, 2.0) dissociation curve for molecule 22. BENCH12¶. Database of <description of members and reference energy type>.; Geometries from <Reference>.; Reference interaction energies from <Reference>. benchmark; '<benchmark_name>' <Reference>.; '<default_benchmark_name>' <Reference>. subset; 'small'; 'large'; 'alkenes'; 'alkanes'; 'acenes'; 'thiophenes'; 'h2o_size'; 'h2o_shape'; 'atoms'; 'S22_HB'; 'S22_MX'; 'S22_DD'. RSE42¶. Database of radical stabilization energies.; Geometries from [E. Soydas and U. Bozkaya, JCTC, 9, 1452-1460 (2013)].; Reference radical stabilization energies from [E. Soydas and U. Bozkaya, JCTC, 9, 1452-1460 (2013)] at CCSD(T)/cc-pCVTZ level. benchmark; 'RSE42' [E. Soydas and U. Bozkaya, JCTC, 9, 1452-1460 (2013)].; 'RSE42' [E. Soydas and U. Bozkaya, JCTC, 9, 1452-1460 (2013)]. subset; 'small' <members_description>; 'large' <members_description>; 'RSE30' smaller systems in RSE42; '<subset>' <members_description>. BAKERJCC93¶. Database of molecules that are challenging to optimize.; Geometries from Baker J. Comput. Chem. 14 1085 (1993), as reported; i",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodoc_available_databases-1.html:2823,energy,energy,2823,psi4manual/4.0b4/autodoc_available_databases-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodoc_available_databases-1.html,4,['energy'],['energy']
Energy Efficiency,"ne.update_geometry(). >>> E, G = nene.run_gcp('hf3c'). >>> E, G = nene.run_gcp(func='HF3c', verbose=True). qcdb.Molecule.run_gcp(self, func=None, dertype=None, verbose=1)¶; Compute geometrical BSSE correction via Grimme’s GCP program.; Function to call Grimme’s GCP program; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp; to compute an a posteriori geometrical BSSE correction to self for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, func. Returns energy if dertype is 0, gradient; if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The gcp executable must be independently compiled and; found in PATH or PSIPATH. self may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended by this method py-side and only public interface; fns used) or a string that can be instantiated into a qcdb.Molecule. Parameters:. func (Optional[str]) – Name of method/basis combination or composite method for which to compute the correction; (e.g., HF/cc-pVDZ, DFT/def2-SVP, HF3c, PBEh3c).; dertype (Union[int, str, None]) – Maximum derivative level at which to run GCP. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int) – Amount of printing. Unused at present. Returns:. energy (float) – When dertype=0, energy [Eh].; gradient (ndarray) – When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ndarray) – When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. table of contents. Interface to gCP by S. Grimme; Installation; Running gCP; run_gcp(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to gCP by S. Grimme. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/gcp.html:4974,energy,energy-only,4974,psi4manual/master/gcp.html,https://psicode.org,https://psicode.org/psi4manual/master/gcp.html,6,"['efficient', 'energy']","['efficient', 'energy', 'energy-only']"
Energy Efficiency,"ne:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_fnoccsd_t_(name, **kwargs):; """"""Function selecting the algorithm for a FNO-CCSD(T) energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in ['', 'FNOCC']:; func = run_fnocc; elif mtd_type == 'DF':; if module in ['', 'FNOCC']:; func = run_fnodfcc; elif mtd_type == 'CD':; if module in ['', 'FNOCC']:; func = run_fnodfcc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_ccsd_t_(name, **kwargs):; """"""Function selecting the algorithm for a CCSD(T) energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'FNOCC':; func = run_fnocc; elif module == 'MRCC' and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif module in ['', 'CCENERGY']:; func = run_ccenergy; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'FNOCC']:; func = run_fnodfcc; elif mtd_type == 'CD':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'FNOCC']:; func = run_fnodfcc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module == 'MRCC' and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif module in ['', 'CCENERGY']:; func = run_ccenergy; elif mtd_type in [""DF"", ""CD""]:; if module in [""OCC""]: # SOON """",; func = run_dfocc; elif reference == 'ROHF':; if mtd_ty",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:25578,energy,energy,25578,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,8,['energy'],['energy']
Energy Efficiency,"ne; Prints the molecule in Cartesians in Bohr. print_out_of_planes(self: psi4.core.Molecule) → None; Print the out-of-plane angle geometrical parameters. reinterpret_coordentry(self: psi4.core.Molecule, arg0: bool) → None; Do reinterpret coordinate entries during update_geometry(). reset_point_group(self: psi4.core.Molecule, arg0: str) → None; Overrides symmetry from outside the molecule string. rotational_constants(self: psi4.core.Molecule, arg0: float) → psi4.core.Vector; Prints the rotational constants of the molecule. run_dftd3(func=None, dashlvl=None, dashparam=None, dertype=None, verbose=False); Function to call Grimme’s dftd3 program (http://toc.uni-muenster.de/DFTD3/); to compute the -D correction of level dashlvl using parameters for; the functional func. The dictionary dashparam can be used to supply; a full set of dispersion parameters in the absense of func or to supply; individual overrides in the presence of func. Returns energy if dertype is 0,; gradient if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The dftd3 executable must be independently compiled and found in; PATH or PSIPATH.; self may be either a qcdb.Molecule (sensibly) or a psi4.Molecule; (works b/c psi4.Molecule has been extended by this method py-side and; only public interface fns used) or a string that can be instantiated; into a qcdb.Molecule.; func - functional alias or None; dashlvl - functional type d2gr/d3zero/d3bj/d3mzero/d3mbj; dashparam - dictionary; dertype = derivative level. run_gcp(func=None, dertype=None, verbose=False); Function to call Grimme’s dftd3 program (http://toc.uni-muenster.de/DFTD3/); to compute the -D correction of level dashlvl using parameters for; the functional func. The dictionary dashparam can be used to supply; a full set of dispersion parameters in the absense of func or to supply; individual overrides in the presence of func. Returns energy if dertype is 0,; gradient if dertype is 1, else tuple of energy and gradient if derty",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html:28257,energy,energy,28257,psi4manual/1.1.0/api/psi4.core.molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html,2,['energy'],['energy']
Energy Efficiency,"ne; external_indices = []; if 'external' in kwargs:; external = kwargs['external']; external_indices = [molecule.nfragments()]; if 'external_monomers' in kwargs:; external_indices = kwargs['external_monomers']. # Check input args; if not bsse == 'off' and not bsse == 'on' and not bsse == 'both':; raise ValidationError('n_body: bsse argument is one of on, off, or both'); if max_n_body < 1:; raise ValidationError('n_body: max_n_body must be at least 1'); if max_n_body > molecule.nfragments():; raise ValidationError('n_body: max_n_body must be <= to the number of fragments in the molecule'). # Set to save RI integrals for repeated full-basis computations; ri_ints_io = PsiMod.get_option('DF_INTS_IO'); PsiMod.set_global_option('DF_INTS_IO', 'SAVE'); psioh = PsiMod.IOManager.shared_object(); psioh.set_specific_retention(97, True). # Tell 'em what you're gonna tell 'em; has_external = 'No'; if (external):; has_external = 'Yes'; PsiMod.print_out('\n'); PsiMod.print_out(' ==> N-Body Interaction Energy Analysis <==\n\n'); PsiMod.print_out(' BSSE Treatment: %s\n' % (bsse)); PsiMod.print_out(' Maximum N-Body Interactions: %d\n' % (max_n_body)); PsiMod.print_out(' Compute Total Energy: %s\n' % (do_total)); PsiMod.print_out(' External Field: %s\n' % (has_external)); if (external):; PsiMod.print_out(' External Field Monomers: '); for k in external_indices:; PsiMod.print_out('%-3d ' % (k)); PsiMod.print_out('\n'); PsiMod.print_out('\n'). # Run the total molecule, if required; energies_full = {}; energies_mon = {}; N = molecule.nfragments(); Etotal = 0.0; if do_total or max_n_body == molecule.nfragments():; PsiMod.print_out(' => Total Cluster Energy <=\n'); # Full cluster always gets the external field; if (external):; PsiMod.set_global_option_python(""EXTERN"", external); Etotal = call_function_in_1st_argument(func, **kwargs); if (external):; PsiMod.set_global_option_python(""EXTERN"", None); energies_full[N] = []; energies_full[N].append(Etotal); energies_mon[N] = []; energies_mon[N].a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:6138,Energy,Energy,6138,psi4manual/4.0b2/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html,1,['Energy'],['Energy']
Energy Efficiency,"near dependencies. props4; Electrostatic potential and electric field evaluated on a grid around water. scf-ecp; Water-Argon complex with ECP present; check of energies and forces. cc9; UHF-CCSD(T) cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Z-matrix input. gibbs; Test Gibbs free energies at 298 K of N2, H2O, and CH4. scf-guess-read2; Test if the the guess read in the same basis converges. nbody-he-cluster; MP2/aug-cc-pv[DT]Z many body energies of an arbitrary Helium complex Size vs cost tradeoff is rough here. omp2-grad1; OMP2 cc-pVDZ gradient for the H2O molecule. dfomp2-3; OMP2 cc-pVDZ energy for the H2O molecule. dfcasscf-sa-sp; Example of state-averaged CASSCF for the C2 molecule. dfmp2-fc; Kr–Kr nocp energies with all-electron basis set to check frozen core. dft-grad-lr3; wB97X-D test for a large UKS molecule update ref gradient due to new BraggSlater radii. fcidump; test FCIDUMP functionality for rhf/uhf. dfomp2p5-2; DF-OMP2.5 cc-pVDZ energy for the H2O+ cation. sapt4; SAPT2+(3) aug-cc-pVDZ computation of the formamide dimer interaction energy, using the aug-cc-pVDZ-JKFIT DF basis for SCF and aug-cc-pVDZ-RI for SAPT. This example uses frozen core as well as MP2 natural orbital approximations. omp3-3; OMP3 cc-pCVDZ energy with B3LYP initial guess for the NO radical. olccd2; OLCCD cc-pVDZ energy with B3LYP initial guess for the NO radical. nbody-convergence; Convergence of many-body gradients of different BSSE schemes. sapt-dft-api; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. cc46; EOM-CC2/cc-pVDZ on H2O2 with two excited states in each irrep. pubchem1; Benzene vertical singlet-triplet energy difference computation, using the PubChem database to obtain the initial geometry, which is optimized at the HF/STO-3G level, before computing single point energies at the RHF, UHF and ROHF levels of theory. cc13a; UHF-CCSD(T)/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. sad1; Test of the sup",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html:45969,energy,energy,45969,psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"nect=connect,; addcart=addcart,; constraints=Cons,; cvals=CVals[0] if CVals is not None else None); ; # Get initial coordinates in bohr; coords = M.xyzs[0].flatten() / qcel.constants.bohr2angstroms. # Setup an optimizer object; params = geometric.optimize.OptParams(**optimizer_keywords); optimizer = geometric.optimize.Optimizer(coords, M, IC, engine, None, params); ; # TODO: print constraints; # IC.printConstraints(coords, thre=-1); optimizer.calcEnergyForce(); optimizer.prepareFirstStep(); grms, gmax = optimizer.calcGradNorm(); conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; core.print_out(""\n Measures of convergence in internal coordinates in au. ~""); core.print_out(""\n Criteria marked as inactive (o), active & met (*), and active & unmet ( ). ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out(""\n Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out((f""\n Convergence Criteria {params.Convergence_energy:10.2e} ""; f""{params.Convergence_gmax:10.2e} {params.Convergence_grms:10.2e} ""; f""{params.Convergence_dmax:10.2e} {params.Convergence_drms:10.2e} ~"")); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""). core.print_out((f""\n {optimizer.Iteration:4d} {optimizer.E:16.8e} -------- ""; f""{gmax:10.2e} {conv_gmax} {grms:10.2e} {conv_grms} -------- -------- ~"")); while True:; if optimizer.state == geometric.optimize.OPT_STATE.CONVERGED:; core.print_out(""\n\n Optimization converged! ~\n""); break; elif optimizer.state == geometric.optimize.OPT_STATE.FAILED:; core.print_out(""\n\n Optimization failed to converge! ~\n""); break; optimizer.step(); optimizer.calcEnergyForce(); optimizer.evaluateStep(); grms, gmax = ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:56518,Energy,Energy,56518,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,5,['Energy'],['Energy']
Energy Efficiency,"nectivity(self: psi4.core.Molecule, arg0: List[Tuple[int, int, float]]) → None; Sets molecule connectivity. set_full_geometry(self: psi4.core.Molecule, arg0: psi4.core.Matrix) → None; Sets the geometry, given a (Natom X 3) matrix arg0 of coordinates (in Bohr) (including dummies. set_geometry(self: psi4.core.Molecule, arg0: psi4.core.Matrix) → None; Sets the geometry, given a (Natom X 3) matrix arg0 of coordinates [a0] (excluding dummies). set_ghost_fragment(self: psi4.core.Molecule, arg0: int) → None; Sets the specified fragment arg0 to be Ghost. set_ghost_fragments(self: psi4.core.Molecule, arg0: List[int]) → None; Sets the specified list arg0 of fragments to be Ghost. set_input_units_to_au(self: psi4.core.Molecule, arg0: float) → None; Sets unit conversion to [a0] for geometry. set_mass(self: psi4.core.Molecule, atom: int, mass: float) → None; Sets mass of atom (0-indexed) to mass (good for isotopic substitutions). set_molecular_charge(self: psi4.core.Molecule, arg0: int) → None; Change the overall molecular charge. Setting in initial molecule string or constructor preferred. set_multiplicity(self: psi4.core.Molecule, arg0: int) → None; Change the multiplicity (defined as 2S + 1). Setting in initial molecule string or constructor preferred. set_name(self: psi4.core.Molecule, arg0: str) → None; Sets molecule name. set_nuclear_charge(self: psi4.core.Molecule, arg0: int, arg1: float) → None; Set the nuclear charge of the given atom arg0 to the value arg1 (primarily for ECP). set_point_group(self: psi4.core.Molecule, arg0: psi4.core.PointGroup) → None; Sets the molecular point group to the point group object arg0. set_provenance(self: psi4.core.Molecule, arg0: Dict[str, str]) → None; Sets molecule provenance. set_units(self: psi4.core.Molecule, arg0: psi4.core.GeometryUnits) → None; Sets units (Angstrom or Bohr) used to define the geometry. Imposes Psi4 physical constants conversion for input_units_to_au. set_variable(self: psi4.core.Molecule, arg0: str, arg1: float) →",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.molecule.html:58853,charge,charge,58853,psi4manual/1.3.2/api/psi4.core.molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.molecule.html,1,['charge'],['charge']
Energy Efficiency,"ned. delta2_wfn (string) – 'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. delta2_wfn_lesser (string) – delta_wfn || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. delta3_wfn (string) – 'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a third delta correction; to the correlation energy is to be obtained. delta3_wfn_lesser (string) – delta2_wfn || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a third delta correction; to the correlation energy is to be obtained. delta4_wfn (string) – 'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a fourth delta correction; to the correlation energy is to be obtained. delta4_wfn_lesser (string) – delta3_wfn || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a fourth delta correction; to the correlation energy is to be obtained. delta5_wfn (string) – 'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a fifth delta correction; to the correlation energy is to be obtained. delta5_wfn_lesser (string) – delta4_wfn || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a fifth delta correction; to the correlation energy is to be obtained. Basis Sets; Currently, the basis set set through set commands have no influence; on a cbs calculation. Parameters:; scf_basis (basis string) – corl_basis || 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, scf_basis can default; to corl_basis. corl_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the correlation energy. delta_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/cbs-1.html:4889,energy,energy,4889,psi4manual/1.0.0/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/cbs-1.html,4,['energy'],['energy']
Energy Efficiency,"need to be replaced by the text blankline. Functionality¶; Through clever use of the cfour {...} block, one could run most any; Cfour computation through the P4C4 interface. In contrast, enumerated; below are tested functionalities where results from Cfour are collected; into PSI4 data objects.; Implemented. Single-point energy() commands for ground state; methods. Examples:; cfour/sp-rhf-ccsd_t_-ao-ecc, cfour/scf4,; cfour/mints5.; Analytic gradient() and optimize(); commands for ground state methods. Real and; Ghost atoms permitted (though the latter will naturally collapse after; several cycles). Examples: cfour/opt-rhf-ccsd_t_,; cfour/mp2-1, and cfour/mints5-grad. Warning; There exist molecules (e.g., allene) where the; inertial frame is not unique (planes along atoms or between; atoms). The orientation reconciling machinery currently does not; handle these cases and will fail with “Axis unreconcilable between; QC programs”. I will get to this soon. Finite difference of energy gradient() and; optimize() for methods.; Force with gradient('name', dertype=0), etc..; nbody() for computation of interaction energies with or; without counterpoise correction. Example: cfour/dfmp2-1.; database() for computation of a collection of molecules in a; single input, with summarization of results. Examples:; cfour/pywrap-db1 and cfour/psi-a24-grad.; cbs() for computation of compound methods involving; basis set extrapolations and/or delta corrections with any combination; of PSI4 and Cfour computational methods and PSI4 basis sets.; Example: cfour/pywrap-cbs1. Not Yet Implemented. Ground state CI energies and optimizations; Excited state energies and optimizations; Properties are not yet regex-ed, transformed into input frame, and; stowed in PSI Variables.; Property calls that required extra computation not yet translated into; properties() computation command; Frequencies. Energy methods available through P4C4 interface. name; calls method in Stanton and Gauss’s CFOUR program [m",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/cfour.html:26349,energy,energy,26349,psi4manual/1.7.x/cfour.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/cfour.html,4,['energy'],['energy']
Energy Efficiency,"need to be replaced by the text blankline. Functionality¶; Through clever use of the cfour {...} block, one could run most any; Cfour computation through the P4C4 interface. In contrast, enumerated; below are tested functionalities where results from Cfour are collected; into PSI4 data objects.; Implemented. Single-point energy() commands for ground state; methods. Examples:; cfour/sp-rhf-ccsd_t_-ao-ecc, cfour/scf4,; cfour/mints5.; Analytic gradient() and optimize(); commands for ground state methods. Real and; Ghost atoms permitted (though the latter will naturally collapse after; several cycles). Examples: cfour/opt-rhf-ccsd_t_,; cfour/mp2-1, and cfour/mints5-grad. Warning; There exist molecules (e.g., allene) where the; inertial frame is not unique (planes along atoms or between; atoms). The orientation reconciling machinery currently does not; handle these cases and will fail with “Axis unreconcilable between; QC programs”. I will get to this soon. Finite difference of energy gradient() and; optimize() for methods.; Force with gradient('name', dertype=0), etc..; nbody_gufunc() for computation of interaction energies with or; without counterpoise correction. Example: cfour/dfmp2-1.; database() for computation of a collection of molecules in a; single input, with summarization of results. Examples:; cfour/pywrap-db1 and cfour/psi-a24-grad.; cbs() for computation of compound methods involving; basis set extrapolations and/or delta corrections with any combination; of PSI4 and Cfour computational methods and PSI4 basis sets.; Example: cfour/pywrap-cbs1. Not Yet Implemented. Ground state CI energies and optimizations; Excited state energies and optimizations; Properties are not yet regex-ed, transformed into input frame, and; stowed in PSI Variables.; Property calls that required extra computation not yet translated into; properties() computation command; Frequencies. Energy methods available through P4C4 interface. name; calls method in Stanton and Gauss’s CFOUR pro",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/cfour-1.html:26226,energy,energy,26226,psi4manual/1.4.0/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/cfour-1.html,5,['energy'],['energy']
Energy Efficiency,"need to be replaced by the text blankline. Functionality¶; Through clever use of the cfour {...} block, one could run most any; Cfour computation through the P4C4 interface. In contrast, enumerated; below are tested functionalities where results from Cfour are collected; into Psi4 data objects.; Implemented. Single-point energy() commands for ground state; methods. Examples:; cfour/sp-rhf-ccsd_t_-ao-ecc, cfour/scf4,; cfour/mints5.; Analytic gradient() and optimize(); commands for ground state methods. Real and; Ghost atoms permitted (though the latter will naturally collapse after; several cycles). Examples: cfour/opt-rhf-ccsd_t_,; cfour/mp2-1, and cfour/mints5-grad. Warning; There exist molecules (e.g., allene) where the; inertial frame is not unique (planes along atoms or between; atoms). The orientation reconciling machinery currently does not; handle these cases and will fail with “Axis unreconcilable between; QC programs”. I will get to this soon. Finite difference of energy gradient() and; optimize() for methods.; Force with gradient('name', dertype=0), etc..; _nbody_gufunc() for computation of interaction energies with or; without counterpoise correction. Example: cfour/dfmp2-1.; database() for computation of a collection of molecules in a; single input, with summarization of results. Examples:; cfour/pywrap-db1 and cfour/psi-a24-grad.; complete_basis_set() for computation of compound methods involving; basis set extrapolations and/or delta corrections with any combination; of Psi4 and Cfour computational methods and Psi4 basis sets.; Example: cfour/pywrap-cbs1. Not Yet Implemented. Ground state CI energies and optimizations; Excited state energies and optimizations; Properties are not yet regex-ed, transformed into input frame, and; stowed in PSI Variables.; Property calls that required extra computation not yet translated into; property() computation command; Frequencies. Energy methods available through P4C4 interface. name; calls method in Stanton and Gau",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/cfour-1.html:26237,energy,energy,26237,psi4manual/1.0.0/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/cfour-1.html,2,['energy'],['energy']
Energy Efficiency,"negligible one-electron integrals.; COSX_DENSITY_TOLERANCE controls the threshold for significant; shell pairs in the density matrix. Lastly, COSX_BASIS_TOLERANCE is; a cutoff for the value of basis functions at grid points. This keyword is; used to determine the radial extent of the each basis shell, and it is the; COSX analogue to DFT_BASIS_TOLERANCE.; The COSX_INCFOCK keyword (defaults to true) increases performance; by constructing the Fock matrix from differences in the density matrix, which; are more amenable to screening. Consider disabling this keyword if SCF energy; convergence issues are observed, particularly when using diffuse basis functions.; The COSX_OVERLAP_FITTING keyword (defaults to true) reduces numerical; integration errors using the method described in [Izsak:2011:144105] and is; always recommended. LinK Exchange¶. Warning; The LinK code is currently under development and should not be used. Large SCF calculations can benefit from specialized screening procedures that further reduce the scaling of the ERI contribution to the Fock matrix.; LinK, the linear-scaling exchange method described in [Ochsenfeld:1998:1663], is available with the direct SCF algorithm (SCF_TYPE set to DIRECT).; LinK achieves linear-scaling by exploiting shell pair sparsity in the density matrix and overlap sparsity between shell pairs.; This method is most competitive when used with non-diffuse orbital basis sets, since orbital and density overlaps decay slower with diffuse functions.; LinK is especially powerful when combined with density-matrix based ERI screening (set SCREENING to DENSITY) and incremental Fock builds (set INCFOCK to TRUE), which decrease the number of significant two-electron integrals to calculate.; NOTE: Turning on LinK is currently only recommended for research and development purposes, and not for performance,; since a fast J matrix build compatible to use with LinK has not been developed yet.; To turn on and control the LinK algorithm, here are the",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/scf.html:32779,reduce,reduce,32779,psi4manual/1.6.x/scf.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/scf.html,1,['reduce'],['reduce']
Energy Efficiency,nent [E_h]; for the orbital-optimized MP3 level of theory. OMP3 REFERENCE CORRECTION ENERGY¶; The difference [E_h] between the single-determinant energy of the final and; initial orbitals for the orbital-optimized MP3 level of theory. OREMP2 TOTAL ENERGY¶. OREMP2 CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the orbital-optimized retaining-the-excitation-degree Møller–Plesset; hybrid perturbation theory level. OREMP2 REFERENCE CORRECTION ENERGY¶; The difference [E_h] between the single-determinant energy of the final and; initial orbitals for the orbital-optimized retaining-the-excitation-degree; Møller–Plesset hybrid perturbation theory level. ONE-ELECTRON ENERGY¶; The one-electron energy contribution [E_h] to the total SCF energy.; Quantity \(E_{1e^-}\) in Eq. (4). PCM POLARIZATION ENERGY¶; The energy contribution [E_h] from the polarizable continuum model for solvation. DD SOLVATION ENERGY¶; The energy contribution [Eh] from continuum solvation models based on a; domain-decomposition ansatz. PE ENERGY¶; The energy contribution [E_h] from the polarizable embedding model for solvation. QCISD TOTAL ENERGY¶. QCISD CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the quadratic configuration interaction singles and doubles level; of theory. QCISD(T) TOTAL ENERGY¶. QCISD(T) CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the quadratic configuration interaction singles and doubles with; perturbative triples correction level of theory. QCISD(T) CORRECTION ENERGY¶; The quadratic configuration interaction singles and doubles perturbative; triples correction [E_h]. REMP2 TOTAL ENERGY¶. REMP2 CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the retaining-the-excitation-degree Møller–Plesset hybrid perturbation; theory level. SAPT DISP ENERGY¶. SAPT ELST ENERGY¶. SAPT EXCH ENE,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html:44231,energy,energy,44231,psi4manual/1.7.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html,4,['energy'],['energy']
Energy Efficiency,"nently a dummy function; pass. [docs]; def plan(self):; # uncalled function; return [t.plan() for t in self.task_list.values()]. [docs]; def compute(self, client: Optional[""qcportal.FractalClient""] = None):; """"""Run each job in task list.""""""; instructions = ""\n"" + p4util.banner(f"" FiniteDifference Computations"", strNotOutfile=True) + ""\n""; logger.debug(instructions); core.print_out(instructions). with p4util.hold_options_state():; for t in self.task_list.values():; t.compute(client=client). def _prepare_results(self, client: Optional[""qcportal.FractalClient""] = None):; results_list = {k: v.get_results(client=client) for k, v in self.task_list.items()}. # load AtomicComputer results into findifrec[reference]; reference = self.findifrec[""reference""]; task = results_list[""reference""]; response = task.return_result; reference[""module""] = getattr(task.provenance, ""module"", None). if task.driver == 'energy':; reference['energy'] = response. elif task.driver == 'gradient':; reference['gradient'] = response; reference['energy'] = task.extras['qcvars']['CURRENT ENERGY']. elif task.driver == 'hessian':; reference['hessian'] = response; reference['energy'] = task.extras['qcvars']['CURRENT ENERGY']; if 'CURRENT GRADIENT' in task.extras['qcvars']:; reference['gradient'] = task.extras['qcvars']['CURRENT GRADIENT']. dipole_available = False; if 'CURRENT DIPOLE' in task.extras['qcvars']:; reference['dipole'] = task.extras['qcvars']['CURRENT DIPOLE']; dipole_available = True. # load AtomicComputer results into findifrec[displacements]; for label, displacement in self.findifrec[""displacements""].items():; task = results_list[label]; response = task.return_result. if task.driver == 'energy':; displacement['energy'] = response. elif task.driver == 'gradient':; displacement['gradient'] = response; displacement['energy'] = task.extras['qcvars']['CURRENT ENERGY']. elif task.driver == 'hessian':; displacement['hessian'] = response; displacement['energy'] = task.extras['qcvars']['CURRENT ENER",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html:47218,energy,energy,47218,psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,6,['energy'],['energy']
Energy Efficiency,"nents required for given N-body procedure.; ``'ptype'``: dict of set: float64 or dict of set: psi4.Matrix; Dictionary of returned quantities from calls of function `func` during N-body computations; ``'intermediates'``: dict of str: float64; Dictionary of psivars for intermediate N-body computations to be set at the end of the; N-body procedure.; Returns; -------; results : dict of str; Dictionary of all N-body results. Contents:; ``'ret_energy'``: float64; Interaction data requested. If multiple BSSE types requested in `bsse_type_list`, the; interaction data associated with the *first* BSSE type in the list is returned.; ``'nbody_dict'``: dict of str: float64; Dictionary of relevant N-body psivars to be set; ``'energy_body_dict'``: dict of int: float64; Dictionary of total energies at each N-body level, i.e., ``results['energy_body_dict'][2]`` ; is the sum of all 2-body total energies for the supersystem.; ``'ptype_body_dict'``: dict or dict of int: array_like; Empty dictionary if `ptype is ``'energy'``, or dictionary of total ptype arrays at each; N-body level; i.e., ``results['ptype_body_dict'][2]`` for `ptype` ``'gradient'``is the ; total 2-body gradient.; """"""; # Unpack metadata; kwargs = metadata['kwargs']. nbody_range = range(1, metadata['max_nbody'] + 1). # Unpack compute list metadata; compute_list = metadata['compute_dict']['all']; cp_compute_list = metadata['compute_dict']['cp']; nocp_compute_list = metadata['compute_dict']['nocp']; vmfc_compute_list = metadata['compute_dict']['vmfc_compute']; vmfc_level_list = metadata['compute_dict']['vmfc_levels']. # Build size and slices dictionaries; fragment_size_dict = {; frag: metadata['molecule'].extract_subsets(frag).natom(); for frag in range(1, metadata['max_frag'] + 1); }; start = 0; fragment_slice_dict = {}; for k, v in fragment_size_dict.items():; fragment_slice_dict[k] = slice(start, start + v); start += v. molecule_total_atoms = sum(fragment_size_dict.values()). # Final dictionaries; cp_energy_by_level = {n",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_nbody.html:20070,energy,energy,20070,psi4manual/1.3.2/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_nbody.html,1,['energy'],['energy']
Energy Efficiency,"nents required for given N-body procedure.; ``'ptype'``: dict of set: float64 or dict of set: psi4.Matrix; Dictionary of returned quantities from calls of function `func` during N-body computations; ``'intermediates'``: dict of str: float64; Dictionary of psivars for intermediate N-body computations to be set at the end of the; N-body procedure.; Returns; -------; results : dict of str; Dictionary of all N-body results. Contents:; ``'ret_energy'``: float64; Interaction data requested. If multiple BSSE types requested in `bsse_type_list`, the; interaction data associated with the *first* BSSE type in the list is returned.; ``'nbody_dict'``: dict of str: float64; Dictionary of relevant N-body psivars to be set; ``'energy_body_dict'``: dict of int: float64; Dictionary of total energies at each N-body level, i.e., ``results['energy_body_dict'][2]`` ; is the sum of all 2-body total energies for the supersystem.; ``'ptype_body_dict'``: dict or dict of int: array_like; Empty dictionary if `ptype is ``'energy'``, or dictionary of total ptype arrays at each; N-body level; i.e., ``results['ptype_body_dict'][2]`` for `ptype` ``'gradient'``is the ; total 2-body gradient.; """"""; # Unpack metadata; kwargs = metadata['kwargs']. nbody_range = range(1, metadata['max_nbody'] + 1). # Unpack compute list metadata; compute_list = metadata['compute_dict']['all']; cp_compute_list = metadata['compute_dict']['cp']; nocp_compute_list = metadata['compute_dict']['nocp']; vmfc_compute_list = metadata['compute_dict']['vmfc_compute']; vmfc_level_list = metadata['compute_dict']['vmfc_levels']. # Build size and slices dictionaries; fragment_size_dict = {frag: metadata['molecule'].extract_subsets(frag).natom() for; frag in range(1, metadata['max_frag']+1)}; start = 0; fragment_slice_dict = {}; for k, v in fragment_size_dict.items():; fragment_slice_dict[k] = slice(start, start + v); start += v. molecule_total_atoms = sum(fragment_size_dict.values()). # Final dictionaries; cp_energy_by_level = {n: 0.0 ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver_nbody.html:17872,energy,energy,17872,psi4manual/1.2.1/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver_nbody.html,1,['energy'],['energy']
Energy Efficiency,"neral GPL dependencies. Capabilities¶; PSI4 can perform ab initio computations employing basis; sets of contracted Gaussian-type functions of virtually arbitrary; orbital quantum number. Many parts of PSI4 can recognize and; exploit the largest Abelian subgroup of the molecular point group.; Table Methods displays the range of theoretical methods; available in PSI4.; Geometry optimization can be performed using either analytic gradients; or energy points. Likewise, vibrational frequencies can be; computed by analytic second derivatives, by finite; differences of analytic gradients, or by finite differences of energies.; PSI4 can also compute an extensive list of one-electron properties.; For more tables with capabilities details:. Full Capabilities (first below) lists all methods; Capabilities Breakdown (second below) lists selected methods by reference, etc.; Module Capabilities lists selected methods by implementation; Energy, Energy (DFT), Energy (MRCC), Energy (CFOUR) fully list energy target methods; Gradient, Gradient (CFOUR) fully list gradient target methods; Frequency fully lists Hessian target methods. Summary of theoretical methods available in PSI4¶. Method [1]; Reference[2]; Type[2]; Variants[3]. Canonical; OO; FNO [4]; DLPNO. HF; RHF/UHF/ROHF/CUHF; CONV/DF/CD; E/G/H. DFT; RKS/UKS; CONV/DF/CD; E/G. DFT-D2, DFT-NL; RKS/UKS; CONV/DF/CD; E/G. DCT; RHF/UHF; CONV/DF; E/G. MP2; RHF/UHF/ROHF; CONV/DF/CD; E/G; E/G. E. MP3; RHF/UHF; CONV/DF/CD; E/G; E/G; E. MP2.5; RHF/UHF; CONV/DF/CD; E/G; E/G. MP4, MP4(SDQ); RHF; CONV; E. E. MPn; RHF; CONV; E. ZAPTn; ROHF; CONV; E. REMP2; RHF/UHF; CONV/DF/CD; E; E/G. LCCD; RHF/UHF; CONV/DF/CD; E/G; E/G; E. LCCSD, CEPA(0); RHF; CONV; E. E. CEPA(n), n=0,1,3; RHF; CONV; E. E. CCD; RHF; DF/CD; E/G. BCCD; RHF/UHF/ROHF; CONV; E. CC2; RHF/UHF/ROHF; CONV; E/G. CCSD; RHF/UHF/ROHF; CONV/DF/CD; E/G. E [5]. CCSD(T); RHF/UHF/ROHF; CONV/DF/CD; E/G. E [5]. A-CCSD(T); RHF; CONV/DF/CD; E. BCCD(T); RHF/UHF/ROHF; CONV; E. CC3; RHF/UHF/ROHF; CONV;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/introduction.html:24301,energy,energy,24301,psi4manual/1.8.x/introduction.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/introduction.html,3,['energy'],['energy']
Energy Efficiency,"nerally prefer the latter, but both generally give qualitatively identical; energetic partitions.; Users should check the files fragA.dat and fragB.dat to ensure that; there is not too much charge delocalization from one fragment to another. This; is presented in the “Orbital Check” section in these files – a value larger than; 0.1 docc is an indication that the picture of localizable functional groups may; be breaking down. We also strongly discourage the cutting of double,; triple, or aromatic bonding motifs when partitioning the molecule into fragments; – cuts across only simple sigma bonds are encouraged. Caution; November 2022, previous to QCEngine v0.26.0 and Psi4; v1.7.0, there was a scaling inconsistency in the pairwise analysis; such that 2-BODY PAIRWISE DISPERSION CORRECTION ANALYSIS; was doubled when generated from dftd3 compared to the output from other; programs (s-dftd3 and dftd4). This shows up in the QCVariable and in the; Empirical_Disp.dat file written during energy(""fisapt0-d3"") (all; -D3 variants). Fortunately, the fsapt.py script compensated; for dftd3 (by far the most used program for this task). Users of the; pairwise analysis should take care to use the new QCEngine; AND fsapt.py script distributed with NEW Psi4. fisapt0-d4 run; with previous Psi4/fsapt.py will be wrong. fisapt0-d3 run with previous; Psi4/fsapt.py but new QCEngine will be wrong. If you’ve got legacy; calculations, it is extremely easy to check or reanalyze them to; salvage them, so please contact the developers with the circumstances; for guidance. Order-1 Visualization with PyMol¶; The fsapt.py script above also generates a number of order-1 .pdb files; that can be used to get a quick qualitative picture of the F-SAPT partition. The; preferred way to do this is to use PyMol to make plots of the molecular geometry; with the atoms colored according to their order-1 F-SAPT contributions. We have; a set of template .pymol scripts to help with this process. These can be; obtained ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/fisapt.html:7252,energy,energy,7252,psi4manual/1.7.x/fisapt.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/fisapt.html,4,['energy'],['energy']
Energy Efficiency,"nerates spectroscopic constants for a diatomic molecules.; Fits a diatomic potential energy curve using a weighted least squares approach; (c.f. https://doi.org/10.1063/1.4862157, particularly eqn. 7), locates the minimum; energy point, and then applies second order vibrational perturbation theory to obtain spectroscopic; constants. Any number of points greater than 4 may be provided, and they should bracket the minimum.; The data need not be evenly spaced, and can be provided in any order. The data are weighted such that; those closest to the minimum have highest impact. A dictionary with the following keys, which correspond to spectroscopic constants, is returned:. :param rvals: The bond lengths (in Angstrom) for which energies are; provided, of length at least 5 and equal to the length of the energies array. :param energies: The energies (Eh) computed at the bond lengths in the rvals list. :param plot_fit: A string describing where to save a plot of the harmonic and anharmonic fits, the; inputted data points, re, r0 and the first few energy levels, if matplotlib; is available. Set to 'screen' to generate an interactive plot on the screen instead. If a filename is; provided, the image type is determined by the extension; see matplotlib for supported file types. :returns: (*dict*) Keys: ""re"", ""r0"", ""we"", ""wexe"", ""nu"", ""ZPVE(harmonic)"", ""ZPVE(anharmonic)"", ""Be"", ""B0"", ""ae"", ""De""; corresponding to the spectroscopic constants in cm-1; """""". angstrom_to_bohr = 1.0 / constants.bohr2angstroms; angstrom_to_meter = 10e-10. # Make sure the input is valid; if len(rvals) != len(energies):; raise ValidationError(""The number of energies must match the number of distances""); npoints = len(rvals); if npoints < 5:; raise ValidationError(""At least 5 data points must be provided to compute anharmonicity""); core.print_out(""\n\nPerforming a fit to %d data points\n"" % npoints). # Sort radii and values first from lowest to highest radius; indices = np.argsort(rvals); rvals = np.array(rval",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/diatomic.html:3209,energy,energy,3209,psi4manual/1.4.0/_modules/psi4/driver/diatomic.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/diatomic.html,14,['energy'],['energy']
Energy Efficiency,"nergy Point. fd-gradient; SCF STO-3G finite-difference tests. omp2-grad2; OMP2 cc-pVDZ gradient for the NO radical. dfep2-2; Compute three IP and 2 EA’s for the PH3 molecule. phi-ao; Test computing values of basis functions (puream and non-puream) at points. dfcasscf-sp; CASSCF/6-31G** energy point. mints6; Patch of a glycine with a methyl group, to make alanine, then DF-SCF energy calculation with the cc-pVDZ basis set. dfmp2-grad1; DF-MP2 cc-pVDZ gradients for the H2O molecule. sapt-dft2; SAPT(DFT) aug-cc-pVDZ computation for the water dimer interaction energy. dfomp2p5-1; DF-OMP2.5 cc-pVDZ energy for the H2O molecule. freq-masses; check nonphysical masses possible. cc17; Single point energies of multiple excited states with EOM-CCSD. fci-coverage; 6-31G H2O Test for coverage. cdoremp-energy1; Cholesky decomposed OO-REMP/cc-pVDZ energy for the H2O molecule. sapt2; SAPT0 aug-cc-pVDZ computation of the benzene-methane interaction energy, using the aug-pVDZ-JKFIT DF basis for SCF, the aug-cc-pVDZ-RI DF basis for SAPT0 induction and dispersion, and the aug-pVDZ-JKFIT DF basis for SAPT0 electrostatics and induction. This example uses frozen core as well as asyncronous I/O while forming the DF integrals and CPHF coefficients. zaptn-nh2; ZAPT(n)/6-31G NH2 Energy Point, with n=2-25. dfomp2-grad2; OMP2 cc-pVDZ energy for the NO molecule. dct2; DC-06 calculation for the He dimer. This performs a two-step update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the MO Basis. dft1-alt; DFT Functional Test. pywrap-bfs; apply linear fragmentation algorithm to a water cluster. dft-b2plyp; Double-hybrid density functional B2PYLP. Reproduces portion of Table I in S. Grimme’s J. Chem. Phys 124 034108 (2006) paper defining the functional. mp2-1; All-electron MP2 6-31G** geometry optimization of water. cc8c; ROHF-CCSD cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Cartesian input. mbis-6; MBIS calculation on ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html:1713,energy,energy,1713,psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"nergy Point. mints6; Patch of a glycine with a methyl group, to make alanine, then DF-SCF energy calculation with the cc-pVDZ basis set. scf-response1; Compute the dipole, quadrupole, and traceless quadrupoles for water. fsapt1; This test case shows an example of running and analyzing a standard F-SAPT0/jun-cc-pvdz procedure for phenol dimer from the S22 database. cc42; RHF-CC2-LR/STO-3G optical rotation of (S)-methyloxirane. gauge = length, omega = (589 355 nm). fnocc5; Test FNO-DF-CCSD(T) energy. opt4; SCF cc-pVTZ geometry optimzation, with Z-matrix input. psimrcc-ccsd_t-3; Mk-MRCCSD(T) single point. \(^1A_1\) CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. cc35; CC3(ROHF)/cc-pVDZ H2O \(R_e\) geom from Olsen et al., JCP 104, 8007 (1996). dfccsd-t-grad1; DF-CCSD(T) cc-pVDZ gradients for the H2O molecule. mints15; check SP basis Fortran exponent parsing. tdscf-5; td-camb3lyp with DiskDF and method/basis specification. dfccsd1; DF-CCSD cc-pVDZ energy for the H2O molecule. fci-tdm; He2+ FCI/cc-pVDZ Transition Dipole Moment. cc7; Tests CCENERGY’s CCSD gradient in the presence of a dipole field. psimrcc-ccsd_t-4; Mk-MRCCSD(T) single point. \(^1A_1\) O$_3` state described using the Ms = 0 component of the singlet. Uses TCSCF orbitals. cc1; RHF-CCSD 6-31G** all-electron optimization of the H2O molecule. dft-vv10; He Dimer VV10 functional test. notes: DFT_VV10_B/C overwrites the NL_DISPERSION_PARAMETERS tuple updated ‘bench’ reference values for new BraggSlater radii. dfccsdat1; DF-CCSD(AT) cc-pVDZ energy for the H2O molecule. psimrcc-fd-freq2; Mk-MRCCSD frequencies. \(^1A_1\) O$_3` state described using the Ms = 0 component of the singlet. Uses TCSCF orbitals. sapt-exch-disp-inf; SAPT0 with S^inf exch-disp20. dfmp2-grad5; Tests DF-MP2 gradient in the presence of a dipole field. cbs-xtpl-func; optimization with method defined via cbs. mp2-def2; Test case for Binding Energy of C4H5N (Pyrrole) with CO2 using MP2/def2-TZVPP. opt3; SCF",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html:24003,energy,energy,24003,psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"nergy [E_h] of subsystems A and B implemented for F/I-SAPT. SAPT HF(2) ENERGY A(HF)¶; The Hartree–Fock localized energy [E_h] of subsystem A implemented for F/I-SAPT. SAPT HF(2) ENERGY B(HF)¶; The Hartree–Fock localized energy [E_h] of subsystem B implemented for F/I-SAPT. SAPT HF(2) ENERGY C¶; The Hartree–Fock energy [E_h] of subsystem C implemented for F/I-SAPT. SAPT HF(2) ENERGY HF¶; The FI-SAPT Hartree–Fock interaction energy [E_h] implemented for F/I-SAPT. SAPT ELST12,R ENERGY¶; An electrostatics-classified SAPT term energy [E_h] implemented for SAPT2. SAPT EXCH11(S^2) ENERGY¶. SAPT EXCH12(S^2) ENERGY¶; An exchange-classified SAPT term energy [E_h] implemented for SAPT2. SAPT IND22 ENERGY¶. SAPT EXCH-IND22 ENERGY¶; An induction-classified SAPT term energy [E_h] implemented for SAPT2. SAPT DISP21 ENERGY¶; A dispersion-classified SAPT term energy [E_h] implemented for SAPT2+. SAPT DISP22(SDQ) ENERGY¶. SAPT DISP22(T) ENERGY¶. SAPT EST.DISP22(T) ENERGY¶; Dispersion-classified MBPT-based SAPT term energy [E_h] implemented for SAPT2+. SAPT DISP2(CCD) ENERGY¶. SAPT DISP22(S)(CCD) ENERGY¶. SAPT DISP22(T)(CCD) ENERGY¶. SAPT EST.DISP22(T)(CCD) ENERGY¶; Dispersion-classified coupled-cluster-based SAPT term energy [E_h] implemented for SAPT2+. SAPT ELST13,R ENERGY¶; An electrostatics-classified SAPT term energy [E_h] implemented for SAPT2+(3). SAPT IND30,R ENERGY¶. SAPT IND-DISP30 ENERGY¶. SAPT EXCH-IND30,R ENERGY¶; A induction-classified SAPT term energy [E_h] implemented for SAPT2+3. SAPT EXCH-IND30(S^INF) ENERGY¶. SAPT EXCH-IND30,R(S^INF) ENERGY¶; A induction-classified SAPT term energy [E_h] implemented for SAPT2+3. See Higher-Order Exchange Terms without Single-Exchange Approximation. SAPT DISP30 ENERGY¶. SAPT EXCH-DISP30 ENERGY¶. SAPT EXCH-IND-DISP30 ENERGY¶; A dispersion-classified SAPT term energy [E_h] implemented for SAPT2+3. SAPT ALPHA¶; SAPT exchange-scaling alpha. SAPT CT ENERGY¶; SAPT charge-transfer energy. SAPT HF TOTAL ENERGY¶; An induction-classified corr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html:48511,energy,energy,48511,psi4manual/1.7.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html,4,['energy'],['energy']
Energy Efficiency,"nergy [H] and correlation energy component [H]; for the labeled Möller–Plesset perturbation theory level.; n is MP perturbation order. NUCLEAR REPULSION ENERGY¶; The nuclear repulsion energy contribution [H] to the total SCF energy.; Quantity in Eq. (2). ONE-ELECTRON ENERGY¶; The one-electron energy contribution [H] to the total SCF energy.; Quantity in Eq. (2). SAPT DISP ENERGY¶. SAPT ELST ENERGY¶. SAPT EXCH ENERGY¶. SAPT IND ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total electronic interaction energy [H] for the the; requested SAPT level of theory. The sum of these four components yields; SAPT ENERGY. SAPT ENERGY¶; The total electronic interaction energy [H] for the requested SAPT; level of theory. SAPT SAPT0 ENERGY¶. SAPT SAPT2 ENERGY¶. SAPT SAPT2+ ENERGY¶. SAPT SAPT2+(3) ENERGY¶. SAPT SAPT2+3 ENERGY¶; The total electronic interaction energy [H] for the labeled SAPT level; of theory. SCF TOTAL ENERGY¶; The total electronic energy [H] of the SCF stage of the calculation.; The CORRELATION ENERGY variables from subsequent stages of a; calculation are often the corresponding TOTAL ENERGY variables; less this quantity. Constructed from Eq. (2). (2). TWO-ELECTRON ENERGY¶; The two-electron energy contribution [H] to the total SCF energy.; Quantity in Eq. (2). UNCP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [H] considering only two-body interactions,; computed without counterpoise correction.; Related variable CP-CORRECTED 2-BODY INTERACTION ENERGY. ZAPTn TOTAL ENERGY¶. ZAPTn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled Z-averaged perturbation theory level.; n is ZAPT perturbation order. Previous topic; Keywords by Alpha; Next topic; Keywords by Module; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Appendices ». © Copyri",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/glossary_psivariables-1.html:8355,energy,energy,8355,psi4manual/4.0b2/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/glossary_psivariables-1.html,2,['energy'],['energy']
Energy Efficiency,"nergy atop a T-zeta reference; >>> energy('cbs', corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme='corl_xtpl_helgaker_2'). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme='corl_xtpl_helgaker_2', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme='corl_xtpl_helgaker_2'). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme='corl_xtpl_helgaker_2', delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] a Q5-zeta MP2 calculation, corrected by CCSD(T) at the TQ-zeta extrapolated level, and all-electron CCSD(T) correlation at T-zeta level; >>> energy(cbs, cbs_metadata=[{""wfn"": ""hf"", ""basis"": ""cc-pv5z""}, {""wfn"": ""mp2"", ""basis"": ""cc-pv[q5]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pv[tq]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pvtz"", ""options"": {""freeze_core"": ""False""}}]). >>> # [8] cbs() coupled with database(); >>> TODO database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme='corl_xtpl_helgaker_2', delta_wfn='ccsd(t)', delta_basis='sto-3g'). >>> # [9] cbs() coupled with optimize(); >>> TODO optimize('mp2', corl_basis='cc-pV[DT]Z', corl_scheme='corl_xtpl_helgaker_2', func=cbs). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. PSI4 API: Linking C++ and Python; cbs. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.driver.cbs.html:14130,energy,energy,14130,psi4manual/1.6.x/api/psi4.driver.cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.driver.cbs.html,2,['energy'],['energy']
Energy Efficiency,"nergy code.; ; clean(...); clean() -> None :; Function to remove scratch files. Call between independent jobs.; ; close_outfile(...); close_outfile() -> None :; Closes the output file.; ; dcft(...); dcft() -> float :; Runs the density cumulant functional theory code.; ; deriv(...); deriv() -> int :; Runs deriv, which contracts density matrices with derivative integrals, to compute gradients.; ; detci(...); detci() -> float :; Runs the determinant-based configuration interaction code.; ; dfmp2(...); dfmp2() -> float :; Runs the DF-MP2 code.; ; dfmp2grad(...); dfmp2grad() -> float :; Runs the DF-MP2 gradient.; ; dftsapt(...); dftsapt( (Wavefunction)arg1, (Wavefunction)arg2, (Wavefunction)arg3) -> float :; Runs the DFT variant of the symmetry adapted perturbation theory code.; ; fd_1_0(...); fd_1_0( (list)arg1) -> PsiReturnType :; Performs a finite difference gradient computation, from energy points.; ; fd_freq_0(...); fd_freq_0( (list)arg1, (int)arg2) -> PsiReturnType :; Performs a finite difference frequency computation, from energy points, for a given irrep.; ; fd_freq_1(...); fd_freq_1( (list)arg1, (int)arg2) -> PsiReturnType :; Performs a finite difference frequency computation, from gradients, for a given irrep.; ; fd_geoms_1_0(...); fd_geoms_1_0() -> matrix_vector :; Gets the list of displacements needed for a finite difference gradient computation, from energy points.; ; fd_geoms_freq_0(...); fd_geoms_freq_0( (int)arg1) -> matrix_vector :; Gets the list of displacements needed for a finite difference frequency computation, from energy points, for a given irrep.; ; fd_geoms_freq_1(...); fd_geoms_freq_1( (int)arg1) -> matrix_vector :; Gets the list of displacements needed fof a finite difference frequency computation, from gradients, for a given irrep; ; fd_geoms_hessian_0(...); fd_geoms_hessian_0() -> matrix_vector :; Gets the list of displacements needed fof a finite difference frequency computation, from energy points.; ; fd_hessian_0(...); fd_hessian_0( (list)",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/psimod-1.html:106376,energy,energy,106376,psi4manual/4.0b4/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html,2,['energy'],['energy']
Energy Efficiency,"nergy components. Checks that computed identically between cfour and psi4. cfour/pywrap-cbs1; Various basis set extrapolation tests only in Cfour instead of Psi4. cfour/sp-rohf-mp4-sc; single-point MP4/qz2p on NH2. cfour/kw-6; Basis set spherical/Cartesian with cfour_basis and puream. cfour/kw-1; testing best practices options, part i. cfour/sp-uhf-scf; single-point HF/qz2p on NH2. cfour/kw-8; Translating psi4 options to cfour, part ii. cfour/kw-3; Basis set spherical/Cartesian with cfour_basis and cfour_spherical. cfour/opt-rhf-ccsd_t_-ecc; optimization CCSD(T)/dzp on water with ecc, aobasis. cfour/sp-rohf-ccsd_t_; single-point CCSD(T)/qz2p on NH2. cfour/sp-rhf-ccsd_t_-ecc; single-point CCSD(T)/qz2p on water with ecc module. cfour/sp-rohf-ccsd-ao; single-point CCSD/qz2p on NH2 with aobasis. cfour/kw-2; testing best practices options, part ii. cfour/sp-uhf-ccsd_t_-ecc; single-point CCSD(T)/qz2p on NH2 with ecc. cfour/scf4; RHF cc-pVDZ energy for water, automatically scanning the symmetric stretch and bending coordinates using Python’s built-in loop mechanisms. The geometry is apecified using a Z-matrix with variables that are updated during the potential energy surface scan, and then the same procedure is performed using polar coordinates, converted to Cartesian coordinates. cfour/psi-ghost-grad; MP2 optimization of dimers with one momomer ghosted. Gradients after three opt cycles are compared with those from psi4. cfour/opt-rhf-scf; optimization HF/svp on water. cfour/sp-uhf-mp2; single-point MP2/qz2p on NH2. cfour/kw-5; Basis set spherical/Cartesian with basis and cfour_spherical. cfour/sp-uhf-ccsd_t_-ao-ecc; single-point CCSD(T)/qz2p on NH2 with ecc, aobasis. cfour/psi-rohf-scsmp2; ROHF MP2 energy components. Checks that computed identically between cfour and psi4. cfour/psi-uhf-mp3; UHF MP3 energy components. Checks that converted identically between cfour and psi4. cfour/dfmp2-1; MP2/cc-PVDZ computation of formic acid dimer binding energy using automatic counte",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_cfour.html:3829,energy,energy,3829,psi4manual/1.9.x/autodoc_testsuite_cfour.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_cfour.html,1,['energy'],['energy']
Energy Efficiency,"nergy contribution to the excitation energy from the ground state to; root n within irrep h. This variable is only defined for Psi’s built-in ADC and will be removed for 1.7. AQCC DIPOLE¶; Dipole array [e a0] for the averaged quadratic coupled-cluster level of theory, (3,). AQCC QUADRUPOLE¶; Redundant quadrupole array [e a0^2] for the averaged quadratic coupled-cluster level of theory, (3, 3). AQCC TOTAL ENERGY¶. AQCC CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the averaged quadratic coupled-cluster level of theory. BRUECKNER CONVERGED¶; Value 1 (0) when the Brueckner orbitals have (have not) converged. CBS NUMBER¶. NBODY NUMBER¶. FINDIF NUMBER¶; Number of tasks [] the named procedure performs. These are immediate; tasks, so if procedures are nested, the total number of tasks is; the product. CBS TOTAL ENERGY¶. CBS CORRELATION ENERGY¶. CBS REFERENCE ENERGY¶; The total electronic energy [Eh] and its breakdown into reference total; energy [Eh] and correlation correction components [Eh] for the compound; method requested through cbs(). CCname ROOT n TOTAL ENERGY¶. TD-fctl ROOT n TOTAL ENERGY¶; The total electronic energy [Eh] for the requested theory and root n (n starts at 0).; DFT functional labeled if canonical. CCname ROOT n (IN h) TOTAL ENERGY¶. TD-fctl ROOT n (IN h) TOTAL ENERGY¶; The total electronic energy [Eh] for the requested theory and root n within irrep h (n starts at 0).; DFT functional labeled if canonical. CCname ROOT n (h) TOTAL ENERGY¶. TD-fctl ROOT n (h) TOTAL ENERGY¶; The total electronic energy [Eh] for the requested theory and root n, which is of irrep h (n starts at 0).; DFT functional labeled if canonical. CCname ROOT n TOTAL ENERGY - h TRANSITION¶. TD-fctl ROOT n TOTAL ENERGY - h TRANSITION¶; The total electronic energy [Eh] for the requested theory and root n, and the transition is of irrep h, (n starts at 0). CCname ROOT n CORRELATION ENERGY¶; The correlation energy [Eh] for the requested c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/glossary_psivariables.html:8342,energy,energy,8342,psi4manual/1.6.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/glossary_psivariables.html,2,['energy'],['energy']
Energy Efficiency,"nergy is to be obtained. Basis SetsCurrently, the basis set set through set commands have no influence; on a cbs calculation. Parameters. scf_basis (basis string) – \(\Rightarrow\) corl_basis \(\Leftarrow\) || 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, scf_basis can default; to corl_basis. corl_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the correlation energy. delta_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. delta2_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. SchemesTransformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, 'xtpl_highest_1', which uses the best basis; set available. See Extrapolation Schemes for all available schemes. Parameters. scf_scheme (Callable) – \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || scf_xtpl_helgaker_3 || etc.; Indicates the basis set extrapolation scheme to be applied to the reference energy.; Defaults to scf_xtpl_helgaker_3() if three valid basis sets; present in psi4.driver.driver_cbs.scf_basis, scf_xtpl_helgaker_2() if two valid basis; sets present in scf_basis, and xtpl_highest_1() otherwise. xtpl_highest_1(); scf_xtpl_helgaker_3(); scf_xtpl_helgaker_2(); scf_xtpl_truhlar_2(); scf_xtpl_karton_2(). corl_scheme (Callable) – \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.cbs-1.html:7458,energy,energy,7458,psi4manual/1.4.0/api/psi4.driver.cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.cbs-1.html,12,['energy'],['energy']
Energy Efficiency,"nergy is to be obtained. Basis SetsCurrently, the basis set set through set commands have no influence; on a cbs calculation. Parameters. scf_basis (basis string) – \(\Rightarrow\) corl_basis \(\Leftarrow\) || 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, scf_basis can default; to corl_basis. corl_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the correlation energy. delta_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. delta2_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. SchemesTransformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, 'xtpl_highest_1', which uses the best basis; set available. See Extrapolation Schemes for all available schemes. Parameters. scf_scheme (string) – \(\Rightarrow\) 'xtpl_highest_1' \(\Leftarrow\) || 'scf_xtpl_helgaker_3' || etc.; Indicates the basis set extrapolation scheme to be applied to the reference energy.; Defaults to scf_xtpl_helgaker_3() if three valid basis sets; present in psi4.driver.driver_cbs.scf_basis, scf_xtpl_helgaker_2() if two valid basis; sets present in scf_basis, and xtpl_highest_1() otherwise. xtpl_highest_1(); scf_xtpl_helgaker_3(); scf_xtpl_helgaker_2(); scf_xtpl_truhlar_2(); scf_xtpl_karton_2(). corl_scheme (string) – \(\Rightarrow\) 'xtpl_highest_1' \(\Leftarrow\) || 'corl_xtpl_helgaker_2' || etc.; Indicates the basis set extrapolation scheme to be applied to",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.driver.cbs.html:7458,energy,energy,7458,psi4manual/1.6.x/api/psi4.driver.cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.driver.cbs.html,3,['energy'],['energy']
Energy Efficiency,"nergy']:; # # this correctly filters out cbs fn and ""hf/cc-pvtz""; # # it probably incorrectly filters out mp5, but reconsider in DDD; # core.set_variable(f""CURRENT HESSIAN"", H); # core.set_variable(f""{lowername.upper()} TOTAL HESSIAN"", H); # core.set_variable(f""{lowername.upper()} TOTAL GRADIENT"", G0); # wfn.set_variable(f""{lowername.upper()} TOTAL HESSIAN"", H); # wfn.set_variable(f""{lowername.upper()} TOTAL GRADIENT"", G0); # TODO: check that current energy's being set to the right figure when this code is actually used; core.set_variable('CURRENT ENERGY', wfn.energy()); core.set_variable(""CURRENT GRADIENT"", G0); driver_findif.hessian_write(wfn). if return_wfn:; return (wfn.hessian(), wfn); else:; return wfn.hessian(). [docs]def frequency(name, **kwargs):; r""""""Function to compute harmonic vibrational frequencies. :aliases: frequencies(), freq(). :returns: *float* |w--w| Total electronic energy in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nest",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html:75380,energy,energy,75380,psi4manual/1.6.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html,4,['energy'],['energy']
Energy Efficiency,"nergy'][lowername] == run_dft:; PsiMod.set_global_option('E_CONVERGENCE', 6). procedures['energy'][lowername](lowername, **kwargs). except KeyError:; raise ValidationError('Energy method %s not available.' % (lowername)). optstash.restore(); return PsiMod.get_variable('CURRENT ENERGY'). [docs]def gradient(name, **kwargs):; r""""""Function complementary to optimize(). Carries out one gradient pass,; deciding analytic or finite difference. """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs); dertype = 1. optstash = OptionsState(; ['SCF', 'E_CONVERGENCE'],; ['SCF', 'D_CONVERGENCE'],; ['E_CONVERGENCE']). # Order of precedence:; # 1. Default for wavefunction; # 2. Value obtained from kwargs, if user changed it; # 3. If user provides a custom 'func' use that. # Allow specification of methods to arbitrary order; lowername, level = parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. # 1. set the default to that of the provided name; if lowername in procedures['gradient']:; dertype = 1; elif lowername in procedures['energy']:; dertype = 0; func = energy. # 2. Check if the user passes dertype into this function; if 'dertype' in kwargs:; opt_dertype = kwargs['dertype']. if der0th.match(str(opt_dertype)):; dertype = 0; func = energy; elif der1st.match(str(opt_dertype)):; dertype = 1; else:; raise ValidationError('Requested derivative level \'dertype\' %s not valid for helper function optimize.' % (opt_dertype)). # 3. if the user provides a custom function THAT takes precendence; if ('opt_func' in kwargs) or ('func' in kwargs):; if ('func' in kwargs):; kwargs['opt_func'] = kwargs['func']; del kwargs['func']; dertype = 0; func = kwargs['opt_func']. # Summary validation; if (dertype == 1) and (lowername in procedures['gradient']):; pass; elif (dertype == 0) and (func is energy) and (lowername in procedures['energy']):; pass; elif (dertype == 0) and not(func is energy):; pass; else:; raise ValidationError('Requested method \'name\' %s and derivative level \'d",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/driver.html:31152,energy,energy,31152,psi4manual/4.0b4/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/driver.html,4,['energy'],['energy']
Energy Efficiency,"nergy('mp2'); escf = variable('SCF TOTAL ENERGY'); edfmp2 = variable('MP2 TOTAL ENERGY'); escsmp2 = variable('SCS-MP2 TOTAL ENERGY'); rows.append((R, A)); table.append([escf, escsmp2, edfmp2]). import pandas as pd; df = pd.DataFrame(table, columns = [""E(SCF)"", ""E(SCS)"", ""E(DFMP2)""], index=rows); print(df). # E(SCF) E(SCS) E(DFMP2); # (0.9, 100) -76.020680 -76.217006 -76.221189; # (0.9, 102) -76.021305 -76.217439 -76.221605; # (1.0, 100) -76.021264 -76.224987 -76.228727; # (1.0, 102) -76.021460 -76.224946 -76.228668; # (1.1, 100) -75.990195 -76.201891 -76.205087; # (1.1, 102) -75.990085 -76.201498 -76.204676. Python Wrappers¶; The Python foundations of the PSI4 driver and Psithon syntax permit; many commonly performed post-processing procedures to be integrated into; the PSI4 suite.; As seen in the neon dimer example from the tutorial section,; the nbody() wrapper provides automatic computation of; counterpoise-corrected interaction energies between two molecules. For; example,; energy('mp2', bsse_type='cp'). will compute the counterpoise-corrected density-fitted MP2 interaction energy; between two molecules.; PSI4 also provides the cbs() wrapper,; which automatically computes a complete-basis-set extrapolation (and; automatically sets up the computations with different basis sets required to; do the extrapolation). For example,:; # all equivalent. energy('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). energy('mp2/cc-pv[dt]z'). will compute a 2-point Helgaker extrapolation of the correlation energy; using the cc-pVDZ and cc-pVTZ basis sets (with method MP2) and add this; extrapolated correlation energy to the Hartree–Fock energy in the; largest basis (cc-pVTZ). cbs() can; be configured behind-the-scenes with explicit arguments, as in the; first example, or the convenience syntax of the equivalent second; example can be used.; Another very useful and powerful feature of PSI4 is the ability; to compute results on entire databases of molecules at a ti",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/psithoninput.html:13321,energy,energy,13321,psi4manual/1.7.x/psithoninput.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/psithoninput.html,3,['energy'],['energy']
Energy Efficiency,"nergy('scf'); >>> cbs(name='scf', scf_basis='cc-pVDZ'). 1; 2>>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> cbs(name='mp2', corl_basis='jun-cc-pVDZ'). 1; 2>>> # [3] DTQ-zeta extrapolated scf reference energy; >>> cbs(name='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). 1; 2>>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> cbs(corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). 1; 2; 3>>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> cbs(corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> cbs(energy, wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). 1; 2>>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs(name='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). 1; 2>>> # [7] cbs() coupled with database(); >>> TODO database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='sto-3g'). 1; 2>>> # [8] cbs() coupled with optimize(); >>> TODO optimize('mp2', corl_basis='cc-pV[DT]Z', corl_scheme=corl_xtpl_helgaker_2, func=cbs). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. PSI4 API: Linking C++ and Python. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/api/psi4.driver.cbs-1.html:13449,energy,energy,13449,psi4manual/1.2.1/api/psi4.driver.cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/api/psi4.driver.cbs-1.html,2,['energy'],['energy']
Energy Efficiency,"nergy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. E_CONVERGENCE (SAPT); SAPT — Convergence criterion for energy (change) in the SAPT term during solution of the CPHF equations. Type: conv double; Default: 1e-10. E_CONVERGENCE (SCF); SCF — Convergence criterion for SCF energy. See Table SCF Convergence & Algorithm for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. EA_POLES (OCC); OCC — Do compute OCC poles for electron affinities? Only valid for OMP2. Type: boolean; Default: false. EFP_DISP (EFP); EFP — Do include dispersion energy term in EFP computation?. Type: boolean; Default: true. EFP_DISP_DAMPING (EFP); EFP — Fragment-fragment dispersion damping type. TT is a damping formula by Tang and Toennies. OVERLAP is overlap-based dispersion damping. Type: string; Possible Values: TT, OVERLAP, OFF; Default: OVERLAP. EFP_ELST (EFP); EFP — Do include electrostatics energy term in EFP computation?. Type: boolean; Default: true. EFP_ELST_DAMPING (EFP); EFP — Fragment-fragment electrostatic damping type. SCREEN is a damping formula based on screen group in the EFP potential. OVERLAP is damping that computes charge penetration energy. Type: string; Possible Values: SCREEN, OVERLAP, OFF; Default: SCREEN. EFP_EXCH (EFP); EFP — Do include exchange repulsion energy term in EFP computation?. Type: boolean; Default: true. EFP_POL (EFP); EFP — Do include polarization energy term in EFP computation?. Type: boolean; Default: true. EFP_POL_DAMPING (EFP); EFP — Fragment-fragment polarization damping type. TT is a damping formula like Tang and Toennies. Type: string; Possible Values: TT, OFF; Default: TT. EKT_EA (OCC); OCC — Do compute virtual orbital energies based on extended Koopmans’ theorem?. Type: boolean; Default: false. EKT_IP (DFOCC); DFOCC — Do compute ionization potentials based on the extended Koopmans’ theorem?. Type: boolean; Default: false",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html:115855,energy,energy,115855,psi4manual/1.0.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html,2,['energy'],['energy']
Energy Efficiency,"nergy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-7. MCSCF_GUESS (DETCI)¶DETCI — Initial MCSCF starting guess, MP2 natural orbitals only available for DF-RHF reference. Type: string; Possible Values: MP2, SCF; Default: SCF. MCSCF_MAX_ROT (DETCI)¶DETCI — Maximum value in the rotation matrix. If a value is greater than this number all values are scaled. Type: double; Default: 0.5. MCSCF_MAXITER (DETCI)¶DETCI — Maximum number MCSCF of iterations. Type: integer; Default: 30. MCSCF_R_CONVERGENCE (DETCI)¶DETCI — Convergence criterion for the RMS of the orbital gradient. Type: conv double; Default: 1e-5. MCSCF_ROTATE (DETCI)¶DETCI — Apply a list of 2x2 rotation matrices to the orbitals in the form of [irrep, orbital1, orbital2, theta] where an angle of 0 would do nothing and an angle of 90 would switch the two orbitals. Type: array; Default: No Default. MCSCF_SO_START_E (DETCI)¶DETCI — Start second-order (AH or OS) orbital-orbital MCSCF based on energy convergence. Type: double; Default: 1e-4. MCSCF_SO_START_GRAD (DETCI)¶DETCI — Start second-order (AH or OS) orbital-orbital MCSCF based on RMS of orbital gradient. Type: double; Default: 1e-4. MCSCF_TYPE (DETCI)¶DETCI — Method to handle the two-electron integrals. Type: string; Possible Values: DF, CONV, AO; Default: CONV. MEMORY (ADC)¶ADC — The amount of memory available (in Mb) This option is only available for the built-in ADC backend. Type: integer; Default: 1000. MIN_CCD_DIISVECS (SAPT)¶SAPT — Minimum number of vectors used in CCD-DIIS. Type: integer; Default: 4. MINAO_BASIS (FISAPT)¶FISAPT (Expert) — MinAO Basis for IBO. Type: string; Default: CC-PVTZ-MINAO. MIXED (DETCI)¶DETCI (Expert) — Do allow “mixed” RAS II/RAS III excitations into the CI space? If FALSE, then if there are any electrons in RAS III, then the number of holes in RAS I cannot exceed the given excitation level EX_LEVEL. Type: boolean; Default: true. MIXED4 (DETCI)¶DETC",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html:165057,energy,energy,165057,psi4manual/1.4.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html,5,['energy'],['energy']
Energy Efficiency,"nergy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-7. MCSCF_GUESS (DETCI)¶DETCI — Initial MCSCF starting guess, MP2 natural orbitals only available for DF-RHF reference. Type: string; Possible Values: MP2, SCF; Default: SCF. MCSCF_MAX_ROT (DETCI)¶DETCI — Maximum value in the rotation matrix. If a value is greater than this number all values are scaled. Type: double; Default: 0.5. MCSCF_MAXITER (DETCI)¶DETCI — Maximum number MCSCF of iterations. Type: integer; Default: 30. MCSCF_R_CONVERGENCE (DETCI)¶DETCI — Convergence criterion for the RMS of the orbital gradient. Type: conv double; Default: 1e-5. MCSCF_ROTATE (DETCI)¶DETCI — Apply a list of 2x2 rotation matrices to the orbitals in the form of [irrep, orbital1, orbital2, theta] where an angle of 0 would do nothing and an angle of 90 would switch the two orbitals. Type: array; Default: No Default. MCSCF_SO_START_E (DETCI)¶DETCI — Start second-order (AH or OS) orbital-orbital MCSCF based on energy convergence. Type: double; Default: 1e-4. MCSCF_SO_START_GRAD (DETCI)¶DETCI — Start second-order (AH or OS) orbital-orbital MCSCF based on RMS of orbital gradient. Type: double; Default: 1e-4. MCSCF_TYPE (DETCI)¶DETCI — Method to handle the two-electron integrals. Type: string; Possible Values: DF, CONV, AO; Default: CONV. MIN_CCD_DIISVECS (SAPT)¶SAPT — Minimum number of vectors used in CCD-DIIS. Type: integer; Default: 4. MINAO_BASIS (FISAPT)¶FISAPT (Expert) — MinAO Basis for IBO. Type: string; Default: CC-PVTZ-MINAO. MIXED (DETCI)¶DETCI (Expert) — Do allow “mixed” RAS II/RAS III excitations into the CI space? If FALSE, then if there are any electrons in RAS III, then the number of holes in RAS I cannot exceed the given excitation level EX_LEVEL. Type: boolean; Default: true. MIXED4 (DETCI)¶DETCI (Expert) — Do allow “mixed” excitations involving RAS IV into the CI space. Useful to specify a split-virtual CISD[TQ] computation. If FALSE, then",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodoc_glossary_options_c.html:170544,energy,energy,170544,psi4manual/1.7.x/autodoc_glossary_options_c.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodoc_glossary_options_c.html,4,['energy'],['energy']
Energy Efficiency,"nergy.; You can run it if you wish.; Once PSI4 is in your path (see the; User Configuration; section of the installation instructions), you can run this computation by typing; >>> psi4 input.dat output.dat. If everything goes well, the computation should complete and should report; a final restricted Hartree–Fock energy in a section like this:; Energy converged. @RHF Final Energy: -76.02663273410671. By default, the energy should be converged to about \(1.0 \times 10^{-6}\), so agreement; is only expected for about the first 6 digits after the decimal. If the; computation does not complete, there is probably a problem with the; compilation or installation of the program (see the installation; instructions in Sec. Compiling and Installing from Source).; This very simple input is sufficient to run the requested information.; Notice that we didn’t tell the program some otherwise useful information; like the charge on the molecule (0, it’s neutral), the spin multiplicity; (1 for a closed-shell molecule with all electrons paired), or the reference; wavefunction to use (restricted Hartree–Fock, or RHF, is usually; appropriate for a closed-shell molecule). The program correctly guessed; all of these options for us. We can change the default behavior through; additional keywords.; Let’s consider what we would do for an open-shell molecule, where; not all electrons are paired. For example, let’s run a computation; on methylene (CH2), whose ground electronic state has two unpaired; electrons (triplet electronic state, or a spin multiplicity \(2S+1 = 3\)).; In this case, the default spin multiplicity (1) is not correct, so we; need to tell the program the true value (3). Like many programs, PSI4; can get the charge and multiplicity as the first two integers in the; Z-matrix. Note the line with 0 3 at the beginning of the molecule; specification below. In this example we will also specify the bond length; and bond angle as variables (\(R\) and \(A\)), whose values are given; at",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/tutorial-1.html:3408,charge,charge,3408,psi4manual/1.4.0/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/tutorial-1.html,9,['charge'],['charge']
Energy Efficiency,"ners; exec actives; try:; freagent = open('%s.out' % (rgt), 'r'); except IOError:; PsiMod.print_out('Warning: Output file \'%s.out\' not found.\n' % (rgt)); PsiMod.print_out(' Database summary will have 0.0 and **** in its place.\n'); else:; while 1:; line = freagent.readline(); if not line:; if ERGT[rgt] == 0.0:; PsiMod.print_out('Warning: Output file \'%s.out\' has no DATABASE RESULT line.\n' % (rgt)); PsiMod.print_out(' Database summary will have 0.0 and **** in its place.\n'); break; s = line.split(); if (len(s) != 0) and (s[0:3] == ['DATABASE', 'RESULT:', 'computation']):; if int(s[3]) != db_linkage:; raise ValidationError('Output file \'%s.out\' has linkage %s incompatible with master.in linkage %s.'; % (rgt, str(s[3]), str(db_linkage))); if s[6] != rgt:; raise ValidationError('Output file \'%s.out\' has nominal affiliation %s incompatible with reagent %s.'; % (rgt, s[6], rgt)); if (s[8:10] == ['electronic', 'energy']):; ERGT[rgt] = float(s[10]); PsiMod.print_out('DATABASE RESULT: electronic energy = %20.12f\n' % (ERGT[rgt])); elif (s[8:10] == ['variable', 'value']):; for envv in db_tabulate:; if (s[13:] == envv.upper().split()):; VRGT[rgt][envv] = float(s[10]); PsiMod.print_out('DATABASE RESULT: variable %s value = %20.12f\n' % (envv.upper(), VRGT[rgt][envv])); freagent.close(). # end sow after writing files; if (db_mode.lower() == 'sow'):; return 0.0. # Reap all the necessary reaction computations; PsiMod.print_out(""\n""); banner((""Database %s Results"" % (db_name))); PsiMod.print_out(""\n""). maxactv = []; for rxn in HRXN:; maxactv.append(len(ACTV[dbse + '-' + str(rxn)])); maxrgt = max(maxactv); table_delimit = '-' * (54 + 20 * maxrgt); tables = ''. # find any reactions that are incomplete; FAIL = defaultdict(int); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); for i in range(len(ACTV[db_rxn])):; if abs(ERGT[ACTV[db_rxn][i]]) < 1.0e-12:; FAIL[rxn] = 1. # tabulate requested process::environment variables; tables += """""" For each VARIABLE requested by tabulate,",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:45369,energy,energy,45369,psi4manual/4.0b2/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html,2,['energy'],['energy']
Energy Efficiency,"ness test of F-SAPT (see fsapt1 for a real example). cepa3; cc-pvdz H2O Test coupled-pair CISD against DETCI CISD. dfomp2-3; OMP2 cc-pVDZ energy for the H2O molecule. cc19; CCSD/cc-pVDZ dipole polarizability at two frequencies. opt12; SCF cc-pVDZ geometry optimzation of ketene, starting from bent structure. cc17; Single point energies of multiple excited states with EOM-CCSD. props2; DF-SCF cc-pVDZ of benzene-hydronium ion, scanning the dissociation coordinate with Python’s built-in loop mechanism. The geometry is specified by a Z-matrix with dummy atoms, fixed parameters, updated parameters, and separate charge/multiplicity specifiers for each monomer. One-electron properties computed for dimer and one monomer. opt2; SCF DZ allene geometry optimization, with Cartesian input, first in c2v symmetry, then in Cs symmetry from a starting point with a non-linear central bond angle. dft1; DFT Functional Test all values update for new BraggSlater radii. fd-freq-energy; SCF STO-3G finite-difference frequencies from energies for H2O. cc-module; check that CC is returning the same values btwn CC*, FNOCC, and DFOCC modules. omp3-grad2; OMP3 cc-pVDZ gradient for the NO radical. scf2; RI-SCF cc-pVTZ energy of water, with Z-matrix input and cc-pVTZ-RI auxilliary basis. sapt9; usapt example with empty beta. nbody-multi-level; Multilevel computation of water trimer energy (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). pubchem1; Benzene vertical singlet-triplet energy difference computation, using the PubChem database to obtain the initial geometry, which is optimized at the HF/STO-3G level, before computing single point energies at the RHF, UHF and ROHF levels of theory. dft-jk; DFT JK on-disk test. omp2-2; OMP2 cc-pVDZ energy with ROHF initial guess orbitals for the NO radical. scf-response2; Compute the dipole polarizability for water with custom basis set. fcidump; test FCIDUMP functionality for rhf/uhf. pywrap-checkrun-rohf; This checks that all energy methods ca",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html:25810,energy,energy,25810,psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"nett. psi4.driver.diatomic.anharmonicity(rvals, energies, plot_fit='', mol=None)[source]¶; Generates spectroscopic constants for a diatomic molecules.; Fits a diatomic potential energy curve using a weighted least squares approach; (c.f. https://doi.org/10.1063/1.4862157, particularly eqn. 7), locates the minimum; energy point, and then applies second order vibrational perturbation theory to obtain spectroscopic; constants. Any number of points greater than 4 may be provided, and they should bracket the minimum.; The data need not be evenly spaced, and can be provided in any order. The data are weighted such that; those closest to the minimum have highest impact.; A dictionary with the following keys, which correspond to spectroscopic constants, is returned:. Parameters:. rvals (List[float]) – The bond lengths (in Angstrom) for which energies are; provided, of length at least 5 and equal to the length of the energies array; energies (List[float]) – The energies (Eh) computed at the bond lengths in the rvals list; plot_fit (str) – A string describing where to save a plot of the harmonic and anharmonic fits, the; inputted data points, re, r0 and the first few energy levels, if matplotlib; is available. Set to ‘screen’ to generate an interactive plot on the screen instead. If a filename is; provided, the image type is determined by the extension; see matplotlib for supported file types. Return type:; Dict[str, Any]. Returns:; (dict) Keys: “re”, “r0”, “we”, “wexe”, “nu”, “ZPVE(harmonic)”, “ZPVE(anharmonic)”, “Be”, “B0”, “ae”, “De”; corresponding to the spectroscopic constants in cm-1. table of contents. Spectroscopic Constants for Diatomics; anharmonicity(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Psithon Functions: Invoking a Calculation; Spectroscopic Constants for Diatomics. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; .",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/diatomic.html:1445,energy,energy,1445,psi4manual/master/diatomic.html,https://psicode.org,https://psicode.org/psi4manual/master/diatomic.html,1,['energy'],['energy']
Energy Efficiency,"next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». Optimize¶. optimize(name[, func, mode, dertype, molecule])[source]¶; Function to perform a geometry optimization. Aliases :opt(). Returns:(float) Total electronic energy of optimized structure in Hartrees. Psi variables:. CURRENT ENERGY. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. scf; Hartree–Fock (HF) or density functional theory (DFT). dcft; density cumulant functional theory. mp2; 2nd-order Moller-Plesset perturbation theory (MP2). ccsd; coupled cluster singles and doubles (CCSD). ccsd(t); CCSD with perturbative triples. eom-ccsd; equation of motion (EOM) CCSD. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; driver.energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``’gradient’`` or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Ana",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/opt-1.html:1068,energy,energy,1068,psi4manual/4.0b2/opt-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/opt-1.html,2,['energy'],['energy']
Energy Efficiency,"ne¶; Deep copies the internal data. del_array_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) Matrix QC variable. del_potential_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) ExternalPotential QC variable. (This function is provisional and might be removed in the future.). del_scalar_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) double QC variable. del_variable(key)¶; Removes scalar or array QCVariable key from cls if present. Return type; None. Parameters. cls (psi4.core.Wavefunction) – ; key (str) – . density_fitted(self: psi4.core.Wavefunction) → bool¶; Returns whether this wavefunction was obtained using density fitting or not. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. efzc(self: psi4.core.Wavefunction) → float¶; Returns the frozen-core energy. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunction’s energy. epsilon_a(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Alpha Eigenvalues subset. epsilon_b(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Beta Eigenvalues subset. esp_at_nuclei(self: psi4.core.Wavefunction) → psi4.core.Vector¶; returns electrostatic potentials at nuclei. external_pot(self: psi4.core.Wavefunction) → psi4.core.ExternalPotential¶; Gets the requested external potential. force_doccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶; Specialized expert use only. Sets the number of doubly occupied oribtals per irrep. Note that this results in inconsistent Wavefunction objects for SCF, so caution is ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ccwavefunction.html:13868,energy,energy,13868,psi4manual/1.4.0/api/psi4.core.ccwavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ccwavefunction.html,4,['energy'],['energy']
Energy Efficiency,"ne¶; Deep copies the internal data. del_array_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) Matrix QC variable. del_potential_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) ExternalPotential QC variable. (This function is provisional and might be removed in the future.). del_scalar_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) double QC variable. del_variable(key)¶; Removes scalar or array QCVariable key from cls if present. Return type; None. Parameters. cls (psi4.core.Wavefunction) – ; key (str) – . density_fitted(self: psi4.core.Wavefunction) → bool¶; Returns whether this wavefunction was obtained using density fitting or not. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. efzc(self: psi4.core.Wavefunction) → float¶; Returns the frozen-core energy. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunction’s energy. epsilon_a(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, basis: str, subset: str) → psi4.core.Vector¶; Returns the requested Alpha orbital energies subset. Parameters. basis – {‘AO’, ‘SO’, ‘MO’}; MO or SO select for Pitzer-ordering the return vector in the full computational point group symmetry.; AO selects for Pitzer-ordering the return vector without point group symmetry.; subset – {‘ALL’, ‘ACTIVE’, ‘FROZEN’, ‘OCC’, ‘VIR’, ‘FROZEN_OCC’, ‘ACTIVE_OCC’, ‘ACTIVE_VIR’, ‘FROZEN_VIR’}; Which subspace of orbital energies should be returned?. Returns; A Pitzer-ordered vector of the orbitals. Return type; Vector. epsilon_b(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, basis: str, subset: str) → psi4.core.Vector¶; Returns the requested Beta orbital energies sub",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.core.ccwavefunction.html:13942,energy,energy,13942,psi4manual/1.5.0/api/psi4.core.ccwavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.core.ccwavefunction.html,12,['energy'],['energy']
Energy Efficiency,"ne¶; Sets all fragments in the molecule to be active. add_atom(self: psi4.core.Molecule, Z: float, x: float, y: float, z: float, symbol: str, mass: float, charge: float, label: str, A: int) → None¶; Adds to self Molecule an atom with atomic number Z, Cartesian coordinates in Bohr (x, y, z), atomic symbol, mass, and charge, extended atomic label, and mass number A. atom_at_position(*args, **kwargs)¶; Overloaded function. atom_at_position(self: psi4.core.Molecule, coord: float, tol: float) -> int. Tests to see if an atom is at the position coord with a given tolerance tol. atom_at_position(self: psi4.core.Molecule, coord: List[float[3]], tol: float) -> int. Tests to see if an atom is at the position coord with a given tolerance tol. basis_on_atom(self: psi4.core.Molecule, arg0: int) → str¶; Gets the label of the orbital basis set on a given atom arg0. center_of_mass(self: psi4.core.Molecule) → psi4.core.Vector3¶; Computes center of mass of molecule (does not translate molecule). charge(self: psi4.core.Molecule, atom: int) → float¶; Gets charge of atom (0-indexed without dummies). clone(self: psi4.core.Molecule) → psi4.core.Molecule¶; Returns a new Molecule identical to arg1. com_fixed(self: psi4.core.Molecule) → bool¶; Gets whether or not center of mass is fixed. comment(self: psi4.core.Molecule) → str¶; Gets molecule comment. connectivity(self: psi4.core.Molecule) → List[Tuple[int, int, float]]¶; Gets molecule connectivity. create_psi4_string_from_molecule(self: psi4.core.Molecule) → str¶; Gets a string re-expressing in input format the current state of the molecule.Contains Cartesian geometry info, fragmentation, charges and multiplicities, and any frame restriction. deactivate_all_fragments(self: psi4.core.Molecule) → None¶; Sets all fragments in the molecule to be inactive. distance_matrix(self: psi4.core.Molecule) → psi4.core.Matrix¶; Returns Matrix of interatom distances. extract_subsets(*args, **kwargs)¶; Overloaded function. extract_subsets(self: psi4.core.Mole",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.molecule.html:16479,charge,charge,16479,psi4manual/1.3.2/api/psi4.core.molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.molecule.html,7,['charge'],['charge']
Energy Efficiency,"nfluences return values, see below.; verbose (int) – Amount of printing. Returns:. energy (float) – When dertype=0, energy [Eh].; gradient (ndarray) – When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ndarray) – When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; This function wraps the QCEngine dftd4 harness which wraps the internal DFTD4 Python API.; As such, the upstream convention of func trumping dashparam holds, rather than the; run_dftd3() behavior of dashparam extending or overriding func. run_gcp(func=None, dertype=None, verbose=1)[source]¶; Compute geometrical BSSE correction via Grimme’s GCP program.; Function to call Grimme’s GCP program; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp; to compute an a posteriori geometrical BSSE correction to self for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, func. Returns energy if dertype is 0, gradient; if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The gcp executable must be independently compiled and; found in PATH or PSIPATH. self may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended by this method py-side and only public interface; fns used) or a string that can be instantiated into a qcdb.Molecule. Parameters:. func (Optional[str]) – Name of method/basis combination or composite method for which to compute the correction; (e.g., HF/cc-pVDZ, DFT/def2-SVP, HF3c, PBEh3c).; dertype (Union[int, str, None]) – Maximum derivative level at which to run GCP. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int) – Amount of printing. Unused at present. Returns:. energy (float) – When dertype=0, energy [Eh].; gradient (ndarray) – When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ndarray) – When dertype=None, both e",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html:30967,energy,energy,30967,psi4manual/1.7.x/api/psi4.core.Molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html,16,['energy'],['energy']
Energy Efficiency,"nformation in wfn to filename in; molden format. Will write natural orbitals from density (MO basis) if supplied.; Warning! Most post-SCF Wavefunctions do not build the density as this is often; much more costly than the energy. In addition, the Wavefunction density attributes; (Da and Db) return the SO density and must be transformed to the MO basis; to use with this function. New in version 0.5: wfn parameter passed explicitly. Returns; None. Parameters. filename (string) – destination file name for MOLDEN file (optional); do_virtual (bool) – do write all the MOs to the MOLDEN file (true) or discard the unoccupied MOs, not valid for NO’s (false) (optional); use_natural (bool) – write natural orbitals determined from density on wavefunction. Examples. Molden file with the Kohn-Sham orbitals of a DFT calculation.; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> wfn.molden('mycalc.molden'). Molden file with the natural orbitals of a CCSD computation. For correlated methods, an energy call will not compute the density.; “properties” or “gradient” must be called.; >>> E, wfn = properties('ccsd', return_wfn=True); >>> wfn.molden('ccsd_no.molden', use_natural=True). To supply a custom density matrix, manually set the Da and Db of the wavefunction.; This is used, for example, to write natural orbitals coming from a root computed; by a CIWavefunction computation, e.g., detci, fci, casscf.`; The first two arguments of get_opdm can be set to n, n where n => 0 selects the root to; write out, provided these roots were computed, see NUM_ROOTS. The; third argument controls the spin (""A"", ""B"" or ""SUM"") and the final; boolean option determines whether inactive orbitals are included.; >>> E, wfn = energy('detci', return_wfn=True); >>> wfn.Da() = wfn.get_opdm(0, 0, ""A"", True); >>> wfn.Db() = wfn.get_opdm(0, 0, ""B"", True); >>> molden(wfn, 'no_root1.molden', use_natural=True). write_nbo(name)¶. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ccwavefunction.html:26348,energy,energy,26348,psi4manual/1.4.0/api/psi4.core.ccwavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ccwavefunction.html,13,['energy'],['energy']
Energy Efficiency,"nformation in wfn to filename in; molden format. Will write natural orbitals from density (MO basis) if supplied.; Warning! Most post-SCF Wavefunctions do not build the density as this is often; much more costly than the energy. In addition, the Wavefunction density attributes; (Da and Db) return the SO density and must be transformed to the MO basis; to use with this function. New in version 0.5: wfn parameter passed explicitly. Returns; None. Parameters. filename (string) – destination file name for MOLDEN file (optional); do_virtual (bool) – do write all the MOs to the MOLDEN file (true) or discard the unoccupied MOs, not valid for NO’s (false) (optional); use_natural (bool) – write natural orbitals determined from density on wavefunction. Examples. Molden file with the Kohn-Sham orbitals of a DFT calculation.; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> wfn.molden('mycalc.molden'). Molden file with the natural orbitals of a CCSD computation. For correlated methods, an energy call will not compute the density.; “properties” or “gradient” must be called.; >>> E, wfn = properties('ccsd', return_wfn=True); >>> wfn.molden('ccsd_no.molden', use_natural=True). To supply a custom density matrix, manually set the Da and Db of the wavefunction.; This is used, for example, to write natural orbitals coming from a root computed; by a CIWavefunction computation, e.g., detci, fci, casscf.`; The first two arguments of get_opdm can be set to n, n where n => 0 selects the root to; write out, provided these roots were computed, see NUM_ROOTS. The; third argument controls the spin (""A"", ""B"" or ""SUM"") and the final; boolean option determines whether inactive orbitals are included.; >>> E, wfn = energy('detci', return_wfn=True); >>> wfn.Da() = wfn.get_opdm(0, 0, ""A"", True); >>> wfn.Db() = wfn.get_opdm(0, 0, ""B"", True); >>> molden(wfn, 'no_root1.molden', use_natural=True). write_nbo(name)¶. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.core.ccwavefunction.html:27452,energy,energy,27452,psi4manual/1.5.0/api/psi4.core.ccwavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.core.ccwavefunction.html,18,['energy'],['energy']
Energy Efficiency,"nformation in wfn to filename in; molden format. Will write natural orbitals from density (MO basis) if supplied.; Warning! Most post-SCF Wavefunctions do not build the density as this is often; much more costly than the energy. In addition, the Wavefunction density attributes; (Da and Db) return the SO density and must be transformed to the MO basis; to use with this function. New in version 0.5: wfn parameter passed explicitly. Returns; None. Parameters. filename (string) – destination file name for MOLDEN file (optional); do_virtual (bool) – do write all the MOs to the MOLDEN file (true) or discard the unoccupied MOs, not valid for NO’s (false) (optional); use_natural (bool) – write natural orbitals determined from density on wavefunction. Examples. Molden file with the Kohn-Sham orbitals of a DFT calculation.; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> wfn.molden('mycalc.molden'). Molden file with the natural orbitals of a CCSD computation. For correlated methods, an energy call will not compute the density.; “properties” or “gradient” must be called.; >>> E, wfn = properties('ccsd', return_wfn=True); >>> wfn.molden('ccsd_no.molden', use_natural=True). To supply a custom density matrix, manually set the Da and Db of the wavefunction.; This is used, for example, to write natural orbitals coming from a root computed; by a CIWavefunction computation, e.g., detci, fci, casscf.`; The first two arguments of get_opdm can be set to n, n where n => 0 selects the root to; write out, provided these roots were computed, see NUM_ROOTS. The; third argument controls the spin (""A"", ""B"" or ""SUM"") and the final; boolean option determines whether inactive orbitals are included.; >>> E, wfn = energy('detci', return_wfn=True); >>> wfn.Da() = wfn.get_opdm(0, 0, ""A"", True); >>> wfn.Db() = wfn.get_opdm(0, 0, ""B"", True); >>> molden(wfn, 'no_root1.molden', use_natural=True). write_nbo(name)¶. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.CCWavefunction.html:27882,energy,energy,27882,psi4manual/1.6.x/api/psi4.core.CCWavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.CCWavefunction.html,18,['energy'],['energy']
Energy Efficiency,"nf}\) Exchange-Induction terms. Type: boolean; Default: false. DO_LEVEL_SHIFT (DFOCC)¶DFOCC — Do apply level shifting?. Type: boolean; Default: true. DO_LEVEL_SHIFT (OCC)¶OCC — Removed in 1.4. Will raise an error in 1.5. Type: boolean; Default: true. DO_MBPT_DISP (SAPT)¶SAPT (Expert) — Do MBPT dispersion correction in SAPT2+, SAPT2+(3) or SAPT2+3, if also doing CCD?. Type: boolean; Default: true. DO_SCS (DFOCC)¶DFOCC — Do perform spin-component-scaled OMP2 (SCS-OMP2)? In all computation, SCS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SCS-OMP2, one needs to set ‘DO_SCS’ to true. Type: boolean; Default: false. DO_SCS (OCC)¶OCC — Removed in 1.4. Will raise an error in 1.5. Pass the method name, like scs-mp2, to energy instead. Type: boolean; Default: false. DO_SINGLETS (CPHF)¶CPHF — Do singlet states? Default true. Type: boolean; Default: true. DO_SOS (DFOCC)¶DFOCC — Do perform spin-opposite-scaled OMP2 (SOS-OMP2)? In all computation, SOS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SOS-OMP2, one needs to set ‘DO_SOS’ to true. Type: boolean; Default: false. DO_SOS (OCC)¶OCC — Removed in 1.4. Will raise an error in 1.5. Pass the method name, like scs-mp2, to energy instead. Type: boolean; Default: false. DO_THIRD_ORDER (SAPT)¶SAPT (Expert) — Do compute third-order corrections?. Type: boolean; Default: false. DO_TRIPLETS (CPHF)¶CPHF — Do triplet states? Default true. Type: boolean; Default: true. DOCC (GLOBALS)¶GLOBALS — An array containing the number of doubly-occupied orbitals per irrep (in Cotton order). Type: array; Default: No Default. DOCC (MCSCF)¶MCSCF — The number of doubly occupied orbitals, per irrep. Type: array; Default: No Default. DYNAMIC_LEVEL (OPTKING)¶OPTKING — Starting level for dynamic optimization (0=nondynamic, higher=>more conservative). Type: integer; Default: 0. E3_SCALE (DFOCC)¶DFOCC — CEPA o",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html:115336,energy,energy,115336,psi4manual/1.4.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html,2,['energy'],['energy']
Energy Efficiency,"ng <apdx:basisElement>`; :param delta4_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the fourth delta correction; to the correlation energy. :type delta5_basis: :ref:`basis string <apdx:basisElement>`; :param delta5_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the fifth delta correction; to the correlation energy. * Schemes; Transformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, ``'xtpl_highest_1'``, which uses the best basis; set available. See :ref:`sec:cbs_xtpl` for all available schemes. :type scf_scheme: function; :param scf_scheme: |dl| ``xtpl_highest_1`` |dr| || ``scf_xtpl_helgaker_3`` || etc. Indicates the basis set extrapolation scheme to be applied to the reference energy.; Defaults to :py:func:`~scf_xtpl_helgaker_3` if three valid basis sets; present in ``scf_basis``, :py:func:`~scf_xtpl_helgaker_2` if two valid basis; sets present in ``scf_basis``, and :py:func:`~xtpl_highest_1` otherwise. .. hlist::; :columns: 1. * xtpl_highest_1; * scf_xtpl_helgaker_3; * scf_xtpl_helgaker_2; * scf_xtpl_truhlar_2; * scf_xtpl_karton_2. :type corl_scheme: function; :param corl_scheme: |dl| ``xtpl_highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the correlation energy.; Defaults to :py:func:`~corl_xtpl_helgaker_2` if two valid basis sets; present in ``corl_basis`` and :py:func:`~xtpl_highest_1` otherwise. .. hlist::; :columns: 1. * xtpl_highest_1; * corl_xtpl_helgaker_2. :type delta_scheme: function; :param delta_scheme: |dl| ``xtpl_highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the delta correcti",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html:32034,energy,energy,32034,psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html,1,['energy'],['energy']
Energy Efficiency,"ng <apdx:basisElement>`; :param delta4_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the fourth delta correction; to the correlation energy. :type delta5_basis: :ref:`basis string <apdx:basisElement>`; :param delta5_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the fifth delta correction; to the correlation energy. * Schemes; Transformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, ``'xtpl_highest_1'``, which uses the best basis; set available. See :ref:`sec:cbs_xtpl` for all available schemes. :type scf_scheme: function; :param scf_scheme: |dl| ``xtpl_highest_1`` |dr| || ``scf_xtpl_helgaker_3`` || etc. Indicates the basis set extrapolation scheme to be applied to the reference energy.; Defaults to :py:func:`~scf_xtpl_helgaker_3` if three valid basis sets; present in ``scf_basis``, :py:func:`~scf_xtpl_helgaker_2` if two valid basis; sets present in ``scf_basis``, and :py:func:`~xtpl_highest_1` otherwise. :type corl_scheme: function; :param corl_scheme: |dl| ``xtpl_highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the correlation energy.; Defaults to :py:func:`~corl_xtpl_helgaker_2` if two valid basis sets; present in ``corl_basis`` and :py:func:`~xtpl_highest_1` otherwise. :type delta_scheme: function; :param delta_scheme: |dl| ``xtpl_highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the delta correction; to the correlation energy.; Defaults to :py:func:`~corl_xtpl_helgaker_2` if two valid basis sets; present in ``delta_basis`` and :py:func:`~xtpl_highest_1` otherwise. :type delta2_scheme: functio",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver_cbs.html:25640,energy,energy,25640,psi4manual/1.1.0/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver_cbs.html,1,['energy'],['energy']
Energy Efficiency,"ng = ', '.join(supp_jk_type[:-1]) + ', or ' + supp_jk_type[-1] + '.'. if scf_type not in supp_jk_type:; raise ValidationError(""Method %s: Requires support for non-symmetric density matrices.\n""; "" Please set SCF_TYPE to %s"" % (name, supp_string)). def check_disk_df(name, optstash):. optstash.add_option(['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE') or core.get_global_option('SCF_TYPE') == ""DF"":; core.set_global_option('SCF_TYPE', 'DISK_DF'); core.print_out(f"""""" For method '{name}', SCF Algorithm Type (re)set to DISK_DF.\n""""""); else:; if core.get_global_option('SCF_TYPE') == ""MEM_DF"":; raise ValidationError(; f"" Method '{name}' requires SCF_TYPE = DISK_DF, please use SCF_TYPE = DF to automatically choose the correct DFJK implementation.""; ). def print_ci_results(ciwfn, rname, scf_e, ci_e, print_opdm_no=False):; """"""; Printing for all CI Wavefunctions; """""". # Print out energetics; core.print_out(""\n ==> Energetics <==\n\n""); core.print_out("" SCF energy = %20.15f\n"" % scf_e); if ""CI"" in rname:; core.print_out("" Total CI energy = %20.15f\n"" % ci_e); elif ""MP"" in rname:; core.print_out("" Total MP energy = %20.15f\n"" % ci_e); elif ""ZAPT"" in rname:; core.print_out("" Total ZAPT energy = %20.15f\n"" % ci_e); else:; core.print_out("" Total MCSCF energy = %20.15f\n"" % ci_e). # Nothing to be done for ZAPT or MP; if (""MP"" in rname) or (""ZAPT"" in rname):; core.print_out(""\n""); return. # Initial info; ci_nroots = core.get_option(""DETCI"", ""NUM_ROOTS""); irrep_labels = ciwfn.molecule().irrep_labels(). # Grab the D-vector; dvec = ciwfn.D_vector(); dvec.init_io_files(True). for root in range(ci_nroots):; core.print_out(""\n ==> %s root %d information <==\n\n"" % (rname, root)). # Print total energy; root_e = ciwfn.variable(""CI ROOT %d TOTAL ENERGY"" % (root)); core.print_out("" %s Root %d energy = %20.15f\n"" % (rname, root, root_e)). # Print natural occupations; if print_opdm_no:; core.print_out(""\n Active Space Natural occupation numbers:\n\n""). oc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc_util.html:4881,energy,energy,4881,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc_util.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc_util.html,6,['energy'],['energy']
Energy Efficiency,"ng CFOUR_SYMMETRY =OFF in the input. The DEFAULT option (which is the default) uses the highest order Abelian subgroup. Type: string; Possible Values: DEFAULT, C1, C2, CS, CI, C2V, C2H, D2, D2H, OFF; Default: DEFAULT. CFOUR_SYM_CHECK (CFOUR); CFOUR — In principle can be used to force the SCF to converge a solution for which the density matrix transforms as the totally symmetric representation of the point group (i.e. no broken symmetry solutions). The code seems to work in most cases, but has currently been implemented for point groups with E type representation and not for those with triply-, quadruply- or pentuply-degenerate representations. Extending the code to those cases is probably straightforward, and the reader is encouraged to do so if (s)he is so inclined. SYM_CHECK=0 “forces” the high-symmetry solution. SYM_CHECK=OVERRIDE (=1) doesn’t. The latter is the default. Type: boolean; Default: true. CFOUR_SYMMETRY (CFOUR); CFOUR — Specifies what subgroup of the full point group is to be used in the energy and/or gradient calculation (the computational point group). OFF (=1) forces a no symmetry run (in ) and ON (=0) runs the calculation in the largest self-adjoint subgroup ( and its subgroups). Type: boolean; Default: true. CFOUR_T3_EXTRAPOL (CFOUR); CFOUR — Specifies whether the T3 amplitudes are included ON (=1) or not included OFF (=0) in the DIIS convergence acceleration during CCSDT calculations. Inclusion of T3 speeds up convergence and allows tight convergence, but on the other hand it increases disk space requirements. Note that this keyword is only available with module xecc. Type: boolean; Default: false. CFOUR_TAMP_SUM (CFOUR); CFOUR — Specifies how often the largest amplitudes are to be printed. For =0, amplitudes are printed at the beginning and end of the run. For =1, amplitudes are printed every iteration. For =2, amplitudes are printed every other iteration, etc. Type: integer; Default: 5. CFOUR_THERMOCHEMISTRY (CFOUR); CFOUR — Specifies whether t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html:79111,energy,energy,79111,psi4manual/1.0.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html,2,['energy'],['energy']
Energy Efficiency,"ng CFOUR_SYMMETRY =OFF in the input. The DEFAULT option (which is the default) uses the highest order Abelian subgroup. Type: string; Possible Values: DEFAULT, C1, C2, CS, CI, C2V, C2H, D2, D2H, OFF; Default: DEFAULT. CFOUR_SYM_CHECK (CFOUR); CFOUR — In principle can be used to force the SCF to converge a solution for which the density matrix transforms as the totally symmetric representation of the point group (i.e. no broken symmetry solutions). The code seems to work in most cases, but has currently been implemented for point groups with E type representation and not for those with triply-, quadruply- or pentuply-degenerate representations. Extending the code to those cases is probably straightforward, and the reader is encouraged to do so if (s)he is so inclined. SYM_CHECK=0 “forces” the high-symmetry solution. SYM_CHECK=OVERRIDE (=1) doesn’t. The latter is the default. Type: boolean; Default: true. CFOUR_SYMMETRY (CFOUR); CFOUR — Specifies what subgroup of the full point group is to be used in the energy and/or gradient calculation (the computational point group). OFF (=1) forces a no symmetry run (in \(C_1\) ) and ON (=0) runs the calculation in the largest self-adjoint subgroup ( \(D_{2h}\) and its subgroups). Type: boolean; Default: true. CFOUR_T3_EXTRAPOL (CFOUR); CFOUR — Specifies whether the T3 amplitudes are included ON (=1) or not included OFF (=0) in the DIIS convergence acceleration during CCSDT calculations. Inclusion of T3 speeds up convergence and allows tight convergence, but on the other hand it increases disk space requirements. Note that this keyword is only available with module xecc. Type: boolean; Default: false. CFOUR_TAMP_SUM (CFOUR); CFOUR — Specifies how often the largest \(t\) amplitudes are to be printed. For =0, amplitudes are printed at the beginning and end of the run. For =1, amplitudes are printed every iteration. For =2, amplitudes are printed every other iteration, etc. Type: integer; Default: 5. CFOUR_THERMOCHEMISTRY (CFOUR); CF",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html:79631,energy,energy,79631,psi4manual/1.2.1/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html,6,['energy'],['energy']
Energy Efficiency,"ng algorithm (0 for old, 1 for new). Type: integer; Default: 0. FITTING_CONDITION (CPHF); CPHF — The maximum reciprocal condition allowed in the fitting metric. Type: double; Default: 1.0e-12. FIXED_BEND (OPTKING); OPTKING — Specify angles between atoms to be fixed (eq. value specified). Type: string; Default: No Default. FIXED_DIHEDRAL (OPTKING); OPTKING — Specify dihedral angles between atoms to be fixed (eq. value specified). Type: string; Default: No Default. FIXED_DISTANCE (OPTKING); OPTKING — Specify distances between atoms to be fixed (eq. value specified). Type: string; Default: No Default. FLEXIBLE_G_CONVERGENCE (OPTKING); OPTKING — Even if a user-defined threshold is set, allow for normal, flexible convergence criteria. Type: boolean; Default: false. FOCK_TOLERANCE (CCENERGY); CCENERGY — Minimum absolute value below which parts of the Fock matrix are skipped. Type: conv double; Default: 1e-2. FOLLOW (STABILITY); STABILITY — Do follow the most negative eigenvalue of the Hessian towards a lower energy HF solution? Follow a UHF UHF instability of same symmetry?. Type: boolean; Default: false. FOLLOW_ROOT (CCLAMBDA); CCLAMBDA — Root to get OPDM. Type: integer; Default: 1. FOLLOW_ROOT (DETCI); DETCI — The root to write out the two-particle density matrix for (the one-particle density matrices are written for all roots). Useful for a state-specific CASSCF or CI optimization on an excited state. Type: integer; Default: 1. FOLLOW_ROOT (MCSCF); MCSCF — Which solution of the SCF equations to find, where 1 is the SCF ground state. Type: integer; Default: 1. FOLLOW_ROOT (PSIMRCC); PSIMRCC — Which root of the effective hamiltonian is the target state?. Type: integer; Default: 1. FOLLOW_STEP_SCALE (SCF); SCF (Expert) — When using STABILITY_ANALYSIS = FOLLOW, how much to scale the step along the eigenvector by. Type: double; Default: 0.5. FOLLOW_VECTOR (DETCI); DETCI (Expert) — In following a particular root (see FOLLOW_ROOT), sometimes the root number changes. To follow",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodoc_glossary_options_c-1.html:45639,energy,energy,45639,psi4manual/4.0b5/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodoc_glossary_options_c-1.html,2,['energy'],['energy']
Energy Efficiency,"ng aligner on enantiomers based on Table 1 of 10.1021/ci100219f aka J Chem Inf Model 2010 50(12) 2129-2140. dfomp3-grad2; DF-OMP3 cc-pVDZ gradients for the H2O+ cation. omp2-grad1; OMP2 cc-pVDZ gradient for the H2O molecule. fsapt-terms; F-SAPT0/jun-cc-pvdz procedure for methane dimer. dfccsdl1; DF-CCSDL cc-pVDZ energy for the H2O molecule. pywrap-freq-e-sowreap; Finite difference of energies frequency, run in sow/reap mode. pywrap-db2; Database calculation, run in sow/reap mode. zaptn-nh2; ZAPT(n)/6-31G NH2 Energy Point, with n=2-25. decontract; RHF/cc-pvdz-decontract HCl single-point energy Testing the in line -decontract option for basis sets. dft-custom; DFT custom functional test. basis-ecp; check mixing ECP and non-ECP orbital/fitting basis sets in a session. adc2; ADC(2)/aug-cc-pVDZ on two water molecules that are distant from 1000 angstroms from each other. cubeprop-esp; RHF orbitals and density for water. scf4; RHF cc-pVDZ energy for water, automatically scanning the symmetric stretch and bending coordinates using Python’s built-in loop mechanisms. The geometry is specified using a Z-matrix with variables that are updated during the potential energy surface scan, and then the same procedure is performed using polar coordinates, converted to Cartesian coordinates. dct-grad4; Unrestricted DF-DCT ODC-12 gradient for O2 with cc-pVTZ/cc-pVTZ-RI standard/auxiliary basis set. fsapt-allterms; This test case shows an example of running and analyzing a standard F-SAPT0/jun-cc-pvdz procedure for HSG-18-dimer from the HSG database. dct-grad2; RHF-ODC-12 analytic gradient computations for H2O use AO_BASIS=DISK and AO_BASIS=NONE, respectively. RHF-ODC-06 analytic gradient computations for H2O use AO_BASIS=DISK and AO_BASIS=NONE, respectively. cisd-h2o-clpse; 6-31G** H2O Test CISD Energy Point with subspace collapse. omp3-1; OMP3 cc-pVDZ energy for the H2O molecule. omp2-4; SCS-OMP2 cc-pVDZ geometry optimization for the H2O molecule. scf-guess-read1; Sample UHF/cc-pVDZ H2",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html:43475,energy,energy,43475,psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"ng best practices options, part i. cfour/sp-uhf-ccsd_t_-ao; single-point CCSD(T)/qz2p on NH2 with aobasis. cfour/sp-rohf-ccsd_t_-ao; single-point CCSD(T)/qz2p on NH2 with aobasis. cfour/sp-rohf-ccsd-ao; single-point CCSD/qz2p on NH2 with aobasis. cfour/kw-7; Translating psi4 options to cfour, part i. cfour/sp-rohf-ccsdt; single-point CCSDT/qz2p on NH2. cfour/sp-uhf-ccsd_t_-ao-ecc; single-point CCSD(T)/qz2p on NH2 with ecc, aobasis. cfour/kw-3; Basis set spherical/Cartesian with cfour_basis and cfour_spherical. cfour/sp-rohf-mp2-sc; single-point MP2/qz2p on NH2. cfour/sp-uhf-mp2; single-point MP2/qz2p on NH2. cfour/opt-rhf-mp2; optimization MP2/cc-pvtz on water. cfour/psi-mp4; MP4 energy components. Checks that computed identically between cfour and psi4. cfour/sp-uhf-ccsd; single-point CCSD/qz2p on NH2. cfour/sp-rhf-ccsd_t_-ao; single-point CCSD(T)/qz2p on water with aobasis. cfour/sp-rohf-ccsd_t_-fc; single-point CCSD(T)/qz2p on NH2 with ecc, aobasis, frozen-core. cfour/psi-rhf-mp3; MP3 energy components. Checks that computed identically between cfour and psi4. cfour/pywrap-cbs1; Various basis set extrapolation tests only in Cfour instead of Psi4. cfour/sp-rohf-ccsd; single-point CCSD/qz2p on NH2. cfour/puream; Basis set spherical/Cartesian behavior in cfour. cfour/mints5-grad; geometry after three optimization cycles for a variety of input formats, references from psi4. cfour/psi-rohf-scsmp2; ROHF MP2 energy components. Checks that computed identically between cfour and psi4. cfour/opt-rhf-scf; optimization HF/svp on water. cfour/sp-rohf-ccsd_t_-ao-ecc; single-point CCSD(T)/qz2p on NH2 with ecc, aobasis. cfour/mp2-1; All-electron MP2 6-31G** geometry optimization of water. cfour/sp-uhf-scf; single-point HF/qz2p on NH2. cfour/opt-rhf-ccsd_t_-ecc; optimization CCSD(T)/dzp on water with ecc, aobasis. cfour/psi-uhf-mp3; UHF MP3 energy components. Checks that converted identically between cfour and psi4. cfour/sp-rhf-ccsd; single point CCSD/qz2p on water. cfour/sp-rhf-",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_cfour-1.html:1175,energy,energy,1175,psi4manual/1.2.1/autodoc_testsuite_cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_cfour-1.html,6,['energy'],['energy']
Energy Efficiency,"ng due to file weirdness). omp3-5; SOS-OMP3 cc-pVDZ geometry optimization for the H2O molecule. adc1; ADC/6-31G** on H2O. cc9; UHF-CCSD(T) cc-pVDZ frozen-core energy for the state of the CN radical, with Z-matrix input. pubchem1; Benzene vertical singlet-triplet energy difference computation, using the PubChem database to obtain the initial geometry, at the UHF an ROHF levels of theory. cc44; Test case for some of the PSI4 out-of-core codes. The code is given only 2.0 MB of memory, which is insufficient to hold either the A1 or B2 blocks of an ovvv quantity in-core, but is sufficient to hold at least two copies of an oovv quantity in-core. cc35; CC3(ROHF)/cc-pVDZ H2O geom from Olsen et al., JCP 104, 8007 (1996). omp2-4; SCS-OMP2 cc-pVDZ geometry optimization for the H2O molecule. mp2_5-grad2; MP2.5 cc-pVDZ gradient for the NO radical. cc9a; ROHF-CCSD(T) cc-pVDZ energy for the state of the CN radical, with Z-matrix input. dfmp2-2; Density fitted MP2 energy of H2, using density fitted reference and automatic looping over cc-pVDZ and cc-pVTZ basis sets. Results are tabulated using the built in table functions by using the default options and by specifiying the format. omp2-grad1; OMP2 cc-pVDZ gradient for the H2O molecule. cc1; RHF-CCSD 6-31G** all-electron optimization of the H2O molecule. scf4; RHF cc-pVDZ energy for water, automatically scanning the symmetric stretch and bending coordinates using Python’s built-in loop mechanisms. The geometry is apecified using a Z-matrix with variables that are updated during the potential energy surface scan, and then the same procedure is performed using polar coordinates, converted to Cartesian coordinates. cisd-h2o-clpse; 6-31G** H2O Test CISD Energy Point with subspace collapse. omp2-3; OMP2 cc-pVDZ energy for the NO radical. cepa1; cc-pvdz H2O Test CEPA(1) Energy. cc24; Single point gradient of 1-2B1 state of H2O+ with EOM-CCSD. dftd3-grad; DF-BP86-D2 cc-pVDZ frozen core gradient of S22 HCN, calling Grimme’s dftd3 program fo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodoc_testsuite-1.html:19428,energy,energy,19428,psi4manual/4.0b4/autodoc_testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodoc_testsuite-1.html,4,['energy'],['energy']
Energy Efficiency,"ng fragment C. Briefly, the interaction between the point charges in A(B); and fragment B(A) enters the SAPT0 interaction energy. It explicitly affects the electrostatics; and induction components, and implicitly affects other SAPT0 components by polarizing the orbitals.; If point charges are present in both subsystems A and B, an additional charge-charge interaction; term is also added to the electrostatic energy. When point charges are assigned to subsystem C, the point; charges in C only polarize the orbitals in both fragment A and B. However, the presence of charges in C does not; directly contribute to the SAPT0 interaction energy.; Examples fsapt-ext-abc and fsapt-ext-abc2; illustrate the use of point charges in F/I-SAPT procedure. Link Orbital Partitioning in I-SAPT¶; The assignment of the A-C and B-C linking electron pairs is controlled by the FISAPT_LINK_ASSIGNMENT; keyword. The default setting fisapt_link_assignment c assigns the entire pair to the linker C together with; a +1 nuclear charge from the connecting atoms of A/B to preserve the electrical neutrality of each fragment.; However, as already noticed in [Parrish:2015:051103], such a partitioning might result in unphysical dipole; moments at the interfragment boundaries. Imagine, for example, that I-SAPT is used to examine the interaction; of two methyl groups connected by some linker fragment. When the linking bonds are assigned to C, the carbon atoms; of the methyl groups are missing electrons on one of their sp^3 hybrid orbitals and a dipole moment appears.; These dipole moments have been observed to lead, in some cases, to I-SAPT energy contributions that do not make; physical sense, for example, to a strongly repulsive electrostatic energy between two fragments connected by an; intramolecular hydrogen bond.; To overcome this issue, Luu and Patkowski proposed a reassignment of the linking electron pairs so that each fragment; (C and A/B) gets one electron [Luu:2023:356]. This electron is placed on",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/fisapt.html:13273,charge,charge,13273,psi4manual/1.8.x/fisapt.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/fisapt.html,3,['charge'],['charge']
Energy Efficiency,"ng has been done to match supplemental info of Szalewicz et. al., Phys. Rev. Lett., 103, 263201 (2009) and Szalewicz et. al., J. Phys. Chem. Lett., 1, 550-555 (2010). omp3-grad2; OMP3 cc-pVDZ gradient for the NO radical. isapt2; This is a shorter version if isapt1 - does not do cube plots. See isapt1 for full details. decontract; RHF/cc-pvdz-decontract HCl single-point energy Testing the in line -decontract option for basis sets. psimrcc-ccsd_t-2; Mk-MRCCSD(T) single point. \(^1A_1\) CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. cc22; ROHF-EOM-CCSD/DZ on the lowest two states of each irrep in \(^{3}B_1\) CH2. scf-bz2; Benzene Dimer Out-of-Core HF/cc-pVDZ. fd-freq-energy; SCF STO-3G finite-difference frequencies from energies for H2O. dct4; DCT calculation for the HF+ using DC-06 functional. This performs both two-step and simultaneous update of the orbitals and cumulant using DIIS extrapolation. Four-virtual integrals are first handled in the MO Basis for the first two energy computations. In the next two the ao_basis=disk algorithm is used, where the transformation of integrals for four-virtual case is avoided. The computation is then repeated using the DC-12 functional with the same algorithms. castup1; Test of SAD/Cast-up (mainly not dying due to file weirdness). cc29; CCSD/cc-pVDZ optical rotation calculation (both gauges) on Cartesian H2O2. fsapt-ext-abc-au; analog of fsapt-ext-abc with molecule and external potentials in Bohr. dfomp2-4; OMP2 cc-pVDZ energy for the NO molecule. fci-h2o; 6-31G H2O Test FCI Energy Point. mp2-grad1; MP2 cc-pVDZ gradient for the H2O molecule. cepa1; cc-pvdz H2O Test CEPA(1) Energy. ao-casscf-sp; CASSCF/6-31G** energy point. dft-custom-gga; DFT (LDA/GGA) test of custom implementations in: gga_superfuncs.py. cbs-xtpl-opt; Various extrapolated optimization methods for the H2 molecule. tdscf-6; td-camb3lyp with DiskDF and method/basis specification. cubeprop; RHF orbitals and density for wate",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html:12697,energy,energy,12697,psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"ng interface of Psi4 core; class CoreStream:; def write(self, text):; core.print_out(text). core.print_out(""\n"" + adcc.banner(colour=False) + ""\n""); try:; state = adcrunner[name](ref_wfn, **kwargs, output=CoreStream()); except InvalidReference as ex:; raise ValidationError(""Cannot run adcc because the passed reference wavefunction is ""; ""not supported in adcc. Check Psi4 SCF parameters. adcc reports: ""; f""{ex}""); except Exception as ex:; raise ValidationError(""Unknown exception occured while ""; f""running adcc: '{ex}' ({type(ex).__name__})""); core.print_out(""\n""). # TODO Should a non-converged calculation throw?. #; # Interpret results; #; # Note: This wavefunction is not consistent ... the density; # is e.g. not the proper one (i.e. not the MP(n) one); adc_wfn = core.Wavefunction(ref_wfn.molecule(), ref_wfn.basisset()); adc_wfn.shallow_copy(ref_wfn); adc_wfn.set_reference_wavefunction(ref_wfn); adc_wfn.set_name(name); adc_wfn.set_module(""adcc""). # MP(3) energy for CVS-ADC(3) calculations is still a missing feature in adcc; # ... we store this variant here to be able to fall back to MP(2) energies.; is_cvs_adc3 = state.method.level >= 3 and state.ground_state.has_core_occupied_space. # Ground-state energies; mp = state.ground_state; mp_energy = mp.energy(state.method.level if not is_cvs_adc3 else 2); mp_corr = 0.0; if state.method.level > 1:; core.print_out(""Ground state energy breakdown:\n""); core.print_out("" Energy SCF {0:15.8g} [Eh]\n"".format(ref_wfn.energy())); for level in range(2, state.method.level + 1):; if level >= 3 and is_cvs_adc3:; continue; energy = mp.energy_correction(level); mp_corr += energy; adc_wfn.set_variable(f""MP{level} CORRELATION ENERGY"", energy); adc_wfn.set_variable(f""MP{level} TOTAL ENERGY"", mp.energy(level)); core.print_out(f"" Energy correlation MP{level} {energy:15.8g} [Eh]\n""); core.print_out("" Energy total {0:15.8g} [Eh]\n"".format(mp_energy)); adc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", mp_corr) # P::e ADC; adc_wfn.set_variable(""C",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:117438,energy,energy,117438,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,10,['energy'],['energy']
Energy Efficiency,"ng on the nature of the variable, this may or may not make any physical sense.\n""""""; for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); VRXN[db_rxn] = {}. for envv in db_tabulate:; envv = envv.upper(); tables += """"""\n ==> %s <==\n\n"""""" % (envv.title()); tables += _tblhead(maxrgt, table_delimit, 2). for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn). if FAIL[rxn]:; tables += """"""\n%23s %8s %8s %8s %8s"""""" % (db_rxn, '', '****', '', ''); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (VRGT[ACTV[db_rxn][i]][envv], RXNM[db_rxn][ACTV[db_rxn][i]]). else:; VRXN[db_rxn][envv] = 0.0; for i in range(len(ACTV[db_rxn])):; VRXN[db_rxn][envv] += VRGT[ACTV[db_rxn][i]][envv] * RXNM[db_rxn][ACTV[db_rxn][i]]. tables += """"""\n%23s %16.8f """""" % (db_rxn, VRXN[db_rxn][envv]); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (VRGT[ACTV[db_rxn][i]][envv], RXNM[db_rxn][ACTV[db_rxn][i]]); tables += """"""\n %s\n"""""" % (table_delimit). # tabulate primary requested energy variable with statistics; count_rxn = 0; minDerror = 100000.0; maxDerror = 0.0; MSDerror = 0.0; MADerror = 0.0; RMSDerror = 0.0. tables += """"""\n ==> %s <==\n\n"""""" % ('Requested Energy'); tables += _tblhead(maxrgt, table_delimit, 1); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn). if FAIL[rxn]:; tables += """"""\n%23s %8.4f %8s %10s %10s"""""" % (db_rxn, BIND[db_rxn], '****', '****', '****'); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). else:; ERXN[db_rxn] = 0.0; for i in range(len(ACTV[db_rxn])):; ERXN[db_rxn] += ERGT[ACTV[db_rxn][i]] * RXNM[db_rxn][ACTV[db_rxn][i]]; error = constants.hartree2kcalmol * ERXN[db_rxn] - BIND[db_rxn]. tables += """"""\n%23s %8.4f %8.4f %10.4f %10.4f"""""" % (db_rxn, BIND[db_rxn], constants.hartree2kcalmol * ERXN[db_rxn],; error, error * constants.cal2J); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). if abs(error) < abs(minD",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/wrapper_database.html:26039,energy,energy,26039,psi4manual/1.3.2/_modules/psi4/driver/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/wrapper_database.html,17,['energy'],['energy']
Energy Efficiency,"ng on the nature of the variable, this may or may not make any physical sense.\n""""""; for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); VRXN[db_rxn] = {}. for envv in db_tabulate:; envv = envv.upper(); tables += """"""\n ==> %s <==\n\n"""""" % (envv.title()); tables += _tblhead(maxrgt, table_delimit, 2). for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn). if FAIL[rxn]:; tables += """"""\n%23s %8s %8s %8s %8s"""""" % (db_rxn, '', '****', '', ''); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (VRGT[ACTV[db_rxn][i]][envv], RXNM[db_rxn][ACTV[db_rxn][i]]). else:; VRXN[db_rxn][envv] = 0.0; for i in range(len(ACTV[db_rxn])):; VRXN[db_rxn][envv] += VRGT[ACTV[db_rxn][i]][envv] * RXNM[db_rxn][ACTV[db_rxn][i]]. tables += """"""\n%23s %16.8f """""" % (db_rxn, VRXN[db_rxn][envv]); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (VRGT[ACTV[db_rxn][i]][envv], RXNM[db_rxn][ACTV[db_rxn][i]]); tables += """"""\n %s\n"""""" % (table_delimit). # tabulate primary requested energy variable with statistics; count_rxn = 0; minDerror = 100000.0; maxDerror = 0.0; MSDerror = 0.0; MADerror = 0.0; RMSDerror = 0.0. tables += """"""\n ==> %s <==\n\n"""""" % ('Requested Energy'); tables += _tblhead(maxrgt, table_delimit, 1); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn). if FAIL[rxn]:; tables += """"""\n%23s %8.4f %8s %10s %10s"""""" % (db_rxn, BIND[db_rxn], '****', '****', '****'); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). else:; ERXN[db_rxn] = 0.0; for i in range(len(ACTV[db_rxn])):; ERXN[db_rxn] += ERGT[ACTV[db_rxn][i]] * RXNM[db_rxn][ACTV[db_rxn][i]]; error = p4const.psi_hartree2kcalmol * ERXN[db_rxn] - BIND[db_rxn]. tables += """"""\n%23s %8.4f %8.4f %10.4f %10.4f"""""" % (db_rxn, BIND[db_rxn], p4const.psi_hartree2kcalmol * ERXN[db_rxn],; error, error * p4const.psi_cal2J); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). if abs(error) < ab",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:25980,energy,energy,25980,psi4manual/1.0.0/_modules/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html,1,['energy'],['energy']
Energy Efficiency,"ng pre-c1-constructed BasisSet *basis. compute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. cphf_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix]) → List[psi4.core.Matrix]¶; CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self: psi4.core.HF) → bool¶; Adds occupied guess alpha orbitals. cphf_solve(self: psi4.core.HF, x_vec: List[psi4.core.Matrix], conv_tol: float, max_iter: int, print_lvl: int=2) → List[psi4.core.Matrix]¶; Solves the CPHF equations for a given set of x vectors. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Deep copies the internal data. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunctions energy. epsilon_a(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Alpha Eigenvalues subset. epsilon_b(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Beta Eigenvalues subset. esp_at_nuclei(self: psi4.core.Wavefunction) → psi4.core.Vector¶; returns electrostatic potentials at nuclei. finalize_E(self: psi4.core.HF) → float¶; Computes the final SCF energy. force_doccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶; Specialized expert use only. Sets the number of doubly occupied oribtals per irrep. Note that this results in inconsistent Wavefunction objects for SCF, so caution is advised. force_soccpi(self: psi4.core.Wavef",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/psi4api-1.html:72787,energy,energy,72787,psi4manual/1.2.1/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html,2,['energy'],['energy']
Energy Efficiency,"ng stages are active. .. include:: cbs_eqn.rst. * Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy. The cbs() function requires, at a minimum, ``name='scf'`` and ``scf_basis``; keywords to be specified for reference-step only jobs and ``name`` and; ``corl_basis`` keywords for correlated jobs. The following energy methods have been set up for cbs(). .. hlist::; :columns: 5. * scf; * df-scf; * mp2; * df-mp2; * cc2; * ccsd; * bccd; * cc3; * ccsd(t); * fci. :type name: string; :param name: ``'scf'`` || ``'ccsd'`` || etc. First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be ``'scf'``. Overruled if stage_wfn keywords supplied. :type corl_wfn: string; :param corl_wfn: ``'mp2'`` || ``'ccsd(t)'`` || etc. Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with ``name`` or as the unlabeled; first argument to the function. :type delta_wfn: string; :param delta_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. :type delta_wfn_lesser: string; :param delta_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd'`` || etc. Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. :type delta2_wfn: string; :param delta2_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta2_wfn_lesser: string; :param delta2_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. * Basis Sets; Currently, the basis set se",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:53500,energy,energy,53500,psi4manual/4.0b2/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html,4,['energy'],['energy']
Energy Efficiency,"ng that the form of the exchange correlation energy is an integral; over all of space of a function depending only on local information in the; density, such as the density value or derivatives. The simplest variants are; Local Spin-Density Approximations (LSDA), which depend only on the spin density; or ,. The most popular variants are Generalized Gradient Approximation (GGA); functionals which use the norm of the density gradient; , or; to build an inhomogeneity; parameter. where,. GGA functionals are essentially the same cost as LSDA functionals, and are often; considerably more accurate.; Another local variant which has gained some popularity (though perhaps not as; much as GGA functionals) is the meta approximation, in which information about; the second derivative of the density is incorporated. The most canonical variant; of these functionals rely on the spin kinetic energy density ; and ,. A generic local meta-GGA functional may then be written as,. The potential corresponding to this energy functional is,. This potential is used to build the Kohn-Sham matrix,. which is diagonalized to form the Kohn-Sham orbitals in the same manner as in; Hartree-Fock.; In practice the local functional kernel and its required; partial derivatives are exceedingly complex, and are not analytically; integrable. In this case, atom-centered numerical quadratures are used to; evaluate the Kohn-Sham potentials and energies to a high degree of accuracy. The; evaluation of these numerical integrals can be made to be linear scaling with a; reasonable amount of cleverness (mostly related to the fact that the basis; functions decay exponentially), meaning that the Coulomb and diagonalization; steps become rate limiting. This enormous potential speed gain over Hartree-Fock; with potentially exact treatment of electron correlation for “free” was one of; the primary motivations for KS-DFT’s adoption by chemists in the late 1980s and; early 1990s.; Unfortunately, local KS-DFT exhibits severa",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/dft-1.html:3091,energy,energy,3091,psi4manual/1.0.0/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/dft-1.html,10,['energy'],['energy']
Energy Efficiency,"ng the above two equations into the energy expression, we obtain:. where the antisymmetrized two-electron integrals and the generalized Fock operator; matrix elements were defined as follows:. Energy functional has several important properties. First,; the energy is now a function of two types of independent parameters, the; idempotent part of OPDM and the density cumulant; . As a result, the energy functional is Hermitian,; which is important for the evaluation of the molecular properties. The additive; separability of the density cumulant guarantees that all of the DCFT methods; are size-extensive and size-consistent. Furthermore, the N-representability; problem is now greatly simplified, because the idempotent part of the OPDM is; N-representable by construction. One only needs to worry about the; N-representability of the density cumulant, which is a relatively small part of; the TPDM.; In order to obtain the DCFT energy, two conditions must be satisfied:; 1) The energy must be stationary with respect to the variation of the; idempotent part of the one-particle density matrix . This is; achieved by the self-consistent diagonalization of the generalized Fock; operator matrix defined above, which introduces the relaxation of the orbitals.; 2) The energy must be stationary with respect to the variation of the density; cumulant , constrained to the N-representability conditions.; Making the energy stationary requires the solution of the two sets of coupled; equations for the orbital and cumulant updates, respectively (also known as; residual equations). At the present moment three different algorithms for the; solution of the system of coupled equations are available (see section; Iterative Algorithms for details).; Publications resulting from the use of the DCFT code should cite contributions; listed here. Methods¶; Currently two DCFT methods (functionals) are available: DC-06 and DC-12. Both; methods use approximate N-representability conditions derived from the; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/dcft-1.html:2894,energy,energy,2894,psi4manual/4.0b4/dcft-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/dcft-1.html,8,['energy'],['energy']
Energy Efficiency,"ng the true -body quantum; effects. The former idea allows the electronic density to be dealt with instead; of the much more complicated wavefunction, while the latter allows for the; treatment of the troublesome kinetic energy term via the implicit one-body; Kohn-Sham orbitals. KS-DFT borrows much of the machinery of Hartree-Fock, as is; evident by looking at the energy expression,. Here is the noninteracting quasiparticle kinetic energy operator,; is the nucleus-electron attraction potential, ; is the total electron density matrix, and is the (potentially nonlocal) exchange, correlation, and residual; kinetic energy functional. The residual kinetic energy term is usually quite; small, and is often ignored, hence is often referred to; as simply the exchange-correlation functional (exchange and correlation, not; just exchange-type correlation).; In practice, the first few generations of KS-DFT functionals were chosen to be; local, meaning that the form of the exchange correlation energy is an integral; over all of space of a function depending only on local information in the; density, such as the density value or derivatives. The simplest variants are; Local Spin-Density Approximations (LSDA), which depend only on the spin density; or ,. The most popular variants are Generalized Gradient Approximation (GGA); functionals which use the norm of the density gradient; , or; to build an inhomogeneity; parameter. where,. GGA functionals are essentially the same cost as LSDA functionals, and are often; considerably more accurate.; Another local variant which has gained some popularity (though perhaps not as; much as GGA functionals) is the meta approximation, in which information about; the second derivative of the density is incorporated. The most canonical variant; of these functionals rely on the spin kinetic energy density ; and ,. A generic local meta-GGA functional may then be written as,. The potential corresponding to this energy functional is,. This potential is u",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/dft-1.html:2128,energy,energy,2128,psi4manual/1.0.0/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/dft-1.html,10,['energy'],['energy']
Energy Efficiency,"ng. so_quadrupole(self: psi4.core.MintsHelper) → List[psi4.core.Matrix]¶; docstring. so_traceless_quadrupole(self: psi4.core.MintsHelper) → List[psi4.core.Matrix]¶; docstring. sobasisset(self: psi4.core.MintsHelper) → psi::SOBasisSet¶; docstring. class psi4.core.MoldenWriter¶; Bases: object; docstring. write(self: psi4.core.MoldenWriter, arg0: str, arg1: psi4.core.Matrix, arg2: psi4.core.Matrix, arg3: psi4.core.Vector, arg4: psi4.core.Vector, arg5: psi4.core.Vector, arg6: psi4.core.Vector, arg7: bool) → None¶; docstring. class psi4.core.Molecule¶; Bases: object; Class to store the elements, coordinates, fragmentation pattern, basis sets, charge, multiplicity, etc. of a molecule. BFS()¶; Perform a breadth-first search (BFS) on the real atoms; in molecule, returning an array of atom indices of fragments.; Relies upon van der Waals radii and so faulty for close; (esp. hydrogen-bonded) fragments. Original code from; Michael S. Marshall. Z(self: psi4.core.Molecule, arg0: int) → float¶; Nuclear charge of atom arg1 (0-indexed). activate_all_fragments(self: psi4.core.Molecule) → None¶; Sets all fragments in the molecule to be active. add_atom(self: psi4.core.Molecule, arg0: int, arg1: float, arg2: float, arg3: float, arg4: str, arg5: float, arg6: float, arg7: int) → None¶; Adds to Molecule arg0 an atom with atomic number arg1, Cartesian coordinates in Bohr (arg2, arg3, arg4), atomic symbol arg5, mass arg6, charge arg7 (optional), and lineno arg8 (optional). atom_at_position(self: psi4.core.Molecule, arg0: float, arg1: float) → int¶; Tests to see if an atom is at the position arg2 with a given tolerance arg3. center_of_mass(self: psi4.core.Molecule) → psi4.core.Vector3¶; Computes center of mass of molecule (does not translate molecule). charge(self: psi4.core.Molecule, arg0: int) → float¶; Gets charge of atom arg1 (0-indexed). clone(self: psi4.core.Molecule) → psi4.core.Molecule¶; Returns a new Molecule identical to arg0. create_molecule_from_string(arg0: str) → psi4.core.Mol",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psi4api-1.html:78214,charge,charge,78214,psi4manual/1.1.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psi4api-1.html,2,['charge'],['charge']
Energy Efficiency,"ng.""""""; if self.negate:; return '-' + self.PYname; else:; return self.PYname. [docs] def everything(self):; print('\nVariableValue\n Fixed = %s\n Computed = %s\n Type = %s\n Value = %f\n FValue = %s\n Name = %s\n Negated = %s\n Map = %s\n\n' %; (self.PYfixed, self.computed, self.type(), self.compute(), self.variable_to_string(4), self.name(), self.negated(), self.geometryVariables)). [docs]class CoordEntry(object):; """"""Class to store all the attributes associated with an atom, not the; larger Molecule. Specialized into CartesianEntry and ZMatrixEntry. """""". def __init__(self, entry_number, Z, charge, mass, symbol, label="""", basis=None, shells=None):; """"""Constructor""""""; # Order in full atomic list; self.PYentry_number = entry_number; # Whether the coordinates have been computed; self.computed = False; # Actual cartesian coordinates of the atom; self.coordinates = [None, None, None]; # Atomic number of the atom; self.PYZ = Z; # Charge of the atom (SAD-related); self.PYcharge = charge; # Mass of the atom; self.PYmass = mass; # Label of the atom minus any extra info (H1 => H); self.PYsymbol = symbol; # Original label from the molecule from the input file (H1); self.PYlabel = label; # Is this a ghost atom?; self.ghosted = False; # Different types of basis sets that can be assigned to this atom.; self.PYbasissets = basis if basis is not None else OrderedDict(); # Hash of one-atom BasisSet attached to this atom; self.PYshells = shells if shells is not None else OrderedDict(). @staticmethod; [docs] def r(a1, a2):; """"""Computes the distance between two sets of coordinates""""""; if len(a1) != 3 or len(a2) != 3:; raise ValidationError('ERROR: r() only defined for Vector3\n'); return distance(a1, a2). @staticmethod; [docs] def a(a1, a2, a3):; """"""Computes the angle (in rad.) between three sets of coordinates.""""""; if len(a1) != 3 or len(a2) != 3 or len(a3) != 3:; raise ValidationError('ERROR: a() only defined for Vector3\n'); eBA = sub(a2, a1); eBC = sub(a2, a3); eBA = normalize(eBA)",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html:5944,charge,charge,5944,psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html,1,['charge'],['charge']
Energy Efficiency,ng; :param corl_wfn: ``'mp2'`` || ``'ccsd(t)'`` || etc. Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with ``name`` or as the unlabeled; first argument to the function. :type delta_wfn: string; :param delta_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. :type delta_wfn_lesser: string; :param delta_wfn_lesser: |dl| ``corl_wfn`` |dr| || ``'mp2'`` || etc. Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. :type delta2_wfn: string; :param delta2_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta2_wfn_lesser: string; :param delta2_wfn_lesser: |dl| ``delta_wfn`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta3_wfn: string; :param delta3_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a third delta correction; to the correlation energy is to be obtained. :type delta3_wfn_lesser: string; :param delta3_wfn_lesser: |dl| ``delta2_wfn`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a third delta correction; to the correlation energy is to be obtained. :type delta4_wfn: string; :param delta4_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a fourth delta correction; to the correlation energy is to be obtained. :type delta4_wfn_lesser: string; :param delta4_wfn_lesser: |dl| ``delta3_wfn`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a fourth delta correction; to the correlation energy is to be obtained. :type delta5_wfn: string; :param delta5_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. I,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:21421,energy,energy,21421,psi4manual/1.0.0/_modules/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html,6,['energy'],['energy']
Energy Efficiency,"ng; C++ signature :. d compute_energy(N3psi12WavefunctionE {lvalue}). psi4.HF.compute_gradient()¶; Python Library Documentation: method compute_gradient; compute_gradient(...) unbound psi4.HF method. compute_gradient( (Wavefunction)arg1) -> Matrix :. docstring; C++ signature :. N5boost10shared_ptrIN3psi6MatrixEEE compute_gradient(N3psi12WavefunctionE {lvalue}). psi4.HF.deep_copy()¶; Python Library Documentation: method deep_copy; deep_copy(...) unbound psi4.HF method. deep_copy( (Wavefunction)arg1, (Wavefunction)arg2) -> None :. docstring; C++ signature :. void deep_copy(N3psi12WavefunctionE {lvalue},N5boost10shared_ptrIN3psi12WavefunctionEEE). psi4.HF.doccpi()¶; Python Library Documentation: method doccpi; doccpi(...) unbound psi4.HF method. doccpi( (Wavefunction)arg1) -> Dimension :. docstring; C++ signature :. N3psi9DimensionE doccpi(N3psi12WavefunctionE {lvalue}). psi4.HF.energy()¶; Python Library Documentation: method energy; energy(...) unbound psi4.HF method. energy( (Wavefunction)arg1) -> float :. docstring; C++ signature :. d energy(N3psi12WavefunctionE {lvalue}). psi4.HF.epsilon_a()¶; Python Library Documentation: method epsilon_a; epsilon_a(...) unbound psi4.HF method. epsilon_a( (Wavefunction)arg1) -> Vector :. docstring; C++ signature :. N5boost10shared_ptrIN3psi6VectorEEE epsilon_a(N3psi12WavefunctionE {lvalue}). psi4.HF.epsilon_a_subset()¶; Python Library Documentation: method epsilon_a_subset; epsilon_a_subset(...) unbound psi4.HF method. epsilon_a_subset( (Wavefunction)arg1, (str)arg2, (str)arg3) -> Vector :. docstring; C++ signature :. N5boost10shared_ptrIN3psi6VectorEEE epsilon_a_subset(N3psi12WavefunctionE {lvalue},Ss,Ss). psi4.HF.epsilon_b()¶; Python Library Documentation: method epsilon_b; epsilon_b(...) unbound psi4.HF method. epsilon_b( (Wavefunction)arg1) -> Vector :. docstring; C++ signature :. N5boost10shared_ptrIN3psi6VectorEEE epsilon_b(N3psi12WavefunctionE {lvalue}). psi4.HF.epsilon_b_subset()¶; Python Library Documentation: method epsi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:171605,energy,energy,171605,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['energy'],['energy']
Energy Efficiency,"ng; Possible Values: DL, RAYLEIGH; Default: DL. SORTED_TEI_FILE (TRANSQT); TRANSQT — MO-basis sorted two-electron integrals file. Type: integer; Default: PSIF_MO_TEI. SOS_SCALE (OMP2); OMP2 — Spin-opposite scaling (SOS) value for SCF orbitals. Type: double; Default: 1.3. SOS_SCALE (OMP3); OMP3 — Spin-opposite scaling (SOS) value for SCF orbitals. Type: double; Default: 1.3. SOS_SCALE2 (OMP2); OMP2 — Spin-opposite scaling (SOS) value for optimized-MP2 orbitals. Type: double; Default: 1.2. SOS_SCALE2 (OMP3); OMP3 — Spin-opposite scaling (SOS) value for optimized-MP2 orbitals. Type: double; Default: 1.2. SOS_TYPE (OMP2); OMP2 — Type of the SOS method. Type: string; Possible Values: SOS, SOSPI; Default: SOS. SOS_TYPE (OMP3); OMP3 — Type of the SOS method. Type: string; Possible Values: SOS, SOSPI; Default: SOS. SPINADAPT_ENERGIES (CCENERGY); CCENERGY — Do print spin-adapted pair energies?. Type: boolean; Default: false. SS_E_CONVERGENCE (CCEOM); CCEOM — Convergence criterion for excitation energy (change) in the Davidson algorithm for the CIS guess to CC-EOM. Type: conv double; Default: 1e-6. SS_R_CONVERGENCE (CCEOM); CCEOM — Convergence criterion for norm of the residual vector in the Davidson algorithm for the CIS guess to CC-EOM. Type: conv double; Default: 1e-6. SS_SKIP_DIAG (CCEOM); CCEOM — Do skip diagonalization of Hbar SS block?. Type: boolean; Default: false. SS_VECS_PER_ROOT (CCEOM); CCEOM — SS vectors stored per root. Type: integer; Default: 5. STABILITY_ADD_VECTORS (DCFT); DCFT (Expert) — The number of vectors that can be added simultaneously into the subspace for Davidson’s diagonalization in stability check. Type: integer; Default: 20. STABILITY_ANALYSIS (SCF); SCF — Whether to perform stability analysis after convergence. NONE prevents analysis being performed. CHECK will print out the analysis of the wavefunction stability at the end of the computation. FOLLOW will perform the analysis and, if a totally symmetric instability is found, will attemp to foll",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html:117856,energy,energy,117856,psi4manual/4.0b3/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html,2,['energy'],['energy']
Energy Efficiency,"nge Approximation. SAPT SAME-SPIN DISP20 ENERGY¶. SAPT SAME-SPIN EXCH-DISP20 ENERGY¶; The portion of SAPT DISP20 ENERGY or; SAPT EXCH-DISP20 ENERGY resulting from; from same-spin or triplet doubles correlations. SAPT HF(2) ENERGY ABC(HF)¶; The total Hartree–Fock energy [Eh] of the supersystem implemented for F/I-SAPT. SAPT HF(2) ENERGY AC(0)¶; The Hartree–Fock energy [Eh] of subsystems A and C implemented for F/I-SAPT. SAPT HF(2) ENERGY BC(0)¶; The Hartree–Fock energy [Eh] of subsystems B and C implemented for F/I-SAPT. SAPT HF(2) ENERGY A(0)¶; The Hartree–Fock energy [Eh] of subsystem A implemented for F/I-SAPT. SAPT HF(2) ENERGY B(0)¶; The Hartree–Fock energy [Eh] of subsystem B implemented for F/I-SAPT. SAPT HF(2) ENERGY AC(HF)¶; The Hartree–Fock localized energy [Eh] of subsystems A and C implemented for F/I-SAPT. SAPT HF(2) ENERGY BC(HF)¶; The Hartree–Fock localized energy [Eh] of subsystems B and C implemented for F/I-SAPT. SAPT HF(2) ENERGY AB(HF)¶; The Hartree–Fock localized energy [Eh] of subsystems A and B implemented for F/I-SAPT. SAPT HF(2) ENERGY A(HF)¶; The Hartree–Fock localized energy [Eh] of subsystem A implemented for F/I-SAPT. SAPT HF(2) ENERGY B(HF)¶; The Hartree–Fock localized energy [Eh] of subsystem B implemented for F/I-SAPT. SAPT HF(2) ENERGY C¶; The Hartree–Fock energy [Eh] of subsystem C implemented for F/I-SAPT. SAPT HF(2) ENERGY HF¶; The FI-SAPT Hartree–Fock interaction energy [Eh] implemented for F/I-SAPT. SAPT ELST12,R ENERGY¶; An electrostatics-classified SAPT term energy [Eh] implemented for SAPT2. SAPT EXCH11(S^2) ENERGY¶. SAPT EXCH12(S^2) ENERGY¶; An exchange-classified SAPT term energy [Eh] implemented for SAPT2. SAPT IND22 ENERGY¶. SAPT EXCH-IND22 ENERGY¶; An induction-classified SAPT term energy [Eh] implemented for SAPT2. SAPT DISP21 ENERGY¶; A dispersion-classified SAPT term energy [Eh] implemented for SAPT2+. SAPT DISP22(SDQ) ENERGY¶. SAPT DISP22(T) ENERGY¶. SAPT EST.DISP22(T) ENERGY¶; Dispersion-classified MBPT-based SAPT te",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html:37137,energy,energy,37137,psi4manual/1.4.0/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html,5,['energy'],['energy']
Energy Efficiency,"nge(3 * self.nlattice)]; self.lattice = [0.0 for ilat in range(self.nlattice)]; self.set_lattice_field(). # Respond to the >CLATTICE command; def recv_clattice(self, clattice=None):; """""" Receive the coordinates of a set of lattice point charges through MDI. Arguments:; clattice: New coordinates of the lattice of point charges. If None, receive through MDI.; """"""; if clattice is None:; self.clattice = MDI_Recv(3 * self.nlattice, MDI_DOUBLE, self.comm); else:; self.clattice = clattice; self.set_lattice_field(). # Respond to the >LATTICE command; def recv_lattice(self, lattice=None):; """""" Receive the charges of a set of lattice point charges through MDI. Arguments:; lattice: New charges of the lattice of point charges. If None, receive through MDI.; """"""; if lattice is None:; self.lattice = MDI_Recv(self.nlattice, MDI_DOUBLE, self.comm); else:; self.lattice = lattice; self.set_lattice_field(). # Respond to the SCF command; def run_scf(self):; """""" Run an energy calculation; """"""; self.energy = psi4.energy(self.scf_method, **self.kwargs). # Respond to the <DIMENSIONS command; def send_dimensions(self):; """""" Send the dimensionality of the system through MDI. :returns: *dimensions* Dimensionality of the system; """"""; dimensions = [1, 1, 1]; MDI_Send(dimensions, 3, MDI_INT, self.comm); return dimensions. # Respond to the <TOTCHARGE command; def send_total_charge(self):; """""" Send the total system charge through MDI. :returns: *charge* Total charge of the system; """"""; charge = self.molecule.molecular_charge(); MDI_Send(charge, 1, MDI_DOUBLE, self.comm); return charge. # Respond to the >TOTCHARGE command; def recv_total_charge(self, charge=None):; """""" Receive the total system charge through MDI. Arguments:; charge: New charge of the system. If None, receive through MDI.; """"""; if charge is None:; charge = MDI_Recv(1, MDI_DOUBLE, self.comm); self.molecule.set_molecular_charge(int(round(charge))). # Respond to the <ELEC_MULT command; def send_multiplicity(self):; """""" Send the electro",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html:10377,energy,energy,10377,psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html,14,['energy'],['energy']
Energy Efficiency,"nge-scaling with F-SAPT. Type: boolean; Default: false. STABILITY_ADD_VECTORS (DCFT); DCFT (Expert) — The number of vectors that can be added simultaneously into the subspace for Davidson’s diagonalization in stability check. Type: integer; Default: 20. STABILITY_ANALYSIS (SCF); SCF — Whether to perform stability analysis after convergence. NONE prevents analysis being performed. CHECK will print out the analysis of the wavefunction stability at the end of the computation. FOLLOW will perform the analysis and, if a totally symmetric instability is found, will attempt to follow the eigenvector and re-run the computations to find a stable solution. Type: string; Possible Values: NONE, CHECK, FOLLOW; Default: NONE. STABILITY_AUGMENT_SPACE_TOL (DCFT); DCFT (Expert) — The value of the rms of the residual in Schmidt orthogonalization which is used as a threshold for augmenting the vector subspace in stability check. Type: conv double; Default: 0.1. STABILITY_CHECK (DCFT); DCFT (Expert) — Performs stability analysis of the DCFT energy. Type: boolean; Default: false. STABILITY_CONVERGENCE (DCFT); DCFT (Expert) — Controls the convergence of the Davidson’s diagonalization in stability check. Type: conv double; Default: 1e-4. STABILITY_MAX_SPACE_SIZE (DCFT); DCFT (Expert) — The maximum size of the subspace for the stability check. The program will terminate if this parameter is exceeded and the convergence (STABILITY_CONVERGENCE) is not satisfied. Type: integer; Default: 200. STABILITY_N_EIGENVALUES (DCFT); DCFT (Expert) — The number of Hessian eigenvalues computed during the stability check. Type: integer; Default: 3. STABILITY_N_GUESS_VECTORS (DCFT); DCFT (Expert) — The number of guess vectors used for Davidson’s diagonalization in stability check. Type: integer; Default: 20. STEP_TYPE (OPTKING); OPTKING — Geometry optimization step type, either Newton-Raphson or Rational Function Optimization. Type: string; Possible Values: RFO, NR, SD, LINESEARCH_STATIC; Default: RFO. SYMM",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html:214127,energy,energy,214127,psi4manual/1.2.1/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html,6,['energy'],['energy']
Energy Efficiency,"nge. set_x_omega(self, arg0); Sets the range-seperation exchange parameter. test_functional(self, arg0, arg1, arg2, ...); Quick testing capabilities. value(self, arg0); Returns a given internal value. values(self); Return all internal values. vv10_b(self); The VV10 b parameter. vv10_c(self); The VV10 c parameter. x_alpha(self); Amount of exact HF exchange. x_beta(self); Amount of exact HF exchange. x_functional(self, arg0); Returns the desired X Functional. x_functionals(self); Returns all X Functionals. x_omega(self); Range-seperated exchange parameter. Methods Documentation. static XC_build(arg0: str, arg1: bool) → psi4.core.SuperFunctional¶; Builds a SuperFunctional from a XC string. add_c_functional(self: psi4.core.SuperFunctional, arg0: psi4.core.Functional) → None¶; Add a correlation Functional. add_x_functional(self: psi4.core.SuperFunctional, arg0: psi4.core.Functional) → None¶; Add a exchange Functional. allocate(self: psi4.core.SuperFunctional) → None¶; Allocates the vectors, should be called after ansatz or npoint changes. ansatz(self: psi4.core.SuperFunctional) → int¶; SuperFunctional rung. static blank() → psi4.core.SuperFunctional¶; Initialize a blank SuperFunctional. c_alpha(self: psi4.core.SuperFunctional) → float¶; Amount of MP2 correlation. c_functional(self: psi4.core.SuperFunctional, arg0: str) → psi4.core.Functional¶; Returns the desired C Functional. c_functionals(self: psi4.core.SuperFunctional) → List[psi4.core.Functional]¶; Returns all C Functionals. c_omega(self: psi4.core.SuperFunctional) → float¶; Range-seperated correlation parameter. c_os_alpha(self: psi4.core.SuperFunctional) → float¶; Amount of SS MP2 correlation. c_ss_alpha(self: psi4.core.SuperFunctional) → float¶; Amount of OS MP2 correlation. citation(self: psi4.core.SuperFunctional) → str¶; SuperFunctional citation. compute_functional(self: psi4.core.SuperFunctional, arg0: Dict[str, psi4.core.Vector], arg1: int) → Dict[str, psi4.core.Vector]¶; Computes the SuperFunctional. density",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.core.superfunctional.html:4318,Allocate,Allocates,4318,psi4manual/1.5.0/api/psi4.core.superfunctional.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.core.superfunctional.html,3,['Allocate'],['Allocates']
Energy Efficiency,"ngle point integral and HF-SCF calculation in order to determine the number and ordering of the irreducible representations. The occupation keyword may be omitted, in which case an initial orbital occupancy is determined by diagonalization of the core Hamiltonian. In many cases, HF-SCF calculations run with the core Hamiltonian guess will usually converge to the lowest energy HF-SCF solution, but this should not be blindly assumed. (Default: The occupation is given by the core Hamiltonian initial guess). Psi4 Interface: The arrays above are specified in PSI as (white space tolerant) [3,1,1,0] and [[3,1,1,0],[3,0,1,0]]. Type: array; Default: No Default. CFOUR_OPEN-SHELL¶. Specifies which kind of open-shell CC treatment is employed. The default is a spin-orbital CC treatment (SPIN-ORBITAL =1) which is the only possible choice for UHF-CC schemes anyways. For ROHF-CC treatments, the possible options are beside the standard spin-orbital scheme a spin-restricted CC approach (SR-CC=3), as well as a corresponding linear approximation (which in the literature usually is referred to as partially-spin-adapted CC scheme) (PSA-CC=1). SR-CC and PSA-CC are within the CCSD approximation restricted to excitations defined by the first-order interacting space arguments. With the keywords PSA-CC_FULL (=2) or SR-CC_FULL (=6) inclusion of the so called “pseudo-triples” beyond the first-order interacting space is also possible. The two-determinant CC method for open-shell singlet states can be activated by TD-CC (=8). Type: string; Possible Values: SPIN-ORBITAL, SR-CC, PSA-CC_FULL, SR-CC_FULL, TD-CC; Default: SPIN-ORBITAL. CFOUR_OPT_MAXCYC¶. Identical to CFOUR_GEO_MAXCYC. Type: integer; Default: 50. CFOUR_ORBITALS¶. Specifies the type of molecular orbitals used in post-HF calculations. STANDARD (=0) requests usage of the orbitals (from a corresponding HF-SCF calculation) without any modification. These are in the case of RHF/UHF the usual canonical HF orbitals and in the case of ROHF calcu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__cfour-1.html:42645,adapt,adapted,42645,psi4manual/1.3.2/autodir_options_c/module__cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__cfour-1.html,24,['adapt'],['adapted']
Energy Efficiency,"ngles and doubles (CCSD) and orbital-optimized; CCD (OD) is similar, the situation is different in the case of triples corrections, especially at stretched; geometries [Bozkaya:2012:odtl]. Bozkaya and Schaefer demonstrated that orbital-optimized coupled cluster based; triple corrections, especially those of asymmetrics, provide significantly better potential energy curves than; CCSD based triples corrections. Theory¶; What follows is a very basic description of orbital-optimized Møller–Plesset perturbation; theory as implemented in PSI4. We will follow our previous presentations ([Bozkaya:2011:omp2],; [Bozkaya:2011:omp3], and [Bozkaya:2012:odtl]); The orbital variations may be expressed by means of an exponential unitary operator. where is the orbital rotation operator. The effect of the orbital rotations on the MO coefficients can be written as. where is the initial MO coefficient matrix and is the new; MO coefficient matrix as a function of .; Now, let us define a variational energy functional (Lagrangian) as a function of . OMP2. OMP3. OCEPA. where subscript c means only connected diagrams are allowed, and; , , and defined as. where , and are the one- and two-electron components of normal-ordered Hamiltonian. Then,; first and second derivatives of the energy with respect to the parameter at . Then the energy can be expanded up to second-order as follows. where is the MO gradient vector, is the MO rotation vector,; and is the MO Hessian matrix. Therefore, minimizing the energy with respect to ; yields. This final equation corresponds to the usual Newton-Raphson step.; Publications resulting from the use of the OMP2 code should cite the following publication(s):; [Bozkaya:2011:omp2].; Publications resulting from the use of the OMP3 code should cite the following publications:; [Bozkaya:2011:omp3] and [Bozkaya:2013:omp3].; Publications resulting from the use of the OMP2.5 code should cite the following publications:; [Bozkaya:2011:omp3] and [Bozkaya:2013:omp3].; Pub",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/occ-1.html:3530,energy,energy,3530,psi4manual/4.0b4/occ-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/occ-1.html,2,['energy'],['energy']
Energy Efficiency,"ngles and doubles (CCSD) and orbital-optimized; CCD (OD) is similar, the situation is different in the case of triples corrections, especially at stretched; geometries [Bozkaya:2012:odtl]. Bozkaya and Schaefer demonstrated that orbital-optimized coupled cluster based; triple corrections, especially those of asymmetrics, provide significantly better potential energy curves than; CCSD based triples corrections. Theory¶; What follows is a very basic description of orbital-optimized Møller–Plesset perturbation; theory as implemented in PSI4. We will follow our previous presentations ([Bozkaya:2011:omp2],; [Bozkaya:2011:omp3], and [Bozkaya:2012:odtl]); The orbital variations may be expressed by means of an exponential unitary operator. where is the orbital rotation operator. The effect of the orbital rotations on the MO coefficients can be written as. where is the initial MO coefficient matrix and is the new; MO coefficient matrix as a function of .; Now, let us define a variational energy functional (Lagrangian) as a function of . OMP2. OMP3. OCEPA. where subscript c means only connected diagrams are allowed, and; , , and defined as. where , and are the one- and two-electron components of normal-ordered Hamiltonian. Then,; first and second derivatives of the energy with respect to the parameter at . Then the energy can be expanded up to second-order as follows. where is the MO gradient vector, is the MO rotation vector,; and is the MO Hessian matrix. Therefore, minimizing the energy with respect to ; yields. This final equation corresponds to the usual Newton-Raphson step.; Publications resulting from the use of the OMP2 code should cite the following publications:; [Bozkaya:2011:omp2] and [Bozkaya:2013:omp2grad].; Publications resulting from the use of the OMP3 code should cite the following publications:; [Bozkaya:2011:omp3] and [Bozkaya:2013:omp3].; Publications resulting from the use of the OMP2.5 code should cite the following publications:; [Bozkaya:2011:omp3] and",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/occ-1.html:3555,energy,energy,3555,psi4manual/4.0b5/occ-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/occ-1.html,2,['energy'],['energy']
Energy Efficiency,"ngles and doubles (CCSD) and orbital-optimized; CCD (OD) is similar, the situation is different in the case of triples corrections, especially at stretched; geometries [Bozkaya:2012:odtl]. Bozkaya and Schaefer demonstrated that orbital-optimized coupled cluster based; triple corrections, especially those of asymmetrics, provide significantly better potential energy curves than; CCSD based triples corrections. Theory¶; What follows is a very basic description of orbital-optimized Møller–Plesset perturbation; theory as implemented in PSI4. We will follow our previous presentations ([Bozkaya:2011:omp2],; [Bozkaya:2011:omp3], and [Bozkaya:2012:odtl]); The orbital variations may be expressed by means of an exponential unitary operator. where is the orbital rotation operator. The effect of the orbital rotations on the MO coefficients can be written as. where is the initial MO coefficient matrix and is the new; MO coefficient matrix as a function of .; Now, let us define a variational energy functional (Lagrangian) as a function of . OMP2. OMP3. where , , and defined as. and first and second derivatives of the energy with respect to the parameter at . Then the energy can be expanded up to second-order as follows. where is the MO gradient vector, is the MO rotation vector,; and is the MO Hessian matrix. Therefore, minimizing the energy with respect to ; yields. This final equation corresponds to the usual Newton-Raphson step.; Publications resulting from the use of the OMP2 code should cite the following publication(s):; [Bozkaya:2011:omp2].; Publications resulting from the use of the OMP3 code should cite the following publications:; [Bozkaya:2011:omp2] and [Bozkaya:2011:omp3]. Methods¶; The orbital-optimized MP2 methods currently supported in PSI4 are outlined in Table OMP2 Methods. Name; Calls Method; Energy; Gradient; Reference. omp2; Orbital-Optimized MP2; Y; Y; RHF/UHF/RKS/UKS. scs-omp2; Spin-Component Scaled Orbital-Optimized MP2; Y; N; RHF/UHF/RKS/UKS. sos-omp2; Spi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/ompn-1.html:3528,energy,energy,3528,psi4manual/4.0b3/ompn-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/ompn-1.html,2,['energy'],['energy']
Energy Efficiency,"ngles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples. >>> # [1] Coupled-cluster singles and doubles calculation with psi code; >>> energy('ccsd'). >>> # [2] Charge-transfer SAPT calculation with scf projection from small into; >>> # requested basis, with specified projection fitting basis; >>> set basis_guess true; >>> set df_basis_guess jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). >>> # [3] Arbitrary-order MPn calculation; >>> energy('mp7'). >>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> # Note that the integral transformation is not done automatically when detci is run in a separate step.; >>> molecule H2 {\n0 1\nH\nH 1 0.74\n}; >>> set basis cc-pVDZ; >>> set reference rohf; >>> scf_e, scf_wfn = energy('scf', return_wfn=True); >>> H2.set_multiplicity(3); >>> core.MintsHelper(scf_wfn.basisset()).integrals(); >>> energy('detci', ref_wfn=scf_wfn). >>> # [5] Run two CI calculations, keeping the integrals generated in the first one.; >>> molecule ne {\nNe\n}; >>> set basis cc-pVDZ; >>> cisd_e, cisd_wfn = energy('cisd', return_wfn=True); >>> energy('fci', ref_wfn=cisd_wfn). >>> # [6] Can automatically perform complete basis set extrapolations; >>> energy(""CCSD/cc-pV[DT]Z""). >>> # [7] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> energy(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. PSI4 API: Linking C++ and Python; energy. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.energy-1.html:21954,energy,energy,21954,psi4manual/1.4.0/api/psi4.driver.energy-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.energy-1.html,24,['energy'],['energy']
Energy Efficiency,"ngles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples. >>> # [1] Coupled-cluster singles and doubles calculation with psi code; >>> energy('ccsd'). >>> # [2] Charge-transfer SAPT calculation with scf projection from small into; >>> # requested basis, with specified projection fitting basis; >>> set basis_guess true; >>> set df_basis_guess jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). >>> # [3] Arbitrary-order MPn calculation; >>> energy('mp7'). >>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> # Note that the integral transformation is not done automatically when detci is run in a separate step.; >>> molecule H2 {\n0 1\nH\nH 1 0.74\n}; >>> set basis cc-pVDZ; >>> set reference rohf; >>> scf_e, scf_wfn = energy('scf', return_wfn=True); >>> H2.set_multiplicity(3); >>> core.MintsHelper(scf_wfn.basisset()).integrals(); >>> energy('detci', ref_wfn=scf_wfn). >>> # [5] Run two CI calculations, keeping the integrals generated in the first one.; >>> molecule ne {\nNe\n}; >>> set basis cc-pVDZ; >>> cisd_e, cisd_wfn = energy('cisd', return_wfn=True); >>> energy('fci', ref_wfn=cisd_wfn). >>> # [6] Can automatically perform complete basis set extrapolations; >>> energy(""CCSD/cc-pV[DT]Z""). >>> # [7] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> energy(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. PSI4 API: Linking C++ and Python; energy. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2021 02:41AM.; Created using Sphinx 4.3.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.driver.energy-1.html:22019,energy,energy,22019,psi4manual/1.5.0/api/psi4.driver.energy-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.driver.energy-1.html,24,['energy'],['energy']
Energy Efficiency,"ngles and doubles level; of theory. QCISD(T) TOTAL ENERGY¶. QCISD(T) CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the quadratic configuration interaction singles and doubles with; perturbative triples correction level of theory. QCISD(T) CORRECTION ENERGY¶; The quadratic configuration interaction singles and doubles perturbative; triples correction [E_h]. REMP2 TOTAL ENERGY¶. REMP2 CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the retaining-the-excitation-degree Møller–Plesset hybrid perturbation; theory level. SAPT DISP ENERGY¶. SAPT ELST ENERGY¶. SAPT EXCH ENERGY¶. SAPT IND ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total electronic interaction energy [E_h] for the; requested SAPT level of theory. The sum of these four components yields; SAPT TOTAL ENERGY. SAPT TOTAL ENERGY¶. SAPT ENERGY¶; The total electronic interaction energy [E_h] for the requested SAPT; level of theory. SAPT ELST10,R ENERGY¶; An electrostatics-classified SAPT term energy [E_h] implemented for SAPT0. SAPT ELST EXTERN-EXTERN ENERGY¶; Electrostatic interaction [E_h] between the point charges in fragments; A and B in F/I-SAPT. SAPT EXCH10 ENERGY¶; An exchange-classified SAPT term energy [E_h] implemented for SAPT0. SAPT EXCH10(S^2) ENERGY¶; An exchange-classified SAPT term energy [E_h] implemented for SAPT0. SAPT IND20,R ENERGY¶. SAPT EXCH-IND20,R ENERGY¶. SAPT IND20,U ENERGY¶. SAPT EXCH-IND20,U ENERGY¶; An induction-classified SAPT term energy [E_h] implemented for SAPT0. SAPT DISP20 ENERGY¶. SAPT EXCH-DISP20 ENERGY¶; A dispersion-classified SAPT term energy [E_h] implemented for SAPT0. SAPT EXCH-DISP20(S^INF) ENERGY¶; A dispersion-classified SAPT term energy [E_h] implemented for SAPT0. See Higher-Order Exchange Terms without Single-Exchange Approximation. SAPT SAME-SPIN DISP20 ENERGY¶. SAPT SAME-SPIN EXCH-DISP20 ENERGY¶; The portion of",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html:45589,energy,energy,45589,psi4manual/1.7.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html,4,['energy'],['energy']
Energy Efficiency,"ngles carried along. DOI: 10.1080/00268970802641242. SCS(N)-MP2 TOTAL ENERGY¶. SCS(N)-MP2 CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the MP2-like method formed by reweighting MP2 DOUBLES ENERGY; by 0 opposite-spin and 1.76 same-spin contributions, with; any singles carried along. doi: 10.1021/ct6002737. SCS(N)-OMP2 CORRELATION ENERGY¶. SCS(N)-OMP2 TOTAL ENERGY¶. SCSN-OMP2 CORRELATION ENERGY¶. SCSN-OMP2 TOTAL ENERGY¶; Two spellings of a discontinued QCVariable that may still appear; because the code is frozen pending an update. SCS-OMP2 TOTAL ENERGY¶. SCS-OMP2 CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the OMP2-like method formed by reweighting OMP2 DOUBLES ENERGY; by 6/5 opposite-spin and 1/3 same-spin contributions, with; any singles carried along. SCS-MP3 TOTAL ENERGY¶. SCS-MP3 CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the MP3-like method formed by reweighting the difference between; MP3 DOUBLES ENERGY and MP2 DOUBLES ENERGY; by 0.25, atop the SCS-MP2 energy, with any singles carried along. SCS-OMP3 TOTAL ENERGY¶. SCS-OMP3 CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the OMP3-like method formed by reweighting the difference between; OMP3 DOUBLES ENERGY and OMP2 DOUBLES ENERGY; by 0.25, atop the SCS-OMP2 energy, with any singles carried along. SOS-MP2 TOTAL ENERGY¶. SOS-MP2 CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the MP2-like method formed by reweighting MP2 DOUBLES ENERGY; by 1.3 opposite-spin and 0 same-spin contributions, with; any singles carried along. SOS-OMP2 TOTAL ENERGY¶. SOS-OMP2 CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the OMP2-like method formed by reweighting OMP2 DOUBLES ENERGY; by 1.2 opposite-spin and 0 same-spin contributions,",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html:45773,energy,energy,45773,psi4manual/1.4.0/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html,10,['energy'],['energy']
Energy Efficiency,"nic energy %20.12f\\n' % (electronic_energy))\n\n""""""); freagent.close(). # S/R: Read energy from each displaced geometry output file and save in energies array; elif (opt_mode.lower() == 'reap'):; E = 0.0; exec banners. try:; freagent = open('%s.out' % (rfile), 'r'); except IOError:; ValidationError('Aborting upon output file \'%s.out\' not found.\n' % (rfile)); return 0.0; else:; while 1:; line = freagent.readline(); if not line:; if E == 0.0:; ValidationError('Aborting upon output file \'%s.out\' has no %s RESULT line.\n' % (rfile, 'GRADIENT')); break; s = line.split(); if (len(s) != 0) and (s[0:3] == ['GRADIENT', 'RESULT:', 'computation']):; if int(s[3]) != opt_linkage:; raise ValidationError('Output file \'%s.out\' has linkage %s incompatible with master.in linkage %s.'; % (rfile, str(s[3]), str(opt_linkage))); if s[6] != str(n + 1):; raise ValidationError('Output file \'%s.out\' has nominal affiliation %s incompatible with item %s.'; % (rfile, s[6], str(n + 1))); if (s[8:10] == ['electronic', 'energy']):; E = float(s[10]); PsiMod.print_out('%s RESULT: electronic energy = %20.12f\n' % ('GRADIENT', E)); freagent.close(); energies.append(E). # S/R: Quit sow after writing files; if (opt_mode.lower() == 'sow'):; return 0.0. if (opt_mode.lower() == 'reap'):; PsiMod.set_variable('CURRENT ENERGY', energies[-1]). # Obtain the gradient; PsiMod.fd_1_0(energies). # The last item in the list is the reference energy, return it; return energies[-1]. [docs]def property(name, **kwargs):; r""""""Function to compute various properties. :aliases: prop(). :returns: (*float*) Total electronic energy in Hartrees. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - This function at present handles property functions only for CC methods.; Consult the keywords sections for other modules for further property capabilities. - Check that energy is actually being returned. - Check if some PSI variables ought to be set. +-------------------------+----------------------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/driver.html:29486,energy,energy,29486,psi4manual/4.0b2/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/driver.html,2,['energy'],['energy']
Energy Efficiency,"nic energy [Eh] for the requested theory and root n (n starts at 0).; DFT functional labeled if canonical. CCname ROOT n (IN h) TOTAL ENERGY¶. TD-fctl ROOT n (IN h) TOTAL ENERGY¶; The total electronic energy [Eh] for the requested theory and root n within irrep h (n starts at 0).; DFT functional labeled if canonical. CCname ROOT n (h) TOTAL ENERGY¶. TD-fctl ROOT n (h) TOTAL ENERGY¶; The total electronic energy [Eh] for the requested theory and root n, which is of irrep h (n starts at 0).; DFT functional labeled if canonical. CCname ROOT n TOTAL ENERGY - h TRANSITION¶. TD-fctl ROOT n TOTAL ENERGY - h TRANSITION¶; The total electronic energy [Eh] for the requested theory and root n, and the transition is of irrep h, (n starts at 0). CCname ROOT n CORRELATION ENERGY¶; The correlation energy [Eh] for the requested coupled cluster level of theory and root n (n starts at 0).; DFT functional labeled if canonical. CCname ROOT n (IN h) CORRELATION ENERGY¶; The correlation energy [Eh] for the requested coupled cluster level of theory and root n within irrep h (n starts at 0). CCname ROOT n (h) CORRELATION ENERGY¶; The correlation energy [Eh] for the requested coupled cluster level of theory and root n, which is of irrep h (n starts at 0). CCname ROOT n CORRELATION ENERGY - h TRANSITION¶; The correlation energy [Eh] for the requested coupled cluster level of theory and root n, and the transition is of irrep h, (n starts at 0). CCname ROOT n DIPOLE¶; Dipole array [e a0] for the requested coupled cluster level of theory and root n (n starts at 0), (3,). CCname ROOT n (IN h) DIPOLE¶; Dipole array [e a0] for the requested coupled cluster level of theory and root n within irrep h (n starts at 0), (3,). CCname ROOT n (h) DIPOLE¶; Dipole array [e a0] for the requested coupled cluster level of theory and root n, which is of irrep h (n starts at 0), (3,). CCname ROOT n DIPOLE - h TRANSITION¶; Dipole array [e a0] for the requested coupled cluster level of theory and root n, and the trans",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/glossary_psivariables.html:9553,energy,energy,9553,psi4manual/1.6.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/glossary_psivariables.html,1,['energy'],['energy']
Energy Efficiency,"nimal Dev 0.0029; Maximal Dev 0.0347; Mean Signed Dev 0.0201; Mean Absolute Dev 0.0201; RMS Dev 0.0240; -----------------------------------------------------------------------------------. As well as being printed in the output file, database results from the; tabulate option are available in the input file as ordinary Python; dictionaries DB_RGT and DB_RXN, indexed firstly by reagent or reaction; name and secondly by the requested PSI variable name. See the first; paragraph of Creating a Database for the distinction between; reagents and reactions. For example, an input file like the following; requests a couple variables through tabulate and then makes use of the; resulting data structures, here, only to print.; set basis 6-31g*; db('dfmp2','s22',subset='small',tabulate=['CURRENT ENERGY','DF-MP2 CORRELATION ENERGY']). from pprint import pprint. print_stdout('\nDB_RGT'); pprint(DB_RGT). print_stdout('\nDB_RXN'); pprint(DB_RXN). print_stdout('\ndf-mp2 interaction energy of water dimer (S22-2)'); print_stdout(DB_RXN['S22-2']['CURRENT ENERGY']). The output to the screen is as follows.; DB_RGT; {'S22-16-dimer': {'CURRENT ENERGY': -155.37373581838636,; 'DF-MP2 CORRELATION ENERGY': -0.523870772178089},; 'S22-16-monoA-unCP': {'CURRENT ENERGY': -78.29412053242164,; 'DF-MP2 CORRELATION ENERGY': -0.2629759351596186},; 'S22-16-monoB-unCP': {'CURRENT ENERGY': -77.07606823017188,; 'DF-MP2 CORRELATION ENERGY': -0.2594122526144091},; 'S22-2-dimer': {'CURRENT ENERGY': -152.40958884746667,; 'DF-MP2 CORRELATION ENERGY': -0.3797598812113561},; 'S22-2-monoA-unCP': {'CURRENT ENERGY': -76.19905879745446,; 'DF-MP2 CORRELATION ENERGY': -0.1887118848315123},; 'S22-2-monoB-unCP': {'CURRENT ENERGY': -76.19902978067739,; 'DF-MP2 CORRELATION ENERGY': -0.18857384937354635},; 'S22-8-dimer': {'CURRENT ENERGY': -80.67416758080654,; 'DF-MP2 CORRELATION ENERGY': -0.2844102558783027},; 'S22-8-monoA-unCP': {'CURRENT ENERGY': -40.336952636980364,; 'DF-MP2 CORRELATION ENERGY': -0.14185962536715307},; 'S2",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/db-1.html:9967,energy,energy,9967,psi4manual/4.0b3/db-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/db-1.html,6,['energy'],['energy']
Energy Efficiency,"nimizations of HOOH with cc-pvdz RHF Internal-coordinate constraints in internal-coordinate optimizations. dfmp2-3; DF-MP2 cc-pVDZ frozen core gradient of benzene, computed at the DF-SCF cc-pVDZ geometry. cdomp2-1; OMP2 cc-pVDZ energy for the H2O molecule. fsapt-diff1; This test case shows an example of running and analyzing a difference F-SAPT0/jun-cc-pvdz procedure for phenol dimer from the S22 database. freq-isotope; Vibrational and thermo analysis of several water isotopologs. Demonstrates Hessian reuse for different temperatures and pressures but not for different isotopologs. cc13a; UHF-CCSD(T)/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. cc8c; ROHF-CCSD cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Cartesian input. props1; RHF STO-3G dipole moment computation, performed by applying a finite electric field and numerical differentiation. cc45; RHF-EOM-CC2/cc-pVDZ lowest two states of each symmetry of H2O. fnocc4; Test FNO-DF-CCSD(T) energy. tu3-h2o-opt; Optimize H2O HF/cc-pVDZ. cc9; UHF-CCSD(T) cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Z-matrix input. mcscf3; RHF 6-31G** energy of water, using the MCSCF module and Z-matrix input. mints2; A test of the basis specification. A benzene atom is defined using a ZMatrix containing dummy atoms and various basis sets are assigned to different atoms. The symmetry of the molecule is automatically lowered to account for the different basis sets. dcft8; DCFT calculation for the NH3+ radical using the ODC-12 and ODC-13 functionals. This performs both simultaneous and QC update of the orbitals and cumulant using DIIS extrapolation. Four-virtual integrals are first handled in the MO Basis for the first two energy computations. In the next computation ao_basis=disk algorithm is used, where the transformation of integrals for four-virtual case is avoided. cc12; Single point energies of multiple excited states with EOM-CCSD. dft2; DFT",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/testsuite-1.html:27575,energy,energy,27575,psi4manual/1.1.0/testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/testsuite-1.html,4,['energy'],['energy']
Energy Efficiency,"ning gCP¶; At present there is a limited interface to gCP that is used; only to implement the “HF-3c” [Sure:2013:1672] and “PBEh-3c”; [Grimme:2015:054107] methods (both energy and gradient). The interface; can use classic or mctc-gcp executables interchangeably and will prefer the latter.; A DFTD3 executable, classic or simple-dftd3,; must also be available for these methods to; run. Unlike every other method in PSI4, if a basis set has not been; set, these will default to their intended basis sets: MINIX for HF-3c; and def2-mSVP for PBEh-3c. If a basis has previously been set, but you; want to use the default basis, use the slash syntax to “empty” the basis; option for the scope of the current calculation, energy(""hf3c/"").; A few practical examples:. HF-3c single point with default minix basis; energy('hf3c'). PBEh-3c optimization with default def2-mSVP basis; optimize('pbeh3c'). HF-3c with non-standard basis; set basis cc-pvdz; energy('hf3c'). PBEh-3c with default basis after basis set; set basis cc-pvdz; energy('pbeh3c/'). If only BSSE/basis set corrections (rather than total energies) are of; interest, the gcp program can be run independently of the scf; through the python function run_gcp(). (This function; is the same PSI4/gcp interface that is called during an scf job.); This route is much faster than running a HF or DFT energy.; molecule nene {; Ne; Ne 1 2.0; }. nene.update_geometry(). >>> E, G = nene.run_gcp('hf3c'). >>> E, G = nene.run_gcp(func='HF3c', verbose=True). qcdb.Molecule.run_gcp(self, func=None, dertype=None, verbose=1)¶; Compute geometrical BSSE correction via Grimme’s GCP program.; Function to call Grimme’s GCP program; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp; to compute an a posteriori geometrical BSSE correction to self for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, func. Returns energy if dertype is 0, gradient; if dertype is 1, else tuple of energy and gradient if dertyp",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/gcp.html:2872,energy,energy,2872,psi4manual/1.7.x/gcp.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/gcp.html,2,['energy'],['energy']
Energy Efficiency,"ning values for X and C parts. SCF will fail or crash (nans) without screening!. casscf-fzc-sp; CASSCF/6-31G** energy point. isapt1; This test case shows an example of running and analyzing an FI-SAPT0/jun-cc-pvdz computation for 2,4-pentanediol (targeting the intramolecular hydrogen bond between the two hydroxyl groups). pywrap-align-chiral; testing aligner on enantiomers based on Table 1 of 10.1021/ci100219f aka J Chem Inf Model 2010 50(12) 2129-2140. cisd-sp; 6-31G** H2O Test CISD Energy Point. dft-grad-lr2; Tests CAM gradients with and without XC pieces to narrow grid error. dfccsd1; DF-CCSD cc-pVDZ energy for the H2O molecule. adc1; ADC(2)/6-31G** on H2O using builtin ADC module. cc5; RHF CCSD(T) aug-cc-pvtz frozen-core energy of C4NH4 Anion. scf-uhf-grad-nobeta; UHF gradient for a one-electron system (no beta electrons). cc24; Single point gradient of 1-2B1 state of H2O+ with EOM-CCSD. cc46; EOM-CC2/cc-pVDZ on H2O2 with two excited states in each irrep. dfccdl1; DF-CCDL cc-pVDZ energy for the H2O molecule. omp2-5; SOS-OMP2 cc-pVDZ geometry optimization for the H2O molecule. dft-grad-meta; meta-GGA gradients of water and ssh molecules reference gradients updated due to new BraggSlater radii. cc2; 6-31G** H2O CCSD optimization by energies, with Z-Matrix input. dfomp3-2; DF-OMP3 cc-pVDZ energy for the H2O+ cation. freq-isotope2; Vibrational and thermo analysis of several water isotopologs. Demonstrates Hessian reuse for different temperatures, pressures, and isotopologs. fci-h2o-2; 6-31G H2O Test FCI Energy Point. tu2-ch2-energy; Sample UHF/6-31G** CH2 computation. nbody-intermediates; HF/cc-pVDZ many body energies of an arbitrary noble gas trimer complex Size vs cost tradeoff is rough here. dft-freq; Frequencies for H2O B3LYP/6-31G* at optimized geometry. fnocc7; Test fnocc with linear dependencies. cisd-h2o+-2; 6-31G** H2O+ Test CISD Energy Point. scf-response1; Compute the dipole, quadrupole, and traceless quadrupoles for water. opt8; Various constrained energ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html:9942,energy,energy,9942,psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"nings; from driver import *; from wrappers import *; from molutil import *; from text import *; from procutil import *. # Python procedures like these can be run directly from the input file or integrated; # with the energy(), etc. routines by means of lines like those at the end of this file. [docs]def sherrillgroup_gold_standard(name='mp2', **kwargs):; r""""""Function to call the quantum chemical method known as 'Gold Standard'; in the Sherrill group. Uses :py:func:`~wrappers.complete_basis_set` to evaluateo; the following expression. Two-point extrapolation of the correlation energy; performed according to :py:func:`~wrappers.corl_xtpl_helgaker_2`. .. math:: E_{total}^{\text{Au\_std}} = E_{total,\; \text{SCF}}^{\text{aug-cc-pVQZ}} \; + E_{corl,\; \text{MP2}}^{\text{aug-cc-pV[TQ]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD(T)}}\big\vert_{\text{aug-cc-pVTZ}}. >>> energy('sherrillgroup_gold_standard'). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). if not ('func_cbs' in kwargs):; kwargs['func_cbs'] = energy. if not ('scf_basis' in kwargs):; kwargs['scf_basis'] = 'aug-cc-pVQZ'; if not ('scf_scheme' in kwargs):; kwargs['scf_scheme'] = highest_1. if not ('corl_wfn' in kwargs):; kwargs['corl_wfn'] = 'mp2'; if not ('corl_basis' in kwargs):; kwargs['corl_basis'] = 'aug-cc-pV[TQ]Z'; if not ('corl_scheme' in kwargs):; kwargs['corl_scheme'] = corl_xtpl_helgaker_2. if not ('delta_wfn' in kwargs):; kwargs['delta_wfn'] = 'ccsd(t)'; if not ('delta_wfn_lesser' in kwargs):; kwargs['delta_wfn_lesser'] = 'mp2'; if not ('delta_basis' in kwargs):; kwargs['delta_basis'] = 'aug-cc-pVTZ'; if not ('delta_scheme' in kwargs):; kwargs['delta_scheme'] = highest_1. return cbs(name, **kwargs). [docs]def run_mp2_5(name, **kwargs):; r""""""Function that computes MP2.5 energy from results of a DETCI; MP3 calculation. .. math:: E_{total}^{\text{MP2.5}} = E_{total,\; \text{SCF}} \; + E_{corl,\; \text{MP2}} + E_{corl, \; \text{MP3}}. :PSI variables: . .. hlist:: ; :columns: 1 ; ; * :psivar:`MP2.5",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/aliases.html:1477,energy,energy,1477,psi4manual/4.0b2/_modules/aliases.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/aliases.html,4,['energy'],['energy']
Energy Efficiency,"nit conversion to [a0] for geometry. irrep_labels(self); Returns Irreducible Representation symmetry labels. is_variable(self, arg0); Checks if variable arg0 is in the structural variables list. label(self, atom); Gets the original label of the atom as given in the input file (C2, H4)(0-indexed without dummies). mass(self, atom); Returns mass of atom (0-indexed). mass_number(self, arg0); Mass number (A) of atom if known, else -1. molecular_charge(self); Gets the molecular charge. move_to_com(self); Moves molecule to center of mass. multiplicity(self); Gets the multiplicity (defined as 2Ms + 1). nallatom(self); Number of real and dummy atoms. name(self); Gets molecule name. natom(self); Number of real atoms. nfragments(self); Gets the number of fragments in the molecule. nuclear_dipole(*args, **kwargs); Overloaded function. nuclear_repulsion_energy(self[, dipole_field]); Computes nuclear repulsion energy. nuclear_repulsion_energy_deriv1(self[, ...]); Returns first derivative of nuclear repulsion energy as a matrix (natom, 3). nuclear_repulsion_energy_deriv2(self); Returns second derivative of nuclear repulsion energy as a matrix (natom X 3, natom X 3). orientation_fixed(self); Get whether or not orientation is fixed. point_group(self); Returns the current point group object. print_bond_angles(self); Print the bond angle geometrical parameters. print_cluster(self); Prints the molecule in Cartesians in input units adding fragment separators. print_distances(self); Print the interatomic distance geometrical parameters. print_in_input_format(self); Prints the molecule as Cartesian or ZMatrix entries, just as inputted. print_out(self); Prints the molecule in Cartesians in input units to output file. print_out_in_angstrom(self); Prints the molecule in Cartesians in Angstroms to output file. print_out_in_bohr(self); Prints the molecule in Cartesians in Bohr to output file. print_out_of_planes(self); Print the out-of-plane angle geometrical parameters to output file. print_r",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.core.molecule.html:5564,energy,energy,5564,psi4manual/1.5.0/api/psi4.core.molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.core.molecule.html,12,['energy'],['energy']
Energy Efficiency,"nit__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class SuperFunctional(Boost.Python.instance); | docstring; | ; | Method resolution order:; | SuperFunctional; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | add_c_functional(...); | add_c_functional( (SuperFunctional)arg1, (Functional)arg2) -> None :; | docstring; | ; | add_x_functional(...); | add_x_functional( (SuperFunctional)arg1, (Functional)arg2) -> None :; | docstring; | ; | allocate(...); | allocate( (SuperFunctional)arg1) -> None :; | docstring; | ; | ansatz(...); | ansatz( (SuperFunctional)arg1) -> int :; | docstring; | ; | c_alpha(...); | c_alpha( (SuperFunctional)arg1) -> float :; | docstring; | ; | c_functional(...); | c_functional( (SuperFunctional)arg1, (str)arg2) -> Functional :; | docstring; | ; | c_omega(...); | c_omega( (SuperFunctional)arg1) -> float :; | docstring; | ; | c_os_alpha(...); | c_os_alpha( (SuperFunctional)arg1) -> float :; | docstring; | ; | c_ss_alpha(...); | c_ss_alpha( (SuperFunctional)arg1) -> float :; | docstring; | ; | citation(...); | citation( (SuperFunctional)arg1) -> str :; | docstring; | ; | deriv(...); | deriv( (SuperFunctional)arg1) -> int :; | docstring; | ; | description(...); | description( (SuperFunctional)arg1) -> str :; | docstring; | ; | dispersion(...); | dispersion( (SuperFunctional)arg1) -> Dispersion :; | docstring; | ; | is_c_hybrid(...); | is_c_hybrid( (SuperFunc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/psimod-1.html:81160,allocate,allocate,81160,psi4manual/4.0b3/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html,6,['allocate'],['allocate']
Energy Efficiency,"nit__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class SuperFunctional(Boost.Python.instance); | docstring; | ; | Method resolution order:; | SuperFunctional; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | add_c_functional(...); | add_c_functional( (SuperFunctional)arg1, (Functional)arg2) -> None :; | docstring; | ; | add_x_functional(...); | add_x_functional( (SuperFunctional)arg1, (Functional)arg2) -> None :; | docstring; | ; | allocate(...); | allocate( (SuperFunctional)arg1) -> None :; | docstring; | ; | ansatz(...); | ansatz( (SuperFunctional)arg1) -> int :; | docstring; | ; | c_alpha(...); | c_alpha( (SuperFunctional)arg1) -> float :; | docstring; | ; | c_functional(...); | c_functional( (SuperFunctional)arg1, (str)arg2) -> Functional :; | docstring; | ; | c_omega(...); | c_omega( (SuperFunctional)arg1) -> float :; | docstring; | ; | citation(...); | citation( (SuperFunctional)arg1) -> str :; | docstring; | ; | deriv(...); | deriv( (SuperFunctional)arg1) -> int :; | docstring; | ; | description(...); | description( (SuperFunctional)arg1) -> str :; | docstring; | ; | dispersion(...); | dispersion( (SuperFunctional)arg1) -> Dispersion :; | docstring; | ; | is_c_hybrid(...); | is_c_hybrid( (SuperFunctional)arg1) -> bool :; | docstring; | ; | is_c_lrc(...); | is_c_lrc( (SuperFunctional)arg1) -> bool :; | docstring; | ; | is_gga(...); | is_gga( (SuperFunctional)arg1) -",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/psimod-1.html:70824,allocate,allocate,70824,psi4manual/4.0b2/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html,2,['allocate'],['allocate']
Energy Efficiency,"nization; functionals ionization energies vs. other programs. dft-b3lyp; Check flavors of B3LYP (b3lyp3/b3lyp5) against other programs. dfomp2-grad1; DF-OMP2 cc-pVDZ gradients for the H2O molecule. psimrcc-fd-freq1; Mk-MRCCSD single point. \(^3 \Sigma ^-\) O2 state described using the Ms = 0 component of the triplet. Uses ROHF triplet orbitals. cbs-xtpl-energy; Extrapolated water energies. mints6; Patch of a glycine with a methyl group, to make alanine, then DF-SCF energy calculation with the cc-pVDZ basis set. isapt2; This is a shorter version if isapt1 - does not do cube plots. See isapt1 for full details. casscf-sa-sp; Example of state-averaged CASSCF for the C2 molecule see C. D. Sherrill and P. Piecuch, J. Chem. Phys. 122, 124104 (2005). cbs-xtpl-wrapper; RHF aug-cc-pVQZ energy for the BH molecule, with Cartesian input. Various gradients for a strained helium dimer and water molecule. pywrap-align; apply linear fragmentation algorithm to a water cluster. dfccsd1; DF-CCSD cc-pVDZ energy for the H2O molecule. cc13b; Tests RHF CCSD(T)gradients. x2c1; Test of SFX2C-1e on water uncontracted cc-pVDZ-DK The reference numbers are from Lan Cheng’s implementation in Cfour. scf-property; UFH and B3LYP cc-pVQZ properties for the CH2 molecule. dfomp2p5-2; DF-OMP2.5 cc-pVDZ energy for the H2O+ cation. soscf-dft; Triple and Singlet Oxygen energy SOSCF, also tests non-symmetric density matrices. opt14; 6-31G(d) optimization of SF4 starting from linear bond angle that is not linear in the optimized structure but is in a symmetry plane of the molecule. dcft-grad1; DCFT DC-06 gradient for the O2 molecule with cc-pVDZ basis set. pywrap-checkrun-rhf; This checks that all energy methods can run with a minimal input and set symmetry. opt5; 6-31G** UHF CH2 3B1 optimization. Uses a Z-Matrix with dummy atoms, just for demo and testing purposes. cc53; Matches Table II a-CCSD(T)/cc-pVDZ H2O @ 2.5 * Re value from Crawford and Stanton, IJQC 98, 601-611 (1998). dfomp3-1; DF-OMP3 cc-pVDZ ener",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html:14732,energy,energy,14732,psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"nlattice)]; self.lattice = [0.0 for ilat in range(self.nlattice)]; self.set_lattice_field(). # Respond to the >CLATTICE command; def recv_clattice(self, clattice=None):; """""" Receive the coordinates of a set of lattice point charges through MDI. Arguments:; clattice: New coordinates of the lattice of point charges. If None, receive through MDI.; """"""; if clattice is None:; self.clattice = MDI_Recv(3 * self.nlattice, MDI_DOUBLE, self.comm); else:; self.clattice = clattice; self.set_lattice_field(). # Respond to the >LATTICE command; def recv_lattice(self, lattice=None):; """""" Receive the charges of a set of lattice point charges through MDI. Arguments:; lattice: New charges of the lattice of point charges. If None, receive through MDI.; """"""; if lattice is None:; self.lattice = MDI_Recv(self.nlattice, MDI_DOUBLE, self.comm); else:; self.lattice = lattice; self.set_lattice_field(). # Respond to the SCF command; def run_scf(self):; """""" Run an energy calculation; """"""; self.energy = psi4.energy(self.scf_method, **self.kwargs). # Respond to the <DIMENSIONS command; def send_dimensions(self):; """""" Send the dimensionality of the system through MDI. :returns: *dimensions* Dimensionality of the system; """"""; dimensions = [1, 1, 1]; MDI_Send(dimensions, 3, MDI_INT, self.comm); return dimensions. # Respond to the <TOTCHARGE command; def send_total_charge(self):; """""" Send the total system charge through MDI. :returns: *charge* Total charge of the system; """"""; charge = self.molecule.molecular_charge(); MDI_Send(charge, 1, MDI_DOUBLE, self.comm); return charge. # Respond to the >TOTCHARGE command; def recv_total_charge(self, charge=None):; """""" Receive the total system charge through MDI. Arguments:; charge: New charge of the system. If None, receive through MDI.; """"""; if charge is None:; charge = MDI_Recv(1, MDI_DOUBLE, self.comm); self.molecule.set_molecular_charge(int(round(charge))). # Respond to the <ELEC_MULT command; def send_multiplicity(self):; """""" Send the electronic multiplic",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html:10391,energy,energy,10391,psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html,14,['energy'],['energy']
Energy Efficiency,"nly meant to work with PSI4’s FCHK files. Parameters. expected (file) – Reference FCHK file against which computed is compared.; computed (file) – Input FCHK file to compare against expected.; atol_exponent (int or float) – Absolute tolerance for high accuracy fields – 1.e-8 or 1.e-9 is suitable.; Values less than one are taken literally; one or greater taken as decimal digits for comparison.; So 1 means atol=0.1 and 2 means atol=0.01 but 0.04 means atol=0.04; Note that the largest expressable processed atol will be ~0.99.; label (str) – Label for passed and error messages. psi4.compare_fcidumps(expected, computed, label)[source]¶; Comparison function for FCIDUMP files.; Compares the first six below, then computes energies from MO integrals and compares the last four. ‘norb’ : number of basis functions; ‘nelec’ : number of electrons; ‘ms2’ : spin polarization of the system; ‘isym’ : symmetry of state (if present in FCIDUMP); ‘orbsym’ : list of symmetry labels of each orbital; ‘uhf’ : whether restricted or unrestricted; ‘ONE-ELECTRON ENERGY’ : SCF one-electron energy; ‘TWO-ELECTRON ENERGY’ : SCF two-electron energy; ‘SCF TOTAL ENERGY’ : SCF total energy; ‘MP2 CORRELATION ENERGY’ : MP2 correlation energy. Parameters. expected – Reference FCIDUMP file against which computed is compared.; computed – Input FCIDUMP file to compare against expected.; label – string labeling the test. psi4.compare_moldenfiles(expected, computed, atol_exponent=7, label='Compare Molden')[source]¶; Comparison function for output data in Molden file format.; Compares many fields including geometry, basis set, occupations, symmetries, energies.; Note only Psi4-style signature ((expected, computed, atol_exponent, label)) available.; A format description is found https://www3.cmbi.umcn.nl/molden/molden_format.html. Parameters. expected (file) – Reference Molden file against which computed is compared.; computed (file) – Input Molden file to compare against expected.; atol_exponent (int or float) –",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/add_tests.html:26239,energy,energy,26239,psi4manual/1.6.x/add_tests.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/add_tests.html,4,['energy'],['energy']
Energy Efficiency,"nly with closed shell reference determinant, it must be zero otherwise. This becomes nsing (option #2) in fort.56. Type: integer; Default: 1. MRCC_NUM_TRIPLET_ROOTS¶. Number of triplet roots. (Strictly speaking number of of roots with \(M_s=0\) and S is odd.) See notes at option MRCC_NUM_SINGLET_ROOTS This becomes ntrip (option #3) in fort.56. Type: integer; Default: 0. Expert¶. MRCC_METHOD¶. If more than one root is requested and calc=1, LR-CC (EOM-CC) calculation is performed automatically for the excited states. This overrides all automatic determination of method and will only work with energy(). This becomes CC/CI (option #5) in fort.56. See Table MRCC_METHOD for details. Type: integer; Default: 1. MRCC_OMP_NUM_THREADS¶. Sets the OMP_NUM_THREADS environment variable before calling MRCC. If the environment variable OMP_NUM_THREADS is set prior to calling Psi4 then that value is used. When set, this option overrides everything. Be aware the -n command-line option described in section Threading does not affect MRCC. Type: integer; Default: 1. MRCC_RESTART¶. The program restarts from the previously calculated parameters if it is 1. In case it is 2, the program executes automatically the lower-level calculations of the same type consecutively (e.g., CCSD, CCSDT, and CCSDTQ if CCSDTQ is requested) and restarts each calculation from the previous one (rest=2 is available only for energy calculations). Currently, only a value of 0 and 2 are supported. This becomes rest (option #4) in fort.56. Type: integer; Default: 0. table of contents. MRCC; General; E_CONVERGENCE; INTS_TOLERANCE; MRCC_LEVEL; MRCC_NUM_DOUBLET_ROOTS; MRCC_NUM_SINGLET_ROOTS; MRCC_NUM_TRIPLET_ROOTS. Expert; MRCC_METHOD; MRCC_OMP_NUM_THREADS; MRCC_RESTART. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Appendices; Keywords by Module. © Copyright 2019, The Psi4 Project.; Last updated on Wednesday, 15 May 2019 08:49PM.; Created using Sphinx 1.8.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__mrcc-1.html:2499,energy,energy,2499,psi4manual/1.3.2/autodir_options_c/module__mrcc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__mrcc-1.html,2,['energy'],['energy']
Energy Efficiency,"nname, zLO, valueLO, zHI, valueHI, verbose=True, alpha=None)[source]¶; Extrapolation scheme using exponential form for reference energies with two adjacent; zeta-level bases. Used by cbs(). Parameters. functionname (str) – Name of the CBS component.; zLO (int) – Lower zeta level.; valueLO (float) – Lower value used for extrapolation.; zHI (int) – Higher zeta level. Should be equal to zLO + 1.; valueHI (float) – Higher value used for extrapolation.; alpha (Optional[float]) – Overrides the default \(\alpha = 1.63\); verbose (bool) – . Returns; Returns \(E_{total}^{\infty}\), see below. Return type; float. Notes; The extrapolation is calculated according to 1:; \(E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}, \alpha = 1.63\); References. 1; Halkier, Helgaker, Jorgensen, Klopper, & Olsen, Chem. Phys. Lett. 302 (1999) 437-446,; DOI: 10.1016/S0009-2614(99)00179-7. psi4.driver.driver_cbs.scf_xtpl_truhlar_2(functionname, zLO, valueLO, zHI, valueHI, verbose=True, alpha=None)[source]¶; Extrapolation scheme using power form for reference energies with two adjacent; zeta-level bases. Used by cbs(). Parameters. functionname (str) – Name of the CBS component.; zLO (int) – Lower zeta level.; valueLO (float) – Lower value used for extrapolation.; zHI (int) – Higher zeta level. Should be equal to zLO + 1.; valueHI (float) – Higher value used for extrapolation.; alpha (Optional[float]) – Overrides the default \(\alpha = 3.4\); verbose (bool) – . Returns; Returns \(E_{total}^{\infty}\), see below. Return type; float. Notes; The extrapolation is calculated according to 2:; \(E_{total}^X = E_{total}^{\infty} + \beta X^{-\alpha}, \alpha = 3.4\); References. 2; Truhlar, Chem. Phys. Lett. 294 (1998) 45-48,; DOI: 10.1016/S0009-2614(98)00866-5. psi4.driver.driver_cbs.scf_xtpl_karton_2(functionname, zLO, valueLO, zHI, valueHI, verbose=True, alpha=None)[source]¶; Extrapolation scheme using root-power form for reference energies with two adjacent; zeta-level bases. Used by cbs(). Param",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/cbs-1.html:21956,power,power,21956,psi4manual/1.4.0/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/cbs-1.html,4,['power'],['power']
Energy Efficiency,"nner('Guess SCF, %s Basis' % (guessbasis)); PsiMod.print_out('\n'). # the FIRST scf call; if cast or do_broken:; # Perform the guess scf; PsiMod.scf(). # broken clean-up; if do_broken:; molecule.set_multiplicity(1); PsiMod.set_local_option('SCF', 'GUESS', 'READ'); PsiMod.print_out('\n'); banner(' Computing broken symmetry solution from high-spin triplet guess '); PsiMod.print_out('\n'). # cast clean-up; if (cast):. # Move files to proper namespace; PsiMod.IO.change_file_namespace(180, (namespace + '.guess'), namespace); PsiMod.IO.set_default_namespace(namespace). # Set to read and project, and reset bases to final ones; optstash2.restore(); PsiMod.set_local_option('SCF', 'GUESS', 'READ'). # Print the banner for the standard operation; PsiMod.print_out('\n'); banner(name.upper()); PsiMod.print_out('\n'). # the SECOND scf call; e_scf = PsiMod.scf(precallback, postcallback). optstash.restore(); return e_scf. [docs]def run_mp2_select(name, **kwargs):; """"""Function selecting the algorithm for a MP2 energy call; and directing toward the OCC (conv MP2) or the DFMP2 modules. """"""; if (PsiMod.get_option(""DFMP2"", ""MP2_TYPE"") == ""CONV"") or (PsiMod.get_option(""OCC"", ""MP2_TYPE"") == ""CONV""):; return run_mp2(name, **kwargs); else:; return run_dfmp2(name, **kwargs). [docs]def run_mp2_select_gradient(name, **kwargs):; """"""Function selecting the algorithm for a MP2 gradient call; and directing toward the OCC (conv MP2) or the DFMP2 modules. """"""; if (PsiMod.get_option(""DFMP2"", ""MP2_TYPE"") == ""CONV"") or (PsiMod.get_option(""OCC"", ""MP2_TYPE"") == ""CONV""):; return run_mp2_gradient(name, **kwargs); else:; return run_dfmp2_gradient(name, **kwargs). [docs]def run_dfmp2_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a DFMP2 gradient calculation. """"""; optstash = OptionsState(; ['DF_BASIS_SCF'],; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not PsiMod.has_option_changed('SCF', 'SCF_TYPE'):; #PsiMod.set_local_option('SCF', 'SCF_TYPE', 'DF') # ins",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/proc.html:18563,energy,energy,18563,psi4manual/4.0b4/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/proc.html,2,['energy'],['energy']
Energy Efficiency,"nnies. OVERLAP is overlap-based dispersion damping. Type: string; Possible Values: TT, OVERLAP, OFF; Default: OVERLAP. EFP_ELST (EFP); EFP — Do include electrostatics energy term in EFP computation?. Type: boolean; Default: true. EFP_ELST_DAMPING (EFP); EFP — Fragment-fragment electrostatic damping type. SCREEN is a damping formula based on screen group in the EFP potential. OVERLAP is damping that computes charge penetration energy. Type: string; Possible Values: SCREEN, OVERLAP, OFF; Default: SCREEN. EFP_EXCH (EFP); EFP — Do include exchange repulsion energy term in EFP computation?. Type: boolean; Default: true. EFP_IND (EFP); EFP — Do include polarization energy term in EFP computation? (EFP_POL c. v1.1). Type: boolean; Default: true. EFP_IND_DAMPING (EFP); EFP — Fragment-fragment polarization damping type. TT is a damping formula like Tang and Toennies. (EFP_POL_DAMPING c. v1.1). Type: string; Possible Values: TT, OFF; Default: TT. EFP_QM_ELST (EFP); EFP — Do include electrostatics energy term in QM/EFP computation? (QMEFP_ELST c. v1.1). Type: boolean; Default: true. EFP_QM_IND (EFP); EFP — Do include polarization energy term in QM/EFP computation? (QMEFP_POL c. v1.1). Type: boolean; Default: true. EKT_EA (OCC); OCC — Do compute virtual orbital energies based on extended Koopmans’ theorem?. Type: boolean; Default: false. EKT_IP (DFOCC); DFOCC — Do compute ionization potentials based on the extended Koopmans’ theorem?. Type: boolean; Default: false. EKT_IP (OCC); OCC — Do compute occupied orbital energies based on extended Koopmans’ theorem?. Type: boolean; Default: false. ENERGY_LEVEL_SHIFT (DCFT); DCFT (Expert) — Level shift applied to the diagonal of the density-weighted Fock operator. While this shift can improve convergence, it does change the DCFT energy. Type: double; Default: 0.0. ENSURE_BT_CONVERGENCE (OPTKING); OPTKING — Reduce step size as necessary to ensure back-transformation of internal coordinate step to cartesian coordinates. Type: boolean; Defau",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html:119128,energy,energy,119128,psi4manual/1.2.1/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html,4,['energy'],['energy']
Energy Efficiency,"nning the SCF code first, then the coupled cluster modules;; the energy() Python helper function ensures that this is performed correctly.; Note that the Python interpreter executes commands in the order they appear in; the input file, so if the last four commands in the above example were to read; set basis cc-pVDZ; energy('ccsd'); set ccenergy print 3; set scf print 1. the commands that set the print level would be ineffective, as they would be; processed after the CCSD computation completes. Basis Sets¶. Basis Sets; Built-In Basis Sets; Mixing Basis Sets; Decontracted Basis Sets; User-Defined Basis Sets. PSI Variables¶; To harness the power of Python, Psi4 makes the most pertinent results; of each computation available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of; H2 and H atom:; molecule h2 {; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h {; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol * (2*h_energy - h2_energy); print ""De=%f"" % D_e. The energy() function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation.; Generally, there are multiple quantities of interest. Appendix; PSI Variables by Module lists PSI variables variables set by each; module, and PSI Variables by Alpha defines them. These can be; accessed through the get_variable() function. For example, after; performing a density fitted MP2 computation, both the spin component; scaled energy and the unscaled MP2 energy are made available:; e_mp2 = get_variable('MP2 TOTAL ENERGY'); e_scs_mp2 = get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/psithoninput-1.html:8172,energy,energy,8172,psi4manual/1.0.0/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/psithoninput-1.html,2,['energy'],['energy']
Energy Efficiency,"nnot run adcc because the passed reference wavefunction is ""; ""not supported in adcc. Check Psi4 SCF parameters. adcc reports: ""; ""{}"".format(str(ex))); core.print_out(""\n""). # TODO Should a non-converged calculation throw?. #; # Interpret results; #; # Note: This wavefunction is not consistent ... the density; # is e.g. not the proper one (i.e. not the MP(n) one); adc_wfn = core.Wavefunction(ref_wfn.molecule(), ref_wfn.basisset()); adc_wfn.shallow_copy(ref_wfn); adc_wfn.set_reference_wavefunction(ref_wfn); adc_wfn.set_name(name); adc_wfn.set_module(""adcc""). # MP(3) energy for CVS-ADC(3) calculations is still a missing feature in adcc; # ... we store this variant here to be able to fall back to MP(2) energies.; is_cvs_adc3 = state.method.level >= 3 and state.ground_state.has_core_occupied_space. # Ground-state energies; mp = state.ground_state; mp_energy = mp.energy(state.method.level if not is_cvs_adc3 else 2); mp_corr = 0.0; if state.method.level > 1:; core.print_out(""Ground state energy breakdown:\n""); core.print_out("" Energy SCF {0:15.8g} [Eh]\n"".format(ref_wfn.energy())); for level in range(2, state.method.level + 1):; if level >= 3 and is_cvs_adc3:; continue; energy = mp.energy_correction(level); mp_corr += energy; adc_wfn.set_variable(f""MP{level} CORRELATION ENERGY"", energy); adc_wfn.set_variable(f""MP{level} TOTAL ENERGY"", mp.energy(level)); core.print_out(f"" Energy correlation MP{level} {energy:15.8g} [Eh]\n""); core.print_out("" Energy total {0:15.8g} [Eh]\n"".format(mp_energy)); adc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", mp_corr) # P::e ADC; adc_wfn.set_variable(""CURRENT ENERGY"", mp_energy) # P::e ADC. # Set results of excited-states computation; # TODO Does not work: Can't use strings; # adc_wfn.set_variable(""excitation kind"", state.kind); adc_wfn.set_variable(""ADC ITERATIONS"", state.n_iter) # P::e ADC; adc_wfn.set_variable(name + "" excitation energies"",; core.Matrix.from_array(state.excitation_energy.reshape(-1, 1))); adc_wfn.set_variable(""number of",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:115586,energy,energy,115586,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,4,['energy'],['energy']
Energy Efficiency,"no-lccd; linear ccd with frozen natural orbitals; CC_TYPE CONV. fno-cepa(0), fno-lccsd; cepa(0) with frozen natural orbitals; CC_TYPE CONV. fno-cepa(1); cepa(1) with frozen natural orbitals; CC_TYPE CONV. fno-cepa(3); cepa(3) with frozen natural orbitals; CC_TYPE CONV. fno-acpf; acpf with frozen natural orbitals; CC_TYPE CONV. fno-aqcc; aqcc with frozen natural orbitals; CC_TYPE CONV. fno-cisd; cisd with frozen natural orbitals; CI_TYPE CONV. Basic FNOCC Keywords¶. BASIS¶. Primary basis set. Available basis sets. Type: string; Possible Values: basis string; Default: No Default. FREEZE_CORE¶. Specifies how many core orbitals to freeze in correlated computations. TRUE will default to freezing the standard default number of core orbitals. For PSI, the standard number of core orbitals is the number of orbitals in the nearest previous noble gas atom. More precise control over the number of frozen orbitals can be attained by using the keywords NUM_FROZEN_DOCC (gives the total number of orbitals to freeze, program picks the lowest-energy orbitals) or FROZEN_DOCC (gives the number of orbitals to freeze per irreducible representation). Type: string; Possible Values: FALSE, TRUE; Default: FALSE. R_CONVERGENCE¶. Convergence for the CC amplitudes. Note that convergence is met only when E_CONVERGENCE and R_CONVERGENCE are satisfied. Type: conv double; Default: 1.0e-7. E_CONVERGENCE¶. Convergence criterion for CC energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Note that convergence is met only when E_CONVERGENCE and R_CONVERGENCE are satisfied. Type: conv double; Default: 1.0e-6. MAXITER¶. Maximum number of CC iterations. Type: integer; Default: 100. DIIS_MAX_VECS¶. Desired number of DIIS vectors. Type: integer; Default: 8. NAT_ORBS¶. Do use MP2 NOs to truncate virtual space for QCISD/CCSD and (T)?. Type: boolean; Default: false. OCC_TOLERANCE¶. Cutoff for occupation of MP2 virtual NOs in FNO-QCISD/CCSD(T). Virtual NOs with ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/fnocc-1.html:15432,energy,energy,15432,psi4manual/1.1.0/fnocc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/fnocc-1.html,6,['energy'],['energy']
Energy Efficiency,"nomerA, monomerB). def sapt_empirical_dispersion(name, dimer_wfn, **kwargs):; sapt_dimer = dimer_wfn.molecule(); sapt_dimer, monomerA, monomerB = prepare_sapt_molecule(sapt_dimer, ""dimer""); disp_name = name.split(""-"")[1]. # Get the names right between SAPT0 and FISAPT0; saptd_name = name.split('-')[0].upper(); if saptd_name == ""SAPT0"":; sapt0_name = ""SAPT0""; else:; sapt0_name = ""SAPT"". save_pair = (saptd_name == ""FISAPT0""). from .proc import build_disp_functor; _, _disp_functor = build_disp_functor('hf-' + disp_name, restricted=True, save_pairwise_disp=save_pair, **kwargs). ## Dimer dispersion; dimer_disp_energy = _disp_functor.compute_energy(dimer_wfn.molecule(), dimer_wfn); ## Monomer dispersion; mon_disp_energy = _disp_functor.compute_energy(monomerA); mon_disp_energy += _disp_functor.compute_energy(monomerB). disp_interaction_energy = dimer_disp_energy - mon_disp_energy; core.set_variable(saptd_name + ""-D DISP ENERGY"", disp_interaction_energy); core.set_variable(""SAPT DISP ENERGY"", disp_interaction_energy); core.set_variable(""DISPERSION CORRECTION ENERGY"", disp_interaction_energy); core.set_variable(saptd_name + ""DISPERSION CORRECTION ENERGY"", disp_interaction_energy). ## Set SAPT0-D3 variables; total = disp_interaction_energy; saptd_en = {}; saptd_en['DISP'] = disp_interaction_energy; for term in ['ELST', 'EXCH', 'IND']:; en = core.variable(' '.join([sapt0_name, term, 'ENERGY'])); saptd_en[term] = en; core.set_variable(' '.join([saptd_name + '-D', term, 'ENERGY']), en); core.set_variable(' '.join(['SAPT', term, 'ENERGY']), en); total += en. core.set_variable(saptd_name + '-D TOTAL ENERGY', total); core.set_variable('SAPT TOTAL ENERGY', total); core.set_variable('CURRENT ENERGY', total). ## Print Energy Summary; units = (1000.0, constants.hartree2kcalmol, constants.hartree2kJmol); core.print_out(f"" => {saptd_name +'-D'} Energy Summary <=\n""). core.print_out("" "" + ""-"" * 104 + ""\n""); core.print_out(; "" %-25s % 16.8f [mEh] % 16.8f [kcal/mol] % 16.8f [kJ/mol]\n"" %; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc_util.html:9275,ENERGY,ENERGY,9275,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc_util.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc_util.html,3,['ENERGY'],['ENERGY']
Energy Efficiency,"norm is smaller than this value DIIS starts. Type: double; Default: 1e-2. DMRG_SCF_GRAD_THR¶. The density RMS convergence to stop an instruction during successive DMRG instructions. Type: double; Default: 1.e-6. DMRG_SCF_MAX_ITER¶. Maximum number of DMRG iterations. Type: integer; Default: 100. DMRG_SCF_STATE_AVG¶. Whether or not to use state-averaging for roots >=2 with DMRG-SCF. Type: boolean; Default: true. DMRG_SWEEP_DVDSON_RTOL¶. The residual tolerances for the Davidson diagonalization during DMRG instructions. Type: array; Default: No Default. DMRG_SWEEP_ENERGY_CONV¶. The energy convergence to stop an instruction during successive DMRG instructions. Type: array; Default: No Default. DMRG_SWEEP_MAX_SWEEPS¶. The maximum number of sweeps to stop an instruction during successive DMRG instructions. Type: array; Default: No Default. DMRG_SWEEP_NOISE_PREFAC¶. The noise prefactors for successive DMRG instructions. Type: array; Default: No Default. DMRG_SWEEP_STATES¶. The number of reduced renormalized basis states to be retained during successive DMRG instructions. Type: array; Default: No Default. DMRG_UNITARY_WRITE¶. Whether or not to store the unitary on disk (convenient for restarting). Type: boolean; Default: true. table of contents. DMRG; General; DMRG_CASPT2_CALC; DMRG_CASPT2_IMAG; DMRG_CASPT2_IPEA; DMRG_CASPT2_ORBS; DMRG_DIIS; DMRG_DIIS_WRITE; DMRG_EXCITATION; DMRG_IRREP; DMRG_LOCAL_INIT; DMRG_MOLDEN_WRITE; DMRG_MPS_WRITE; DMRG_MULTIPLICITY; DMRG_OPDM_AO_PRINT; DMRG_PRINT_CORR; DMRG_SCF_ACTIVE_SPACE; DMRG_SCF_DIIS_THR; DMRG_SCF_GRAD_THR; DMRG_SCF_MAX_ITER; DMRG_SCF_STATE_AVG; DMRG_SWEEP_DVDSON_RTOL; DMRG_SWEEP_ENERGY_CONV; DMRG_SWEEP_MAX_SWEEPS; DMRG_SWEEP_NOISE_PREFAC; DMRG_SWEEP_STATES; DMRG_UNITARY_WRITE. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Appendices; Keywords by Module; DMRG. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodir_options_c/module__dmrg.html:3428,reduce,reduced,3428,psi4manual/1.6.x/autodir_options_c/module__dmrg.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodir_options_c/module__dmrg.html,2,['reduce'],['reduced']
Energy Efficiency,"not converge within the maximum number of iterations.""); core.print_out(""You can increase the number of BCCD iterations by changing BCCD_MAXITER.\n\n""); break; bcc_iter_cnt += 1. if bcc_iter_cnt == 1:; for pv in hold_qcvars:; hold_qcvars[pv] = ref_wfn.variable(pv). ref_wfn.set_variable(""BCCD TOTAL ENERGY"", ref_wfn.variable(""CCSD TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD CORRELATION ENERGY"", ref_wfn.variable(""BCCD TOTAL ENERGY"") - ref_wfn.variable(""SCF TOTAL ENERGY"")); ref_wfn.set_variable(""CURRENT CORRELATION ENERGY"", ref_wfn.variable(""BCCD CORRELATION ENERGY"")). # copy back canonical MP2 and CCSD from initial iteration; for pv, v in hold_qcvars.items():; if v is not None:; ref_wfn.set_variable(pv, v); core.set_variable(pv, v). if name == 'bccd(t)':; core.cctriples(ref_wfn); ref_wfn.set_variable(""B(T) CORRECTION ENERGY"", ref_wfn.variable(""(T) CORRECTION ENERGY"")); ref_wfn.set_variable(""BCCD(T) TOTAL ENERGY"", ref_wfn.variable(""CCSD(T) TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD(T) CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) TOTAL ENERGY"") - ref_wfn.variable(""SCF TOTAL ENERGY"")) # note != CCSD(T) CORRELATION ENERGY; ref_wfn.set_variable(""CURRENT CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) CORRELATION ENERGY"")). for pv in [""(T) CORRECTION ENERGY"", ""CCSD(T) TOTAL ENERGY"", ""CCSD(T) CORRELATION ENERGY""]:; ref_wfn.del_variable(pv); core.del_variable(pv). for pv in [; ""BCCD TOTAL ENERGY"",; ""BCCD CORRELATION ENERGY"",; ""B(T) CORRECTION ENERGY"",; ""BCCD(T) TOTAL ENERGY"",; ""BCCD(T) CORRELATION ENERGY"",; ""CURRENT CORRELATION ENERGY"",; ]:; if ref_wfn.has_variable(pv):; core.set_variable(pv, ref_wfn.variable(pv)). # Notes; # * BCCD or BCCD(T) correlation energy is total energy of last Brueckner iteration minus HF energy of first Brueckner iteration. optstash.restore(); return ref_wfn. def run_tdscf_excitations(wfn,**kwargs):. states = core.get_option(""SCF"",""TDSCF_STATES""). # some sanity checks; if sum(states) == 0:; raise ValidationError(""TDSCF: No states requested in TDSCF_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:97890,ENERGY,ENERGY,97890,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,4,['ENERGY'],['ENERGY']
Energy Efficiency,"not exactly satisfy requirements of stage_scheme.; An exception is the default, 'highest_1', which uses the best basis; set available. See Extrapolation Schemes for all available schemes. Parameters:; scf_scheme (function) – highest_1 || scf_xtpl_helgaker_3 || etc.; Indicates the basis set extrapolation scheme to be applied to the reference energy. corl_scheme (function) – highest_1 || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the correlation energy. delta_scheme (function) – highest_1 || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the delta correction; to the correlation energy. delta2_scheme (function) – highest_1 || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the second delta correction; to the correlation energy. delta3_scheme (function) – highest_1 || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the third delta correction; to the correlation energy. delta4_scheme (function) – highest_1 || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the fourth delta correction; to the correlation energy. delta5_scheme (function) – highest_1 || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the fifth delta correction; to the correlation energy. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> cbs('scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> cbs('mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> cbs('scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). >>> # [4] DT-zeta extrapolated mp2 corr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/cbs-1.html:7911,energy,energy,7911,psi4manual/4.0b5/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/cbs-1.html,2,['energy'],['energy']
Energy Efficiency,"not found in path or execution failed: %s\n' % (external_exe, e.strerror)); core.print_out('Program %s not found in path or execution failed: %s\n' % (external_exe, e.strerror)); message = (""Program %s not found in path or execution failed: %s\n"" % (external_exe, e.strerror)); raise ValidationError(message). c4out = ''; while True:; data = retcode.stdout.readline(); if not data:; break; core.print_out(data.decode('utf-8')); c4out += data.decode('utf-8'). # Scan iface file and grab the file energy.; ene = 0.0; for line in open('iface'):; fields = line.split(); m = fields[1]; try:; ene = float(fields[5]); if m == ""MP(2)"":; m = ""MP2""; elif m == ""CCSD[T]"":; m = ""CCSD+T(CCSD)""; elif m == ""CCSD(T)_L"":; m = ""A-CCSD(T)""; ref_wfn.set_variable(m + ' TOTAL ENERGY', ene); ref_wfn.set_variable(m + ' CORRELATION ENERGY', ene - vscf); except ValueError:; continue. # The last 'ene' in iface is the one the user requested.; ref_wfn.set_variable('CURRENT ENERGY', ene); ref_wfn.set_variable('CURRENT CORRELATION ENERGY', ene - vscf). for subm in [""MP2"", ""CCSD""]:; if ref_wfn.has_variable(f""{subm} TOTAL ENERGY"") and core.get_option(""SCF"", ""REFERENCE"") in [""RHF"", ""UHF""]:; ref_wfn.set_variable(f""{subm} SINGLES ENERGY"", 0.0); ref_wfn.set_variable(f""{subm} DOUBLES ENERGY"", ref_wfn.variable(f""{subm} CORRELATION ENERGY"")). if ref_wfn.has_variable(""CCSD(T) CORRELATION ENERGY"") and ref_wfn.has_variable(""CCSD CORRELATION ENERGY""):; ref_wfn.set_variable(""(T) CORRECTION ENERGY"", ref_wfn.variable(""CCSD(T) CORRELATION ENERGY"") - ref_wfn.variable(""CCSD CORRELATION ENERGY"")). if ref_wfn.has_variable(""A-CCSD(T) CORRELATION ENERGY"") and ref_wfn.has_variable(""CCSD CORRELATION ENERGY""):; ref_wfn.set_variable(""A-(T) CORRECTION ENERGY"", ref_wfn.variable(""A-CCSD(T) CORRELATION ENERGY"") - ref_wfn.variable(""CCSD CORRELATION ENERGY"")). # Load the iface file; iface = open('iface', 'r'); iface_contents = iface.read(). # Delete mrcc tempdir; os.chdir('..'); try:; # Delete unless we're told not to; if (keep is False a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:164726,ENERGY,ENERGY,164726,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,4,['ENERGY'],['ENERGY']
Energy Efficiency,"not in core.get_global_option('SCF_TYPE'):; raise ValidationError('DF-MP2 gradients need DF-SCF reference.'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if ref_wfn.basisset().has_ECP():; raise ValidationError('DF-MP2 gradients with an ECP are not yet available. Use dertype=0 to select numerical gradients.'). core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dfmp2_wfn = core.dfmp2(ref_wfn); grad = dfmp2_wfn.compute_gradient(); dfmp2_wfn.set_gradient(grad). # Shove variables into global space; dfmp2_wfn.set_variable(""MP2 TOTAL GRADIENT"", grad) # P::e DFMP2; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')); for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfmp2d_gradient(name, **kwargs):; """"""Encode MP2-D method."""""". dfmp2_wfn = run_dfmp2_gradient('mp2', **kwargs); wfn_grad = dfmp2_wfn.gradient().clone(). _, _disp_functor = build_disp_functor('MP2D', restricted=True); disp_grad = _disp_functor.compute_gradient(dfmp2_wfn.molecule(), dfmp2_wfn); wfn_grad.add(disp_grad); dfmp2_wfn.set_gradient(wfn_grad). dfmp2_wfn.set_variable('MP2D CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY') + dfmp2_wfn.variable('DISPERSION CORRECTION ENERGY')); dfmp2_wfn.set_variable('MP2D TOTAL ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY') + dfmp2_wfn.variable('HF TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2D TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:84388,ENERGY,ENERGY,84388,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,4,['ENERGY'],['ENERGY']
Energy Efficiency,"not procedures['energy'][lowername] == run_scf and not procedures['energy'][lowername] == run_dft:; PsiMod.set_global_option('E_CONVERGENCE', 10). # Obtain list of displacements; displacements = PsiMod.fd_geoms_freq_0(irrep); molecule.fix_orientation(True); molecule.reinterpret_coordentry(False); # Make a note of the undisplaced molecule's symmetry; PsiMod.set_parent_symmetry(molecule.schoenflies_symbol()). ndisp = len(displacements). # This version is pretty dependent on the reference geometry being last (as it is now); print(' %d displacements needed.' % ndisp); energies = []; for n, displacement in enumerate(displacements):; # Print information to output.dat; PsiMod.print_out('\n'); banner('Loading displacement %d of %d' % (n + 1, ndisp)). # Print information to the screen; print(' %d' % (n + 1), end=""""); if (n + 1) == ndisp:; print('\n', end=''); sys.stdout.flush(). # Load in displacement into the active molecule; molecule.set_geometry(displacement). # Perform the energy calculation; E = func(lowername, **kwargs). # Save the energy; energies.append(E). # clean may be necessary when changing irreps of displacements; PsiMod.clean(). # Obtain the gradient. This function stores the gradient in the wavefunction.; PsiMod.fd_freq_0(energies, irrep). print(' Computation complete.'). # Clear the ""parent"" symmetry now; PsiMod.set_parent_symmetry(""""). # TODO: These need to be restored to the user specified setting; PsiMod.get_active_molecule().fix_orientation(False); # But not this one, it always goes back to True; PsiMod.get_active_molecule().reinterpret_coordentry(True). # The last item in the list is the reference energy, return it; optstash.restore(). # Clear the ""parent"" symmetry now; PsiMod.set_parent_symmetry(""""). # call thermo module; PsiMod.thermo(). optstash.restore(); return energies[-1]. ## Aliases ##; frequencies = frequency; freq = frequency. # hessian to be changed later to compute force constants; [docs]def hessian(name, **kwargs):; r""""""Function to compute f",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/driver.html:66652,energy,energy,66652,psi4manual/4.0b4/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/driver.html,2,['energy'],['energy']
Energy Efficiency,"nough to figure out what auxiliary basis sets are needed for a given computation. In this case, jun-cc-pVDZ is a standard enough basis set (just a simple truncation of the very popular aug-cc-pVDZ basis set) that Psi4 correctly guesses that we want the jun-cc-pVDZ-JKFIT auxiliary basis for the Hartree-Fock, and the jun-cc-pVDZ-RI basis set for the SAPT; procedure.; To speed up the computation a little, we also tell the SAPT procedure to freeze the core electrons by adding 'freeze_core': 'true' to the dictionary passed to psi4.set_options(). The SAPT procedure is invoked by psi4.energy('sapt0/jun-cc-pvdz', molecule=dimer). Here, Psi4 knows to automatically run two monomer computations and a dimer computation and then use these results to perform the SAPT analysis. The various energy components are printed at the end of the output, in addition to; the total SAPT0 interaction energy. An explanation of the various energy components can be found in the review by Jeziorski, Moszynski, and Szalewicz (Jeziorski:1994:1887), and this is discussed in more detail in the SAPT section of the Psi4 manual.; For now, we’ll note that most of the SAPT energy components are negative; this means those are attractive contributions (the zero of energy in a SAPT computation is defined as non-interacting monomers). The exchange contributions are positive (repulsive). In this example, the most attractive contribution between ethylene and acetylene is an electrostatic term of \(-2.12\) kcal/mol (Elst10,r where the 1 indicates the first-order perturbation theory result with respect to the; intermolecular interaction, and the 0 indicates zeroth-order with respect to the intramolecular electron correlation). The next most attractive contribution is the Disp20 term (second order intermolecular dispersion, which looks like MP2 in which one excitation is placed on each monomer), contributing an attraction of \(-1.21\) kcal/mol. It is not surprising that the electrostatic contribution is dominant, b",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psiapi-1.html:15252,energy,energy,15252,psi4manual/1.3.2/psiapi-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psiapi-1.html,11,['energy'],['energy']
Energy Efficiency,"np = {; 'molecule': self.to_schema(dtype=2),; 'driver': derdriver,; 'model': {; 'method': func,; 'basis': '(auto)',; },; 'keywords': {; 'verbose': verbose,; },; }; try:; jobrec = qcng.compute(resinp, 'mctc-gcp', raise_error=True); except qcng.exceptions.ResourceError:; jobrec = qcng.compute(resinp, 'gcp', raise_error=True). jobrec = jobrec.dict(). # hack (instead of checking dertype GRAD) to collect `(nat, 3)` ndarray of gradient if present; for variable_name, qcv in jobrec['extras']['qcvars'].items():; if isinstance(qcv, (list, np.ndarray)):; jobrec['extras']['qcvars'][variable_name] = np.array(qcv).reshape(-1, 3). if isinstance(self, Molecule):; pass; else:; from psi4 import core. for variable_name, qcv in jobrec['extras']['qcvars'].items():; if not isinstance(qcv, (list, np.ndarray)):; core.set_variable(variable_name, float(qcv)). if derint == -1:; return (float(jobrec['extras']['qcvars']['GCP CORRECTION ENERGY']),; jobrec['extras']['qcvars']['GCP CORRECTION GRADIENT']); elif derint == 0:; return float(jobrec['extras']['qcvars']['GCP CORRECTION ENERGY']); elif derint == 1:; return jobrec['extras']['qcvars']['GCP CORRECTION GRADIENT']. @staticmethod; def from_schema(molschema, return_dict=False, verbose=1):; """"""Construct Molecule from non-Psi4 schema. Light wrapper around :py:func:`~qcdb.Molecule.from_arrays`. Parameters; ----------; molschema : dict; Dictionary form of Molecule following known schema.; return_dict : bool, optional; Additionally return Molecule dictionary intermediate.; verbose : int, optional; Amount of printing. Returns; -------; mol : :py:class:`~qcdb.Molecule`; molrec : dict, optional; Dictionary representation of instance.; Only provided if `return_dict` is True. """""". molrec = qcel.molparse.from_schema(molschema, verbose=verbose). if return_dict:; return Molecule.from_dict(molrec), molrec; else:; return Molecule.from_dict(molrec). [docs] def to_schema(self, dtype, units='Bohr'):; """"""Serializes instance into dictionary according to schema `dty",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:47748,ENERGY,ENERGY,47748,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,2,['ENERGY'],['ENERGY']
Energy Efficiency,"np = {; 'molecule': self.to_schema(dtype=2),; 'driver': derdriver,; 'model': {; 'method': func,; 'basis': '(auto)',; },; 'keywords': {; 'verbose': verbose,; },; }; try:; jobrec = qcng.compute(resinp, 'mctc-gcp', raise_error=True); except qcng.exceptions.ResourceError:; jobrec = qcng.compute(resinp, 'gcp', raise_error=True). jobrec = jobrec.dict(). # hack (instead of checking dertype GRAD) to collect `(nat, 3)` ndarray of gradient if present; for variable_name, qcv in jobrec['extras']['qcvars'].items():; if isinstance(qcv, (list, np.ndarray)):; jobrec['extras']['qcvars'][variable_name] = np.array(qcv).reshape(-1, 3). if isinstance(self, Molecule):; pass; else:; from psi4 import core. for variable_name, qcv in jobrec['extras']['qcvars'].items():; if not isinstance(qcv, (list, np.ndarray)):; core.set_variable(variable_name, float(qcv)). if derint == -1:; return (float(jobrec['extras']['qcvars']['GCP CORRECTION ENERGY']),; jobrec['extras']['qcvars']['GCP CORRECTION GRADIENT']); elif derint == 0:; return float(jobrec['extras']['qcvars']['GCP CORRECTION ENERGY']); elif derint == 1:; return jobrec['extras']['qcvars']['GCP CORRECTION GRADIENT']. @staticmethod; def from_schema(molschema, return_dict=False, verbose=1):; """"""Construct Molecule from non-Psi4 schema. Light wrapper around :py:func:`~qcdb.Molecule.from_arrays`. Parameters; ----------; molschema : dict; Dictionary form of Molecule following known schema.; return_dict : bool, optional; Additionally return Molecule dictionary intermediate.; verbose : int, optional; Amount of printing. Returns; -------; mol : :py:class:`~qcdb.Molecule`; molrec : dict, optional; Dictionary representation of instance.; Only provided if `return_dict` is True. """""". molrec = qcel.molparse.from_schema(molschema, verbose=verbose). if return_dict:; return Molecule.from_dict(molrec), molrec; else:; return Molecule.from_dict(molrec). [docs]; def to_schema(self, dtype, units='Bohr'):; """"""Serializes instance into dictionary according to schema `dt",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html:47757,ENERGY,ENERGY,47757,psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html,6,['ENERGY'],['ENERGY']
Energy Efficiency,"np.asarray([mol.mass(at) for at in range(mol.natom())]); irrep_labels = mol.irrep_labels(). vibinfo, vibtext = qcdb.vib.harmonic_analysis(; nmwhess, geom, m, wfn.basisset(), irrep_labels, dipder=dipder, project_trans=project_trans, project_rot=project_rot); vibrec.update({k: qca.to_dict() for k, qca in vibinfo.items()}). core.print_out(vibtext); core.print_out(qcdb.vib.print_vibs(vibinfo, shortlong=True, normco='x', atom_lbl=symbols)). if core.has_option_changed('THERMO', 'ROTATIONAL_SYMMETRY_NUMBER'):; rsn = core.get_option('THERMO', 'ROTATIONAL_SYMMETRY_NUMBER'); else:; rsn = mol.rotational_symmetry_number(). if irrep is None:; therminfo, thermtext = qcdb.vib.thermo(; vibinfo,; T=core.get_option(""THERMO"", ""T""), # 298.15 [K]; P=core.get_option(""THERMO"", ""P""), # 101325. [Pa]; multiplicity=mol.multiplicity(),; molecular_mass=np.sum(m),; sigma=rsn,; rotor_type=mol.rotor_type(),; rot_const=np.asarray(mol.rotational_constants()),; E0=core.variable('CURRENT ENERGY')) # someday, wfn.energy(); vibrec.update({k: qca.to_dict() for k, qca in therminfo.items()}). core.set_variable(""ZPVE"", therminfo['ZPE_corr'].data); core.set_variable(""THERMAL ENERGY CORRECTION"", therminfo['E_corr'].data); core.set_variable(""ENTHALPY CORRECTION"", therminfo['H_corr'].data); core.set_variable(""GIBBS FREE ENERGY CORRECTION"", therminfo['G_corr'].data). core.set_variable(""ZERO K ENTHALPY"", therminfo['ZPE_tot'].data); core.set_variable(""THERMAL ENERGY"", therminfo['E_tot'].data); core.set_variable(""ENTHALPY"", therminfo['H_tot'].data); core.set_variable(""GIBBS FREE ENERGY"", therminfo['G_tot'].data). core.print_out(thermtext); else:; core.print_out(' Thermochemical analysis skipped for partial frequency calculation.\n'). if core.get_option('FINDIF', 'HESSIAN_WRITE'):; filename = core.get_writer_file_prefix(mol.name()) + "".vibrec""; with open(filename, 'w') as handle:; json.dump(vibrec, handle, sort_keys=True, indent=4). if core.get_option('FINDIF', 'NORMAL_MODES_WRITE'):; filename = core.get_writer_file_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html:77026,energy,energy,77026,psi4manual/1.3.2/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html,1,['energy'],['energy']
Energy Efficiency,"np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). variables(include_deprecated_keys=False)¶; Return all scalar or array QCVariables; from self. Parameters:. self – Wavefunction instance.; include_deprecated_keys (bool) – Also return duplicate entries with keys that have been deprecated. Returns:; Map of all QCVariables that have been set on self. Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles or per-atom charges); are returned as ndarray of natural dimensionality.; Other array variables are returned as Matrix and; may have an extra dimension with symmetry information. Return type:; Dict[str, Union[float, ndarray, Matrix]. write_molden(filename=None, do_virtual=None, use_natural=False)¶; Writes wavefunction information in wfn to filename in; molden format. Will write natural orbitals from density (MO basis) if supplied.; Warning! most post-SCF wavefunctions do not build the density as this is often; much more costly than the energy. In addition, the wavefunction density attributes; (Da and Db) return the SO density and must be transformed to the MO basis; to use with this function. Added in version 0.5: wfn parameter passed explicitly. Returns:; None. Parameters:. filename (Optional[str]) – Destination file name for MOLDEN file. If unspecified (None), a file; name will be generated from the molecule name.; do_virtual (Optional[bool]) – Do write all the MOs to the MOLDEN file (True) or discard the unoccupied; MOs (False). Not valid for NO’s. If unspecified (None), value taken from; MOLDEN_WITH_VIRTUAL.; use_natural (bool) – Write natural orbitals determined from density on wavefunction.; self (Wavefunction). Examples:. Molden file with the Kohn-Sham orbitals of a DFT calculation.; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> wfn.molden('mycalc.molden'). Molden file with the natural orbitals of a CCSD computation. For correlated methods, an energy call ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/api/psi4.core.Wavefunction.html:27472,energy,energy,27472,psi4manual/master/api/psi4.core.Wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.Wavefunction.html,2,['energy'],['energy']
Energy Efficiency,"np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). variables(include_deprecated_keys=False)¶; Return all scalar or array QCVariables; from self. Parameters:. self – Wavefunction instance.; include_deprecated_keys (bool) – Also return duplicate entries with keys that have been deprecated. Returns:; Map of all QCVariables that have been set on self. Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles or per-atom charges); are returned as ndarray of natural dimensionality.; Other array variables are returned as Matrix and; may have an extra dimension with symmetry information. Return type:; Dict[str, Union[float, ndarray, Matrix]. write_molden(filename=None, do_virtual=None, use_natural=False)¶; Writes wavefunction information in wfn to filename in; molden format. Will write natural orbitals from density (MO basis) if supplied.; Warning! most post-SCF wavefunctions do not build the density as this is often; much more costly than the energy. In addition, the wavefunction density attributes; (Da and Db) return the SO density and must be transformed to the MO basis; to use with this function. New in version 0.5: wfn parameter passed explicitly. Returns:; None. Parameters:. filename (Optional[str]) – Destination file name for MOLDEN file. If unspecified (None), a file; name will be generated from the molecule name.; do_virtual (Optional[bool]) – Do write all the MOs to the MOLDEN file (True) or discard the unoccupied; MOs (False). Not valid for NO’s. If unspecified (None), value taken from; MOLDEN_WITH_VIRTUAL.; use_natural (bool) – Write natural orbitals determined from density on wavefunction.; self (Wavefunction) – . Examples:. Molden file with the Kohn-Sham orbitals of a DFT calculation.; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> wfn.molden('mycalc.molden'). Molden file with the natural orbitals of a CCSD computation. For correlated methods, an energy call",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Wavefunction.html:27320,energy,energy,27320,psi4manual/1.7.x/api/psi4.core.Wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Wavefunction.html,6,['energy'],['energy']
Energy Efficiency,"npoints == 9):; optx = rvals[4]. # Molecule can be passed in be user. Look at the function definition above.; if mol == None:; mol = psi4.get_active_molecule(); natoms = mol.natom(); if natoms != 2:; raise Exception(""The current molecule must be a diatomic for this code to work!""); m1 = mol.mass(0); m2 = mol.mass(1). maxit = 30; thres = 1.0e-9; for i in range(maxit):; if (npoints == 5):; grad= first_deriv_5pt(rvals, energies, optx); secd = second_deriv_5pt(rvals, energies, optx); energy = function_5pt(rvals, energies, optx); elif (npoints == 9):; grad = first_deriv_9pt(rvals, energies, optx); secd = second_deriv_9pt(rvals, energies, optx); energy = function_9pt(rvals, energies, optx); psi4.print_out("" E = %20.14f, x = %14.7f, grad = %20.14f\n"" % (energy, optx, grad)); if abs(grad) < thres:; break; optx -= grad / secd;; psi4.print_out("" Final E = %20.14f, x = %14.7f, grad = %20.14f\n"" % (function_5pt(rvals, energies, optx), optx, grad));. if optx < min(rvals):; raise Exception(""Minimum energy point is outside range of points provided. Use a lower range of r values.""); if optx > max(rvals):; raise Exception(""Minimum energy point is outside range of points provided. Use a higher range of r values.""). if (npoints == 5):; energy = function_5pt(rvals, energies, optx); first = first_deriv_5pt(rvals, energies, optx); secd = second_deriv_5pt(rvals, energies, optx) * p4const.psi_hartree2aJ; third = third_deriv_5pt(rvals, energies, optx) * p4const.psi_hartree2aJ; fourth = fourth_deriv_5pt(rvals, energies, optx) * p4const.psi_hartree2aJ; elif (npoints == 9):; energy = function_9pt(rvals, energies, optx); first = first_deriv_9pt(rvals, energies, optx); secd = second_deriv_9pt(rvals, energies, optx) * p4const.psi_hartree2aJ; third = third_deriv_9pt(rvals, energies, optx) * p4const.psi_hartree2aJ; fourth = fourth_deriv_9pt(rvals, energies, optx) * p4const.psi_hartree2aJ. psi4.print_out(""\nEquilibrium Energy %20.14f Hartrees\n"" % energy); psi4.print_out(""Gradient %20.14f\n"" % first",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/diatomic.html:3514,energy,energy,3514,psi4manual/4.0b5/_modules/diatomic.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/diatomic.html,2,['energy'],['energy']
Energy Efficiency,"nppp(beta); cbsscheme += f""""""\n Extrapolated Data\n""""""; cbsscheme += nppp(value); cbsscheme += ""\n""; core.print_out(cbsscheme); logger.debug(cbsscheme). return value. else:; raise ValidationError(f""scf_xtpl_truhlar_2: datatype is not recognized '{type(valueLO)}'.""). [docs]def scf_xtpl_karton_2(functionname: str, zLO: int, valueLO: Extrapolatable, zHI: int, valueHI: Extrapolatable, verbose: int = 1, alpha: Optional[float] = None) -> Extrapolatable:; r""""""Extrapolation scheme using root-power form for reference energies with two adjacent; zeta-level bases. Used by :py:func:`~psi4.driver.cbs`. Parameters; ----------; functionname; Name of the CBS component (e.g., 'HF') used in summary printing.; zLO; Zeta number of the smaller basis set in 2-point extrapolation.; valueLO; Energy, gradient, or Hessian value at the smaller basis set in 2-point; extrapolation.; zHI; Zeta number of the larger basis set in 2-point extrapolation; Must be `zLO + 1`.; valueHI; Energy, gradient, or Hessian value at the larger basis set in 2-point; extrapolation.; verbose; Controls volume of printing.; alpha; Overrides the default :math:`\alpha = 6.3`. Returns; -------; float or ~numpy.ndarray; Eponymous function applied to input zetas and values; type from `valueLO`. Notes; -----; The extrapolation is calculated according to [3]_:; :math:`E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha\sqrt{X}}, \alpha = 6.3`. References; ----------. .. [3] Karton, Martin, Theor. Chem. Acc. 115 (2006) 330-333,; DOI: 10.1007/s00214-005-0028-6. """""". if type(valueLO) != type(valueHI):; raise ValidationError(; f""scf_xtpl_karton_2: Inputs must be of the same datatype! ({type(valueLO)}, {type(valueHI)})""). if alpha is None:; alpha = 6.30. # prior to April 2022, this wrong expression was used; # beta_division = 1 / (math.exp(-1 * alpha) * (math.exp(math.sqrt(zHI)) - math.exp(math.sqrt(zLO)))); beta_division = 1 / (math.exp(-1 * alpha * math.sqrt(zHI)) - math.exp(-1 * alpha * math.sqrt(zLO))); beta_mult = math.exp(-",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_cbs_helper.html:10564,Energy,Energy,10564,psi4manual/1.7.x/_modules/psi4/driver/driver_cbs_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_cbs_helper.html,1,['Energy'],['Energy']
Energy Efficiency,"nput and set symmetry. omp2_5-grad2; OMP2.5 cc-pVDZ gradient for the NO radical. cc38; RHF-CC2-LR/cc-pVDZ static polarizabilities of HOF molecule. mrcc3; CCSD(T) cc-pVDZ geometry optimization for the H2O molecule using MRCC. opt3; SCF cc-pVDZ geometry optimzation, with Z-matrix input. omp2_5-2; OMP2 cc-pVDZ energy for the H2O molecule. cc3; cc3: RHF-CCSD/6-31G** H2O geometry optimization and vibrational frequency analysis by finite-differences of gradients. scf-bz2; Benzene Dimer Out-of-Core HF/cc-pVDZ. cc51; EOM-CC3/cc-pVTZ on H2O. fci-h2o-2; 6-31G H2O Test FCI Energy Point. mp2-grad2; MP2 cc-pVDZ gradient for the NO radical. cc31; CCSD/sto-3g optical rotation calculation (both gauges) at two frequencies on methyloxirane. psimrcc-ccsd_t-1; Mk-MRCCSD(T) single point. CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. cc11; Frozen-core CCSD(ROHF)/cc-pVDZ on CN radical with disk-based AO algorithm. pywrap-checkrun-rhf; This checks that all energy methods can run with a minimal input and set symmetry. fd-freq-energy-large; SCF DZ finite difference frequencies by energies for C4NH4. cc33; CC3(UHF)/cc-pVDZ H2O geom from Olsen et al., JCP 104, 8007 (1996). dft-grad; DF-BP86-D2 cc-pVDZ frozen core gradient of S22 HCN. tu6-cp-ne2; Example potential energy surface scan and CP-correction for Ne2. cc30; CCSD/sto-3g optical rotation calculation (length gauge only) at two frequencies on methyloxirane. omp3-3; OMP3 cc-pVDZ energy with B3LYP initial guess for the NO radical. sapt3; SAPT2+3(CCD) aug-cc-pVDZ computation of the water dimer interaction energy, using the aug-cc-pVDZ-JKFIT DF basis for SCF and aug-cc-pVDZ-RI for SAPT. scf5; Test of all different algorithms and reference types for SCF, on singlet and triplet O2, using the cc-pVTZ basis set. pywrap-opt-sowreap; Finite difference optimization, run in sow/reap mode. cc8a; ROHF-CCSD(T) cc-pVDZ frozen-core energy for the state of the CN radical, with Cartesian input. opt1-fd; SCF STO-3G ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodoc_testsuite-1.html:17088,energy,energy,17088,psi4manual/4.0b4/autodoc_testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodoc_testsuite-1.html,8,['energy'],['energy']
Energy Efficiency,"nput is sufficient to run the requested information. Notice we didn’t tell the program some otherwise useful information like the charge of the molecule (0, it’s neutral), the spin multiplicity (1 for a closed-shell molecule with all electrons paired), or the reference wavefunction to use (restricted Hartree-Fock, or RHF, is usually appropriate for a closed-shell molecule). The program correctly guessed all of these options for us. We can change the default behavior through; additional keywords.; Let’s consider what we would do for an open-shell molecule, where not all the electrons are paired. For example, let’s run a computation on methylene (\(\text{CH}_2\)), whose ground electronic state has two unpaired electrons (triplet electronic state, or a spin multiplicity \(2S + 1 = 3\)). In this case, the default spin multiplicity (1) is not correct, so we need to tell the program the true value (3). Like many programs, Psi4 can get the charge and multiplicity as the first two; integers in the Z-matrix (note the line with 0 3 at the beginning of the molecule specification below). In this example, we will also specify the bond length and bond angle as variables (\(R\) and \(A\)), whose values are first stored and then inserted into the geometry specification using Python 3 string formatting. [4]:. #! Sample UHF/6-31G** CH2 Computation. R = 1.075; A = 133.93. ch2 = psi4.geometry(""""""; 0 3; C; H 1 {0}; H 1 {0} 2 {1}; """""".format(R, A); ). psi4.set_options({'reference': 'uhf'}); psi4.energy('scf/6-31g**'). [4]:. -38.925334628859886. Executing this cell should yield the final energy as; @DF-UHF Final Energy: -38.92533462887677. Notice the new command, psi4.set_options() API, to the input. This function takes a Python dictionary as its argument, which is a key-value list which associates a Psi4 keyword with its user-defined value. For open shell molecules, we have a choice of unrestricted orbitals; (unrestricted Hartree-Fock, or UHF) or restricted orbitals (restricted open-shell",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psiapi-1.html:5189,charge,charge,5189,psi4manual/1.3.2/psiapi-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psiapi-1.html,11,['charge'],['charge']
Energy Efficiency,"nput. Various gradients for a strained helium dimer and water molecule. dfccsd1; DF-CCSD cc-pVDZ energy for the H2O molecule. cc13b; Tests RHF CCSD(T)gradients. x2c1; Test of SFX2C-1e on water uncontracted cc-pVDZ-DK The reference numbers are from Lan Cheng’s implementation in Cfour. scf-property; UFH and B3LYP cc-pVQZ properties for the CH2 molecule. dfomp2p5-2; DF-OMP2.5 cc-pVDZ energy for the H2O+ cation. opt14; 6-31G(d) optimization of SF4 starting from linear bond angle that is not linear in the optimized structure but is in a symmetry plane of the molecule. dcft-grad1; DCFT DC-06 gradient for the O2 molecule with cc-pVDZ basis set. pywrap-checkrun-rhf; This checks that all energy methods can run with a minimal input and set symmetry. opt5; 6-31G** UHF CH2 3B1 optimization. Uses a Z-Matrix with dummy atoms, just for demo and testing purposes. cc53; Matches Table II a-CCSD(T)/cc-pVDZ H2O @ 2.5 * Re value from Crawford and Stanton, IJQC 98, 601-611 (1998). dfomp3-1; DF-OMP3 cc-pVDZ energy for the H2O molecule. psithon1; Spectroscopic constants of H2, and the full ci cc-pVTZ level of theory. tu5-sapt; Example SAPT computation for ethene*ethine (i.e., ethylene*acetylene), test case 16 from the S22 database. cc39; RHF-CC2-LR/cc-pVDZ dynamic polarizabilities of HOF molecule. cc18; RHF-CCSD-LR/cc-pVDZ static polarizability of HOF. dfomp2-1; OMP2 cc-pVDZ energy for the H2O molecule. cc35; CC3(ROHF)/cc-pVDZ H2O \(R_e\) geom from Olsen et al., JCP 104, 8007 (1996). fd-freq-energy-large; SCF DZ finite difference frequencies by energies for C4NH4. dfomp2-grad2; OMP2 cc-pVDZ energy for the NO molecule. cc1; RHF-CCSD 6-31G** all-electron optimization of the H2O molecule. psimrcc-sp1; Mk-MRCCSD single point. \(^3 \Sigma ^-\) O2 state described using the Ms = 0 component of the triplet. Uses ROHF triplet orbitals. castup2; SCF with various combinations of pk/density-fitting, castup/no-castup, and spherical/cartesian settings. Demonstrates that puream setting is getting set by o",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/testsuite-1.html:14444,energy,energy,14444,psi4manual/1.1.0/testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/testsuite-1.html,4,['energy'],['energy']
Energy Efficiency,"nput. cepa2; cc-pvdz H2O Test ACPF Energy/Properties. rasci-ne; Ne atom RASCI/cc-pVQZ Example of split-virtual CISD[TQ] from Sherrill and Schaefer, J. Phys. Chem. XXX This uses a “primary” virtual space 3s3p (RAS 2), a “secondary” virtual space 3d4s4p4d4f (RAS 3), and a “tertiary” virtual space consisting of the remaining virtuals. First, an initial CISD computation is run to get the natural orbitals; this allows a meaningful partitioning of the virtual orbitals into groups of different importance. Next, the RASCI is run. The split-virtual CISD[TQ] takes all singles and doubles, and all triples and quadruples with no more than 2 electrons in the secondary virtual subspace (RAS 3). If any electrons are present in the tertiary virtual subspace (RAS 4), then that excitation is only allowed if it is a single or double. cc5a; RHF CCSD(T) STO-3G frozen-core energy of C4NH4 Anion. ocepa2; OCEPA cc-pVDZ energy with B3LYP initial guess for the NO radical. mcscf3; RHF 6-31G** energy of water, using the MCSCF module and Z-matrix input. frac; Carbon/UHF Fractionally-Occupied SCF Test Case. pywrap-basis; SAPT calculation on bimolecular complex where monomers are unspecified so driver auto-fragments it. Basis set and auxiliary basis sets are assigned by atom type. psimrcc-sp1; Mk-MRCCSD single point. O2 state described using the Ms = 0 component of the triplet. Uses ROHF triplet orbitals. fd-freq-gradient; STO-3G frequencies for H2O by finite-differences of gradients. dfmp2-1; Density fitted MP2 cc-PVDZ/cc-pVDZ-RI computation of formic acid dimer binding energy using automatic counterpoise correction. Monomers are specified using Cartesian coordinates. cc13; UHF-CCSD/cc-pVDZ CH2 geometry optimization via analytic gradients. cc34; RHF-CCSD/cc-pVDZ energy of H2O partitioned into pair energy contributions. cepa3; cc-pvdz H2O Test coupled-pair CISD against DETCI CISD. cisd-opt-fd; H2O CISD/6-31G** Optimize Geometry by Energies. omp2-grad2; OMP2 cc-pVDZ gradient for the NO radical. mr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodoc_testsuite-1.html:5388,energy,energy,5388,psi4manual/4.0b4/autodoc_testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodoc_testsuite-1.html,8,['energy'],['energy']
Energy Efficiency,"nput. mcscf3; RHF 6-31G** energy of water, using the MCSCF module and Z-matrix input. scf-dipder; Test SCF dipole derivatives against old Psi3 reference values. dfccsdat1; DF-CCSD(AT) cc-pVDZ energy for the H2O molecule. pywrap-checkrun-rohf; This checks that all energy methods can run with a minimal input and set symmetry. cc4a; RHF-CCSD(T) cc-pVQZ frozen-core energy of the BH molecule, with Cartesian input. This version tests the FROZEN_DOCC option explicitly. dft-psivar; HF and DFT variants single-points on zmat methane, mostly to test that PSI variables are set and computed correctly. Now also testing that CSX harvesting PSI variables correctly update ref_dft_2e/xc due to new BraggSlater radii. fci-tdm-2; BH-H2+ FCI/cc-pVDZ Transition Dipole Moment. mints-benchmark; run some BLAS benchmarks. mp2-grad1; MP2 cc-pVDZ gradient for the H2O molecule. mints12; test roundtrip-ness of dict repr for psi4.core.Molecule and qcdb.Molecule. cc13c; Tests RHF CCSD(T)gradients. ao-casscf-sp; CASSCF/6-31G** energy point. x2c2; Test of SFX2C-1e on Water cc-pVDZ-DK. In this test the Dirac equation is solved in the uncontracted cc-pVDZ-DK basis. The reference numbers are from Lan Cheng’s implementation in Cfour. dft-freq-analytic; Analytic SVWN frequencies, compared to finite difference values. cc55; EOM-CCSD/6-31g excited state transition data for water with two excited states per irrep. dct5; DC-06 calculation for the O2 molecule (triplet ground state). This performs geometry optimization using two-step and simultaneous solution of the response equations for the analytic gradient. fnocc1; Test QCISD(T) for H2O/cc-pvdz Energy. ao-dfcasscf-sp; CASSCF/6-31G** energy point. opt5; 6-31G** UHF CH2 3B1 optimization. Uses a Z-Matrix with dummy atoms, just for demo and testing purposes. cc-module; check that CC is returning the same values btwn CC*, FNOCC, and DFOCC modules. tu4-h2o-freq; Optimization followed by frequencies H2O HF/cc-pVDZ. dct10; The multiple guesses for DCT amplitudes for",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html:15784,energy,energy,15784,psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"nputs — Psi4 [1.0.0 6a9a71b] Docs. Navigation. index. modules    . toc    . next    . previous    ; Psi4 [1.0.0 6a9a71b] » ; Appendices ». Test Suite and Sample Inputs¶; Psi4 is distributed with an extensive test suite, which can; be found in psi4/tests. After building the source code, these; can automatically be run by running ctest in the compilation; directory. More info on ctest options can be found on the; Wiki. Sample input files; can be found in the the psi4/samples subdirectory of the top-level Psi; directory. The samples and a brief description are provided below.; Sample inputs accessible through interfaced executables are bulleted below. DFTD3; MRCC; CFOUR; LIBEFP; PCMSOLVER; DMRG. Sample inputs for Psi4 as distributed are below. Input File; Description. cc24; Single point gradient of 1-2B1 state of H2O+ with EOM-CCSD. cc53; Matches Table II a-CCSD(T)/cc-pVDZ H2O @ 2.5 * Re value from Crawford and Stanton, IJQC 98, 601-611 (1998). soscf2; Triple and Singlet Oxygen energy SOSCF, also tests non-symmetric density matrices. cbs-xtpl-gradient; Various gradients for a strained helium dimer and water molecule. mints5; Tests to determine full point group symmetry. Currently, these only matter for the rotational symmetry number in thermodynamic computations. dcft-grad1; DCFT DC-06 gradient for the O2 molecule with cc-pVDZ basis set. pubchem2; Superficial test of PubChem interface. cepa-module; routing check on lccd, lccsd, cepa(0). cc4a; RHF-CCSD(T) cc-pVQZ frozen-core energy of the BH molecule, with Cartesian input. This version tests the FROZEN_DOCC option explicitly. decontract; RHF/cc-pvdz-decontract HCl single-point energy Testing the in line -decontract option for basis sets. dfomp2-grad2; OMP2 cc-pVDZ energy for the NO molecule. pywrap-all; Intercalls among python wrappers- database, cbs, optimize, energy, etc. Though each call below functions individually, running them all in sequence or mixing up the sequence is aspirational at present. Also aspirational i",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/testsuite-1.html:1016,energy,energy,1016,psi4manual/1.0.0/testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/testsuite-1.html,2,['energy'],['energy']
Energy Efficiency,"nrestricted DF-DCFT ODC-12 gradient for O2 with cc-pVTZ/cc-pVTZ-RI standard/auxiliary basis set. mints8; Patch of a glycine with a methyl group, to make alanine, then DF-SCF energy calculation with the cc-pVDZ basis set. ocepa-grad1; OCEPA cc-pVDZ gradient for the H2O molecule. fd-gradient; SCF STO-3G finite-difference tests. psimrcc-sp1; Mk-MRCCSD single point. O2 state described using the Ms = 0 component of the triplet. Uses ROHF triplet orbitals. pywrap-db3; Test that Python Molecule class processes geometry like psi4 Molecule class. cc44; Test case for some of the PSI4 out-of-core codes. The code is given only 2.0 MB of memory, which is insufficient to hold either the A1 or B2 blocks of an ovvv quantity in-core, but is sufficient to hold at least two copies of an oovv quantity in-core. fnocc2; Test G2 method for H2O. opt9; Various constrained energy minimizations of HOOH with cc-pvdz RHF. Cartesian-coordinate constrained optimizations of HOOH in internals. omp2-1; OMP2 cc-pVDZ energy for the H2O molecule. cdomp2-2; OMP2 cc-pVDZ energy for the NO molecule. dft-b3lyp; Check flavors of B3LYP (b3lyp3/b3lyp5) against other programs. dfccdl1; DF-CCDL cc-pVDZ energy for the H2O molecule. cc12; Single point energies of multiple excited states with EOM-CCSD. cc43; RHF-CC2-LR/STO-3G optical rotation of (S)-methyloxirane. gauge = both, omega = (589 355 nm). castup3; SCF with various combinations of pk/density-fitting, castup/no-castup, and spherical/cartesian settings. Demonstrates that puream setting is getting set by orbital basis for all df/castup parts of calc. Demonstrates that answer doesn’t depend on presence/absence of castup. Demonstrates (by comparison to castup2) that output file doesn’t depend on options (scf_type) being set global or local. This input uses local. dfccsdt1; DF-CCSD(T) cc-pVDZ energy for the H2O molecule. scf-guess-read; Sample UHF/cc-pVDZ H2O computation on a doublet cation, using RHF/cc-pVDZ orbitals for the closed-shell neutral as a guess. c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html:9445,energy,energy,9445,psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"ns CCSORT, which reorders integrals for use in the coupled cluster codes.; ; cctriples(...); cctriples() -> float :; Runs the coupled cluster (T) energy code.; ; clean(...); clean() -> None :; Function to remove scratch files. Call between independent jobs.; ; close_outfile(...); close_outfile() -> None :; Closes the output file.; ; dcft(...); dcft() -> float :; Runs the density cumulant functional theory code.; ; deriv(...); deriv() -> int :; Runs deriv, which contracts density matrices with derivative integrals, to compute gradients.; ; detci(...); detci() -> float :; Runs the determinant-based configuration interaction code.; ; dfmp2(...); dfmp2() -> float :; Runs the DF-MP2 code.; ; dfmp2grad(...); dfmp2grad() -> float :; Runs the DF-MP2 gradient.; ; dftsapt(...); dftsapt( (Wavefunction)arg1, (Wavefunction)arg2, (Wavefunction)arg3) -> float :; Runs the DFT variant of the symmetry adapted perturbation theory code.; ; fd_1_0(...); fd_1_0( (list)arg1) -> PsiReturnType :; Performs a finite difference gradient computation, from energy points.; ; fd_freq_0(...); fd_freq_0( (list)arg1, (int)arg2) -> PsiReturnType :; Performs a finite difference frequency computation, from energy points, for a given irrep.; ; fd_freq_1(...); fd_freq_1( (list)arg1, (int)arg2) -> PsiReturnType :; Performs a finite difference frequency computation, from gradients, for a given irrep.; ; fd_geoms_1_0(...); fd_geoms_1_0() -> matrix_vector :; Gets the list of displacements needed for a finite difference gradient computation, from energy points.; ; fd_geoms_freq_0(...); fd_geoms_freq_0( (int)arg1) -> matrix_vector :; Gets the list of displacements needed for a finite difference frequency computation, from energy points, for a given irrep.; ; fd_geoms_freq_1(...); fd_geoms_freq_1( (int)arg1) -> matrix_vector :; Gets the list of displacements needed fof a finite difference frequency computation, from gradients, for a given irrep; ; fd_geoms_hessian_0(...); fd_geoms_hessian_0() -> matrix_vector :; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/psimod-1.html:106231,energy,energy,106231,psi4manual/4.0b4/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html,2,['energy'],['energy']
Energy Efficiency,"ns are VCC (=0), ECC (=1), MRCC (=2), and EXTERNAL (=3). The default for all calculations is currently VCC which requests usage of xvcc, but in many cases (e.g., for CCSD and CCSD(T)) ECC should be preferred due to the better performance of xecc (available currently for CCSD, CCSD+T, CCSD(T), and closed-shell CCSDT-n, CC3, and CCSDT). MRCC and External are intended for CC programs outside the CFOUR suite, e.g., the general CC module mrcc written by M. Kallay (Budapest, Hungary). Default: VCC Note: Using the option ECC is not recommended for ROHF gradients. That is, if you are doing a geometry optimization with ROHF as your reference wave function then it is safe to use the option VCC. Psi4 Interface: Keyword set according to best practice for the computational method CFOUR_CALC_LEVEL, reference CFOUR_REFERENCE (NYI) and derivative level CFOUR_DERIV_LEVEL according to Table Best Practices when method specified by argument to computation command (e.g., when energy('c4-ccsd') requested but not when energy('cfour') requested). Value can always be set explicitly. Type: string; Possible Values: VCC, ECC, MRCC, EXTERNAL; Default: VCC. CFOUR_CHARGE (CFOUR); CFOUR — Specifies the molecular charge. Psi4 Interface: Keyword set from active molecule. Type: integer; Default: 0. CFOUR_CIS_CONV (CFOUR); CFOUR — Specifies the convergence threshold as \(10^{-N}\) for CIS calculations. Type: integer; Default: 5. CFOUR_CONTINUUM (CFOUR); CFOUR — Signifies that one or more “continuum” orbitals should be added to the calculation. VIRTUAL and DVIRTUAL specify one or two orbital which should be initially unoccupied (in the SCF calculation), while OCCUPIED and DOCCUPIED specify one or two orbitals which should be initially occupied. Type: string; Possible Values: NONE, VIRTUAL, DVIRTUAL, OCCUPIED, DOCCUPIED; Default: NONE. CFOUR_CONTRACTION (CFOUR); CFOUR — Specifies the contraction scheme used by the integral and integral derivative program. SEGMENTED (=0) uses a segmented contraction schem",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodoc_glossary_options_c-1.html:27748,energy,energy,27748,psi4manual/1.1.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodoc_glossary_options_c-1.html,4,['energy'],['energy']
Energy Efficiency,"ns are VCC (=0), ECC (=1), MRCC (=2), and EXTERNAL (=3). The default for all calculations is currently VCC which requests usage of xvcc, but in many cases (e.g., for CCSD and CCSD(T)) ECC should be preferred due to the better performance of xecc (available currently for CCSD, CCSD+T, CCSD(T), and closed-shell CCSDT-n, CC3, and CCSDT). MRCC and External are intended for CC programs outside the CFOUR suite, e.g., the general CC module mrcc written by M. Kallay (Budapest, Hungary). Default: VCC Note: Using the option ECC is not recommended for ROHF gradients. That is, if you are doing a geometry optimization with ROHF as your reference wave function then it is safe to use the option VCC. Psi4 Interface: Keyword set according to best practice for the computational method CFOUR_CALC_LEVEL, reference CFOUR_REFERENCE (NYI) and derivative level CFOUR_DERIV_LEVEL according to Table Best Practices when method specified by argument to computation command (e.g., when energy('c4-ccsd') requested but not when energy('cfour') requested). Value can always be set explicitly. Type: string; Possible Values: VCC, ECC, MRCC, EXTERNAL; Default: VCC. CFOUR_CHARGE (CFOUR); CFOUR — Specifies the molecular charge. Psi4 Interface: Keyword set from active molecule. Type: integer; Default: 0. CFOUR_CIS_CONV (CFOUR); CFOUR — Specifies the convergence threshold as for CIS calculations. Type: integer; Default: 5. CFOUR_CONTINUUM (CFOUR); CFOUR — Signifies that one or more “continuum” orbitals should be added to the calculation. VIRTUAL and DVIRTUAL specify one or two orbital which should be initially unoccupied (in the SCF calculation), while OCCUPIED and DOCCUPIED specify one or two orbitals which should be initially occupied. Type: string; Possible Values: NONE, VIRTUAL, DVIRTUAL, OCCUPIED, DOCCUPIED; Default: NONE. CFOUR_CONTRACTION (CFOUR); CFOUR — Specifies the contraction scheme used by the integral and integral derivative program. SEGMENTED (=0) uses a segmented contraction scheme; GENERAL (",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html:27986,energy,energy,27986,psi4manual/1.0.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html,4,['energy'],['energy']
Energy Efficiency,"ns are VCC (=0), ECC (=1), MRCC (=2), and EXTERNAL (=3). The default for all calculations is currently VCC which requests usage of xvcc, but in many cases (e.g., for CCSD and CCSD(T)) ECC should be preferred due to the better performance of xecc (available currently for CCSD, CCSD+T, CCSD(T), and closed-shell CCSDT-n, CC3, and CCSDT). MRCC and External are intended for CC programs outside the CFOUR suite, e.g., the general CC module mrcc written by M. Kallay (Budapest, Hungary). Default: VCC Note: Using the option ECC is not recommended for ROHF gradients. That is, if you are doing a geometry optimization with ROHF as your reference wave function then it is safe to use the option VCC. Psi4 Interface: Keyword set according to best practice for the computational method CFOUR_CALC_LEVEL, reference CFOUR_REFERENCE (NYI) and derivative level CFOUR_DERIV_LEVEL according to Table Best Practices when method specified by argument to computation command (e.g., when energy('c4-ccsd') requested but not when energy('cfour') requested). Value can always be set explicitly. Type: string; Possible Values: VCC, ECC, NCC, MRCC, EXTERNAL; Default: VCC. CFOUR_CHARGE (CFOUR); CFOUR — Specifies the molecular charge. Psi4 Interface: Keyword set from active molecule. Type: integer; Default: 0. CFOUR_CIS_CONV (CFOUR); CFOUR — Specifies the convergence threshold as \(10^{-N}\) for CIS calculations. Type: integer; Default: 5. CFOUR_CONTINUUM (CFOUR); CFOUR — Signifies that one or more “continuum” orbitals should be added to the calculation. VIRTUAL and DVIRTUAL specify one or two orbital which should be initially unoccupied (in the SCF calculation), while OCCUPIED and DOCCUPIED specify one or two orbitals which should be initially occupied. Type: string; Possible Values: NONE, VIRTUAL, DVIRTUAL, OCCUPIED, DOCCUPIED; Default: NONE. CFOUR_CONTRACTION (CFOUR); CFOUR — Specifies the contraction scheme used by the integral and integral derivative program. SEGMENTED (=0) uses a segmented contraction ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html:27748,energy,energy,27748,psi4manual/1.2.1/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html,8,['energy'],['energy']
Energy Efficiency,"ns are VCC (=0), ECC (=1), MRCC (=2), and EXTERNAL (=3). The default for all calculations is currently VCC which requests usage of xvcc, but in many cases (e.g., for CCSD and CCSD(T)) ECC should be preferred due to the better performance of xecc (available currently for CCSD, CCSD+T, CCSD(T), and closed-shell CCSDT-n, CC3, and CCSDT). MRCC and External are intended for CC programs outside the CFOUR suite, e.g., the general CC module mrcc written by M. Kallay (Budapest, Hungary). Default: VCC Note: Using the option ECC is not recommended for ROHF gradients. That is, if you are doing a geometry optimization with ROHF as your reference wave function then it is safe to use the option VCC. Psi4 Interface: Keyword set according to best practice for the computational method CFOUR_CALC_LEVEL, reference CFOUR_REFERENCE (NYI) and derivative level CFOUR_DERIV_LEVEL according to Table Best Practices when method specified by argument to computation command (e.g., when energy('c4-ccsd') requested but not when energy('cfour') requested). Value can always be set explicitly. Type: string; Possible Values: VCC, ECC, NCC, MRCC, EXTERNAL; Default: VCC. CFOUR_CHARGE (CFOUR)¶CFOUR — Specifies the molecular charge. Psi4 Interface: Keyword set from active molecule. Type: integer; Default: 0. CFOUR_CIS_CONV (CFOUR)¶CFOUR — Specifies the convergence threshold as \(10^{-N}\) for CIS calculations. Type: integer; Default: 5. CFOUR_CONTINUUM (CFOUR)¶CFOUR — Signifies that one or more “continuum” orbitals should be added to the calculation. VIRTUAL and DVIRTUAL specify one or two orbital which should be initially unoccupied (in the SCF calculation), while OCCUPIED and DOCCUPIED specify one or two orbitals which should be initially occupied. Type: string; Possible Values: NONE, VIRTUAL, DVIRTUAL, OCCUPIED, DOCCUPIED; Default: NONE. CFOUR_CONTRACTION (CFOUR)¶CFOUR — Specifies the contraction scheme used by the integral and integral derivative program. SEGMENTED (=0) uses a segmented contraction sche",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html:28126,energy,energy,28126,psi4manual/1.4.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html,18,['energy'],['energy']
Energy Efficiency,"ns by using the default options and by specifiying the format. opt12; SCF cc-pVDZ geometry optimzation of ketene, starting from bent structure. dfmp2-4; conventional and density-fitting mp2 test of mp2 itself and setting scs-mp2. cisd-sp; 6-31G** H2O Test CISD Energy Point. sapt5; SAPT0 aug-cc-pVTZ computation of the charge transfer energy of the water dimer. dct4; DCT calculation for the HF+ using DC-06 functional. This performs both two-step and simultaneous update of the orbitals and cumulant using DIIS extrapolation. Four-virtual integrals are first handled in the MO Basis for the first two energy computations. In the next two the ao_basis=disk algorithm is used, where the transformation of integrals for four-virtual case is avoided. The computation is then repeated using the DC-12 functional with the same algorithms. props4; Electrostatic potential and electric field evaluated on a grid around water. sapt3; SAPT2+3(CCD) aug-cc-pVDZ+midbond computation of the water dimer interaction energy, using the aug-cc-pVDZ-JKFIT DF basis for SCF and aug-cc-pVDZ-RI for SAPT. mp2-1; All-electron MP2 6-31G** geometry optimization of water. sapt1; SAPT0 cc-pVDZ computation of the ethene-ethyne interaction energy, using the cc-pVDZ-JKFIT RI basis for SCF and cc-pVDZ-RI for SAPT. Monomer geometries are specified using Cartesian coordinates. tdscf-3; td-wb97x excitation energies of singlet states of h2o, wfn passing. dft2; DFT Functional Test. dfomp2-grad2; OMP2 cc-pVDZ energy for the NO molecule. aediis-1; ADIIS test case, from 10.1063/1.3304922. soscf-dft; Triple and Singlet Oxygen energy SOSCF, also tests non-symmetric density matrices. scf-bz2; Benzene Dimer Out-of-Core HF/cc-pVDZ. fsapt-ext-abc; FSAPT with external charge on trimer. cc28; CCSD/cc-pVDZ optical rotation calculation (length gauge only) on Z-mat H2O2. dft-reference; MP2 with a PBE0 reference computation. dft1; DFT Functional Test all values update for new BraggSlater radii. dfmp2-freq2; DF-MP2 frequency by differ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html:25666,energy,energy,25666,psi4manual/master/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"ns for local-CC calculations. See J. Broughton and P. Pulay, J. Comp. Chem. 14, 736-740 (1993) and C. Hampel and H.-J. Werner, J. Chem. Phys. 104, 6286-6297 (1996). Type: double; Default: 0.01. LOCAL_DO_SINGLES (CCEOM); CCEOM —. Type: boolean; Default: true. LOCAL_FILTER_SINGLES (CCEOM); CCEOM — Do apply local filtering to singles amplitudes?. Type: boolean; Default: true. LOCAL_FILTER_SINGLES (CCLAMBDA); CCLAMBDA — Do apply local filtering to single de-excitation (\(\lambda 1\) amplitudes?. Type: boolean; Default: true. LOCAL_FILTER_SINGLES (CCRESPONSE); CCRESPONSE — Do apply local filtering to single excitation amplitudes?. Type: boolean; Default: false. LOCAL_GHOST (CCEOM); CCEOM — Permit ghost atoms to hold projected atomic orbitals to include in the virtual space in local-EOM-CCSD calculations. Type: integer; Default: -1. LOCAL_IBO_CONDITION (FISAPT); FISAPT (Expert) — Condition number to use in IBO metric inversions. Type: double; Default: 1.0e-7. LOCAL_IBO_POWER (FISAPT); FISAPT — IBO localization metric power. Type: integer; Default: 4. LOCAL_IBO_STARS (FISAPT); FISAPT — IBO Centers for Pi Degeneracy. Type: array; Default: No Default. LOCAL_IBO_STARS_COMPLETENESS (FISAPT); FISAPT — IBO Charge metric for classification as Pi. Type: double; Default: 0.90. LOCAL_IBO_USE_STARS (FISAPT); FISAPT — IBO Stars procedure. Type: boolean; Default: false. LOCAL_MAXITER (FISAPT); FISAPT — Maximum iterations in localization. Type: integer; Default: 1000. LOCAL_MAXITER (SCF); SCF — The maxiter on the orbital localization procedure. Type: integer; Default: 200. LOCAL_METHOD (CCENERGY); CCENERGY — Type of local-CCSD scheme to be simulated. WERNER selects the method developed by H.-J. Werner and co-workers, and AOBASIS selects the method developed by G.E. Scuseria and co-workers (currently inoperative). Type: string; Possible Values: WERNER, AOBASIS; Default: WERNER. LOCAL_METHOD (CCEOM); CCEOM — Type of local-CCSD scheme to be simulated. WERNER selects the method developed by",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html:152660,power,power,152660,psi4manual/1.2.1/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html,6,['power'],['power']
Energy Efficiency,"ns for the block of two-electron integrals in the evaluation of second-order T2 amplitudes? Recommended true for all SAPT computations. Type: boolean; Default: false. OCC_TOLERANCE¶. Minimum occupation (eigenvalues of the MP2 OPDM) below which virtual natural orbitals are discarded for in each of the above three truncations. Type: conv double; Default: 1.0e-6. Advanced Keywords Controlling MP2 NO Approximations¶. Charge-Transfer in SAPT¶; It is possible to obtain the stabilization energy of a complex due to; charge-transfer effects from a SAPT computation. The charge-transfer energy; can be computed with the SAPT module as described by Stone; and Misquitta [Misquitta:2009:201].; Charge-transfer energies can be obtained from the following calls to the; energy function.; energy('sapt0-ct'); energy('sapt2-ct'); energy('sapt2+-ct'); energy('sapt2+(3)-ct'); energy('sapt2+3-ct'). A SAPT charge-transfer analysis will perform 5 HF computations: the dimer; in the dimer basis, monomer A in the dimer basis, monomer B in the dimer; basis, monomer A in the monomer A basis, and monomer B in the monomer B; basis. Next, it performs two SAPT computations, one in the dimer basis and; one in the monomer basis. Finally, it will print a summary of the; charge-transfer results:; SAPT Charge Transfer Analysis; -----------------------------------------------------------------------------; SAPT Induction (Dimer Basis) -2.0970 mH -1.3159 kcal mol^-1; SAPT Induction (Monomer Basis) -1.1396 mH -0.7151 kcal mol^-1; SAPT Charge Transfer -0.9574 mH -0.6008 kcal mol^-1. These results are for the water dimer geometry shown above computed with; SAPT0/aug-cc-pVDZ. Monomer-Centered Basis Computations¶; The charge-transfer analysis above is carried out by taking the; difference between SAPT induction as calculated in the dimer-centered; basis (i.e., each monomer sees the basis functions on both monomers); vs. the monomer-centered basis (i.e., each monomer utilizes only its; own basis set). It is also po",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/sapt-1.html:12402,charge,charge-transfer,12402,psi4manual/4.0b5/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/sapt-1.html,2,['charge'],['charge-transfer']
Energy Efficiency,"ns of the full databases, restricted by subset keyword, are computed by sapt0 and dfmp2 methods. cc52; CCSD Response for H2O2. pywrap-db2; Database calculation, run in sow/reap mode. cc50; EOM-CC3(ROHF) on CH radical with user-specified basis and properties for particular root. omp2-2; OMP2 cc-pVDZ energy with ROHF initial guess orbitals for the NO radical. cc12; Single point energies of multiple excited states with EOM-CCSD. cisd-sp; 6-31G** H2O Test CISD Energy Point. mints6; Patch of a glycine with a methyl group, to make alanine, then DF-SCF energy calculation with the cc-pVDZ basis set. mrcc4; CCSDT cc-pVDZ optimization and frequencies for the H2O molecule using MRCC. omp2-5; SOS-OMP2 cc-pVDZ geometry optimization for the H2O molecule. props1; RHF STO-3G dipole moment computation, performed by applying a finite electric field and numerical differentiation. cc42; RHF-CC2-LR/STO-3G optical rotation of (S)-methyloxirane. gauge = length, omega = (589 355 nm). omp2_5-1; OMP2 cc-pVDZ energy for the H2O molecule. fci-dipole; 6-31G H2O Test FCI Energy Point. fnocc3; Test FNO-QCISD(T) computation. tu4-h2o-freq; Frequencies for H2O HF/cc-pVDZ at optimized geometry. dcft3; DC-06 calculation for the He dimer. This performs a simultaneous update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the AO Basis, using integrals stored on disk. cc4a; RHF-CCSD(T) cc-pVQZ frozen-core energy of the BH molecule, with Cartesian input. This version tests the FROZEN_DOCC option explicitly. cisd-h2o+-1; 6-31G** H2O+ Test CISD Energy Point. dft-psivar; HF and DFT variants single-points on zmat methane, mostly to test that PSI variables are set and computed correctly. pywrap-alias; Test parsed and exotic calls to energy() like zapt4, mp2.5, and cisd are working. cc8b; ROHF-CCSD cc-pVDZ frozen-core energy for the state of the CN radical, with Cartesian input. mints3; Test individual integral objects for correctness. omp3-2; OMP3 cc-pVDZ energy wi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodoc_testsuite-1.html:13299,energy,energy,13299,psi4manual/4.0b4/autodoc_testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodoc_testsuite-1.html,4,['energy'],['energy']
Energy Efficiency,"ns of the full databases, restricted by subset keyword, are computed by sapt0 and dfmp2 methods. cc52; CCSD Response for H2O2. pywrap-db2; Database calculation, run in sow/reap mode. cc50; EOM-CC3(ROHF) on CH radical with user-specified basis and properties for particular root. omp2-2; OMP2 cc-pVDZ energy with ROHF initial guess orbitals for the NO radical. cc12; Single point energies of multiple excited states with EOM-CCSD. cisd-sp; 6-31G** H2O Test CISD Energy Point. mints6; Patch of a glycine with a methyl group, to make alanine, then DF-SCF energy calculation with the cc-pVDZ basis set. mrcc4; CCSDT cc-pVDZ optimization and frequencies for the H2O molecule using MRCC. omp2-5; SOS-OMP2 cc-pVDZ geometry optimization for the H2O molecule. props1; RHF STO-3G dipole moment computation, performed by applying a finite electric field and numerical differentiation. cc42; RHF-CC2-LR/STO-3G optical rotation of (S)-methyloxirane. gauge = length, omega = (589 355 nm). omp2_5-1; OMP2 cc-pVDZ energy for the H2O molecule. fci-dipole; 6-31G H2O Test FCI Energy Point. pywrap-freq-e-sowreap; Finite difference of energies frequency, run in sow/reap mode. fnocc3; Test FNO-QCISD(T) computation. tu4-h2o-freq; Frequencies for H2O HF/cc-pVDZ at optimized geometry. dcft3; DC-06 calculation for the He dimer. This performs a simultaneous update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the AO Basis, using integrals stored on disk. cc4a; RHF-CCSD(T) cc-pVQZ frozen-core energy of the BH molecule, with Cartesian input. This version tests the FROZEN_DOCC option explicitly. cisd-h2o+-1; 6-31G** H2O+ Test CISD Energy Point. dft-psivar; HF and DFT variants single-points on zmat methane, mostly to test that PSI variables are set and computed correctly. pywrap-alias; Test parsed and exotic calls to energy() like zapt4, mp2.5, and cisd are working. cc8b; ROHF-CCSD cc-pVDZ frozen-core energy for the state of the CN radical, with Cartesian input. mi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodoc_testsuite-1.html:13297,energy,energy,13297,psi4manual/4.0b5/autodoc_testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodoc_testsuite-1.html,4,['energy'],['energy']
Energy Efficiency,"ns the One-electron Overlap Matrix. X(). alpha_orbital_space(self, id, basis, subset); Creates OrbitalSpace with information about the requested alpha orbital space. aotoso(self); Returns the Atomic Orbital to Symmetry Orbital transformer. array_variable(self, arg0); Returns copy of the requested (case-insensitive) Matrix QC variable. array_variables(self); Returns the dictionary of all Matrix QC variables. arrays(). Deprecated since version 1.4. atomic_point_charges(self); Returns the set atomic point charges. basis_projection(self, arg0, arg1, arg2, arg3); Projects a orbital matrix from one basis to another. basisset(self); Returns the current orbital basis. beta_orbital_space(self, arg0, arg1, arg2); docstring. build(mol[, basis]). c1_deep_copy(self, basis); Returns a new wavefunction with internal data converted to \(C_1\) symmetry, using pre-c1-constructed basis. ci_nat_orbs(self); docstring. cleanup_ci(self); docstring. cleanup_dpd(self); docstring. compute_energy(self); Computes the energy of the Wavefunction. compute_gradient(self); Computes the gradient of the Wavefunction. compute_hessian(self); Computes the Hessian of the Wavefunction. compute_state_transfer(self, arg0, arg1, ...); docstring. deep_copy(self, arg0); Deep copies the internal data. del_array_variable(self, arg0); Removes the requested (case-insensitive) Matrix QC variable. del_potential_variable(self, arg0); Removes the requested (case-insensitive) ExternalPotential QC variable. del_scalar_variable(self, arg0); Removes the requested (case-insensitive) double QC variable. del_variable(key); Removes scalar or array QCVariable key from cls if present. density_fitted(self); Returns whether this wavefunction was obtained using density fitting or not. diag_h(self, arg0, arg1); docstring. doccpi(self); Returns the number of doubly occupied orbitals per irrep. efzc(self); Returns the frozen-core energy. energy(self); Returns the Wavefunction's energy. epsilon_a(self); Returns the Alpha Eigenvalues. e",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.core.ciwavefunction.html:2138,energy,energy,2138,psi4manual/1.5.0/api/psi4.core.ciwavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.core.ciwavefunction.html,2,['energy'],['energy']
Energy Efficiency,"ns the One-electron Overlap Matrix. X(). alpha_orbital_space(self, id, basis, subset); Creates OrbitalSpace with information about the requested alpha orbital space. aotoso(self); Returns the Atomic Orbital to Symmetry Orbital transformer. array_variable(self, arg0); Returns copy of the requested (case-insensitive) Matrix QC variable. array_variables(self); Returns the dictionary of all Matrix QC variables. arrays(). Deprecated since version 1.4. atomic_point_charges(self); Returns the set atomic point charges. basis_projection(self, arg0, arg1, arg2, arg3); Projects a orbital matrix from one basis to another. basisset(self); Returns the current orbital basis. beta_orbital_space(self, arg0, arg1, arg2); docstring. build(mol[, basis]). c1_deep_copy(self, basis); Returns a new wavefunction with internal data converted to \(C_1\) symmetry, using pre-c1-constructed basis. ci_nat_orbs(self); docstring. cleanup_ci(self); docstring. cleanup_dpd(self); docstring. compute_energy(self); Computes the energy of the Wavefunction. compute_gradient(self); Computes the gradient of the Wavefunction. compute_hessian(self); Computes the Hessian of the Wavefunction. compute_state_transfer(self, arg0, arg1, …); docstring. deep_copy(self, arg0); Deep copies the internal data. del_array_variable(self, arg0); Removes the requested (case-insensitive) Matrix QC variable. del_potential_variable(self, arg0); Removes the requested (case-insensitive) ExternalPotential QC variable. del_scalar_variable(self, arg0); Removes the requested (case-insensitive) double QC variable. del_variable(key); Removes scalar or array QCVariable key from cls if present. density_fitted(self); Returns whether this wavefunction was obtained using density fitting or not. diag_h(self, arg0, arg1); docstring. doccpi(self); Returns the number of doubly occupied orbitals per irrep. efzc(self); Returns the frozen-core energy. energy(self); Returns the Wavefunction’s energy. epsilon_a(self); Returns the Alpha Eigenvalues. eps",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ciwavefunction.html:2138,energy,energy,2138,psi4manual/1.4.0/api/psi4.core.ciwavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ciwavefunction.html,1,['energy'],['energy']
Energy Efficiency,"ns the SCF energy computed by finalize_energy(). compute_initial_E(self: psi4.core.HF) → float¶; docstring. compute_orbital_gradient(self: psi4.core.HF, arg0: bool, arg1: int) → float¶; docstring. compute_spin_contamination(self: psi4.core.HF) → None¶; docstring. cphf_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix]) → List[psi4.core.Matrix]¶; CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self: psi4.core.HF) → bool¶; Adds occupied guess alpha orbitals. cphf_solve(self: psi4.core.HF, x_vec: List[psi4.core.Matrix], conv_tol: float, max_iter: int, print_lvl: int=2) → List[psi4.core.Matrix]¶; Solves the CPHF equations for a given set of x vectors. damping_update(self: psi4.core.HF, arg0: float) → None¶; docstring. diis(self: psi4.core.HF) → bool¶; docstring. diis_manager(self: psi4.core.HF) → psi4.core.DIISManager¶; docstring. finalize(self: psi4.core.HF) → None¶; Cleans up the the Wavefunction’s temporary data. finalize_energy()¶; Performs stability analysis and calls back SCF with new guess; if needed, Returns the SCF energy. This function should be called; once orbitals are ready for energy/property computations, usually; after iterations() is called. find_occupation(self: psi4.core.HF) → None¶; docstring. form_C(self: psi4.core.HF) → None¶; Forms the Orbital Matrices from the current Fock Matrices. form_D(self: psi4.core.HF) → None¶; Forms the Density Matrices from the current Orbitals Matrices. form_F(self: psi4.core.HF) → None¶; Forms the F matrix. form_G(self: psi4.core.HF) → None¶; Forms the G matrix. form_H(self: psi4.core.HF) → None¶; Forms the core Hamiltonian. form_Shalf(self: psi4.core.HF) → None¶; Forms the S^1/2 matrix. form_V(self: psi4.core.HF) → None¶; Form the Kohn-Sham Potential Matrices from the current Density Matrices. form_initial_C(self: psi4.core.HF) → None¶; Forms the initial Orbital Matrices from the current Fock Matrices. form_initial_F(self: psi4.core.HF) → None¶; Forms the initial F matrix. frac_renormalize(self: psi4.c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.hf.html:6179,energy,energy,6179,psi4manual/1.3.2/api/psi4.core.hf.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.hf.html,1,['energy'],['energy']
Energy Efficiency,"ns the code to generate the similarity transformed Hamiltonian.; ; C++ signature :; void cchbar(N5boost10shared_ptrIN3psi12WavefunctionEEE); ; cclambda(...); cclambda( (Wavefunction)arg1) -> Wavefunction :; Runs the coupled cluster lambda equations code.; ; C++ signature :; N5boost10shared_ptrIN3psi12WavefunctionEEE cclambda(N5boost10shared_ptrIN3psi12WavefunctionEEE); ; ccresponse(...); ccresponse( (Wavefunction)arg1) -> float :; Runs the coupled cluster response theory code.; ; C++ signature :; d ccresponse(N5boost10shared_ptrIN3psi12WavefunctionEEE); ; ccsort(...); ccsort() -> float :; Runs CCSORT, which reorders integrals for use in the coupled cluster codes.; ; C++ signature :; d ccsort(); ; cctransort(...); cctransort( (Wavefunction)arg1) -> None :; Runs CCTRANSORT, which transforms and reorders integrals for use in the coupled cluster codes.; ; C++ signature :; void cctransort(N5boost10shared_ptrIN3psi12WavefunctionEEE); ; cctriples(...); cctriples( (Wavefunction)arg1) -> float :; Runs the coupled cluster (T) energy code.; ; C++ signature :; d cctriples(N5boost10shared_ptrIN3psi12WavefunctionEEE); ; clean(...); clean() -> None :; Function to remove scratch files. Call between independent jobs.; ; C++ signature :; void clean(); ; clean_variables(...); clean_variables() -> None :; Empties all PSI variables that have set internally.; ; C++ signature :; void clean_variables(); ; close_outfile(...); close_outfile() -> None :; Closes the output file.; ; C++ signature :; void close_outfile(); ; compute_shell(...); compute_shell( (TwoBodyAOInt)arg1, (int)arg2, (int)arg3, (int)arg4, (int)arg5) -> int :; docstring; ; C++ signature :; m compute_shell(N3psi12TwoBodyAOIntE {lvalue},i,i,i,i); ; dcft(...); dcft( (Wavefunction)arg1) -> Wavefunction :; Runs the density cumulant functional theory code.; ; C++ signature :; N5boost10shared_ptrIN3psi12WavefunctionEEE dcft(N5boost10shared_ptrIN3psi12WavefunctionEEE); ; detci(...); detci( (Wavefunction)arg1) -> Wavefunction :; Runs ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:677475,energy,energy,677475,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['energy'],['energy']
Energy Efficiency,"ns will be highlighted; in section Interface to adcc and Built-in ADC(2) code. ADC capabilities of Psi4¶. Method; Backend; References; Exc. Energies; Props; Supported values for kind keyword. ADC(1); adcc; RHF, UHF; yes; yes; any, singlet, triplet, spin_flip. ADC(2); adcc; RHF, UHF; yes; yes; any, singlet, triplet, spin_flip. built-in; RHF; yes; —; singlet. ADC(2)-x; adcc; RHF, UHF; yes; yes; any, singlet, triplet, spin_flip. ADC(3); adcc; RHF, UHF; yes; yes | any, singlet, triplet, spin_flip. CVS-ADC(1); adcc; RHF, UHF; yes; yes | any, singlet, triplet. CVS-ADC(2); adcc; RHF, UHF; yes; yes; any, singlet, triplet. CVS-ADC(2)-x; adcc; RHF, UHF; yes; yes; any, singlet, triplet. CVS-ADC(3); adcc; RHF, UHF; yes; yes; any, singlet, triplet. The leftmost column of table ADC capabilities of Psi4 provides the supported ADC methods.; If only excitation energies are desired, one can simply pass one; of the listed method strings to the function energy().; For example, energy('adc(2)-x') will compute; excitation energies at ADC(2)-x level.; Properties such as oscillator strengths, transition or state dipole moments; are available by calling the function properties(); with appropriate arguments.; Most commonly users will want to compute at least oscillator strengths; along with the excitation energies,; resulting in a call like properties('adc(2)', properties=[""oscillator_strength""]). Running ADC calculations¶; Section author: Michael F. Herbst; Running an ADC calculation with PSI4 requires; the call to properties() as discussed above; as well as one or more mandatory keyword arguments.; The most important keyword argument is ROOTS_PER_IRREP,; which is an array with the number of excited states desired; for each irreducible representation. Most ADC methods; are only supported at C1 symmetry at the moment, such that; this option should in most cases be set to an array with a single; element only. For example one can run an ADC(2) calculation for 10; (singlet) excited states using",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/adc-1.html:4649,energy,energy,4649,psi4manual/1.4.0/adc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/adc-1.html,5,['energy'],['energy']
Energy Efficiency,"ns with midbonds can be accomplished by adding a third ghost; monomer to the computation. For example; molecule dimer {; 0 1; He 0 0 5; --; 0 1; He 0 0 -5; --; 0 1; @He 0 0 0; }. Here the functions of the third monomer will be added to the virtual space of; the entire computation. Note that an error will be thrown if each atom in the; third monomer is not a ghost to prevent confusion with three-body SAPT which is; not currently supported by Psi4. Interpreting SAPT Results¶; We will examine the results of a SAPT2+3/aug-cc-pVDZ computation on the; water dimer. This computation can be performed with the following; input:; molecule water_dimer {; 0 1; O -1.551007 -0.114520 0.000000; H -1.934259 0.762503 0.000000; H -0.599677 0.040712 0.000000; --; 0 1; O 1.350625 0.111469 0.000000; H 1.680398 -0.373741 -0.758561; H 1.680398 -0.373741 0.758561; units angstrom; }. set globals {; basis aug-cc-pvdz; guess sad; scf_type df; }. set sapt {; print 1; nat_orbs_t2 true; freeze_core true; }. energy('sapt2+3'). To reiterate some of the options mentioned above: the; NAT_ORBS_T2 option will compute MP2 natural orbitals and use; them in the evaluation of the triples correction to dispersion, and the; FREEZE_CORE option will freeze the core throughout the SAPT; computation. This SAPT2+3/aug-cc-pVDZ computation produces the following; results:; SAPT Results; --------------------------------------------------------------------------------------------------------; Electrostatics -13.06509118 [mEh] -8.19846883 [kcal/mol] -34.30239689 [kJ/mol]; Elst10,r -13.37542977 [mEh] -8.39320925 [kcal/mol] -35.11719087 [kJ/mol]; Elst12,r 0.04490350 [mEh] 0.02817737 [kcal/mol] 0.11789413 [kJ/mol]; Elst13,r 0.26543510 [mEh] 0.16656305 [kcal/mol] 0.69689985 [kJ/mol]. Exchange 13.41768202 [mEh] 8.41972294 [kcal/mol] 35.22812415 [kJ/mol]; Exch10 11.21822294 [mEh] 7.03954147 [kcal/mol] 29.45344432 [kJ/mol]; Exch10(S^2) 11.13802706 [mEh] 6.98921779 [kcal/mol] 29.24289005 [kJ/mol]; Exch11(S^2) 0.04558907 [mEh] ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/sapt-1.html:33665,energy,energy,33665,psi4manual/1.4.0/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/sapt-1.html,9,['energy'],['energy']
Energy Efficiency,"ns with the lowest total energy. For an oscillating system where the; lowest total energy occurs on iterations , invoking; MOM_START can often rescue the convergence of the SCF. MOM can; be used in concert with DIIS, though care should be taken to not turn MOM on; until the oscillatory behavior begins.; Damping [Off by Default]; In some cases, a static mixing of Fock Matrices from adjacent iterations can; quench oscillations. This mixing, known as “damping” can be activated by setting; the DAMPING_PERCENTAGE keyword to a nonzero percent. ERI Algorithms¶; The key difficulty in the SCF procedure is treatment of the four-index ERI; contributions to the Fock Matrix. A number of algorithms are available in; PSI4 for these terms. The algorithm is selected by the SCF_TYPE; keyword, which may be one of the following. PK [Default]; An in-core, presorted algorithm using exact ERIs. Quite fast; for a zero-error algorithm if enough memory is available. Integrals are; generated only once, and symmetry is utilized to reduce number of integrals.; OUT_OF_CORE; An out-of-core, unsorted algorithm using exact; ERIs. Overcomes the memory bottleneck of the current PK algorithm. Integrals are; generated only once, and symmetry is utilized to reduce number of integrals.; DIRECT; An in-core repeated integral evaluation algorithm using; exact ERIs. Symmetry is used to reduce the number of integrals, and no disk is; used. However, integral regeneration is quite costly, implying that this; algorithm should be used only if there is not enough disk space for the; OUT_OF_CORE algorithm.; DF; A density-fitted algorithm designed for computations with thousands of basis; functions. This algorithm is highly optimized, and is threaded with a mixture of; parallel BLAS and OpenMP. Note that this algorithm should use the -JKFIT series; of auxiliary bases, not the -RI or -MP2FIT bases. The default guess for; auxiliary basis set should work for all Dunning bases, otherwise the; DF_BASIS_SCF keyword can be",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/scf-1.html:17241,reduce,reduce,17241,psi4manual/4.0b2/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf-1.html,4,['reduce'],['reduce']
Energy Efficiency,"ns without a -D. The “best-practice” input file for KS-DFT is:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14memory 1 GB # As much as you've got, the DF algorithm can use. molecule {; H; H 1 0.7; }. set {; basis cc-pvdz; scf_type df; guess sad; }. energy('b3lyp'). Advanced Functional Use and Manipulation¶; New DFT functionals can be created from scratch from within the input; file and accessed using the dft_functional keyword argument in the; energy call:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28# DFT Custom Functional. molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; basis sto-3g; dft_spherical_points 302; dft_radial_points 99; reference rks; }. pbe0 = {; ""name"": ""my_PBE0"",; ""x_functionals"": {""GGA_X_PBE"": {""alpha"": 0.75}},; ""x_hf"": {""alpha"": 0.25},; ""c_functionals"": {""GGA_C_PBE"": {}}; }. func_call = energy('SCF', dft_functional=pbe0). # as PBE0 is a pre-defined functional, the call above is equivalent to both below:; func_call = energy('SCF', dft_functional=""PBE0""); func_call = energy('PBE0'). Supported keywords include:. name: string, name of the functional. for custom defined functionals used for printing only.; xc_functionals: dict, definition of a complete (X + C) functional based in LibXC name; x_functionals: dict, definition of exchange functionals using LibXC names; c_functionals: dict, definition of correlation functionals using LibXC names; x_hf: dict, parameters dealing with exact (HF) exchange settings for hybrid DFT; c_mp2: dict, parameters dealing with MP2 correlation for double hybrid DFT; dispersion: dict, definition of dispersion corrections; citation: string, citation for the method, for printing purposes; description: string, description of the method, for printing purposes. The full interface is defined in; psi4/psi4/driver/procrouting/dft/dft_builder.py. All; standard functionals provided in PSI4 are implemented in the; *_functionals.py files in the same folder.; Superfuncti",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/dft-1.html:27907,energy,energy,27907,psi4manual/1.3.2/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/dft-1.html,4,['energy'],['energy']
Energy Efficiency,"ns,; the dftd3/PSI4 interface enables computations of three-body dispersion; corrections. In DFT-D3, three-body dispersion is approximated with the; Axilrod-Teller-Muto model:. \[E_{disp}^{(3)}=-\frac{1}{6}\sum_{A\neq B\neq C}\frac{C_{9}^{ABC}(3\cos{\theta_a}\cos{\theta_b}\cos{\theta_c}+1)}{(r_{AB}r_{BC}r_{AC})^{3}}f_{damp}(\bar{r}_{ABC})\]; where \(\theta_a\) is the angle at atom A corresponding to the triangle formed by atoms A, B, and C,; and \(\bar{r}_{ABC}\) is the geometric mean of the corresponding atomic-pair distances.; The dispersion coefficients are defined as. \[C_{9}^{ABC} = \sqrt{C_{6}^{AB}C_{6}^{BC}C_{6}^{AC}}\]; See the DFT-D3 documentation; for more details.; For now, the three-body correction can be called by using the run_dftd3(); function with d3-atmgr as the passed functional string.; For example, the three-body ATM dispersion correction for a neon trimer could; be computed with:; molecule ne3 {; Ne 0.0 0.0 0.0; Ne 0.0 0.0 1.0; Ne 0.0 1.0 1.0; }; ne.update_geometry(); energy = m.run_dftd3('d3-atmgr', dertype=0); print(energy). Since v1.7, it is preferred to use s-dftd3 for ATM since the 3-body can be run concurrent; with the 2-body contribution.; Footnotes. [1]; Note that there are functionals with these extensions (e.g., wB97X-D) that,; not being Grimme corrections, won’t follow this table exactly. [2]; [Grimme:2004:1463]. [3]; [Grimme:2006:1787]. [4]; (1,2); [Grimme:2010:154104]. [5]; (1,2); [Grimme:2011:1456]. [6]; (1,2,3,4); [Smith:2016:2197]. [7]; [Hujo:2011:3866]. [8]; [Chai:2010:6615]. [9]; [Pernal:2009:263201]. [10]; [Podeszwa:2010:550]. [11]; Keyword not used for user-defined functionals where the dft_dict[""dispersion""][""params""]; is easily editable for this purpose. See Advanced Functional Use and Manipulation. [12]; [Caldeweyher:2019:154122]. A few practical examples:. DFT-D2 single point with default parameters (dftd3 not called); energy('bp86-d'). DFT-D3BJ optimization with default parameters; optimize('pbe-d3bj'). DFT-D2 optimizati",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/dftd3.html:11048,energy,energy,11048,psi4manual/1.9.x/dftd3.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/dftd3.html,2,['energy'],['energy']
Energy Efficiency,"ns. Type: integer; Default: 50. MAX_CCD_DIISVECS¶. Maximum number of vectors used in CCD-DIIS. Type: integer; Default: 10. MIN_CCD_DIISVECS¶. Minimumnumber of vectors used in CCD-DIIS. Type: integer; Default: 4. NAT_ORBS_T2¶. Do use MP2 natural orbital approximations for the block of two-electron integrals in the evaluation of second-order T2 amplitudes? Recommended true for all SAPT computations. Type: boolean; Default: true. NAT_ORBS_T3¶. Do natural orbitals to speed up evaluation of the triples contribution to dispersion by truncating the virtual orbital space? Recommended true for all SAPT computations. Type: boolean; Default: true. NAT_ORBS_V4¶. Do use MP2 natural orbital approximations for the block of two-electron integrals in the evaluation of CCD T2 amplitudes? Recommended true for all SAPT computations. Type: boolean; Default: true. NO_RESPONSE¶. Don’t solve the CPHF equations? Evaluate and instead of their response-including coupterparts. Only turn on this option if the induction energy is not going to be used. Type: boolean; Default: false. OCC_TOLERANCE¶. Minimum occupation (eigenvalues of the MP2 OPDM) below which virtual natural orbitals are discarded for in each of the above three truncations. Type: conv double; Default: 1.0e-6. PRINT¶. The amount of information to print to the output file for the sapt module. For 0, only the header and final results are printed. For 1, (recommended for large calculations) some intermediate quantities are also printed. Type: integer; Default: 1. SAPT_LEVEL¶. The level of theory for SAPT. Type: string; Possible Values: SAPT0, SAPT2, SAPT2+, SAPT2+3; Default: SAPT0. SAPT_MEM_CHECK¶. Do force SAPT2 and higher to die if it thinks there isn’t enough memory? Turning this off is ill-advised. Type: boolean; Default: true. SAPT_MEM_SAFETY¶. Memory safety. Type: double; Default: 0.9. Expert¶. DO_CCD_DISP¶. Do CCD dispersion correction in SAPT2+, SAPT2+(3) or SAPT2+3?. Type: boolean; Default: false. DO_MBPT_DISP¶. Do MBPT dispe",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__sapt-1.html:3884,energy,energy,3884,psi4manual/1.0.0/autodir_options_c/module__sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__sapt-1.html,2,['energy'],['energy']
Energy Efficiency,"ns. opt3; SCF cc-pVDZ geometry optimzation, with Z-matrix input. props3; DF-SCF cc-pVDZ multipole moments of benzene, up to 7th order and electrostatic potentials evaluated at the nuclear coordinates. stability3; Test LDA stability analysis against QChem. dct1; DC-06, DC-12, ODC-06 and ODC-12 calculation for the He dimer. This performs a simultaneous update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the MO Basis. opt-freeze-coords; SCF/cc-pVDZ optimization example with frozen cartesian. scf-level-shift-rks; SCF level shift on an RKS computation. cc1; RHF-CCSD 6-31G** all-electron optimization of the H2O molecule. cc36; CC2(RHF)/cc-pVDZ energy of H2O. tu6-cp-ne2; Example potential energy surface scan and CP-correction for Ne2. fnocc3; Test FNO-QCISD(T) computation. frac-sym; Fractional occupation with symmetry. tdscf-7; TD-HF test variable access. cisd-h2o+-1; 6-31G** H2O+ Test CISD Energy Point. nbody-multi-level; Multilevel computation of water trimer energy (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). dft-grad-lr2; Tests CAM gradients with and without XC pieces to narrow grid error. dfcasscf-sa-sp; Example of state-averaged CASSCF for the C2 molecule. dft1-alt; DFT Functional Test. cc16; ROHF and UHF-B-CCD(T)/cc-pVDZ \(^{3}B_1\) CH2 single-point energy (fzc, MO-basis \(\langle ab|cd \rangle\) ). scf-upcast-custom-basis; test scf castup with custom basis sets. mints4; A demonstration of mixed Cartesian/ZMatrix geometry specification, using variables, for the benzene-hydronium complex. Atoms can be placed using ZMatrix coordinates, whether they belong to the same fragment or not. Note that the Cartesian specification must come before the ZMatrix entries because the former define absolute positions, while the latter are relative. dfmp2-3; DF-MP2 cc-pVDZ frozen core gradient of benzene, computed at the DF-SCF cc-pVDZ geometry. dfomp2p5-1; DF-OMP2.5 cc-pVDZ energy for the H2O molecule. cc31; CCSD/sto-3g",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html:22253,energy,energy,22253,psi4manual/master/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"ns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :type name: string; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``freq_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: |dl| ``'hessian'`` |dr| || ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available- they're not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. :type irrep: int or string; :param irrep: |dl| ``-1`` |dr| || ``1`` || ``'b2'`` || ``'App'`` || etc. Indicates which symmetry block (:ref:`Cotton <table:irrepOrdering>` ordering) of vibrational; frequencies to be computed. ``1``, ``'1'``, or ``'a1'`` represents; :math:`a_1`, requesting only the totally symmetric modes.; ``-1`` indicates a full frequency calculation. .. note:: Analytic hessians are only available for RHF. For all other methods, Frequencies will; proceed through finite differences according to availabilit",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html:70164,energy,energy,70164,psi4manual/1.3.2/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html,1,['energy'],['energy']
Energy Efficiency,"ns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :type name: string; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``freq_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. For a finite difference of energies or gradients frequency, indicates; whether the calculations required to complete the frequency are to be run; in one file (``'continuous'``) or are to be farmed out in an; embarrassingly parallel fashion (``'sow'``/``'reap'``)/ For the latter,; run an initial job with ``'sow'`` and follow instructions in its output file.; For maximum flexibility, ``return_wfn`` is always on in ``'reap'`` mode. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: |dl| ``'hessian'`` |dr| || ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available- they're not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. :typ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html:81821,energy,energy,81821,psi4manual/1.1.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html,2,['energy'],['energy']
Energy Efficiency,"ns; >>> energy(""MP2/cc-pV[DT]Z""). """"""; kwargs = p4util.kwargs_lower(kwargs). # Bounce if name is function; if hasattr(name, '__call__'):; return name(energy, kwargs.pop('label', 'custom function'), ptype='energy', **kwargs). # Allow specification of methods to arbitrary order; lowername = name.lower(); lowername, level = driver_util.parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. # Bounce to CP if bsse kwarg; if kwargs.get('bsse_type', None) is not None:; return driver_nbody._nbody_gufunc(energy, name, ptype='energy', **kwargs). # Bounce to CBS if ""method/basis"" name; if ""/"" in lowername:; return driver_cbs._cbs_gufunc(energy, name, ptype='energy', **kwargs). # Commit to procedures['energy'] call hereafter; return_wfn = kwargs.pop('return_wfn', False); psi4.clean_variables(). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', psi4.get_active_molecule()); molecule.update_geometry(). for precallback in hooks['energy']['pre']:; precallback(lowername, **kwargs). optstash = driver_util._set_convergence_criterion('energy', lowername, 6, 8, 6, 8, 6). # Before invoking the procedure, we rename any file that should be read.; # This is a workaround to do restarts with the current PSI4 capabilities; # before actual, clean restarts are put in there; # Restartfile is always converted to a single-element list if; # it contains a single string; if 'restart_file' in kwargs:; restartfile = kwargs['restart_file'] # Option still available for procedure-specific action; if restartfile != list(restartfile):; restartfile = [restartfile]; # Rename the files to be read to be consistent with psi4's file system; for item in restartfile:; name_split = re.split(r'\.', item); filenum = name_split[len(name_split) - 1]; try:; filenum = int(filenum); except ValueError:; filenum = 32 # Default file number is the checkpoint one; psioh = psi4.IOManager.shared_object(); psio = psi4.IO.shared_object(); filepath = psioh.get_file_path(fil",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver.html:29470,energy,energy,29470,psi4manual/1.0.0/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver.html,1,['energy'],['energy']
Energy Efficiency,nship [Hz] uncertainty=(exact). inverse_meter_joule_relationship; 1.986445824E-25; inverse meter-joule relationship [J] uncertainty=0.000 000 024 e-25. inverse_meter_kelvin_relationship; 0.0143877736; inverse meter-kelvin relationship [K] uncertainty=0.000 000 83 e-2. inverse_meter_kilogram_relationship; 2.210219057E-42; inverse meter-kilogram relationship [kg] uncertainty=0.000 000 027 e-42. inverse_of_conductance_quantum; 12906.4037278; inverse of conductance quantum [ohm] uncertainty=0.000 0029. Josephson_constant; 4.835978525E+14; Josephson constant [Hz V^{-1}] uncertainty=0.0030 e9. joule_atomic_mass_unit_relationship; 6700535363; joule-atomic mass unit relationship [u] uncertainty=0.000 000 082 e9. joule_electron_volt_relationship; 6.241509126E+18; joule-electron volt relationship [eV] uncertainty=0.000 000 038 e18. joule_hartree_relationship; 2.293712317E+17; joule-hartree relationship [E_h] uncertainty=0.000 000 028 e17. joule_hertz_relationship; 1.509190205E+33; joule-hertz relationship [Hz] uncertainty=0.000 000 019 e33. joule_inverse_meter_relationship; 5.034116651E+24; joule-inverse meter relationship [m^{-1}] uncertainty=0.000 000 062 e24. joule_kelvin_relationship; 7.2429731E+22; joule-kelvin relationship [K] uncertainty=0.000 0042 e22. joule_kilogram_relationship; 1.112650056E-17; joule-kilogram relationship [kg] uncertainty=(exact). kelvin_atomic_mass_unit_relationship; 9.2510842E-14; kelvin-atomic mass unit relationship [u] uncertainty=0.000 0053 e-14. kelvin_electron_volt_relationship; 0.000086173303; kelvin-electron volt relationship [eV] uncertainty=0.000 0050 e-5. kelvin_hartree_relationship; 0.0000031668105; kelvin-hartree relationship [E_h] uncertainty=0.000 0018 e-6. kelvin_hertz_relationship; 2.0836612E+10; kelvin-hertz relationship [Hz] uncertainty=0.000 0012 e10. kelvin_inverse_meter_relationship; 69.503457; kelvin-inverse meter relationship [m^{-1}] uncertainty=0.000 040. kelvin_joule_relationship; 1.38064852E-23; kelvin-joule relationship,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodoc_physconst-1.html:18222,joule,joule-hertz,18222,psi4manual/1.3.2/autodoc_physconst-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodoc_physconst-1.html,11,['joule'],['joule-hertz']
Energy Efficiency,"nsider what we would do for an open-shell molecule, where not all the electrons are paired. For example, let’s run a computation on methylene (\(\text{CH}_2\)), whose ground electronic state has two unpaired electrons (triplet electronic state, or a spin multiplicity \(2S + 1 = 3\)). In this case, the default spin multiplicity (1) is not correct, so we need to tell the program the true value (3). Like many programs, Psi4 can get the charge and multiplicity as the first two; integers in the Z-matrix (note the line with 0 3 at the beginning of the molecule specification below). In this example, we will also specify the bond length and bond angle as variables (\(R\) and \(A\)), whose values are first stored and then inserted into the geometry specification using Python 3 string formatting. [4]:. #! Sample UHF/6-31G** CH2 Computation. R = 1.075; A = 133.93. ch2 = psi4.geometry(""""""; 0 3; C; H 1 {0}; H 1 {0} 2 {1}; """""".format(R, A); ). psi4.set_options({'reference': 'uhf'}); psi4.energy('scf/6-31g**'). [4]:. -38.925334628859886. Executing this cell should yield the final energy as; @DF-UHF Final Energy: -38.92533462887677. Notice the new command, psi4.set_options() API, to the input. This function takes a Python dictionary as its argument, which is a key-value list which associates a Psi4 keyword with its user-defined value. For open shell molecules, we have a choice of unrestricted orbitals; (unrestricted Hartree-Fock, or UHF) or restricted orbitals (restricted open-shell Hartree-Fock, or ROHF). Usually, UHF is a little easier to converge (although it may be more susceptible to spin contamination than ROHF). III. Geometry Optimization and Vibrational Frequency Analysis¶; The above examples were simple single-point energy computations (as specified by the psi4.energy() API function). Of course there are other kinds of computations to perform, such as geometry optimizations and vibrational frequency computations. These can be specified by replacing psi4.energy() API with; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psiapi-1.html:5741,energy,energy,5741,psi4manual/1.3.2/psiapi-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psiapi-1.html,11,['energy'],['energy']
Energy Efficiency,"nsions (e.g., wB97X-D) that,; not being Grimme corrections, won’t follow this table exactly. 2; [Grimme:2004:1463]. 3; [Grimme:2006:1787]. 4; [Grimme:2010:154104]. 5; [Grimme:2011:1456]. 6(1,2); [Smith:2016:2197]. 7; [Hujo:2011:3866]. 8; [Chai:2010:6615]. 9; [Pernal:2009:263201]. 10; [Podeszwa:2010:550]. 11; Keyword not used for user-defined functionals where the dft_dict[""dispersion""][""params""]; is easily editable for this purpose. See Advanced Functional Use and Manipulation. 12; [Caldeweyher:2019:154122]. A few practical examples:. DFT-D2 single point with default parameters (dftd3 not called); energy('bp86-d'). DFT-D3BJ optimization with default parameters; optimize('pbe-d3bj'). DFT-D2 optimization with custom s6 parameter; set dft_dispersion_parameters [1.20]; optimize('b3lyp-d2'). DFT-D3ZERO single point (b3lyp) with custom s8 parameter (reset all four values); set dft_dispersion_parameters [1.0, 2.0, 1.261, 14.0]; energy('b3lyp-d3'). DFT-D2 single point with dftd3 instead of PSI4‘s libdisp; energy('pbe-d2', engine='dftd3'). If only dispersion corrections (rather than total energies) are of; interest, the dispersion programs can be run independently of the scf; through the python function run_dftd3() or run_dftd4(). (These functions; call QCEngine, which is the same PSI4 + dftd3/dftd4 interface that is called during an scf job.); This “D-only” route is much faster than running a DFT-D energy.; Note that in a DFT+D energy or gradient calculation, user-specified; dispersion parameters override any information provided about the; functional. The same holds true for a dftd3 “D-only” calculation. But; in a dftd4 “D-only” calculation, functional information overrides; any user-specified dispersion parameters. Some set-up:; molecule nene {; Ne; Ne 1 2.0; }. nene.update_geometry(). The same four dispersion corrections/gradients as the section above:; >>> print nene.run_dftd3('bp86', 'd', dertype=0); -7.735e-05. >>> E, G = nene.run_dftd3('pbe', 'd3bj'); >>> print G; [[",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/dftd3-1.html:9208,energy,energy,9208,psi4manual/1.5.0/dftd3-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/dftd3-1.html,3,['energy'],['energy']
Energy Efficiency,"nsity Functional Theory (KS-DFT) is one of the primary; workhorses of modern computational chemistry due to its phenomenal accuracy/cost; ratio.; Pure Kohn-Sham DFT is based on the ideas that A) the energy is a universal; functional of the one-particle electronic density and B) there exists a set of; noninteracting quasiparticles with the same density as the true set of; electrons, with the quasiparticle states determined as eigenvectors of an; effective one-body potential encapsulating the true -body quantum; effects. The former idea allows the electronic density to be dealt with instead; of the much more complicated wavefunction, while the latter allows for the; treatment of the troublesome kinetic energy term via the implicit one-body; Kohn-Sham orbitals. KS-DFT borrows much of the machinery of Hartree-Fock, as is; evident by looking at the energy expression,. Here is the noninteracting quasiparticle kinetic energy operator,; is the nucleus-electron attraction potential, ; is the total electron density matrix, and is the (potentially nonlocal) exchange, correlation, and residual; kinetic energy functional. The residual kinetic energy term is usually quite; small, and is often ignored, hence is often referred to; as simply the exchange-correlation functional (exchange and correlation, not; just exchange-type correlation).; In practice, the first few generations of KS-DFT functionals were chosen to be; local, meaning that the form of the exchange correlation energy is an integral; over all of space of a function depending only on local information in the; density, such as the density value or derivatives. The simplest variants are; Local Spin-Density Approximations (LSDA), which depend only on the spin density; or ,. The most popular variants are Generalized Gradient Approximation (GGA); functionals which use the norm of the density gradient; , or; to build an inhomogeneity; parameter. where,. GGA functionals are essentially the same cost as LSDA functionals, and ar",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/dft-1.html:1459,energy,energy,1459,psi4manual/4.0b2/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/dft-1.html,16,['energy'],['energy']
Energy Efficiency,"nsity as this is often; much more costly than the energy. In addition, the Wavefunction density attributes; (Da and Db) return the SO density and must be transformed to the MO basis; to use with this function. New in version 0.5: wfn parameter passed explicitly. Returns; None. Parameters. filename (string) – destination file name for MOLDEN file (optional); do_virtual (bool) – do write all the MOs to the MOLDEN file (true) or discard the unoccupied MOs, not valid for NO’s (false) (optional); use_natural (bool) – write natural orbitals determined from density on wavefunction. Examples. Molden file with the Kohn-Sham orbitals of a DFT calculation.; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> wfn.molden('mycalc.molden'). Molden file with the natural orbitals of a CCSD computation. For correlated methods, an energy call will not compute the density.; “properties” or “gradient” must be called.; >>> E, wfn = properties('ccsd', return_wfn=True); >>> wfn.molden('ccsd_no.molden', use_natural=True). To supply a custom density matrix, manually set the Da and Db of the wavefunction.; This is used, for example, to write natural orbitals coming from a root computed; by a CIWavefunction computation, e.g., detci, fci, casscf.`; The first two arguments of get_opdm can be set to n, n where n => 0 selects the root to; write out, provided these roots were computed, see NUM_ROOTS. The; third argument controls the spin (""A"", ""B"" or ""SUM"") and the final; boolean option determines whether inactive orbitals are included.; >>> E, wfn = energy('detci', return_wfn=True); >>> wfn.Da() = wfn.get_opdm(0, 0, ""A"", True); >>> wfn.Db() = wfn.get_opdm(0, 0, ""B"", True); >>> molden(wfn, 'no_root1.molden', use_natural=True). write_nbo(name)¶. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. PSI4 API: Linking C++ and Python; HF. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.hf.html:35879,energy,energy,35879,psi4manual/1.4.0/api/psi4.core.hf.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.hf.html,1,['energy'],['energy']
Energy Efficiency,"nsity as this is often; much more costly than the energy. In addition, the Wavefunction density attributes; (Da and Db) return the SO density and must be transformed to the MO basis; to use with this function. New in version 0.5: wfn parameter passed explicitly. Returns; None. Parameters. filename (string) – destination file name for MOLDEN file (optional); do_virtual (bool) – do write all the MOs to the MOLDEN file (true) or discard the unoccupied MOs, not valid for NO’s (false) (optional); use_natural (bool) – write natural orbitals determined from density on wavefunction. Examples. Molden file with the Kohn-Sham orbitals of a DFT calculation.; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> wfn.molden('mycalc.molden'). Molden file with the natural orbitals of a CCSD computation. For correlated methods, an energy call will not compute the density.; “properties” or “gradient” must be called.; >>> E, wfn = properties('ccsd', return_wfn=True); >>> wfn.molden('ccsd_no.molden', use_natural=True). To supply a custom density matrix, manually set the Da and Db of the wavefunction.; This is used, for example, to write natural orbitals coming from a root computed; by a CIWavefunction computation, e.g., detci, fci, casscf.`; The first two arguments of get_opdm can be set to n, n where n => 0 selects the root to; write out, provided these roots were computed, see NUM_ROOTS. The; third argument controls the spin (""A"", ""B"" or ""SUM"") and the final; boolean option determines whether inactive orbitals are included.; >>> E, wfn = energy('detci', return_wfn=True); >>> wfn.Da() = wfn.get_opdm(0, 0, ""A"", True); >>> wfn.Db() = wfn.get_opdm(0, 0, ""B"", True); >>> molden(wfn, 'no_root1.molden', use_natural=True). write_nbo(name)¶. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. PSI4 API: Linking C++ and Python; HF. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2021 02:41AM.; Created using Sphinx 4.3.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.core.hf.html:37513,energy,energy,37513,psi4manual/1.5.0/api/psi4.core.hf.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.core.hf.html,2,['energy'],['energy']
Energy Efficiency,"nsity fitted REMP/cc-pVDZ energies for the CO2 molecule. omp2-5; SOS-OMP2 cc-pVDZ geometry optimization for the H2O molecule. opt13; B3LYP cc-pVDZ geometry optimzation of phenylacetylene, starting from not quite linear structure updated reference due to new BraggSlater radii. mints9; A test of the basis specification. Various basis sets are specified outright and in blocks, both orbital and auxiliary. Constructs libmints BasisSet objects through the constructor that calls qcdb.BasisSet infrastructure. Checks that the resulting bases are of the right size and checks that symmetry of the Molecule observes the basis assignment to atoms. scf1; RHF cc-pVQZ energy for the BH molecule, with Cartesian input. scf-cholesky-basis; incremental Cholesky filtered SCF. freq-isotope1; Vibrational and thermo analysis of several water isotopologs. Demonstrates Hessian reuse for different temperatures and pressures but not for different isotopologs. cc8b; ROHF-CCSD cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Cartesian input. cc15; RHF-B-CCD(T)/6-31G** H2O single-point energy (fzc, MO-basis \(\langle ab|cd \rangle\)). dfomp3-1; DF-OMP3 cc-pVDZ energy for the H2O molecule. ddd-function-kwargs; check distributed driver is correctly passing function kwargs. dct2; DC-06 calculation for the He dimer. This performs a two-step update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the MO Basis. cc13b; Tests RHF CCSD(T)gradients. cc17; Single point energies of multiple excited states with EOM-CCSD. ghosts; Density fitted MP2 cc-PVDZ/cc-pVDZ-RI computation of formic acid dimer binding energy using explicit specification of ghost atoms. This is equivalent to the dfmp2_1 sample but uses both (equivalent) specifications of ghost atoms in a manual counterpoise correction. dft-grad-lr3; wB97X-D test for a large UKS molecule update ref gradient due to new BraggSlater radii. decontract; RHF/cc-pvdz-decontract HCl single-p",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html:9710,energy,energy,9710,psi4manual/master/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"nsity_b: :py:class:`~psi4.core.Matrix`; :param density_b: density in the MO basis to build beta NO's from, assumes restricted if not supplied (optional). :type dovirtual: bool; :param dovirtual: do write all the MOs to the MOLDEN file (true) or discard the unoccupied MOs, not valid for NO's (false) (optional). :examples:. 1. Molden file with the Kohn-Sham orbitals of a DFT calculation. >>> E, wfn = energy('b3lyp', return_wfn=True); >>> molden(wfn, 'mycalc.molden'). 2. Molden file for CI/MCSCF computation using NO roots.; Any method returning a ``CIWavefunction`` object will work: ``detci``,; ``fci``, ``casscf``, etc. The first two arguments of ``get_opdm`` can be; set to ``n, n`` where n => 0 selects the root to write out, provided; these roots were computed, see :term:`NUM_ROOTS <NUM_ROOTS (DETCI)>`. The; third argument controls the spin (``""A""``, ``""B""`` or ``""SUM""``) and the final; boolean option determines whether inactive orbitals are included. >>> E, wfn = energy('detci', return_wfn=True); >>> molden(wfn, 'no_root1.molden', density_a=wfn.get_opdm(0, 0, ""A"", True)). 3. The following produces **an INCORRECT Molden file**, because the; ``molden`` function needs orbitals in the MO basis (which are internally; converted and written to the Molden file in the AO basis). The correct; usage is given in the next point. >>> E, wfn = energy('ccsd', return_wfn=True); >>> molden(wfn, 'ccsd_no.molden', density_a=wfn.Da()). 4. Molden file with the natural orbitals of the ground-state 1RDM of a; Post-HF calculation. Note the required transformation of Da (SO->MO). >>> E, wfn = properties('ccsd', return_wfn=True); >>> Da_so = wfn.Da(); >>> SCa = core.doublet(wfn.S(), wfn.Ca(), False, False); >>> Da_mo = core.triplet(SCa, Da_so, SCa, True, False, False); >>> molden(wfn, 'ccsd_no.molden', density_a=Da_mo). """""". if filename is None:; filename = core.get_writer_file_prefix(wfn.molecule().name()) + "".molden"". if dovirtual is None:; dovirt = bool(core.get_option(""SCF"", ""MOLDEN_WITH_V",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:99988,energy,energy,99988,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,14,['energy'],['energy']
Energy Efficiency,"nslating psi4 options to cfour, part ii. cfour/kw-3; Basis set spherical/Cartesian with cfour_basis and cfour_spherical. cfour/opt-rhf-ccsd_t_-ecc; optimization CCSD(T)/dzp on water with ecc, aobasis. cfour/sp-rohf-ccsd_t_; single-point CCSD(T)/qz2p on NH2. cfour/sp-rhf-ccsd_t_-ecc; single-point CCSD(T)/qz2p on water with ecc module. cfour/sp-rohf-ccsd-ao; single-point CCSD/qz2p on NH2 with aobasis. cfour/kw-2; testing best practices options, part ii. cfour/sp-uhf-ccsd_t_-ecc; single-point CCSD(T)/qz2p on NH2 with ecc. cfour/scf4; RHF cc-pVDZ energy for water, automatically scanning the symmetric stretch and bending coordinates using Python’s built-in loop mechanisms. The geometry is apecified using a Z-matrix with variables that are updated during the potential energy surface scan, and then the same procedure is performed using polar coordinates, converted to Cartesian coordinates. cfour/psi-ghost-grad; MP2 optimization of dimers with one momomer ghosted. Gradients after three opt cycles are compared with those from psi4. cfour/opt-rhf-scf; optimization HF/svp on water. cfour/sp-uhf-mp2; single-point MP2/qz2p on NH2. cfour/kw-5; Basis set spherical/Cartesian with basis and cfour_spherical. cfour/sp-uhf-ccsd_t_-ao-ecc; single-point CCSD(T)/qz2p on NH2 with ecc, aobasis. cfour/psi-rohf-scsmp2; ROHF MP2 energy components. Checks that computed identically between cfour and psi4. cfour/psi-uhf-mp3; UHF MP3 energy components. Checks that converted identically between cfour and psi4. cfour/dfmp2-1; MP2/cc-PVDZ computation of formic acid dimer binding energy using automatic counterpoise correction. Monomers are specified using Cartesian coordinates. cfour/sp-uhf-ccsd; single-point CCSD/qz2p on NH2. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Appendices; Test Suite and Sample Inputs; CFOUR. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_cfour.html:4603,energy,energy,4603,psi4manual/1.9.x/autodoc_testsuite_cfour.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_cfour.html,3,['energy'],['energy']
Energy Efficiency,"nstrained optimizations of HOOH in Cartesians. opt6; Various constrained energy minimizations of HOOH with cc-pvdz RHF Internal-coordinate constraints in internal-coordinate optimizations. dfmp2-3; DF-MP2 cc-pVDZ frozen core gradient of benzene, computed at the DF-SCF cc-pVDZ geometry. cdomp2-1; OMP2 cc-pVDZ energy for the H2O molecule. fsapt-diff1; This test case shows an example of running and analyzing a difference F-SAPT0/jun-cc-pvdz procedure for phenol dimer from the S22 database. cc13a; UHF-CCSD(T)/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. cbs-xtpl-alpha; Extrapolated water energies. cc8c; ROHF-CCSD cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Cartesian input. props1; RHF STO-3G dipole moment computation, performed by applying a finite electric field and numerical differentiation. cc45; RHF-EOM-CC2/cc-pVDZ lowest two states of each symmetry of H2O. soscf-large; Second-order SCF convergnece: Benzene. fnocc4; Test FNO-DF-CCSD(T) energy. tu3-h2o-opt; Optimize H2O HF/cc-pVDZ. cc9; UHF-CCSD(T) cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Z-matrix input. mcscf3; RHF 6-31G** energy of water, using the MCSCF module and Z-matrix input. mints2; A test of the basis specification. A benzene atom is defined using a ZMatrix containing dummy atoms and various basis sets are assigned to different atoms. The symmetry of the molecule is automatically lowered to account for the different basis sets. dcft8; DCFT calculation for the NH3+ radical using the ODC-12 and ODC-13 functionals. This performs both simultaneous and QC update of the orbitals and cumulant using DIIS extrapolation. Four-virtual integrals are first handled in the MO Basis for the first two energy computations. In the next computation ao_basis=disk algorithm is used, where the transformation of integrals for four-virtual case is avoided. cc12; Single point energies of multiple excited states with EOM-CCSD. dft2; DFT",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html:30525,energy,energy,30525,psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"nstructions. Type: array; Default: No Default. DMRG_UNITARY_WRITE (DMRG); DMRG — Whether or not to store the unitary on disk (convenient for restarting). Type: boolean; Default: true. DO_CCD_DISP (SAPT); SAPT (Expert) — Do CCD dispersion correction in SAPT2+, SAPT2+(3) or SAPT2+3?. Type: boolean; Default: false. DO_DIIS (DFOCC); DFOCC — Do apply DIIS extrapolation?. Type: boolean; Default: true. DO_DIIS (OCC); OCC — Do apply DIIS extrapolation?. Type: boolean; Default: true. DO_IND_EXCH_SINF (SAPT); SAPT (Expert) — For SAPT(DFT) computes the S^inf Exchange-Induction terms. Type: boolean; Default: false. DO_LEVEL_SHIFT (DFOCC); DFOCC — Do apply level shifting?. Type: boolean; Default: true. DO_LEVEL_SHIFT (OCC); OCC — Do apply level shifting?. Type: boolean; Default: true. DO_MBPT_DISP (SAPT); SAPT (Expert) — Do MBPT dispersion correction in SAPT2+, SAPT2+(3) or SAPT2+3, if also doing CCD?. Type: boolean; Default: true. DO_SCS (DFOCC); DFOCC — Do perform spin-component-scaled OMP2 (SCS-OMP2)? In all computation, SCS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SCS-OMP2, one needs to set ‘DO_SCS’ to true. Type: boolean; Default: false. DO_SCS (OCC); OCC — Do perform spin-component-scaled OMP2 (SCS-OMP2)? In all computation, SCS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SCS-OMP2, one needs to set ‘DO_SCS’ to true. Type: boolean; Default: false. DO_SINGLETS (CPHF); CPHF — Do singlet states? Default true. Type: boolean; Default: true. DO_SOS (DFOCC); DFOCC — Do perform spin-opposite-scaled OMP2 (SOS-OMP2)? In all computation, SOS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SOS-OMP2, one needs to set ‘DO_SOS’ to true. Type: boolean; Default: false. DO_SOS (OCC); OCC — Do perform spin-opposite-scaled OMP2 (SOS-OMP2)? In all computation, SOS",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodoc_glossary_options_c-1.html:112075,energy,energy,112075,psi4manual/1.3.2/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodoc_glossary_options_c-1.html,2,['energy'],['energy']
Energy Efficiency,"nsult the; database python files for available molecular systems. This; is the only portion of database input that is case sensitive;; choices for this keyword must match the database python file. Examples. >>> # [1] Two-stage SCF calculation on short, equilibrium, and long helium dimer; >>> db('scf','RGC10',cast_up='sto-3g',subset=['HeHe-0.85','HeHe-1.0','HeHe-1.5'], tabulate=['scf total energy','natom']). >>> # [2] Counterpoise-corrected interaction energies for three complexes in S22; >>> # Error statistics computed wrt an old benchmark, S22A; >>> database('mp2','S22',cp=1,subset=[16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). Output¶; At the beginning of a database job is printed a listing of the individual system; calculations which will be performed. The output snippet below is from the example job [1]; above. It shows each reagent required for the subset of database reactions requested.; Note that this is an un-counterpoise-corrected example, and the wrapper is smart enough; to compute only once the monomer whose energy will be subtracted from each of the three dimers.; RGC1-HeHe-0.85-dimer; RGC1-He-mono-unCP; RGC1-HeHe-1.0-dimer; RGC1-HeHe-1.5-dimer. At the end of the job, the Requested Energy table is printed that gives the total; energies for the requested model chemistry for each reagent and each reaction, as; well as the stoichiometric weights by which the reagent energies are transformed; into the reaction energy. In this case, the dimer is +1 and the monomer is -2,; indicating the interaction energy is computed",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/db-1.html:6200,energy,energy,6200,psi4manual/1.4.0/db-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/db-1.html,10,['energy'],['energy']
Energy Efficiency,"nt += 1. if bcc_iter_cnt == 1:; for pv in hold_qcvars:; hold_qcvars[pv] = ref_wfn.variable(pv). ref_wfn.set_variable(""BCCD TOTAL ENERGY"", ref_wfn.variable(""CCSD TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD CORRELATION ENERGY"", ref_wfn.variable(""BCCD TOTAL ENERGY"") - ref_wfn.variable(""SCF TOTAL ENERGY"")); ref_wfn.set_variable(""CURRENT CORRELATION ENERGY"", ref_wfn.variable(""BCCD CORRELATION ENERGY"")). # copy back canonical MP2 and CCSD from initial iteration; for pv, v in hold_qcvars.items():; if v is not None:; ref_wfn.set_variable(pv, v); core.set_variable(pv, v). if name == 'bccd(t)':; core.cctriples(ref_wfn); ref_wfn.set_variable(""B(T) CORRECTION ENERGY"", ref_wfn.variable(""(T) CORRECTION ENERGY"")); ref_wfn.set_variable(""BCCD(T) TOTAL ENERGY"", ref_wfn.variable(""CCSD(T) TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD(T) CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) TOTAL ENERGY"") - ref_wfn.variable(""SCF TOTAL ENERGY"")) # note != CCSD(T) CORRELATION ENERGY; ref_wfn.set_variable(""CURRENT CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) CORRELATION ENERGY"")). for pv in [""(T) CORRECTION ENERGY"", ""CCSD(T) TOTAL ENERGY"", ""CCSD(T) CORRELATION ENERGY""]:; ref_wfn.del_variable(pv); core.del_variable(pv). for pv in [; ""BCCD TOTAL ENERGY"",; ""BCCD CORRELATION ENERGY"",; ""B(T) CORRECTION ENERGY"",; ""BCCD(T) TOTAL ENERGY"",; ""BCCD(T) CORRELATION ENERGY"",; ""CURRENT CORRELATION ENERGY"",; ]:; if ref_wfn.has_variable(pv):; core.set_variable(pv, ref_wfn.variable(pv)). # Notes; # * BCCD or BCCD(T) correlation energy is total energy of last Brueckner iteration minus HF energy of first Brueckner iteration. optstash.restore(); return ref_wfn. def run_tdscf_excitations(wfn,**kwargs):. states = core.get_option(""SCF"",""TDSCF_STATES""). # some sanity checks; if sum(states) == 0:; raise ValidationError(""TDSCF: No states requested in TDSCF_STATES""). # unwrap 1-membered list of states, regardless of symmetry; # we will apportion states per irrep later on; if len(states) == 1:; states = states[0]. # Tie TDSCF",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:98060,ENERGY,ENERGY,98060,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,4,['ENERGY'],['ENERGY']
Energy Efficiency,"nt and symmetry; c1 molecule keywords, as in the example above. As a reminder, only; SAPT0 can handle the interaction of both closed- and open-shell monomers.; Higher-order SAPT and SAPT(DFT) are currently available only; for computation of interactions between; closed-shell singlets. The SAPT codes in PSI4 have been written; to utilize density fitting, which is much faster than using conventional; 4-index electron repulsion integrals. This happens automatically and; does not require any additional keywords to be specified (both the; SAPT computations and the underlying Hartree-Fock computations will; utilize density fitting).; For SAPT(DFT), the user will need to manually specify the GRAC shift of; both monomers, defined by the difference of ionization potential (IP) and; Kohn-Sham HOMO energy. The ionization potential data for many common molecules; is available in NIST Chemistry Webbook. Alternatively, one can estimate the; ionization potential of molecule by computing the energy difference between; the molecule as given, and the molecule after one electron has been removed; (e.g., the energy difference between a neutral molecule and its cation).; The values of GRAC shifts should be given in Hartree. For the example above,; the GRAC shift value of both molecules are calculated to be 0.1307 (using experimental; IP from CCCBDB), and the user would specify them using the following keywords:; set globals {; sapt_dft_grac_shift_a 0.1307; sapt_dft_grac_shift_b 0.1307; }. A complete, minimal example of a SAPT(DFT) computation is given below.; molecule {; 0 1; O -1.551007 -0.114520 0.000000; H -1.934259 0.762503 0.000000; H -0.599677 0.040712 0.000000; --; 0 1; O 1.350625 0.111469 0.000000; H 1.680398 -0.373741 -0.758561; H 1.680398 -0.373741 0.758561. units angstrom; }. set {; basis aug-cc-pVDZ; sapt_dft_grac_shift_a 0.1307; sapt_dft_grac_shift_b 0.1307; }. energy('sapt(dft)'). As already mentioned above, the SAPT0 module for open-shell cases can also; use exact integral",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/sapt.html:13281,energy,energy,13281,psi4manual/1.7.x/sapt.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/sapt.html,4,['energy'],['energy']
Energy Efficiency,"nt and symmetry; c1 molecule keywords, as in the example above. As a reminder, only; SAPT0 can handle the interaction of both closed- and open-shell monomers.; Higher-order SAPT and SAPT(DFT) are currently available only; for computation of interactions between; closed-shell singlets. The SAPT codes in PSI4 have been written; to utilize density fitting, which is much faster than using conventional; 4-index electron repulsion integrals. This happens automatically and; does not require any additional keywords to be specified (both the; SAPT computations and the underlying Hartree-Fock computations will; utilize density fitting).; For SAPT(DFT), the user will need to manually specify the GRAC shift of; both monomers, defined by the difference of ionization potential (IP) and; Kohn-Sham HOMO energy. The ionization potential data for many common molecules; is available in NIST Chemistry Webbook. Alternatively, one can estimate the; ionization potential of molecule by computing the energy difference between; the molecule as given, and the molecule after one electron has been removed; (e.g., the energy difference between a neutral molecule and its cation).; The values of GRAC shifts should be given in Hartree. For the example above,; the GRAC shift value of both molecules are calculated to be 0.1307, and the; user would specify them using the following keywords:; set globals {; sapt_dft_grac_shift_a 0.1307; sapt_dft_grac_shift_b 0.1307; }. A complete, minimal example of a SAPT(DFT) computation is given below.; molecule {; 0 1; O -1.551007 -0.114520 0.000000; H -1.934259 0.762503 0.000000; H -0.599677 0.040712 0.000000; --; 0 1; O 1.350625 0.111469 0.000000; H 1.680398 -0.373741 -0.758561; H 1.680398 -0.373741 0.758561. units angstrom; }. set {; basis aug-cc-pVDZ; sapt_dft_grac_shift_a 0.1307; sapt_dft_grac_shift_b 0.1307; }. energy('sapt(dft)'). As already mentioned above, the SAPT0 module for open-shell cases can also; use exact integrals for all terms except for dispersio",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/sapt-1.html:11826,energy,energy,11826,psi4manual/1.4.0/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/sapt-1.html,5,['energy'],['energy']
Energy Efficiency,"nt difficulties with running multiple jobs in the same scratch, the; process ID (PID) of the PSI4 instance is incorporated into the full file; name; therefore, it is safe to use the same scratch directory for calculations; running simultaneously.; To override any of these defaults for selected jobs, simply place the; appropriate commands from the snippets above in the input file itself. During; excecution, the ~/.psi4rc defaults will be loaded in first, but then the commands; in the input file will be executed. Executing PSI4 with the psi4 -m (for; messy) flag will prevent files being deleted at the end of the run:; psi4 -m. Alternately, the scratch directory can be set through the environment; variable PSI_SCRATCH (overrides ~/.psi4rc settings).; The ~/.psi4rc file can also be used to define constants that are accessible; in input files or to place any Python statements that should be executed; with every PSI4 instance. Threading¶; Most new modules in PSI4 are designed to run efficiently on SMP architectures; via application of several thread models. The de facto standard for PSI4; involves using threaded BLAS/LAPACK (particularly Intel’s excellent MKL package); for most tensor-like operations, OpenMP for more general operations, and Boost; Threads for some special-case operations. Note: Using OpenMP alone is a really; bad idea. The developers make little to no effort to explicitly parallelize; operations which are already easily threaded by MKL or other threaded BLAS. Less; than 20% of the threaded code in PSI4 uses OpenMP, the rest is handled by; parallel DGEMM and other library routines. From this point forward, it is; assumed that you have compiled PSI4 with OpenMP and MKL (Note that it is; possible to use g++ or another compiler and yet still link against MKL).; Control of threading in PSI4 can be accomplished at a variety of levels,; ranging from global environment variables to direct control of thread count in; the input file, to even directives specific to e",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/external-1.html:3978,efficient,efficiently,3978,psi4manual/4.0b2/external-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/external-1.html,2,['efficient'],['efficiently']
Energy Efficiency,"nt in enumerate(findif_meta_dict[""displacements""].values(), start=2):; _process_displacement(; energy, lowername, molecule, displacement, n, ndisp, write_orbitals=False, **kwargs). # Reset variables; for key, val in var_dict.items():; core.set_variable(key, val). # Compute the gradient; core.set_local_option('FINDIF', 'GRADIENT_WRITE', True); G = driver_findif.assemble_gradient_from_energies(findif_meta_dict); grad_psi_matrix = core.Matrix.from_array(G); grad_psi_matrix.print_out(); wfn.set_gradient(grad_psi_matrix); core.set_variable('CURRENT GRADIENT', grad_psi_matrix). # Explicitly set the current energy..; if isinstance(lowername, str) and lowername in procedures['energy']:; # this correctly filters out cbs fn and ""hf/cc-pvtz""; # it probably incorrectly filters out mp5, but reconsider in DDD; core.set_variable(f""{lowername.upper()} TOTAL GRADIENT"", grad_psi_matrix); wfn.set_variable(f""{lowername.upper()} TOTAL GRADIENT"", grad_psi_matrix); core.set_variable('CURRENT ENERGY', findif_meta_dict[""reference""][""energy""]); wfn.set_variable('CURRENT ENERGY', findif_meta_dict[""reference""][""energy""]). optstash.restore(). if core.get_option('FINDIF', 'GRADIENT_WRITE'):; filename = core.get_writer_file_prefix(wfn.molecule().name()) + "".grad""; qcdb.gradparse.to_string(np.asarray(wfn.gradient()), filename, dtype='GRD', mol=molecule, energy=wfn.energy()). if return_wfn:; return (wfn.gradient(), wfn); else:; return wfn.gradient(). [docs]def properties(*args, **kwargs):; r""""""Function to compute various properties. :aliases: prop(). :returns: none. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - This function at present has a limited functionality.; Consult the keywords sections of other modules for further property capabilities. +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | Name | Calls Method | Reference | Supported Properties |; +==========",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:44635,energy,energy,44635,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,6,"['ENERGY', 'energy']","['ENERGY', 'energy']"
Energy Efficiency,"nt matrix FCMFINAL, which is written to disk during the course of both analytic and finite-difference vibrational frequency calculations. No such transformation is performed if OFF (=0); while ON (=1) directs the program to evaluate the gradient and transform it to the chosen set of normal coordinates. A warning message is printed if the force constant matrix is unavailable. Type: boolean; Default: false. CFOUR_RESTART_CC (CFOUR); CFOUR — Offers the possibilty to restart a CC calculation which stopped for various reasons, e.g. time limit, in the correlation part. However, note that a restart which is specified by ON (= 1) needs the following files of the previous unfinished calculation: JOBARC, JAINDX, MOINTS, and MOABCD. Type: boolean; Default: false. CFOUR_ROT_EVEC (CFOUR); CFOUR — Specifies which eigenvector of the orbital rotation Hessian is to be used to rotate the original SCF orbitals. By default, it will use that associated with the lowest eigenvalue of the totally symmetric part of the block-factored Hessian, as this choice often leads to the lowest energy SCF solution. For RHF stability checks, only those instabilities which correspond to RHF solutions will be considered. It is important to understand that following non-symmetric eigenvectors lowers the symmetry of the wavefunction and that following RHF –> UHF stabilities leads to a UHF solution. To converge the SCF roots associated with such instabilities, one must run the calculation in reduced symmetry and as a closed-shell UHF case, respectively. Value n directs the program to follow the vector associated with the nth lowest eigenvalue having the proper symmetry (totally symmetric) and spin (RHF–>RHF or UHF–>UHF) properties. 0 means use the lowest eigenvalue. Type: integer; Default: 0. CFOUR_SAVE_INTS (CFOUR); CFOUR — Tells CFOUR whether to delete large files (AO integrals and MOINTS file for now) when they are no longer needed. OFF (=0) They will not be saved, ON (=1) they will be saved. Type: boolea",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html:73000,energy,energy,73000,psi4manual/1.0.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html,2,['energy'],['energy']
Energy Efficiency,"nt of; dispersion by an improved method based on coupled-cluster doubles (CCD).; This approach tends to give good improvements when dispersion effects; are very large, as in the PCCP dimer (see [Hohenstein:2011:2842]).; As shown in [Parker:2014:094106], whether or not CCD dispersion offers; more accurate interaction energies tends to depend on the SAPT truncation; and basis set employed, due to cancellations of errors. Thanks to; natural orbital methods [Parrish:2013:174102], the SAPT code; is able to include CCD dispersion with only a modest additional cost.; Computations employing CCD dispersion should cite [Parrish:2013:174102].; To request CCD dispersion treatment in a SAPT computation, simply append; (ccd) to the name of the method, as in the following examples; energy('sapt2+(ccd)'); energy('sapt2+(3)(ccd)'); energy('sapt2+3(ccd)'). The \(\delta_{MP2}\) corrections can also be computed automatically; by appending dmp2 to the name of the method, with or without CCD dispersion; energy('sapt2+dmp2'); energy('sapt2+(3)dmp2'); energy('sapt2+3dmp2'); energy('sapt2+(ccd)dmp2'); energy('sapt2+(3)(ccd)dmp2'); energy('sapt2+3(ccd)dmp2'). A brief note on memory usage: the higher-order SAPT code assumes that; certain quantities can be held in core. This code requires sufficient; memory to hold \(3o^2v^2+v^2N_{aux}\) arrays in core. With this; requirement computations on the adenine-thymine complex can be performed; with an aug-cc-pVTZ basis in less than 64GB of memory.; Higher-order SAPT is treated separately from the highly optimized SAPT0; code, therefore, higher-order SAPT uses a separate set of keywords.; The following keywords are relevant for higher-order SAPT. Basic Keywords for Higher-order SAPT¶. BASIS¶. Primary basis set, describes the monomer molecular orbitals. Type: string; Possible Values: basis string; Default: No Default. DF_BASIS_SAPT¶. Auxiliary basis set for SAPT density fitting computations. Defaults to a RI basis. Type: string; Possible Values: basis s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/sapt-1.html:25590,energy,energy,25590,psi4manual/1.4.0/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/sapt-1.html,54,['energy'],['energy']
Energy Efficiency,"nt one-electron property capabilities of PSI4¶. Feature; Keyword; Notes. Electric dipole moment; DIPOLE. Electric quadrupole moment; QUADRUPOLE; Raw (traced) moments and traceless multipoles. All moments up order N; MULTIPOLE(N); Only raw (traced) moments. Sets global variables e.g. “DIPOLE”, “32-POLE”. Electrostatic potential, at nuclei; ESP_AT_NUCLEI; Sets global variables “ESP AT CENTER n”, n = 1 to natoms. Electrostatic potential, on grid; GRID_ESP; Generates V at each point in grid_esp.dat. See Properties evaluated on a grid. Electric field, on grid; GRID_FIELD; Generates {Ex,Ey,Ez} at each point grid_field.dat. See Properties evaluated on a grid. Molecular orbital extents; MO_EXTENTS. Mulliken atomic charges; MULLIKEN_CHARGES. Löwdin atomic charges; LOWDIN_CHARGES. Wiberg bond indices; WIBERG_LOWDIN_INDICES; Uses (Löwdin) symmetrically orthogonalized orbitals. Mayer bond indices; MAYER_INDICES. Natural orbital occupations; NO_OCCUPATIONS. Stockholder Atomic Multipoles; MBIS_CHARGES; Generates atomic charges, dipoles, etc. See Minimal Basis Iterative Stockholder. Free-atom volumes; MBIS_VOLUME_RATIOS. There are two ways the computation of one-electron properties can be requested.; Firstly, the properties can be evaluated from the last; computed one-particle density, using the following syntax:; oeprop(""MO_EXTENTS"", ""MULTIPOLE(4)"", title = ""hello!""). Note that it is the user’s responsibility to ensure that the relaxed density; matrix is computed using the method of interest, which may require setting; additional keywords (see the method’s manual section for details). The named; argument, title, is completely optional and is prepended to any; globals variables set during the computation. The unnamed arguments are the; properties to be computed. These can appear in any order, and multiple; properties may be requested, as in the example above. Note that, due to Python; syntax restrictions, the title argument must appear after the list of; properties to compute. The ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/oeprop.html:1989,charge,charges,1989,psi4manual/1.7.x/oeprop.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/oeprop.html,2,['charge'],['charges']
Energy Efficiency,"nt one-electron property capabilities of PSI4¶. Feature; Keyword; Notes. Electric dipole moment; DIPOLE. Electric quadrupole moment; QUADRUPOLE; Raw (traced) moments and traceless multipoles. All moments up order N; MULTIPOLE(N); Only raw (traced) moments. Sets global variables e.g. “DIPOLE”, “32-POLE”. Electrostatic potential, at nuclei; ESP_AT_NUCLEI; Sets global variables “ESP AT CENTER n”, n = 1 to natoms. Electrostatic potential, on grid; GRID_ESP; Generates V at each point in grid_esp.dat. See Properties evaluated on a grid. Electric field, on grid; GRID_FIELD; Generates {Ex,Ey,Ez} at each point grid_field.dat. See Properties evaluated on a grid. Molecular orbital extents; MO_EXTENTS. Mulliken atomic charges; MULLIKEN_CHARGES. Löwdin atomic charges; LOWDIN_CHARGES. Wiberg bond indices; WIBERG_LOWDIN_INDICES; Uses (Löwdin) symmetrically orthogonalized orbitals. Mayer bond indices; MAYER_INDICES. Natural orbital occupations; NO_OCCUPATIONS. Stockholder Atomic Multipoles; MBIS_CHARGES; Generates atomic charges, dipoles, etc. See Minimal Basis Iterative Stockholder. Hirshfeld volume ratios; MBIS_VOLUME_RATIOS; Generate the AIM to free atom volume ratios. There are two ways the computation of one-electron properties can be requested.; Firstly, the properties can be evaluated from the last; computed one-particle density, using the following syntax:; oeprop(""MO_EXTENTS"", ""MULTIPOLE(4)"", title = ""hello!""). Note that it is the user’s responsibility to ensure that the relaxed density; matrix is computed using the method of interest, which may require setting; additional keywords (see the method’s manual section for details). The named; argument, title, is completely optional and is prepended to any; globals variables set during the computation. The unnamed arguments are the; properties to be computed. These can appear in any order, and multiple; properties may be requested, as in the example above. Note that, due to Python; syntax restrictions, the title argument must ap",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/oeprop.html:1991,charge,charges,1991,psi4manual/1.9.x/oeprop.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/oeprop.html,2,['charge'],['charges']
Energy Efficiency,"nt one-electron property capabilities of PSI4¶. Feature; Keyword; Notes. Electric dipole moment; DIPOLE. Electric quadrupole moment; QUADRUPOLE; Raw (traced) moments and traceless multipoles. All moments up order N; MULTIPOLE(N); Only raw (traced) moments. Sets global variables e.g. “DIPOLE”, “32-POLE”. Electrostatic potential, at nuclei; ESP_AT_NUCLEI; Sets global variables “ESP AT CENTER n”, n = 1 to natoms. Electrostatic potential, on grid; GRID_ESP; Generates V at each point in grid_esp.dat. See Properties evaluated on a grid. Electric field, on grid; GRID_FIELD; Generates {Ex,Ey,Ez} at each point grid_field.dat. See Properties evaluated on a grid. Molecular orbital extents; MO_EXTENTS. Mulliken atomic charges; MULLIKEN_CHARGES. Löwdin atomic charges; LOWDIN_CHARGES. Wiberg bond indices; WIBERG_LOWDIN_INDICES; Uses (Löwdin) symmetrically orthogonalized orbitals. Mayer bond indices; MAYER_INDICES. Natural orbital occupations; NO_OCCUPATIONS. Stockholder Atomic Multipoles; MBIS_CHARGES; Generates atomic charges, dipoles, etc. See Minimal Basis Iterative Stockholder. There are two ways the computation of one-electron properties can be requested.; Firstly, the properties can be evaluated from the last; computed one-particle density, using the following syntax:; oeprop(""MO_EXTENTS"", ""MULTIPOLE(4)"", title = ""hello!""). Note that it is the user’s responsibility to ensure that the relaxed density; matrix is computed using the method of interest, which may require setting; additional keywords (see the method’s manual section for details). The named; argument, title, is completely optional and is prepended to any; globals variables set during the computation. The unnamed arguments are the; properties to be computed. These can appear in any order, and multiple; properties may be requested, as in the example above. Note that, due to Python; syntax restrictions, the title argument must appear after the list of; properties to compute. The available properties are shown in the t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/oeprop.html:1975,charge,charges,1975,psi4manual/1.6.x/oeprop.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/oeprop.html,1,['charge'],['charges']
Energy Efficiency,"nt(lowername, molecule=molecule, **kwargs); translations_projection_sound, rotations_projection_sound = _energy_is_invariant(G0); core.print_out(; '\n Based on options and gradient (rms={:.2E}), recommend {}projecting translations and {}projecting rotations.\n'; .format(G0.rms(), '' if translations_projection_sound else 'not ',; '' if rotations_projection_sound else 'not ')); if not core.has_option_changed('FINDIF', 'FD_PROJECT'):; core.set_local_option('FINDIF', 'FD_PROJECT', rotations_projection_sound). # Does an analytic procedure exist for the requested method?; if dertype == 2:; core.print_out(""""""hessian() will perform analytic frequency computation.\n""""""). # We have the desired method. Do it.; wfn = procedures['hessian'][lowername](lowername, molecule=molecule, **kwargs); wfn.set_gradient(G0); optstash.restore(); optstash_conv.restore(). # TODO: check that current energy's being set to the right figure when this code is actually used; core.set_variable('CURRENT ENERGY', wfn.energy()). elif dertype == 1:; core.print_out(; """"""hessian() will perform frequency computation by finite difference of analytic gradients.\n""""""). # Obtain list of displacements; findif_meta_dict = driver_findif.hessian_from_gradient_geometries(molecule, irrep). # Record undisplaced symmetry for projection of displaced point groups; core.set_parent_symmetry(molecule.schoenflies_symbol()). ndisp = len(findif_meta_dict[""displacements""]) + 1. print("""""" %d displacements needed."""""" % ndisp). wfn = _process_displacement(gradient, lowername, molecule, findif_meta_dict[""reference""], 1, ndisp,; **kwargs); var_dict = core.variables(). for n, displacement in enumerate(findif_meta_dict[""displacements""].values(), start=2):; _process_displacement(; gradient, lowername, molecule, displacement, n, ndisp, write_orbitals=False, **kwargs). # Reset variables; for key, val in var_dict.items():; core.set_variable(key, val). # Assemble Hessian from gradients; # Final disp is undisp, so wfn has mol, G, H general t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html:65891,energy,energy,65891,psi4manual/1.3.2/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html,1,['energy'],['energy']
Energy Efficiency,"nt)arg5) -> None :; docstring; ; dcft(...); dcft() -> float :; Runs the density cumulant functional theory code.; ; deriv(...); deriv() -> int :; Runs deriv, which contracts density matrices with derivative integrals, to compute gradients.; ; detci(...); detci() -> float :; Runs the determinant-based configuration interaction code.; ; dfmp2(...); dfmp2() -> float :; Runs the DF-MP2 code.; ; dfmp2grad(...); dfmp2grad() -> float :; Runs the DF-MP2 gradient.; ; fd_1_0(...); fd_1_0( (list)arg1) -> PsiReturnType :; Performs a finite difference gradient computation, from energy points.; ; fd_freq_0(...); fd_freq_0( (list)arg1, (int)arg2) -> PsiReturnType :; Performs a finite difference frequency computation, from energy points, for a given irrep.; ; fd_freq_1(...); fd_freq_1( (list)arg1, (int)arg2) -> PsiReturnType :; Performs a finite difference frequency computation, from gradients, for a given irrep.; ; fd_geoms_1_0(...); fd_geoms_1_0() -> matrix_vector :; Gets the list of displacements needed for a finite difference gradient computation, from energy points.; ; fd_geoms_freq_0(...); fd_geoms_freq_0( (int)arg1) -> matrix_vector :; Gets the list of displacements needed for a finite difference frequency computation, from energy points, for a given irrep.; ; fd_geoms_freq_1(...); fd_geoms_freq_1( (int)arg1) -> matrix_vector :; Gets the list of displacements needed fof a finite difference frequency computation, from gradients, for a given irrep; ; fd_geoms_hessian_0(...); fd_geoms_hessian_0() -> matrix_vector :; Gets the list of displacements needed fof a finite difference frequency computation, from energy points.; ; fd_hessian_0(...); fd_hessian_0( (list)arg1) -> PsiReturnType :; Performs a finite difference frequency computation, from energy points.; ; flush_outfile(...); flush_outfile() -> None :; Flushes the output file.; ; fnocc(...); fnocc() -> float :; Runs the fno-ccsd(t)/qcisd(t)/mp4/cepa energy code; ; get_active_molecule(...); get_active_molecule() -> Molecule :;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/psimod-1.html:156469,energy,energy,156469,psi4manual/4.0b5/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/psimod-1.html,2,['energy'],['energy']
Energy Efficiency,"nt)arg9) -> None :; docstring; ; IDAMAX(...); IDAMAX( (int)arg1, (int)arg2, (Vector)arg3, (int)arg4) -> int :; docstring; ; adc(...); adc() -> float :; Runs the ADC propagator code, for excited states.; ; add_user_basis_file(...); add_user_basis_file( (str)arg1) -> None :; Adds a custom basis set file, provided by the user.; ; benchmark_blas1(...); benchmark_blas1( (int)arg1, (float)arg2) -> None :; docstring; ; benchmark_blas2(...); benchmark_blas2( (int)arg1, (float)arg2) -> None :; docstring; ; benchmark_blas3(...); benchmark_blas3( (int)arg1, (float)arg2, (int)arg3) -> None :; docstring; ; benchmark_disk(...); benchmark_disk( (int)arg1, (float)arg2) -> None :; docstring; ; benchmark_integrals(...); benchmark_integrals( (int)arg1, (float)arg2) -> None :; docstring; ; benchmark_math(...); benchmark_math( (float)arg1) -> None :; docstring; ; ccdensity(...); ccdensity() -> float :; Runs the code to compute coupled cluster density matrices.; ; ccenergy(...); ccenergy() -> float :; Runs the coupled cluster energy code.; ; cceom(...); cceom() -> float :; Runs the equation of motion coupled cluster code, for excited states.; ; cchbar(...); cchbar() -> float :; Runs the code to generate the similariry transformed Hamiltonian.; ; cclambda(...); cclambda() -> float :; Runs the coupled cluster lambda equations code.; ; ccresponse(...); ccresponse() -> float :; Runs the coupled cluster response theory code.; ; ccsort(...); ccsort() -> float :; Runs CCSORT, which reorders integrals for use in the coupled cluster codes.; ; cctriples(...); cctriples() -> float :; Runs the coupled cluster (T) energy code.; ; cepa(...); cepa() -> float :; Runs the coupled electron pair approximation code; ; clean(...); clean() -> None :; Function to remove scratch files. Call between independent jobs.; ; close_outfile(...); close_outfile() -> None :; Closes the output file.; ; dcft(...); dcft() -> float :; Runs the density cumulant functional theory code.; ; deriv(...); deriv() -> int :; Runs deri",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/psimod-1.html:104373,energy,energy,104373,psi4manual/4.0b3/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html,2,['energy'],['energy']
Energy Efficiency,"nt)arg9) -> None :; docstring; ; IDAMAX(...); IDAMAX( (int)arg1, (int)arg2, (Vector)arg3, (int)arg4) -> int :; docstring; ; adc(...); adc() -> float :; Runs the ADC propagator code, for excited states.; ; add_user_basis_file(...); add_user_basis_file( (str)arg1) -> None :; Adds a custom basis set file, provided by the user.; ; benchmark_blas1(...); benchmark_blas1( (int)arg1, (float)arg2) -> None :; docstring; ; benchmark_blas2(...); benchmark_blas2( (int)arg1, (float)arg2) -> None :; docstring; ; benchmark_blas3(...); benchmark_blas3( (int)arg1, (float)arg2, (int)arg3) -> None :; docstring; ; benchmark_disk(...); benchmark_disk( (int)arg1, (float)arg2) -> None :; docstring; ; benchmark_integrals(...); benchmark_integrals( (int)arg1, (float)arg2) -> None :; docstring; ; benchmark_math(...); benchmark_math( (float)arg1) -> None :; docstring; ; ccdensity(...); ccdensity() -> float :; Runs the code to compute coupled cluster density matrices.; ; ccenergy(...); ccenergy() -> float :; Runs the coupled cluster energy code.; ; cceom(...); cceom() -> float :; Runs the equation of motion coupled cluster code, for excited states.; ; cchbar(...); cchbar() -> float :; Runs the code to generate the similariry transformed Hamiltonian.; ; cclambda(...); cclambda() -> float :; Runs the coupled cluster lambda equations code.; ; ccresponse(...); ccresponse() -> float :; Runs the coupled cluster response theory code.; ; ccsort(...); ccsort() -> float :; Runs CCSORT, which reorders integrals for use in the coupled cluster codes.; ; cctriples(...); cctriples() -> float :; Runs the coupled cluster (T) energy code.; ; clean(...); clean() -> None :; Function to remove scratch files. Call between independent jobs.; ; close_outfile(...); close_outfile() -> None :; Closes the output file.; ; compute_shell(...); compute_shell( (TwoBodyAOInt)arg1, (int)arg2, (int)arg3, (int)arg4, (int)arg5) -> None :; docstring; ; dcft(...); dcft() -> float :; Runs the density cumulant functional theory code.; ;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/psimod-1.html:154546,energy,energy,154546,psi4manual/4.0b5/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/psimod-1.html,2,['energy'],['energy']
Energy Efficiency,"nt)arg9) -> None :; docstring; ; IDAMAX(...); IDAMAX( (int)arg1, (int)arg2, (Vector)arg3, (int)arg4) -> int :; docstring; ; adc(...); adc() -> float :; Runs the ADC propagator code, for excited states.; ; add_user_basis_file(...); add_user_basis_file( (str)arg1) -> None :; Adds a custom basis set file, provided by the user.; ; benchmark_blas1(...); benchmark_blas1( (int)arg1, (float)arg2) -> None :; docstring; ; benchmark_blas2(...); benchmark_blas2( (int)arg1, (float)arg2) -> None :; docstring; ; benchmark_blas3(...); benchmark_blas3( (int)arg1, (float)arg2, (int)arg3) -> None :; docstring; ; benchmark_disk(...); benchmark_disk( (int)arg1, (float)arg2) -> None :; docstring; ; benchmark_integrals(...); benchmark_integrals( (int)arg1, (float)arg2) -> None :; docstring; ; benchmark_math(...); benchmark_math( (float)arg1) -> None :; docstring; ; ccdensity(...); ccdensity() -> float :; Runs the code to compute coupled cluster density matrices.; ; ccenergy(...); ccenergy() -> float :; Runs the coupled cluster energy code.; ; cceom(...); cceom() -> float :; Runs the equation of motion coupled cluster code, for excited states.; ; cchbar(...); cchbar() -> float :; Runs the code to generate the similariry transformed Hamiltonian.; ; cclambda(...); cclambda() -> float :; Runs the coupled cluster lambda equations code.; ; ccresponse(...); ccresponse() -> float :; Runs the coupled cluster response theory code.; ; ccsort(...); ccsort() -> float :; Runs CCSORT, which reorders integrals for use in the coupled cluster codes.; ; cctriples(...); cctriples() -> float :; Runs the coupled cluster (T) energy code.; ; clean(...); clean() -> None :; Function to remove scratch files. Call between independent jobs.; ; close_outfile(...); close_outfile() -> None :; Closes the output file.; ; dcft(...); dcft() -> float :; Runs the density cumulant functional theory code.; ; deriv(...); deriv() -> int :; Runs deriv, which contracts density matrices with derivative integrals, to compute gradients",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/psimod-1.html:104747,energy,energy,104747,psi4manual/4.0b4/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html,2,['energy'],['energy']
Energy Efficiency,"nt-based configuration interaction code. dfmp2(arg0); Runs the DF-MP2 code. dfocc(arg0); Runs the density-fitted orbital optimized CC codes. displace_atom(arg0, arg1, arg2, arg3, arg4); Displaces one coordinate of single atom. dmrg(arg0); Runs the DMRG code. efp_init(); Initializes the EFP library and returns an EFP object. efp_set_options(); Set EFP options from environment options object. fcidump_tei_helper(nirrep, restricted, …); Write integrals to file in FCIDUMP format. fd_1_0(arg0, arg1); Performs a finite difference gradient computation, from energy points. fd_freq_0(arg0, arg1, arg2); Performs a finite difference frequency computation, from energy points, for a given irrep. fd_freq_1(arg0, arg1, arg2); Performs a finite difference frequency computation, from gradients, for a given irrep. fd_geoms_1_0(arg0); Gets list of displacements needed for a finite difference gradient computation, from energy points. fd_geoms_freq_0(arg0, arg1); Gets list of displacements needed for a finite difference frequency computation, from energy points, for a given irrep. fd_geoms_freq_1(arg0, arg1); Gets list of displacements needed fof a finite difference frequency computation, from gradients, for a given irrep. finalize(). flush_outfile(); Flushes the output file. fnocc(arg0); Runs the fno-ccsd(t)/qcisd(t)/mp4/cepa energy code. get_active_efp(); Returns the currently active EFP object. get_active_molecule(); Returns the currently active molecule object. get_array_variable(arg0); Returns one of the PSI variables set internally by the modules or python driver (see manual for full listing of variables available). get_array_variables(); Returns dictionary of the PSI variables set internally by the modules or python driver. get_atomic_point_charges(); Returns the most recently computed atomic point charges, as a double * object. get_datadir(); Sets the path to shared text resources, PSIDATADIR. get_efp_torque(); Returns the most recently computed gradient for the EFP portion, as a ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/psi4api-1.html:243321,energy,energy,243321,psi4manual/1.2.1/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html,2,['energy'],['energy']
Energy Efficiency,"nt. \(^1A_1\) F2 state described using the Ms = 0 component of the singlet. Uses TCSCF singlet orbitals. dfmp2-freq1; DF-MP2 frequency by difference of energies for H2O. cc51; EOM-CC3/cc-pVTZ on H2O. rasci-h2o; RASCI/6-31G** H2O Energy Point. ddd-deriv; Sample HF/cc-pVDZ H2O computation all derivatives. scf-auto-cholesky; Cholesky filter a complete basis. sapt-dft-lrc; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. castup3; SCF with various combinations of pk/density-fitting, castup/no-castup, and spherical/cartesian settings. Demonstrates that puream setting is getting set by orbital basis for all df/castup parts of calc. Demonstrates that answer doesn’t depend on presence/absence of castup. Demonstrates (by comparison to castup2) that output file doesn’t depend on options (scf_type) being set global or local. This input uses local. cc50; EOM-CC3(ROHF) on CH radical with user-specified basis and properties for particular root. sapt-dft-api; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. freq-isotope1; Vibrational and thermo analysis of several water isotopologs. Demonstrates Hessian reuse for different temperatures and pressures but not for different isotopologs. dft-pbe0-2; Internal match to psi4, test to match to literature values in litref.in/litref.out. dft-grad-meta; meta-GGA gradients of water and ssh molecules reference gradients updated due to new BraggSlater radii. dft-freq; Frequencies for H2O B3LYP/6-31G* at optimized geometry. pywrap-cbs1; Various basis set extrapolation tests. mp2p5-grad2; MP2.5 cc-pVDZ gradient for the NO radical. dct10; The multiple guesses for DCT amplitudes for ODC-12. tu6-cp-ne2; Example potential energy surface scan and CP-correction for Ne2. dct-grad4; Unrestricted DF-DCT ODC-12 gradient for O2 with cc-pVTZ/cc-pVTZ-RI standard/auxiliary basis set. fsapt-ext; Quick test of external potential in F-SAPT (see fsapt1 for a real example). props4; Electrostatic potential and electric field evaluate",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html:10241,energy,energy,10241,psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"nt. mrcc4; CCSDT cc-pVDZ optimization and frequencies for the H2O molecule using MRCC. props1; RHF STO-3G dipole moment computation, performed by applying a finite electric field and numerical differentiation. cc42; RHF-CC2-LR/STO-3G optical rotation of (S)-methyloxirane. gauge = length, omega = (589 355 nm). fci-dipole; 6-31G H2O Test FCI Energy Point. tu4-h2o-freq; Frequencies for H2O HF/cc-pVDZ at optimized geometry. dcft3; DCFT-06 calculation for the He dimer. This performs a simultaneous update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the AO Basis, using integrals stored on disk. cc4a; RHF-CCSD(T) cc-pVQZ frozen-core energy of the BH molecule, with Cartesian input. This version tests the FROZEN_DOCC option explicitly. cisd-h2o+-1; 6-31G** H2O+ Test CISD Energy Point. dft-psivar; HF and DFT variants single-points on zmat methane, mostly to test that PSI variables are set and computed correctly. pywrap-alias; Test parsed and exotic calls to energy() like zapt4, mp2.5, and cisd are working. cc8b; ROHF-CCSD cc-pVDZ frozen-core energy for the state of the CN radical, with Cartesian input. mints3; Test individual integral objects for correctness. omp3-2; SCS-OMP3 cc-pVDZ geometry optimization for the H2O molecule. cc2; 6-31G** H2O CCSD optimization by energies, with Z-Matrix input. cc45; RHF-EOM-CC2/cc-pVDZ lowest two states of each symmetry of H2O. fci-tdm-2; BH-H2+ FCI/cc-pVDZ Transition Dipole Moment. psimrcc-ccsd_t-2; Mk-MRCCSD(T) single point. CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. sad1; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. psimrcc-fd-freq1; Mk-MRCCSD single point. O2 state ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_testsuite-1.html:12402,energy,energy,12402,psi4manual/4.0b3/autodoc_testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_testsuite-1.html,4,['energy'],['energy']
Energy Efficiency,"nt; Computation of VMFC-corrected water trimer gradient (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). dft-custom; DFT custom functional test. dft2; DFT Functional Test. molden1; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. cepa-module; routing check on lccd, lccsd, cepa(0). dct12; Spin-restricted DC-06 counterpart of dct1. dft-b3lyp; Check flavors of B3LYP (b3lyp3/b3lyp5) against other programs. cc9a; ROHF-CCSD(T) cc-pVDZ energy for the \(^2\Sigma^+\) state of the CN radical, with Z-matrix input. mints12; test roundtrip-ness of dict repr for psi4.core.Molecule and qcdb.Molecule. fsapt2; A very quick correctness test of F-SAPT (see fsapt1 for a real example). omp2p5-2; OMP2.5 cc-pVDZ energy for the H2O molecule. cc6; Frozen-core CCSD(T)/cc-pVDZ on C4H4N anion with disk ao algorithm. ddd-function-kwargs; check distributed driver is correctly passing function kwargs. numpy-array-interface; Numpy interface testing. cc54; CCSD dipole with user-specified basis set. omp2-grad1; OMP2 cc-pVDZ gradient for the H2O molecule. cc32; CC3/cc-pVDZ H2O \(R_e\) geom from Olsen et al., JCP 104, 8007 (1996). fnocc1; Test QCISD(T) for H2O/cc-pvdz Energy. dft-dens-cut; LibXC density screening test. Tests empty, C-only, X-only and XC superfunctionals. ‘super_mix’ showcases how to use different screening values for X and C parts. SCF will fail or crash (nans) without screening!. oremp-grad2; integral conventional OO-REMP/cc-pVDZ engrad single points for the H2O molecule. single point energies were independently checked using the original wavels code. ao-casscf-sp; CASSCF/6-31G** energy point. cc31; CCSD/sto-3g optical rotation calculation (both gauges) at two frequencies on methyloxirane. cc51; E",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html:15944,energy,energy,15944,psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"nt; if *dertype* is 1, else tuple of energy and gradient if *dertype*; unspecified. The gcp executable must be independently compiled and; found in :envvar:`PATH` or :envvar:`PSIPATH`. *self* may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended by this method py-side and only public interface; fns used) or a string that can be instantiated into a qcdb.Molecule. Parameters; ----------; func; Name of method/basis combination or composite method for which to compute the correction; (e.g., HF/cc-pVDZ, DFT/def2-SVP, HF3c, PBEh3c).; dertype; Maximum derivative level at which to run GCP. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose; Amount of printing. Unused at present. Returns; -------; energy : float; When `dertype=0`, energy [Eh].; gradient : ndarray; When `dertype=1`, (nat, 3) gradient [Eh/a0].; (energy, gradient) : tuple of float and ndarray; When `dertype=None`, both energy [Eh] and (nat, 3) gradient [Eh/a0]. """"""; import qcengine as qcng. if dertype is None:; derint, derdriver = -1, 'gradient'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). resinp = {; 'molecule': self.to_schema(dtype=2),; 'driver': derdriver,; 'model': {; 'method': func,; 'basis': '(auto)',; },; 'keywords': {; 'verbose': verbose,; },; }; try:; jobrec = qcng.compute(resinp, 'mctc-gcp', raise_error=True); except qcng.exceptions.ResourceError:; jobrec = qcng.compute(resinp, 'gcp', raise_error=True). jobrec = jobrec.dict(). # hack (instead of checking dertype GRAD) to collect `(nat, 3)` ndarray of gradient if present; for variable_name, qcv in jobrec['extras']['qcvars'].items():; if isinstance(qcv, (list, np.ndarray)):; jobrec['extras']['qcvars'][variable_name] = np.array(qcv).reshape(-1, 3). if isinstance(self, Molecule):; pass; else:; from psi4 import core. for variable_name, qcv in jobrec['extras']['qcvars'].items():; if not isinstance(qcv, (l",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:46550,energy,energy,46550,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,16,['energy'],['energy']
Energy Efficiency,"nt_out('\n'). # Compute dimer wavefunction. if (sapt_basis == 'dimer') and (ri == 'DF'):; core.set_global_option('DF_INTS_IO', 'SAVE'). core.timer_on(""SAPT: Dimer SCF""); dimer_wfn = scf_helper('RHF', molecule=sapt_dimer, **kwargs); core.timer_off(""SAPT: Dimer SCF""). if do_delta_mp2:; select_mp2(name, ref_wfn=dimer_wfn, **kwargs); mp2_corl_interaction_e = core.variable('MP2 CORRELATION ENERGY'). if (sapt_basis == 'dimer') and (ri == 'DF'):; core.set_global_option('DF_INTS_IO', 'LOAD'). # Compute Monomer A wavefunction; if (sapt_basis == 'dimer') and (ri == 'DF'):; core.IO.change_file_namespace(97, 'dimer', 'monomerA'). core.IO.set_default_namespace('monomerA'); core.print_out('\n'); p4util.banner('Monomer A HF'); core.print_out('\n'). core.timer_on(""SAPT: Monomer A SCF""); monomerA_wfn = scf_helper('RHF', molecule=monomerA, **kwargs); core.timer_off(""SAPT: Monomer A SCF""). if do_delta_mp2:; select_mp2(name, ref_wfn=monomerA_wfn, **kwargs); mp2_corl_interaction_e -= core.variable('MP2 CORRELATION ENERGY'). # Compute Monomer B wavefunction; if (sapt_basis == 'dimer') and (ri == 'DF'):; core.IO.change_file_namespace(97, 'monomerA', 'monomerB'); core.IO.set_default_namespace('monomerB'); core.print_out('\n'); p4util.banner('Monomer B HF'); core.print_out('\n'). core.timer_on(""SAPT: Monomer B SCF""); monomerB_wfn = scf_helper('RHF', molecule=monomerB, **kwargs); core.timer_off(""SAPT: Monomer B SCF""). # Delta MP2; if do_delta_mp2:; select_mp2(name, ref_wfn=monomerB_wfn, **kwargs); mp2_corl_interaction_e -= core.variable('MP2 CORRELATION ENERGY'); core.set_variable(""SAPT MP2 CORRELATION ENERGY"", mp2_corl_interaction_e) # P::e SAPT; core.set_global_option('DF_INTS_IO', df_ints_io). if core.get_option('SCF', 'REFERENCE') == 'RHF':; core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERA, 'monomerA', 'dimer'); core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERB, 'monomerB', 'dimer'). core.IO.set_default_namespace('dimer'); core.set_local_option('SAPT', 'E_CONVERGENCE', 10e-10); c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:134909,ENERGY,ENERGY,134909,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"nt_out(); core.print_out("""""" Extrapolated Data:\n""""""); value.print_out(); core.print_out("""""" Alpha (exponent) Value: %16.8f\n"""""" % alpha); core.print_out("""""" Beta Data:\n""""""); beta.print_out(). # value.add(valueSCF); return value. else:; raise ValidationError(""corl_xtpl_helgaker_2: datatype is not recognized '%s'."" % type(valueLO)). def return_energy_components():; """"""Define some quantum chemical knowledge, namely what methods are subsumed in others."""""". # yapf: disable; VARH = {}; VARH['scf'] = {; 'scf': 'SCF TOTAL ENERGY'}; VARH['hf'] = {; 'hf': 'HF TOTAL ENERGY'}; VARH['mp2'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY'}; VARH['mp2d'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2d': 'MP2D TOTAL ENERGY'}; VARH['mp2.5'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'mp2.5': 'MP2.5 TOTAL ENERGY',; 'mp3': 'MP3 TOTAL ENERGY'}; VARH['mp3'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'mp2.5': 'MP2.5 TOTAL ENERGY',; 'mp3': 'MP3 TOTAL ENERGY'}; VARH['mp4(sdq)'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'mp2.5': 'MP2.5 TOTAL ENERGY',; 'mp3': 'MP3 TOTAL ENERGY',; 'mp4(sdq)': 'MP4(SDQ) TOTAL ENERGY'}; VARH['mp4'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'mp2.5': 'MP2.5 TOTAL ENERGY',; 'mp3': 'MP3 TOTAL ENERGY',; 'mp4(sdq)': 'MP4(SDQ) TOTAL ENERGY',; 'mp4': 'MP4 TOTAL ENERGY'}; VARH['omp2'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'omp2': 'OMP2 TOTAL ENERGY'}; VARH['omp2.5'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'mp2.5': 'MP2.5 TOTAL ENERGY',; 'omp2.5': 'OMP2.5 TOTAL ENERGY'}; VARH['omp3'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'mp3': 'MP3 TOTAL ENERGY',; 'omp3': 'OMP3 TOTAL ENERGY'}; VARH['olccd'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'olccd': 'OLCCD TOTAL ENERGY'}; VARH['lccd'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'lccd': 'LCCD TOTAL ENERGY'}; VARH['lccsd'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERG",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:23918,ENERGY,ENERGY,23918,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,4,['ENERGY'],['ENERGY']
Energy Efficiency,"nt_slice_dict[bas]] += sign * grad[start:end]; start += fragment_size_dict[bas]. elif ptype == 'hessian':; for fragn, basisn in compute_list:; hess = np.asarray(ptype_dict[(fragn, basisn)]). if vmfc:; sign = ((-1)**(n - len(fragn))). # Build up start and end slices; abs_start, rel_start = 0, 0; abs_slices, rel_slices = [], []; for bas in basisn:; rel_end = rel_start + 3 * fragment_size_dict[bas]; rel_slices.append(slice(rel_start, rel_end)); rel_start += 3 * fragment_size_dict[bas]. tmp_slice = fragment_slice_dict[bas]; abs_slices.append(slice(tmp_slice.start * 3, tmp_slice.stop * 3)). for abs_sl1, rel_sl1 in zip(abs_slices, rel_slices):; for abs_sl2, rel_sl2 in zip(abs_slices, rel_slices):; ret[abs_sl1, abs_sl2] += hess[rel_sl1, rel_sl2]. else:; raise KeyError(""ptype can only be gradient or hessian How did you end up here?""). def _print_nbody_energy(energy_body_dict, header, embedding=False):; core.print_out(""""""\n ==> N-Body: %s energies <==\n\n"""""" % header); core.print_out("""""" n-Body Total Energy [Eh] I.E. [kcal/mol] Delta [kcal/mol]\n""""""); previous_e = energy_body_dict[1]; if previous_e == 0.0:; tot_e = False; else:; tot_e = True; nbody_range = list(energy_body_dict); nbody_range.sort(); for n in nbody_range:; delta_e = (energy_body_dict[n] - previous_e); delta_e_kcal = delta_e * constants.hartree2kcalmol; int_e_kcal = (; energy_body_dict[n] - energy_body_dict[1]) * constants.hartree2kcalmol if not embedding else np.nan; if tot_e:; core.print_out("""""" %4s %20.12f %20.12f %20.12f\n"""""" % (n, energy_body_dict[n], int_e_kcal,; delta_e_kcal)); else:; core.print_out("""""" %4s %20s %20.12f %20.12f\n"""""" % (n, ""N/A"", int_e_kcal,; delta_e_kcal)); previous_e = energy_body_dict[n]; core.print_out(""\n""). [docs]def nbody_gufunc(func: Union[str, Callable], method_string: str, **kwargs):; """"""; Computes the nbody interaction energy, gradient, or Hessian depending on input.; This is a generalized universal function for computing interaction and total quantities. :returns: *return type",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html:3034,Energy,Energy,3034,psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html,2,['Energy'],['Energy']
Energy Efficiency,"ntact the developers on GitHub and/or the forum. External potentials and QM/MM¶; In addition to the implementation of EFP for accurate QM/MM; computations, PSI4 can perform more rudimentary QM/MM procedures via the; EXTERN keyword. The following snippet, extracted from the; extern1 test case, demonstrates its use for a TIP3P external potential:; 1; 2; 3; 4; 5Chrgfield = QMMM(); Chrgfield.extern.addCharge(-0.834, 1.649232019048, 0.0, -2.356023604706); Chrgfield.extern.addCharge( 0.417, 0.544757019107, 0.0, -3.799961446760); Chrgfield.extern.addCharge( 0.417, 0.544757019107, 0.0, -0.912085762652); psi4.set_global_option_python('EXTERN', Chrgfield.extern). First a QMMM object is created, then three separate particles are added to this; object before the SCF code is told about its existence on the last line. The; calls to addCharge take the atomic charge, x coordinate, y coordinate, and; z coordinate in that order. The atomic charge is specified in atomic units,; and the coordinates always use the same units as the geometry specification in; the regular QM region. Additional MM molecules may be specified by adding; extra calls to addCharge to describe the full MM region.; To run a computation in a constant dipole field, the PERTURB_H,; PERTURB_WITH and PERTURB_DIPOLE keywords can be used. As an; example, to add a dipole field of magnitude 0.05 a.u. in the y direction and; 0.1 a.u. in the z direction, we can use the following keywords:; 1; 2; 3set perturb_h true; set perturb_with dipole; set perturb_dipole [ 0, 0.05, 0.1 ]. Note that if any specified fields do not fall along a symmetry axis, the; symmetry of the calculation should be reduced accordingly; if in doubt run the; calculation in C1 symmetry. For examples of SCF and MP2 calculations in an; external field, see scf7 and dfmp2-grad5. Convergence and Algorithm Defaults¶. SCF algorithm and convergence criteria defaults by calculation type [1]¶. Ab Initio Method; Calculation Type; E_CONVERGENCE; D_CONVERGENCE; SCF_TY",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/scf-1.html:34920,charge,charge,34920,psi4manual/1.2.1/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/scf-1.html,4,['charge'],['charge']
Energy Efficiency,"ntdump = fcidump_from_file(expected); intdump = fcidump_from_file(computed). # Compare headers; header_diff = DeepDiff(; ref_intdump,; intdump,; ignore_order=True,; exclude_paths={""root['enuc']"", ""root['hcore']"", ""root['eri']"", ""root['epsilon']""}); if header_diff:; message = (""\tComputed FCIDUMP file header does not match expected header.\n""); raise TestComparisonError(header_diff). ref_energies = energies_from_fcidump(ref_intdump); energies = energies_from_fcidump(intdump). pass_1el = compare_values(ref_energies['ONE-ELECTRON ENERGY'], energies['ONE-ELECTRON ENERGY'], 7,; label + '. 1-electron energy'); pass_2el = compare_values(ref_energies['TWO-ELECTRON ENERGY'], energies['TWO-ELECTRON ENERGY'], 7,; label + '. 2-electron energy'); pass_scf = compare_values(ref_energies['SCF TOTAL ENERGY'], energies['SCF TOTAL ENERGY'], 10,; label + '. SCF total energy'); pass_mp2 = compare_values(ref_energies['MP2 CORRELATION ENERGY'], energies['MP2 CORRELATION ENERGY'], 10,; label + '. MP2 correlation energy'). if (pass_1el and pass_2el and pass_scf and pass_mp2):; success(label). return True. [docs]def energies_from_fcidump(intdump):; energies = {}; energies['NUCLEAR REPULSION ENERGY'] = intdump['enuc']; epsilon = intdump['epsilon']; Hcore = intdump['hcore']; eri = intdump['eri']. # Compute SCF energy; energies['ONE-ELECTRON ENERGY'], energies['TWO-ELECTRON ENERGY'] = _scf_energy(Hcore, eri,; np.where(epsilon < 0)[0],; intdump['uhf']); # yapf: disable; energies['SCF TOTAL ENERGY'] = energies['ONE-ELECTRON ENERGY'] + energies['TWO-ELECTRON ENERGY'] + energies['NUCLEAR REPULSION ENERGY']; # yapf: enable. # Compute MP2 energy; energies['MP2 CORRELATION ENERGY'] = _mp2_energy(eri, epsilon, intdump['uhf']). return energies. def _scf_energy(Hcore, ERI, occ_sl, unrestricted):; scf_1el_e = np.einsum('ii->', Hcore[np.ix_(occ_sl, occ_sl)]); if not unrestricted:; scf_1el_e *= 2; coulomb = np.einsum('iijj->', ERI[np.ix_(occ_sl, occ_sl, occ_sl, occ_sl)]); exchange = np.einsum('ijij->', ERI[",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/fcidump.html:13903,energy,energy,13903,psi4manual/1.3.2/_modules/psi4/driver/p4util/fcidump.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/fcidump.html,1,['energy'],['energy']
Energy Efficiency,"nted for F/I-SAPT. SAPT HF(2) ENERGY A(0)¶; The Hartree–Fock energy [Eh] of subsystem A implemented for F/I-SAPT. SAPT HF(2) ENERGY B(0)¶; The Hartree–Fock energy [Eh] of subsystem B implemented for F/I-SAPT. SAPT HF(2) ENERGY AC(HF)¶; The Hartree–Fock localized energy [Eh] of subsystems A and C implemented for F/I-SAPT. SAPT HF(2) ENERGY BC(HF)¶; The Hartree–Fock localized energy [Eh] of subsystems B and C implemented for F/I-SAPT. SAPT HF(2) ENERGY AB(HF)¶; The Hartree–Fock localized energy [Eh] of subsystems A and B implemented for F/I-SAPT. SAPT HF(2) ENERGY A(HF)¶; The Hartree–Fock localized energy [Eh] of subsystem A implemented for F/I-SAPT. SAPT HF(2) ENERGY B(HF)¶; The Hartree–Fock localized energy [Eh] of subsystem B implemented for F/I-SAPT. SAPT HF(2) ENERGY C¶; The Hartree–Fock energy [Eh] of subsystem C implemented for F/I-SAPT. SAPT HF(2) ENERGY HF¶; The FI-SAPT Hartree–Fock interaction energy [Eh] implemented for F/I-SAPT. SAPT ELST12,R ENERGY¶; An electrostatics-classified SAPT term energy [Eh] implemented for SAPT2. SAPT EXCH11(S^2) ENERGY¶. SAPT EXCH12(S^2) ENERGY¶; An exchange-classified SAPT term energy [Eh] implemented for SAPT2. SAPT IND22 ENERGY¶. SAPT EXCH-IND22 ENERGY¶; An induction-classified SAPT term energy [Eh] implemented for SAPT2. SAPT DISP21 ENERGY¶; A dispersion-classified SAPT term energy [Eh] implemented for SAPT2+. SAPT DISP22(SDQ) ENERGY¶. SAPT DISP22(T) ENERGY¶. SAPT EST.DISP22(T) ENERGY¶; Dispersion-classified MBPT-based SAPT term energy [Eh] implemented for SAPT2+. SAPT DISP2(CCD) ENERGY¶. SAPT DISP22(S)(CCD) ENERGY¶. SAPT DISP22(T)(CCD) ENERGY¶. SAPT EST.DISP22(T)(CCD) ENERGY¶; Dispersion-classified coupled-cluster-based SAPT term energy [Eh] implemented for SAPT2+. SAPT ELST13,R ENERGY¶; An electrostatics-classified SAPT term energy [Eh] implemented for SAPT2+(3). SAPT IND30,R ENERGY¶. SAPT IND-DISP30 ENERGY¶. SAPT EXCH-IND30,R ENERGY¶; A induction-classified SAPT term energy [Eh] implemented for SAPT2+3. SAPT DISP30 ENERGY",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html:37661,energy,energy,37661,psi4manual/1.4.0/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html,5,['energy'],['energy']
Energy Efficiency,"nted. Buy a developer a coffee. No way to tell function to boost fitting basis size for all calculations.; No way to extrapolate def2 family basis sets; Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in several; sequential stages (scf, corl, delta, delta2, delta3, delta4, delta5) covering treatment; of the reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction, etc.. Each is activated by its; stage_wfn keyword and is only allowed if all preceding stages are active. Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy.; The cbs() function requires, at a minimum, name='scf' and scf_basis; keywords to be specified for reference-step only jobs and name and; corl_basis keywords for correlated jobs.; The following energy methods have been set up for cbs(). scf; hf; mp2; mp2.5; mp3; mp4(sdq); mp4; mpn. omp2; omp2.5; omp3; olccd; lccd; lccsd; cepa(0); cepa(1). cepa(3); acpf; aqcc; qcisd; cc2; ccsd; fno-ccsd; bccd. cc3; qcisd(t); ccsd(t); fno-ccsd(t); bccd(t); cisd; cisdt. cisdtq; cin; fci; mrccsd; mrccsd(t); mrccsdt; mrccsdt(q). Parameters:; name (string) – 'scf' || 'ccsd' || etc.; First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be 'scf'. Overruled if stage_wfn keywords supplied. scf_wfn (string) – \(\Rightarrow\) 'scf' \(\Leftarrow\) || 'c4-scf' || etc.; Indicates the energy method for which the reference energy is to be; obtained. Generally unnecessary, as ‘scf’ is the scf in PSI4 but; can be used to direct lone scf components to run in PSI4 or Cfour; in a mixed-program composite method. corl_wfn (string) – 'mp2' || 'ccsd(t)' || etc.; Indicates the energy method for which the correlation energ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/cbs-1.html:2968,energy,energy,2968,psi4manual/1.2.1/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/cbs-1.html,4,['energy'],['energy']
Energy Efficiency,"nteger; Default: 0. Expert¶. MRCC_METHOD¶. If more than one root is requested and calc=1, LR-CC (EOM-CC) calculation is performed automatically for the excited states. This overrides all automatic determination of method and will only work with energy(). This becomes CC/CI (option #5) in fort.56 | begin{tabular}{ccc} | Value & Method & Description \ | hline | 1 & CC & \ | 2 & CC(n-1)[n] & \ | 3 & CC(n-1)(n) & (CC(n-1)[n] energy is also calculated) \ | 4 & CC(n-1)(n)_L & (CC(n-1)[n] and CC(n-1)(n) energies are also calculated) \ | 5 & CC(n)-1a & \ | 6 & CC(n)-1b & \ | 7 & CCn & \ | 8 & CC(n)-3 & \ | end{tabular}. Type: integer; Default: 1. MRCC_OMP_NUM_THREADS¶. Sets the OMP_NUM_THREADS environment variable before calling MRCC. If the environment variable OMP_NUM_THREADS is set prior to calling PSI4 then that value is used. When set, this option overrides everything. Be aware the -n command-line option described in section Threading does not affect MRCC. Type: integer; Default: 1. MRCC_RESTART¶. The program restarts from the previously calculated parameters if it is 1. In case it is 2, the program executes automatically the lower-level calculations of the same type consecutively (e.g., CCSD, CCSDT, and CCSDTQ if CCSDTQ is requested) and restarts each calculation from the previous one (rest=2 is available only for energy calculations). Currently, only a value of 0 and 2 are supported. This becomes rest (option #4) in fort.56. Type: integer; Default: 0. Table Of Contents. MRCC; General; E_CONVERGENCE; INTS_TOLERANCE; MRCC_LEVEL; MRCC_NUM_SINGLET_ROOTS; MRCC_NUM_TRIPLET_ROOTS. Expert; MRCC_METHOD; MRCC_OMP_NUM_THREADS; MRCC_RESTART. Previous topic; WFN; Next topic; E_CONVERGENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Appendices »; Keywords by Module ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodir_options_c/module__mrcc-1.html:2509,energy,energy,2509,psi4manual/4.0b2/autodir_options_c/module__mrcc-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodir_options_c/module__mrcc-1.html,4,['energy'],['energy']
Energy Efficiency,"nteger; Default: 0. FRAC_VAL (SCF); SCF — The occupations of the orbital indices specified above (). Type: array; Default: No Default. FRAG_MODE (OPTKING); OPTKING — For multi-fragment molecules, treat as single bonded molecule or via interfragment coordinates. A primary difference is that in MULTI mode, the interfragment coordinates are not redundant. Type: string; Possible Values: SINGLE, MULTI; Default: SINGLE. FREEZE_CORE (GLOBALS); GLOBALS — Specifies how many core orbitals to freeze in correlated computations. TRUE will default to freezing the standard default number of core orbitals. For heavier elements, there can be some ambiguity in how many core orbitals to freeze; in such cases, SMALL picks the most conservative standard setting (freezes fewer orbitals), and LARGE picks the least conservative standard setting (freezes more orbitals). More precise control over the number of frozen orbitals can be attained by using the keywords NUM_FROZEN_DOCC (gives the total number of orbitals to freeze, program picks the lowest-energy orbitals) or FROZEN_DOCC (gives the number of orbitals to freeze per irreducible representation). Type: string; Possible Values: FALSE, TRUE, SMALL, LARGE; Default: FALSE. FREEZE_CORE (SAPT); SAPT — The scope of core orbitals to freeze in evaluation of SAPT and terms. Recommended true for all SAPT computations. Type: string; Possible Values: FALSE, TRUE, SMALL, LARGE; Default: FALSE. FREEZE_INTERFRAG (OPTKING); OPTKING — Do freeze all interfragment modes?. Type: boolean; Default: false. FREEZE_INTRAFRAG (OPTKING); OPTKING — Do freeze all fragments rigid?. Type: boolean; Default: false. FROZEN_DOCC (GLOBALS); GLOBALS — An array containing the number of frozen doubly-occupied orbitals per irrep (these are not excited in a correlated wavefunction, nor can they be optimized in MCSCF. Type: array; Default: No Default. FROZEN_DOCC (PSIMRCC); PSIMRCC — The number of frozen occupied orbitals per irrep. Type: array; Default: No Default. FROZEN_UOCC ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodoc_glossary_options_c-1.html:36610,energy,energy,36610,psi4manual/4.0b2/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodoc_glossary_options_c-1.html,4,['energy'],['energy']
Energy Efficiency,"nteger; Default: 1. ROTATE_MO_P (MCSCF); MCSCF (Expert) — For orbital rotations after convergence, number of the first orbital (1-based) to rotate. Type: integer; Default: 1. ROTATE_MO_Q (MCSCF); MCSCF (Expert) — For orbital rotations after convergence, number of the second orbital (1-based) to rotate. Type: integer; Default: 2. ROTATION_SCHEME (STABILITY); STABILITY — Method for following eigenvectors, either 0 by angles or 1 by antisymmetric matrix. Type: integer; Default: 0. RUN_CCSD (FNOCC); FNOCC (Expert) — do ccsd rather than qcisd?. Type: boolean; Default: false. RUN_CEPA (FNOCC); FNOCC (Expert) — Is this a CEPA job? This parameter is used internally by the pythond driver. Changing its value won’t have any effect on the procedure. Type: boolean; Default: false. RUN_MP2 (FNOCC); FNOCC (Expert) — do only evaluate mp2 energy?. Type: boolean; Default: false. RUN_MP3 (FNOCC); FNOCC (Expert) — do only evaluate mp3 energy?. Type: boolean; Default: false. RUN_MP4 (FNOCC); FNOCC (Expert) — do only evaluate mp4 energy?. Type: boolean; Default: false. S (DETCI); DETCI — The value of the spin quantum number is given by this option. The default is determined by the value of the multiplicity. This is used for two things: (1) determining the phase of the redundant half of the CI vector when the component is used (i.e., MS0 = TRUE), and (2) making sure the guess vector has the desired value of (if S_SQUARED is TRUE and ICORE = 1). Type: double; Default: 0.0. S_ORTHOGONALIZATION (SCF); SCF — SO orthogonalization: symmetric or canonical?. Type: string; Possible Values: SYMMETRIC, CANONICAL; Default: SYMMETRIC. S_SQUARED (DETCI); DETCI — Do calculate the value of for each root? Only supported for ICORE = 1. Type: boolean; Default: false. S_TOLERANCE (SCF); SCF — Minimum S matrix eigenvalue to be used before compensating for linear dependencies. Type: conv double; Default: 1e-7. SAD_CHOL_TOLERANCE (SCF); SCF (Expert) — SAD Guess Cholesky Cutoff (for eliminating redundancies). Ty",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodoc_glossary_options_c-1.html:114307,energy,energy,114307,psi4manual/4.0b4/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodoc_glossary_options_c-1.html,4,['energy'],['energy']
Energy Efficiency,"ntegral + occ - 1.0); energies.append(E); convs.append(C). PsiMod.set_global_option(""FRAC_START"", 2); PsiMod.set_global_option(""FRAC_LOAD"", True); PsiMod.set_global_option(""FRAC_DIIS"", frac_diis); PsiMod.set_global_option(""GUESS"", ""READ""). # Set the next charge/mult; mol.set_molecular_charge(charge) ; mol.set_multiplicity(mult). # Determine HOMO; ref = PsiMod.wavefunction(); eps_a = ref.epsilon_a(); eps_b = ref.epsilon_b(); if (Na == Nb):; HOMO = -Nb; elif (Nb == 0):; HOMO = Na; else:; E_a = eps_a[int(Na - 1)] ; E_b = eps_b[int(Nb - 1)] ; if (E_a >= E_b):; HOMO = Na; else: ; HOMO = -Nb. stats.append('\t%6d %6d %6d %6d %6d %6d\n' %(Nintegral-1, Na, Nb, charge, mult, HOMO)). if (HOMO > 0):; Na = Na - 1; else:; Nb = Nb - 1; charge = charge + 1; mult = Na - Nb + 1; ; PsiMod.set_global_option(""DF_INTS_IO"", ""NONE""). # => Print the results out <= #; E = {}; PsiMod.print_out('\n ==> Fractional Occupation Nuke Results <==\n\n'); PsiMod.print_out('\t%-11s %-24s %-24s %11s\n' %('N', 'Energy', 'HOMO Energy', 'Converged')); for k in range(len(Ns)):; PsiMod.print_out('\t%11.3E %24.16E %24.16E %11d\n' % (Ns[k], energies[k], potentials[k], convs[k])); E[Ns[k]] = energies[k]. PsiMod.print_out('\n'); PsiMod.print_out('\t%6s %6s %6s %6s %6s %6s\n' %('N', 'Na', 'Nb', 'Charge', 'Mult', 'HOMO')); for line in stats: ; PsiMod.print_out(line). PsiMod.print_out('\n\t""You shoot a nuke down a bug hole, you got a lot of dead bugs""\n'); PsiMod.print_out('\t\t\t-Starship Troopers\n'). # Drop the files out; fh = open(traverse_filename, 'w'); fh.write('\t%-11s %-24s %-24s %11s\n' %('N', 'Energy', 'HOMO Energy', 'Converged')); for k in range(len(Ns)):; fh.write('\t%11.3E %24.16E %24.16E %11d\n' % (Ns[k], energies[k], potentials[k], convs[k])); fh.close(). fh = open(stats_filename, 'w'); fh.write('\t%6s %6s %6s %6s %6s %6s\n' %('N', 'Na', 'Nb', 'Charge', 'Mult', 'HOMO')); for line in stats: ; fh.write(line); fh.close(). return E . [docs]def ip_fitting(mol, omega_l, omega_r, **kwargs):; kwargs = kwargs",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/frac.html:9914,Energy,Energy,9914,psi4manual/4.0b4/_modules/frac.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/frac.html,2,['Energy'],['Energy']
Energy Efficiency,"ntegrals S. partition(self); Partition the nuclei and electrons. plot(); Filesystem wrapper for FISAPT::plot. print_header(self); Print header, bases, sizes, etc. print_trailer(self); Print SAPT results. raw_plot(self, arg0); Plot some analysis files. scalars(self); Return the interally computed scalars (not copied). scf(self); Solve the relaxed SCF equations for A0 and B0. sinf_disp(self, arg0, psi4.core.Matrix], …); Computes the MP2-based DispE20 and Exch-DispE20 energy without S^2. unify(self); Produce unified matrices for A’, B’, and C’. vectors(self); Return the interally computed vectors (not copied). Methods Documentation. compute_energy(external_potentials=None)¶; Computes the FSAPT energy. FISAPT::compute_energy. coulomb(self: psi4.core.FISAPT) → None¶; Build the J/K potentials for C, D, and E. dHF(self: psi4.core.FISAPT) → None¶; SAPT0 delta HF. disp(self: psi4.core.FISAPT, arg0: Dict[str, psi4.core.Matrix], arg1: Dict[str, psi4.core.Vector], arg2: bool) → None¶; Computes the MP2-based DispE20 and Exch-DispE20 energy. elst(self: psi4.core.FISAPT) → None¶; SAPT0 electrostatics. exch(self: psi4.core.FISAPT) → None¶; SAPT0 exchange. fdisp(self: psi4.core.FISAPT) → None¶; F-SAPT0 dispersion. fdrop(external_potentials=None)¶; Drop output files from FSAPT calculation. FISAPT::fdrop. felst(self: psi4.core.FISAPT) → None¶; F-SAPT0 electrostatics. fexch(self: psi4.core.FISAPT) → None¶; F-SAPT0 exchange. find(self: psi4.core.FISAPT) → None¶; F-SAPT0 induction. flocalize(self: psi4.core.FISAPT) → None¶; F-SAPT0 localize. freeze_core(self: psi4.core.FISAPT) → None¶; Freeze the core orbitals. ind(self: psi4.core.FISAPT) → None¶; SAPT0 induction. kinetic(self: psi4.core.FISAPT) → None¶; Build the kinetic integrals T. localize(self: psi4.core.FISAPT) → None¶; Localize the active occupied orbitals via IBO2. matrices(self: psi4.core.FISAPT) → Dict[str, psi4.core.Matrix]¶; Return the interally computed matrices (not copied). molecule(self: psi4.core.FISAPT) → psi4.core.Molec",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.fisapt.html:2238,energy,energy,2238,psi4manual/1.4.0/api/psi4.core.fisapt.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.fisapt.html,1,['energy'],['energy']
Energy Efficiency,"ntegrals for four-virtual case is avoided. The computation is then repeated using the DC-12 functional with the same algorithms. dfrasscf-sp; 6-31G** H2O Test RASSCF Energy Point will default to only singles and doubles in the active space. opt6; Various constrained energy minimizations of HOOH with cc-pvdz RHF Internal-coordinate constraints in internal-coordinate optimizations. cdomp2-1; OMP2 cc-pVDZ energy for the H2O molecule. freq-isotope; Vibrational and thermo analysis of several water isotopologs. Demonstrates Hessian reuse for different temperatures and pressures but not for different isotopologs. cc36; CC2(RHF)/cc-pVDZ energy of H2O. cbs-delta-energy; Extrapolated energies with delta correction. dfccd1; DF-CCD cc-pVDZ energy for the H2O molecule. psimrcc-ccsd_t-1; Mk-MRCCSD(T) single point. CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. omp3-2; OMP3 cc-pVDZ energy with ROHF initial guess for the NO radical. dfomp3-2; DF-OMP3 cc-pVDZ energy for the H2O+ cation. ghosts; Density fitted MP2 cc-PVDZ/cc-pVDZ-RI computation of formic acid dimer binding energy using explicit specification of ghost atoms. This is equivalent to the dfmp2_1 sample but uses both (equivalent) specifications of ghost atoms in a manual counterpoise correction. cc26; Single-point gradient, analytic and via finite-differences of 2-1A1 state of H2O with EOM-CCSD. cbs-xtpl-freq; Various gradients for a strained helium dimer and water molecule. dft1-alt; DFT Functional Test. cc14; ROHF-CCSD/cc-pVDZ CH2 geometry optimization via analytic gradients. tu6-cp-ne2; Example potential energy surface scan and CP-correction for Ne2. mints2; A test of the basis specification. A benzene atom is defined using a ZMatrix containing dummy atoms and various basis sets are assigned to different atoms. The symmetry of the molecule is automatically lowered to account for the different basis sets. scf1; RHF cc-pVQZ energy for the BH molecule, with Cartesian input. dfomp2",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html:12613,energy,energy,12613,psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"ntegrals. PCM_enabled(self); Whether running a PCM calculation. S(self); Returns the One-electron Overlap Matrix. X(). alpha_orbital_space(self, id, basis, subset); Creates OrbitalSpace with information about the requested alpha orbital space. aotoso(self); Returns the Atomic Orbital to Symmetry Orbital transformer. array_variable(self, arg0); Returns copy of the requested (case-insensitive) Matrix QC variable. array_variables(self); Returns the dictionary of all Matrix QC variables. arrays(). Deprecated since version 1.4. atomic_point_charges(self); Returns the set atomic point charges. basis_projection(self, arg0, arg1, arg2, arg3); Projects a orbital matrix from one basis to another. basisset(self); Returns the current orbital basis. beta_orbital_space(self, arg0, arg1, arg2); docstring. build(mol[, basis]). c1_deep_copy(self, basis); Returns a new wavefunction with internal data converted to \(C_1\) symmetry, using pre-c1-constructed basis. compute(self, arg0); Computes the density-fitted EP2 energy for the input orbitals. compute_energy(self); Computes the energy of the Wavefunction. compute_gradient(self); Computes the gradient of the Wavefunction. compute_hessian(self); Computes the Hessian of the Wavefunction. deep_copy(self, arg0); Deep copies the internal data. del_array_variable(self, arg0); Removes the requested (case-insensitive) Matrix QC variable. del_potential_variable(self, arg0); Removes the requested (case-insensitive) ExternalPotential QC variable. del_scalar_variable(self, arg0); Removes the requested (case-insensitive) double QC variable. del_variable(key); Removes scalar or array QCVariable key from cls if present. density_fitted(self); Returns whether this wavefunction was obtained using density fitting or not. doccpi(self); Returns the number of doubly occupied orbitals per irrep. efzc(self); Returns the frozen-core energy. energy(self); Returns the Wavefunction's energy. epsilon_a(self); Returns the Alpha Eigenvalues. epsilon_a_subset(self,",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.core.dfep2wavefunction.html:2072,energy,energy,2072,psi4manual/1.5.0/api/psi4.core.dfep2wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.core.dfep2wavefunction.html,2,['energy'],['energy']
Energy Efficiency,"ntegrals. PCM_enabled(self); Whether running a PCM calculation. S(self); Returns the One-electron Overlap Matrix. X(). alpha_orbital_space(self, id, basis, subset); Creates OrbitalSpace with information about the requested alpha orbital space. aotoso(self); Returns the Atomic Orbital to Symmetry Orbital transformer. array_variable(self, arg0); Returns copy of the requested (case-insensitive) Matrix QC variable. array_variables(self); Returns the dictionary of all Matrix QC variables. arrays(). Deprecated since version 1.4. atomic_point_charges(self); Returns the set atomic point charges. basis_projection(self, arg0, arg1, arg2, arg3); Projects a orbital matrix from one basis to another. basisset(self); Returns the current orbital basis. beta_orbital_space(self, arg0, arg1, arg2); docstring. build(mol[, basis]). c1_deep_copy(self, basis); Returns a new wavefunction with internal data converted to \(C_1\) symmetry, using pre-c1-constructed basis. compute(self, arg0); Computes the density-fitted EP2 energy for the input orbitals. compute_energy(self); Computes the energy of the Wavefunction. compute_gradient(self); Computes the gradient of the Wavefunction. compute_hessian(self); Computes the Hessian of the Wavefunction. deep_copy(self, arg0); Deep copies the internal data. del_array_variable(self, arg0); Removes the requested (case-insensitive) Matrix QC variable. del_potential_variable(self, arg0); Removes the requested (case-insensitive) ExternalPotential QC variable. del_scalar_variable(self, arg0); Removes the requested (case-insensitive) double QC variable. del_variable(key); Removes scalar or array QCVariable key from cls if present. density_fitted(self); Returns whether this wavefunction was obtained using density fitting or not. doccpi(self); Returns the number of doubly occupied orbitals per irrep. efzc(self); Returns the frozen-core energy. energy(self); Returns the Wavefunction’s energy. epsilon_a(self); Returns the Alpha Eigenvalues. epsilon_a_subset(self,",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.dfep2wavefunction.html:2072,energy,energy,2072,psi4manual/1.4.0/api/psi4.core.dfep2wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.dfep2wavefunction.html,1,['energy'],['energy']
Energy Efficiency,"ntegrals. The solution of the Newton-Raphson equations is performed; iteratively using the preconditioned conjugate gradients method, where only the; product of the electronic Hessian with the step vector is computed for; efficiency. The electronic Hessian is build for both the cumulant and orbital; updates and both updates are performed simultaneously. By default the; electronic Hessian also contains the matrix elements that couple the orbitals; and the density cumulant. The computation of these coupling elements increases; the cost of the macroiteration, but usually leads to faster convergence and is; recommended for open-shell systems. If the computation of the coupling elements; is not desired, it can be turned off by setting QC_COUPLING to FALSE.; It is important to note that the quadratically-convergent algorithm is not yet fully; optimized and often converges slowly when the RMS of the cumulant or; the orbital gradient is below .; The choice of the iterative algorithm can significantly affect the cost of the; energy computation. While the two-step algorithm requires a small number of; disk-intensive integral transformations, the simultaneous; algorithm benefits from a smaller number of expensive ; cumulant updates. As a result, for the small closed-shell systems the two-step; algorithm is usually preferred, while for the larger systems and the molecules with the; open-shell character it is recommended to use the simultaneous algorithm. The; efficiency of the simultaneous algorithm can be greatly increased by avoiding; the transformation of the four-index virtual two-electron integrals; and computing the terms that involve these integrals in the AO; basis. In order to do that one needs to set the AO_BASIS option to; DISK. For more recommendations on the choice of the algorithm see; Recommendations section. Analytic Gradients¶; Analytic gradients are available for the DC-06 method. Gradients are only; available if the ALGORITHM option is set to TWOSTEP or SIMULT",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/dcft-1.html:8297,energy,energy,8297,psi4manual/4.0b4/dcft-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/dcft-1.html,4,['energy'],['energy']
Energy Efficiency,"nteraction energies for bimolecular complexes.; Geometries from <Reference>.; Reference interaction energies from Rezac and Hobza, JCTC (in press). cp 'off' <erase this comment and after unless on is a valid option> || 'on'; rlxd 'off' <erase this comment and after unless on is valid option> || 'on'; benchmark. '<benchmark_name>' <Reference>.; \(\Rightarrow\) '<default_benchmark_name>' \(\Leftarrow\) <Reference>. subset. 'small' <members_description>; 'large' <members_description>; '<subset>' <members_description>. BASIC¶. Database of simple molecules, mostly for testing.; Geometries from nowhere special, and no reference energies defined. cp 'off'; rlxd 'off'; subset ['h2o', 'nh3', 'ch4']. BBI¶. Database (Merz) of protein backbone-backbone interactions.; Geometries from Kenneth Merz Group, Univ. of Florida.; Reference interaction energies from Sherrill group, Georgia Tech.; Part of the BioFragment Database (BFDb). cp 'off' || 'on'; rlxd 'off'. BENCH12¶. Database of <description of members and reference energy type>.; Geometries from <Reference>.; Reference interaction energies from <Reference>. benchmark. '<benchmark_name>' <Reference>.; \(\Rightarrow\) '<default_benchmark_name>' \(\Leftarrow\) <Reference>. subset. 'small'; 'large'; 'alkenes'; 'alkanes'; 'acenes'; 'thiophenes'; 'h2o_size'; 'h2o_shape'; 'atoms'; 'S22_HB'; 'S22_MX'; 'S22_DD'. O24by5mb¶. Database (O24) of interaction energies for small open-shell high-spin bimolecular complexes.; Geometries taken from https://gitlab.com/piotr.zuchowski/o24x5/-/tree/4ec3cae0546b6ae4f4f2cf28482cd164c8323cc6.; Reference interaction energies taken from J. Chem. Phys. 154, 134106 (2021) https://doi.org/10.1063/5.0043793.; Variant with ghosted hydrogen as midbonds in the COM. no | name | subset. 1 | CN - He | DD; 2 | NH - He | DD; 3 | C2H3 - C2H4 | DD; 4 | O2 - H2 | DD; 5 | NH - Ar | DD; 6 | CN - Ar | DD; 7 | O2 - N2 | DD; 8 | H2O - O2(sp) | DD; 9 | O2 - O2 | DD. 10 | NH - NH | ED; 11 | CH2O - NH2 | ED; 12 | H2O - Na | ED; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/autodoc_available_databases.html:1195,energy,energy,1195,psi4manual/1.9.x/autodoc_available_databases.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/autodoc_available_databases.html,2,['energy'],['energy']
Energy Efficiency,"nteraction singles and doubles level of theory and root. CISD QUADRUPOLE XX¶. CISD QUADRUPOLE XY¶. CISD QUADRUPOLE XZ¶. CISD QUADRUPOLE YY¶. CISD QUADRUPOLE YZ¶. CISD QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; configuration interaction singles and doubles level of theory and root. CISD TOTAL ENERGY¶. CISD CORRELATION ENERGY¶. CISDT TOTAL ENERGY¶. CISDT CORRELATION ENERGY¶. CISDTQ CORRELATION ENERGY¶. CISDTQ TOTAL ENERGY¶. CIn CORRELATION ENERGY¶. CIn TOTAL ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled configuration interaction level of theory and root.; n is CI order for n > 4. CP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [H] considering only two-body interactions,; computed with counterpoise correction.; Related variable UNCP-CORRECTED 2-BODY INTERACTION ENERGY. \[E_{\text{IE}} = E_{dimer} - \sum_{monomer}^{n}{E_{monomer}^{\text{CP}}}\]. CURRENT CORRELATION ENERGY¶; The correlation energy [H] corresponding to the CURRENT ENERGY variable. CURRENT ENERGY¶; The total electronic energy [H] of the most recent stage of a; calculation (frequently overwritten). This is the quantity tracked by; the geometry optimizer. CURRENT REFERENCE ENERGY¶; The total electronic energy [H] of the reference stage corresponding to; the CURRENT ENERGY variable. db_name DATABASE MEAN ABSOLUTE DEVIATION¶; The mean absolute deviation [kcal mol-1] of the requested method; name from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. \[\frac{1}{n}\sum_{rxn}^{n}{| \textsf{\textsl{name}}_{rxn}-\text{REF}_{rxn} | }\]. db_name DATABASE MEAN SIGNED DEVIATION¶; The mean deviation [kcal mol-1] of the requested method name; from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. \[\frac{1}{n}\sum_{rxn}^{n}{",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/glossary_psivariables-1.html:9753,energy,energy,9753,psi4manual/1.1.0/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/glossary_psivariables-1.html,6,['energy'],['energy']
Energy Efficiency,"ntermediates; HF/cc-pVDZ many body energies of an arbitrary noble gas trimer complex Size vs cost tradeoff is rough here. cc44; Test case for some of the PSI4 out-of-core codes. The code is given only 2.0 MB of memory, which is insufficient to hold either the A1 or B2 blocks of an ovvv quantity in-core, but is sufficient to hold at least two copies of an oovv quantity in-core. oremp-grad1; integral conventional OO-REMP/cc-pVDZ engrad single points for the H2O molecule. pywrap-molecule; Check that C++ Molecule class and qcdb molecule class are reading molecule input strings identically. fci-tdm-2; BH-H2+ FCI/cc-pVDZ Transition Dipole Moment. rasci-h2o; RASCI/6-31G** H2O Energy Point. casscf-sa-sp; Example of state-averaged CASSCF for the C2 molecule see C. D. Sherrill and P. Piecuch, J. Chem. Phys. 122, 124104 (2005). props3; DF-SCF cc-pVDZ multipole moments of benzene, up to 7th order and electrostatic potentials evaluated at the nuclear coordinates. olccd3; OLCCD cc-pVDZ energy with ROHF initial guess for the NO radical. scf-level-shift-rks; SCF level shift on an RKS computation. dfccsd-t-grad1; DF-CCSD(T) cc-pVDZ gradients for the H2O molecule. cc13a; UHF-CCSD(T)/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. sapt-exch-disp-inf; SAPT0 with S^inf exch-disp20. props1; RHF STO-3G dipole moment computation, performed by applying a finite electric field and numerical differentiation. cbs-parser; mtd/basis syntax examples. pubchem1; Benzene vertical singlet-triplet energy difference computation, using the PubChem database to obtain the initial geometry, which is optimized at the HF/STO-3G level, before computing single point energies at the RHF, UHF and ROHF levels of theory. basis-ecp; check mixing ECP and non-ECP orbital/fitting basis sets in a session. dfremp-1; density fitted REMP/cc-pVDZ energies for the CO2 molecule. psithon1; Spectroscopic constants of H2, and the full ci cc-pVTZ level of theory. pywrap-alias; Test parsed and exotic calls to",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html:8318,energy,energy,8318,psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"ntial calculation involving a TIP3P water and a QM water. Gradient on the external charges is compared to gradient on the QM atoms to validate the gradient on the charges. cdoremp-energy1; Cholesky decomposed OO-REMP/cc-pVDZ energy for the H2O molecule. dfccsd-t-grad1; DF-CCSD(T) cc-pVDZ gradients for the H2O molecule. cc4a; RHF-CCSD(T) cc-pVQZ frozen-core energy of the BH molecule, with Cartesian input. This version tests the FROZEN_DOCC option explicitly. gibbs; Test Gibbs free energies at 298 K of N2, H2O, and CH4. mbis-6; MBIS calculation on H2O. psimrcc-fd-freq1; Mk-MRCCSD single point. \(^3 \Sigma ^-\) O2 state described using the Ms = 0 component of the triplet. Uses ROHF triplet orbitals. cc41; RHF-CC2-LR/cc-pVDZ optical rotation of H2O2. gauge = both, omega = (589 355 nm). scf5; Test of all different algorithms and reference types for SCF, on singlet and triplet O2, using the cc-pVTZ basis set. fci-h2o-fzcv; 6-31G H2O Test FCI Energy Point. olccd2; OLCCD cc-pVDZ energy with B3LYP initial guess for the NO radical. dct6; DCT calculation for the triplet O2 using DC-06 and DC-12. Only two-step algorithm is tested. scf-level-shift-rohf; SCF level shift on an ROHF computation. mints8; Patch of a glycine with a methyl group, to make alanine, then DF-SCF energy calculation with the cc-pVDZ basis set. cc38; RHF-CC2-LR/cc-pVDZ static polarizabilities of HOF molecule. pywrap-checkrun-rohf; This checks that all energy methods can run with a minimal input and set symmetry. pywrap-align; apply linear fragmentation algorithm to a water cluster. opt14; 6-31G(d) optimization of SF4 starting from linear bond angle that is not linear in the optimized structure but is in a symmetry plane of the molecule. pubchem2; Superficial test of PubChem interface. mints12; test roundtrip-ness of dict repr for psi4.core.Molecule and qcdb.Molecule. stability2; ROHF stability analysis check for CN with cc-pVDZ. This test corresponds to the rohf-stab test from Psi3. rasci-h2o; RASCI/6-31G** H",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html:43044,energy,energy,43044,psi4manual/master/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"ntial energy surface scan, and then the same procedure is performed using polar coordinates, converted to Cartesian coordinates. dfmp2-grad1; DF-MP2 cc-pVDZ gradients for the H2O molecule. pywrap-cbs1; Various basis set extrapolation tests. dfmp2-ecp; Ne-Xe dimer MP2 energies with ECP, with electrons correlated then frozen. scf3; File retention, docc, socc, and bond distances specified explicitly. mbis-2; MBIS calculation on OH- (Expanded Arrays). opt13; B3LYP cc-pVDZ geometry optimzation of phenylacetylene, starting from not quite linear structure updated reference due to new BraggSlater radii. cisd-h2o-clpse; 6-31G** H2O Test CISD Energy Point with subspace collapse. mbis-3; MBIS calculation on OH radical. props1; RHF STO-3G dipole moment computation, performed by applying a finite electric field and numerical differentiation. fnocc4; Test FNO-DF-CCSD(T) energy. cc42; RHF-CC2-LR/STO-3G optical rotation of (S)-methyloxirane. gauge = length, omega = (589 355 nm). cbs-xtpl-energy; Extrapolated water energies. cc8; UHF-CCSD(T) cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Z-matrix input. dft-dsd; DSD S22 Ammonia test. fsapt2; A very quick correctness test of F-SAPT (see fsapt1 for a real example). dft-dens-cut; LibXC density screening test. Tests empty, C-only, X-only and XC superfunctionals. ‘super_mix’ showcases how to use different screening values for X and C parts. SCF will fail or crash (nans) without screening!. casscf-fzc-sp; CASSCF/6-31G** energy point. isapt1; This test case shows an example of running and analyzing an FI-SAPT0/jun-cc-pvdz computation for 2,4-pentanediol (targeting the intramolecular hydrogen bond between the two hydroxyl groups). pywrap-align-chiral; testing aligner on enantiomers based on Table 1 of 10.1021/ci100219f aka J Chem Inf Model 2010 50(12) 2129-2140. cisd-sp; 6-31G** H2O Test CISD Energy Point. dft-grad-lr2; Tests CAM gradients with and without XC pieces to narrow grid error. dfccsd1; DF-CCSD cc-",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html:8536,energy,energy,8536,psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"ntial. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. PSI4 API: Linking C++ and Python; ExternalPotential. ExternalPotential¶. class psi4.core.ExternalPotential¶; Bases: pybind11_builtins.pybind11_object; Stores external potential field, computes external potential matrix; Methods Summary. addBasis(self, basis, coefs); Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self, Z, x, y, z); Add a charge Z at (x,y,z). appendCharges(self, arg0, float, float, float]]); Append a vector of charge tuples to a current ExternalPotential. clear(self); Reset the field to zero (eliminates all entries). computeExternExternInteraction(self, arg0, arg1); Compute the interaction between this potential and other external potential. computeNuclearEnergy(self, arg0); Compute the contribution to the nuclear repulsion energy for the given molecule. computePotentialMatrix(self, basis); Compute the external potential matrix in the given basis set. getCharges(self); Get the vector of charge tuples. print_out(self); Print python print helper to the outfile. setName(self, arg0); Sets the name. Methods Documentation. addBasis(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet, coefs: psi4.core.Vector) → None¶; Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self: psi4.core.ExternalPotential, Z: float, x: float, y: float, z: float) → None¶; Add a charge Z at (x,y,z). appendCharges(self: psi4.core.ExternalPotential, arg0: List[Tuple[float, float, float, float]]) → None¶; Append a vector of charge tuples to a current ExternalPotential. clear(self: psi4.core.ExternalPotential) → None¶; Reset the field to zero (eliminates all entries). computeExternExternInteraction(self: psi4.core.ExternalPotential, arg0: psi4.core.ExternalPotential, arg1: bool) → float¶; Compute the interaction between this potential and other external potential. computeNuclearEnergy(self: psi4.core.ExternalPotential, arg0: psi4.core.Molecule) → float¶; Compute t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.externalpotential.html:1027,charge,charge,1027,psi4manual/1.4.0/api/psi4.core.externalpotential.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.externalpotential.html,1,['charge'],['charge']
Energy Efficiency,"ntial/electron affinity (IP/EA) [Nooijen:1995:3629]; approaches.; The Psi4FockCI plugin allows one to perform spin-flip (SF), ionization; potential (IP), and electron affinity (EA) calculations, as well as; combined RAS-SF-IP/EA calculations, through the DETCI (CI: Configuration Interaction) module. Installation¶. Download the plugin from the GitHub repository:; >>> git clone https://github.com/shannonhouck/psi4fockci.git. Once downloaded, the plugin can be installed as follows:; >>> cd {top-level-psi4fockci-directory}; >>> python -m pip install . Sample Input¶; To run a CAS-nSF-IP/EA calculation, start with a molecule with the; correct charge and multiplicity for the reference state (i.e. some; state well-represented by a single reference). Then, run an energy; calculation, passing in the charge and multiplicity of the; desired state; the number of spin-flips and IP/EA will be automatically; determined based on this input. If additional excitations outside of the; RAS II space are desired, one can set the level of external; excitations using the conf_space keyword.; A sample input file for a RAS(h)-2SF-IP calculation is shown below:; molecule {; 0 7; N 0.0 0.0 0.0; N 0.0 0.0 1.3; symmetry c1; }. set {; basis cc-pVDZ; }. energy('psi4fockci', new_charge=1, new_multiplicity=1, conf_space=""h""). Note that for calculations involving IP/EA, inclusion of hole (for IP) and; particle (for EA) excitations is strongly recommended. Additional keywords; can be found in the documentation.; This input file can be run with Psi4:; >>> psi4 input.dat. table of contents. Psi4FockCI: A General Fock-Space CI For Spin-Flip And IP/EA; Installation; Sample Input. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Psi4FockCI: A General Fock-Space CI For Spin-Flip And IP/EA. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/plugin_psi4fockci.html:1868,energy,energy,1868,psi4manual/1.8.x/plugin_psi4fockci.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/plugin_psi4fockci.html,1,['energy'],['energy']
Energy Efficiency,"ntial/electron affinity (IP/EA) [Nooijen:1995:3629]; approaches.; The Psi4FockCI plugin allows one to perform spin-flip (SF), ionization; potential (IP), and electron affinity (EA) calculations, as well as; combined RAS-SF-IP/EA calculations, through the DETCI (CI: Configuration Interaction) module. Installation¶. Download the plugin from the GitHub repository:; >>> git clone https://github.com/shannonhouck/psi4fockci.git. Once downloaded, the plugin can be installed as follows:; >>> cd {top-level-psi4fockci-directory}; >>> python -m pip install . Sample Input¶; To run a CAS-nSF-IP/EA calculation, start with a molecule with the; correct charge and multiplicity for the reference state (i.e. some; state well-represented by a single reference). Then, run an energy; calculation, passing in the charge and multiplicity of the; desired state; the number of spin-flips and IP/EA will be automatically; determined based on this input. If additional excitations outside of the; RAS II space are desired, one can set the level of external; excitations using the conf_space keyword.; A sample input file for a RAS(h)-2SF-IP calculation is shown below:; molecule {; 0 7; N 0.0 0.0 0.0; N 0.0 0.0 1.3; symmetry c1; }. set {; basis cc-pVDZ; }. energy('psi4fockci', new_charge=1, new_multiplicity=1, conf_space=""h""). Note that for calculations involving IP/EA, inclusion of hole (for IP) and; particle (for EA) excitations is strongly recommended. Additional keywords; can be found in the documentation.; This input file can be run with Psi4:; >>> psi4 input.dat. table of contents. Psi4FockCI: A General Fock-Space CI For Spin-Flip And IP/EA; Installation; Sample Input. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Psi4FockCI: A General Fock-Space CI For Spin-Flip And IP/EA. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/plugin_psi4fockci.html:1868,energy,energy,1868,psi4manual/1.9.x/plugin_psi4fockci.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/plugin_psi4fockci.html,1,['energy'],['energy']
Energy Efficiency,"ntional or density-fitted mp2 through kwargs ; with value ‘conv-mp2’ or ‘df-mp2’, not with c-side option. As represented in the equation below, a CBS energy method is defined in four; sequential stages (scf, corl, delta, delta2) covering treatment of the; reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction. Each is activated by its; stage_wfn keyword and is only allowed if all preceding stages are active. Here, is an energy or energy extrapolation scheme, and the following also hold. A translation of this ungainly equation to example [5] below is as; follows. In words, this is a double- and triple-zeta 2-point; Helgaker-extrapolated CCSD(T) coupled-cluster correlation correction; appended to a triple- and quadruple-zeta 2-point; Helgaker-extrapolated MP2 correlation energy appended to a SCF/aug-cc-pVQZ; reference energy. Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy.; The cbs() function requires, at a minimum, name='scf' and scf_basis; keywords to be specified for reference-step only jobs and name and; corl_basis keywords for correlated jobs.; The following energy methods have been set up for cbs(). scf; df-scf; mp2. df-mp2; cc2; ccsd. bccd; cc3; ccsd(t). cisd; cisdt; cisdtq. cin; fci. Parameters:; name (string) – 'scf' || 'ccsd' || etc.; First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be 'scf'. Overruled if stage_wfn keywords supplied. corl_wfn (string) – 'mp2' || 'ccsd(t)' || etc.; Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with name or as the unlabeled; first argument to the function. delta_wfn (string) – 'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for w",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/cbs-1.html:2419,energy,energy,2419,psi4manual/4.0b3/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/cbs-1.html,2,['energy'],['energy']
Energy Efficiency,"ntities on the atomic spheres and DDX_N_LEBEDEV determines the; number of points of the Lebedev angular grid used for integration on the spheres.; DDX_N_LEBEDEV should be chosen higher than DDX_SOLUTE_SPHERICAL_POINTS; and the defaults are usually good. DDX_SOLUTE_RADIAL_POINTS¶. Number of radial points used to compute the integrals for DDX calculations. Type: integer; Default: 35. DDX_SOLUTE_SPHERICAL_POINTS¶. Number of spherical points used to compute the solute electric potential/field integrals for DDX calculations (A Lebedev Points number). Type: integer; Default: 110. DDX_LMAX¶. Maximal degree of modelling spherical harmonics. Type: integer; Default: 9. DDX_N_LEBEDEV¶. Number of Lebedev grid points to use. (A Lebedev Points number). Type: integer; Default: 302. Iterative solver parameters¶; These parameters determine how the forward and adjoint linear systems; of the solvation model are solved. Usually these parameters do not need; to be changed. Occasionally DDX_SOLVATION_CONVERGENCE might need to be adapted,; e.g. if only a very crude or a highly accurate SCF solution is targeted. DDX_DIIS_MAX_VECS¶. Number of previous iterates to use in DIIS acceleration inside DDX. Type: integer; Default: 20. DDX_MAXITER¶. Maximal number of iterations used inside DDX. Type: integer; Default: 100. DDX_SOLVATION_CONVERGENCE¶. Tolerance to which DDX linear systems are solved. Type: conv double; Default: 1e-8. Further keywords for ddx¶; These parameter should rarely require changes.; In particular DDX_ETA, DDX_SHIFT and DDX_LOGFILE; are expert parameters and should not be altered beyond debugging. DDX_ETA¶. Regularization parameter for characteristic function of sphere overlap. Advanced parameter, which usually does not need to be modified. Valid values are within the range [0, 1]. Type: double; Default: 0.1. DDX_FMM_LOCAL_LMAX¶. Maximal degree of local spherical harmonics (near-field FMM interations). Type: integer; Default: 6. DDX_FMM_MULTIPOLE_LMAX¶. Maximal degree of multip",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/ddx.html:7436,adapt,adapted,7436,psi4manual/1.7.x/ddx.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/ddx.html,4,['adapt'],['adapted']
Energy Efficiency,"ntly used by default). For more recommendations on the choice of the algorithm see; Recommendations section. Analytic Gradients¶; Analytic gradients are available for the DC-06, ODC-06, ODC-12, and ODC-13 methods.; For DC-06, the evaluation of the analytic gradients requires the solution of the; coupled response equations. Two algorithms are available for their iterative; solution: two-step (default) and simultaneous. These algorithms are similar to those; described for the orbital and cumulant updates in the Iterative Algorithms; section and usually exhibit similar efficiency. The choice of the algorithm can; be made using the RESPONSE_ALGORITHM option. For the DC-12 method the; analytic gradients are not yet available, one has to use numerical gradients to; perform the geometry optimizations. For the ODC-06, ODC-12 and ODC-13 methods no response equations; need to be solved, which makes the computation of the analytic gradients very; efficient. Analytic gradients are not available for the three-particle energy; correction . Methods Summary¶; The table below summarizes current DCFT code features:. Method; Available algorithms; Energy; Gradient; Reference. ODC-06; SIMULTANEOUS, QC; Y; Y; RHF/UHF. ODC-12; SIMULTANEOUS, QC; Y; Y; RHF/UHF. ODC-13; SIMULTANEOUS, QC; Y; Y; UHF. SIMULTANEOUS, QC; Y; N; UHF. SIMULTANEOUS, QC; Y; N; UHF. DC-06; SIMULTANEOUS, QC, TWOSTEP; Y; Y; UHF. DC-12; SIMULTANEOUS, QC, TWOSTEP; Y; N; UHF. Note that for ODC-06 and ODC-12 REFERENCE = RHF is only available for; ALGORITHM = SIMULTANEOUS. To compute correction,; the THREE_PARTICLE option needs to be set to PERTURBATIVE. Minimal Input¶; Minimal input for the DCFT single-point computation looks like this:; molecule {; H; H 1 1.0; }. set basis cc-pvdz. energy('dcft'). The energy('dcft') call to energy() executes the DCFT; module, which will first call the SCF module and perform the SCF computation; with RHF reference to obtain a guess for the DCFT orbitals. After SCF is; converged, the program w",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/dcft-1.html:11939,energy,energy,11939,psi4manual/1.0.0/dcft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/dcft-1.html,2,['energy'],['energy']
Energy Efficiency,"nto PSI4 format. Note; PSI4 only recognizes keywords by their full name, so the common; Cfour keyword abbreviations CALC, REF, etc. must be replaced by their; proper names of CFOUR_CALC_LEVEL, CFOUR_REFERENCE, etc. Whenever the molecule is supplied in PSI4 format, it is possible to; perform geometry optimizations where Cfour supplies the gradient and the; PSI4 module optking drives the structural; changes. Because of the limitations on geometry specification for; optimizations in Cfour, optking-driven optimizations are the only; optimizations allowed in the P4C4 interface. (The exception is sandwich; mode, which, of course, permits optimizations with the Cfour optimizer.); Below is an example of a geometry optimization:; memory 200 mb. molecule {; O; H 1 R; H 1 R 2 A. R=0.958; A=104.5; }. set {. cfour_CALC_level CCSD(T); cfour_BASIS DZP; cfour_CC_CONV 12; cfour_LINEQ_CONV 12; cfour_SCF_CONV 12; g_convergence cfour; }. optimize('cfour'). Note that the primary change is the exchange of energy(); for optimize() to trigger an optimization. Setting; G_CONVERGENCE=CFOUR provides a good imitation of Cfour; default convergence criteria. Although Cfour produces gradients only in; its standard orientation and atom ordering, these are transformed back to; input orientation by the P4C4 interface. Several sample inputs in; psi4/tests/cfour/ starting with opt- show basic geometry; optimizations. cfour/mints5-grad shows optimizations from a; variety of molecule input formats, and cfour/psi-ghost-grad; shows an optimization with ghosted atoms. To obtain a single gradient; sans optimization, call instead gradient().; Note that it can be convenient to monitor the progress of a geometry; optimization by grepping the tilde ~ character.; Measures of convergence in internal coordinates in au.; Criteria marked as inactive (o), active & met (*), and active & unmet ( ).; --------------------------------------------------------------------------------------------- ~; Step Total Energy Delta E",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/cfour-1.html:7068,energy,energy,7068,psi4manual/1.4.0/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/cfour-1.html,9,['energy'],['energy']
Energy Efficiency,"nto Psi4 format. Note; Psi4 only recognizes keywords by their full name, so the common; Cfour keyword abbreviations CALC, REF, etc. must be replaced by their; proper names of CFOUR_CALC_LEVEL, CFOUR_REFERENCE, etc. Whenever the molecule is supplied in Psi4 format, it is possible to; perform geometry optimizations where Cfour supplies the gradient and the; Psi4 module optking drives the structural; changes. Because of the limitations on geometry specification for; optimizations in Cfour, optking-driven optimizations are the only; optimizations allowed in the P4C4 interface. (The exception is sandwich; mode, which, of course, permits optimizations with the Cfour optimizer.); Below is an example of a geometry optimization:; memory 200 mb. molecule {; O; H 1 R; H 1 R 2 A. R=0.958; A=104.5; }. set {. cfour_CALC_level CCSD(T); cfour_BASIS DZP; cfour_CC_CONV 12; cfour_LINEQ_CONV 12; cfour_SCF_CONV 12; g_convergence cfour; }. optimize('cfour'). Note that the primary change is the exchange of energy(); for optimize() to trigger an optimization. Setting; G_CONVERGENCE=CFOUR provides a good imitation of Cfour; default convergence criteria. Although Cfour produces gradients only in; its standard orientation and atom ordering, these are transformed back to; input orientation by the P4C4 interface. Several sample inputs in; psi4/tests/cfour/ starting with opt- show basic geometry; optimizations. cfour/mints5-grad shows optimizations from a; variety of molecule input formats, and cfour/psi-ghost-grad; shows an optimization with ghosted atoms. To obtain a single gradient; sans optimization, call instead gradient().; Note that it can be convenient to monitor the progress of a geometry; optimization by grepping the tilde ~ character.; Measures of convergence in internal coordinates in au.; Criteria marked as inactive (o), active & met (*), and active & unmet ( ).; --------------------------------------------------------------------------------------------- ~; Step Total Energy Delta E",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/cfour-1.html:7081,energy,energy,7081,psi4manual/1.0.0/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/cfour-1.html,2,['energy'],['energy']
Energy Efficiency,"ntral bond angle. dfomp2-3; OMP2 cc-pVDZ energy for the H2O molecule. omp3-2; OMP3 cc-pVDZ energy with ROHF initial guess for the NO radical. ocepa3; OCEPA cc-pVDZ energy with ROHF initial guess for the NO radical. cisd-h2o+-1; 6-31G** H2O+ Test CISD Energy Point. mcscf1; ROHF 6-31G** energy of the \(^{3}B_1\) state of CH2, with Z-matrix input. The occupations are specified explicitly. dfomp2p5-grad2; DF-OMP2.5 cc-pVDZ gradients for the H2O+ cation. props3; DF-SCF cc-pVDZ multipole moments of benzene, up to 7th order and electrostatic potentials evaluated at the nuclear coordinates. scf11-freq-from-energies; Test frequencies by finite differences of energies for planar C4NH4 TS. stability1; UHF->UHF stability analysis test for BH with cc-pVDZ Test direct SCF with and without symmetry, test PK without symmetry. cc29; CCSD/cc-pVDZ optical rotation calculation (both gauges) on Cartesian H2O2. ci-property; CI/MCSCF cc-pvDZ properties for Potassium nitrate (rocket fuel!). cc37; CC2(UHF)/cc-pVDZ energy of H2O+. sapt8; SAPT0(ROHF) open-shell computation of CN - Ne interaction energy First with jun-cc-pVDZ and density fitted integrals with ROHF Then with cc-pVDZ and direct integrals, except for dispersion that is computed with cc-pVDZ-ri density fitting with ROHF. cc42; RHF-CC2-LR/STO-3G optical rotation of (S)-methyloxirane. gauge = length, omega = (589 355 nm). opt-irc-2; Compute the IRC for HCN <-> NCH interconversion at the RHF/DZP level of theory. cc3; cc3: RHF-CCSD/6-31G** H2O geometry optimization and vibrational frequency analysis by finite-differences of gradients. dft-freq; Frequencies for H2O B3LYP/6-31G* at optimized geometry. cc23; ROHF-EOM-CCSD/DZ analytic gradient lowest \(^{2}B_1\) state of H2O+ (A1 excitation). fnocc3; Test FNO-QCISD(T) computation. scf3; File retention, docc, socc, and bond distances specified explicitly. adc2; ADC/aug-cc-pVDZ on two water molecules that are distant from 1000 angstroms from each other. dfcasscf-sp; CASSCF/6-31G** energy poi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/testsuite-1.html:20430,energy,energy,20430,psi4manual/1.1.0/testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/testsuite-1.html,4,['energy'],['energy']
Energy Efficiency,"ntributions in extended systems. To activate; sieving, set the INTS_TOLERANCE keyword to your desired cutoff; (1.0E-12 is recommended for most applications). Convergence and Algorithm Defaults¶. SCF algorithm and convergence criteria defaults by calculation type [1]. Ab Initio Method; Calculation Type; E_CONVERGENCE; D_CONVERGENCE; SCF_TYPE. SCF of HF or DFT; energy; 6; 5; DF. optimization; 8; 6. frequency; 8; 6. SCF of post-HF; energy; 8; 6; PK [3]. optimization; 10; 7. frequency; 10; 7. CC property [2]; 10; 7. Footnotes. [1]Note that this table applies only the SCF module,; not to the final convergence criteria for post-HF methods or to methods; that use an alternate starting point, like MCSCF. [2]This applies to properties computed through the property() function. [3]Post-HF methods that do not rely upon the usual 4-index AO integrals use a density-; fitted SCF reference. That is, for DF-MP2 and SAPT, the default SCF_TYPE is DF. Recommendations¶; The SCF code is already quite flexible and powerful, with new features being; added weekly. We have tried as much as possible to keep the number of options to; a minimum, and to allow all options to be used in the presence of all other; options. Below are some rough words of advice about using the SCF code for; practical calculations:. For GUESS, the SAD guess is usually your; friend, even for open-shell systems (at the very least, it gets the right; number of electrons, unlike some other programs). For instance, we have found; that a simple SAD guess is often as good as doing a full SCF in a 3-21G basis; and then performing a cast-up, at a fraction of the cost. However, SAD and; DOCC/SOCC arrays do not play very well together at the moment.; For wall time, DF may be a factor of ten or more faster than the exact; integral technologies available in PSI4.; Use DF unless you need absolute accuracy or do not; have a -JKFIT auxiliary set for your primary basis/atom type. Then use; OUT_OF_CORE unless you run out of disk space.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/scf-1.html:20300,power,powerful,20300,psi4manual/4.0b3/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/scf-1.html,2,['power'],['powerful']
Energy Efficiency,"nts 1 and 2 are explicitly included in the energy computation,; with basis functions from each of fragments 1, 2, 3, & 4 included in; the basis set. Therefore, the basis functions from fragments 3 and 4; are included as ghost functions within the energy computation. OCEPA(0) TOTAL ENERGY¶. OCEPA(0) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the orbital-optimized CEPA(0) level of theory. OMP2 TOTAL ENERGY¶. OMP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the orbital-optimized MP2 level of theory. OMP3 TOTAL ENERGY¶. OMP3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the orbital-optimized MP3 level of theory. ONE-ELECTRON ENERGY¶; The one-electron energy contribution [H] to the total SCF energy.; Quantity \(E_{1e^-}\) in Eq. (4). QCISD TOTAL ENERGY¶. QCISD CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the quadratic configuration interaction singles and doubles level; of theory. QCISD(T) TOTAL ENERGY¶. QCISD(T) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the quadratic configuration interaction singles and doubles with; perturbative triples correction level of theory. SAPT DISP ENERGY¶. SAPT ELST ENERGY¶. SAPT EXCH ENERGY¶. SAPT IND ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total electronic interaction energy [H] for the the; requested SAPT level of theory. The sum of these four components yields; SAPT TOTAL ENERGY. SAPT TOTAL ENERGY¶; The total electronic interaction energy [H] for the requested SAPT; level of theory. SAPT0 TOTAL ENERGY¶. SSAPT0 TOTAL ENERGY¶. SAPT2 TOTAL ENERGY¶. SAPT2+ TOTAL ENERGY¶. SAPT2+(3) TOTAL ENERGY¶. SAPT2+3 TOTAL ENERGY¶; The total electronic interaction energy [H] for the labeled SAPT level; of theory. SAPT2+(CCD) TOTAL ENERGY¶. SAPT2+(3)",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/glossary_psivariables-1.html:17615,energy,energy,17615,psi4manual/1.2.1/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/glossary_psivariables-1.html,8,['energy'],['energy']
Energy Efficiency,"nts are set; with the COSX_INTS_TOLERANCE, COSX_DENSITY_TOLERANCE, and; COSX_BASIS_TOLERANCE keywords, respectively. COSX_INTS_TOLERANCE; is the most consequential of the three thresholds in both cost and accuracy.; This keyword determines screening of negligible one-electron integrals.; COSX_DENSITY_TOLERANCE controls the threshold for significant; shell pairs in the density matrix. Lastly, COSX_BASIS_TOLERANCE is; a cutoff for the value of basis functions at grid points. This keyword is; used to determine the radial extent of the each basis shell, and it is the; COSX analogue to DFT_BASIS_TOLERANCE.; The COSX_INCFOCK keyword (defaults to true) increases performance; by constructing the Fock matrix from differences in the density matrix, which; are more amenable to screening. Consider disabling this keyword if SCF energy; convergence issues are observed, particularly when using diffuse basis functions.; The COSX_OVERLAP_FITTING keyword (defaults to true) reduces numerical; integration errors using the method described in [Izsak:2011:144105] and is; always recommended. LinK Exchange¶. Warning; The LinK code is currently under development and should not be used. Large SCF calculations can benefit from specialized screening procedures that further reduce the scaling of the ERI contribution to the Fock matrix.; LinK, the linear-scaling exchange method described in [Ochsenfeld:1998:1663], is available with the direct SCF algorithm (SCF_TYPE set to DIRECT).; LinK achieves linear-scaling by exploiting shell pair sparsity in the density matrix and overlap sparsity between shell pairs.; This method is most competitive when used with non-diffuse orbital basis sets, since orbital and density overlaps decay slower with diffuse functions.; LinK is especially powerful when combined with density-matrix based ERI screening (set SCREENING to DENSITY) and incremental Fock builds (set INCFOCK to TRUE), which decrease the number of significant two-electron integrals to calculate.; NOTE",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/scf.html:32483,reduce,reduces,32483,psi4manual/1.6.x/scf.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/scf.html,1,['reduce'],['reduces']
Energy Efficiency,"nts for a strained helium dimer and water molecule. dft-jk; DFT JK on-disk test. cbs-xtpl-opt; Various extrapolated optimization methods for the H2 molecule. ci-multi; BH single points, checking that program can run multiple instances of DETCI in a single input, without an intervening clean() call. fd-freq-gradient-large; SCF DZ finite difference frequencies by gradients for C4NH4. soscf-ref; Triple and Singlet Oxygen energy SOSCF, also tests non-symmetric density matrices. cisd-h2o+-0; 6-31G** H2O+ Test CISD Energy Point. sapt-dft-lrc; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. serial-wfn; A simple hf/cc-pvdz water calculation. The resulting wavefunction is written to a file, and then a new wavefunction is generated from that file. The member variables of both wavefunctions should be identical in value. psimrcc-ccsd_t-4; Mk-MRCCSD(T) single point. \(^1A_1\) O$_3` state described using the Ms = 0 component of the singlet. Uses TCSCF orbitals. casscf-semi; CASSCF/6-31G** energy point. Check energy with frozen core/virtual orbs. after semicanonicalization. mp2-grad1; MP2 cc-pVDZ gradient for the H2O molecule. omp3-grad2; OMP3 cc-pVDZ gradient for the NO radical. fsapt1; This test case shows an example of running and analyzing a standard F-SAPT0/jun-cc-pvdz procedure for phenol dimer from the S22 database. extern1; External potential calculation involving a TIP3P water and a QM water. Finite different test of the gradient is performed to validate forces. cisd-h2o+-2; 6-31G** H2O+ Test CISD Energy Point. sapt1; SAPT0 cc-pVDZ computation of the ethene-ethyne interaction energy, using the cc-pVDZ-JKFIT RI basis for SCF and cc-pVDZ-RI for SAPT. Monomer geometries are specified using Cartesian coordinates. scf-upcast-custom-basis; test scf castup with custom basis sets. cc52; CCSD Response for H2O2. decontract; RHF/cc-pvdz-decontract HCl single-point energy Testing the in line -decontract option for basis sets. nbody-multi-level; Multilevel computatio",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html:3192,energy,energy,3192,psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"nts in internal-coordinate optimizations. mints-helper; A general test of the MintsHelper function. dfcasscf-sa-sp; Example of state-averaged CASSCF for the C2 molecule. ci-property; CI/MCSCF cc-pvDZ properties for Potassium nitrate (rocket fuel!). scf-upcast-custom-basis; test scf castup with custom basis sets. dct10; The multiple guesses for DCT amplitudes for ODC-12. sapt5; SAPT0 aug-cc-pVTZ computation of the charge transfer energy of the water dimer. cc34; RHF-CCSD/cc-pVDZ energy of H2O partitioned into pair energy contributions. dft-grad1; DF-BP86-D2 cc-pVDZ frozen core gradient of S22 HCN update ref gradient due to new BraggSlater radii. sapt-ecp; sapt0 of charged system in ECP basis set. cc15; RHF-B-CCD(T)/6-31G** H2O single-point energy (fzc, MO-basis \(\langle ab|cd \rangle\)). scf-freq1; Analytic vs. finite difference DF-SCF frequency test for water. cbs-xtpl-alpha; Extrapolated water energies. sapt3; SAPT2+3(CCD) aug-cc-pVDZ+midbond computation of the water dimer interaction energy, using the aug-cc-pVDZ-JKFIT DF basis for SCF and aug-cc-pVDZ-RI for SAPT. fci-tdm; He2+ FCI/cc-pVDZ Transition Dipole Moment. tu5-sapt; Example SAPT computation for ethene*ethine (i.e., ethylene*acetylene), test case 16 from the S22 database. dfmp2-3; DF-MP2 cc-pVDZ frozen core gradient of benzene, computed at the DF-SCF cc-pVDZ geometry. dct8; DCT calculation for the NH3+ radical using the ODC-12 and ODC-13 functionals. This performs both simultaneous and QC update of the orbitals and cumulant using DIIS extrapolation. Four-virtual integrals are first handled in the MO Basis for the first two energy computations. In the next computation ao_basis=disk algorithm is used, where the transformation of integrals for four-virtual case is avoided. scf-bz2; Benzene Dimer Out-of-Core HF/cc-pVDZ. casscf-semi; CASSCF/6-31G** energy point. Check energy with frozen core/virtual orbs. after semicanonicalization. scf-cholesky-basis; incremental Cholesky filtered SCF. cc47; EOM-CCSD/cc-pVDZ o",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html:22161,energy,energy,22161,psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"nts in the molecule. ptype (str) – 'energy' || 'gradient' || 'hessian'; Type of the procedure passed in. return_total_data (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); If True returns the total data (energy/gradient/Hessian) of the system,; otherwise returns interaction data. Default is 'off' for energies,; 'on' for gradients and Hessians. Note that the calculation of total; counterpoise corrected energies implies the calculation of the energies of; monomers in the monomer basis, hence specifying return_total_data = True; may carry out more computations than return_total_data = False. levels (dict) – {1: 'ccsd(t)', 2: 'mp2', 'supersystem': 'scf'} || {1: 2, 2: 'ccsd(t)', 3: 'mp2'} || etc; Dictionary of different levels of theory for different levels of expansion; Note that method_string is not used in this case. supersystem computes; all higher order n-body effects up to the number of fragments. embedding_charges (dict) – {1: [-0.834, 0.417, 0.417], ..}; Dictionary of atom-centered point charges. keys: 1-based index of fragment, values: list of charges for each fragment. charge_method (str) – scf/6-31g || b3lyp/6-31g* || etc; Method to compute point charges for monomers. Overridden by embedding_charges; if both are provided. charge_type (str) – MULLIKEN_CHARGES || LOWDIN_CHARGES; Default is MULLIKEN_CHARGES. The nbody function computes counterpoise-corrected (CP), non-CP (noCP), and Valiron-Mayer Function Counterpoise (VMFC) interaction energies for complexes composed of arbitrary numbers of monomers.; Examples :; # Counterpoise corrected CCSD(T) energies for the Helium dimer; molecule mol {; He; --; He 1 3; }; # Calculate interaction energies only (skips monomers in monomer basis):; energy('CCSD(T)', bsse_type='cp'); # Calculate interaction and total energies, return interaction energies:; energy('CCSD(T)', bsse_type=['cp','nocp']); # Calculate and return counterpoise-corrected gradient; # Useful for e.g. CP-corrected geometry optimization; gradient('CCS",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/nbody-1.html:2849,charge,charges,2849,psi4manual/1.4.0/nbody-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/nbody-1.html,4,['charge'],['charges']
Energy Efficiency,"nts it. Basis set and auxiliary basis sets are assigned by atom type. mp2-1; All-electron MP2 6-31G** geometry optimization of water. molden1; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. dct12; Spin-restricted DC-06 counterpart of dct1. ao-dfcasscf-sp; CASSCF/6-31G** energy point. mom; Maximum Overlap Method (MOM) Test. MOM is designed to stabilize SCF convergence and to target excited Slater determinants directly. cc12; Single point energies of multiple excited states with EOM-CCSD. dfccd-grad1; DF-CCSD cc-pVDZ gradients for the H2O molecule. dfomp3-1; DF-OMP3 cc-pVDZ energy for the H2O molecule. cc6; Frozen-core CCSD(T)/cc-pVDZ on C4H4N anion with disk ao algorithm. sapt-dft-api; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. cc54; CCSD dipole with user-specified basis set. dft-dens-cut; LibXC density screening test. Tests empty, C-only, X-only and XC superfunctionals. ‘super_mix’ showcases how to use different screening values for X and C parts. SCF will fail or crash (nans) without screening!. fnocc7; Test fnocc with linear dependencies. cc9; UHF-CCSD(T) cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Z-matrix input. opt3; SCF cc-pVDZ geometry optimzation, with Z-matrix input. scf7; Tests SCF gradient in the presence of a dipole field. psimrcc-sp1; Mk-MRCCSD single point. \(^3 \Sigma ^-\) O2 state described using the Ms = 0 component of the triplet. Uses ROHF triplet orbitals. olccd1; OLCCD cc-pVDZ energy for the H2O molecule. dft-psivar; HF and DFT variants single-points on zmat methane, mostly to test that PSI variables are set and computed correctly. Now also testing that CSX harvesting PSI variables correctly update ref_dft_2e/xc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html:19662,energy,energy,19662,psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"nts of the named method 64-pole [Debye Ang^5].; Deprecated in favor of mtd 64-POLE. mtd 128-POLE¶; Redundant 128-pole array [e a0^7] for the named method, (3, 3, 3, 3, 3, 3, 3). mtd 128-POLE XXXXXXX¶. mtd 128-POLE XXXXXXY¶. mtd 128-POLE ZZZZZZZ¶; The 36 components of the named method 128-pole [Debye Ang^6].; Deprecated in favor of mtd 128-POLE. MP2 TOTAL ENERGY¶. MP2 CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the MP2 level of theory. MP2 TOTAL GRADIENT¶. The total electronic gradient [E_h/a0] of the MP2 level of theory, ({nat}, 3).¶. MP2 DIPOLE GRADIENT¶; The derivative of the MP2 level of theory dipole [E_h a0/u] = [(e a0/a0)^2/u] with respect to nuclear perturbations; as a degree-of-freedom by dipole component array, (3 * {nat}, 3). MP2 TOTAL HESSIAN¶; The total electronic second derivative [Eh/a0/a0] for the MP2 level of theory, (3 * {nat}, 3 * {nat}). MP2.5 TOTAL ENERGY¶. MP2.5 CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the MP2.5 level of theory. MP3 TOTAL ENERGY¶. MP3 CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the MP3 level of theory. MP4(T) CORRECTION ENERGY¶; The MP4 triples component [Eh]. Quantity is second right-hand term in; Eq. (2). MP4(SDQ) TOTAL ENERGY¶. MP4(SDQ) CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the MP4 singles, doubles, quadruples level of theory. Quantity; MP4(SDQ) CORRELATION ENERGY is; first right-hand term in Eq. (2). MP4 TOTAL ENERGY¶. MP4 CORRELATION ENERGY¶. MP4(SDTQ) TOTAL ENERGY¶. MP4(SDTQ) CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the full MP4 level of theory. Quantity MP4 CORRELATION; ENERGY / MP4(SDTQ) CORRELATION ENERGY; is left-hand term in Eq. (2). (2)¶\[E_{\text{MP4}} = E_{\text{MP4(SDQ)}} + E_{\text{MP4(T)}}\]. MPn TOTAL ENERGY¶. MPn CORRELATION ENERGY¶; The t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html:28248,energy,energy,28248,psi4manual/1.4.0/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html,8,['energy'],['energy']
Energy Efficiency,"nts of the quadrupole [Debye Ang] for the requested; coupled cluster level of theory and root. CCSD TOTAL ENERGY¶. CCSD CORRELATION ENERGY¶. CCSDT TOTAL ENERGY¶. CCSDT CORRELATION ENERGY¶. CCSDTQ TOTAL ENERGY¶. CCSDTQ CORRELATION ENERGY¶. CCn TOTAL ENERGY¶. CCn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested full coupled-cluster (CCSD, CCSDT, up to CCn); level of theory. CCSD(T) TOTAL ENERGY¶. CCSD(T) CORRELATION ENERGY¶. CCSDT(Q) TOTAL ENERGY¶. CCSDT(Q) CORRELATION ENERGY¶. CC(n-1)(n) TOTAL ENERGY¶. CC(n-1)(n) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the perturbatively corrected coupled-cluster (CCSD(T), CCSDT(Q),; up to CC(n-1)(n) level of theory. CCSDT-1a TOTAL ENERGY¶. CCSDT-1a CORRELATION ENERGY¶. CCSDTQ-1a TOTAL ENERGY¶. CCSDTQ-1a CORRELATION ENERGY¶. CCn-1a TOTAL ENERGY¶. CCn-1a CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the approximate coupled-cluster (CCSD(T)-1a, CCSDT(Q)-1a,; up to CCn-1a) level of theory. CCSDT-1b TOTAL ENERGY¶. CCSDT-1b CORRELATION ENERGY¶. CCSDTQ-1b TOTAL ENERGY¶. CCSDTQ-1b CORRELATION ENERGY¶. CCn-1b TOTAL ENERGY¶. CCn-1b CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the approximate coupled-cluster (CCSD(T)-1b, CCSDT(Q)-1b,; up to CCn-1b) level of theory. CCSDT-3 TOTAL ENERGY¶. CCSDT-3 CORRELATION ENERGY¶. CCSDTQ-3 TOTAL ENERGY¶. CCSDTQ-3 CORRELATION ENERGY¶. CCn-3 TOTAL ENERGY¶. CCn-3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the approximate coupled-cluster (CCSD(T)-3, CCSDT(Q)-3,; up to CCn-3) level of theory. CCSD(T)_L TOTAL ENERGY¶. CCSD(T)_L CORRELATION ENERGY¶. CCSDT(Q)_L TOTAL ENERGY¶. CCSDT(Q)_L CORRELATION ENERGY¶. CC(n-1)(n)_L TOTAL ENERGY¶. CC(n-1)(n)_L CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the approximat",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html:3821,energy,energy,3821,psi4manual/4.0b3/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html,8,['energy'],['energy']
Energy Efficiency,"nts yields; the SAPT Level TOTAL ENERGY. SAPT0 TOTAL ENERGY¶. SSAPT0 TOTAL ENERGY¶. SAPT2 TOTAL ENERGY¶. SAPT2+ TOTAL ENERGY¶. SAPT2+(3) TOTAL ENERGY¶. SAPT2+3 TOTAL ENERGY¶; The total electronic interaction energy [Eh] for the labeled SAPT level; of theory. SAPT2+(CCD) DISP ENERGY¶. SAPT2+(CCD) ELST ENERGY¶. SAPT2+(CCD) EXCH ENERGY¶. SAPT2+(CCD) IND ENERGY¶. SAPT2+(3)(CCD) DISP ENERGY¶. SAPT2+(3)(CCD) ELST ENERGY¶. SAPT2+(3)(CCD) EXCH ENERGY¶. SAPT2+(3)(CCD) IND ENERGY¶. SAPT2+3(CCD) DISP ENERGY¶. SAPT2+3(CCD) ELST ENERGY¶. SAPT2+3(CCD) EXCH ENERGY¶. SAPT2+3(CCD) IND ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total electronic interaction energy [Eh] for the; given SAPT level of theory that incorporates coupled-cluster dispersion.; The sum of these four components yields the SAPT Level TOTAL ENERGY. SAPT2+(CCD) TOTAL ENERGY¶. SAPT2+(3)(CCD) TOTAL ENERGY¶. SAPT2+3(CCD) TOTAL ENERGY¶; The total electronic interaction energy [Eh] for the labeled SAPT level; of theory that incorporates coupled-cluster dispersion. SAPT2+DMP2 DISP ENERGY¶. SAPT2+DMP2 ELST ENERGY¶. SAPT2+DMP2 EXCH ENERGY¶. SAPT2+DMP2 IND ENERGY¶. SAPT2+(3)DMP2 DISP ENERGY¶. SAPT2+(3)DMP2 ELST ENERGY¶. SAPT2+(3)DMP2 EXCH ENERGY¶. SAPT2+(3)DMP2 IND ENERGY¶. SAPT2+3DMP2 DISP ENERGY¶. SAPT2+3DMP2 ELST ENERGY¶. SAPT2+3DMP2 EXCH ENERGY¶. SAPT2+3DMP2 IND ENERGY¶. SAPT2+(CCD)DMP2 DISP ENERGY¶. SAPT2+(CCD)DMP2 ELST ENERGY¶. SAPT2+(CCD)DMP2 EXCH ENERGY¶. SAPT2+(CCD)DMP2 IND ENERGY¶. SAPT2+(3)(CCD)DMP2 DISP ENERGY¶. SAPT2+(3)(CCD)DMP2 ELST ENERGY¶. SAPT2+(3)(CCD)DMP2 EXCH ENERGY¶. SAPT2+(3)(CCD)DMP2 IND ENERGY¶. SAPT2+3(CCD)DMP2 DISP ENERGY¶. SAPT2+3(CCD)DMP2 ELST ENERGY¶. SAPT2+3(CCD)DMP2 EXCH ENERGY¶. SAPT2+3(CCD)DMP2 IND ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total electronic interaction energy [Eh] for the; given SAPT level of theory that incorporates MP2 induction correction.; The sum of these four co",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html:40795,energy,energy,40795,psi4manual/1.4.0/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html,5,['energy'],['energy']
Energy Efficiency,"nts):; # Print information to output.dat; PsiMod.print_out('\n'); banner('Loading displacement %d of %d' % (n + 1, ndisp)). # Print information to the screen; print(' %d' % (n + 1), end=""""); if (n + 1) == ndisp:; print('\n', end=''); sys.stdout.flush(). # Load in displacement into the active molecule; molecule.set_geometry(displacement). # Perform the energy calculation; E = func(lowername, **kwargs). # Save the energy; energies.append(E). # clean may be necessary when changing irreps of displacements; PsiMod.clean(). # Obtain the gradient. This function stores the gradient in the wavefunction.; PsiMod.fd_freq_0(energies, irrep). print(' Computation complete.'). # Clear the ""parent"" symmetry now; PsiMod.set_parent_symmetry(""""). # TODO: These need to be restored to the user specified setting; PsiMod.get_active_molecule().fix_orientation(False); # But not this one, it always goes back to True; PsiMod.get_active_molecule().reinterpret_coordentry(True). # The last item in the list is the reference energy, return it; optstash.restore(). # Clear the ""parent"" symmetry now; PsiMod.set_parent_symmetry(""""). # call thermo module; PsiMod.thermo(). optstash.restore(); return energies[-1]. ## Aliases ##; frequencies = frequency; freq = frequency. # hessian to be changed later to compute force constants; [docs]def hessian(name, **kwargs):; r""""""Function to compute force constants. Presently identical to frequency().""""""; lowername = name.lower(); kwargs = kwargs_lower(kwargs); frequencies(name, **kwargs). [docs]def molden(filename):; """"""Function to write wavefunction information in molden; format to *filename*. """"""; m = PsiMod.MoldenWriter(PsiMod.wavefunction()); m.write(filename). [docs]def parse_cotton_irreps(irrep):; r""""""Function to return validated Cotton ordering index from string or integer; irreducible representation *irrep*. """"""; cotton = {; 'c1': {; 'a': 1,; '1': 1; },; 'ci': {; 'ag': 1,; 'au': 2,; '1': 1,; '2': 2; },; 'c2': {; 'a': 1,; 'b': 2,; '1': 1,; '2': 2; },; 'cs': {",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/driver.html:67307,energy,energy,67307,psi4manual/4.0b4/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/driver.html,2,['energy'],['energy']
Energy Efficiency,"nts, and spectroscopic intensities,; such as oscillator strengths and rotatory strengths [Pedersen1995-du], [Lestrange2015-xn].; For example, PSI4 will compute compute oscillator strengths from; the MO basis electric dipole moment integrals, \(\mathbf{\mu}_{u}\), and the right; excitation vectors, \(|\mathbf{X}_{n}+\mathbf{Y}_{n}\rangle\):. \[f = \frac{2}{3} \omega_{n} \sum_{u=x,y,z}\sum_{ia}|(\mathbf{X}_{n}+\mathbf{Y}_{n})_{ia}\mu_{ai, u}|^{2}.\]. Psithon keywords¶. TDSCF_STATES¶. Number of roots (excited states) we should seek to converge. This can be either an integer (total number of states to seek) or a list (number of states per irrep). The latter is only valid if the system has symmetry. Furthermore, the total number of states will be redistributed among irreps when symmetry is used. Type: array; Default: No Default. TDSCF_TRIPLETS¶. Controls inclusion of triplet states, which is only valid for restricted references. Valid options: - none : No triplets computed (default) - also : lowest-energy triplets and singlets included, in 50-50 ratio. Note that singlets are privileged, i.e. if seeking to converge 5 states in total, 3 will be singlets and 2 will be triplets. - only : Only triplet states computed. Type: string; Possible Values: NONE, ALSO, ONLY; Default: NONE. TDSCF_TDA¶. Run with Tamm-Dancoff approximation (TDA), uses random-phase approximation (RPA) when false. Type: boolean; Default: false. TDSCF_R_CONVERGENCE¶. Convergence threshold for the norm of the residual vector. If unset, default based on D_CONVERGENCE. Type: conv double; Default: 1e-4. TDSCF_MAXITER¶. Maximum number of TDSCF solver iterations. Type: integer; Default: 60. TDSCF_GUESS¶. Guess type, only ‘denominators’ currently supported. Type: string; Default: DENOMINATORS. TDSCF_PRINT¶. Verbosity level in TDSCF. Type: integer; Default: 1. PsiAPI usage¶; The TDSCF functionality is also accessible from PsiAPI. The example calculation shown above can be carried out as follows:; import psi4. from ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/tdscf-1.html:9077,energy,energy,9077,psi4manual/1.4.0/tdscf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/tdscf-1.html,4,['energy'],['energy']
Energy Efficiency,"nts, and spectroscopic intensities,; such as oscillator strengths and rotatory strengths [Pedersen1995-du], [Lestrange2015-xn].; For example, PSI4 will compute compute oscillator strengths from; the MO basis electric dipole moment integrals, \(\mathbf{\mu}_{u}\), and the right; excitation vectors, \(|\mathbf{X}_{n}+\mathbf{Y}_{n}\rangle\):. \[f = \frac{2}{3} \omega_{n} \sum_{u=x,y,z}\sum_{ia}|(\mathbf{X}_{n}+\mathbf{Y}_{n})_{ia}\mu_{ai, u}|^{2}.\]. Psithon keywords¶. TDSCF_STATES¶. Number of roots (excited states) we should seek to converge. This can be either an integer (total number of states to seek) or a list (number of states per irrep). The latter is only valid if the system has symmetry. Furthermore, the total number of states will be redistributed among irreps when symmetry is used. Type: array; Default: No Default. TDSCF_TRIPLETS¶. Controls inclusion of triplet states, which is only valid for restricted references. Valid options: - none : No triplets computed (default) - also : lowest-energy triplets and singlets included, in 50-50 ratio. Note that singlets are privileged, i.e. if seeking to converge 5 states in total, 3 will be singlets and 2 will be triplets. - only : Only triplet states computed. Type: string; Possible Values: NONE, ALSO, ONLY; Default: NONE. TDSCF_TDA¶. Run with Tamm-Dancoff approximation (TDA), uses random-phase approximation (RPA) when false. Type: boolean; Default: false. TDSCF_R_CONVERGENCE¶. Convergence threshold for the norm of the residual vector. If unset, default based on D_CONVERGENCE. Type: conv double; Default: 1e-4. TDSCF_MAXITER¶. Maximum number of TDSCF solver iterations. Type: integer; Default: 60. TDSCF_GUESS¶. Guess type, only ‘denominators’ currently supported. Type: string; Default: DENOMINATORS. TDSCF_PRINT¶. Verbosity level in TDSCF. Type: integer; Default: 1. TDSCF_COEFF_CUTOFF¶. Cutoff for printing excitations and de-excitations contributing to each excited state. Type: double; Default: 0.1. TDSCF_TDM_PRINT¶. Whi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/tdscf.html:9077,energy,energy,9077,psi4manual/1.7.x/tdscf.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/tdscf.html,4,['energy'],['energy']
Energy Efficiency,"nts, and spectroscopic intensities,; such as oscillator strengths and rotatory strengths [Pedersen1995-du], [Lestrange2015-xn].; For example, PSI4 will compute compute oscillator strengths from; the MO basis electric dipole moment integrals, \(\mathbf{\mu}_{u}\), and the right; excitation vectors, \(|\mathbf{X}_{n}+\mathbf{Y}_{n}\rangle\):. \[f = \frac{2}{3} \omega_{n} \sum_{u=x,y,z}\sum_{ia}|(\mathbf{X}_{n}+\mathbf{Y}_{n})_{ia}\mu_{ai, u}|^{2}.\]. Psithon keywords¶. TDSCF_STATES¶. Number of roots (excited states) we should seek to converge. This can be either an integer (total number of states to seek) or a list (number of states per irrep). The latter is only valid if the system has symmetry. Furthermore, the total number of states will be redistributed among irreps when symmetry is used. Type: array; Default: No Default. TDSCF_TRIPLETS¶. Controls inclusion of triplet states, which is only valid for restricted references. Valid options: - none : No triplets computed (default) - also : lowest-energy triplets and singlets included, in 50-50 ratio. Note that singlets are privileged, i.e. if seeking to converge 5 states in total, 3 will be singlets and 2 will be triplets. - only : Only triplet states computed. Type: string; Possible Values: NONE, ALSO, ONLY; Default: NONE. TDSCF_TDA¶. Run with Tamm-Dancoff approximation (TDA), uses random-phase approximation (RPA) when false. Type: boolean; Default: false. TDSCF_R_CONVERGENCE¶. Convergence threshold for the norm of the residual vector. If unset, default based on D_CONVERGENCE. Type: conv double; Default: 1e-4. TDSCF_MAXITER¶. Maximum number of TDSCF solver iterations. Type: integer; Default: 60. TDSCF_GUESS¶. Guess type, only ‘denominators’ currently supported. Type: string; Default: DENOMINATORS. TDSCF_PRINT¶. Verbosity level in TDSCF. Type: integer; Default: 1. TDSCF_COEFF_CUTOFF¶. Cutoff for printing excitations and de-excitations icontributing to each excited state. Type: double; Default: 0.1. TDSCF_TDM_PRINT¶. Wh",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/tdscf.html:9077,energy,energy,9077,psi4manual/1.6.x/tdscf.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/tdscf.html,1,['energy'],['energy']
Energy Efficiency,"nts."",; ""default"": -1,; ""type"": ""integer""; },; ""nbodies_per_mc_level"": {; ""title"": ""Nbodies Per Mc Level"",; ""description"": ""Distribution of active n-body levels among model chemistry levels. All bodies in range [1, self.max_nbody] must be present exactly once. Number of items in outer list is how many different modelchems. Each inner list specifies what n-bodies to be run at the corresponding modelchem (e.g., `[[1, 2]]` has max_nbody=2 and 1-body and 2-body contributions computed at the same level of theory; `[[1], [2]]` has max_nbody=2 and 1-body and 2-body contributions computed at different levels of theory. An entry 'supersystem' means all higher order n-body effects up to the number of fragments. The n-body levels are effectively sorted in the outer list, and any 'supersystem' element is at the end."",; ""default"": [],; ""type"": ""array"",; ""items"": {; ""type"": ""array"",; ""items"": {; ""anyOf"": [; {; ""type"": ""integer""; },; {; ""enum"": [; ""supersystem""; ],; ""type"": ""string""; }; ]; }; }; },; ""embedding_charges"": {; ""title"": ""Embedding Charges"",; ""description"": ""Atom-centered point charges to be used on molecule fragments whose basis sets are not included in the computation. Keys: 1-based index of fragment. Values: list of atom charges for that fragment."",; ""default"": {},; ""type"": ""object"",; ""additionalProperties"": {; ""type"": ""array"",; ""items"": {; ""type"": ""number""; }; }; },; ""return_total_data"": {; ""title"": ""Return Total Data"",; ""description"": ""When True, returns the total data (energy/gradient/Hessian) of the system, otherwise returns interaction data. Default is False for energies, True for gradients and Hessians. Note that the calculation of total counterpoise corrected energies implies the calculation of the energies of monomers in the monomer basis, hence specifying ``return_total_data = True`` may carry out more computations than ``return_total_data = False``."",; ""type"": ""boolean""; },; ""quiet"": {; ""title"": ""Quiet"",; ""description"": ""Whether to print/log formatted n-bod",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/nbody.html:6353,charge,charges,6353,psi4manual/1.7.x/nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/nbody.html,4,['charge'],['charges']
Energy Efficiency,"nts.; Relies upon van der Waals radii and so faulty for close; (esp. hydrogen-bonded) fragments. Original code from; Michael S. Marshall. Z(self: psi4.core.Molecule, arg0: int) → float; Nuclear charge of atom arg1 (0-indexed). activate_all_fragments(self: psi4.core.Molecule) → None; Sets all fragments in the molecule to be active. add_atom(self: psi4.core.Molecule, arg0: int, arg1: float, arg2: float, arg3: float, arg4: str, arg5: float, arg6: float, arg7: int) → None; Adds to Molecule arg0 an atom with atomic number arg1, Cartesian coordinates in Bohr (arg2, arg3, arg4), atomic symbol arg5, mass arg6, charge arg7 (optional), and lineno arg8 (optional). atom_at_position(self: psi4.core.Molecule, arg0: float, arg1: float) → int; Tests to see if an atom is at the position arg2 with a given tolerance arg3. center_of_mass(self: psi4.core.Molecule) → psi4.core.Vector3; Computes center of mass of molecule (does not translate molecule). charge(self: psi4.core.Molecule, arg0: int) → float; Gets charge of atom arg1 (0-indexed). clone(self: psi4.core.Molecule) → psi4.core.Molecule; Returns a new Molecule identical to arg0. create_molecule_from_string(arg0: str) → psi4.core.Molecule; Returns a new Molecule with member data from the geometry string arg0 in Psi4 format. create_psi4_string_from_molecule(self: psi4.core.Molecule) → str; Gets a string reexpressing in input format the current states of the molecule. deactivate_all_fragments(self: psi4.core.Molecule) → None; Sets all fragments in the molecule to be inactive. distance_matrix(self: psi4.core.Molecule) → psi4.core.Matrix; Returns Matrix of interatom distances. extract_subsets(*args, **kwargs); Overloaded function. extract_subsets(self: psi4.core.Molecule, arg0: list, arg1: list) -> psi4.core.Molecule. Returns copy of arg1 with arg2 fragments Real and arg3 fragments Ghost. extract_subsets(self: psi4.core.Molecule, arg0: list, arg1: int) -> psi4.core.Molecule. Returns copy of arg1 with arg2 fragments Real and arg3 fragment",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html:21502,charge,charge,21502,psi4manual/1.1.0/api/psi4.core.molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html,1,['charge'],['charge']
Energy Efficiency,"nual counterpoise correction. mints-helper; A general test of the MintsHelper function. sapt3; SAPT2+3(CCD) aug-cc-pVDZ+midbond computation of the water dimer interaction energy, using the aug-cc-pVDZ-JKFIT DF basis for SCF and aug-cc-pVDZ-RI for SAPT. mints4; A demonstration of mixed Cartesian/ZMatrix geometry specification, using variables, for the benzene-hydronium complex. Atoms can be placed using ZMatrix coordinates, whether they belong to the same fragment or not. Note that the Cartesian specification must come before the ZMatrix entries because the former define absolute positions, while the latter are relative. tu4-h2o-freq; Optimization followed by frequencies H2O HF/cc-pVDZ. cbs-parser; mtd/basis syntax examples. dft-reference; MP2 with a PBE0 reference computation. mp2p5-grad1; MP2.5 cc-pVDZ gradient for the H2O molecule. dfmp2-grad3; DF-MP2 cc-pVDZ gradients for the H2O molecule. dfomp2p5-1; DF-OMP2.5 cc-pVDZ energy for the H2O molecule. omp3-3; OMP3 cc-pVDZ energy with B3LYP initial guess for the NO radical. dfomp3-2; DF-OMP3 cc-pVDZ energy for the H2O+ cation. pubchem1; Benzene vertical singlet-triplet energy difference computation, using the PubChem database to obtain the initial geometry, which is optimized at the HF/STO-3G level, before computing single point energies at the RHF, UHF and ROHF levels of theory. opt2; SCF DZ allene geometry optimization, with Cartesian input, first in c2v symmetry, then in Cs symmetry from a starting point with a non-linear central bond angle. dfomp2-3; OMP2 cc-pVDZ energy for the H2O molecule. omp3-2; OMP3 cc-pVDZ energy with ROHF initial guess for the NO radical. ocepa3; OCEPA cc-pVDZ energy with ROHF initial guess for the NO radical. cisd-h2o+-1; 6-31G** H2O+ Test CISD Energy Point. mcscf1; ROHF 6-31G** energy of the \(^{3}B_1\) state of CH2, with Z-matrix input. The occupations are specified explicitly. dfomp2p5-grad2; DF-OMP2.5 cc-pVDZ gradients for the H2O+ cation. freq-isotope2; Vibrational and thermo analysis ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html:20681,energy,energy,20681,psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,8,['energy'],['energy']
Energy Efficiency,"nual will provide only an elementary introduction to the most; important keywords. Additional information is available in the complete; list of keywords for DETCI provided in Appendix DETCI.; For single-reference CI computations, the easiest way to invoke a CI; computation with DETCI is simply to call energy(), optimize(), etc.,; with the common name for that CI wavefunction, like energy('cisd'); for a CISD single-point energy. The Python driver; recognizes cisd, cisdt, and cisdtq. As mentioned above, codes; written specifically for CISD will be more efficient than DETCI for a; CISD computation, and energy('cisd') by default will call other,; more efficient modules. To force a CISD computation with DETCI,; set QC_MODULE = DETCI.; Higher order single-reference CI wavefunctions, like those including singles through; 6-fold excitations, can be invoked using numbers, like ci6. A full; CI can be specified by fci. More complicated CI computations, like; RASCI, can be performed by setting the appropriate keywords and calling the; module generically like energy('detci'). The latter approach; will also work for any of the previously-mentioned CI wavefunctions for; which the driver has built-in shortcuts, so long as the relevant options; (especially EX_LEVEL) are set appropriately. Some; examples of single-refence CI, RASCI, and full CI computations are provided; in psi4/samples. Orbital spaces for CI computations¶. CI (e.g., CISD, FCI); RASCI; CASCI. FROZEN_UOCC; FROZEN_UOCC; FROZEN_UOCC 1. (all orbitals not in; FROZEN_UOCC; or FROZEN_DOCC; are included in CI); RAS4; ACTIVE. RAS3. RAS2. RAS1. FROZEN_DOCC; FROZEN_DOCC; FROZEN_DOCC. 1; FROZEN_UOCC is not required and will be inferred if; ACTIVE is provided. However, if it is easier to specify; FROZEN_UOCC, then this may be provided and ACTIVE can; be inferred. The table above shows the relevant orbitals spaces for CI computations (an; analogous table for MCSCF is also available).; The third column of the; table refers to CASCI",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/detci-1.html:5472,energy,energy,5472,psi4manual/1.4.0/detci-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/detci-1.html,5,['energy'],['energy']
Energy Efficiency,"nual will provide only an elementary introduction to the most; important keywords. Additional information is available in the complete; list of keywords for DETCI provided in Appendix DETCI.; For single-reference CI computations, the easiest way to invoke a CI; computation with DETCI is simply to call energy(), optimize(), etc.,; with the common name for that CI wavefunction, like energy('cisd'); for a CISD single-point energy. The Python driver; recognizes cisd, cisdt, and cisdtq. As mentioned above, codes; written specifically for CISD will be more efficient than DETCI for a; CISD computation, and energy('cisd') by default will call other,; more efficient modules. To force a CISD computation with DETCI,; set QC_MODULE = DETCI.; Higher order single-reference CI wavefunctions, like those including singles through; 6-fold excitations, can be invoked using numbers, like ci6. A full; CI can be specified by fci. More complicated CI computations, like; RASCI, can be performed by setting the appropriate keywords and calling the; module generically like energy('detci'). The latter approach; will also work for any of the previously-mentioned CI wavefunctions for; which the driver has built-in shortcuts, so long as the relevant options; (especially EX_LEVEL) are set appropriately. Some; examples of single-refence CI, RASCI, and full CI computations are provided; in psi4/samples. Orbital spaces for CI computations¶. CI (e.g., CISD, FCI); RASCI; CASCI. FROZEN_UOCC; FROZEN_UOCC; FROZEN_UOCC [1]. (all orbitals not in; FROZEN_UOCC; or FROZEN_DOCC; are included in CI); RAS4; ACTIVE. RAS3. RAS2. RAS1. FROZEN_DOCC; FROZEN_DOCC; FROZEN_DOCC. [1]; FROZEN_UOCC is not required and will be inferred if; ACTIVE is provided. However, if it is easier to specify; FROZEN_UOCC, then this may be provided and ACTIVE can; be inferred. The table above shows the relevant orbitals spaces for CI computations (an; analogous table for MCSCF is also available).; The third column of the; table refers to C",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/detci.html:5472,energy,energy,5472,psi4manual/1.7.x/detci.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/detci.html,4,['energy'],['energy']
Energy Efficiency,"nual]. c4-scf; Hartree–Fock (HF). c4-mp2; 2nd-order Møller–Plesset perturbation theory (non-density-fitting) (MP2). c4-mp3; 3rd-order Møller–Plesset perturbation theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). table of contents. optimize; optimize(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. PSI4 API: Linking C++ and Python; optimize. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/api/psi4.driver.optimize.html:17080,energy,energy,17080,psi4manual/master/api/psi4.driver.optimize.html,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.driver.optimize.html,4,['energy'],['energy']
Energy Efficiency,"nual]. ccenergy; expert full control over ccenergy module. dfocc; expert full control over dfocc module. cisd; configuration interaction (CI) singles and doubles (CISD) [manual] [details]. fno-cisd; CISD with frozen natural orbitals [manual]. cisdt; CI singles, doubles, and triples (CISDT) [manual]. cisdtq; CI singles, doubles, triples, and quadruples (CISDTQ) [manual]. cin; nth-order CI [manual]. fci; full configuration interaction (FCI) [manual]. detci; expert full control over detci module. casscf; complete active space self consistent field (CASSCF) [manual]. rasscf; restricted active space self consistent field (RASSCF) [manual]. mcscf; multiconfigurational self consistent field (SCF) [manual]. psimrcc; Mukherjee multireference coupled cluster (Mk-MRCC) [manual]. dmrg-scf; density matrix renormalization group SCF [manual]. dmrg-caspt2; density matrix renormalization group CASPT2 [manual]. dmrg-ci; density matrix renormalization group CI [manual]. sapt0; 0th-order symmetry adapted perturbation theory (SAPT) [manual]. ssapt0; 0th-order SAPT with special exchange scaling [manual]. fisapt0; 0th-order functional and/or intramolecular SAPT [manual]. sapt2; 2nd-order SAPT, traditional definition [manual]. sapt2+; SAPT including all 2nd-order terms [manual]. sapt2+(3); SAPT including perturbative triples [manual]. sapt2+3; SAPT including all 3rd-order terms [manual]. sapt2+(ccd); SAPT2+ with CC-based dispersion [manual]. sapt2+(3)(ccd); SAPT2+(3) with CC-based dispersion [manual]. sapt2+3(ccd); SAPT2+3 with CC-based dispersion [manual]. sapt2+dmp2; SAPT including all 2nd-order terms and MP2 correction [manual]. sapt2+(3)dmp2; SAPT including perturbative triples and MP2 correction [manual]. sapt2+3dmp2; SAPT including all 3rd-order terms and MP2 correction [manual]. sapt2+(ccd)dmp2; SAPT2+ with CC-based dispersion and MP2 correction [manual]. sapt2+(3)(ccd)dmp2; SAPT2+(3) with CC-based dispersion and MP2 correction [manual]. sapt2+3(ccd)dmp2; SAPT2+3 with CC-based disper",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/energy.html:5632,adapt,adapted,5632,psi4manual/1.1.0/energy.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/energy.html,26,['adapt'],['adapted']
Energy Efficiency,"nual]. ccenergy; expert full control over ccenergy module. dfocc; expert full control over dfocc module. cisd; configuration interaction (CI) singles and doubles (CISD) [manual] [details]. fno-cisd; CISD with frozen natural orbitals [manual]. cisdt; CI singles, doubles, and triples (CISDT) [manual]. cisdtq; CI singles, doubles, triples, and quadruples (CISDTQ) [manual]. cin; nth-order CI [manual]. fci; full configuration interaction (FCI) [manual]. detci; expert full control over detci module. casscf; complete active space self consistent field (CASSCF) [manual]. rasscf; restricted active space self consistent field (RASSCF) [manual]. mcscf; multiconfigurational self consistent field (SCF) [manual]. psimrcc; Mukherjee multireference coupled cluster (Mk-MRCC) [manual]. dmrg-scf; density matrix renormalization group SCF [manual]. dmrg-caspt2; density matrix renormalization group CASPT2 [manual]. dmrg-ci; density matrix renormalization group CI [manual]. sapt0; 0th-order symmetry adapted perturbation theory (SAPT) [manual]. ssapt0; 0th-order SAPT with special exchange scaling [manual]. sapt2; 2nd-order SAPT, traditional definition [manual]. sapt2+; SAPT including all 2nd-order terms [manual]. sapt2+(3); SAPT including perturbative triples [manual]. sapt2+3; SAPT including all 3rd-order terms [manual]. sapt2+(ccd); SAPT2+ with CC-based dispersion [manual]. sapt2+(3)(ccd); SAPT2+(3) with CC-based dispersion [manual]. sapt2+3(ccd); SAPT2+3 with CC-based dispersion [manual]. sapt2+dmp2; SAPT including all 2nd-order terms and MP2 correction [manual]. sapt2+(3)dmp2; SAPT including perturbative triples and MP2 correction [manual]. sapt2+3dmp2; SAPT including all 3rd-order terms and MP2 correction [manual]. sapt2+(ccd)dmp2; SAPT2+ with CC-based dispersion and MP2 correction [manual]. sapt2+(3)(ccd)dmp2; SAPT2+(3) with CC-based dispersion and MP2 correction [manual]. sapt2+3(ccd)dmp2; SAPT2+3 with CC-based dispersion and MP2 correction [manual]. sapt0-ct; 0th-order SAPT plus cha",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/energy-1.html:5507,adapt,adapted,5507,psi4manual/1.0.0/energy-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/energy-1.html,2,['adapt'],['adapted']
Energy Efficiency,"number of the larger basis set in 2-point extrapolation.; Must be zLO + 1.; valueHI (Union[float, Matrix, Vector]) – Energy, gradient, or Hessian value at the larger basis set in 2-point; extrapolation.; verbose (int) – Controls volume of printing.; alpha (Optional[float]) – Fitted 2-point parameter. Overrides the default \(\alpha = 1.63\). Returns:; Eponymous function applied to input zetas and values; type from valueLO. Return type:; float or ndarray. Notes; The extrapolation is calculated according to [1]:; \(E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}, \alpha = 1.63\); References. [1]; Halkier, Helgaker, Jorgensen, Klopper, & Olsen, Chem. Phys. Lett. 302 (1999) 437-446,; DOI: 10.1016/S0009-2614(99)00179-7. Examples; >>> # [1] Hartree-Fock extrapolation; >>> psi4.energy('cbs', scf_wfn='hf', scf_basis='cc-pV[DT]Z', scf_scheme='scf_xtpl_helgaker_2'). psi4.driver.driver_cbs_helper.scf_xtpl_truhlar_2(functionname, zLO, valueLO, zHI, valueHI, verbose=1, alpha=None)[source]¶; Extrapolation scheme using power form for reference energies with two adjacent; zeta-level bases. Used by cbs(). Parameters:. functionname (str) – Name of the CBS component (e.g., ‘HF’) used in summary printing.; zLO (int) – Zeta number of the smaller basis set in 2-point extrapolation.; valueLO (Union[float, Matrix, Vector]) – Energy, gradient, or Hessian value at the smaller basis set in 2-point; extrapolation.; zHI (int) – Zeta number of the larger basis set in 2-point extrapolation; Must be zLO + 1.; valueHI (Union[float, Matrix, Vector]) – Energy, gradient, or Hessian value at the larger basis set in 2-point; extrapolation.; verbose (int) – Controls volume of printing.; alpha (Optional[float]) – Overrides the default \(\alpha = 3.4\). Returns:; Eponymous function applied to input zetas and values; type from valueLO. Return type:; float or ndarray. Notes; The extrapolation is calculated according to [2]:; \(E_{total}^X = E_{total}^{\infty} + \beta X^{-\alpha}, \alpha = 3.4\); Referen",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/cbs.html:23733,power,power,23733,psi4manual/1.7.x/cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/cbs.html,4,['power'],['power']
Energy Efficiency,"number of virtual orbitals retained after the FNO; truncation.; The general outline for the FNO procedure in PSI4 is:. construct the virtual-virtual block of the unrelaxed MP2 one-particle density matrix (OPDM); diagonalize this block of the OPDM to obtain a set of natural virtual orbitals; based on some occupancy threshold, determine which orbitals are unimportant and may be discarded; project the virtual-virtual block of the Fock matrix onto the truncated space; construct semicanonical orbitals by diagonalizing the virtual-virtual block of the Fock matrix; proceed with the QCISD(T) / CCSD(T) / MP4 computation in the reduced virtual space. A second-order correction based upon the MP2 energies in the full and; truncated spaces captures much of the missing correlation effects. More; details on the implementation and numerical accuracy of FNO methods in; PSI4 can be found in Ref. [DePrince:2013:293]. FNO computations; are controlled through the keywords NAT_ORBS and; OCC_TOLERANCE, or by prepending a valid method name with “fno” in; the energy call as; energy('fno-ccsd(t)'). QCISD(T), CCSD(T), MP4, and CEPA¶; The FNOCC module in PSI4 supports several related many-body quantum; chemistry methods, including the CCSD(T) and QCISD(T) methods, several; orders of many-body perturbation theory (MP2-MP4), and a family methods; related to the coupled electron pair approximation (CEPA). Quadratic configuration interaction and coupled cluster¶; The quadratic configuration interaction singles doubles (QCISD) method of; Pople, Head-Gordon, and Raghavachari [Pople:1987:5968] was originally; presented as a size-consistent extension of configuration interaction; singles doubles (CISD). The method can also be obtained as a; simplified version of the coupled cluster singles doubles (CCSD); method [Purvis:1982]. Consider the set of equations defining CCSD:. (1); where we have chosen the intermediate normalization,; , and the symbols ; and represent single and double excitation operators",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/fnocc-1.html:2033,energy,energy,2033,psi4manual/4.0b4/fnocc-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/fnocc-1.html,4,['energy'],['energy']
Energy Efficiency,"number of virtual; orbitals retained after the FNO truncation.; The general outline for the FNO procedure in PSI4 is:. construct the virtual-virtual block of the unrelaxed MP2 one-particle density matrix (OPDM); diagonalize this block of the OPDM to obtain a set of natural virtual orbitals; based on some occupancy threshold, determine which orbitals are unimportant and may be discarded; project the virtual-virtual block of the Fock matrix onto the truncated space; construct semicanonical orbitals by diagonalizing the virtual-virtual block of the Fock matrix; proceed with the QCISD(T) / CCSD(T) / MP4 computation in the reduced virtual space. A second-order correction based upon the MP2 energies in the full and; truncated spaces captures much of the missing correlation effects. More; details on the implementation and numerical accuracy of FNO methods in; PSI4 can be found in Ref. [DePrince:2013:293]. FNO computations; are controlled through the keywords NAT_ORBS and; OCC_TOLERANCE, or by prepending a valid method name with “fno” in; the energy call as; energy('fno-ccsd(t)'). QCISD(T), CCSD(T), MP4, and CEPA¶; The FNOCC module in PSI4 supports several related many-body quantum; chemistry methods, including the CCSD(T) and QCISD(T) methods, several; orders of many-body perturbation theory (MP2-MP4), and a family methods; related to the coupled electron pair approximation (CEPA). Quadratic configuration interaction and coupled cluster¶; The quadratic configuration interaction singles doubles (QCISD) method of; Pople, Head-Gordon, and Raghavachari [Pople:1987:5968] was originally; presented as a size-consistent extension of configuration interaction; singles doubles (CISD). The method can also be obtained as a; simplified version of the coupled cluster singles doubles (CCSD); method [Purvis:1982]. Consider the set of equations defining CCSD:. (1); where we have chosen the intermediate normalization,; , and the symbols ; and represent single and double excitation operators",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/fnocc-1.html:2071,energy,energy,2071,psi4manual/4.0b5/fnocc-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/fnocc-1.html,4,['energy'],['energy']
Energy Efficiency,"number of virtual; orbitals retained after the FNO truncation.; The general outline for the FNO procedure in Psi4 is:. construct the virtual-virtual block of the unrelaxed MP2 one-particle density matrix (OPDM); diagonalize this block of the OPDM to obtain a set of natural virtual orbitals; based on some occupancy threshold, determine which orbitals are unimportant and may be discarded; project the virtual-virtual block of the Fock matrix onto the truncated space; construct semicanonical orbitals by diagonalizing the virtual-virtual block of the Fock matrix; proceed with the QCISD(T) / CCSD(T) / MP4 computation in the reduced virtual space. A second-order correction based upon the MP2 energies in the full and; truncated spaces captures much of the missing correlation effects. More; details on the implementation and numerical accuracy of FNO methods in; Psi4 can be found in Ref. [DePrince:2013:293]. FNO computations; are controlled through the keywords NAT_ORBS and; OCC_TOLERANCE, or by prepending a valid method name with “fno” in; the energy call as; energy('fno-ccsd(t)'). If you wish to specify the number of active natural orbitals manually, use; the keyword ACTIVE_NAT_ORBS. This keyword will override the; keyword OCC_TOLERANCE. QCISD(T), CCSD(T), MP4, and CEPA¶; The FNOCC module in Psi4 supports several related many-body quantum; chemistry methods, including the CCSD(T) and QCISD(T) methods, several; orders of many-body perturbation theory (MP2-MP4), and a family methods; related to the coupled electron pair approximation (CEPA). Quadratic configuration interaction and coupled cluster¶; The quadratic configuration interaction singles doubles (QCISD) method of; Pople, Head-Gordon, and Raghavachari [Pople:1987:5968] was originally; presented as a size-consistent extension of configuration interaction; singles doubles (CISD). The method can also be obtained as a; simplified version of the coupled cluster singles doubles (CCSD); method [Purvis:1982]. Consider the set ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/fnocc-1.html:2537,energy,energy,2537,psi4manual/1.0.0/fnocc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/fnocc-1.html,4,['energy'],['energy']
Energy Efficiency,"number. See PubChem Database for; details.; Symmetry; The symmetry can be specified by a line reading symmetry; symbol, where symbol is the Schönflies symbol; of the (Abelian) point group to use for the computation, one of one of; c1, c2, ci, cs, d2, c2h, c2v, or d2h.; This need not be specified, as the molecular symmetry is automatically; detected by PSI4. See Symmetry for details.; Fragments; A line reading -- is interpreted as the separator between two non-covalently; bound molecular fragments. See Non-Covalently Bonded Molecule Fragments for details. Multiple Molecules¶; To facilitate more elaborate computations, it is possible to provide a name for; each molecule and tell PSI4 which one should be used in a given; calculation. For example, consider the following input file:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18molecule h2 {; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; energy('scf') # on H2. clean(). molecule h {; H; }. set basis cc-pvdz; set reference uhf; energy('scf') # on H. Here, two separate jobs are performed on two different molecules; the first is; performed on H2, while the second is for H atom. The last molecule to be; specified is the “active” molecule by default. To explicitly activate a named; molecule, the activate command is provided. With it, the above input file can be; equivalently written as follows. Alternatively, the molecule can be specified; directly to the computing function. Below, the third calculation is the same as; the first.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28molecule h2 {; H; H 1 0.9; }. molecule h {; H; }. activate(h2); set basis cc-pvdz; set reference rhf; energy('scf') # on H2. clean(). activate(h); set basis cc-pvdz; set reference uhf; energy('scf') # on H. # --------------------------------------; # equivalent to previous input ends here. clean(). set reference rhf; energy('scf', molecule=h2) # on H2. Job Control Keywords provi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psithonmol-1.html:5104,energy,energy,5104,psi4manual/1.1.0/psithonmol-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psithonmol-1.html,6,['energy'],['energy']
Energy Efficiency,"numerical differentiation. fci-dipole; 6-31G H2O Test FCI Energy Point. dft-custom-dhdf; DSD-PBEP86 S22 Ammonia test. cisd-h2o+-2; 6-31G** H2O+ Test CISD Energy Point. scf5; Test of all different algorithms and reference types for SCF, on singlet and triplet O2, using the cc-pVTZ basis set. mints8; Patch of a glycine with a methyl group, to make alanine, then DF-SCF energy calculation with the cc-pVDZ basis set. ci-multi; BH single points, checking that program can run multiple instances of DETCI in a single input, without an intervening clean() call. omp3-5; SOS-OMP3 cc-pVDZ geometry optimization for the H2O molecule. omp3-grad1; OMP3 cc-pVDZ gradient for the H2O molecule. dfomp2p5-1; DF-OMP2.5 cc-pVDZ energy for the H2O molecule. mints-helper; A general test of the MintsHelper function. extern2; External potential calculation involving a TIP3P water and a QM water for DFMP2. Finite different test of the gradient is performed to validate forces. cc34; RHF-CCSD/cc-pVDZ energy of H2O partitioned into pair energy contributions. castup3; SCF with various combinations of pk/density-fitting, castup/no-castup, and spherical/cartesian settings. Demonstrates that puream setting is getting set by orbital basis for all df/castup parts of calc. Demonstrates that answer doesn’t depend on presence/absence of castup. Demonstrates (by comparison to castup2) that output file doesn’t depend on options (scf_type) being set global or local. This input uses local. cc8a; ROHF-CCSD(T) cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Cartesian input. cisd-h2o+-1; 6-31G** H2O+ Test CISD Energy Point. cepa-module; routing check on lccd, lccsd, cepa(0). psithon1; Spectroscopic constants of H2, and the full ci cc-pVTZ level of theory. cc41; RHF-CC2-LR/cc-pVDZ optical rotation of H2O2. gauge = both, omega = (589 355 nm). dfmp2-grad3; DF-MP2 cc-pVDZ gradients for the H2O molecule. scf-bs; UHF and broken-symmetry UHF energy for molecular hydrogen. cc31; CCSD/sto-3g ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html:17593,energy,energy,17593,psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,8,['energy'],['energy']
Energy Efficiency,"numpy as np; import qcelemental as qcel. import psi4. _have_mdi = False; try:; from mdi import MDI_Init, MDI_MPI_get_world_comm, MDI_Accept_Communicator, \; MDI_Send, MDI_Recv, MDI_Recv_Command, MDI_INT, MDI_DOUBLE, \; MDI_Register_Node, MDI_Register_Command; _have_mdi = True; except ImportError:; pass. try:; from mpi4py import MPI; use_mpi4py = True; except ImportError:; use_mpi4py = False. class MDIEngine():; def __init__(self, scf_method, **kwargs):; """""" Initialize an MDIEngine object for communication with MDI. Arguments:; scf_method: Method used when calculating energies or gradients; """""". # Method used when the SCF command is received; self.scf_method = scf_method. # Additional arguments for energy, gradient, or optimization calculations; self.kwargs = kwargs. # Molecule all MDI operations are performed on; input_molecule = kwargs.pop('molecule', psi4.core.get_active_molecule()); self.molecule = input_molecule.clone(); psi4.core.set_active_molecule(self.molecule). # Most recent SCF energy; self.energy = 0.0. # Variables used when MDI sets a lattice of point charges; self.nlattice = 0 # number of lattice point charges; self.clattice = [] # list of lattice coordinates; self.lattice = [] # list of lattice charges; self.lattice_field = psi4.QMMM() # Psi4 chargefield. # MPI variables; self.mpi_world = None; self.world_rank = 0. # Flag for if a lattice of point charges has been set; self.set_lattice = False. # Get correct intra-code MPI communicator; if use_mpi4py:; self.mpi_world = MDI_MPI_get_world_comm(); self.world_rank = self.mpi_world.Get_rank(). # Psi4 does not currently support multiple MPI ranks; if self.mpi_world.Get_size() != 1:; MPI.COMM_WORLD.Abort(). # Accept a communicator to the driver code; self.comm = MDI_Accept_Communicator(). # Ensure that the molecule is using c1 symmetry; self.molecule.reset_point_group('c1'); self.molecule.fix_orientation(True); self.molecule.fix_com(True); self.molecule.reinterpret_coordentry(False); self.molecule.update_geom",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html:2246,energy,energy,2246,psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html,4,['energy'],['energy']
Energy Efficiency,"numpy as np; import qcelemental as qcel. import psi4. _have_mdi = False; try:; from mdi import MDI_Init, MDI_MPI_get_world_comm, MDI_Accept_Communicator, \; MDI_Send, MDI_Recv, MDI_Recv_Command, MDI_INT, MDI_DOUBLE, \; MDI_Register_Node, MDI_Register_Command; _have_mdi = True; except ImportError:; pass. try:; from mpi4py import MPI; use_mpi4py = True; except ImportError:; use_mpi4py = False. class MDIEngine():; def __init__(self, scf_method, **kwargs):; """""" Initialize an MDIEngine object for communication with MDI. Arguments:; scf_method: Method used when calculating energies or gradients; """""". # Method used when the SCF command is received; self.scf_method = scf_method. # Additional arguments for energy, gradient, or optimization calculations; self.kwargs = kwargs. # Molecule all MDI operations are performed on; input_molecule = kwargs.pop('molecule', psi4.core.get_active_molecule()); self.molecule = input_molecule.clone(); psi4.core.set_active_molecule(self.molecule). # Most recent SCF energy; self.energy = 0.0. # Variables used when MDI sets a lattice of point charges; self.nlattice = 0 # number of lattice point charges; self.clattice = [] # list of lattice coordinates; self.lattice = [] # list of lattice charges; self.lattice_field = psi4.QMMMbohr() # Psi4 chargefield. # MPI variables; self.mpi_world = None; self.world_rank = 0. # Flag for if a lattice of point charges has been set; self.set_lattice = False. # Get correct intra-code MPI communicator; if use_mpi4py:; self.mpi_world = MDI_MPI_get_world_comm(); self.world_rank = self.mpi_world.Get_rank(). # Psi4 does not currently support multiple MPI ranks; if self.mpi_world.Get_size() != 1:; MPI.COMM_WORLD.Abort(). # Accept a communicator to the driver code; self.comm = MDI_Accept_Communicator(). # Ensure that the molecule is using c1 symmetry; self.molecule.reset_point_group('c1'); self.molecule.fix_orientation(True); self.molecule.fix_com(True); self.molecule.reinterpret_coordentry(False); self.molecule.update_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/mdi_engine.html:2246,energy,energy,2246,psi4manual/1.6.x/_modules/psi4/driver/mdi_engine.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/mdi_engine.html,2,['energy'],['energy']
Energy Efficiency,"nunity parameters fitted for individual functionals. (2). A modified damping scheme for DFT-D3 using the rational damping form of; Becke and Johnson was introduced in [Grimme:2011:1456]. The parameters; fit for individual functionals are now , ,; , and . All parameters characterizing the dispersion correction are taken from; http://toc.uni-muenster.de/DFTD3/; or else from the literature. Running DFTD3¶; A number of a posteriori dispersion corrections are available in; PSI4. While most are computed within PSI4’s codebase (-D1, -D2,; -CHG, -DAS2009, -DAS2010), the -D3 correction and its variants are; available only through the DFTD3 program. Once installed, the; dftd3/PSI4 interface is transparent, and all corrections are; interfaced exactly alike.; Dispersion corrections are built into DFT functionals, so appending an a; posteriori correction to a computation is as simple as; energy('b2plyp-d') vs. energy('b2plyp'). For example, the; following input file computes (with much redundant work) for water a; B3LYP, a B3LYP-D2, and a B3LYP-D3 (zero-damping) energy.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('b3lyp'); energy('b3lyp-d'); energy('b3lyp-d3'). Consult the table -D Functionals to see for each; functional what corrections are available and what default parameters; define them. The dispersion correction is available after a calculation in; the PSI variable DISPERSION CORRECTION ENERGY.; By default, the output from the dftd3; program is suppressed; to see it in the output file, set print > 2. Variants of S. Grimme’s -D correction. Extension [1]; Variant and Computing Program; DFT_DISPERSION_PARAMETERS. -D; alias to -D2P4;  . -D1; -D1 [2] within PSI4;  . -D2; alias to -D2P4;  . -D2P4; -D2 [3] within PSI4; []. -D2GR; -D2 [3] through dftd3; [, ]. -D3; alias to -D3ZERO;  . -D3ZERO; -D3 [4] w/ original zero-damping through dftd3; [, , , ]. -D3BJ; -D3 [5] w/ newer Becke-Johnson rational damping through dftd3; [, , , ]. Footnotes. [1]No",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/dftd3.html:3978,energy,energy,3978,psi4manual/4.0b3/dftd3.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/dftd3.html,5,['energy'],['energy']
Energy Efficiency,"nunity parameters fitted for individual functionals. (2). A modified damping scheme for DFT-D3 using the rational damping form of; Becke and Johnson was introduced in [Grimme:2011:1456]. The parameters; fit for individual functionals are now , ,; , and . All parameters characterizing the dispersion correction are taken from; http://toc.uni-muenster.de/DFTD3/; or else from the literature. Running DFTD3¶; A number of a posteriori dispersion corrections are available in; Psi4. While most are computed within Psi4‘s codebase (-D1, -D2,; -CHG, -DAS2009, -DAS2010), the -D3 correction and its variants are; available only through the DFTD3 program. Once installed, the; dftd3/Psi4 interface is transparent, and all corrections are; interfaced exactly alike.; Dispersion corrections are built into DFT functionals, so appending an a; posteriori correction to a computation is as simple as; energy('b2plyp-d') vs. energy('b2plyp'). For example, the; following input file computes (with much redundant work) for water a; B3LYP, a B3LYP-D2, and a B3LYP-D3 (zero-damping) energy.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('b3lyp'); energy('b3lyp-d'); energy('b3lyp-d3'). Consult the table -D Functionals to see for each; functional what corrections are available and what default parameters; define them. The dispersion correction is available after a calculation in; the PSI variable DISPERSION CORRECTION ENERGY.; By default, the output from the dftd3; program is suppressed; to see it in the output file, set print > 2. Variants of S. Grimme’s -D correction¶. Extension [1]; Variant and Computing Program; DFT_DISPERSION_PARAMETERS. -D; alias to -D2P4;  . -D1; -D1 [2] within Psi4;  . -D2; alias to -D2P4;  . -D2P4; -D2 [3] within Psi4; []. -D2GR; -D2 [3] through dftd3; [, ]. -D3; alias to -D3ZERO;  . -D3ZERO; -D3 [4] w/ original zero-damping through dftd3; [, , , ]. -D3BJ; -D3 [5] w/ newer Becke-Johnson rational damping through dftd3; [, , , ]. -D3M; alias to ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/dftd3-1.html:4692,energy,energy,4692,psi4manual/1.0.0/dftd3-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/dftd3-1.html,2,['energy'],['energy']
Energy Efficiency,"nverged to \(10^{-6} E_h\), the user may set the e_convergence; keyword to 0.000001, 1.0e-6, or 6. Alternate Implementations¶; Depending on the reference (RHF, UHF, ROHF) and the integral treatment; (conventional CONV, density-fitted DF, and Cholesky-decomposed CD),; computational methods are sometimes implemented by multiple coders or even; multiple times. PSI4 transparently selects the most efficient; implementation, so one generally needn’t consult this table. However, to; understand the details of what combinations are accessible or what; alternate implementations are available, read on.; Below, “Y” means method available in module, “D” means module is default; for that method, and “” means method not available. HF, DFT, and MP2; default to density-fitted integrals, while all higher methods default to; conventional integrals. Therefore, for a closed-shell molecule:. runs MP2 with default DF with default implementation DFMP2; energy('mp2'). runs MP2 with CONV with default implementation OCC; set mp2_type conv; energy('mp2'). runs MP2 with default DF with implementation OCC; set qc_module occ; energy('mp2'). Overlapping capabilities of PSI4. “Y” is available; “D” is default.¶. name; _; type select 1. QC_MODULE; REFERENCE; _. energy(); gradient(). RHF; UHF; ROHF; RHF; UHF; ROHF. CV; DF; CD; CV; DF; CD; CV; DF; CD; CV; DF; CD; CV; DF; CD; CV; DF; CD. mp2; MP2_TYPE. CCENERGY. DETCI; Y. Y. DFMP2. D 2. D 2. D. D. FNOCC; Y. OCC; D; Y; D; D; Y; Y; D; Y; D; D; Y. D; D. mp3; MP_TYPE. CCENERGY. DETCI; Y. Y 3. DFMP2. FNOCC; Y. OCC; D; D; D; D; D; D. D; D. D; D. mp2.5; MP_TYPE. CCENERGY. DETCI. DFMP2. FNOCC. OCC; D; D; D; D; D; D. D; D. D; D. mp4; MP_TYPE. CCENERGY. DETCI; Y. Y 3. DFMP2. FNOCC; D. OCC. lccd; CC_TYPE. CCENERGY. DETCI. DFMP2. FNOCC; D. OCC; Y; D; D; D; D; D. D; D. D; D. lccsd, cepa(0); CC_TYPE. CCENERGY. DETCI. DFMP2. FNOCC; D. OCC. ccsd; CC_TYPE. CCENERGY; D. D. D. D. D. D. DETCI. DFMP2. FNOCC; Y; D; D. OCC. Y; Y. D. ccsd(t); CC_TYPE. CCENERGY; D. D. D. D. D. ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/notes_c-1.html:2088,energy,energy,2088,psi4manual/1.4.0/notes_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/notes_c-1.html,4,['energy'],['energy']
Energy Efficiency,"nvergence problems, because roundoff may allow the lower-lying; roots of lower multiplicities to re-enter the computation (reducing convergence criteria may help).; For open-shell systems, the MS0 keyword is typically not relevant, and there; is no control over spin multiplicities of higher roots unless|detci__calc_s_squared| is; used. Arbitrary Order Perturbation Theory¶; The DETCI module is capable of computing energies for arbitrary; order Møller–Plesset perturbation theory (MPn, for closed-shell; systems with an RHF reference) and for Z-averaged perturbation theory; (ZAPTn, open-shell systems with a ROHF reference). However, please; note that these computations are essentially doing high-order CI (up to; full CI) computations to obtain these results, and hence they will only; be possible for very small systems (generally a dozen electrons or less).; The simplest way to run high-order perturbation theory computations is to; call, e.g., energy('mp10') to invoke a MP10 computation or; energy('zapt25') to invoke a ZAPT25 computation. This will; automatically set several additional user options to their appropriate; values. The program uses the Wigner (2n+1) rule to obtain higher-order; energies from lower-order wavefunctions.; For the interested reader, the additional user options that are; automatically set up by the calls above are as follows. A call like; energy('mp10') sets MPN to TRUE.; The program uses the Wigner (2n+1) rule by default; (MPN_WIGNER = TRUE); and figures out what order of wavefunction is; necessary to reach the desired order in the energy. The program then; sets MAX_NUM_VECS to the required order in the; wavefunction.; By default, the requested n-th order energy is saved as the current; energy to the process environment. ZAPTN works essentially the same; way for an ROHF reference. Arbitrary Order Coupled-Cluster Theory¶; This DETCI-based version of this feature is not yet released. However,; the current version of the code does include an interf",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/detci-1.html:13204,energy,energy,13204,psi4manual/1.4.0/detci-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/detci-1.html,18,['energy'],['energy']
Energy Efficiency,"nvergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; conv_dmax = '*' if dmax < params.Convergence_dmax else ' '; conv_drms = '*' if drms < params.Convergence_drms else ' '; core.print_out((f'\n {optimizer.Iteration:4d} {optimizer.E:16.8e} '; f'{optimizer.E-optimizer.Eprev:10.2e} {conv_energy} {gmax:10.2e} {conv_gmax} '; f'{grms:10.2e} {conv_grms} {dmax:10.2e} {conv_dmax} {drms:10.2e} {conv_drms} ~')). if return_history:; step_energies.append(optimizer.E); step_coordinates.append(core.Matrix.from_array(optimizer.X.reshape(-1,3))); step_gradients.append(core.Matrix.from_array(optimizer.gradx.reshape(-1,3))). return_energy = optimizer.E; opt_geometry = core.Matrix.from_array(optimizer.X.reshape(-1,3)); molecule.set_geometry(opt_geometry); molecule.update_geometry(); core.print_out(f'\n Final Energy : {return_energy} \n'); core.print_out('\n Final Geometry : \n'); molecule.print_in_input_format(). if return_history:; history = {; 'energy': step_energies,; 'gradient': step_gradients,; 'coordinates': step_coordinates,; }. if return_wfn:; wfn = engine.p4_wfn. if return_wfn and return_history:; return (return_energy, wfn, history); elif return_wfn and not return_history:; return (return_energy, wfn); elif return_history and not return_wfn:; return (return_energy, history); else:; return return_energy. [docs]; def optimize(name, **kwargs):; r""""""Function to perform a geometry optimization. :aliases: opt(). :returns: *float* |w--w| Total electronic energy of optimized structure in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :raises: :py:class:`psi4.driver.OptimizationConvergenceError` if :term:`GEOM_MAXITER <GEOM_MAXITER (OPTKING)>` exceeded without reaching geometry convergence. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY`. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicat",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:60520,energy,energy,60520,psi4manual/1.8.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html,6,['energy'],['energy']
Energy Efficiency,"nvergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; conv_dmax = '*' if dmax < params.Convergence_dmax else ' '; conv_drms = '*' if drms < params.Convergence_drms else ' '; core.print_out((f'\n {optimizer.Iteration:4d} {optimizer.E:16.8e} '; f'{optimizer.E-optimizer.Eprev:10.2e} {conv_energy} {gmax:10.2e} {conv_gmax} '; f'{grms:10.2e} {conv_grms} {dmax:10.2e} {conv_dmax} {drms:10.2e} {conv_drms} ~')). if return_history:; step_energies.append(optimizer.E); step_coordinates.append(core.Matrix.from_array(optimizer.X.reshape(-1,3))); step_gradients.append(core.Matrix.from_array(optimizer.gradx.reshape(-1,3))). return_energy = optimizer.E; opt_geometry = core.Matrix.from_array(optimizer.X.reshape(-1,3)); molecule.set_geometry(opt_geometry); molecule.update_geometry(); core.print_out(f'\n Final Energy : {return_energy} \n'); core.print_out('\n Final Geometry : \n'); molecule.print_in_input_format(). if return_history:; history = {; 'energy': step_energies,; 'gradient': step_gradients,; 'coordinates': step_coordinates,; }. if return_wfn:; wfn = engine.p4_wfn. if return_wfn and return_history:; return (return_energy, wfn, history); elif return_wfn and not return_history:; return (return_energy, wfn); elif return_history and not return_wfn:; return (return_energy, history); else:; return return_energy. [docs]def optimize(name, **kwargs):; r""""""Function to perform a geometry optimization. :aliases: opt(). :returns: *float* |w--w| Total electronic energy of optimized structure in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :raises: :py:class:`psi4.OptimizationConvergenceError` if :term:`GEOM_MAXITER <GEOM_MAXITER (OPTKING)>` exceeded without reaching geometry convergence. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY`. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the co",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:58746,energy,energy,58746,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,6,['energy'],['energy']
Energy Efficiency,"nvergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; conv_dmax = '*' if dmax < params.Convergence_dmax else ' '; conv_drms = '*' if drms < params.Convergence_drms else ' '; core.print_out((f'\n {optimizer.Iteration:4d} {optimizer.E:16.8e} '; f'{optimizer.E-optimizer.Eprev:10.2e} {conv_energy} {gmax:10.2e} {conv_gmax} '; f'{grms:10.2e} {conv_grms} {dmax:10.2e} {conv_dmax} {drms:10.2e} {conv_drms} ~')). if return_history:; step_energies.append(optimizer.E); step_coordinates.append(core.Matrix.from_array(optimizer.X.reshape(-1,3))); step_gradients.append(core.Matrix.from_array(optimizer.gradx.reshape(-1,3))). return_energy = optimizer.E; opt_geometry = core.Matrix.from_array(optimizer.X.reshape(-1,3)); molecule.set_geometry(opt_geometry); molecule.update_geometry(); core.print_out(f'\n Final Energy : {return_energy} \n'); core.print_out('\n Final Geometry : \n'); molecule.print_in_input_format(). if return_history:; history = {; 'energy': step_energies,; 'gradient': step_gradients,; 'coordinates': step_coordinates,; }. if return_wfn:; wfn = engine.p4_wfn. if return_wfn and return_history:; return (return_energy, wfn, history); elif return_wfn and not return_history:; return (return_energy, wfn); elif return_history and not return_wfn:; return (return_energy, history); else:; return return_energy. [docs]def optimize(name, **kwargs):; r""""""Function to perform a geometry optimization. :aliases: opt(). :returns: *float* |w--w| Total electronic energy of optimized structure in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :raises: :py:class:`psi4.driver.OptimizationConvergenceError` if :term:`GEOM_MAXITER <GEOM_MAXITER (OPTKING)>` exceeded without reaching geometry convergence. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY`. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html:60497,energy,energy,60497,psi4manual/1.7.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html,2,['energy'],['energy']
Energy Efficiency,"nvironment p4env and performed; source activate p4env, then which psi4 likely yields; condadist/envs/p4env/bin/psi4 and the PATH setting lines; below are redundant.; # csh, tcsh: add to shell or ~/.tcshrc file; unsetenv PSIDATADIR; setenv PATH {prefix}/bin:$PATH; setenv PSI_SCRATCH /path/to/existing/writable/local-not-network/directory/for/scratch/files. # sh, bash: add to shell or ~/.bashrc (Linux/Windows) or ~/.bash_profile (Mac) file; unset PSIDATADIR; export PATH={prefix}/bin:$PATH; export PSI_SCRATCH=/path/to/existing/writable/local-not-network/directory/for/scratch/files. Run PSI4 as executable.; 1; 2; 3; 4; 5; 6; 7; 8>>> cat sample.in; molecule {; He; }; energy('hf/cc-pvdz'); compare_values(-2.85518839, get_variable('current energy'), 5, 'SCF E'); >>> psi4 sample.in; SCF E.............................................................PASSED. or Run PSI4 as Python module.; 1; 2; 3; 4; 5; 6; 7; 8; 9>>> cat sample.py; import psi4; mol = psi4.geometry(""""""; He; """"""); psi4.energy('hf/cc-pvdz'); psi4.compare_values(-2.85518839, psi4.core.get_variable('current energy'), 5, 'SCF E'); >>> python sample.py; SCF E.............................................................PASSED. How to run Psi4 as executable after compilation using driver from source¶; When developing python driver code, it can be annoying to keep makeing to test the code. PSI4 can be run “inplace” through the; following procedure. To be clear, this is running compiled C++ from the; build directory and python from the source directory. This is an expert; option for development, and not all functionality will be available.; 1; 2; 3>>> cd {objdir}; >>> ln -s {top-level-psi4-dir}/{objdir}/stage/{prefix}/lib/psi4/core.so ../psi4/core.so; >>> python ../psi4/run_psi4.py --inplace input.dat. How to set PSIDATADIR and why¶; PSIDATADIR is an environment variable containing the location of the; text resource parts of the PSI4 codebase (e.g., basis sets,; databases, EFP fragments). It is for developer use only. In P",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/build_planning-1.html:22964,energy,energy,22964,psi4manual/1.1.0/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/build_planning-1.html,2,['energy'],['energy']
Energy Efficiency,"nvironment p4env and performed; source activate p4env, then which psi4 likely yields; condadist/envs/p4env/bin/psi4 and the PATH setting lines; below are redundant.; # csh, tcsh: add to shell or ~/.tcshrc file; unsetenv PSIDATADIR; setenv PATH {prefix}/bin:$PATH; setenv PSI_SCRATCH /path/to/existing/writable/local-not-network/directory/for/scratch/files. # sh, bash: add to shell or ~/.bashrc (Linux/Windows) or ~/.bash_profile (Mac) file; unset PSIDATADIR; export PATH={prefix}/bin:$PATH; export PSI_SCRATCH=/path/to/existing/writable/local-not-network/directory/for/scratch/files. Run PSI4 as executable.; 1; 2; 3; 4; 5; 6; 7; 8>>> cat sample.in; molecule {; He; }; energy('hf/cc-pvdz'); compare_values(-2.85518839, get_variable('current energy'), 5, 'SCF E'); >>> psi4 sample.in; SCF E.............................................................PASSED. or Run PSI4 as Python module.; 1; 2; 3; 4; 5; 6; 7; 8; 9>>> cat sample.py; import psi4; mol = psi4.geometry(""""""; He; """"""); psi4.energy('hf/cc-pvdz'); psi4.compare_values(-2.85518839, psi4.core.get_variable('current energy'), 5, 'SCF E'); >>> python sample.py; SCF E.............................................................PASSED. How to run Psi4 as executable after compilation using driver from source¶; When developing python driver code, it can be annoying to keep makeing to test the code. PSI4 can be run “inplace” through the; following procedure. To be clear, this is running compiled C++ from the; build directory and python from the source directory. This is an expert; option for development, and not all functionality will be available.; 1; 2; 3>>> cd {objdir}; >>> ln -s {top-level-psi4-dir}/{objdir}/stage/{prefix}/lib/psi4/core.so ../psi4/core.so; >>> python ../psi4/run_psi4.py --inplace input.dat. Why not to set PSIDATADIR¶; PSIDATADIR is an environment variable containing the location of the; text resource parts of the PSI4 codebase (e.g., basis sets,; databases, EFP fragments). It is for developer use only. In PSI4 ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/build_planning-1.html:26339,energy,energy,26339,psi4manual/1.2.1/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/build_planning-1.html,2,['energy'],['energy']
Energy Efficiency,"nvoked in sandwich mode,; all Cfour optimization keywords (e.g., CFOUR_GEO_MAXCYC) are; ineffective, as the Cfour optimizer is never invoked. Psi4; optimization keywords (e.g., GEOM_MAXITER) instead fill; these roles. Specifying the computational method (through, for instance,; energy('c4-ccsd') instead of energy('cfour')) often; sets additional keywords consistent with best practices (e.g.,; CFOUR_CC_PROGRAM). Since those settings are implicit, any; explicit setting of those those keywords, whether contradicting or; concurring, takes priority (halts never generated). The following are; some concrete examples. For the moment, click the source button at; qcdb.cfour.muster_modelchem() for details of what keywords; get set. runs in vcc since that’s Cfour’s default for cc_program; set cfour_calc_level ccsd; energy('cfour'). runs in ecc since Cfour’s default overwritten by keyword; set cfour_calc_level ccsd; set cfour_cc_program ecc; energy('cfour'). runs in ecc since that’s best practice for the requested ccsd; energy('c4-ccsd'). runs in vcc since hidden default overwritten by keyword; set cfour_cc_program vcc; energy('c4-ccsd'). Specifying certain keywords that are nominally applicable for pure-Psi4 modules directs them to fulfil analogous roles; in the Cfour program (e.g., MAXITER is used to set; CFOUR_SCF_MAXCYC). This keyword translation only takes place; if the keywords are explicitly set in the input file (part of that; contract that you mean it), meaning that Psi4‘s defaults don’t; get imposed on Cfour. Also, in the case where a translatable pure-Psi4 keyword and its translation Cfour keyword are both set,; the value attached to the latter is always used. Below are a few; clarifying examples. uses SCF conv crit since that’s Cfour’s default; for CFOUR_SCF_CONV; energy('c4-scf'). uses SCF conv crit since default overwritten by; keyword; set cfour_scf_conv 6; energy('c4-scf'). uses SCF conv crit since default overwritten by; SCF module keyword; set d_convergence 5; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/cfour-1.html:32401,energy,energy,32401,psi4manual/1.0.0/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/cfour-1.html,2,['energy'],['energy']
Energy Efficiency,"nvolving RAS IV into the CI space. Useful to specify a split-virtual CISD[TQ] computation. If FALSE, then if there are any electrons in RAS IV, then the number of holes in RAS I cannot exceed the given excitation level EX_LEVEL. Type: boolean; Default: true. MO_DIIS_NUM_VECS (DFOCC); DFOCC — Number of vectors used in orbital DIIS. Type: integer; Default: 6. MO_DIIS_NUM_VECS (OCC); OCC — Number of vectors used in orbital DIIS. Type: integer; Default: 6. MO_MAXITER (DFOCC); DFOCC — Maximum number of iterations to determine the orbitals. Type: integer; Default: 50. MO_MAXITER (OCC); OCC — Maximum number of iterations to determine the orbitals. Type: integer; Default: 50. MO_READ (MCSCF); MCSCF — Do read in from file the MOs from a previous computation?. Type: boolean; Default: true. MO_READ (OCC); OCC — Do read coefficient matrices from external files of a previous OMP2 or OMP3 computation?. Type: boolean; Default: false. MO_RELAX (DCFT); DCFT (Expert) — Controls whether to relax the orbitals during the energy computation or not (for debug puproses only). For practical applications only the default must be used. Type: boolean; Default: true. MO_STEP_MAX (DFOCC); DFOCC — Maximum step size in orbital-optimization procedure. Type: double; Default: 0.5. MO_STEP_MAX (OCC); OCC — Maximum step size in orbital-optimization procedure. Type: double; Default: 0.5. MO_WRITE (OCC); OCC — Do write coefficient matrices to external files for direct reading MOs in a subsequent job?. Type: boolean; Default: false. MODULE (CPHF); CPHF — What app to test?. Type: string; Possible Values: RCIS, RCPHF, RTDHF, RCPKS, RTDA, RTDDFT; Default: RCIS. MOGRAD_DAMPING (OCC); OCC — Damping factor for the orbital gradient (Rendell et al., JCP, vol. 87, pp. 5976, 1987). Type: double; Default: 1.0. MOLDEN_WITH_VIRTUAL (GLOBALS); GLOBALS — Write all the MOs to the MOLDEN file (true) or discard the unoccupied MOs (false). Type: boolean; Default: true. MOLDEN_WRITE (DCFT); DCFT — Do write a MOLDEN output fi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html:163490,energy,energy,163490,psi4manual/1.2.1/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html,6,['energy'],['energy']
Energy Efficiency,"nvolving RAS IV into the CI space. Useful to specify a split-virtual CISD[TQ] computation. If FALSE, then if there are any electrons in RAS IV, then the number of holes in RAS I cannot exceed the given excitation level EX_LEVEL. Type: boolean; Default: true. MO_DIIS_NUM_VECS (DFOCC); DFOCC — Number of vectors used in orbital DIIS. Type: integer; Default: 6. MO_DIIS_NUM_VECS (OCC); OCC — Number of vectors used in orbital DIIS. Type: integer; Default: 6. MO_MAXITER (DFOCC); DFOCC — Maximum number of iterations to determine the orbitals. Type: integer; Default: 50. MO_MAXITER (OCC); OCC — Maximum number of iterations to determine the orbitals. Type: integer; Default: 50. MO_READ (MCSCF); MCSCF — Do read in from file the MOs from a previous computation?. Type: boolean; Default: true. MO_READ (OCC); OCC — Do read coefficient matrices from external files of a previous OMP2 or OMP3 computation?. Type: boolean; Default: false. MO_RELAX (DCFT); DCFT (Expert) — Controls whether to relax the orbitals during the energy computation or not (for debug puproses only). For practical applications only the default must be used. Type: boolean; Default: true. MO_STEP_MAX (DFOCC); DFOCC — Maximum step size in orbital-optimization procedure. Type: double; Default: 0.5. MO_STEP_MAX (OCC); OCC — Maximum step size in orbital-optimization procedure. Type: double; Default: 0.5. MO_WRITE (OCC); OCC — Do write coefficient matrices to external files for direct reading MOs in a subsequent job?. Type: boolean; Default: false. MODULE (CPHF); CPHF — What app to test?. Type: string; Possible Values: RCIS, RCPHF, RTDHF, RCPKS, RTDA, RTDDFT; Default: RCIS. MOGRAD_DAMPING (OCC); OCC — Damping factor for the orbital gradient (Rendell et al., JCP, vol. 87, pp. 5976, 1987). Type: double; Default: 1.0. MOLDEN_WRITE (DCFT); DCFT — Do write a MOLDEN output file? If so, the filename will end in .molden, and the prefix is determined by WRITER_FILE_LABEL (if set), or else by the name of the output file plus the n",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html:161219,energy,energy,161219,psi4manual/1.0.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html,2,['energy'],['energy']
Energy Efficiency,"ny computations, many of the algorithms will perform better if; more is available. To specify memory, the memory keyword should be used. The following; lines are all equivalent methods for specifying that 2 Gb of RAM is available; to PSI4:; # all equivalent. memory 2 Gb. memory 2000 Mb. memory 2000000 Kb. One convenient way to override the PSI4 default memory is to place a; memory command in the ~/.psi4rc file (Sec. Scratch Files and the ~/.psi4rc File). For example,; the following makes the default memory 2 Gb.; set_memory(2000000000). However, unless you’re assured of having only one job running on a node at; a time (and all nodes on the filesystem with ~/.psi4rc have similar memory; capacities), it is advised to set memory in the input file on a; per-calculation basis. Note; For parallel jobs, the memory keyword represents the total memory; available to the job, not the memory per thread. Return Values and PSI Variables¶; To harness the power of Python, PSI4 makes the most pertinent results of; each computation are made available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of H2; and H atom:; molecule h2{; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h{; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol*(2*h_energy - h2_energy); print""De=%f""%D_e. The energy() function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation.; Generally, there are multiple quantities of interest. Appendix; PSI Variables by Module lists PSI variables variables set by each; module. These can be accessed through the get_variable() function.; For example, after performing a density fitted MP2 computation, both the; spin component scaled energy and the",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:22842,power,power,22842,psi4manual/4.0b4/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html,4,['power'],['power']
Energy Efficiency,"n¶. class psi4.core.Wavefunction¶; Bases: pybind11_builtins.pybind11_object; docstring; Methods Summary. Ca(self); Returns the Alpha Orbitals. Ca_subset(self, arg0, arg1); Returns the requested Alpha Orbital subset. Cb(self); Returns the Beta Orbitals. Cb_subset(self, arg0, arg1); Returns the requested Beta Orbital subset. Da(self); Returns the Alpha Density Matrix. Da_subset(self, arg0); Returns the requested Alpha Density subset. Db(self); Returns the Beta Density Matrix. Db_subset(self, arg0); Returns the requested Beta Density subset. Fa(self); Returns the Alpha Fock Matrix. Fb(self); Returns the Beta Fock Matrix. H(self); Returns the ‘Core’ Matrix (Potential + Kinetic) Integrals. S(self); Returns the One-electron Overlap Matrix. X(self); Returns the Lagrangian Matrix. alpha_orbital_space(self, arg0, arg1, arg2); docstring. aotoso(self); Returns the Atomic Orbital to Symmetry Orbital transformer. arrays(self); Returns the map of all internal arrays. atomic_point_charges(self); Returns the set atomic point charges. basis_projection(self, arg0, arg1, arg2, arg3); Projects a orbital matrix from one basis to another. basisset(self); Returns the current orbital basis. beta_orbital_space(self, arg0, arg1, arg2); docstring. build(mol[, basis]). c1_deep_copy(self, basis); Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet *basis. compute_energy(self); Computes the energy of the Wavefunction. compute_gradient(self); Computes the gradient of the Wavefunction. compute_hessian(self); Computes the Hessian of the Wavefunction. deep_copy(self, arg0); Deep copies the internal data. doccpi(self); Returns the number of doubly occupied orbitals per irrep. energy(self); Returns the Wavefunctions energy. epsilon_a(self); Returns the Alpha Eigenvalues. epsilon_a_subset(self, arg0, arg1); Returns the requested Alpha Eigenvalues subset. epsilon_b(self); Returns the Beta Eigenvalues. epsilon_b_subset(self, arg0, arg1); Returns the ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/api/psi4.core.wavefunction.html:1157,charge,charges,1157,psi4manual/1.2.1/api/psi4.core.wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/api/psi4.core.wavefunction.html,1,['charge'],['charges']
Energy Efficiency,"n¶; Binary. CPPE is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell).; If using the PSI4 binary, CPPE has already been installed alongside.; If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; CPPE can be obtained through conda install cppe -c psi4.; Then enable it as a feature with ENABLE_cppe,; hint its location with cppe_DIR,; and rebuild PSI4 to detect CPPE and activate dependent code. To remove a conda installation, conda remove cppe. Source. If using PSI4 built from source and you want CPPE built from; from source also,; enable it as a feature with ENABLE_cppe,; and let the build system fetch and build it and activate dependent code. Using the polarizable embedding model¶; The inclusion of a PE description of the solvent into your calculation; is achieved by setting PE true in your input file. Note; At present, PE can only be used for energy calculations with SCF; wavefunctions and CC wavefunctions in the PTE approximation [Cammi:2009:164104].; All ERI algorithms (PK, OUT_OF_CORE, DIRECT, DF, CD) are supported. Note; linear response calculations (static polarisabilities, TD-SCF) are supported for RHF/UHF if available. Warning; The CPPE library cannot exploit molecular point group symmetry. A typical input for a Hartree–Fock calculation with PE would look like the following:; molecule pna {; C 8.64800 1.07500 -1.71100; C 9.48200 0.43000 -0.80800; C 9.39600 0.75000 0.53800; C 8.48200 1.71200 0.99500; C 7.65300 2.34500 0.05500; C 7.73200 2.03100 -1.29200; H 10.18300 -0.30900 -1.16400; H 10.04400 0.25200 1.24700; H 6.94200 3.08900 0.38900; H 7.09700 2.51500 -2.01800; N 8.40100 2.02500 2.32500; N 8.73400 0.74100 -3.12900; O 7.98000 1.33100 -3.90100; O 9.55600 -0.11000 -3.46600; H 7.74900 2.71100 2.65200; H 8.99100 1.57500 2.99500; symmetry c1; no_reorient; no_com; }. set {; basis sto-3g; pe true; e_convergence 10; d_convergence 10; scf_type pk; }. set pe",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/cppe-1.html:1703,energy,energy,1703,psi4manual/1.4.0/cppe-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/cppe-1.html,9,['energy'],['energy']
Energy Efficiency,"n’s density being mixed into the current iteration) can help in cases where oscillatory convergence is observed. Type: double; Default: 0.0. DIIS_MAX_VECS¶. Maximum number of error vectors stored for DIIS extrapolation. Type: integer; Default: 6. DIIS_MIN_VECS¶. Minimum number of error vectors stored for DIIS extrapolation. Type: integer; Default: 3. DIIS_START_CONVERGENCE¶. Value of RMS of the density cumulant residual and SCF error vector below which DIIS extrapolation starts. Same keyword controls the DIIS extrapolation for the solution of the response equations. Type: conv double; Default: 1e-3. LAMBDA_MAXITER¶. Maximum number of density cumulant update micro-iterations per macro-iteration (for ALOGRITHM = TWOSTEP). Same keyword controls the maximum number of density cumulant response micro-iterations per macro-iteration for the solution of the response equations (for RESPONSE_ALOGRITHM = TWOSTEP). Type: integer; Default: 50. MAXITER¶. Maximum number of macro-iterations for both energy and the solution of the response equations. Type: integer; Default: 40. RESPONSE_ALGORITHM¶. The algorithm to use for the solution of the response equations for the analytic gradients and properties. Two-step algorithm is generally more efficient than simultaneous and is used by default. Type: string; Possible Values: TWOSTEP, SIMULTANEOUS; Default: TWOSTEP. R_CONVERGENCE¶. Convergence criterion for the RMS of the residual vector in the density cumulant updates as well as the solution of the density cumulant and orbital response equations. In the orbital updates controls the RMS of the SCF error vector. Type: conv double; Default: 1e-10. SCF_MAXITER¶. Maximum number of orbital update micro-iterations per macro-iteration (for ALOGRITHM = TWOSTEP). Same keyword controls the maximum number of orbital response micro-iterations per macro-iteration for the solution of the response equations (for RESPONSE_ALOGRITHM = TWOSTEP). Type: integer; Default: 50. TIKHONOW_OMEGA¶. The shift applied",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodir_options_c/module__dcft-1.html:2144,energy,energy,2144,psi4manual/4.0b3/autodir_options_c/module__dcft-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/module__dcft-1.html,4,['energy'],['energy']
Energy Efficiency,"n’s “biorthogonal” JCP paper. pywrap-opt-sowreap; Finite difference optimization, run in sow/reap mode. soscf-ref; Triple and Singlet Oxygen energy SOSCF, also tests non-symmetric density matrices. basis-ecp; check mixing ECP and non-ECP orbital/fitting basis sets in a session. dct2; DC-06 calculation for the He dimer. This performs a two-step update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the MO Basis. cc36; CC2(RHF)/cc-pVDZ energy of H2O. dct-grad1; Various DCT analytic gradients for the O2 molecule with 6-31G basis set. sapt-compare; SAPT0 aug-cc-pVDZ computation of the water-water interaction energy, using the three SAPT codes. cc37; CC2(UHF)/cc-pVDZ energy of H2O+. dft-freq-analytic; Analytic SVWN frequencies, compared to finite difference values. dfmp2-freq2; DF-MP2 frequency by difference of energies for H2O. cepa1; cc-pvdz H2O Test CEPA(1) Energy. omp2-grad1; OMP2 cc-pVDZ gradient for the H2O molecule. dfcasscf-fzc-sp; CASSCF/6-31G** energy point. ao-dfcasscf-sp; CASSCF/6-31G** energy point. dft-b2plyp; Double-hybrid density functional B2PYLP. Reproduces portion of Table I in S. Grimme’s J. Chem. Phys 124 034108 (2006) paper defining the functional. dfmp2-2; Density fitted MP2 energy of H2, using density fitted reference and automatic looping over cc-pVDZ and cc-pVTZ basis sets. Results are tabulated using the built in table functions by using the default options and by specifiying the format. scf-upcast-custom-basis; test scf castup with custom basis sets. cc25; Single point gradient of 1-2B2 state of H2O+ with EOM-CCSD. dft-pruning; Tests all grid pruning options available and screening of small weights. Check against grid size. psithon1; Spectroscopic constants of H2, and the full ci cc-pVTZ level of theory. mbis-4; MBIS calculation on NaCl. mp2-grad1; MP2 cc-pVDZ gradient for the H2O molecule. scf3; File retention, docc, socc, and bond distances specified explicitly. dfomp2-4; OMP2 cc-pVDZ energy for ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html:40249,energy,energy,40249,psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"o Default. DOCC (MCSCF); MCSCF — The number of doubly occupied orbitals, per irrep. Type: array; Default: No Default. DOMAIN_PRINT (CIS); CIS — Do ?. Type: boolean; Default: false. DOMAIN_PRINT_EXIT (LMP2); LMP2 — Do exit after printing the domains?. Type: boolean; Default: false. DOMAINS (CIS); CIS —. Type: array; Default: No Default. E_CONVERGENCE (CCEOM); CCEOM — Convergence criterion for excitation energy (change) in the Davidson algorithm for CC-EOM. Type: conv double; Default: 1e-8. E_CONVERGENCE (DETCI); DETCI — Convergence criterion for energy. Type: conv double; Default: 1e-6. E_CONVERGENCE (LMP2); LMP2 — Convergence criterion for energy (change). Type: conv double; Default: 1e-7. E_CONVERGENCE (MCSCF); MCSCF — Convergence criterion for energy. Type: conv double; Default: 1e-8. E_CONVERGENCE (MRCC); MRCC — This becomes tol (option #16) in fort.56. Type: conv double; Default: 1e-8. E_CONVERGENCE (OMP2); OMP2 —. Type: conv double; Default: 1e-8. E_CONVERGENCE (PSIMRCC); PSIMRCC — Convergence criterion for energy. Type: conv double; Default: 1e-9. E_CONVERGENCE (SAPT); SAPT — Convergence criterion for energy (change) in the SAPT term during solution of the CPHF equations. Type: conv double; Default: 1e-10. E_CONVERGENCE (SCF); SCF — Convergence criterion for SCF energy. Type: conv double; Default: 1e-8. EOM_GUESS (CCEOM); CCEOM — Specifies a set of single-excitation guess vectors for the EOM-CC procedure. If EOM_GUESS = SINGLES, the guess will be taken from the singles-singles block of the similarity-transformed Hamiltonian, Hbar. If EOM_GUESS = DISK, guess vectors from a previous computation will be read from disk. If EOM_GUESS = INPUT, guess vectors will be specified in user input. The latter method is not currently available. Type: string; Possible Values: SINGLES, DISK, INPUT; Default: SINGLES. EOM_REFERENCE (CCEOM); CCEOM —. Type: string; Possible Values: RHF, ROHF, UHF; Default: RHF. EOM_REFERENCE (CCHBAR); CCHBAR —. Type: string; Default: RHF. EOM_REFERE",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodoc_glossary_options_c-1.html:28054,energy,energy,28054,psi4manual/4.0b2/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodoc_glossary_options_c-1.html,2,['energy'],['energy']
Energy Efficiency,"o an antisymmetric N-electron wavefunction. Unfortunately, no; simple set of necessary and sufficient N-representability conditions are known,; and some of the known conditions are not easily imposed. In addition, the lack; of separability of the density matrices may result in the loss of; size-consistency and size-extensivity. In DCT, one takes a different route and; replaces \(\boldsymbol{\gamma_2}\) in favor of its two-particle density cumulant:. \[\lambda_{pq}^{rs} = \gamma_{pq}^{rs} - \gamma_p^r \gamma_q^s + \gamma_p^s \gamma_q^r\]; The one-particle density matrix is separated into its idempotent part; \(\boldsymbol{\kappa}\) and a correction \(\boldsymbol{\tau}\):. \[\gamma_p^q = \kappa_p^q + \tau_p^q\]; The idempotent part of \(\boldsymbol{\gamma_1}\) corresponds to a mean-field Hartree–Fock-like density,; while the non-idempotent correction \(\boldsymbol{\tau}\); depends on the density cumulant and describes the electron correlation effects.; Inserting the above two equations into the energy expression, we obtain:. \[E_{DCT} = \frac{1}{2} \left( h_p^q + f_p^q \right) \gamma_q^p + \frac{1}{4} \bar{g}_{pq}^{rs} \lambda_{rs}^{pq}\]; where the antisymmetrized two-electron integrals and the generalized Fock operator; matrix elements were defined as follows:. \[\bar{g}_{pq}^{rs} = g_{pq}^{rs} - g_{pq}^{sr}\]. \[f_p^q = h_p^q + \bar{g}_{pr}^{qs} \gamma_{s}^{r}\]; Energy functional \(E_{DCT}\) has several important properties. First,; the energy is now a function of two sets of independent parameters, the; idempotent part of \(\boldsymbol{\gamma_1}\) (\(\boldsymbol{\kappa}\)) and the density cumulant; (\(\boldsymbol{\lambda_2}\)). As a result, the energy functional is Hermitian,; which is important for the evaluation of the molecular properties. The additive; separability of the density cumulant guarantees that all of the DCT methods; are size-extensive and size-consistent. Furthermore, the N-representability; problem is now greatly simplified, because the idempotent",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/dct-1.html:2419,energy,energy,2419,psi4manual/1.4.0/dct-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/dct-1.html,9,['energy'],['energy']
Energy Efficiency,"o analysis of several water isotopologs. Demonstrates Hessian reuse for different temperatures, pressures, and isotopologs. remp-energy2; integral conventional unrestricted REMP/cc-pVDZ energies for the H2O+ molecule. results were independently verified against the initial wavels implementation. props2; DF-SCF cc-pVDZ of benzene-hydronium ion, scanning the dissociation coordinate with Python’s built-in loop mechanism. The geometry is specified by a Z-matrix with dummy atoms, fixed parameters, updated parameters, and separate charge/multiplicity specifiers for each monomer. One-electron properties computed for dimer and one monomer. olccd-freq1; OLCCD cc-pVDZ freqs for C2H2. mp2-grad2; MP2 cc-pVDZ gradient for the NO radical. scf-guess-read1; Sample UHF/cc-pVDZ H2O computation on a doublet cation, using RHF/cc-pVDZ orbitals for the closed-shell neutral as a guess. cepa-module; routing check on lccd, lccsd, cepa(0). scf4; RHF cc-pVDZ energy for water, automatically scanning the symmetric stretch and bending coordinates using Python’s built-in loop mechanisms. The geometry is specified using a Z-matrix with variables that are updated during the potential energy surface scan, and then the same procedure is performed using polar coordinates, converted to Cartesian coordinates. dfccdl1; DF-CCDL cc-pVDZ energy for the H2O molecule. cc13b; Tests RHF CCSD(T)gradients. nbody-hessian; Computation of VMFC-corrected HF dimer Hessian. sapt-compare; SAPT0 aug-cc-pVDZ computation of the water-water interaction energy, using the three SAPT codes. sapt-exch-ind30-inf; SAPT2+3 with S^inf exch-ind30 Geometries taken from the S66x10 database, the shortest-range point (R = 0.7 R_e). pywrap-molecule; Check that C++ Molecule class and qcdb molecule class are reading molecule input strings identically. dft-dens-cut; LibXC density screening test. Tests empty, C-only, X-only and XC superfunctionals. ‘super_mix’ showcases how to use different screening values for X and C parts. SCF will fail o",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html:29117,energy,energy,29117,psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"o and testing purposes. dfmp2-ecp; Ne-Xe dimer MP2 energies with ECP, with electrons correlated then frozen. sapt-exch-ind-inf; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. mbis-4; MBIS calculation on NaCl. cisd-opt-fd; H2O CISD/6-31G** Optimize Geometry by Energies. dfmp2-grad2; DF-MP2 cc-pVDZ gradient for the NO molecule. dfomp3-grad1; DF-OMP3 cc-pVDZ gradients for the H2O molecule. dfomp2-3; OMP2 cc-pVDZ energy for the H2O molecule. pywrap-cbs1; Various basis set extrapolation tests. dct-grad1; Various DCT analytic gradients for the O2 molecule with 6-31G basis set. opt-full-hess-every; SCF/sto-3g optimization with a hessian every step. dct10; The multiple guesses for DCT amplitudes for ODC-12. mom-h2o-3; MOM excitation from LUMO HOMO+3. isapt1; This test case shows an example of running and analyzing an FI-SAPT0/jun-cc-pvdz computation for 2,4-pentanediol (targeting the intramolecular hydrogen bond between the two hydroxyl groups). dfccsdat1; DF-CCSD(AT) cc-pVDZ energy for the H2O molecule. casscf-sa-sp; Example of state-averaged CASSCF for the C2 molecule see C. D. Sherrill and P. Piecuch, J. Chem. Phys. 122, 124104 (2005). pywrap-checkrun-rhf; This checks that all energy methods can run with a minimal input and set symmetry. nbo; Generation of NBO file. cc48; reproduces dipole moments in J.F. Stanton’s “biorthogonal” JCP paper. fsapt1; This test case shows an example of running and analyzing a standard F-SAPT0/jun-cc-pvdz procedure for phenol dimer from the S22 database. scf-hess3; CONV SCF 6-31G analytical vs finite-difference tests Tests UHF hessian code for Ca != Cb. dft3; DFT integral algorithms test, performing w-B97 RKS and UKS computations on water and its cation, using all of the different integral algorithms. This tests both the ERI and ERF integrals. mbis-5; MBIS calculation on ZnO. cc2; 6-31G** H2O CCSD optimization by energies, with Z-Matrix input. fd-gradient; SCF STO-3G finite-difference tests. opt15; 6-31G(d) optimization of",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html:36920,energy,energy,36920,psi4manual/master/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"o another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None, *, quiet=False)¶. Parameters; quiet (bool) – . c1_deep_copy(self: psi4.core.Wavefunction, basis: psi4.core.BasisSet) → psi4.core.Wavefunction¶; Returns a new wavefunction with internal data converted to \(C_1\) symmetry, using pre-c1-constructed basis. check_phases(self: psi4.core.HF) → None¶; docstring. clear_external_cpscf_perturbations(self: psi4.core.HF) → None¶; Clear private external_cpscf_perturbations map. clear_external_potentials(self: psi4.core.HF) → None¶; Clear private external_potentials list. compute_E(self: psi4.core.HF) → float¶; docstring. compute_energy()¶; Base class Wavefunction requires this function. Here it is; simply a wrapper around initialize(), iterations(), finalize_energy(). It; returns the SCF energy computed by finalize_energy(). compute_fvpi(self: psi4.core.HF) → None¶; Update number of frozen virtuals. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. compute_initial_E(self: psi4.core.HF) → float¶; docstring. compute_orbital_gradient(self: psi4.core.HF, arg0: bool, arg1: int) → float¶; docstring. compute_spin_contamination(self: psi4.core.HF) → None¶; docstring. cphf_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix]) → List[psi4.core.Matrix]¶; CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self: psi4.core.HF) → bool¶; Adds occupied guess alpha orbitals. cphf_solve(self: psi4.core.HF, x_vec: List[psi4.core.Matrix], conv_tol: float, max_iter: int, print_lvl: int = 2) → List[psi4.core.Matrix]¶; Solves the CPHF equations for a given set of x vectors. damping_update(self: psi4.core.HF, arg0: float) →",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.HF.html:18161,energy,energy,18161,psi4manual/1.6.x/api/psi4.core.HF.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.HF.html,2,['energy'],['energy']
Energy Efficiency,"o be; run via pytest. Running a limited number of “smoke” tests is; generally sufficient to verify an installation. From the executable; # smoke tests only in serial; psi4 --test; # smoke tests only in parallel; psi4 --test -n`getconf _NPROCESSORS_ONLN`; # most tests; psi4 --test full. From the library (PSI4 must be detectable as a Python; module. See setup at How to configure paths for PsiAPI; if needed.); # smoke tests only; python -c ""import psi4; psi4.test('smoke')""; # most tests; python -c ""import psi4; psi4.test()"". From pytest directly. If package pytest-xdist is installed, can run in parallel.; # smoke tests only; pytest {prefix}/lib/{PYMOD_INSTALL_LIBDIR}/psi4/tests/ -m smoke -n`getconf _NPROCESSORS_ONLN`; # all tests; pytest {prefix}/lib/{PYMOD_INSTALL_LIBDIR}/psi4/tests/ -n`getconf _NPROCESSORS_ONLN`. Output looks something like the below. PASSED in green is good; (means test ran correctly); SKIPPED in yellow is good (means that; not all software required for test is available); XPASS or XFAIL; in yellow is fine (unexpected pass or expected fail happens when we; include tests that need particular conditions (e.g., multiple cores); to run correctly); FAILED in red is bad.; test_addons.py::test_gdma PASSED; test_addons.py::test_mrcc SKIPPED; test_addons.py::test_chemps2 PASSED; test_addons.py::test_dftd3 PASSED; test_addons.py::test_libefp PASSED; test_addons.py::test_pcmsolver PASSED; test_addons.py::test_erd PASSED; test_addons.py::test_simint PASSED; test_addons.py::test_json PASSED; test_addons.py::test_cfour SKIPPED; test_addons.py::test_v2rdm_casscf PASSED; test_addons.py::test_grimme_3c PASSED; test_addons.py::test_dkh PASSED; test_psi4.py::test_psi4_basic PASSED; test_psi4.py::test_psi4_cc PASSED; test_psi4.py::test_psi4_cas PASSED; test_psi4.py::test_psi4_dfmp2 PASSED; test_psi4.py::test_psi4_sapt PASSED; test_psi4.py::test_psi4_scfproperty PASSED. How to refer to Psi4¶; Ways to refer to PSI4 in text, in order of decreasing goodness:. as Psi4 in Opt",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/build_planning-1.html:55511,green,green,55511,psi4manual/1.4.0/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/build_planning-1.html,4,['green'],['green']
Energy Efficiency,"o compute linear response; properties (such as static or frequency-dependent polarizability,; or optical rotation angles) for some models. Excited states can; also be computed by the CC2 and CC3 models, or by EOM-CCSD. Table; CC Methods summarizes these capabilities. This section; describes how to carry out coupled cluster calculations within PSI4.; For higher-order coupled-cluster methods like CCSDT and CCSDTQ, PSI4; can interface to Kállay’s MRCC code (see MRCC).; Solvent effects on energies can be taken into account using the polarizable; continuum model (PCM) in the PTE approximation [Cammi:2009:164104], see; PCM; The following wavefunctions are currently recognized by PSI4 as arguments; to functions like energy(): 'ccsd', 'ccsd(t)', 'a-ccsd(t)', 'cc2',; 'cc3', 'bccd' (CCD with Brueckner orbitals), 'bccd(t)' (CCD(T) with; Brueckner orbitals), 'eom-ccsd', 'eom-cc2' (CC2 for excited states),; 'eom-cc3' (CC3 for excited states). Response properties can be obtained; by calling the function properties() (instead of, for example, energy(),; e.g., properties('ccsd'). There are many sample; coupled cluster inputs provided in psi4/samples.; The various methods supported by the CCENERGY modules in PSI4 are; summarized in Table CC Methods and detailed; (except excited state methods) in Table CCENERGY Capabilities. Even without set qc_module ccenergy,; methods will default to this module, but alternate implementations can; be seen at other modules. Current coupled cluster capabilities of PSI4¶. Method; Reference; Energy; Gradient; Exc. Energies; LR Props. CC2; RHF; Y; Y; Y; Y. UHF; Y; —; —; —. ROHF; Y; —; —; —. CCSD; RHF; Y; Y; Y; Y. UHF; Y; Y; Y; —. ROHF; Y; Y; Y; —. CCSD(T); RHF; Y; Y [4]; n/a; n/a. UHF; Y; Y [4]; n/a; n/a. ROHF; Y; —; n/a; n/a. A-CCSD(T) [5]; RHF; Y; —; n/a; n/a. CC3; RHF; Y; —; Y; —. UHF; Y; —; Y; —. ROHF; Y; —; Y; —. CCD; Brueckner; Y; —; —; —. CCD(T); Brueckner; Y; —; n/a; n/a. Detailed capabilities of CCENERGY and related modules. “✓” runs analytical",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/cc.html:3773,energy,energy,3773,psi4manual/1.8.x/cc.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/cc.html,3,['energy'],['energy']
Energy Efficiency,"o compute linear response; properties (such as static or frequency-dependent polarizability,; or optical rotation angles) for some models. Excited states can; also be computed by the CC2 and CC3 models, or by EOM-CCSD. Table; CC Methods summarizes these capabilities. This section; describes how to carry out coupled cluster calculations within PSI4.; For higher-order coupled-cluster methods like CCSDT and CCSDTQ, PSI4; can interface to Kállay’s MRCC code (see MRCC).; Solvent effects on energies can be taken into account using the polarizable; continuum model (PCM) in the PTE approximation [Cammi:2009:164104], see; PCM; The following wavefunctions are currently recognized by PSI4 as arguments; to functions like energy(): 'ccsd', 'ccsd(t)', 'a-ccsd(t)', 'cc2',; 'cc3', 'bccd' (CCD with Brueckner orbitals), 'bccd(t)' (CCD(T) with; Brueckner orbitals), 'eom-ccsd', 'eom-cc2' (CC2 for excited states),; 'eom-cc3' (CC3 for excited states). Response properties can be obtained; by calling the function properties() (instead of, for example, energy(),; e.g., properties('ccsd'). There are many sample; coupled cluster inputs provided in psi4/samples.; The various methods supported by the CCENERGY modules in PSI4 are; summarized in Table CC Methods and detailed; (except excited state methods) in Table CCENERGY Capabilities. Even without set qc_module ccenergy,; methods will default to this module, but alternate implementations can; be seen at other modules. Current coupled cluster capabilities of PSI4¶. Method; Reference; Energy; Gradient; Exc. Energies; LR Props. CC2; RHF; Y; Y; Y; Y. UHF; Y; —; —; —. ROHF; Y; —; —; —. CCSD; RHF; Y; Y; Y; Y. UHF; Y; Y; Y; —. ROHF; Y; Y; Y; —. CCSD(T); RHF; Y; Y; n/a; n/a. UHF; Y; Y; n/a; n/a. ROHF; Y; —; n/a; n/a. A-CCSD(T) [4]; RHF; Y; —; n/a; n/a. CC3; RHF; Y; —; Y; —. UHF; Y; —; Y; —. ROHF; Y; —; Y; —. CCD; Brueckner; Y; —; —; —. CCD(T); Brueckner; Y; —; n/a; n/a. Detailed capabilities of CCENERGY and related modules. “✓” runs analytically. Sing",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/cc.html:3771,energy,energy,3771,psi4manual/1.7.x/cc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/cc.html,1,['energy'],['energy']
Energy Efficiency,"o control the; formatting of the tables can be found in the sample input files provided; see; Appendix Test Suite and Sample Inputs for a complete listing. Python Wrappers¶; The Python foundations of the PSI4 driver and Psithon syntax permit; many commonly performed post-processing procedures to be integrated into; the PSI4 suite.; As seen in the neon dimer example from the tutorial section,; the nbody_gufunc() wrapper provides automatic computation of; counterpoise-corrected interaction energies between two molecules. For; example,; energy('mp2', bsse_type='cp'). will compute the counterpoise-corrected density-fitted MP2 interaction energy; between two molecules.; PSI4 also provides the cbs() wrapper,; which automatically computes a complete-basis-set extrapolation (and; automatically sets up the computations with different basis sets required to; do the extrapolation). For example,:; # all equivalent. cbs('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). energy('mp2/cc-pv[dt]z'). will compute a 2-point Helgaker extrapolation of the correlation energy; using the cc-pVDZ and cc-pVTZ basis sets (with method MP2) and add this; extrapolated correlation energy to the Hartree–Fock energy in the; largest basis (cc-pVTZ). cbs() can; either be called directly, as in the first example, or the convenience; syntax of the equivalent second example can be used.; Another very useful and powerful feature of PSI4 is the ability; to compute results on entire databases of molecules at a time,; as provided by the database() wrapper. For example,:; database('mp2', 'S22', cp=1, benchmark='S22B'). will perform DF-MP2 counterpoise-corrected interaction energies; (cp=1) on all members of Hobza’s S22 database set of van der Waals; dimers, and then compare the results against the S22B benchmark energies.; Built-in databases include S22, A24, HTBH, HBC6, HSG, S22by5, S66, JSCH,; NCB31, S66by8, and NBC10, among others.; These wrapper functions are discussed separately in; Psit",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/psithoninput-1.html:14020,energy,energy,14020,psi4manual/1.4.0/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/psithoninput-1.html,4,['energy'],['energy']
Energy Efficiency,"o frozen core. dft-grad-lr1; wB97X-D cc-pVDZ gradient of S22 HCN update df/pk_ref values due to new BraggSlater radii. scf-cholesky-basis; incremental Cholesky filtered SCF. scf-guess-read3; Test if the the guess read in the same basis converges. extern3; External potential calculation with one Ghost atom and one point charge at the same position. mbis-3; MBIS calculation on OH radical. dfomp2p5-2; DF-OMP2.5 cc-pVDZ energy for the H2O+ cation. isapt-charged; This test case shows an example of running the I-SAPT0/aug-cc-pVDZ computation for a positively charged system, illustrating the cation-pi interaction. The SIAO1 link partitioning algorithm is used. The system is taken from http://dx.doi.org/10.1016/j.comptc.2014.02.008. opt4; SCF cc-pVTZ geometry optimzation, with Z-matrix input. opt14; 6-31G(d) optimization of SF4 starting from linear bond angle that is not linear in the optimized structure but is in a symmetry plane of the molecule. soscf-ref; Triple and Singlet Oxygen energy SOSCF, also tests non-symmetric density matrices. opt2-fd; SCF DZ allene geometry optimzation, with Cartesian input. x2c2; Test of SFX2C-1e on Water cc-pVDZ-DK. In this test the Dirac equation is solved in the uncontracted cc-pVDZ-DK basis. The reference numbers are from Lan Cheng’s implementation in Cfour. props2; DF-SCF cc-pVDZ of benzene-hydronium ion, scanning the dissociation coordinate with Python’s built-in loop mechanism. The geometry is specified by a Z-matrix with dummy atoms, fixed parameters, updated parameters, and separate charge/multiplicity specifiers for each monomer. One-electron properties computed for dimer and one monomer. scf7; Tests SCF gradient in the presence of a dipole field. cc55; EOM-CCSD/6-31g excited state transition data for water with two excited states per irrep. fd-freq-gradient; SCF STO-3G finite-differences frequencies from gradients for H2O. psimrcc-fd-freq1; Mk-MRCCSD single point. \(^3 \Sigma ^-\) O2 state described using the Ms = 0 component of th",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html:21816,energy,energy,21816,psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"o hold. A translation of this ungainly equation to example [5] below is as; follows. In words, this is a double- and triple-zeta 2-point; Helgaker-extrapolated CCSD(T) coupled-cluster correlation correction; appended to a triple- and quadruple-zeta 2-point; Helgaker-extrapolated MP2 correlation energy appended to a SCF/aug-cc-pVQZ; reference energy. Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy.; The cbs() function requires, at a minimum, name='scf' and scf_basis; keywords to be specified for reference-step only jobs and name and; corl_basis keywords for correlated jobs.; The following energy methods have been set up for cbs(). scf; df-scf. mp2; df-mp2. cc2; ccsd. bccd; cc3. ccsd(t); fci. Parameters:; name (string) – 'scf' || 'ccsd' || etc.; First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be 'scf'. Overruled if stage_wfn keywords supplied. corl_wfn (string) – 'mp2' || 'ccsd(t)' || etc.; Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with name or as the unlabeled; first argument to the function. delta_wfn (string) – 'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. delta_wfn_lesser (string) – 'mp2' || 'ccsd' || etc.; Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. delta2_wfn (string) – 'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. delta2_wfn_lesser (string) – 'mp2' || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtain",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/cbs-1.html:2732,energy,energy,2732,psi4manual/4.0b2/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/cbs-1.html,2,['energy'],['energy']
Energy Efficiency,"o make alanine, then DF-SCF energy calculation with the cc-pVDZ basis set. cc9a; ROHF-CCSD(T) cc-pVDZ energy for the state of the CN radical, with Z-matrix input. dfmp2-2; Density fitted MP2 energy of H2, using density fitted reference and automatic looping over cc-pVDZ and cc-pVTZ basis sets. Results are tabulated using the built in table functions by using the default options and by specifiying the format. omp2-grad1; OMP2 cc-pVDZ gradient for the H2O molecule. cc1; RHF-CCSD 6-31G** all-electron optimization of the H2O molecule. scf4; RHF cc-pVDZ energy for water, automatically scanning the symmetric stretch and bending coordinates using Python’s built-in loop mechanisms. The geometry is apecified using a Z-matrix with variables that are updated during the potential energy surface scan, and then the same procedure is performed using polar coordinates, converted to Cartesian coordinates. cisd-h2o-clpse; 6-31G** H2O Test CISD Energy Point with subspace collapse. omp2-3; OMP2 cc-pVDZ energy for the NO radical. cepa1; cc-pvdz H2O Test CEPA(1) Energy. cc24; Single point gradient of 1-2B1 state of H2O+ with EOM-CCSD. dftd3-grad; DF-BP86-D2 cc-pVDZ frozen core gradient of S22 HCN, calling Grimme’s dftd3 program for -D2 gradients. cc14; ROHF-CCSD/cc-pVDZ CH2 geometry optimization via analytic gradients. mp3-grad2; MP3 cc-pVDZ gradient for the NO radical. cc29; CCSD/cc-pVDZ optical rotation calculation (both gauges) on Cartesian H2O2. dfscf-bz2; Benzene Dimer DF-HF/cc-pVDZ. psithon1; Spectroscopic constants of H2, and the full ci cc-pVTZ level of theory. ocepa3; OCEPA cc-pVDZ energy with ROHF initial guess for the NO radical. matrix1; An example of using BLAS and LAPACK calls directly from the Psi input file, demonstrating matrix multiplication, eigendecomposition, Cholesky decomposition and LU decomposition. These operations are performed on vectors and matrices provided from the Psi library. cc36; CC2(RHF)/cc-pVDZ energy of H2O. castup2; SCF with various combinations of ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodoc_testsuite-1.html:20745,energy,energy,20745,psi4manual/4.0b5/autodoc_testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodoc_testsuite-1.html,4,['energy'],['energy']
Energy Efficiency,"o otherwise. This becomes nsing (option #2) in fort.56. Type: integer; Default: 1. MRCC_NUM_TRIPLET_ROOTS (MRCC)¶MRCC — Number of triplet roots. (Strictly speaking number of of roots with \(M_s=0\) and S is odd.) See notes at option MRCC_NUM_SINGLET_ROOTS. This becomes ntrip (option #3) in fort.56. Type: integer; Default: 0. MRCC_OMP_NUM_THREADS (MRCC)¶MRCC (Expert) — Sets the OMP_NUM_THREADS environment variable before calling MRCC. If the environment variable OMP_NUM_THREADS is set prior to calling Psi4 then that value is used. When set, this option overrides everything. Be aware the -n command-line option described in section Threading does not affect MRCC. Type: integer; Default: 1. MRCC_RESTART (MRCC)¶MRCC (Expert) — The program restarts from the previously calculated parameters if it is 1. In case it is 2, the program executes automatically the lower-level calculations of the same type consecutively (e.g., CCSD, CCSDT, and CCSDTQ if CCSDTQ is requested) and restarts each calculation from the previous one (rest=2 is available only for energy calculations). Currently, only a value of 0 and 2 are supported. This becomes rest (option #4) in fort.56. Type: integer; Default: 0. MS0 (DETCI)¶DETCI — Do use the \(M_s = 0\) component of the state? Defaults to TRUE if closed-shell and FALSE otherwise. Related to the S option. Type: boolean; Default: false. NAT_ORBS (DETCI)¶DETCI — Do compute natural orbitals?. Type: boolean; Default: false. NAT_ORBS (DFOCC)¶DFOCC — Do compute natural orbitals?. Type: boolean; Default: false. NAT_ORBS (FNOCC)¶FNOCC — Do use MP2 NOs to truncate virtual space for QCISD/CCSD and (T)?. Type: boolean; Default: false. NAT_ORBS (OCC)¶OCC — Do compute natural orbitals?. Type: boolean; Default: false. NAT_ORBS_T2 (SAPT)¶SAPT — Do use MP2 natural orbital approximations for the \(v^4\) block of two-electron integrals in the evaluation of second-order T2 amplitudes? Recommended true for all SAPT computations. Type: boolean; Default: true. NAT_ORBS_T3 ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html:173977,energy,energy,173977,psi4manual/1.4.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html,9,['energy'],['energy']
Energy Efficiency,"o preferentially use a particular gcp compilation, simply adjust its; position in the path environment variables. Running gCP¶; At present there is a limited interface to gCP that is used; only to implement the “HF-3c” [Sure:2013:1672] and “PBEh-3c”; [Grimme:2015:054107] methods (both energy and gradient). The DFTD3 executable must also be available for these methods to; run. Unlike every other method in PSI4, if a basis set has not been; set, these will default to their intended basis sets: MINIX for HF-3c; and def2-mSVP for PBEh-3c. If a basis has previously been set, but you; want to use the default basis, use the slash syntax to “empty” the basis; option for the scope of the current calculation, energy(""hf3c/"").; A few practical examples:. HF-3c single point with default minix basis; 1energy('hf3c'). PBEh-3c optimization with default def2-mSVP basis; 1optimize('pbeh3c'). HF-3c with non-standard basis; 1; 2set basis cc-pvdz; energy('hf3c'). PBEh-3c with default basis after basis set; 1; 2set basis cc-pvdz; energy('pbeh3c/'). If only BSSE/basis set corrections (rather than total energies) are of; interest, the gcp program can be run independently of the scf; through the python function run_gcp(). (This function; is the same PSI4/gcp interface that is called during an scf job.); This route is much faster than running a HF or DFT energy.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10molecule nene {; Ne; Ne 1 2.0; }. nene.update_geometry(). >>> E, G = nene.run_gcp('hf3c'). >>> E, G = nene.run_gcp(func='HF3c', verbose=True). qcdb.interface_gcp.run_gcp(self, func=None, dertype=None, verbose=False)[source]¶; Function to call Grimme’s GCP program; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp; to compute an a posteriori geometrical BSSE correction to self for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, func. Returns energy if dertype is 0, gradient; if dertype is 1, else tuple of energy and gradient if dertype; unspecified.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/gcp-1.html:2309,energy,energy,2309,psi4manual/1.3.2/gcp-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/gcp-1.html,2,['energy'],['energy']
Energy Efficiency,"o preferentially use a particular gcp compilation, simply adjust its; position in the path environment variables. Running gCP¶; At present there is a limited interface to gCP that is used; only to implement the “HF-3c” [Sure:2013:1672] and “PBEh-3c”; [Grimme:2015:054107] methods (both energy and gradient). The DFTD3 executable must also be available for these methods to; run. Unlike every other method in PSI4, if a basis set has not been; set, these will default to their intended basis sets: MINIX for HF-3c; and def2-mSVP for PBEh-3c. If a basis has previously been set, but you; want to use the default basis, use the slash syntax to “empty” the basis; option for the scope of the current calculation, energy(""hf3c/"").; A few practical examples:. HF-3c single point with default minix basis; 1energy('hf3c'). PBEh-3c optimization with default def2-mSVP basis; 1optimize('pbeh3c'). HF-3c with non-standard basis; 1; 2set basis cc-pvdz; energy('hf3c'). PBEh-3c with default basis after basis set; 1; 2set basis cc-pvdz; energy('pbeh3c/'). If only BSSE/basis set corrections (rather than total energies) are of; interest, the gcp program can be run independently of the scf; through the python function run_gcp(). (This function; is the same PSI4/gcp interface that is called during an scf job.); This route is much faster than running a HF or DFT energy.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10molecule nene {; Ne; Ne 1 2.0; }. nene.update_geometry(). >>> E, G = nene.run_gcp('hf3c'). >>> E, G = nene.run_gcp(func='HF3c', verbose=True). qcdb.interface_gcp.run_gcp(self, func=None, dertype=None, verbose=False)[source]¶; Function to call Grimme’s dftd3 program (http://toc.uni-muenster.de/DFTD3/); to compute the -D correction of level dashlvl using parameters for; the functional func. The dictionary dashparam can be used to supply; a full set of dispersion parameters in the absense of func or to supply; individual overrides in the presence of func. Returns energy if dertype is 0,; gradient if dertyp",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/gcp-1.html:2150,energy,energy,2150,psi4manual/1.1.0/gcp-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/gcp-1.html,4,['energy'],['energy']
Energy Efficiency,"o response equations; need to be solved, which makes the computation of the analytic gradients very; efficient. Analytic gradients are not available for the three-particle energy; correction \((\lambda_3)\). Methods Summary¶; The table below summarizes current DCT code features:. Method; Available algorithms; Energy; Gradient; Reference. ODC-06; SIMULTANEOUS, QC; Y; Y; RHF/UHF. ODC-12; SIMULTANEOUS, QC; Y; Y; RHF/UHF. ODC-13; SIMULTANEOUS, QC; Y; Y; UHF. \(\mbox{ODC-12$(\lambda_3)$}\); SIMULTANEOUS, QC; Y; N; UHF. \(\mbox{ODC-13$(\lambda_3)$}\); SIMULTANEOUS, QC; Y; N; UHF. DC-06; SIMULTANEOUS, QC, TWOSTEP; Y; Y; UHF. DC-12; SIMULTANEOUS, QC, TWOSTEP; Y; N; UHF. Note that for ODC-06 and ODC-12 REFERENCE RHF is only available for; ALGORITHM SIMULTANEOUS. To compute \((\lambda_3)\) correction,; the THREE_PARTICLE option needs to be set to PERTURBATIVE. Minimal Input¶; Minimal input for the DCT single-point computation looks like this:; molecule {; H; H 1 1.0; }. set basis cc-pvdz. energy('dct'). The energy('dct') call to energy() executes the DCT; module, which will first call the SCF module and perform the SCF computation; with RHF reference to obtain a guess for the DCT orbitals. After SCF is; converged, the program will perform the energy computation using the ODC-12; method. By default, simultaneous algorithm will be used for the solution of; the equations. One can also request to perform geometry; optimization following example below:; molecule {; H; H 1 1.0; }. set basis cc-pvdz. optimize('dct'). The optimize('dct') call will first perform all of the procedures; described above to obtain the ODC-12 energy. After that, the ODC-12 analytic; gradients code will be executed and geometry optimization will be performed. Recommendations¶; Here is a list of recommendations for the DCT module:. Generally, the use of the simultaneous algorithm together with the; AO_BASIS DISK option is recommended (set by default).; In cases when available memory is insufficient, the use o",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/dct-1.html:13194,energy,energy,13194,psi4manual/1.4.0/dct-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/dct-1.html,9,['energy'],['energy']
Energy Efficiency,"o root n within irrep i. DFT; functional labeled if canonical. TD-fctl ROOT 0 (h) -> ROOT n (i) RIGHT EIGENVECTOR BETA¶; The right beta spin eigenvectors of the named method; from ground state, which is in irrep h, to root n, which is in irrep i. DFT; functional labeled if canonical. TD-fctl ROOT 0 -> ROOT n RIGHT EIGENVECTOR BETA - h TRANSITION¶; The right alpha and beta spin eigenvectors of the named method; from ground state to root n, and the transition is of irrep h. DFT; functional labeled if canonical. THERMAL ENERGY¶; Total thermal energy E [E_h] at given temperature. THERMAL ENERGY CORRECTION¶; Sum of electronic, translational, rotational, and vibrational corrections [E_h] to the thermal energy at given temperature. TWO-ELECTRON ENERGY¶; The two-electron energy contribution [E_h] to the total SCF energy.; Quantity \(E_{2e^-}\) in Eq. (4). UNCP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [E_h] considering only two-body interactions,; computed without counterpoise correction.; Related variable CP-CORRECTED 2-BODY INTERACTION ENERGY. \[E_{\text{IE}} = E_{dimer} - \sum_{monomer}^{n}{E_{monomer}^{\text{unCP}}}\]. WIBERG LOWDIN INDICES¶; Property of Wiberg bond indices using orthogonal Löwdin orbitals, (nat, nat). ZAPTn TOTAL ENERGY¶. ZAPTn CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the labeled Z-averaged perturbation theory level.; n is ZAPT perturbation order. ZERO K ENTHALPY¶; Total electronic and zero-point energy [E_h] at 0 [K]. ZPVE¶; Vibrational zero-point energy [E_h] at 0 [K]. 2-BODY PAIRWISE DISPERSION CORRECTION ANALYSIS¶; The interatomic contributions to the dispersion correction [E_h].; Sums to the dispersion energy. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Appendices; PSI Variables by Alpha. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/glossary_psivariables.html:63876,energy,energy,63876,psi4manual/1.8.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/glossary_psivariables.html,5,['energy'],['energy']
Energy Efficiency,"o root n within irrep i. DFT; functional labeled if canonical. TD-fctl ROOT 0 (h) -> ROOT n (i) RIGHT EIGENVECTOR BETA¶; The right beta spin eigenvectors of the named method; from ground state, which is in irrep h, to root n, which is in irrep i. DFT; functional labeled if canonical. TD-fctl ROOT 0 -> ROOT n RIGHT EIGENVECTOR BETA - h TRANSITION¶; The right alpha and beta spin eigenvectors of the named method; from ground state to root n, and the transition is of irrep h. DFT; functional labeled if canonical. THERMAL ENERGY¶; Total thermal energy E [E_h] at given temperature. THERMAL ENERGY CORRECTION¶; Sum of electronic, translational, rotational, and vibrational corrections [E_h] to the thermal energy at given temperature. TWO-ELECTRON ENERGY¶; The two-electron energy contribution [E_h] to the total SCF energy.; Quantity \(E_{2e^-}\) in Eq. (4). UNCP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [E_h] considering only two-body interactions,; computed without counterpoise correction.; Related variable CP-CORRECTED 2-BODY INTERACTION ENERGY. \[E_{\text{IE}} = E_{dimer} - \sum_{monomer}^{n}{E_{monomer}^{\text{unCP}}}\]. WIBERG LOWDIN INDICES¶; Property of Wiberg bond indices using orthogonal Löwdin orbitals, (nat, nat). ZAPTn TOTAL ENERGY¶. ZAPTn CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the labeled Z-averaged perturbation theory level.; n is ZAPT perturbation order. ZERO K ENTHALPY¶; Total electronic and zero-point energy [E_h] at 0 [K]. ZPVE¶; Vibrational zero-point energy [E_h] at 0 [K]. 2-BODY PAIRWISE DISPERSION CORRECTION ANALYSIS¶; The interatomic contributions to the dispersion correction [E_h].; Sums to the dispersion energy. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Appendices; PSI Variables by Alpha. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/glossary_psivariables.html:63876,energy,energy,63876,psi4manual/1.9.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/glossary_psivariables.html,5,['energy'],['energy']
Energy Efficiency,"o the early density updates. 0 will result in a full update, 100 will completely stall the update. A value around 20 (which corresponds to 20% of the previous iteration’s density being mixed into the current density) could help to solve problems with oscillatory convergence. Type: double; Default: 100.0. DEBUG (CPHF); CPHF — The amount of debug information printed to the output file. Type: integer; Default: 0. DEBUG (GLOBALS); GLOBALS (Expert) — The amount of information to print to the output file. Type: integer; Default: 0. DELETE_AO (TRANSQT); TRANSQT — Don’t ?. Type: boolean; Default: true. DELETE_RESTR_DOCC (TRANSQT); TRANSQT — Don’t ?. Type: boolean; Default: true. DELETE_TEI (TRANSQT2); TRANSQT2 — Boolean to delete the SO-basis two-electron integral file after the transformation. Type: boolean; Default: true. DELETE_TPDM (TRANSQT); TRANSQT — Don’t ?. Type: boolean; Default: true. DENOMINATOR_ALGORITHM (SAPT); SAPT — Denominator algorithm for PT methods. Laplace transformations are slightly more efficient. Type: string; Possible Values: LAPLACE, CHOLESKY; Default: LAPLACE. DENOMINATOR_DELTA (SAPT); SAPT — Maximum error allowed (Max error norm in Delta tensor) in the approximate energy denominators employed for most of the and evaluation. Type: double; Default: 1.0e-6. DERTYPE (GLOBALS); GLOBALS (Expert) — Derivative level. Type: string; Possible Values: NONE, FIRST, SECOND, RESPONSE; Default: NONE. DETCI_FREEZE_CORE (DETCI); DETCI — Do freeze core orbitals?. Type: boolean; Default: true. DF_BASIS_ELST (SAPT); SAPT — Auxiliary basis set for SAPT Elst10 and Exch10 density fitting computations, may be important if heavier elements are involved. Defaults to BASIS-RI. Type: string; Possible Values: basis string; Default: No Default. DF_BASIS_MP2 (DFMP2); DFMP2 — Auxiliary basis set for MP2 density fitting computations. Defaults to BASIS-RI. Type: string; Possible Values: basis string; Default: No Default. DF_BASIS_MP2 (LMP2); LMP2 — Auxiliary basis set for MP2 densi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodoc_glossary_options_c-1.html:17425,efficient,efficient,17425,psi4manual/4.0b2/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodoc_glossary_options_c-1.html,2,['efficient'],['efficient']
Energy Efficiency,"o the second; list of minimum number of calculations which will actually be run.; Naive listing of computations required.; scf / aug-cc-pvqz for SCF TOTAL ENERGY; mp2 / aug-cc-pvtz for MP2 CORRELATION ENERGY; mp2 / aug-cc-pvqz for MP2 CORRELATION ENERGY; ccsd(t) / aug-cc-pvdz for CCSD(T) CORRELATION ENERGY; ccsd(t) / aug-cc-pvtz for CCSD(T) CORRELATION ENERGY; mp2 / aug-cc-pvdz for MP2 CORRELATION ENERGY; mp2 / aug-cc-pvtz for MP2 CORRELATION ENERGY. Enlightened listing of computations required.; mp2 / aug-cc-pvqz for MP2 CORRELATION ENERGY; ccsd(t) / aug-cc-pvdz for CCSD(T) CORRELATION ENERGY; ccsd(t) / aug-cc-pvtz for CCSD(T) CORRELATION ENERGY. At the end of a cbs() job is printed a summary section like the one below. First,; in the components section, are listed the results for each model chemistry available, whether; required for the cbs job (*) or not. Next, in the stages section, are listed the results for; each extrapolation. The energies of this section must be dotted with the weightings in column Wt; to get the total cbs energy. Finally, in the CBS section, are listed the results for each stage; of the cbs procedure. The stage energies of this section sum outright to the total cbs energy.; ==> Components <==. ----------------------------------------------------------------------------------; Method / Basis Rqd Energy [H] Variable; ----------------------------------------------------------------------------------; scf / aug-cc-pvqz * -1.11916375 SCF TOTAL ENERGY; mp2 / aug-cc-pvqz * -0.03407997 MP2 CORRELATION ENERGY; scf / aug-cc-pvdz -1.11662884 SCF TOTAL ENERGY; mp2 / aug-cc-pvdz * -0.02881480 MP2 CORRELATION ENERGY; ccsd(t) / aug-cc-pvdz * -0.03893812 CCSD(T) CORRELATION ENERGY; ccsd / aug-cc-pvdz -0.03893812 CCSD CORRELATION ENERGY; scf / aug-cc-pvtz -1.11881134 SCF TOTAL ENERGY; mp2 / aug-cc-pvtz * -0.03288936 MP2 CORRELATION ENERGY; ccsd(t) / aug-cc-pvtz * -0.04201004 CCSD(T) CORRELATION ENERGY; ccsd / aug-cc-pvtz -0.04201004 CCSD CORRELATION ENERGY; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/cbs-1.html:13181,energy,energy,13181,psi4manual/1.0.0/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/cbs-1.html,19,['energy'],['energy']
Energy Efficiency,o() psi4.core.DFHelper method. set_tei_already_presorted() psi4.core.IntegralTransform method. set_title() psi4.core.OEProp method. set_tpdm_already_presorted() psi4.core.IntegralTransform method. set_tpdm_presorted() psi4.core.Deriv method. set_tweak() psi4.core.LibXCFunctional method. set_units() psi4.core.Molecule method. set_variable() in module psi4.core. psi4.core.Molecule method. psi4.core.Wavefunction method. set_view() psi4.driver.p4util.InPsight method. set_vv10_b() psi4.core.SuperFunctional method. set_vv10_c() psi4.core.SuperFunctional method. set_wcombine() psi4.core.JK method. set_write_dpd_so_tpdm() psi4.core.IntegralTransform method. set_x_alpha() psi4.core.SuperFunctional method. set_x_beta() psi4.core.SuperFunctional method. set_x_omega() psi4.core.SuperFunctional method. set_xclib_description() psi4.core.SuperFunctional method. setName() psi4.core.ExternalPotential method. setting. ; keywords anharmonicity(). keywords cbs(). keywords cp. keywords database(). keywords energy(). keywords frequency(). keywords general. keywords molecule. keywords optimize(). keywords properties(). keywords vmfc. SF_RESTRICT (DETCI). shallow_copy() psi4.core.Wavefunction method. shape psi4.core.Matrix attribute. psi4.core.Vector attribute. shared_object() psi4.core.IO static method. psi4.core.IOManager static method. shell() psi4.core.BasisSet method. shell_extents() psi4.core.BasisExtents method. shell_on_center() psi4.core.BasisSet method. shell_significant() psi4.core.ERISieve method. psi4.core.TwoBodyAOInt method. psi4.core.TwoElectronInt method. shell_to_ao_function() psi4.core.BasisSet method. shell_to_basis_function() psi4.core.BasisSet method. shell_to_center() psi4.core.BasisSet method. ShellInfo class in psi4.core. shells_iterator() psi4.core.IntegralFactory method. shells_local_to_global() psi4.core.BlockOPoints method. sherrill_gold_standard() in module psi4.driver.aliases. shift() psi4.core.CIVector method. sigma() psi4.core.CIWavefunction method. SIGMA_OV,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/genindex.html:114296,energy,energy,114296,psi4manual/1.8.x/genindex.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/genindex.html,1,['energy'],['energy']
Energy Efficiency,"o). compute_dict = {; 'all': compute_list,; 'cp': cp_compute_list,; 'nocp': nocp_compute_list,; 'vmfc_compute': vmfc_compute_list,; 'vmfc_levels': vmfc_level_list; }; return compute_dict. def assemble_nbody_components(; ptype: DriverEnum,; component_results: Dict[str, Union[float, np.ndarray]],; metadata: Dict[str, Any],; ) -> Dict[str, Any]:; """"""Assembles N-body components for a single derivative level and a single model chemistry level into interaction quantities according to requested BSSE treatment(s). Parameters; ----------; ptype; Derivative level of component results to assemble. Matters mostly for scalar vs. array and array dimensions.; component_results; Dictionary with keys ""mc_(frag, bas)"" and values e/g/H computed component results according to *ptype*.; metadata; Dictionary of N-body metadata. Items described below.; Later, assemble_nbody_components should become a class function and the below are simply class member data.; quiet : bool; See class field. Whether to print/log energy summaries. Default True. False used by multilevel to suppress per-mc-level printing.; nfragments : int; See class field. Number of distinct fragments comprising the full molecular supersystem.; Formerly max_frag; return_total_data : bool; See class field. Whether the total data (e/g/H) of the molecular system has been requested, as opposed to interaction data.; max_nbody : int; See class field. Maximum number of bodies to include in the many-body treatment.""; embedding_charges : bool; Whether embedding charges are present. Used to NaN the output printing rather than print bad numbers.; molecule : psi4.core.Molecule; See class field. Used to count atoms in fragments.; nbodies_per_mc_level: List[List[Union[int, Literal[""supersystem""]]]]; See class field. Distribution of active n-body levels among model chemistry levels.; Formerly nbody_list; bsse_type : List[BsseEnum]; See class field. Requested BSSE treatments. First in list determines which interaction or total energy/gradient",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html:20823,energy,energy,20823,psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html,10,['energy'],['energy']
Energy Efficiency,"o; DFT FUNCTIONAL TOTAL ENERGY. DFT XC ENERGY¶; The functional energy contribution [H] to the total SCF energy (DFT only).; Quantity in Eqs. (3) and (1). DISPERSION CORRECTION ENERGY¶; The dispersion correction [H] appended to an underlying functional; when a DFT-D method is requested. Quantity ; in Eqs. (3) and (1). DOUBLE-HYBRID CORRECTION ENERGY¶; The scaled MP2 correlation energy correction [H] appended to an; underlying functional when a DH-DFT method is requested.; Quantity in Eq. (1). FCI TOTAL ENERGY¶. FCI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the full configuration interaction level of theory. HF TOTAL ENERGY¶; The total electronic energy [H] for the Hartree–Fock method, without; any dispersion correction; the first three (or four, since; ) terms in Eq. (3). Quantity ; in Eq. (3). LCC2 (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CC2 level of theory. LCCSD (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CCSD level of theory. MP2 TOTAL ENERGY¶. MP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2 level of theory. MP2.5 TOTAL ENERGY¶. MP2.5 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2.5 level of theory. MP3 TOTAL ENERGY¶. MP3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP3 level of theory. MPn TOTAL ENERGY¶. MPn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled Möller–Plesset perturbation theory level.; n is MP perturbation order. NUCLEAR REPULSION ENERGY¶; The nuclear repulsion energy contribution [H] to the total SCF energy.; Quantity in Eq. (3). (2). ONE-ELECTRON ENERGY¶; The one-electron energy contribution [H] to the total SCF energy.; Quantity in Eq. (3). SAPT DISP ENERGY¶. SAPT ELST ENERGY¶. SAPT EXCH ENERGY¶. SAPT IND ENERGY¶; Respe",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html:11749,energy,energy,11749,psi4manual/4.0b3/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html,2,['energy'],['energy']
Energy Efficiency,"o; DFT FUNCTIONAL TOTAL ENERGY. DFT XC ENERGY¶; The functional energy contribution [H] to the total SCF energy (DFT only).; Quantity in Eqs. (4) and (1). DISPERSION CORRECTION ENERGY¶; The dispersion correction [H] appended to an underlying functional; when a DFT-D method is requested. Quantity ; in Eqs. (4) and (1). DOUBLE-HYBRID CORRECTION ENERGY¶; The scaled MP2 correlation energy correction [H] appended to an; underlying functional when a DH-DFT method is requested.; Quantity in Eq. (1). FCI TOTAL ENERGY¶. FCI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the full configuration interaction level of theory. HF TOTAL ENERGY¶; The total electronic energy [H] for the Hartree–Fock method, without; any dispersion correction; the first three (or four, since; ) terms in Eq. (4). Quantity ; in Eq. (4). LCC2 (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CC2 level of theory. LCCSD (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CCSD level of theory. MP2 TOTAL ENERGY¶. MP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2 level of theory. MP2.5 TOTAL ENERGY¶. MP2.5 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2.5 level of theory. MP3 TOTAL ENERGY¶. MP3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP3 level of theory. MP4(SDQ) TOTAL ENERGY¶. MP4(SDQ) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP4 singles, doubles, quadruples level of theory. Quantity; MP4(SDQ) CORRELATION ENERGY is; first right-hand term in Eq. (2). MP4 TOTAL ENERGY¶. MP4 CORRELATION ENERGY¶. MP4(SDTQ) TOTAL ENERGY¶. MP4(SDTQ) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the full MP4 level of theory. Quantity MP4 CORRELATION; ENERGY / MP4(SDTQ) CORRELATI",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/glossary_psivariables-1.html:11943,energy,energy,11943,psi4manual/1.0.0/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/glossary_psivariables-1.html,6,['energy'],['energy']
Energy Efficiency,"o; MP2_TYPE: MP_TYPE,; CI_TYPE, CC_TYPE, which can have values CONV,; DF, and CD. These are all global keywords, as their values are; shared among modules rather than (or in addition to) being used internally; by the module). We’re sticking with SCF_TYPE and; MP2_TYPE defaulting to DF, while everything higher defaults; to CONV. In psi4/share/python/driver.py, a managed method calls a; “select” function rather than a “run” function.; procedures = {; 'energy': {; 'scf' : run_scf,; 'mp3' : select_mp3,; 'dcft' : run_dcft,. Then in psi4/share/python/proc.py, the select function runs through; reference (always outer loop) and type (inner loop) to specify the proc; function to call for any able, non-default module (e.g., mtd_type ==; 'DETCI' ) or able, default module (e.g., mtd_typd == ['', 'FNOCC'] ).; Don’t worry about ‘else’ statements as anything that falls through will be; caught and a readable error generated.; def select_mp3(name, **kwargs):; """"""Function selecting the algorithm for a MP3 energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ/fnocc/detci. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['DETCI']:; func = run_detci. if func is None:; raise ManagedMethodError(['select_mp3', name, 'MP_TYPE', mtd_typ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/proc_py-1.html:5074,energy,energy,5074,psi4manual/1.0.0/proc_py-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/proc_py-1.html,2,['energy'],['energy']
Energy Efficiency,"o_delta5:; # pass; else:; raise ValidationError('Requested scf (%s) + corl (%s) + delta (%s) + delta2 (%s) + delta3 (%s) + delta4 (%s) + delta5 (%s) not valid. These steps are cummulative.' %; (do_scf, do_corl, do_delta, do_delta2, do_delta3, do_delta4, do_delta5)). # Establish list of valid basis sets for correlation energy; if do_corl:; if 'corl_basis' in kwargs:; BSTC, ZETC = _expand_bracketed_basis(kwargs['corl_basis'].lower(), molecule=molstr); else:; raise ValidationError(""""""CORL basis sets through keyword '%s' are required."""""" % ('corl_basis')). # Establish list of valid basis sets for scf energy; if 'scf_basis' in kwargs:; BSTR, ZETR = _expand_bracketed_basis(kwargs['scf_basis'].lower(), molecule=molstr); elif do_corl:; BSTR = BSTC[:]; ZETR = ZETC[:]; else:; raise ValidationError(""""""SCF basis sets through keyword '%s' are required. Or perhaps you forgot the '%s'."""""" % ('scf_basis', 'corl_wfn')). # Establish list of valid basis sets for delta correction energy; if do_delta:; if 'delta_basis' in kwargs:; BSTD, ZETD = _expand_bracketed_basis(kwargs['delta_basis'].lower(), molecule=molstr); else:; raise ValidationError(""""""DELTA basis sets through keyword '%s' are required."""""" % ('delta_basis')). # Establish list of valid basis sets for second delta correction energy; if do_delta2:; if 'delta2_basis' in kwargs:; BSTD2, ZETD2 = _expand_bracketed_basis(kwargs['delta2_basis'].lower(), molecule=molstr); else:; raise ValidationError(""""""DELTA2 basis sets through keyword '%s' are required."""""" % ('delta2_basis')). # # Establish list of valid basis sets for third delta correction energy; # if do_delta3:; # if 'delta3_basis' in kwargs:; # BSTD3, ZETD3 = validate_bracketed_basis(kwargs['delta3_basis'].lower()); # else:; # raise ValidationError('DELTA3 basis sets through keyword \'%s\' are required.' % ('delta3_basis')); #; # # Establish list of valid basis sets for fourth delta correction energy; # if do_delta4:; # if 'delta4_basis' in kwargs:; # BSTD4, ZETD4 = validate_brac",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:36561,energy,energy,36561,psi4manual/1.0.0/_modules/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html,3,['energy'],['energy']
Energy Efficiency,"oad parameters from dashcoeff[dashlvl][func]. This is not; 	 passed to DFTD3 and thus may be a dummy or `None`. Any or all; 	 parameters initialized can be overwritten via `dashparam`.; dashlvl : {'d2p4', 'd2gr', 'd3zero', 'd3bj', 'd3mzero', d3mbj', 'd', 'd2', 'd3', 'd3m'}; 	 Flavor of a posteriori dispersion correction for which to load; 	 parameters and call procedure in DFTD3. Must be a keys in; 	 dashcoeff dict (or a key in dashalias that resolves to one).; dashparam : dict, optional; 	 Dictionary of the same keys as dashcoeff[dashlvl] used to; 	 override any or all values initialized by; 	 dashcoeff[dashlvl][func].; dertype : {None, 0, 'none', 'energy', 1, 'first', 'gradient'}, optional; 	 Maximum derivative level at which to run DFTD3. For large; 	 `mol`, energy-only calculations can be significantly more; 	 efficient. Also controls return values, see below.; verbose : bool, optional; When `True`, additionally include DFTD3 output in output. Returns; -------; energy : float, optional; When `dertype` is 0, energy [Eh].; gradient : list of lists of floats or psi4.core.Matrix, optional; When `dertype` is 1, (nat, 3) gradient [Eh/a0].; (energy, gradient) : float and list of lists of floats or psi4.core.Matrix, optional; When `dertype` is unspecified, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; -----; research site: https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/dft-d3; Psi4 mode: When `psi4` the python module is importable at `import qcdb`; time, Psi4 mode is activated, with the following alterations:; * output goes to output file; * gradient returned as psi4.core.Matrix, not list o'lists; * scratch is written to randomly named subdirectory of psi scratch; * psivar ""DISPERSION CORRECTION ENERGY"" is set; * `verbose` triggered when PRINT keywork of SCF module >=3. """"""; # Create (if necessary) and update qcdb.Molecule; if isinstance(mol, (Molecule, core.Molecule)):; # 1st: called on a qcdb.Molecule; # 2nd: called on a python export of a psi4.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/qcdb/interface_dftd3.html:3429,energy,energy,3429,psi4manual/1.2.1/_modules/qcdb/interface_dftd3.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/qcdb/interface_dftd3.html,2,['energy'],['energy']
Energy Efficiency,"oad the plugin of name arg0. prepare_options_for_module(name); Sets up the options library to return options pertaining to the module or plugin name (e.g. print_global_options(); Prints the currently set global (all modules) options to the output file. print_options(); Prints the currently set options (to the output file) for the current module. print_out(arg0); Prints a string (using sprintf-like notation) to the output file. print_variables(); Prints to output file all QCVariables that have been set in global memory. psi_top_srcdir(); Returns the location of the source code. psimrcc(arg0); Runs the multireference coupled cluster code. reopen_outfile(); Reopens the output file. revoke_global_option_changed(key); Clear the touched status for keyword key at global (all-module) scope. revoke_local_option_changed(module, key); Clear the touched status for keyword key at module scope. run_gdma(ref_wfn, datfilename); Runs the GDMA interface code. sapt(dimer_wfn, monoa_wfn, monob_wfn); Runs the symmetry adapted perturbation theory code. scalar_variable(key); Returns the double QCVariable key (case-insensitive); prefer variable(). scalar_variables(); Returns dictionary of all double QCVariables; prefer variables(). scatter(arg0, arg1, arg2, arg3, arg4); New Scatter function. scfgrad(ref_wfn); Run scfgrad, which is a specialized DF-SCF gradient program. scfhess(ref_wfn); Run scfhess, which is a specialized DF-SCF hessian program. set_active_molecule(molecule); Activates a previously defined molecule in global memory so next computations use it. set_array_variable(key, value); Sets the requested (case-insensitive) Matrix QCVariable; prefer set_variable(). set_datadir(psidatadir); Sets the path to shared text resources, PSIDATADIR. set_global_option(*args, **kwargs); Overloaded function. set_global_option_python(key, EXTERN); This is a fairly hacky way to get around EXTERN issues. set_gradient(val). Deprecated since version 1.2. set_legacy_gradient(grad); Assigns the global gr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/psi4api-1.html:8737,adapt,adapted,8737,psi4manual/1.4.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/psi4api-1.html,5,['adapt'],['adapted']
Energy Efficiency,"oad the plugin of name arg0. prepare_options_for_module(name); Sets up the options library to return options pertaining to the module or plugin name (e.g. print_global_options(); Prints the currently set global (all modules) options to the output file. print_options(); Prints the currently set options (to the output file) for the current module. print_out(arg0); Prints a string (using sprintf-like notation) to the output file. print_variables(); Prints to output file all QCVariables that have been set in global memory. psi_top_srcdir(); Returns the location of the source code. psimrcc(arg0); Runs the multireference coupled cluster code. reopen_outfile(); Reopens the output file. revoke_global_option_changed(key); Clear the touched status for keyword key at global (all-module) scope. revoke_local_option_changed(module, key); Clear the touched status for keyword key at module scope. run_gdma(ref_wfn, datfilename); Runs the GDMA interface code. sapt(dimer_wfn, monoa_wfn, monob_wfn); Runs the symmetry adapted perturbation theory code. scalar_variable(key); Returns the double QCVariable key (case-insensitive); prefer variable(). scalar_variables(); Returns dictionary of all double QCVariables; prefer variables(). scatter(arg0, arg1, arg2, arg3, arg4); New Scatter function. scfgrad(ref_wfn); Run scfgrad, which is a specialized DF-SCF gradient program. scfhess(ref_wfn); Run scfhess, which is a specialized DF-SCF hessian program. set_active_molecule(molecule); Activates a previously defined molecule in global memory so next computations use it. set_array_variable(key, value); Sets the requested (case-insensitive) Matrix QCVariable; prefer set_variable(). set_datadir(psidatadir); Sets the path to shared text resources, PSIDATADIR. set_global_option(*args, **kwargs); Overloaded function. set_global_option_python(key, EXTERN); This is a fairly hacky way to get around EXTERN issues. set_local_option(*args, **kwargs); Overloaded function. set_local_option_python(key, value); Sets",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/psi4api.html:8294,adapt,adapted,8294,psi4manual/1.7.x/psi4api.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/psi4api.html,1,['adapt'],['adapted']
Energy Efficiency,"oat* |w--w| Total electronic energy of optimized structure in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :raises: :py:class:`psi4.driver.OptimizationConvergenceError` if :term:`GEOM_MAXITER <GEOM_MAXITER (OPTKING)>` exceeded without reaching geometry convergence. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY`. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`psi4.driver.energy`. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple. :type return_history: :ref:`boolean <op_py_boolean>`; :param return_history: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. :type engine: str; :param engine: |dl| ``'optking'`` |dr| || ``'geometric'``. Indicates the optimization engine to use, which can be either Psi4's; native Optking optimizer or the GeomeTRIC program. :type optimizer_keywords: dict; :param optimizer_keywords: Extra options passed to the GeomeTRIC or optking optimizers. Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. Alternatively, can be used to set optking options; that are not currently recognized by Psi4. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html:62013,energy,energy,62013,psi4manual/1.7.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html,8,['energy'],['energy']
Energy Efficiency,"oat, z: float, symbol: str, mass: float, charge: float, label: str, A: int) → None¶; Adds to self Molecule an atom with atomic number Z, Cartesian coordinates in Bohr (x, y, z), atomic symbol, mass, and charge, extended atomic label, and mass number A. atom_at_position(*args, **kwargs)¶; Overloaded function. atom_at_position(self: psi4.core.Molecule, coord: float, tol: float) -> int. Returns the index of the atom inside tol radius around coord. Returns -1 for no atoms, throws an exception if more than one is found. atom_at_position(self: psi4.core.Molecule, coord: List[float[3]], tol: float) -> int. Returns the index of the atom inside tol radius around coord. Returns -1 for no atoms, throws an exception if more than one is found. basis_on_atom(self: psi4.core.Molecule, arg0: int) → str¶; Gets the label of the orbital basis set on a given atom arg0. center_of_mass(self: psi4.core.Molecule) → psi4.core.Vector3¶; Computes center of mass of molecule (does not translate molecule). charge(self: psi4.core.Molecule, atom: int) → float¶; Gets charge of atom (0-indexed without dummies). clone(self: psi4.core.Molecule) → psi4.core.Molecule¶; Returns a new Molecule identical to arg1. com_fixed(self: psi4.core.Molecule) → bool¶; Gets whether or not center of mass is fixed. comment(self: psi4.core.Molecule) → str¶; Gets molecule comment. connectivity(self: psi4.core.Molecule) → List[Tuple[int, int, float]]¶; Gets molecule connectivity. create_psi4_string_from_molecule(self: psi4.core.Molecule) → str¶; Gets a string re-expressing in input format the current state of the molecule.Contains Cartesian geometry info, fragmentation, charges and multiplicities, and any frame restriction. deactivate_all_fragments(self: psi4.core.Molecule) → None¶; Sets all fragments in the molecule to be inactive. distance_matrix(self: psi4.core.Molecule) → psi4.core.Matrix¶; Returns Matrix of interatom distances. extract_subsets(*args, **kwargs)¶; Overloaded function. extract_subsets(self: psi4.core.Mole",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.Molecule.html:16544,charge,charge,16544,psi4manual/1.6.x/api/psi4.core.Molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.Molecule.html,6,['charge'],['charge']
Energy Efficiency,"oat; Returns :math:`E_{total}^{\infty}`, see below. Notes; -----; The extrapolation is calculated according to [1]_:; :math:`E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}, \alpha = 1.63`. References; ----------. .. [1] Halkier, Helgaker, Jorgensen, Klopper, & Olsen, Chem. Phys. Lett. 302 (1999) 437-446,; DOI: 10.1016/S0009-2614(99)00179-7. """""". if type(valueLO) != type(valueHI):; raise ValidationError(; ""scf_xtpl_helgaker_2: Inputs must be of the same datatype! (%s, %s)"" % (type(valueLO), type(valueHI))). if alpha is None:; alpha = 1.63. beta_division = 1 / (math.exp(-1 * alpha * zLO) * (math.exp(-1 * alpha) - 1)); beta_mult = math.exp(-1 * alpha * zHI). if isinstance(valueLO, float):; beta = (valueHI - valueLO) * beta_division; value = valueHI - beta * beta_mult. if verbose:; # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> Helgaker 2-point exponential SCF extrapolation for method: %s <==\n\n"""""" % (; functionname.upper()); cbsscheme += """""" LO-zeta (%s) Energy: % 16.12f\n"""""" % (str(zLO), valueLO); cbsscheme += """""" HI-zeta (%s) Energy: % 16.12f\n"""""" % (str(zHI), valueHI); cbsscheme += """""" Alpha (exponent) Value: % 16.12f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: % 16.12f\n\n"""""" % (beta). name_str = ""%s/(%s,%s)"" % (functionname.upper(), _zeta_val2sym[zLO].upper(), _zeta_val2sym[zHI].upper()); cbsscheme += """""" @Extrapolated """"""; cbsscheme += name_str + ':'; cbsscheme += "" "" * (18 - len(name_str)); cbsscheme += """"""% 16.12f\n\n"""""" % value; core.print_out(cbsscheme). return value. elif isinstance(valueLO, (core.Matrix, core.Vector)):; beta = valueHI.clone(); beta.name = 'Helgaker SCF (%s, %s) beta' % (zLO, zHI); beta.subtract(valueLO); beta.scale(beta_division); beta.scale(beta_mult). value = valueHI.clone(); value.subtract(beta); value.name = 'Helgaker SCF (%s, %s) data' % (zLO, zHI). if verbose > 2:; core.print_out(""""""\n ==> Helgaker 2-point exponential SCF extrapolation for method: %s <==\n\n"""""" %; (function",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:8906,Energy,Energy,8906,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,2,['Energy'],['Energy']
Energy Efficiency,"oat[3]], tol: float) -> int. Tests to see if an atom is at the position coord with a given tolerance tol. basis_on_atom(self: psi4.core.Molecule, arg0: int) → str; Gets the label of the orbital basis set on a given atom arg0. center_of_mass(self: psi4.core.Molecule) → psi4.core.Vector3; Computes center of mass of molecule (does not translate molecule). charge(self: psi4.core.Molecule, atom: int) → float; Gets charge of atom (0-indexed without dummies). clone(self: psi4.core.Molecule) → psi4.core.Molecule; Returns a new Molecule identical to arg1. com_fixed(self: psi4.core.Molecule) → bool; Gets whether or not center of mass is fixed. comment(self: psi4.core.Molecule) → str; Gets molecule comment. connectivity(self: psi4.core.Molecule) → List[Tuple[int, int, float]]; Gets molecule connectivity. create_psi4_string_from_molecule(self: psi4.core.Molecule) → str; Gets a string re-expressing in input format the current state of the molecule.Contains Cartesian geometry info, fragmentation, charges and multiplicities, and any frame restriction. deactivate_all_fragments(self: psi4.core.Molecule) → None; Sets all fragments in the molecule to be inactive. distance_matrix(self: psi4.core.Molecule) → psi4.core.Matrix; Returns Matrix of interatom distances. extract_subsets(*args, **kwargs); Overloaded function. extract_subsets(self: psi4.core.Molecule, arg0: List[int], arg1: List[int]) -> psi4.core.Molecule. Returns copy of self with arg0 fragments Real and arg1 fragments Ghost. extract_subsets(self: psi4.core.Molecule, arg0: List[int], arg1: int) -> psi4.core.Molecule. Returns copy of self with arg0 fragments Real and arg1 fragment Ghost. extract_subsets(self: psi4.core.Molecule, arg0: int, arg1: List[int]) -> psi4.core.Molecule. Returns copy of self with arg0 fragment Real and arg1 fragments Ghost. extract_subsets(self: psi4.core.Molecule, arg0: int, arg1: int) -> psi4.core.Molecule. Returns copy of self with arg0 fragment Real and arg1 fragment Ghost. extract_subsets(self: psi4",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.molecule.html:42870,charge,charges,42870,psi4manual/1.3.2/api/psi4.core.molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.molecule.html,1,['charge'],['charges']
Energy Efficiency,"oat]]); keywords (Dict[str, Any]); max_nbody (int); method (str); molecule (Any); nbodies_per_mc_level (List[List[Union[int, Literal['supersystem']]]]); nfragments (int); quiet (bool); return_total_data (Optional[bool]); task_list (Dict[str, Union[psi4.driver.task_base.AtomicComputer, psi4.driver.driver_cbs.CompositeComputer, psi4.driver.driver_findif.FiniteDifferenceComputer]]). Validators:. set_bsse_type » bsse_type; set_embedding_charges » embedding_charges; set_max_nbody » max_nbody; set_molecule » molecule; set_nfragments » nfragments; set_return_total_data » return_total_data. field basis: str = '(auto)'¶. field bsse_type: List[BsseEnum] = [<BsseEnum.cp: 'cp'>]¶; Requested BSSE treatments. First in list determines which interaction or total energy/gradient/Hessian returned. Validated by:. set_bsse_type. field driver: DriverEnum [Required]¶; The computation driver; i.e., energy, gradient, hessian. field embedding_charges: Dict[int, List[float]] = {}¶; Atom-centered point charges to be used on molecule fragments whose basis sets are not included in the computation. Keys: 1-based index of fragment. Values: list of atom charges for that fragment. Validated by:. set_embedding_charges. field keywords: Dict[str, Any] = {}¶; The computation keywords/options. field max_nbody: int = -1¶; Maximum number of bodies to include in the many-body treatment. Possible: max_nbody <= nfragments. Default: max_nbody = nfragments. Validated by:. set_max_nbody. field method: str = '(auto)'¶. field molecule: Any [Required]¶; The target molecule, if not the last molecule defined. Validated by:. set_molecule. field nbodies_per_mc_level: List[List[Union[int, Literal['supersystem']]]] = []¶; Distribution of active n-body levels among model chemistry levels. All bodies in range [1, self.max_nbody] must be present exactly once. Number of items in outer list is how many different modelchems. Each inner list specifies what n-bodies to be run at the corresponding modelchem (e.g., [[1, 2]] has m",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/nbody.html:12788,charge,charges,12788,psi4manual/1.7.x/nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/nbody.html,1,['charge'],['charges']
Energy Efficiency,"ob; * from reference job, set add'l mol, DD, G, H as available; * form model, including detailed dict at atomicresult.extras[""findif_record""]. * convert result to psi4.core.Matrix. _findif_schema_to_wfn(); -----------------------; * build wfn from findif mol and basis (if singular) and module (if singular); * push qcvars to P::e and wfn. gradient_write(); ----------------; * write .grad file if requested. hessian_write(); ---------------; * write .hess file if requested. * return dd/g/h and wfn. """""". import copy; import logging; from functools import partial; from typing import Any, Callable, Dict, Iterator, List, Optional, Tuple, Union, TYPE_CHECKING. import numpy as np; from pydantic import Field, validator; from qcelemental.models import DriverEnum, AtomicResult; from qcelemental import constants. from psi4 import core; from psi4.driver import p4util, pp, qcdb, nppp10; from psi4.driver.p4util.exceptions import ValidationError; from psi4.driver.task_base import AtomicComputer, BaseComputer, EnergyGradientHessianWfnReturn. if TYPE_CHECKING:; import qcportal. logger = logging.getLogger(__name__). # CONVENTIONS:; # n_ at the start of a variable name is short for ""number of.""; # _pi at the end of a variable name is short for ""per irrep.""; # h is the index of an irrep. def _displace_cart(mass: np.ndarray, geom: np.ndarray, salc_list: core.CdSalcList, i_m: Iterator[Tuple], step_size: float) -> Tuple[np.ndarray, str]:; """"""Displace a geometry along the specified displacement SALCs. Parameters; ----------; mass; (nat, ) masses [u] of atoms of the molecule (const).; geom; (nat, 3) reference geometry [a0] of the molecule (const).; salc_list; A list of Cartesian displacement SALCs; i_m; An iterator containing tuples. Each tuple has the index of a salc in; salc_list and the number of steps (positive or negative) to displace; the salc at that index.; step_size; The size of a single ""step,"" i.e., the stencil size. Returns; -------; disp_geom; (nat, 3) Displaced geometry.; label;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_findif.html:4923,Energy,EnergyGradientHessianWfnReturn,4923,psi4manual/1.7.x/_modules/psi4/driver/driver_findif.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_findif.html,1,['Energy'],['EnergyGradientHessianWfnReturn']
Energy Efficiency,"obal_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). if core.get_global_option(""RELATIVISTIC"") in [""X2C"", ""DKH""]:; rel_bas = core.BasisSet.build(ref_wfn.molecule(), ""BASIS_RELATIVISTIC"",; core.get_option(""SCF"", ""BASIS_RELATIVISTIC""),; ""DECON"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset('BASIS_RELATIVISTIC',rel_bas). fnocc_wfn = core.fnocc(ref_wfn). # set current correlation energy and total energy. only need to treat mpn here.; if name in [""mp3"", ""fno-mp3""]:; fnocc_wfn.set_variable(""CURRENT ENERGY"", fnocc_wfn.variable(""MP3 TOTAL ENERGY"")); fnocc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", fnocc_wfn.variable(""MP3 CORRELATION ENERGY"")); elif name in [""mp4(sdq)"", ""fno-mp4(sdq)""]:; fnocc_wfn.set_variable(""CURRENT ENERGY"", fnocc_wfn.variable(""MP4(SDQ) TOTAL ENERGY"")); fnocc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", fnocc_wfn.variable(""MP4(SDQ) CORRELATION ENERGY"")); elif name in [""mp4"", ""fno-mp4""]:; fnocc_wfn.set_variable(""CURRENT ENERGY"", fnocc_wfn.variable(""MP4 TOTAL ENERGY"")); fnocc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", fnocc_wfn.variable(""MP4 CORRELATION ENERGY"")). # Shove variables into global space; for k, v in fnocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return fnocc_wfn. def run_cepa(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a cepa-like calculation. >>> energy('cepa(1)'). """"""; kwargs = p4util.kwargs_lower(kwargs). # save user options; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['FNOCC', 'NAT_ORBS'],; ['FNOCC', 'RUN_CEPA'],; ['FNOCC', 'USE_DF_INTS'],; ['FNOCC', 'CEPA_NO_SINGLES']). core.set_local_option('FNOCC', 'RUN_CEPA', True); core.set_local_option('FNOCC', 'USE_DF_INTS', False). # what type of cepa?; if name in ['lccd', 'fno-lccd']:; cepa_level = 'cepa(0)'; core.set_local_option('FNOCC', 'CEPA_NO_SINGLES', True); elif name in ['cepa(0)', 'fno-cepa(0)', '",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:160350,ENERGY,ENERGY,160350,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,3,['ENERGY'],['ENERGY']
Energy Efficiency,"obal_option('FCI', 'FALSE'); PsiMod.revoke_global_option_changed('FCI'); PsiMod.set_global_option('EX_LEVEL', 2); PsiMod.revoke_global_option_changed('EX_LEVEL'). return returnvalue. [docs]def run_dfmp2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted MP2 calculation. .. caution:: Get rid of madness-era restart file. """"""; if 'restart_file' in kwargs:; restartfile = kwargs.pop('restart_file'); # Rename the checkpoint file to be consistent with psi4's file system; psioh = PsiMod.IOManager.shared_object(); psio = PsiMod.IO.shared_object(); filepath = psioh.get_file_path(32); namespace = psio.get_default_namespace(); pid = str(os.getpid()); prefix = 'psi'; targetfile = filepath + prefix + '.' + pid + '.' + namespace + '.32'; if(PsiMod.me() == 0):; shutil.copy(restartfile, targetfile); else:; run_scf('RHF', **kwargs). PsiMod.print_out('\n'); banner('DFMP2'); PsiMod.print_out('\n'); e_dfmp2 = PsiMod.dfmp2(); e_scs_dfmp2 = PsiMod.get_variable('SCS-DF-MP2 ENERGY'); if (name.upper() == 'SCS-DFMP2'):; return e_scs_dfmp2; elif (name.upper() == 'DF-MP2'):; return e_dfmp2. [docs]def run_psimrcc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for a PSIMRCC computation; using a reference from the MCSCF module. """"""; run_mcscf(name, **kwargs); return PsiMod.psimrcc(). [docs]def run_psimrcc_scf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for a PSIMRCC computation; using a reference from the SCF module. """""". run_scf(name, **kwargs); return PsiMod.psimrcc(). [docs]def run_mp2c(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a coupled MP2 calculation. """"""; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); monomerA = molecule.extract_subsets(1, 2); monomerA.set_name('monomerA'); monomerB = molecule.extract_subsets(2, 1); monomerB.set_name('monomerB'). ri = PsiMod.get_option('SCF_TYPE'); df_ints_io = PsiMod.get_option('DF_INTS_IO'). PsiMod.IO.set_default_namespa",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/proc.html:21965,ENERGY,ENERGY,21965,psi4manual/4.0b2/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/proc.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"obal_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). if core.get_global_option('REFERENCE') == ""ROHF"":; ref_wfn.semicanonicalize(). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dfmp2_wfn = core.dfmp2(ref_wfn); dfmp2_wfn.compute_energy(). if name == 'scs-mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')). elif name == 'mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')). # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfep2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted MP2 calculation. """"""; core.tstart(); optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if core.get_global_option('REFERENCE') != ""RHF"":; raise ValidationError(""DF-EP2 is not available for %s references."",; core.get_g",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:126265,ENERGY,ENERGY,126265,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,7,['ENERGY'],['ENERGY']
Energy Efficiency,"object for communication with MDI (MolSSI driver interface). Parameters; ----------; scf_method; Method (SCF or post-SCF) used when calculating energies or gradients.; molecule; The target molecule, if not the last molecule defined.; kwargs; Any additional arguments to pass to :func:`psi4.driver.energy` or; :func:`psi4.driver.gradient` computation. """""". # Method used when the SCF command is received; self.scf_method = scf_method. # Additional arguments for energy, gradient, or optimization calculations; self.kwargs = kwargs. # Molecule all MDI operations are performed on; input_molecule = kwargs.pop('molecule', psi4.core.get_active_molecule()); _ini_cart = getattr(input_molecule, ""_initial_cartesian"", None); self.molecule = input_molecule.clone(); if _ini_cart:; self.molecule._initial_cartesian = _ini_cart; psi4.core.set_active_molecule(self.molecule). # Most recent SCF energy; self.energy = 0.0. # Variables used when MDI sets a lattice of point charges; self.nlattice = 0 # number of lattice point charges; self.clattice = [] # list of lattice coordinates; self.lattice = [] # list of lattice charges; self.lattice_field = psi4.QMMMbohr() # Psi4 chargefield. # MPI variables; self.mpi_world = None; self.world_rank = 0. # Flag for if a lattice of point charges has been set; self.set_lattice = False. # Get correct intra-code MPI communicator; if use_mpi4py:; self.mpi_world = MDI_MPI_get_world_comm(); self.world_rank = self.mpi_world.Get_rank(). # Psi4 does not currently support multiple MPI ranks; if self.mpi_world.Get_size() != 1:; MPI.COMM_WORLD.Abort(). # Accept a communicator to the driver code; self.comm = MDI_Accept_Communicator(). # Ensure that the molecule is using c1 symmetry; self.molecule.reset_point_group('c1'); self.molecule.fix_orientation(True); self.molecule.fix_com(True); self.molecule.reinterpret_coordentry(False); self.molecule.update_geometry(). # Flag to stop listening for MDI commands; self.stop_listening = False. # Dictionary of all supported MDI com",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html:2804,charge,charges,2804,psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html,6,['charge'],['charges']
Energy Efficiency,"object""; },; ""metadata"": {; ""title"": ""Metadata""; },; ""metameta"": {; ""title"": ""Metameta"",; ""default"": {},; ""type"": ""object""; },; ""verbose"": {; ""title"": ""Verbose"",; ""default"": 1,; ""type"": ""integer""; },; ""cbsrec"": {; ""title"": ""Cbsrec"",; ""default"": [],; ""type"": ""array"",; ""items"": {; ""type"": ""object""; }; },; ""trove"": {; ""title"": ""Trove"",; ""default"": [],; ""type"": ""array"",; ""items"": {; ""type"": ""object""; }; },; ""compute_list"": {; ""title"": ""Compute List"",; ""default"": [],; ""type"": ""array"",; ""items"": {; ""type"": ""object""; }; },; ""task_list"": {; ""title"": ""Task List"",; ""default"": [],; ""type"": ""array"",; ""items"": {; ""$ref"": ""#/definitions/AtomicComputer""; }; },; ""results_list"": {; ""title"": ""Results List"",; ""default"": [],; ""type"": ""array"",; ""items"": {}; }; },; ""required"": [; ""driver""; ],; ""definitions"": {; ""DriverEnum"": {; ""title"": ""DriverEnum"",; ""description"": ""Allowed computation driver values."",; ""enum"": [; ""energy"",; ""gradient"",; ""hessian"",; ""properties""; ],; ""type"": ""string""; },; ""WavefunctionProtocolEnum"": {; ""title"": ""WavefunctionProtocolEnum"",; ""description"": ""Wavefunction to keep from a computation."",; ""enum"": [; ""all"",; ""orbitals_and_eigenvalues"",; ""occupations_and_eigenvalues"",; ""return_results"",; ""none""; ],; ""type"": ""string""; },; ""ErrorCorrectionProtocol"": {; ""title"": ""ErrorCorrectionProtocol"",; ""description"": ""Configuration for how QCEngine handles error correction\n\nWARNING: These protocols are currently experimental and only supported by NWChem tasks"",; ""type"": ""object"",; ""properties"": {; ""default_policy"": {; ""title"": ""Default Policy"",; ""description"": ""Whether to allow error corrections to be used if not directly specified in `policies`"",; ""default"": true,; ""type"": ""boolean""; },; ""policies"": {; ""title"": ""Policies"",; ""description"": ""Settings that define whether specific error corrections are allowed. Keys are the name of a known error and values are whether it is allowed to be used."",; ""type"": ""object"",; ""additionalProperties"": {; ""type"": ""boolean""; }; }; },; ""additio",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/cbs.html:34548,energy,energy,34548,psi4manual/1.9.x/cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/cbs.html,2,['energy'],['energy']
Energy Efficiency,"object""; },; ""metadata"": {; ""title"": ""Metadata""; },; ""metameta"": {; ""title"": ""Metameta"",; ""default"": {},; ""type"": ""object""; },; ""verbose"": {; ""title"": ""Verbose"",; ""default"": 1,; ""type"": ""integer""; },; ""cbsrec"": {; ""title"": ""Cbsrec"",; ""default"": [],; ""type"": ""array"",; ""items"": {; ""type"": ""object""; }; },; ""trove"": {; ""title"": ""Trove"",; ""default"": [],; ""type"": ""array"",; ""items"": {; ""type"": ""object""; }; },; ""compute_list"": {; ""title"": ""Compute List"",; ""default"": [],; ""type"": ""array"",; ""items"": {; ""type"": ""object""; }; },; ""task_list"": {; ""title"": ""Task List"",; ""default"": [],; ""type"": ""array"",; ""items"": {; ""$ref"": ""#/definitions/AtomicComputer""; }; },; ""results_list"": {; ""title"": ""Results List"",; ""default"": [],; ""type"": ""array"",; ""items"": {}; }; },; ""required"": [; ""driver""; ],; ""definitions"": {; ""DriverEnum"": {; ""title"": ""DriverEnum"",; ""description"": ""Allowed computation driver values."",; ""enum"": [; ""energy"",; ""gradient"",; ""hessian"",; ""properties""; ],; ""type"": ""string""; },; ""WavefunctionProtocolEnum"": {; ""title"": ""WavefunctionProtocolEnum"",; ""description"": ""Wavefunction to keep from a computation."",; ""enum"": [; ""all"",; ""orbitals_and_eigenvalues"",; ""return_results"",; ""none""; ],; ""type"": ""string""; },; ""ErrorCorrectionProtocol"": {; ""title"": ""ErrorCorrectionProtocol"",; ""description"": ""Configuration for how QCEngine handles error correction\n\nWARNING: These protocols are currently experimental and only supported by NWChem tasks"",; ""type"": ""object"",; ""properties"": {; ""default_policy"": {; ""title"": ""Default Policy"",; ""description"": ""Whether to allow error corrections to be used if not directly specified in `policies`"",; ""default"": true,; ""type"": ""boolean""; },; ""policies"": {; ""title"": ""Policies"",; ""description"": ""Settings that define whether specific error corrections are allowed. Keys are the name of a known error and values are whether it is allowed to be used."",; ""type"": ""object"",; ""additionalProperties"": {; ""type"": ""boolean""; }; }; },; ""additionalProperties"": false; },; ""Nati",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/cbs.html:34548,energy,energy,34548,psi4manual/1.8.x/cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/cbs.html,1,['energy'],['energy']
Energy Efficiency,"object, but scoped only to a single module. set_memory_bytes(memory, quiet); Sets the memory available to Psi (in bytes). set_num_threads(nthread, quiet); Sets the number of threads to use in SMP parallel computations. set_output_file(*args, **kwargs); Overloaded function. set_parent_symmetry(arg0); Sets the symmetry of the ‘parent’ (undisplaced) geometry, by Schoenflies symbol, at the beginning of a finite difference computation. set_psi_file_prefix(arg0). set_variable(arg0, arg1); Sets a PSI variable, by name. tstart(); docstring. tstop(); docstring. version(); Returns the version ID of this copy of Psi. Classes¶. AOShellCombinationsIterator. AngularMomentumInt; Computes angular momentum integrals. BSVec. BasisExtents; docstring. BasisFunctions; docstring. BasisSet; Contains basis set information. BlockOPoints; docstring. BoysLocalizer; Performs Boys orbital localization. CIVector; docstring. CIWavefunction; docstring. CUHF; docstring. CdSalcList; Class for generating symmetry adapted linear combinations of Cartesian displacements. CorrelationFactor; docstring. CorrelationTable; Provides a correlation table between two point groups. CubeProperties; docstring. DFEP2Wavefunction; A density-fitted second-order Electron Propagator Wavefunction. DFHelper; docstring. DFSOMCSCF; docstring. DFTGrid; docstring. DFTensor; docstring. Deriv; Computes gradients of wavefunctions. DiagonalizeOrder; Defines ordering of eigenvalues after diagonalization. Dimension; Initializes and defines Dimension Objects. DipoleInt; Computes dipole integrals. DiskSOMCSCF; docstring. Dispersion; docstring. EFP; Class interfacing with libefp. ERI; Computes normal two electron reuplsion integrals. ElectricFieldInt; Computes electric field integrals. ElectrostaticInt; Computes electrostatic integrals. ErfComplementERI; Computes ERF complement electron repulsion integrals. ErfERI; Computes ERF electron repulsion integrals. ExternalPotential; Stores external potential field, computes external potentia",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/psi4api-1.html:250580,adapt,adapted,250580,psi4manual/1.2.1/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html,2,['adapt'],['adapted']
Energy Efficiency,"object. Opposite of; from_file(). Parameters:. wfn (Wavefunction) – Wavefunction or inherited class instance.; filename (Optional[str]) – An optional filename to which to write the data. Returns:; A dictionary and NumPy representation of the Wavefunction. Return type:; Dict[str, Dict[str, Any]]. variable(key)¶; Return copy of scalar or array QCVariable; key from self. Parameters:. self (Wavefunction) – Wavefunction instance.; key (str) – Case-insensitive key to instance’s double or Matrix; storage maps. Returns:; Requested QCVariable from self. Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles or per-atom charges); are returned as ndarray of natural dimensionality.; Other array variables are returned as Matrix and; may have an extra dimension with symmetry information. Return type:; float or ndarray or Matrix. Raises:; KeyError – If key not set on self. Example; >>> g, wfn = psi4.gradient(""hf/cc-pvdz"", return_wfn=True); >>> wfn.variable(""CURRENT ENERGY""); -100.00985995185668; >>> wfn.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> wfn.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> wfn.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). variables(include_deprecated_keys=False)¶; Return all scalar or array QCVariables; from self. Parameters:. self – Wavefunction instance.; include_deprecated_keys (bool) – Also return duplicate entries with keys that have been deprecated. Returns:; Map of all QCVariables that have been set on self. Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles or per-atom charges); are returned as ndarray of natural dimensionality.; Other array variables are returned as Matrix and; may have an extra dimension with symmetry information. Return type:; Dict[str, Union[float, ndarray, Matrix]. write_molden(filename=None, do_virtual=",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Wavefunction.html:26052,ENERGY,ENERGY,26052,psi4manual/1.7.x/api/psi4.core.Wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Wavefunction.html,3,['ENERGY'],['ENERGY']
Energy Efficiency,"object’s update_density member, passing it a SharedMatrix holding the; current density (remember that it changes during each iteration of the SCF) and; the product will be considered during screening. If only coulomb-like terms; are to be computed, the needs_exchange argument to the integral object; constructor should be set to false, otherwise it should be true to correcly; account for products of the density and integrals that contribute to; exchange-like terms. Shell blocking¶; Each underlying integral engine knows whether it will use blocks, and will set up; the metadata automatically. Instead of looping over individual shells, the; user should loop over blocks supplied by the integral object; these blocks will; be just a single shell quartet combination for the case where blocking is not; used. It is simple to loop over pairs within each block using C++11 syntax, as; demonstrated in the code snippet above. Only shell pairs with significant; overlap are included in the shell block information, making this an efficient; way to loop over non-negligible terms. Permutational symmetry¶; The pairs within each block are optimized for efficiency. First, they are; screened during the integral object’s creation to ensure that only terms with; appreciable overlap are stored. Second, only P,Q combinations that are; permutationally unique are stored, ordered with the higher angular momentum; first. Therefore care must be taken to ensure that the missing permutations; are correctly accounted for when processing the integrals within the loop. See; the DirectJK code in libfock for an example of using this scheme for a Fock; matrix build. Using bra-ket symmetry¶; In cases where there is no batching performed, bra-ket symmetry can be; trivially enforced by ensuring that one of the block indices is greater than or; equal to the other. When batching is used, the situation is trickier; some ket; batches may contain a mixture of integrals that are bra-ket unique and those; that are no",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/prog_integrals-1.html:7503,efficient,efficient,7503,psi4manual/1.4.0/prog_integrals-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/prog_integrals-1.html,9,['efficient'],['efficient']
Energy Efficiency,"obtain orbitals using PSIMRCC’s MCSCF module regardless of what; orbital type is chosen, twocon, rhf, or rohf. An example of the; MCSCF input is given below.; PSIMRCC is most commonly used for low-spin cases (singlets or open-shell; singlets). It is capable of performing computations on higher spin states; (e.g., triplets), but in general, not all the required matrix elements have; been coded for high-spin cases, meaning that results will correspond to an; approximate Mk-MRCC computation for high-spin cases. A Simple Example¶; The CORR_WFN allows you to select one of three methods; Mk-MRPT2 [PT2], Mk-MRCCSD [CCSD], or Mk-MRCCSD(T) [CCSD_T].; The CORR_MULTP option allows you to select the Slater; determinants with a particular value. The WFN_SYM; keyword is neccesary if you do not want to compute the energy of the; totally-symmetric state. The FOLLOW_ROOT option may be used; to follow different roots of the effective Hamiltonian. A value of 1; instructs PSIMRCC to follow the solution with the lowest energy given; a certain set of determinants.; molecule o2 {; 0 3; O; O 1 2.265122720724; units au; }; set {; basis cc-pvtz; }; set mcscf {; reference rohf; docc [3,0,0,0,0,2,1,1] # Doubly occupied MOs; socc [0,0,1,1,0,0,0,0] # Singly occupied MOs; }; set psimrcc {; corr_wfn ccsd # Do Mk-MRCCSD; frozen_docc [1,0,0,0,0,1,0,0] # Frozen MOs; restricted_docc [2,0,0,0,0,1,1,1] # Doubly occupied MOs; active [0,0,1,1,0,0,0,0] # Active MOs; frozen_uocc [0,0,0,0,0,0,0,0] # Frozen virtual MOs; corr_multp 1 # Select the Ms = 0 component; follow_root 1; wfn_sym B1g # Select the B1g state; }; energy('psimrcc'). Note that the oxygen molecule has 16 electrons (including core), while; the docc array contains only 7 doubly-occupied orbitals (or 14; electrons). Hence, two more electrons are available to place into; the active space (given by active), which consists of 2 orbitals.; Thus there are two active electrons in two orbitals. In this particular; example, we are using standard ROHF or",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/psimrcc-1.html:4083,energy,energy,4083,psi4manual/1.0.0/psimrcc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/psimrcc-1.html,2,['energy'],['energy']
Energy Efficiency,"obtain orbitals using PSIMRCC’s MCSCF module regardless of what; orbital type is chosen, twocon, rhf, or rohf. An example of the; MCSCF input is given below.; PSIMRCC is most commonly used for low-spin cases (singlets or open-shell; singlets). It is capable of performing computations on higher spin states; (e.g., triplets), but in general, not all the required matrix elements have; been coded for high-spin cases, meaning that results will correspond to an; approximate Mk-MRCC computation for high-spin cases. A Simple Example¶; The CORR_WFN allows you to select one of three methods; Mk-MRPT2 [PT2], Mk-MRCCSD [CCSD], or Mk-MRCCSD(T) [CCSD_T].; The CORR_MULTP option allows you to select the Slater; determinants with a particular value. The WFN_SYM; keyword is neccesary if you do not want to compute the energy of the; totally-symmetric state. The FOLLOW_ROOT option may be used; to follow different roots of the effective Hamiltonian. A value of 1; instructs PSIMRCC to follow the solution with the lowest energy given; a certain set of determinants.; molecule o2 {; 0 3; O; O 1 2.265122720724; units au; }; set {; basis cc-pvtz; }; set mcscf {; reference rohf; docc [3,0,0,0,0,2,1,1] # Doubly occupied MOs; socc [0,0,1,1,0,0,0,0] # Singly occupied MOs; }; set psimrcc {; corr_wfn ccsd # Do Mk-MRCCSD; frozen_docc [1,0,0,0,0,1,0,0] # Frozen MOs; restricted_docc [2,0,0,0,0,1,1,1] # Doubly occupied MOs; active [0,0,1,1,0,0,0,0] # Active MOs; frozen_uocc [0,0,0,0,0,0,0,0] # Frozen virtual MOs; corr_multp 1 # Select the Ms = 0 component; root 1; wfn_sym B1g # Select the B1g state; }; energy('psimrcc'). Note that the oxygen molecule has 16 electrons (including core), while; the docc array contains only 7 doubly-occupied orbitals (or 14; electrons). Hence, two more electrons are available to place into; the active space (given by active), which consists of 2 orbitals.; Thus there are two active electrons in two orbitals. In this particular; example, we are using standard ROHF orbitals ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/psimrcc-1.html:4076,energy,energy,4076,psi4manual/4.0b3/psimrcc-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimrcc-1.html,6,['energy'],['energy']
Energy Efficiency,"ocal_option('OCC', 'WFN_TYPE', 'OMP2'); core.set_local_option('OCC', 'ORB_OPT', 'TRUE'). elif name == 'mp2.5':; core.set_local_option('OCC', 'WFN_TYPE', 'OMP2.5'); core.set_local_option('OCC', 'ORB_OPT', 'FALSE'); elif name == 'omp2.5':; core.set_local_option('OCC', 'WFN_TYPE', 'OMP2.5'); core.set_local_option('OCC', 'ORB_OPT', 'TRUE'). elif name == 'mp3':; core.set_local_option('OCC', 'WFN_TYPE', 'OMP3'); core.set_local_option('OCC', 'ORB_OPT', 'FALSE'); elif name == 'omp3':; core.set_local_option('OCC', 'WFN_TYPE', 'OMP3'); core.set_local_option('OCC', 'ORB_OPT', 'TRUE'). elif name == 'lccd':; core.set_local_option('OCC', 'WFN_TYPE', 'OCEPA'); core.set_local_option('OCC', 'ORB_OPT', 'FALSE'); elif name == 'olccd':; core.set_local_option('OCC', 'WFN_TYPE', 'OCEPA'); core.set_local_option('OCC', 'ORB_OPT', 'TRUE'); else:; raise ValidationError(""""""Invalid method %s"""""" % name). core.set_global_option('DERTYPE', 'FIRST'). # locking out SCS through explicit keyword setting; # * so that current energy must match call; # * since grads not avail for scs; core.set_local_option('OCC', 'DO_SCS', 'FALSE'); core.set_local_option('OCC', 'DO_SOS', 'FALSE'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(). occ_wfn = core.occ(ref_wfn). derivobj = core.Deriv(occ_wfn); grad = derivobj.compute(). occ_wfn.set_gradient(grad). optstash.restore(); return occ_wfn. def run_scf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a self-consistent-field theory (HF & DFT) calculation.; """"""; optstash_mp2 = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['DFMP2', 'MP2_OS_SCALE'],; ['DFMP2', 'MP2_SS_SCALE']). dft_func = False; if ""dft_functional"" in kwargs:; dft_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html:59365,energy,energy,59365,psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,2,['energy'],['energy']
Energy Efficiency,"ocal_option('OCC', 'WFN_TYPE', 'OMP2'); core.set_local_option('OCC', 'ORB_OPT', 'TRUE'). elif name == 'mp2.5':; core.set_local_option('OCC', 'WFN_TYPE', 'OMP2.5'); core.set_local_option('OCC', 'ORB_OPT', 'FALSE'); elif name == 'omp2.5':; core.set_local_option('OCC', 'WFN_TYPE', 'OMP2.5'); core.set_local_option('OCC', 'ORB_OPT', 'TRUE'). elif name == 'mp3':; core.set_local_option('OCC', 'WFN_TYPE', 'OMP3'); core.set_local_option('OCC', 'ORB_OPT', 'FALSE'); elif name == 'omp3':; core.set_local_option('OCC', 'WFN_TYPE', 'OMP3'); core.set_local_option('OCC', 'ORB_OPT', 'TRUE'). elif name == 'lccd':; core.set_local_option('OCC', 'WFN_TYPE', 'OCEPA'); core.set_local_option('OCC', 'ORB_OPT', 'FALSE'); elif name == 'olccd':; core.set_local_option('OCC', 'WFN_TYPE', 'OCEPA'); core.set_local_option('OCC', 'ORB_OPT', 'TRUE'); else:; raise ValidationError(""""""Invalid method %s"""""" % name). core.set_global_option('DERTYPE', 'FIRST'). # locking out SCS through explicit keyword setting; # * so that current energy must match call; # * since grads not avail for scs; core.set_local_option('OCC', 'DO_SCS', 'FALSE'); core.set_local_option('OCC', 'DO_SOS', 'FALSE'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_option('SCF', 'SCF_TYPE'), ref_wfn). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(). occ_wfn = core.occ(ref_wfn). derivobj = core.Deriv(occ_wfn); grad = derivobj.compute(). occ_wfn.set_gradient(grad). optstash.restore(); return occ_wfn. def run_scf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a self-consistent-field theory (HF & DFT) calculation. """""". optstash = proc_util.scf_set_reference_local(name). scf_wfn = scf_helper(name, **kwargs). optstash.restore(); return scf_wfn. def run_scf_gradient(name, **kwargs):; """"",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html:57592,energy,energy,57592,psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,1,['energy'],['energy']
Energy Efficiency,"ocal_option('OCC', 'WFN_TYPE', 'OMP2'); core.set_local_option('OCC', 'ORB_OPT', 'TRUE'). elif name == 'mp2.5':; core.set_local_option('OCC', 'WFN_TYPE', 'OMP2.5'); core.set_local_option('OCC', 'ORB_OPT', 'FALSE'); elif name == 'omp2.5':; core.set_local_option('OCC', 'WFN_TYPE', 'OMP2.5'); core.set_local_option('OCC', 'ORB_OPT', 'TRUE'). elif name == 'mp3':; core.set_local_option('OCC', 'WFN_TYPE', 'OMP3'); core.set_local_option('OCC', 'ORB_OPT', 'FALSE'); elif name == 'omp3':; core.set_local_option('OCC', 'WFN_TYPE', 'OMP3'); core.set_local_option('OCC', 'ORB_OPT', 'TRUE'). elif name == 'lccd':; core.set_local_option('OCC', 'WFN_TYPE', 'OCEPA'); core.set_local_option('OCC', 'ORB_OPT', 'FALSE'); elif name == 'olccd':; core.set_local_option('OCC', 'WFN_TYPE', 'OCEPA'); core.set_local_option('OCC', 'ORB_OPT', 'TRUE'); else:; raise ValidationError(""""""Invalid method %s"""""" % name). core.set_global_option('DERTYPE', 'FIRST'). # locking out SCS through explicit keyword setting; # * so that current energy must match call; # * since grads not avail for scs; core.set_local_option('OCC', 'SPIN_SCALE_TYPE', 'NONE'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(). occ_wfn = core.occ(ref_wfn). derivobj = core.Deriv(occ_wfn); grad = derivobj.compute(). occ_wfn.set_gradient(grad); occ_wfn.set_variable(f""{name.upper()} TOTAL GRADIENT"", grad). # Shove variables into global space; keep_custom_spin_scaling = core.has_option_changed(""OCC"", ""SS_SCALE"") or core.has_option_changed(""OCC"", ""OS_SCALE""); for k, v in occ_wfn.variables().items():; # Custom spin component scaling variables are meaningless if custom scalings hasn't been set. Delete them.; if k.startswith(""CUSTOM",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:74010,energy,energy,74010,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,6,['energy'],['energy']
Energy Efficiency,"ocal_option('OCC', 'WFN_TYPE', 'OMP2'); psi4.set_local_option('OCC', 'ORB_OPT', 'TRUE'). elif name == 'mp2.5':; psi4.set_local_option('OCC', 'WFN_TYPE', 'OMP2.5'); psi4.set_local_option('OCC', 'ORB_OPT', 'FALSE'); elif name == 'omp2.5':; psi4.set_local_option('OCC', 'WFN_TYPE', 'OMP2.5'); psi4.set_local_option('OCC', 'ORB_OPT', 'TRUE'). elif name == 'mp3':; psi4.set_local_option('OCC', 'WFN_TYPE', 'OMP3'); psi4.set_local_option('OCC', 'ORB_OPT', 'FALSE'); elif name == 'omp3':; psi4.set_local_option('OCC', 'WFN_TYPE', 'OMP3'); psi4.set_local_option('OCC', 'ORB_OPT', 'TRUE'). elif name == 'lccd':; psi4.set_local_option('OCC', 'WFN_TYPE', 'OCEPA'); psi4.set_local_option('OCC', 'ORB_OPT', 'FALSE'); elif name == 'olccd':; psi4.set_local_option('OCC', 'WFN_TYPE', 'OCEPA'); psi4.set_local_option('OCC', 'ORB_OPT', 'TRUE'); else:; raise ValidationError(""""""Invalid method %s"""""" % name). psi4.set_global_option('DERTYPE', 'FIRST'). # locking out SCS through explicit keyword setting; # * so that current energy must match call; # * since grads not avail for scs; psi4.set_local_option('OCC', 'DO_SCS', 'FALSE'); psi4.set_local_option('OCC', 'DO_SOS', 'FALSE'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(psi4.get_option('SCF', 'SCF_TYPE'), ref_wfn). if psi4.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(). occ_wfn = psi4.occ(ref_wfn). derivobj = psi4.Deriv(occ_wfn); grad = derivobj.compute(). occ_wfn.set_gradient(grad). optstash.restore(); return occ_wfn. [docs]def run_scf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a self-consistent-field theory (HF & DFT) calculation. """""". optstash = proc_util.scf_set_reference_local(name). scf_wfn = scf_helper(name, **kwargs). optstash.restore(); return scf_wfn. [docs]def run_scf_gradient(name, **",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:47951,energy,energy,47951,psi4manual/1.0.0/_modules/procedures/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html,1,['energy'],['energy']
Energy Efficiency,"ocal_option_changed in module psi4; revoke_local_option_changed(...). revoke_local_option_changed( (str)arg1, (str)arg2) -> None :. Given a string of a keyword name arg2 and a particular module arg1, sets the has_changed attribute in the module options scope to false. Used in python driver when a function sets the value of an option. Before the function exits, this command is called on the option so that has_changed reflects whether the user (not the program) has touched the option.; C++ signature :. void revoke_local_option_changed(Ss,Ss). psi4.run_gdma()¶; Python Library Documentation: built-in function run_gdma in module psi4; run_gdma(...). run_gdma( (Wavefunction)arg1, (str)arg2) -> float :. Runs the GDMA code.; C++ signature :. d run_gdma(N5boost10shared_ptrIN3psi12WavefunctionEEE,Ss). psi4.sapt()¶; Python Library Documentation: built-in function sapt in module psi4; sapt(...). sapt( (Wavefunction)arg1, (Wavefunction)arg2, (Wavefunction)arg3) -> float :. Runs the symmetry adapted perturbation theory code.; C++ signature :. d sapt(N5boost10shared_ptrIN3psi12WavefunctionEEE,N5boost10shared_ptrIN3psi12WavefunctionEEE,N5boost10shared_ptrIN3psi12WavefunctionEEE). psi4.scatter()¶; Python Library Documentation: built-in function scatter in module psi4; scatter(...). scatter( (Molecule)arg1, (float)arg2, (list)arg3, (list)arg4, (list)arg5) -> None :. New Scatter function.; C++ signature :. void scatter(N5boost10shared_ptrIN3psi8MoleculeEEE,d,N5boost6python4listE,N5boost6python4listE,N5boost6python4listE). psi4.scf()¶; Python Library Documentation: built-in function scf in module psi4; scf(...). scf( (Wavefunction)arg1, (object)arg2, (object)arg3) -> Wavefunction :. Runs the SCF code.; C++ signature :. N5boost10shared_ptrIN3psi12WavefunctionEEE scf(N5boost10shared_ptrIN3psi12WavefunctionEEE,P7_object,P7_object). psi4.scfgrad()¶; Python Library Documentation: built-in function scfgrad in module psi4; scfgrad(...). scfgrad( (Wavefunction)arg1) -> Matrix :. Run scfgrad, w",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:40237,adapt,adapted,40237,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['adapt'],['adapted']
Energy Efficiency,"ocalized energy [Eh] of subsystems A and B implemented for F/I-SAPT. SAPT HF(2) ENERGY A(HF)¶; The Hartree–Fock localized energy [Eh] of subsystem A implemented for F/I-SAPT. SAPT HF(2) ENERGY B(HF)¶; The Hartree–Fock localized energy [Eh] of subsystem B implemented for F/I-SAPT. SAPT HF(2) ENERGY C¶; The Hartree–Fock energy [Eh] of subsystem C implemented for F/I-SAPT. SAPT HF(2) ENERGY HF¶; The FI-SAPT Hartree–Fock interaction energy [Eh] implemented for F/I-SAPT. SAPT ELST12,R ENERGY¶; An electrostatics-classified SAPT term energy [Eh] implemented for SAPT2. SAPT EXCH11(S^2) ENERGY¶. SAPT EXCH12(S^2) ENERGY¶; An exchange-classified SAPT term energy [Eh] implemented for SAPT2. SAPT IND22 ENERGY¶. SAPT EXCH-IND22 ENERGY¶; An induction-classified SAPT term energy [Eh] implemented for SAPT2. SAPT DISP21 ENERGY¶; A dispersion-classified SAPT term energy [Eh] implemented for SAPT2+. SAPT DISP22(SDQ) ENERGY¶. SAPT DISP22(T) ENERGY¶. SAPT EST.DISP22(T) ENERGY¶; Dispersion-classified MBPT-based SAPT term energy [Eh] implemented for SAPT2+. SAPT DISP2(CCD) ENERGY¶. SAPT DISP22(S)(CCD) ENERGY¶. SAPT DISP22(T)(CCD) ENERGY¶. SAPT EST.DISP22(T)(CCD) ENERGY¶; Dispersion-classified coupled-cluster-based SAPT term energy [Eh] implemented for SAPT2+. SAPT ELST13,R ENERGY¶; An electrostatics-classified SAPT term energy [Eh] implemented for SAPT2+(3). SAPT IND30,R ENERGY¶. SAPT IND-DISP30 ENERGY¶. SAPT EXCH-IND30,R ENERGY¶; A induction-classified SAPT term energy [Eh] implemented for SAPT2+3. SAPT DISP30 ENERGY¶. SAPT EXCH-DISP30 ENERGY¶. SAPT EXCH-IND-DISP30 ENERGY¶; A dispersion-classified SAPT term energy [Eh] implemented for SAPT2+3. SAPT ALPHA¶; SAPT exchange-scaling alpha. SAPT CT ENERGY¶; SAPT charge-transfer energy. SAPT HF TOTAL ENERGY¶; An induction-classified correction from HF implemented for SAPT0.; Value varies by SAPT level. SAPT MP2 CORRELATION ENERGY¶; An induction-classified correction from MP2 implemented for SAPT2.; Value varies by SAPT level. SAPT0 DISP ENERGY¶. ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html:38142,energy,energy,38142,psi4manual/1.4.0/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html,5,['energy'],['energy']
Energy Efficiency,"ocation with CMAKE_PREFIX_PATH,; and rebuild PSI4 to detect PCMSolver and activate dependent code. Previous bullet had details. To build PSI4 from source and use; pcmsolver from conda without thinking, consult sec:condapsi4dev. To remove a conda installation, conda remove pcmsolver. Source. If using PSI4 built from source and you want PCMSolver built from; from source also,; enable it as a feature with ENABLE_PCMSolver,; and let the build system fetch and build it and activate dependent code. Using the polarizable continuum model¶; The inclusion of a PCM description of the solvent into your calculation; is achieved by setting PCM true in your input file.; PSI4 understands the additional option PCM_SCF_TYPE with possible values total; (the default) or separate.; The latter forces the separate handling of nuclear and electronic electrostatic potentials and; polarization charges. It is mainly useful for debugging. Note; At present PCM can only be used for energy calculations with SCF; wavefunctions and CC wavefunctions in the PTE approximation [Cammi:2009:164104].; All ERI algorithms (PK, OUT_OF_CORE, DIRECT, DF, CD) are supported. Warning; The PCMSolver library cannot exploit molecular point group symmetry. Warning; ROHF with PCM is known not to work. See issue #999 on GitHub.; For the adventurous, a fix is available in pull request #953 on GitHub. Warning; Analytic gradients and Hessians are not available with PCM. Finite differences will be used; regardless of the dertype passed to the optimize function.; See pcmsolver/opt-fd for a sample input. The PCM model and molecular cavity are specified in a pcm section that has; to be explicitly typed in by the user. This additional section follows a syntax; that is slightly different from that of PSI4 and is fully documented; here; A typical input for a Hartree–Fock calculation with PCM would look like the following:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 3",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/pcmsolver-1.html:2102,energy,energy,2102,psi4manual/1.2.1/pcmsolver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/pcmsolver-1.html,2,['energy'],['energy']
Energy Efficiency,"ocations. cc14; ROHF-CCSD/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. ci-multi; BH single points, checking that program can run multiple instances of DETCI in a single input, without an intervening clean() call. omp3-2; OMP3 cc-pCVDZ energy with ROHF initial guess for the NO radical. fd-gradient; SCF STO-3G finite-difference tests. cc36; CC2(RHF)/cc-pVDZ energy of H2O. molden2; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. fd-freq-gradient; SCF STO-3G finite-differences frequencies from gradients for H2O. soscf-dft; Triple and Singlet Oxygen energy SOSCF, also tests non-symmetric density matrices. mp2p5-grad1; MP2.5 cc-pVDZ gradient for the H2O molecule. cc5; RHF CCSD(T) cc-pVDZ frozen-core energy of C4NH4 Anion. tdscf-3; td-wb97x excitation energies of singlet states of h2o, wfn passing. psimrcc-ccsd_t-4; Mk-MRCCSD(T) single point. \(^1A_1\) O$_3` state described using the Ms = 0 component of the singlet. Uses TCSCF orbitals. castup2; SCF with various combinations of pk/density-fitting, castup/no-castup, and spherical/cartesian settings. Demonstrates that puream setting is getting set by orbital basis for all df/castup parts of calc. Demonstrates that answer doesn’t depend on presence/absence of castup. Demonstrates (by comparison to castup3) that output file doesn’t depend on options (scf_type) being set global or local. This input uses global. cc32; CC3/cc-pVDZ H2O \(R_e\) geom from Olsen et al., JCP 104, 8007 (1996). scf-response2; Compute the dipole polarizability for water with custom basis set. dct5; DC-06 calculation for the O2 molecule (triplet ground state). This performs geometry optimization using two-step and simultaneous solution of the response equa",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html:1255,energy,energy,1255,psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"occ - 1.0); energies.append(E); convs.append(C). PsiMod.set_global_option(""FRAC_START"", 2); PsiMod.set_global_option(""FRAC_LOAD"", True); PsiMod.set_global_option(""FRAC_DIIS"", frac_diis); PsiMod.set_global_option(""GUESS"", ""READ""). # Set the next charge/mult; mol.set_molecular_charge(charge) ; mol.set_multiplicity(mult). # Determine HOMO; ref = PsiMod.reference_wavefunction(); eps_a = ref.epsilon_a(); eps_b = ref.epsilon_b(); if (Na == Nb):; HOMO = -Nb; elif (Nb == 0):; HOMO = Na; else:; E_a = eps_a[int(Na - 1)] ; E_b = eps_b[int(Nb - 1)] ; if (E_a >= E_b):; HOMO = Na; else: ; HOMO = -Nb. stats.append('\t%6d %6d %6d %6d %6d %6d\n' %(Nintegral-1, Na, Nb, charge, mult, HOMO)). if (HOMO > 0):; Na = Na - 1; else:; Nb = Nb - 1; charge = charge + 1; mult = Na - Nb + 1; ; PsiMod.set_global_option(""DF_INTS_IO"", ""NONE""). # => Print the results out <= #; E = {}; PsiMod.print_out('\n ==> Fractional Occupation Nuke Results <==\n\n'); PsiMod.print_out('\t%-11s %-24s %-24s %11s\n' %('N', 'Energy', 'HOMO Energy', 'Converged')); for k in range(len(Ns)):; PsiMod.print_out('\t%11.3E %24.16E %24.16E %11d\n' % (Ns[k], energies[k], potentials[k], convs[k])); E[Ns[k]] = energies[k]. PsiMod.print_out('\n'); PsiMod.print_out('\t%6s %6s %6s %6s %6s %6s\n' %('N', 'Na', 'Nb', 'Charge', 'Mult', 'HOMO')); for line in stats: ; PsiMod.print_out(line). PsiMod.print_out('\n\t""You shoot a nuke down a bug hole, you got a lot of dead bugs""\n'); PsiMod.print_out('\t\t\t-Starship Troopers\n'). # Drop the files out; fh = open(traverse_filename, 'w'); fh.write('\t%-11s %-24s %-24s %11s\n' %('N', 'Energy', 'HOMO Energy', 'Converged')); for k in range(len(Ns)):; fh.write('\t%11.3E %24.16E %24.16E %11d\n' % (Ns[k], energies[k], potentials[k], convs[k])); fh.close(). fh = open(stats_filename, 'w'); fh.write('\t%6s %6s %6s %6s %6s %6s\n' %('N', 'Na', 'Nb', 'Charge', 'Mult', 'HOMO')); for line in stats: ; fh.write(line); fh.close(). return E . [docs]def ip_fitting(mol, omega_l, omega_r, **kwargs):; kwargs = kwargs",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/frac.html:9997,Energy,Energy,9997,psi4manual/4.0b2/_modules/frac.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/frac.html,4,['Energy'],['Energy']
Energy Efficiency,"occs.append(occ - 1.0); energies.append(E); convs.append(C). PsiMod.set_global_option(""FRAC_START"", 2); PsiMod.set_global_option(""FRAC_LOAD"", True); PsiMod.set_global_option(""GUESS"", ""READ""); PsiMod.set_global_option(""FRAC_DIIS"", frac_diis); PsiMod.set_global_option(""DF_INTS_IO"", ""LOAD""). PsiMod.set_global_option(""DF_INTS_IO"", old_df_ints_io). # => Print the results out <= #; E = {}; PsiMod.print_out('\n ==> Fractional Occupation Traverse Results <==\n\n'); PsiMod.print_out('\t%-11s %-24s %-24s %11s\n' %('N', 'Energy', 'HOMO Energy', 'Converged')); for k in range(len(occs)):; PsiMod.print_out('\t%11.3E %24.16E %24.16E %11d\n' % (occs[k], energies[k], potentials[k], convs[k])); E[occs[k]] = energies[k]. PsiMod.print_out('\n\t""You trying to be a hero Watkins?""\n'); PsiMod.print_out('\t""Just trying to kill some bugs sir!""\n'); PsiMod.print_out('\t\t\t-Starship Troopers\n'). # Drop the files out; fh = open(traverse_filename, 'w'); fh.write('\t%-11s %-24s %-24s %11s\n' %('N', 'Energy', 'HOMO Energy', 'Converged')); for k in range(len(occs)):; fh.write('\t%11.3E %24.16E %24.16E %11d\n' % (occs[k], energies[k], potentials[k], convs[k])); fh.close(). return E . # Pull all the electrons out, one at a time ; [docs]def frac_nuke(mol, **kwargs):; kwargs = kwargs_lower(kwargs). # The molecule is required, and should be the neutral species; mol.update_geometry(); activate(mol); charge0 = mol.molecular_charge(); mult0 = mol.multiplicity() . # By default, we start the frac procedure on the 25th iteration ; # when not reading a previous guess; frac_start = 25; if kwargs.has_key('frac_start'):; frac_start = kwargs['frac_start']. # By default, we occupy by tenths of electrons; foccs = [1.0, 0.9, 0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2, 0.1, 0.0]; if kwargs.has_key('foccs'):; foccs = kwargs['foccs'] . # By default, HOMO and LUMO are both in alpha; N = 0;; for A in range(mol.natom()):; N += mol.Z(A); N -= charge0; N = int(N); Nb = int((N - mult0 + 1)/2); Na = int(N - Nb). charge = charge0; mul",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/frac.html:6214,Energy,Energy,6214,psi4manual/4.0b2/_modules/frac.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/frac.html,6,['Energy'],['Energy']
Energy Efficiency,"occupied-occupied block of the unperturbed density matrix in analytic derivative calculations. For testing purposes, it is possible to force the use standard perturbed orbitals even in case of iterative triple excitations via the option FORCE_STANDA (dne?). Note also that in case of unrelaxed derivatives standard orbitals must be used. Default : STANDARD for all methods without triples (except CCSDT), CANONICAL for all methods with triples in case of relaxed derivatives. Type: string; Possible Values: STANDARD, CANONICAL, IJ_CANONICAL; Default: No Default. CFOUR_POINTS¶. Specifies either single (=1, or SINGLE) or double (=2, DOUBLE) sided numerical differentiation in the finite difference evaluation of the Hessian. Two-sided numerical differentiation is considerably more accurate than the single-sided method, and its use is strongly recommended for production work. Type: string; Possible Values: SINGLE, DOUBLE; Default: DOUBLE. CFOUR_PRINT¶. Controls the amount of printing in the energy and energy derivative calculation programs. Using a value of 1 will produce a modest amount of additional output over the default value of 0, which includes some useful information such as SCF eigenvectors, Fock matrix elements, etc. Type: integer; Default: 0. CFOUR_PROPS¶. Specifies whether and which molecular property is calculated. OFF (=0) means that no property is calculated, FIRST_ORDER (=1) requests computation of various one-electron first-order properties (e.g., dipole moment, quadrupole moment, electric field gradient, spin densities,etc.), SECOND_ORDER (=2, in the next release replaced by STAT_POL) computes static electric polarizabilities, DYNAMICAL (=7, in the next release replaced by DYN_POL) requests the calculation of frequency-dependent polarizabilities (note that here an additional input of the frequency is required), NMR (=5) requests the calculation of NMR chemical shifts/chemical shielding tensors (by default using GIAOs), J_FC requests the calculation of the Fer",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__cfour-1.html:46023,energy,energy,46023,psi4manual/1.3.2/autodir_options_c/module__cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__cfour-1.html,52,['energy'],['energy']
Energy Efficiency,"ocedure for methane dimer. pywrap-align; apply linear fragmentation algorithm to a water cluster. opt4; SCF cc-pVTZ geometry optimzation, with Z-matrix input. fsapt-ext-abc-au; analog of fsapt-ext-abc with molecule and external potentials in Bohr. psimrcc-ccsd_t-4; Mk-MRCCSD(T) single point. \(^1A_1\) O$_3` state described using the Ms = 0 component of the singlet. Uses TCSCF orbitals. dct-grad1; Various DCT analytic gradients for the O2 molecule with 6-31G basis set. dft3; DFT integral algorithms test, performing w-B97 RKS and UKS computations on water and its cation, using all of the different integral algorithms. This tests both the ERI and ERF integrals. dfcasscf-sp; CASSCF/6-31G** energy point. dft-grad2; DF-BP86-D2 cc-pVDZ frozen core gradient of S22 HCN updated ref gradient due to new BraggSlater radii. olccd-grad2; OLCCD cc-pVDZ gradient for the NO radical. nbody-convergence; Convergence of many-body gradients of different BSSE schemes. sapt-dft2; SAPT(DFT) aug-cc-pVDZ computation for the water dimer interaction energy. cbs-xtpl-dict; Extrapolated water energies. cisd-h2o+-1; 6-31G** H2O+ Test CISD Energy Point. olccd3; OLCCD cc-pVDZ energy with ROHF initial guess for the NO radical. pywrap-freq-g-sowreap; Finite difference of gradients frequency, run in sow/reap mode. cc32; CC3/cc-pVDZ H2O \(R_e\) geom from Olsen et al., JCP 104, 8007 (1996). mints4; A demonstration of mixed Cartesian/ZMatrix geometry specification, using variables, for the benzene-hydronium complex. Atoms can be placed using ZMatrix coordinates, whether they belong to the same fragment or not. Note that the Cartesian specification must come before the ZMatrix entries because the former define absolute positions, while the latter are relative. dfcasscf-fzc-sp; CASSCF/6-31G** energy point. tu5-sapt; Example SAPT computation for ethene*ethine (i.e., ethylene*acetylene), test case 16 from the S22 database. sapt2; SAPT0 aug-cc-pVDZ computation of the benzene-methane interaction energy, using the",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html:21482,energy,energy,21482,psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"ocedure for phenol dimer from the S22 database. dfmp2-freq1; DF-MP2 frequency by difference of energies for H2O. cc56; EOM-CCSD/6-31g excited state transition data for water cation. dfmp2-grad5; Tests DF-MP2 gradient in the presence of a dipole field. dlpnomp2-1; comparison of DF-MP2 and DLPNO-MP2. dft-custom-gga; DFT (LDA/GGA) test of custom implementations in: gga_superfuncs.py. ci-property; CI/MCSCF cc-pvDZ properties for Potassium nitrate (rocket fuel!). fisapt-siao1; This test case shows an example of running the I-SAPT0/jun-cc-pVDZ computation for 2,4-pentanediol (targeting the intramolecular hydrogen bond between the two hydroxyl groups) The SIAO1 link partitioning algorithm is used. An F-SAPT partitioning follows I-SAPT. dfccsd-t-grad2; DF-CCSD(T) cc-pVDZ gradient for the NH molecule. dfomp2-grad1; DF-OMP2 cc-pVDZ gradients for the H2O molecule. soscf-dft; Triple and Singlet Oxygen energy SOSCF, also tests non-symmetric density matrices. fd-freq-energy-large; SCF DZ finite difference frequencies by energies for C4NH4. cc18; RHF-CCSD-LR/cc-pVDZ static polarizability of HOF. tdscf-3; td-wb97x excitation energies of singlet states of h2o, wfn passing. fsapt-diff1; This test case shows an example of running and analyzing a difference F-SAPT0/jun-cc-pvdz procedure for phenol dimer from the S22 database. scf6; Tests RHF/ROHF/UHF SCF gradients. cc8a; ROHF-CCSD(T) cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Cartesian input. dfomp3-2; DF-OMP3 cc-pVDZ energy for the H2O+ cation. cc47; EOM-CCSD/cc-pVDZ on H2O2 with two excited states in each irrep. mp2-def2; Test case for Binding Energy of C4H5N (Pyrrole) with CO2 using MP2/def2-TZVPP. cbs-xtpl-alpha; Extrapolated water energies. nbody-vmfc-gradient; Computation of VMFC-corrected water trimer gradient (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). dft-custom; DFT custom functional test. dft2; DFT Functional Test. molden1; Test of the superposition of atomic densities (",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html:14162,energy,energy-large,14162,psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy-large']
Energy Efficiency,"ocedure. The choice of auxiliary basis is controlled by the keyword; DF_BASIS_CC. By default, DF_BASIS_CC is the RI set; (optimized for DFMP2) most appropriate for use with the primary basis.; For example, if the primary basis is aug-cc-pVDZ, the default; DF_BASIS_CC will be aug-cc-pVDZ-RI.; Alternatively, the user can request that the DF-CCSD(T) procedure use a; set of vectors defined by the Cholesky decomposition of the ERI tensor as; the auxiliary basis. This feature is enabled by specifying CC_TYPE CD.; CD methods can be enabled in the SCF; procedure as well, by specifying the SCF_TYPE as CD. The; accuracy of the decomposition can be controlled through the keyword; CHOLESKY_TOLERANCE.; The following input file sets up a DF-CCSD(T); computation using CD integrals; molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; scf_type cd; cc_type cd; basis aug-cc-pvdz; freeze_core true; }; energy('ccsd(t)'). The resulting CCSD(T) correlation energy will be equivalent to that; obtained from a conventional computation if CHOLESKY_TOLERANCE is; sufficiently small (e.g. ). Gn theory¶; The FNOCC module contains all the components that comprise the Gn family; of composite methods. Currently, only the G2 method is supported; [Curtiss:1991:7221]. The G2 procedure may be called through the; energy() wrapper:; energy('gaussian-2'). Supported methods¶; The various methods supported by the FNOCC module in Psi4 are detailed; in Table FNOCC Methods. Note that these methods; are implemented for closed-shell references only. For open-shell references,; the calls energy('mp2.5'), energy('mp3'), and energy('mp4') will; default to implementations of these methods in other modules Cross-module Redundancies. name; calls method; type select. qcisd; quadratic configuration interaction singles doubles; CI_TYPE CONV. qcisd(t); qcisd with perturbative triples; CI_TYPE CONV. mp2.5; average of second- and third-order perturbation theories; MP_TYPE CONV. mp3; third-order perturbation theory; MP_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/fnocc-1.html:10199,energy,energy,10199,psi4manual/1.0.0/fnocc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/fnocc-1.html,2,['energy'],['energy']
Energy Efficiency,"ocedure. The choice of auxiliary basis is controlled by the keyword; DF_BASIS_CC. By default, DF_BASIS_CC is the RI set; (optimized for DFMP2) most appropriate for use with the primary basis.; For example, if the primary basis is aug-cc-pVDZ, the default; DF_BASIS_CC will be aug-cc-pVDZ-RI.; Alternatively, the user can request that the DF-CCSD(T) procedure use a; set of vectors defined by the Cholesky decomposition of the ERI tensor as; the auxiliary basis. This feature is enabled by specifying CC_TYPE CD.; CD methods can be enabled in the SCF; procedure as well, by specifying the SCF_TYPE as CD. The; accuracy of the decomposition can be controlled through the keyword; CHOLESKY_TOLERANCE.; The following input file sets up a DF-CCSD(T); computation using CD integrals; molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; scf_type cd; cc_type cd; basis aug-cc-pvdz; freeze_core true; }; energy('ccsd(t)'). The resulting CCSD(T) correlation energy will be equivalent to that; obtained from a conventional computation if CHOLESKY_TOLERANCE is; sufficiently small (e.g. 1e-9). Gn theory¶; The FNOCC module contains all the components that comprise the Gn family; of composite methods. Currently, only the G2 method is supported; [Curtiss:1991:7221]. The G2 procedure may be called through the; energy() wrapper:; energy('gaussian-2'). Supported methods¶; The various methods supported by the FNOCC module in PSI4 are detailed; in Table FNOCC Methods. Note that these methods; are implemented for closed-shell references only. For open-shell references,; the calls energy('mp2.5'), energy('mp3'), and energy('mp4') will; default to implementations of these methods in other modules. name; calls method; type select. qcisd; quadratic configuration interaction singles doubles; CI_TYPE CONV. qcisd(t); qcisd with perturbative triples; CI_TYPE CONV. mp2.5; average of second- and third-order perturbation theories; MP_TYPE CONV. mp3; third-order perturbation theory; MP_TYPE CONV. mp4(sdq); f",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/fnocc-1.html:12184,energy,energy,12184,psi4manual/1.4.0/fnocc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/fnocc-1.html,5,['energy'],['energy']
Energy Efficiency,"ocedure. The choice of auxiliary basis is controlled by the keyword; DF_BASIS_CC. By default, DF_BASIS_CC is the RI set; (optimized for DFMP2) most appropriate for use with the primary basis.; For example, if the primary basis is aug-cc-pVDZ, the default; DF_BASIS_CC will be aug-cc-pVDZ-RI.; Alternatively, the user can request that the DF-CCSD(T) procedure use a; set of vectors defined by the Cholesky decomposition of the ERI tensor as; the auxiliary basis. This feature is enabled by specifying CC_TYPE CD.; CD methods can be enabled in the SCF; procedure as well, by specifying the SCF_TYPE as CD. The; accuracy of the decomposition can be controlled through the keyword; CHOLESKY_TOLERANCE.; The following input file sets up a DF-CCSD(T); computation using CD integrals; molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; scf_type cd; cc_type cd; basis aug-cc-pvdz; freeze_core true; }; energy('ccsd(t)'). The resulting CCSD(T) correlation energy will be equivalent to that; obtained from a conventional computation if CHOLESKY_TOLERANCE is; sufficiently small (e.g. 1e-9). Gn theory¶; The FNOCC module contains all the components that comprise the Gn family; of composite methods. Currently, only the G2 method is supported; [Curtiss:1991:7221]. The G2 procedure may be called through the; energy() wrapper:; energy('gaussian-2'). Supported methods¶; The various methods supported by the FNOCC module in PSI4 are; summarized in Table FNOCC Methods; and detailed (except FNO) in Table FNOCC Capabilities. Note that these methods are implemented; for closed-shell reference only. Without set qc_module fnocc,; these methods may default to implementations in other modules. Theoretical methods accessible through FNOCC¶. name; calls method; plain; FNO. mp3; third-order MP perturbation theory; E; E. mp4(sdq); fourth-order MP perturbation theory, less triples; E; E. mp4; full fourth-order MP perturbation theory; E; E. cisd; configuration interaction singles and doubles; E; E. qcisd; q",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/fnocc.html:12184,energy,energy,12184,psi4manual/1.7.x/fnocc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/fnocc.html,4,['energy'],['energy']
Energy Efficiency,"ock method, without; any dispersion correction; the first three (or four, since; ) terms in Eq. (3). Quantity ; in Eq. (3). LCC2 (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CC2 level of theory. LCCSD (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CCSD level of theory. MP2 TOTAL ENERGY¶. MP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2 level of theory. MP2.5 TOTAL ENERGY¶. MP2.5 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2.5 level of theory. MP3 TOTAL ENERGY¶. MP3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP3 level of theory. MPn TOTAL ENERGY¶. MPn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled Möller–Plesset perturbation theory level.; n is MP perturbation order. NUCLEAR REPULSION ENERGY¶; The nuclear repulsion energy contribution [H] to the total SCF energy.; Quantity in Eq. (3). (2). ONE-ELECTRON ENERGY¶; The one-electron energy contribution [H] to the total SCF energy.; Quantity in Eq. (3). SAPT DISP ENERGY¶. SAPT ELST ENERGY¶. SAPT EXCH ENERGY¶. SAPT IND ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total electronic interaction energy [H] for the the; requested SAPT level of theory. The sum of these four components yields; SAPT ENERGY. SAPT ENERGY¶; The total electronic interaction energy [H] for the requested SAPT; level of theory. SAPT SAPT0 ENERGY¶. SAPT SAPT2 ENERGY¶. SAPT SAPT2+ ENERGY¶. SAPT SAPT2+(3) ENERGY¶. SAPT SAPT2+3 ENERGY¶; The total electronic interaction energy [H] for the labeled SAPT level; of theory. SCF DIPOLE X¶. SCF DIPOLE Y¶. SCF DIPOLE Z¶; The three components of the SCF dipole [Debye]. SCF QUADRUPOLE XX¶. SCF QUADRUPOLE XY¶. SCF QUADRUPOLE XZ¶. SCF QUADRUPOLE YY¶. SCF QUADRUPOLE YZ¶. SCF QUADRUPOLE ZZ¶; The six ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html:12481,energy,energy,12481,psi4manual/4.0b3/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html,4,['energy'],['energy']
Energy Efficiency,"ocs] def charge(self):; """"""The ""atomic charge"" of the current atom (for SAD purposes).""""""; return self.PYcharge. [docs] def mass(self):; """"""The atomic mass of the current atom.""""""; return self.PYmass. [docs] def symbol(self):; """"""The atomic symbol.""""""; return self.PYsymbol. [docs] def label(self):; """"""The atom label.""""""; return self.PYlabel. [docs] def entry_number(self):; """"""The order in which this appears in the full atom list.""""""; return self.PYentry_number. [docs] def everything(self):; print '\nCoordEntry\n Entry Number = %d\n Computed = %s\n Z = %d\n Charge = %f\n Mass = %f\n Symbol = %s\n Label = %s\n Ghosted = %s\n Coordinates = %s\n\n' % \; (self.entry_number(), self.is_computed(), self.Z(), self.charge(), self.mass(), self.symbol(), self.label(), self.is_ghosted(), self.coordinates). [docs]class CartesianEntry(CoordEntry):; """"""Class to hold all information about an atom, including its; coordinate specification as three Cartesians. """"""; def __init__(self, entry_number, Z, charge, mass, symbol, label, x, y, z):; CoordEntry.__init__(self, entry_number, Z, charge, mass, symbol, label); self.x = x; self.y = y; self.z = z. [docs] def compute(self):; """"""Computes the values of the coordinates (in whichever units; were inputted), returning them in a Vector. """"""; if self.computed:; return self.coordinates; self.coordinates[0] = self.x.compute(); self.coordinates[1] = self.y.compute(); self.coordinates[2] = self.z.compute(); self.computed = True; return self.coordinates. [docs] def set_coordinates(self, x, y, z):; """"""Given the current set of coordinates, updates the values of this; atom's coordinates and any variables that may depend on it. """"""; self.coordinates[0] = x; self.coordinates[1] = y; self.coordinates[2] = z. self.x.rset(x); self.y.rset(y); self.z.rset(z). self.computed = True. [docs] def type(self):; """"""The type of CoordEntry specialization.""""""; return 'CartesianCoord'. [docs] def print_in_input_format(self):; """"""Prints the updated geometry, in the format p",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintscoordentry.html:7940,charge,charge,7940,psi4manual/4.0b3/_modules/qcdb/libmintscoordentry.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintscoordentry.html,6,['charge'],['charge']
Energy Efficiency,"ocs]def build_m05_2x_superfunctional(name, npoints, deriv):. # Call this first; sup = PsiMod.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('M05-2X'); # Tab in, trailing newlines; sup.set_description(' Heavily Parameterized Hybrid Meta-GGA XC Functional\n'); # Tab in, trailing newlines; sup.set_citation(' Zhao et. al., J. Chem. Theory Comput., 2, 364, 2006\n'). # Add member functionals; X = build_functional('M_X'); X.set_name('M05_2X_X'); X.set_alpha(1.0). # LSDA Exchange type is Slater, no parameters. # GGA Exchange type is PBE, special parameters because Truhlar is lazy; C1 = 3.36116E-3; C2 = 4.49267E-3; K0 = 3.0 / 2.0 * math.pow(3.0 / (math.pi * 4.0), 1.0 / 3.0); k0 = math.pow(6.0 * math.pi * math.pi, 1.0 / 3.0); kp = C1 / (C2 * K0); mu = 4.0 * k0 * k0 * kp * C2; X.set_parameter('PBE_kp', kp); X.set_parameter('PBE_mu', mu). # Meta Exchange type is insane mess of w power series expansion; X.set_parameter('Meta_a0', 1.0); X.set_parameter('Meta_a1', -0.56833); X.set_parameter('Meta_a2', -1.30057); X.set_parameter('Meta_a3', 5.50070); X.set_parameter('Meta_a4', 9.06402); X.set_parameter('Meta_a5', -32.21075); X.set_parameter('Meta_a6', -23.73298); X.set_parameter('Meta_a7', 70.22996); X.set_parameter('Meta_a8', 29.88614); X.set_parameter('Meta_a9', -60.25778); X.set_parameter('Meta_a10', -13.22205); X.set_parameter('Meta_a11', 15.23694). C = build_functional('M_C'); C.set_name('M05_2X_C'). # LSDA Correlation type is PW92, no parameters. # GGA Correlation type is B97; C.set_parameter('B97_os_gamma', 0.0031 * 2.0); C.set_parameter('B97_os_a0', 1.00000); C.set_parameter('B97_os_a1', 1.09297); C.set_parameter('B97_os_a2', -3.79171); C.set_parameter('B97_os_a3', 2.82810); C.set_parameter('B97_os_a4', -10.58909). C.set_parameter('B97_ss_gamma', 0.06); C.set_parameter('B97_ss_a0', 1.00000); C.set_parameter('B97_ss_a1', -3.05430); C.set_parameter('B",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/functional.html:64424,power,power,64424,psi4manual/4.0b4/_modules/functional.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/functional.html,2,['power'],['power']
Energy Efficiency,"ocstring. DTBMV(arg0, arg1, arg2, arg3, arg4, arg5, …); docstring. DTBSV(arg0, arg1, arg2, arg3, arg4, arg5, …); docstring. DTRMM(arg0, arg1, arg2, arg3, arg4, arg5, …); docstring. DTRMV(arg0, arg1, arg2, arg3, arg4, arg5, …); docstring. DTRSM(arg0, arg1, arg2, arg3, arg4, arg5, …); docstring. DTRSV(arg0, arg1, arg2, arg3, arg4, arg5, …); docstring. IDAMAX(arg0, arg1, arg2, arg3); docstring. adc(arg0); Runs the ADC propagator code, for excited states. array_variable(arg0); Returns copy of the requested (case-insensitive) Matrix QC variable. array_variables(); Returns dictionary of all Matrix QC variables. be_quiet(); Redirects output to /dev/null. benchmark_blas1(arg0, arg1); docstring. benchmark_blas2(arg0, arg1); docstring. benchmark_blas3(arg0, arg1, arg2); docstring. benchmark_disk(arg0, arg1); docstring. benchmark_integrals(arg0, arg1); docstring. benchmark_math(arg0); docstring. ccdensity(arg0); Runs the code to compute coupled cluster density matrices. ccenergy(arg0); Runs the coupled cluster energy code. cceom(arg0); Runs the equation of motion coupled cluster code, for excited states. cchbar(arg0); Runs the code to generate the similarity transformed Hamiltonian. cclambda(arg0); Runs the coupled cluster lambda equations code. ccresponse(arg0); Runs the coupled cluster response theory code. cctransort(arg0); Runs CCTRANSORT, which transforms and reorders integrals for use in the coupled cluster codes. cctriples(arg0); Runs the coupled cluster (T) energy code. clean(); Function to remove scratch files. clean_options(); Function to reset options to clean state. clean_variables(); Empties all PSI scalar and array variables that have been set internally. close_outfile(); Closes the output file. dcft(arg0); Runs the density cumulant functional theory code. del_array_variable(arg0); Removes the requested (case-insensitive) Matrix QC variable. del_scalar_variable(arg0); Removes the requested (case-insensitive) double QC variable. del_variable(key). detci(arg0); Run",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psi4api-1.html:293185,energy,energy,293185,psi4manual/1.3.2/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psi4api-1.html,2,['energy'],['energy']
Energy Efficiency,"ocstring. DTRMM((arg0: int, arg1: str, arg2: str, ...); docstring. DTRMV((arg0: int, arg1: str, arg2: str, ...); docstring. DTRSM((arg0: int, arg1: str, arg2: str, ...); docstring. DTRSV((arg0: int, arg1: str, arg2: str, ...); docstring. IDAMAX((arg0: int, arg1: int, ...); docstring. adc(...); Runs the ADC propagator code, for excited states. atomic_displacements(...); Returns list of displacements generated by displacing each atom in the +/- x, y, z directions. be_quiet(() -> None); Redirects output to /dev/null. benchmark_blas1((arg0: int, arg1: float) -> None); docstring. benchmark_blas2((arg0: int, arg1: float) -> None); docstring. benchmark_blas3((arg0: int, arg1: float, ...); docstring. benchmark_disk((arg0: int, arg1: float) -> None); docstring. benchmark_integrals((arg0: int, ...); docstring. benchmark_math((arg0: float) -> None); docstring. ccdensity((arg0: psi::Wavefunction) -> float); Runs the code to compute coupled cluster density matrices. ccenergy(...); Runs the coupled cluster energy code. cceom((arg0: psi::Wavefunction) -> float); Runs the equation of motion coupled cluster code, for excited states. cchbar((arg0: psi::Wavefunction) -> None); Runs the code to generate the similarity transformed Hamiltonian. cclambda(...); Runs the coupled cluster lambda equations code. ccresponse((arg0: psi::Wavefunction) -> float); Runs the coupled cluster response theory code. cctransort((arg0: psi::Wavefunction) -> None); Runs CCTRANSORT, which transforms and reorders integrals for use in the coupled cluster codes. cctriples((arg0: psi::Wavefunction) -> float); Runs the coupled cluster (T) energy code. clean(() -> None); Function to remove scratch files. clean_options(() -> None); Function to reset options to clean state. clean_variables(() -> None); Empties all PSI variables that have set internally. close_outfile(() -> None); Closes the output file. dcft(...); Runs the density cumulant functional theory code. detci(...); Runs the determinant-based configuration ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psi4api-1.html:162317,energy,energy,162317,psi4manual/1.1.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psi4api-1.html,2,['energy'],['energy']
Energy Efficiency,"ocstring. DiagonalizeOrder; docstring. Dimension; docstring. DipoleInt; docstring. DiskSOMCSCF; docstring. Dispersion; docstring. EFP; Class interfacing with libefp. ERI; docstring. ElectricFieldInt; docstring. ElectrostaticInt; docstring. ErfComplementERI; docstring. ErfERI; docstring. ExternalPotential; docstring. F12; docstring. F12DoubleCommutator; docstring. F12G12; docstring. F12Squared; docstring. FCHKWriter; docstring. FittedSlaterCorrelationFactor; docstring. FittingMetric; docstring. Functional; docstring. Gaussian94BasisSetParser; docstring. GaussianShell; docstring. GaussianType; docstring. GeometryUnits; docstring. HF; docstring. IO; docstring. IOManager; docstring. IntVector; docstring. IntegralFactory; docstring. JK; docstring. KineticInt; docstring. LaplaceDenominator; docstring. Localizer; docstring. MOWriter; docstring. Matrix; docstring. MatrixFactory; docstring. MintsHelper; docstring. MoldenWriter; docstring. Molecule; Class to store the elements, coordinates, fragmentation pattern, basis sets, charge, multiplicity, etc. MultipoleInt; docstring. MultipoleSymmetry; docstring. NBOWriter; docstring. NablaInt; docstring. OEProp; docstring. OneBodyAOInt; docstring. OrbitalSpace; docstring. OverlapInt; docstring. PMLocalizer; docstring. PetiteList; docstring. PointGroup; docstring. PotentialInt; docstring. PrimitiveType; docstring. Prop; docstring. PseudoTrial; docstring. PseudospectralInt; docstring. PsiReturnType; docstring. QuadrupoleInt; docstring. RHF; docstring. ROHF; docstring. SOBasisSet; docstring. SOMCSCF; docstring. ShellInfo. SuperFunctional; docstring. SymmetryOperation; Class to provide a 3 by 3 matrix representation of a symmetry operation, such as a rotation or reflection. ThreeCenterOverlapInt; docstring. TracelessQuadrupoleInt; docstring. TwoBodyAOInt; docstring. TwoElectronInt; docstring. UHF; docstring. VBase; docstring. Vector; docstring. Vector3; Class for vectors of length three, often Cartesian coordinate vectors, and their com",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psi4api-1.html:173548,charge,charge,173548,psi4manual/1.1.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psi4api-1.html,2,['charge'],['charge']
Energy Efficiency,"ocstring. cphf_Hx(self, arg0); CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self); Adds occupied guess alpha orbitals. cphf_solve(self, x_vec, conv_tol, max_iter, …); Solves the CPHF equations for a given set of x vectors. damping_update(self, arg0); docstring. deep_copy(self, arg0); Deep copies the internal data. del_array_variable(self, arg0); Removes the requested (case-insensitive) Matrix QC variable. del_potential_variable(self, arg0); Removes the requested (case-insensitive) ExternalPotential QC variable. del_scalar_variable(self, arg0); Removes the requested (case-insensitive) double QC variable. del_variable(key); Removes scalar or array QCVariable key from cls if present. density_fitted(self); Returns whether this wavefunction was obtained using density fitting or not. diis(self); docstring. diis_manager(self); docstring. doccpi(self); Returns the number of doubly occupied orbitals per irrep. efzc(self); Returns the frozen-core energy. energy(self); Returns the Wavefunction’s energy. epsilon_a(self); Returns the Alpha Eigenvalues. epsilon_a_subset(self, arg0, arg1); Returns the requested Alpha Eigenvalues subset. epsilon_b(self); Returns the Beta Eigenvalues. epsilon_b_subset(self, arg0, arg1); Returns the requested Beta Eigenvalues subset. esp_at_nuclei(self); returns electrostatic potentials at nuclei. external_pot(self); Gets the requested external potential. finalize(self); Cleans up the the Wavefunction’s temporary data. finalize_energy(); Performs stability analysis and calls back SCF with new guess if needed, Returns the SCF energy. find_occupation(self); docstring. force_doccpi(self, arg0); Specialized expert use only. force_soccpi(self, arg0); Specialized expert use only. form_C(self, shift); Forms the Orbital Matrices from the current Fock Matrices. form_D(self); Forms the Density Matrices from the current Orbitals Matrices. form_F(self); Forms the F matrix. form_G(self); Forms the G matrix. form_H(self); Forms the core Hamiltonia",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.cuhf.html:4165,energy,energy,4165,psi4manual/1.4.0/api/psi4.core.cuhf.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.cuhf.html,16,['energy'],['energy']
Energy Efficiency,"ocstring. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. efzc(self: psi4.core.Wavefunction) → float¶; Returns the frozen-core energy. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunction’s energy. epsilon_a(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Alpha Eigenvalues subset. epsilon_b(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Beta Eigenvalues subset. esp_at_nuclei(self: psi4.core.Wavefunction) → psi4.core.Vector¶; returns electrostatic potentials at nuclei. finalize(self: psi4.core.HF) → None¶; Cleans up the the Wavefunction’s temporary data. finalize_energy()¶; Performs stability analysis and calls back SCF with new guess; if needed, Returns the SCF energy. This function should be called; once orbitals are ready for energy/property computations, usually; after iterations() is called. find_occupation(self: psi4.core.HF) → None¶; docstring. force_doccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶; Specialized expert use only. Sets the number of doubly occupied oribtals per irrep. Note that this results in inconsistent Wavefunction objects for SCF, so caution is advised. force_soccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶; Specialized expert use only. Sets the number of singly occupied oribtals per irrep. Note that this results in inconsistent Wavefunction objects for SCF, so caution is advised. form_C(self: psi4.core.HF) → None¶; Forms the Orbital Matrices from the current Fock Matrices. form_D(self: psi4.core.HF) → None¶; Forms the Density Matrices from the current Orbitals Matrices. form_F(self: psi4.core.HF) → None¶; Forms the F mat",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.cuhf.html:6976,energy,energy,6976,psi4manual/1.3.2/api/psi4.core.cuhf.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.cuhf.html,14,['energy'],['energy']
Energy Efficiency,"ocstring; | ; | Da(...); | Da( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Db(...); | Db( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fa(...); | Fa( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fb(...); | Fb( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | add_postiteration_callback(...); | add_postiteration_callback( (Wavefunction)arg1, (object)arg2) -> None :; | docstring; | ; | add_preiteration_callback(...); | add_preiteration_callback( (Wavefunction)arg1, (object)arg2) -> None :; | docstring; | ; | alpha_orbital_space(...); | alpha_orbital_space( (Wavefunction)arg1, (str)arg2, (str)arg3, (str)arg4) -> OrbitalSpace :; | docstring; | ; | basisset(...); | basisset( (Wavefunction)arg1) -> BasisSet :; | docstring; | ; | beta_orbital_space(...); | beta_orbital_space( (Wavefunction)arg1, (str)arg2, (str)arg3, (str)arg4) -> OrbitalSpace :; | docstring; | ; | doccpi(...); | doccpi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | energy(...); | energy( (Wavefunction)arg1) -> float :; | docstring; | ; | epsilon_a(...); | epsilon_a( (Wavefunction)arg1) -> Vector :; | docstring; | ; | epsilon_b(...); | epsilon_b( (Wavefunction)arg1) -> Vector :; | docstring; | ; | frequencies(...); | frequencies( (Wavefunction)arg1) -> Vector :; | docstring; | ; | frzcpi(...); | frzcpi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | frzvpi(...); | frzvpi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | gradient(...); | gradient( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | molecule(...); | molecule( (Wavefunction)arg1) -> Molecule :; | docstring; | ; | nalpha(...); | nalpha( (Wavefunction)arg1) -> int :; | docstring; | ; | nalphapi(...); | nalphapi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | nbeta(...); | nbeta( (Wavefunction)arg1) -> int :; | docstring; | ; | nbetapi(...); | nbetapi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | nirrep(...); | nirrep( (Wavef",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/psimod-1.html:94496,energy,energy,94496,psi4manual/4.0b3/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html,6,['energy'],['energy']
Energy Efficiency,"ocstring; | ; | diagonalize(...); | diagonalize( (Matrix)arg1, (Matrix)arg2, (Vector)arg3, (DiagonalizeOrder)arg4) -> None :; | docstring; | ; | gemm(...); | gemm( (Matrix)arg1, (bool)arg2, (bool)arg3, (float)arg4, (Matrix)arg5, (Matrix)arg6, (float)arg7) -> None :; | docstring; | ; | get(...); | get( (Matrix)arg1, (int)arg2, (int)arg3 [, (int)arg4]) -> float :; | docstring; | ; | identity(...); | identity( (Matrix)arg1) -> None :; | docstring; | ; | invert(...); | invert( (Matrix)arg1) -> None :; | docstring; | ; | load(...); | load( (Matrix)arg1, (str)arg2) -> None :; | docstring; | ; | load_mpqc(...); | load_mpqc( (Matrix)arg1, (str)arg2) -> None :; | docstring; | ; | name(...); | name( (Matrix)arg1) -> str :; | docstring; | ; | nirrep(...); | nirrep( (Matrix)arg1) -> int :; | docstring; | ; | partial_cholesky_factorize(...); | partial_cholesky_factorize( (Matrix)arg1, (float)arg2, (bool)arg3) -> Matrix :; | docstring; | ; | power(...); | power( (Matrix)arg1, (float)arg2, (float)arg3) -> Dimension :; | docstring; | ; | print_out(...); | print_out( (Matrix)arg1) -> None :; | docstring; | ; | project_out(...); | project_out( (Matrix)arg1, (Matrix)arg2) -> None :; | docstring; | ; | remove_symmetry(...); | remove_symmetry( (Matrix)arg1, (Matrix)arg2, (Matrix)arg3) -> None :; | docstring; | ; | rms(...); | rms( (Matrix)arg1) -> float :; | docstring; | ; | rowdim(...); | rowdim( (Matrix)arg1) -> Dimension :; | docstring; | ; | rows(...); | rows( (Matrix)arg1, (int)arg2) -> int :; | docstring; | ; | save(...); | save( (Matrix)arg1, (str)arg2, (bool)arg3, (bool)arg4, (bool)arg5) -> None :; | docstring; | ; | scale(...); | scale( (Matrix)arg1, (float)arg2) -> None :; | docstring; | ; | scale_column(...); | scale_column( (Matrix)arg1, (int)arg2, (int)arg3, (float)arg4) -> None :; | docstring; | ; | scale_row(...); | scale_row( (Matrix)arg1, (int)arg2, (int)arg3, (float)arg4) -> None :; | docstring; | ; | set(...); | set( (Matrix)arg1, (int)arg2, (int)arg3, (float)arg4) ->",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/psimod-1.html:37806,power,power,37806,psi4manual/4.0b2/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html,8,['power'],['power']
Energy Efficiency,"ocumented; here; A typical input for a Hartree–Fock calculation with PCM would look like the following:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33molecule NH3 {; symmetry c1; N -0.0000000001 -0.1040380466 0.0000000000; H -0.9015844116 0.4818470201 -1.5615900098; H -0.9015844116 0.4818470201 1.5615900098; H 1.8031688251 0.4818470204 0.0000000000; units bohr; no_reorient; no_com; }. set {; basis STO-3G; scf_type pk; pcm true; pcm_scf_type total; }. pcm = {; Units = Angstrom; Medium {; SolverType = IEFPCM; Solvent = Water; }. Cavity {; RadiiSet = UFF; Type = GePol; Scaling = False; Area = 0.3; Mode = Implicit; }; }. More examples can be found in the directories with PCM tests; pcmsolver/ccsd-pte,; pcmsolver/scf,; pcmsolver/opt-fd,; pcmsolver/dft, and; pcmsolver/dipole. Keywords for PCMSolver¶. PCM¶. PCM boolean for pcmsolver module. Type: boolean; Default: false. PCM_SCF_TYPE¶. Use total or separate potentials and charges in the PCM-SCF step. Type: string; Possible Values: TOTAL, SEPARATE; Default: TOTAL. PCM_CC_TYPE¶. PCM-CCSD algorithm type. Type: string; Possible Values: PTE; Default: PTE. How to configure PCMSolver for building Psi4¶; Role and Dependencies. Role — In PSI4, PCMSolver is a library that provides additional; quantum chemical capabilities (solvation modeling).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) PCMSolver; Upstream Dependencies — PCMSolver \(\Leftarrow\) Fortran, zlib. CMake Variables. ENABLE_PCMSolver — CMake variable toggling whether Psi4 builds with PCMSolver; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For PCMSolver, set to an installation directory containing include/PCMSolver/pcmsolver.h; PCMSolver_DIR — CMake variable to specify where pre-built PCMSolver can be found. Set to installation directory containing share/cmake/PCMSolver/PCMSolverConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_PCMSolver — CMake ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/pcmsolver-1.html:3928,charge,charges,3928,psi4manual/1.2.1/pcmsolver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/pcmsolver-1.html,2,['charge'],['charges']
Energy Efficiency,"od for which a third delta correction; to the correlation energy is to be obtained. delta3_wfn_lesser (string) – \(\Rightarrow\) delta2_wfn \(\Leftarrow\) || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a third delta correction; to the correlation energy is to be obtained. delta4_wfn (string) – 'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a fourth delta correction; to the correlation energy is to be obtained. delta4_wfn_lesser (string) – \(\Rightarrow\) delta3_wfn \(\Leftarrow\) || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a fourth delta correction; to the correlation energy is to be obtained. delta5_wfn (string) – 'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a fifth delta correction; to the correlation energy is to be obtained. delta5_wfn_lesser (string) – \(\Rightarrow\) delta4_wfn \(\Leftarrow\) || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a fifth delta correction; to the correlation energy is to be obtained. Basis Sets; Currently, the basis set set through set commands have no influence; on a cbs calculation. Parameters:; scf_basis (basis string) – \(\Rightarrow\) corl_basis \(\Leftarrow\) || 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, scf_basis can default; to corl_basis. corl_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the correlation energy. delta_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. delta2_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. delta3_basis (b",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/cbs-1.html:5886,energy,energy,5886,psi4manual/1.2.1/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/cbs-1.html,14,['energy'],['energy']
Energy Efficiency,"od from which the delta correction is to be calculated. By default, it is set to ```wfn``` from the previous field in the ```cbs_metadata``` array.; * ```basis_lo```: basis set to be used for the delta correction. By default, it is the same as the ```basis``` specified above. * Others. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> energy(cbs, scf_wfn='scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> energy(cbs, corl_wfn='mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> energy('cbs', scf_wfn='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme='scf_xtpl_helgaker_3'). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> energy('cbs', corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme='corl_xtpl_helgaker_2'). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme='corl_xtpl_helgaker_2', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme='corl_xtpl_helgaker_2'). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme='corl_xtpl_helgaker_2', delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] a Q5-zeta MP2 calcul",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html:33651,energy,energy,33651,psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html,20,['energy'],['energy']
Energy Efficiency,"od is requested. Quantity ; in Eqs. (3) and (1). DOUBLE-HYBRID CORRECTION ENERGY¶; The scaled MP2 correlation energy correction [H] appended to an; underlying functional when a DH-DFT method is requested.; Quantity in Eq. (1). FCI TOTAL ENERGY¶. FCI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the full configuration interaction level of theory. HF TOTAL ENERGY¶; The total electronic energy [H] for the Hartree–Fock method, without; any dispersion correction; the first three (or four, since; ) terms in Eq. (3). Quantity ; in Eq. (3). LCC2 (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CC2 level of theory. LCCSD (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CCSD level of theory. MP2 TOTAL ENERGY¶. MP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2 level of theory. MP2.5 TOTAL ENERGY¶. MP2.5 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2.5 level of theory. MP3 TOTAL ENERGY¶. MP3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP3 level of theory. MPn TOTAL ENERGY¶. MPn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled Möller–Plesset perturbation theory level.; n is MP perturbation order. NUCLEAR REPULSION ENERGY¶; The nuclear repulsion energy contribution [H] to the total SCF energy.; Quantity in Eq. (3). (2). ONE-ELECTRON ENERGY¶; The one-electron energy contribution [H] to the total SCF energy.; Quantity in Eq. (3). SAPT DISP ENERGY¶. SAPT ELST ENERGY¶. SAPT EXCH ENERGY¶. SAPT IND ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total electronic interaction energy [H] for the the; requested SAPT level of theory. The sum of these four components yields; SAPT ENERGY. SAPT ENERGY¶; The total electronic interaction ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html:12008,energy,energy,12008,psi4manual/4.0b3/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html,4,['energy'],['energy']
Energy Efficiency,"od is requested. Quantity ; in Eqs. (4) and (1). DOUBLE-HYBRID CORRECTION ENERGY¶; The scaled MP2 correlation energy correction [H] appended to an; underlying functional when a DH-DFT method is requested.; Quantity in Eq. (1). FCI TOTAL ENERGY¶. FCI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the full configuration interaction level of theory. HF TOTAL ENERGY¶; The total electronic energy [H] for the Hartree–Fock method, without; any dispersion correction; the first three (or four, since; ) terms in Eq. (4). Quantity ; in Eq. (4). LCC2 (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CC2 level of theory. LCCSD (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CCSD level of theory. MP2 TOTAL ENERGY¶. MP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2 level of theory. MP2.5 TOTAL ENERGY¶. MP2.5 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2.5 level of theory. MP3 TOTAL ENERGY¶. MP3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP3 level of theory. MP4(SDQ) TOTAL ENERGY¶. MP4(SDQ) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP4 singles, doubles, quadruples level of theory. Quantity; MP4(SDQ) CORRELATION ENERGY is; first right-hand term in Eq. (2). MP4 TOTAL ENERGY¶. MP4 CORRELATION ENERGY¶. MP4(SDTQ) TOTAL ENERGY¶. MP4(SDTQ) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the full MP4 level of theory. Quantity MP4 CORRELATION; ENERGY / MP4(SDTQ) CORRELATION ENERGY is left-hand term in Eq. (2). (2). MPn TOTAL ENERGY¶. MPn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled Möller–Plesset perturbation theory level.; n is MP perturbation order. NUCLEAR REPULSION ENERGY",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/glossary_psivariables-1.html:12202,energy,energy,12202,psi4manual/1.0.0/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/glossary_psivariables-1.html,12,['energy'],['energy']
Energy Efficiency,"od, where only the; product of the electronic Hessian with the step vector is computed for; efficiency. By default, the electronic Hessian is build for both the cumulant and orbital; updates and both updates are performed simultaneously. Setting the QC_TYPE; option to TWOSTEP will perform the Newton-Raphson update only for the orbitals,; while the equations for the cumulant will be solved using a standard Jacobi update.; If requested by the user (set QC_COUPLING to TRUE), the electronic Hessian can include; matrix elements that couple the orbitals and the density cumulant.; The computation of these coupling elements increases; the cost of the macroiteration, but usually leads to faster convergence and is; recommended for open-shell systems.; It is important to note that the quadratically-convergent algorithm is not yet fully; optimized and often converges slowly when the RMS of the cumulant or; the orbital gradient is below \(10^{-7}\). The choice of the iterative algorithm can significantly affect the cost of the; energy computation. While the two-step algorithm requires a small number of; disk-intensive \({\cal O}(N^5)\) integral transformations, the simultaneous; algorithm benefits from a smaller number of expensive \({\cal O}(N^6)\); cumulant updates. As a result, for small closed-shell systems the two-step; algorithm is usually preferred, while for larger systems and molecules with; open-shell character it is recommended to use the simultaneous algorithm.; Efficiency of the simultaneous algorithm can be greatly increased by avoiding; the transformation of the four-index virtual two-electron integrals; \((vv|vv)\) and computing the terms that involve these integrals in the AO; basis. In order to do that one needs to set the AO_BASIS option to; DISK (currently used by default). For more recommendations on the choice of the algorithm see; Recommendations. Analytic Gradients¶; Analytic gradients are available for the DC-06, ODC-06, ODC-12, and ODC-13 methods.; For ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/dcft-1.html:11112,energy,energy,11112,psi4manual/1.2.1/dcft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/dcft-1.html,15,['energy'],['energy']
Energy Efficiency,"od.revoke_option_changed(""DF_BASIS_SCF""); if not scftypeChanged:; PsiMod.revoke_option_changed(""SCF_TYPE""). [docs] def fitGeneral(self):; """"""Function to perform a general fit of diffuse charges; to wavefunction density. """"""; PsiMod.print_out("" => Diffuse Charge Fitting (Determines da) <=\n\n""); self.wfn = PsiMod.wavefunction(); self.Da = self.wfn.Da(); self.basis = self.wfn.basisset(); parser = PsiMod.Gaussian94BasisSetParser(); self.ribasis = PsiMod.BasisSet.construct(parser, self.molecule, ""DF_BASIS_SCF""). fitter = PsiMod.DFChargeFitter(); fitter.setPrimary(self.basis); fitter.setAuxiliary(self.ribasis); fitter.setD(self.Da); self.da = fitter.fit(); self.da.scale(2.0). [docs] def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]class QMMM(object):. def __init__(self):; self.charges = []; self.diffuses = []; self.extern = PsiMod.ExternalPotential(). [docs] def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs] def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs] def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / physconst.psi_bohr2angstroms, y / physconst.psi_bohr2angstroms, z / physconst.psi_bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/qmmm.html:2705,charge,charges,2705,psi4manual/4.0b4/_modules/qmmm.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qmmm.html,2,['charge'],['charges']
Energy Efficiency,"odError(['select_olccd', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_olccd_gradient(name, **kwargs):; """"""Function selecting the algorithm for an OLCCD gradient call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('CC_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError(['select_olccd_gradient', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_fnoccsd(name, **kwargs):; """"""Function selecting the algorithm for a FNO-CCSD energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('CC_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only fnocc. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in ['', 'FNOCC']:; func = run_fnocc; elif mtd_type == 'DF':; if module in ['', 'FNOCC']:; func = run_fnodfcc; elif mtd_type == 'CD':; if module in ['', 'FNOCC']:; func = run_fnodfcc. if func is None:; raise ManagedMethodError(['select_fnoccsd', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_ccsd(name, **kwargs):; """"""Function selecting the algorithm for a CCSD energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('CC_TYPE'); module = psi4.get_global_option('QC_MO",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:18159,energy,energy,18159,psi4manual/1.0.0/_modules/procedures/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html,1,['energy'],['energy']
Energy Efficiency,"od_string (string) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, lowercase and usually unlabeled. Indicates the computational; method to be passed to func. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || 'off' ; Indicate to additionally return the Wavefunction; calculation result as the second element of a tuple. bsse_type (string or list) – 'cp' || ['nocp', 'vmfc'] || None || etc.; Type of BSSE correction to compute: CP, NoCP, or VMFC. The first in this; list is returned by this function. By default, this function is not called. max_nbody (int) – 3 || etc.; Maximum n-body to compute, cannot exceed the number of fragments in the moleucle. ptype (string) – 'energy' || 'gradient' || 'hessian'; Type of the procedure passed in. return_total_data (boolean) – 'on' || 'off' ; If True returns the total data (energy/gradient/etc) of the system,; otherwise returns interaction data. The nbody function computes counterpoise-corrected (CP), non-CP (noCP), and Valiron-Mayer Function Couterpoise (VMFC) interaction energies for complexes composed of arbitrary numbers of monomers.; Examples :; # Counterpoise corrected CCSD(T) energy for the Helium dimer; molecule mol {; He; --; He 1 3; }. energy('CCSD(T)', bsse_type='cp'). # noCP, VMFC, and CP energy for a helium cluster, limited at 3 bodies; molecule mol {; He 0 0 0; --; He 0 0 4; --; He 0 4 0; --; He 4 0 0; }. # Returns the nocp energy as its first in the list; energy('CCSD(T)', bsse_type=['nocp', 'cp', 'vmfc'], max_nbody=3). Previous topic; Property; Next topic; Geometry Optimization, optimize() and gradient(). This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; Psi4 [1.0.0 6a9a71b] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/nbody-1.html:2069,energy,energy,2069,psi4manual/1.0.0/nbody-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/nbody-1.html,10,['energy'],['energy']
Energy Efficiency,"ode is quite new, but relatively complete. During code development,; emphasis was placed on flexibility of functional technology, efficiency for; medium to large systems in difficult electronic environments (e.g., compact; spatial extents, diffuse basis sets, low band-gaps, LRC and/or hybrid GKS; functionals), and time to code completion. We are very interested in optimizing; and extending the code, so expect performance gains and extensions to; gradients/hessians and TDDFT in future releases.; Some rough guidelines for using the KS-DFT code are as follows,. Use DF for the ERI algorithm wherever possible.; PSI4 is a “tight” code, meaning we’ve set the default numerical cutoffs; for integrals, grids, and convergence criteria in such a way that you will often; get many more digits of precision than needed. You may be able to realize; additional speed gains by loosening some of these thresholds. See; SCF Convergence for default convergence criteria.; Read the literature to determine which functional technology to use. The world; contains far too many papers using B3LYP on noncovalent interactions without a -D. The “best-practice” input file for KS-DFT is:; memory 1 GB # As much as you've got, the DF algorithm can use. molecule {; H; H 1 0.7; }. set {; basis cc-pvdz; scf_type df; guess sad; }. energy('b3lyp'). Table Of Contents. DFT: Density Functional Theory; Theory; Minimal Input; Spin/Symmetry Treatment; Functional Selection; Grid Selection; ERI Algorithms; IP Fitting; Fractional Particle Curves; Dispersion Corrections; Recommendations. Previous topic; HF: Hartree–Fock Theory; Next topic; DF-MP2: Density-Fitted Second-Order Møller-Plesset Perturbation Theory; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Theoretical Methods: SCF to FCI ». © Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/dft-1.html:23215,energy,energy,23215,psi4manual/4.0b3/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/dft-1.html,2,['energy'],['energy']
Energy Efficiency,"ode will be executed to perform the solution of the DCFT response; equations, compute the analytic gradients of the DCFT energy and perform the; geometry optimization. Recommendations¶; Here is the list of the recommendations for the DCFT module:. For the computations of small systems (less than 150 basis; functions and high symmetry) the use of the default parameters is recommended,; including the choice of the two-step algorithm.; For large systems (more than 150 basis functions) the simultaneous algorithm; is preferred and can be significantly faster than two-step, as the result of; smaller number of the expensive steps. In addition,; significant savings can be achieved if one sets AO_BASIS option to; DISK together with simultaneous algorithm. It should be noted, however, that; the analytic gradients of the DC-06 method are currently not implemented for; AOBASIS DISK option.; In the case when insufficient memory is available, set AO_BASIS option; to DISK. This will significantly reduce the memory requirements. However, when; used together with the two-step algorithm, this option can significantly; increase the cost of the energy computation.; In the case when the oscillatory convergence is observed before the DIIS; extrapolation is initialized, it is recommended to increase the threshold for; the RMS of the density cumulant or orbital update residual, below which the; DIIS extrapolation starts. This can be done by setting; DIIS_START_CONVERGENCE option to the value greater than; by one or two orders of magnitude (e.g. or; ).; If the oscillatory convergence is observed for atoms or molecules with high; symmetry, it is recommended to use quadratically-convergent algorithm.; When using quadratically-convergent algorithm for closed-shell molecules, it; is recommended to set QC_COUPLING option to FALSE for efficiency; reasons. Table Of Contents. DCFT: Density Cumulant Functional Theory; Theory; Methods; Iterative Algorithms; Analytic Gradients; Minimal Input; Recommen",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/dcft-1.html:11916,reduce,reduce,11916,psi4manual/4.0b4/dcft-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/dcft-1.html,2,['reduce'],['reduce']
Energy Efficiency,"ode, one can use the command set_options(); like below for general and module-specific options. Note that these values; should be of correct type, strings for strings, floats for floats like; convergences. The function ~psi4.core.clean_options that reinitializes; all options may also be useful to separate calculations in a PsiAPI; session.; psi4.set_options({; 'scf_type': 'pk',; 'e_convergence': 1.e-5,; 'soscf': True,; 'optking__geom_maxiter': 50; }). Basis Sets¶. Basis Sets; Built-In Basis Sets; Mixing Basis Sets; Decontracted Basis Sets; User-Defined Basis Sets; Inputting effective core potentials (ECPs). PSI Variables¶; To harness the power of Python, PSI4 makes the most pertinent results; of each computation available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of; H2 and H atom:; molecule h2 {; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h {; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol * (2*h_energy - h2_energy); print ""De=%f"" % D_e. The energy() function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation.; Generally, there are multiple quantities of interest. Appendix; PSI Variables by Module lists PSI variables variables set by each; module, and PSI Variables by Alpha defines them. These can be; accessed through the get_variable() function. For example, after; performing a density fitted MP2 computation, both the spin component; scaled energy and the unscaled MP2 energy are made available:; e_mp2 = get_variable('MP2 TOTAL ENERGY'); e_scs_mp2 = get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/psithoninput-1.html:7604,energy,energy,7604,psi4manual/1.4.0/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/psithoninput-1.html,8,['energy'],['energy']
Energy Efficiency,"odel chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> molecule mol {\nH 0.0 0.0 0.0\nH 2.0 0.0 0.0\nF 0.0 1.0 0.0\nF 2.0 1.0 0.0\n}; >>> print mol.nfragments() # 1; >>> fragmol = auto_fragments(); >>> print fragmol.nfragments() # 2. qmmm¶; Module with classes to integrate MM charges into; a QM calculation. class Diffuse(molecule, basisname, ribasisname)[source]¶. fitGeneral()[source]¶; Function to perform a general fit of diffuse charges; to wavefunction density. fitScf()[source]¶; Function to run scf and fit a system of diffuse charges to; resulting density. populateExtern(extern)[source]¶. class QMMM[source]¶. addChargeAngstrom(Q, x, y, z)[source]¶; Function to add a point charge of magnitude Q at; position (x, y, z) Angstroms. addChargeBohr(Q, x, y, z)[source]¶; Function to add a point charge of magnitude Q at; position (x, y, z) Bohr. addDiffuse(diffuse)[source]¶; Function to add a diffuse charge field diffuse. populateExtern()[source]¶; Function to define a charge field external to the; molecule through point and diffuse charges. qcdb¶; Module to facilitate quantum chemical computations on chemical; databases. Contains Molecule class and physical constants from psi4 suite.; Module with commands building BasisFamily objects; for Pople and other non-Dunning orbital basis sets. Some; plausible fitting basis sets are supplied as defaults. load_basfam_other()[source]¶. class CharacterTable(*args)[source]¶; The CharacterTable class provides a workable character table for; all of the non-cubic point groups. While I have tried to match the; ordering in Cotton’s book, I don’t guarantee that it is always; followed. It shouldn’t matter anyway. Also note that I don’t lump; symmetry operations of the same class together. For example, in C3v; there are two distinct C3 rotations and 3 distinct reflections, each; with a separate character. Thus symop has 6 elements rather than the 3; you’ll find in most published character tables. bits()[source]¶; Returns bitwise re",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html:9529,charge,charge,9529,psi4manual/1.0.0/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html,4,['charge'],"['charge', 'charges']"
Energy Efficiency,"odified damping scheme for DFT-D3 using the rational damping form of; Becke and Johnson was introduced in [Grimme:2011:1456]. The parameters; fit for individual functionals are now \(s_6\), \(s_8\),; \(a_1\), and \(a_2\). \[E_{disp}^{\text{D3BJ}}=-\sum_{n=6,8} s_n \sum_{i,j>i}^{N_{at}}; \frac{C_n^{ij}}{(R_{ij})^n + (f_{damp})^n}\]. \[f_{damp} = a_1 \sqrt{\frac{C_8^{ij}}{C_6^{ij}}} + a_2\]; All parameters characterizing the dispersion correction are taken from; Grimme’s website; or else from the literature. Running DFTD3 or DFTD4¶; A number of a posteriori dispersion corrections are available in; PSI4. While some are computed within PSI4‘s codebase (-D1, -D2,; -CHG, -DAS2009, -DAS2010), the -D3 or -D4 corrections and their variants are; available only through the DFTD3 or DFTD4 programs. Once installed, the; dftd3/PSI4 and dftd4/PSI4 interfaces are transparent, and all corrections are; interfaced exactly alike.; Dispersion corrections are built into DFT functionals, so appending an a; posteriori correction to a computation is as simple as; energy('b2plyp-d') vs. energy('b2plyp'). For example, the; following input file computes (with much redundant work) for water a; B3LYP, a B3LYP-D2, a B3LYP-D3 (zero-damping), and a B3LYP-D4 (Becke-Johnson damping) energy.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('b3lyp'); energy('b3lyp-d'); energy('b3lyp-d3'); energy('b3lyp-d4'). Consult the table -D Functionals to see for each; functional what corrections are available and what default parameters; define them. The dispersion correction is available after a calculation in; the PSI variable DISPERSION CORRECTION ENERGY.; By default, the output from the dftd3; program is suppressed; to see it in the output file, set print > 2.; No text output is available from the dftd4 program. Variants of dispersion corrections¶. Extension 1; Variant; Computing Program (engine); DFT_DISPERSION_PARAMETERS 11. -D; alias to -D2. -D1; -D1 2; PSI4‘s libdisp; [\(s_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/dftd3-1.html:4911,energy,energy,4911,psi4manual/1.5.0/dftd3-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/dftd3-1.html,3,['energy'],['energy']
Energy Efficiency,"ods are closely related to perturbation theory, and the; MP2, MP3, and MP4(SDQ) correlation energies can be obtained as a free; by-product of a CCSD or QCISD computation. The following is an; example of the results for a computation run with the call; energy('fno-qcisd') to energy():; QCISD iterations converged!. OS MP2 FNO correction: -0.000819116338; SS MP2 FNO correction: -0.000092278158; MP2 FNO correction: -0.000911394496. OS MP2 correlation energy: -0.166478414245; SS MP2 correlation energy: -0.056669079827; MP2 correlation energy: -0.223147494072; * MP2 total energy: -76.258836941658. OS MP2.5 correlation energy: -0.171225850256; SS MP2.5 correlation energy: -0.054028401038; MP2.5 correlation energy: -0.225254251294; * MP2.5 total energy: -76.260943698880. OS MP3 correlation energy: -0.175973286267; SS MP3 correlation energy: -0.051387722248; MP3 correlation energy: -0.227361008515; * MP3 total energy: -76.263050456101. OS MP4(SDQ) correlation energy: -0.180324322304; SS MP4(SDQ) correlation energy: -0.048798468084; MP4(SDQ) correlation energy: -0.230995119324; * MP4(SDQ) total energy: -76.266684566910. OS QCISD correlation energy: -0.181578117924; SS QCISD correlation energy: -0.049853548145; QCISD correlation energy: -0.231431666069; * QCISD total energy: -76.267121113654. The first set of energies printed corresponds to the second-order FNO; correction mentioned previously. Results for many-body perturbation; theory through partial fourth order are then provided.; The notation MP4(SDQ) indicates that we have included all contributions to; the correlation energy through fourth order, with the exception of that; from connected triple excitations.; One need not run a full QCISD or CCSD computation to obtain these; perturbation theory results. The keywords for invoking perturbation; theory computations are given below in; Table FNOCC Methods. Full MP4 correlation; energies are also available. Coupled electron pair approximation¶; Coupled-pair methods can be vie",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/fnocc-1.html:6009,energy,energy,6009,psi4manual/1.4.0/fnocc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/fnocc-1.html,15,['energy'],['energy']
Energy Efficiency,"ods; - simple modifications to existing methods. """"""; import PsiMod; import re; import os; import math; import warnings; from driver import *; from wrappers import *; from molutil import *; from text import *; from procutil import *. # Python procedures like these can be run directly from the input file or integrated; # with the energy(), etc. routines by means of lines like those at the end of this file. [docs]def sherrillgroup_gold_standard(name='mp2', **kwargs):; r""""""Function to call the quantum chemical method known as 'Gold Standard'; in the Sherrill group. Uses :py:func:`~wrappers.complete_basis_set` to evaluateo; the following expression. Two-point extrapolation of the correlation energy; performed according to :py:func:`~wrappers.corl_xtpl_helgaker_2`. .. math:: E_{total}^{\text{Au\_std}} = E_{total,\; \text{SCF}}^{\text{aug-cc-pVQZ}} \; + E_{corl,\; \text{MP2}}^{\text{aug-cc-pV[TQ]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD(T)}}\big\vert_{\text{aug-cc-pVTZ}}. >>> energy('sherrillgroup_gold_standard'). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). if not ('func_cbs' in kwargs):; kwargs['func_cbs'] = energy. if not ('scf_basis' in kwargs):; kwargs['scf_basis'] = 'aug-cc-pVQZ'; if not ('scf_scheme' in kwargs):; kwargs['scf_scheme'] = highest_1. if not ('corl_wfn' in kwargs):; kwargs['corl_wfn'] = 'mp2'; if not ('corl_basis' in kwargs):; kwargs['corl_basis'] = 'aug-cc-pV[TQ]Z'; if not ('corl_scheme' in kwargs):; kwargs['corl_scheme'] = corl_xtpl_helgaker_2. if not ('delta_wfn' in kwargs):; kwargs['delta_wfn'] = 'ccsd(t)'; if not ('delta_wfn_lesser' in kwargs):; kwargs['delta_wfn_lesser'] = 'mp2'; if not ('delta_basis' in kwargs):; kwargs['delta_basis'] = 'aug-cc-pVTZ'; if not ('delta_scheme' in kwargs):; kwargs['delta_scheme'] = highest_1. return cbs(name, **kwargs). [docs]def run_mp2_5(name, **kwargs):; r""""""Function that computes MP2.5 energy from results of a DETCI; MP3 calculation. .. math:: E_{total}^{\text{MP2.5}} = E_{total,\; \text{SCF}} \; +",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/aliases.html:1320,energy,energy,1320,psi4manual/4.0b3/_modules/aliases.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/aliases.html,2,['energy'],['energy']
Energy Efficiency,"odule calls for; a density-fitted MP2 calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). if core.get_global_option('REFERENCE') == ""ROHF"":; ref_wfn.semicanonicalize(). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dfmp2_wfn = core.dfmp2(ref_wfn); dfmp2_wfn.compute_energy(). if name == 'scs-mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')). elif name == 'mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')). # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfep2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted MP2 calculation. """"""; core.tstart(); optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:126097,ENERGY,ENERGY,126097,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,7,['ENERGY'],['ENERGY']
Energy Efficiency,"odule proc. run_oldmp2() in module proc. run_omp2() in module proc. run_omp2_5() in module proc. run_omp2_5_gradient() in module proc. run_omp2_gradient() in module proc. run_omp3() in module proc. run_omp3_gradient() in module proc. run_psimrcc() in module proc. run_psimrcc_scf() in module proc. run_sapt() in module proc. run_sapt_ct() in module proc. run_scf() in module proc. run_scf_gradient() in module proc. run_scf_property() in module proc. run_scs_omp2() in module proc. run_scs_omp3() in module proc. run_sos_omp2() in module proc. run_sos_omp3() in module proc. S. S (DETCI). S22 module, [1]. S22by5 module, [1]. S66 module, [1]. S_ORTHOGONALIZATION (SCF). S_SQUARED (DETCI). S_TOLERANCE (SCF). SAD_CHOL_TOLERANCE (SCF). SAD_D_CONVERGENCE (SCF). SAD_E_CONVERGENCE (SCF). SAD_F_MIX_START (SCF). SAD_MAXITER (SCF). SAD_PRINT (SCF). sanitize() Getkw method. Section method. sanitize_basisname() in module p4util.basislist. sanity_check() Keyword method. Section method. SAPT. SAPT0. charge-transfer. higher-order. output. theory. SAPT (SCF). SAPT_LEVEL (SAPT). SAPT_MEM_CHECK (SAPT). SAPT_MEM_SAFETY (SAPT). SAPT_OS_SCALE (SAPT). SAPT_SS_SCALE (SAPT). SAPTDISPENERGY. SAPTELSTENERGY. SAPTENERGY. SAPTEXCHENERGY. SAPTINDENERGY. SAPTSAPT0ENERGY. SAPTSAPT2+(3)(CCD)ENERGY. SAPTSAPT2+(3)ENERGY. SAPTSAPT2+(CCD)ENERGY. SAPTSAPT2+3(CCD)ENERGY. SAPTSAPT2+3ENERGY. SAPTSAPT2+ENERGY. SAPTSAPT2ENERGY. save() Table method. SAVE_JK (SCF). save_string_xyz() LibmintsMolecule method. Molecule method. save_to_checkpoint() LibmintsMolecule method. save_xyz() LibmintsMolecule method. SCALE (STABILITY). scale() in module qcdb.vecutil. Table method. SCF. theory. scf_helper() in module proc. SCF_MAXITER (DCFT). SCF_MEM_SAFETY_FACTOR (SCF). SCF_TYPE (CPHF). (SCF). scf_xtpl_helgaker_2() in module wrappers. scf_xtpl_helgaker_3() in module wrappers. SCFDIPOLEX. SCFDIPOLEY. SCFDIPOLEZ. SCFQUADRUPOLEXX. SCFQUADRUPOLEXY. SCFQUADRUPOLEXZ. SCFQUADRUPOLEYY. SCFQUADRUPOLEYZ. SCFQUADRUPOLEZZ. SCFTOTALENERGY. SCH",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/genindex.html:42809,charge,charge-transfer,42809,psi4manual/4.0b5/genindex.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/genindex.html,1,['charge'],['charge-transfer']
Energy Efficiency,"odule psi4.driver. E. E() psi4.core.SymmetryOperation method, [1], [2]. E3_SCALE (DFOCC). (OCC). E_CONVERGENCE (CCENERGY). (CCEOM). (DCFT). (DETCI). (DFOCC). (FNOCC). (MCSCF). (MRCC). (OCC). (PSIMRCC). (SAPT). (SCF). EA_POLES (OCC). EFP. adding new. library fragments, [1]. molecule specification. EFP class in psi4.core, [1]. EFP_DISP (EFP). EFP_DISP_DAMPING (EFP). EFP_ELST (EFP). EFP_ELST_DAMPING (EFP). EFP_EXCH (EFP). EFP_IND (EFP). EFP_IND_DAMPING (EFP). efp_init() in module psi4.core, [1]. EFP_QM_ELST (EFP). EFP_QM_IND (EFP). efp_set_options() in module psi4.core, [1]. EKT_EA (OCC). EKT_IP (DFOCC). (OCC). electric_field() psi4.core.IntegralFactory method, [1], [2]. psi4.core.MintsHelper method, [1], [2]. ElectricFieldInt class in psi4.core, [1]. electrostatic() psi4.core.IntegralFactory method, [1], [2]. ElectrostaticInt class in psi4.core, [1]. EmpericalDispersion class in psi4.driver. end() psi4.core.Slice method, [1], [2]. EndLoop psi4.core.PsiReturnType attribute, [1], [2]. energy(). setting keywords. energy() in module psi4. in module psi4.driver. psi4.core.CIWavefunction method, [1]. psi4.core.CUHF method, [1]. psi4.core.DFEP2Wavefunction method, [1]. psi4.core.HF method, [1]. psi4.core.RHF method, [1]. psi4.core.ROHF method, [1]. psi4.core.UHF method, [1]. psi4.core.Wavefunction method, [1], [2]. ENERGY_LEVEL_SHIFT (DCFT). ENSURE_BT_CONVERGENCE (OPTKING). environment variable. ; CONDA_PREFIX, [1]. CRAYPE_LINK_TYPE. CRAY_ADD_RPATH. HOST, [1]. MATH_ROOT. MKL_NUM_THREADS, [1]. MKL_ROOT. MONTAGE. OMP_NESTED, [1], [2]. OMP_NUM_THREADS, [1], [2], [3], [4], [5], [6], [7], [8], [9]. PATH, [1], [2], [3], [4], [5], [6], [7], [8], [9], [10], [11], [12], [13], [14], [15], [16], [17], [18], [19], [20], [21], [22], [23], [24], [25], [26], [27], [28], [29], [30], [31], [32], [33], [34], [35], [36], [37], [38]. PSIDATADIR, [1], [2], [3], [4], [5]. PSIPATH, [1], [2], [3], [4], [5], [6], [7], [8], [9], [10], [11], [12], [13], [14], [15], [16], [17], [18], [19], [20], [21], ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/genindex-1.html:44672,energy,energy,44672,psi4manual/1.2.1/genindex-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/genindex-1.html,2,['energy'],['energy']
Energy Efficiency,odule__mp2.txt; module__mrcc.txt; module__oeprop.txt; module__omp2.txt; module__omp3.txt; module__optking.txt; module__psimrcc.txt; module__sapt.txt; module__scf.txt; module__thermo.txt. adc.txt; appendices.txt; autodoc_available_databases.txt; autodoc_basissets_byfamily.txt; autodoc_dft_all.txt; autodoc_dft_dhybrid.txt; autodoc_dft_disp.txt; autodoc_dft_energy.txt; autodoc_dft_gga.txt; autodoc_dft_hybrid.txt; autodoc_dft_lrc.txt; autodoc_dft_meta.txt; autodoc_dft_opt.txt; autodoc_dft_scsdhybrid.txt; autodoc_driver.txt; autodoc_glossary_options_c.txt; autodoc_options_c_bymodule.txt; autodoc_psi4bases.txt; autodoc_psifiles.txt; autodoc_psivariables_bymodule.txt; autodoc_testsuite.txt; basissets.txt; basissets_byelement.txt; basissets_byfamily.txt; bestpractices_py.txt; bibliography.txt; cbs.txt; cbs_eqn.txt; cc.txt; cepa.txt; contents.txt; contributing.txt; cp.txt; customizing.txt; db.txt; detci.txt; dfmp2.txt; dft.txt; dft_byfunctional.txt; dftd3.txt; diatomic.txt; documentation.txt; energy.txt; external.txt; freq.txt; glossary_psivariables.txt; index.txt; installfile.txt; intercalls.txt; interfacing.txt; introduction.txt; methods.txt; mrcc.txt; notes_c.txt; notes_py.txt; oeprop.txt; ompn.txt; opt.txt; optionshandling.txt; optking.txt; pep0001.txt; plugins.txt; programming.txt; prop.txt; psimod.txt; psimrcc.txt; psipep.txt; psithonfunc.txt; psithoninput.txt; quickaddalias.txt; quickaddbasis.txt; quickadddatabase.txt; sapt.txt; scf.txt; testsuite.txt; tutorial.txt. /_static; ; basic.css; doctools.js; jquery.cookie.js; jquery.js; psi4.css; pygments.css; searchtools.js; toggle_codeprompt.js; toggle_sections.js; toggle_sidebar.js; underscore.js. ADC: Ab Initio Polarization Propagator — PSI4 [beta3] documentation; ADC: Ab Initio Polarization Propagator — PSI4 [beta3] documentation; Appendices — PSI4 [beta3] documentation; Appendices — PSI4 [beta3] documentation. /autodir_options_c; ; CACHELEVEL — PSI4 [beta3] documentation; MEMORY — PSI4 [beta3] documentation; NEWTON_CON,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/index-wcopy.html:1216567,energy,energy,1216567,index-wcopy.html,https://psicode.org,https://psicode.org/index-wcopy.html,1,['energy'],['energy']
Energy Efficiency,odule__mp2.txt; module__mrcc.txt; module__oeprop.txt; module__omp2.txt; module__omp3.txt; module__optking.txt; module__psimrcc.txt; module__sapt.txt; module__scf.txt; module__thermo.txt. adc.txt; appendices.txt; autodoc_available_databases.txt; autodoc_basissets_byfamily.txt; autodoc_dft_all.txt; autodoc_dft_dhybrid.txt; autodoc_dft_disp.txt; autodoc_dft_energy.txt; autodoc_dft_gga.txt; autodoc_dft_hybrid.txt; autodoc_dft_lrc.txt; autodoc_dft_meta.txt; autodoc_dft_opt.txt; autodoc_dft_scsdhybrid.txt; autodoc_driver.txt; autodoc_glossary_options_c.txt; autodoc_options_c_bymodule.txt; autodoc_psi4bases.txt; autodoc_psifiles.txt; autodoc_psivariables_bymodule.txt; autodoc_testsuite.txt; basissets.txt; basissets_byelement.txt; basissets_byfamily.txt; bestpractices_py.txt; bibliography.txt; cbs.txt; cbs_eqn.txt; cc.txt; cepa.txt; contents.txt; contributing.txt; cp.txt; customizing.txt; db.txt; detci.txt; dfmp2.txt; dft.txt; dft_byfunctional.txt; dftd3.txt; diatomic.txt; documentation.txt; energy.txt; external.txt; freq.txt; glossary_psivariables.txt; index.txt; installfile.txt; intercalls.txt; interfacing.txt; introduction.txt; methods.txt; mrcc.txt; notes_c.txt; notes_py.txt; oeprop.txt; ompn.txt; opt.txt; optionshandling.txt; optking.txt; pep0001.txt; plugins.txt; programming.txt; prop.txt; psimod.txt; psimrcc.txt; psipep.txt; psithonfunc.txt; psithoninput.txt; quickaddalias.txt; quickaddbasis.txt; quickadddatabase.txt; sapt.txt; scf.txt; testsuite.txt; tutorial.txt. _static; ; basic.css; doctools.js; jquery.cookie.js; jquery.js; psi4.css; pygments.css; searchtools.js; toggle_codeprompt.js; toggle_sections.js; toggle_sidebar.js; underscore.js. <no title> — PSI4 [beta3] documentation; ADC: Ab Initio Polarization Propagator — PSI4 [beta3] documentation; ADC: Ab Initio Polarization Propagator — PSI4 [beta3] documentation; Appendices — PSI4 [beta3] documentation; Appendices — PSI4 [beta3] documentation. autodir_options_c; ; CACHELEVEL — PSI4 [beta3] documentation; MEMORY —,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/index-wcopy.html:1111458,energy,energy,1111458,index-wcopy.html,https://psicode.org,https://psicode.org/index-wcopy.html,1,['energy'],['energy']
Energy Efficiency,"odules) options to the output file. print_options(() -> None); Prints the currently set options (to the output file) for the current module. print_out((arg0: str) -> None); Prints a string (using sprintf-like notation) to the output file. print_variables(() -> None); Prints all PSI variables that have been set internally. psi_top_srcdir(() -> str); Returns the location of the source code. psimrcc((arg0: psi::Wavefunction) -> float); Runs the multireference coupled cluster code. reopen_outfile(() -> None); Reopens the output file. revoke_global_option_changed((arg0: str) -> None); Given a string of a keyword name arg1, sets the has_changed attribute in the global options scope to false. revoke_local_option_changed((arg0: str, ...); Given a string of a keyword name arg2 and a particular module arg1, sets the has_changed attribute in the module options scope to false. run_gdma((arg0: psi::Wavefunction, ...); Runs the GDMA code. sapt((arg0: psi::Wavefunction, ...); Runs the symmetry adapted perturbation theory code. scatter((arg0: psi::Molecule, arg1: float, ...); New Scatter function. scfgrad((arg0: psi::Wavefunction) -> psi::Matrix); Run scfgrad, which is a specialized DF-SCF gradient program. scfhess((arg0: psi::Wavefunction) -> psi::Matrix); Run scfhess, which is a specialized DF-SCF hessian program. set_active_molecule(...); Activates a previously defined (in the input) molecule, by name. set_array_variable((arg0: str, ...); Sets a PSI variable, by name. set_efp_torque((arg0: psi::Matrix) -> None); Assigns the global EFP gradient to the values stored in the Nefp by 6 Matrix argument. set_environment((arg0: str, arg1: str) -> str); Set enviromental vairable. set_frequencies((arg0: psi::Vector) -> None); Assigns the global frequencies to the values stored in the 3N-6 Vector argument. set_global_option(*args, **kwargs); Overloaded function. set_global_option_python((arg0: str, ...); Sets a global option to a Python object type. set_gradient((arg0: psi::Matrix) -> None",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psi4api-1.html:169932,adapt,adapted,169932,psi4manual/1.1.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psi4api-1.html,2,['adapt'],['adapted']
Energy Efficiency,"ody; RHF interaction energies using nbody and cbs parts of the driver Ne dimer with mp2/v[dt]z + d:ccsd(t)/vdz. cisd-opt-fd; H2O CISD/6-31G** Optimize Geometry by Energies. linK-3; UHF and ROHF Linear Exchange Algorithm test for benzyl cation. pubchem2; Superficial test of PubChem interface. sapt3; SAPT2+3(CCD) aug-cc-pVDZ+midbond computation of the water dimer interaction energy, using the aug-cc-pVDZ-JKFIT DF basis for SCF and aug-cc-pVDZ-RI for SAPT. olccd1; OLCCD cc-pVDZ energy for the H2O molecule. cc42; RHF-CC2-LR/STO-3G optical rotation of (S)-methyloxirane. gauge = length, omega = (589 355 nm). cepa2; cc-pvdz H2O Test ACPF Energy/Properties. cc48; reproduces dipole moments in J.F. Stanton’s “biorthogonal” JCP paper. sapt7; SAPT0 open-shell computation of H2O-HO2 interaction energy First with cc-pVDZ and density fitted integrals with UHF Then with 6-31g and direct integrals, except for dispersion that is computed with cc-pVDZ-ri density fitting with UHF. dfomp2-4; OMP2 cc-pVDZ energy for the NO molecule. dft-omega; Test omega is setable updated wb97x_20,wb97x_03 to account for new BraggSlater radii. matrix2; An example of using BLAS and LAPACK calls directly from the Psi input file, demonstrating. extern2; External potential calculation involving a TIP3P water and a QM water for DFMP2. Finite different test of the gradient is performed to validate forces. casscf-sp; CASSCF/6-31G** energy point. dft-grad-lr3; wB97X-D test for a large UKS molecule update ref gradient due to new BraggSlater radii. nbody-intermediates; HF/cc-pVDZ many body energies of an arbitrary noble gas trimer complex Size vs cost tradeoff is rough here. cc44; Test case for some of the PSI4 out-of-core codes. The code is given only 2.0 MB of memory, which is insufficient to hold either the A1 or B2 blocks of an ovvv quantity in-core, but is sufficient to hold at least two copies of an oovv quantity in-core. oremp-grad1; integral conventional OO-REMP/cc-pVDZ engrad single points for the H2O mol",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html:6796,energy,energy,6796,psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"ody_dict, ""Non-Counterpoise Corrected (NoCP)"", metadata[""nfragments""], metadata['embedding_charges']). nbody_dict['NOCP-CORRECTED TOTAL ENERGY'] = nocp_body_dict[metadata['max_nbody']]; nbody_dict['NOCP-CORRECTED INTERACTION ENERGY'] = nocp_body_dict[metadata['max_nbody']] - nocp_body_dict[1]. for nb in nbodies[1:]:; nbody_dict[f""NOCP-CORRECTED INTERACTION ENERGY THROUGH {nb}-BODY""] = nocp_body_dict[nb] - nocp_body_dict[1]; nbody_dict[f""NOCP-CORRECTED {nb}-BODY CONTRIBUTION TO ENERGY""] = nocp_body_dict[nb] - nocp_body_dict[nb-1]; for nb in nbodies:; nbody_dict[f""NOCP-CORRECTED TOTAL ENERGY THROUGH {nb}-BODY""] = nocp_body_dict[nb]. # Compute vmfc; if 'vmfc' in metadata['bsse_type']:; for nb in nbodies:; if ptype == ""energy"":; for k in range(1, nb + 1):; vmfc_body_dict[nb] += vmfc_by_level[k]. else:; if nb > 1:; vmfc_body_dict[nb] = vmfc_by_level[nb - 1]; vmfc_body_dict[nb] += vmfc_by_level[nb]. if ptype == ""energy"":; if not metadata[""quiet""]:; _print_nbody_energy(vmfc_body_dict, ""Valiron-Mayer Function Counterpoise (VMFC)"", metadata[""nfragments""], metadata['embedding_charges']). vmfc_interaction_energy = vmfc_body_dict[metadata['max_nbody']] - vmfc_body_dict[1]; nbody_dict['VMFC-CORRECTED TOTAL ENERGY'] = vmfc_body_dict[metadata['max_nbody']]; nbody_dict['VMFC-CORRECTED INTERACTION ENERGY'] = vmfc_interaction_energy. for nb in nbodies[1:]:; nbody_dict[f""VMFC-CORRECTED INTERACTION ENERGY THROUGH {nb}-BODY""] = vmfc_body_dict[nb] - vmfc_body_dict[1]; nbody_dict[f""VMFC-CORRECTED {nb}-BODY CONTRIBUTION TO ENERGY""] = vmfc_body_dict[nb] - vmfc_body_dict[nb-1]; for nb in nbodies:; nbody_dict[f""VMFC-CORRECTED TOTAL ENERGY THROUGH {nb}-BODY""] = vmfc_body_dict[nb]. # Collect specific and generalized returns; results = {; f""cp_{ptype}_body_dict"" : {f""{nb}cp"": j for nb, j in cp_body_dict.items()},; f""nocp_{ptype}_body_dict"": {f""{nb}nocp"": j for nb, j in nocp_body_dict.items()},; f""vmfc_{ptype}_body_dict"": {f""{nb}vmfc"": j for nb, j in vmfc_body_dict.items()},; }. if ptype == ""ener",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html:29064,energy,energy,29064,psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html,10,['energy'],['energy']
Energy Efficiency,"of (S)-methyloxirane. gauge = both, omega = (589 355 nm). cc41; RHF-CC2-LR/cc-pVDZ optical rotation of H2O2. gauge = both, omega = (589 355 nm). molden2; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. dfcasscf-sa-sp; Example of state-averaged CASSCF for the C2 molecule. dfomp3-grad2; DF-OMP3 cc-pVDZ gradients for the H2O+ cation. dfmp2-grad2; DF-MP2 cc-pVDZ gradient for the NO molecule. cc38; RHF-CC2-LR/cc-pVDZ static polarizabilities of HOF molecule. frac; Carbon/UHF Fractionally-Occupied SCF Test Case. cc34; RHF-CCSD/cc-pVDZ energy of H2O partitioned into pair energy contributions. sapt2; SAPT0 aug-cc-pVDZ computation of the benzene-methane interaction energy, using the aug-pVDZ-JKFIT DF basis for SCF, the aug-cc-pVDZ-RI DF basis for SAPT0 induction and dispersion, and the aug-pVDZ-JKFIT DF basis for SAPT0 electrostatics and induction. This example uses frozen core as well as asyncronous I/O while forming the DF integrals and CPHF coefficients. rasscf-sp; 6-31G** H2O Test RASSCF Energy Point will default to only singles and doubles in the active space. omp2p5-grad1; OMP2.5 cc-pVDZ gradient for the H2O molecule. cisd-sp; 6-31G** H2O Test CISD Energy Point. opt-multi-frozen-dimer-c2h; Frozen-fragment opt of C2h methane dimer with user-combined reference points. dfmp2-4; conventional and density-fitting mp2 test of mp2 itself and setting scs-mp2. cc54; CCSD dipole with user-specified basis set. pywrap-db1; Database calculation, so no molecule section in input file. Portions of the full databases, restricted by subset keyword, are computed by sapt0 and dfmp2 methods. dfmp2-1; Density fitted MP2 cc-PVDZ/cc-pVDZ-RI computation of formic acid dimer binding energy using automatic counterpoise corr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/testsuite-1.html:23022,energy,energy,23022,psi4manual/1.1.0/testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/testsuite-1.html,4,['energy'],['energy']
Energy Efficiency,"of (S)-methyloxirane. gauge = both, omega = (589 355 nm). cc41; RHF-CC2-LR/cc-pVDZ optical rotation of H2O2. gauge = both, omega = (589 355 nm). molden2; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. dft-custom; DFT custom functional test. dfcasscf-sa-sp; Example of state-averaged CASSCF for the C2 molecule. dfomp3-grad2; DF-OMP3 cc-pVDZ gradients for the H2O+ cation. dft-grad-meta; DF-BP86-D2 cc-pVDZ frozen core gradient of S22 HCN. dfmp2-grad2; DF-MP2 cc-pVDZ gradient for the NO molecule. cc38; RHF-CC2-LR/cc-pVDZ static polarizabilities of HOF molecule. frac; Carbon/UHF Fractionally-Occupied SCF Test Case. dft-grad1; DF-BP86-D2 cc-pVDZ frozen core gradient of S22 HCN. sapt-dft-api; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. cc34; RHF-CCSD/cc-pVDZ energy of H2O partitioned into pair energy contributions. sapt2; SAPT0 aug-cc-pVDZ computation of the benzene-methane interaction energy, using the aug-pVDZ-JKFIT DF basis for SCF, the aug-cc-pVDZ-RI DF basis for SAPT0 induction and dispersion, and the aug-pVDZ-JKFIT DF basis for SAPT0 electrostatics and induction. This example uses frozen core as well as asyncronous I/O while forming the DF integrals and CPHF coefficients. rasscf-sp; 6-31G** H2O Test RASSCF Energy Point will default to only singles and doubles in the active space. omp2p5-grad1; OMP2.5 cc-pVDZ gradient for the H2O molecule. freq-isotope1; Vibrational and thermo analysis of several water isotopologs. Demonstrates Hessian reuse for different temperatures and pressures but not for different isotopologs. cisd-sp; 6-31G** H2O Test CISD Energy Point. opt-multi-frozen-dimer-c2h; Frozen-fragment opt of C2h methane dimer with user-combined reference points. dfmp2-4",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html:25572,energy,energy,25572,psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"of 1-1B2 state of H2O with EOM-CCSD. cc17; Single point energies of multiple excited states with EOM-CCSD. scf-guess-read1; Sample UHF/cc-pVDZ H2O computation on a doublet cation, using RHF/cc-pVDZ orbitals for the closed-shell neutral as a guess. dct9; UHF-ODC-12 and RHF-ODC-12 single-point energy for H2O. This performs a simultaneous update of orbitals and cumulants, using DIIS extrapolation. Four-virtual integrals are handled in the AO basis, where integral transformation is avoided. In the next RHF-ODC-12 computation, AO_BASIS=NONE is used, where four-virtual integrals are transformed into MO basis. explicit-am-basis; Check that basis sets can be input with explicit angular momentum format. mp3-grad1; MP3 cc-pVDZ gradient for the H2O molecule. opt13; B3LYP cc-pVDZ geometry optimzation of phenylacetylene, starting from not quite linear structure updated reference due to new BraggSlater radii. opt-full-hess-every; SCF/sto-3g optimization with a hessian every step. casscf-sp; CASSCF/6-31G** energy point. psimrcc-ccsd_t-2; Mk-MRCCSD(T) single point. \(^1A_1\) CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. dfccsdt2; DF-CCSD(T) cc-pVDZ energy for the NH molecule. dft-reference; MP2 with a PBE0 reference computation. options1; check all variety of options parsing. ghosts; Density fitted MP2 cc-PVDZ/cc-pVDZ-RI computation of formic acid dimer binding energy using explicit specification of ghost atoms. This is equivalent to the dfmp2_1 sample but uses both (equivalent) specifications of ghost atoms in a manual counterpoise correction. opt1; SCF STO-3G geometry optimzation, with Z-matrix input. cc23; ROHF-EOM-CCSD/DZ analytic gradient lowest \(^{2}B_1\) state of H2O+ (A1 excitation). fnocc5; Test FNO-DF-CCSD(T) energy. omp2p5-2; OMP2.5 cc-pVDZ energy for the H2O molecule. dft-grad-lr3; wB97X-D test for a large UKS molecule update ref gradient due to new BraggSlater radii. dfmp2-grad3; DF-MP2 cc-pVDZ gradients for the H2O molecule",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html:32154,energy,energy,32154,psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"of C4NH4 Anion. scf-guess-read2; Test if the the guess read in the same basis converges. cc13d; Tests analytic CC2 gradients. psimrcc-ccsd_t-4; Mk-MRCCSD(T) single point. \(^1A_1\) O$_3` state described using the Ms = 0 component of the singlet. Uses TCSCF orbitals. dft-custom-gga; DFT (LDA/GGA) test of custom implementations in: gga_superfuncs.py. dft-custom-hybrid; DFT (hybrids) test of implementations in: hybrid_superfuncs.py. opt13; B3LYP cc-pVDZ geometry optimzation of phenylacetylene, starting from not quite linear structure updated reference due to new BraggSlater radii. mp2-h; check that methods can act on single atom. mcscf2; TCSCF cc-pVDZ energy of asymmetrically displaced ozone, with Z-matrix input. fnocc3; Test FNO-QCISD(T) computation. cbs-xtpl-freq; Various gradients for a strained helium dimer and water molecule. sapt5; SAPT0 aug-cc-pVTZ computation of the charge transfer energy of the water dimer. pubchem2; Superficial test of PubChem interface. dfomp2-4; OMP2 cc-pVDZ energy for the NO molecule. dfmp2-freq2; DF-MP2 frequency by difference of energies for H2O. soscf-ref; Triple and Singlet Oxygen energy SOSCF, also tests non-symmetric density matrices. cc36; CC2(RHF)/cc-pVDZ energy of H2O. cbs-xtpl-gradient; Various gradients for a strained helium dimer and water molecule. dft-smoke; DFT Functional Smoke Test. dfmp2-2; Density fitted MP2 energy of H2, using density fitted reference and automatic looping over cc-pVDZ and cc-pVTZ basis sets. Results are tabulated using the built in table functions by using the default options and by specifiying the format. fci-coverage; 6-31G H2O Test for coverage. tdscf-5; td-camb3lyp with DiskDF and method/basis specification. scf-guess; Test initial SCF guesses on FH and FH+ in cc-pVTZ basis. opt1; SCF STO-3G geometry optimzation, with Z-matrix input. fsaptd-terms; F-SAPT0/jun-cc-pvdz procedure for methane dimer. cc4a; RHF-CCSD(T) cc-pVQZ frozen-core energy of the BH molecule, with Cartesian input. This version tests ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html:5678,energy,energy,5678,psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"of CI ROOT n DIPOLE. CI ROOT n QUADRUPOLE¶; Redundant quadrupole array [e a0^2] for the requested configuration interaction level of theory and root n, (3, 3). CI ROOT n QUADRUPOLE XX¶. CI ROOT n QUADRUPOLE XY¶. CI ROOT n QUADRUPOLE XZ¶. CI ROOT n QUADRUPOLE YY¶. CI ROOT n QUADRUPOLE YZ¶. CI ROOT n QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; configuration interaction level of theory and root n.; Deprecated in favor of CI ROOT n QUADRUPOLE. CI ROOT n TOTAL ENERGY¶. CI ROOT n CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the requested configuration interaction level of theory and root; n (numbering starts at 0). CI STATE-AVERAGED TOTAL ENERGY¶. CI STATE-AVERAGED CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for state-averaged CI/CASSCF levels of theory. CI TOTAL ENERGY¶. CI CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the requested configuration interaction level of theory and root. CISD DIPOLE¶; Dipole array [e a0] for the configuration interaction singles and doubles level of theory, (3,). CISD DIPOLE X¶. CISD DIPOLE Y¶. CISD DIPOLE Z¶; The three components of the dipole [Debye] for the; configuration interaction singles and doubles level of theory and root.; Deprecated in favor of CISD DIPOLE. CISD QUADRUPOLE¶; Redundant quadrupole array [e a0^2] for the configuration interaction singles and doubles level of theory, (3, 3). CISD QUADRUPOLE XX¶. CISD QUADRUPOLE XY¶. CISD QUADRUPOLE XZ¶. CISD QUADRUPOLE YY¶. CISD QUADRUPOLE YZ¶. CISD QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; configuration interaction singles and doubles level of theory and root.; Deprecated in favor of CISD QUADRUPOLE. CISD TOTAL ENERGY¶. CISD CORRELATION ENERGY¶. CISDT TOTAL ENERGY¶. CISDT CORRELATION ENERGY¶. CISDTQ CORRELATION ENERGY¶. CISDTQ TOTAL ENERGY¶. CIn CORRELATION ENERGY",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html:13245,energy,energy,13245,psi4manual/1.4.0/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html,8,['energy'],['energy']
Energy Efficiency,"of Normal Modes — frequency() and hessian(). Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Psithon Functions: Invoking a Calculation; Harmonic Vibrational Analysis and Visualization of Normal Modes — frequency() and hessian(). Harmonic Vibrational Analysis and Visualization of Normal Modes — frequency() and hessian()¶. Psi4 Native Hessian Methods. For further discussion of vibrational and thermochemical analysis,; see Sec. Vibrational and Thermochemical Analysis.; frequency() is the only command most users will ever; need to access directly to perform frequency calculations. Behind; the scenes, frequency() is a light wrapper over; hessian() that computes the Hessian then adds a; thermochemical analysis. psi4.frequency(name[, molecule, return_wfn, func, mode, dertype, irrep])[source]; Function to compute harmonic vibrational frequencies. Aliases:; frequencies(), freq(). Returns:; float – Total electronic energy in Hartrees. Returns:; (float, Wavefunction) – energy and wavefunction when return_wfn specified. Parameters:. name (str) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. dertype (dertype) – \(\Rightarrow\) 'hessian' \(\Lef",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/freq.html:1044,energy,energy,1044,psi4manual/1.7.x/freq.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/freq.html,1,['energy'],['energy']
Energy Efficiency,"of R & C; npcgp = np.array(cgp); submatCC = ccnremat[np.ix_(cgp, cgp)]; submatRR = rrnremat[np.ix_(rgp, rgp)]; sumCC = 100.0 * np.sum(submatCC, axis=0) # cost mat small if not scaled, this way like Z=Neon; sumRR = 100.0 * np.sum(submatRR, axis=0); cost = np.zeros((len(cgp), len(rgp))); for j in range(cost.shape[1]):; for i in range(cost.shape[0]):; cost[i, j] = (sumCC[i] - sumRR[j]) ** 2; if verbose >= 2:; print(""Cost:\n"", cost); costcopy = np.copy(cost) # other one gets manipulated by hungarian call. # find _a_ best match btwn R & C atoms through Kuhn-Munkres (Hungarian) algorithm; # * linear_sum_assigment call is exactly like `scipy.optimize.linear_sum_assignment(cost)` only with extra return; t00 = time.time(); (row_ind, col_ind), reducedcost = linear_sum_assignment(cost, return_cost=True); ptsCR = list(zip(row_ind, col_ind)); ptsCR = sorted(ptsCR, key=lambda tup: tup[1]); sumCR = costcopy[row_ind, col_ind].sum(); t01 = time.time(); if verbose >= 2:; print(""Reduced cost:\n"", cost); if verbose >= 1:; print(""Hungarian time [s] for space: {:.3}"".format(t01 - t00)). # find _all_ best matches btwn R & C atoms through Uno algorithm, seeded from Hungarian sol'n; edges = np.argwhere(reducedcost < uno_cutoff); gooduns = uno(edges, ptsCR); t02 = time.time(); if verbose >= 1:; print(""Uno time [s] for space: {:.3}"".format(t02 - t01)). for gu in gooduns:; gu2 = gu[:]; gu2.sort(key=lambda x: x[1]) # resorts match into (r, c) = (info, range); subans = [p[0] for p in gu2] # compacted to subans/lap format. ans = tuple(npcgp[np.array(subans)]); if verbose >= 3:; print(""Best Candidate ({:6.3}):"".format(sumCR), rgp, ""<--"", ans, "" from"", cgp, subans); yield ans. if algorithm == ""permutative"":; ccdistmat = distance_matrix(cgeom, cgeom); rrdistmat = distance_matrix(rgeom, rgeom); algofn = filter_permutative. if algorithm == ""hungarian_uno"":; ccdistmat = distance_matrix(cgeom, cgeom); rrdistmat = distance_matrix(rgeom, rgeom); with np.errstate(divide=""ignore""):; ccnremat = np.reciprocal",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/molutil/align.html:12865,Reduce,Reduced,12865,psi4manual/1.4.0/_modules/qcelemental/molutil/align.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/molutil/align.html,3,['Reduce'],['Reduced']
Energy Efficiency,"of a single electron; pair between monomers.; The \(S^{2}\) approximation is usually pretty good, but may; break down for short intermolecular distance, particularly in high-order; terms. To compensate these deviations, Parker et al. [Parker:2014:094106]; recommend to scale all \(S^{2}\) approximated exchange terms by the ratio:. \[p_{EX}(\alpha) = \left( \frac{E_{exch}^{(10)}}{E_{exch}^{(10)}(S^{2})} \right)^{\alpha}\]; where the recommended exponent is \(\alpha = 1\). To obtain SAPT energies with this scaling,; simply set the keyword exch_scale_alpha true. Alternatively, another value for \(\alpha\); can be specified by setting EXCH_SCALE_ALPHA to a value. For example,; 1set exch_scale_alpha 1.0. will set \(\alpha = 1.0\) and scale exchange energies with \(p_{EX}(1.0)\).; Instead of this straightforward scaling, SAPT0 energies benefit from a slightly modified; recipe that involves an empirically adjusted exponent \(\alpha = 3.0\).; To distinguish it from its unscaled counterpart, this energy is denoted sSAPT0 (see [Parker:2014:094106]). (8)¶\[E_{sSAPT0} = E_{elst}^{(10)} + E_{exch}^{(10)} + E_{ind,resp}^{(20)} +; p_{EX}(3.0) E_{exch-ind,resp}^{(20)} + E_{disp}^{(20)} + p_{EX}(3.0) E_{exch-disp}^{(20)}; + \delta_{HF}^{(2)}\]; where \(\delta_{HF}^{(2)}\) is computed without any scaling. Please note that; sSAPT0 is thus not the same as requesting exch_scale_alpha 3.0, and that the; scaling is automatically performed by requesting energy('ssapt0'). A First Example¶; The following is the simplest possible input that will perform all; available SAPT computations (normally, you would pick one of these methods).; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23molecule water_dimer {; 0 1; O -1.551007 -0.114520 0.000000; H -1.934259 0.762503 0.000000; H -0.599677 0.040712 0.000000; --; 0 1; O 1.350625 0.111469 0.000000; H 1.680398 -0.373741 -0.758561; H 1.680398 -0.373741 0.758561. units angstrom; no_reorient; symmetry c1; }. set basis aug-",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/sapt-1.html:7801,energy,energy,7801,psi4manual/1.1.0/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/sapt-1.html,6,['energy'],['energy']
Energy Efficiency,"of all Matrix QC variables. arrays()¶. Deprecated since version 1.4: Use psi4.core.Wavefunction.variables() instead. atomic_point_charges(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the set atomic point charges. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.Wavefunction, basis: psi4.core.BasisSet) → psi4.core.Wavefunction¶; Returns a new wavefunction with internal data converted to \(C_1\) symmetry, using pre-c1-constructed basis. compute(self: psi4.core.DFEP2Wavefunction, arg0: List[List[int]]) → List[List[Tuple[float, float]]]¶; Computes the density-fitted EP2 energy for the input orbitals. compute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Deep copies the internal data. del_array_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) Matrix QC variable. del_potential_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) ExternalPotential QC variable. (This function is provisional and might be removed in the future.). del_scalar_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) double QC variable. del_variable(key)¶; Removes scal",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.dfep2wavefunction.html:12642,energy,energy,12642,psi4manual/1.4.0/api/psi4.core.dfep2wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.dfep2wavefunction.html,3,['energy'],['energy']
Energy Efficiency,"of atom-centered point charges. keys: 1-based index of fragment, values: list of charges for each fragment.; Add atom-centered point charges for fragments whose basis sets are not included in the computation. """""". [docs]; class BsseEnum(str, Enum):; """"""Available basis-set superposition error (BSSE) treatments."""""". nocp = ""nocp"" # plain supramolecular interaction energy; cp = ""cp"" # counterpoise correction; vmfc = ""vmfc"" # Valiron-Mayer function counterpoise. def _sum_cluster_ptype_data(; ptype: DriverEnum,; ptype_dict: Dict,; compute_list: Set[FragBasIndex],; fragment_slice_dict: Dict[int, Sequence],; fragment_size_dict: Dict[int, int],; mc_level_lbl: int,; vmfc: bool = False,; nb: int = 0,; ) -> Union[float, np.ndarray]:; """"""; Sum arrays from n-body computations to obtain the BSSE corrected or uncorrected scalar or array. Parameters; ----------; ptype; Hint to shape of array data to sum.; ptype_dict; Dictionary containing computed energy, gradient, or Hessian obtained from each subsystem computation; compute_list; A list of (frag, bas) tuples notating all the required computations.; fragment_slice_dict; Dictionary containing slices that index the gradient or Hessian matrix for each of the 1-indexed fragments.; For He--HOOH--Me cluster, `{1: slice(0, 1, None), 2: slice(1, 5, None), 3: slice(5, 10, None)}`.; fragment_size_dict; Dictionary containing the number of atoms of each 1-indexed fragment.; For He--HOOH--Me cluster, `{1: 1, 2: 4, 3: 5}`.; vmfc; Is it a VMFC calculation?; nb; n-body level; required for VMFC calculations.; mc_level_lbl; User label for what modelchem level results should be pulled out of *ptype_dict*.; This is the 1-indexed counterpart to 0-indexed mc_level_idx. Returns; -------; ret; Scalar or array containing the summed energy, gradient, or Hessian result.; Formerly, passed in and modified in place and only called for g/h. """"""; sign = 1; nat = sum(fragment_size_dict.values()). def labeler(frag: Tuple, bas:Tuple) -> str:; return str(mc_level_lbl",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/driver_nbody.html:11525,energy,energy,11525,psi4manual/1.9.x/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/driver_nbody.html,4,['energy'],['energy']
Energy Efficiency,"of charge tuples to a current ExternalPotential. clear(self); Reset the field to zero (eliminates all entries). computeExternExternInteraction(self, arg0); Compute the interaction between this potential and other external potential. computeNuclearEnergy(self, arg0); Compute the contribution to the nuclear repulsion energy for the given molecule. computePotentialMatrix(self, basis); Compute the external potential matrix in the given basis set. getCharges(self); Get the vector of charge tuples. print_out(self); Print python print helper to the outfile. setName(self, arg0); Sets the name. Methods Documentation. addBasis(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet, coefs: psi4.core.Vector) → None¶; Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self: psi4.core.ExternalPotential, Z: float, x: float, y: float, z: float) → None¶; Add a charge Z at (x,y,z). appendCharges(self: psi4.core.ExternalPotential, arg0: List[Tuple[float, float, float, float]]) → None¶; Append a vector of charge tuples to a current ExternalPotential. clear(self: psi4.core.ExternalPotential) → None¶; Reset the field to zero (eliminates all entries). computeExternExternInteraction(self: psi4.core.ExternalPotential, arg0: psi4.core.ExternalPotential) → float¶; Compute the interaction between this potential and other external potential. computeNuclearEnergy(self: psi4.core.ExternalPotential, arg0: psi4.core.Molecule) → float¶; Compute the contribution to the nuclear repulsion energy for the given molecule. computePotentialMatrix(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet) → psi4.core.Matrix¶; Compute the external potential matrix in the given basis set. getCharges(self: psi4.core.ExternalPotential) → List[Tuple[float, float, float, float]]¶; Get the vector of charge tuples. print_out(self: psi4.core.ExternalPotential) → None¶; Print python print helper to the outfile. setName(self: psi4.core.ExternalPotential, arg0: str) → None¶; Sets the name. tabl",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/api/psi4.core.ExternalPotential.html:1524,charge,charge,1524,psi4manual/1.8.x/api/psi4.core.ExternalPotential.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.ExternalPotential.html,2,['charge'],['charge']
Energy Efficiency,"of charge tuples to a current ExternalPotential. clear(self); Reset the field to zero (eliminates all entries). computeExternExternInteraction(self, arg0); Compute the interaction between this potential and other external potential. computeNuclearEnergy(self, arg0); Compute the contribution to the nuclear repulsion energy for the given molecule. computePotentialMatrix(self, basis); Compute the external potential matrix in the given basis set. getCharges(self); Get the vector of charge tuples. print_out(self); Print python print helper to the outfile. setName(self, arg0); Sets the name. Methods Documentation. addBasis(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet, coefs: psi4.core.Vector) → None¶; Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self: psi4.core.ExternalPotential, Z: float, x: float, y: float, z: float) → None¶; Add a charge Z at (x,y,z). appendCharges(self: psi4.core.ExternalPotential, arg0: List[Tuple[float, float, float, float]]) → None¶; Append a vector of charge tuples to a current ExternalPotential. clear(self: psi4.core.ExternalPotential) → None¶; Reset the field to zero (eliminates all entries). computeExternExternInteraction(self: psi4.core.ExternalPotential, arg0: psi4.core.ExternalPotential) → float¶; Compute the interaction between this potential and other external potential. computeNuclearEnergy(self: psi4.core.ExternalPotential, arg0: psi4.core.Molecule) → float¶; Compute the contribution to the nuclear repulsion energy for the given molecule. computePotentialMatrix(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet) → psi4.core.Matrix¶; Compute the external potential matrix in the given basis set. getCharges(self: psi4.core.ExternalPotential) → List[Tuple[float, float, float, float]]¶; Get the vector of charge tuples. print_out(self: psi4.core.ExternalPotential) → None¶; Print python print helper to the outfile. setName(self: psi4.core.ExternalPotential, arg0: str) → None¶; Sets the name. «; h",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.ExternalPotential.html:1540,charge,charge,1540,psi4manual/1.6.x/api/psi4.core.ExternalPotential.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.ExternalPotential.html,4,['charge'],['charge']
Energy Efficiency,"of displacements; findif_meta_dict = driver_findif.hessian_from_energy_geometries(molecule, irrep). # Record undisplaced symmetry for projection of diplaced point groups; core.set_parent_symmetry(molecule.schoenflies_symbol()). ndisp = len(findif_meta_dict[""displacements""]) + 1. print(' %d displacements needed.' % ndisp). wfn = _process_displacement(energy, lowername, molecule, findif_meta_dict[""reference""], 1, ndisp,; **kwargs); var_dict = core.variables(). for n, displacement in enumerate(findif_meta_dict[""displacements""].values(), start=2):; _process_displacement(; energy, lowername, molecule, displacement, n, ndisp, write_orbitals=False, **kwargs). # Reset variables; for key, val in var_dict.items():; core.set_variable(key, val). # Assemble Hessian from energies; H = driver_findif.compute_hessian_from_energies(findif_meta_dict, irrep); wfn.set_hessian(core.Matrix.from_array(H)); wfn.set_gradient(G0). # Explicitly set the current energy..; core.set_variable('CURRENT ENERGY', findif_meta_dict[""reference""][""energy""]); wfn.set_variable('CURRENT ENERGY', findif_meta_dict[""reference""][""energy""]). core.set_parent_symmetry(''); optstash.restore(); optstash_conv.restore(). _hessian_write(wfn). if return_wfn:; return (wfn.hessian(), wfn); else:; return wfn.hessian(). [docs]def frequency(name, **kwargs):; r""""""Function to compute harmonic vibrational frequencies. :aliases: frequencies(), freq(). :returns: *float* |w--w| Total electronic energy in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :type name: string; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html:68723,energy,energy,68723,psi4manual/1.3.2/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html,1,['energy'],['energy']
Energy Efficiency,"of each symmetry of H2O. mints4; A demonstration of mixed Cartesian/ZMatrix geometry specification, using variables, for the benzene-hydronium complex. Atoms can be placed using ZMatrix coordinates, whether they belong to the same fragment or not. Note that the Cartesian specification must come before the ZMatrix entries because the former define absolute positions, while the latter are relative. dfomp3-grad1; DF-OMP3 cc-pVDZ gradients for the H2O molecule. sapt2; SAPT0 aug-cc-pVDZ computation of the benzene-methane interaction energy, using the aug-pVDZ-JKFIT DF basis for SCF, the aug-cc-pVDZ-RI DF basis for SAPT0 induction and dispersion, and the aug-pVDZ-JKFIT DF basis for SAPT0 electrostatics and induction. This example uses frozen core as well as asyncronous I/O while forming the DF integrals and CPHF coefficients. nbo; Generation of NBO file. frac-traverse; Scan fractional occupation of electrons updated values due to new BraggSlater radii. sapt-dft-lrc; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. dfcasscf-sa-sp; Example of state-averaged CASSCF for the C2 molecule. soscf-dft; Triple and Singlet Oxygen energy SOSCF, also tests non-symmetric density matrices. sapt-compare; SAPT0 cc-pVDZ computation of the ethene-ethyne interaction energy, using the cc-pVDZ-JKFIT RI basis for SCF and cc-pVDZ-RI for SAPT. Monomer geometries are specified using Cartesian coordinates. dfomp3-2; DF-OMP3 cc-pVDZ energy for the H2O+ cation. cc7; Tests CCENERGY’s CCSD gradient in the presence of a dipole field. ghosts; Density fitted MP2 cc-PVDZ/cc-pVDZ-RI computation of formic acid dimer binding energy using explicit specification of ghost atoms. This is equivalent to the dfmp2_1 sample but uses both (equivalent) specifications of ghost atoms in a manual counterpoise correction. dfomp2-2; OMP2 cc-pVDZ energy for the NO molecule. olccd-freq1; OLCCD cc-pVDZ freqs for C2H2. opt5; 6-31G** UHF CH2 3B1 optimization. Uses a Z-Matrix with dummy atoms, just for demo and t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html:22527,energy,energy,22527,psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"of geometry optimizations. SAPSuperposition of Atomic Potentials. This is essentially a; modification of the core Hamiltonian, which includes screening; effects by using a radially screened effective atomic charge. The; screening effects have been calculated at the complete basis set; limit with finite-element calculations, see [Lehtola:2019:25945]; and [Lehtola:2020:012516]. The guess and its implementation have; been described in [Lehtola:2019:1593]. The guess is evaluated on a; DFT quadrature grid, so the guess energy depends slightly on the; used DFT quadrature. The current implementation is based on; exchange-only local density calculations that are but nanohartree; away from the complete basis set limit [Lehtola:2020:012516]. SAPGAUSuperposition of Atomic Potentials, but using error function based; fits to the atomic radial potentials as discussed in; [Lehtola:2020:144105]. The main difference to the SAP guess; discussed above [Lehtola:2019:25945] is that the SAPGAU scheme is; analytic, and can be efficiently formed in terms of three-center; two-electron integrals [Lehtola:2020:144105]. The potential in; the SAPGAU scheme is passed with the SAPGAU_BASIS; keyword. The default potential is given by the large fit to the; HelFEM potential, sap_helfem_large, described in; [Lehtola:2020:144105]. Note that this guess is known in the DIRAC; program as .SCRPOT and in the ERKALE program as SAPFIT. These are all set by the GUESS keyword. Also, an automatic Python; procedure has been developed for converging the SCF in a small basis, and then; casting up to the true basis. This can be done by adding; BASIS_GUESS = SMALL_BASIS to the options list. We recommend the; 3-21G or pcseg-0 basis for the small basis due to its efficient mix of flexibility and; compactness. An example of performing an RHF solution of water by SAD guessing; in a 3-21G basis and then casting up to cc-pVTZ is shown below:; molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; basis cc-pvtz; basis_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/scf.html:19366,efficient,efficiently,19366,psi4manual/1.8.x/scf.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/scf.html,3,['efficient'],['efficiently']
Energy Efficiency,"of ghost atoms in a manual counterpoise correction. cc8; UHF-CCSD(T) cc-pVDZ frozen-core energy for the state of the CN radical, with Z-matrix input. cepa2; cc-pvdz H2O Test ACPF Energy/Properties. rasci-ne; Ne atom RASCI/cc-pVQZ Example of split-virtual CISD[TQ] from Sherrill and Schaefer, J. Phys. Chem. XXX This uses a “primary” virtual space 3s3p (RAS 2), a “secondary” virtual space 3d4s4p4d4f (RAS 3), and a “tertiary” virtual space consisting of the remaining virtuals. First, an initial CISD computation is run to get the natural orbitals; this allows a meaningful partitioning of the virtual orbitals into groups of different importance. Next, the RASCI is run. The split-virtual CISD[TQ] takes all singles and doubles, and all triples and quadruples with no more than 2 electrons in the secondary virtual subspace (RAS 3). If any electrons are present in the tertiary virtual subspace (RAS 4), then that excitation is only allowed if it is a single or double. cc5a; RHF CCSD(T) STO-3G frozen-core energy of C4NH4 Anion. mcscf3; RHF 6-31G** energy of water, using the MCSCF module and Z-matrix input. frac; Carbon/UHF Fractionally-Occupied SCF Test Case. pywrap-basis; SAPT calculation on bimolecular complex where monomers are unspecified so driver auto-fragments it. Basis set and auxiliary basis sets are assigned by atom type. psimrcc-sp1; Mk-MRCCSD single point. O2 state described using the Ms = 0 component of the triplet. Uses ROHF triplet orbitals. fd-freq-gradient; STO-3G frequencies for H2O by finite-differences of gradients. dfmp2-1; Density fitted MP2 cc-PVDZ/cc-pVDZ-RI computation of formic acid dimer binding energy using automatic counterpoise correction. Monomers are specified using Cartesian coordinates. cc13; UHF-CCSD/cc-pVDZ CH2 geometry optimization via analytic gradients. cc34; RHF-CCSD/cc-pVDZ energy of H2O partitioned into pair energy contributions. cepa3; cc-pvdz H2O Test coupled-pair CISD against DETCI CISD. cisd-opt-fd; H2O CISD/6-31G** Optimize Geometry",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_testsuite-1.html:4619,energy,energy,4619,psi4manual/4.0b3/autodoc_testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_testsuite-1.html,4,['energy'],['energy']
Energy Efficiency,"of ghost atoms in a manual counterpoise correction. cc8; UHF-CCSD(T) cc-pVDZ frozen-core energy for the state of the CN radical, with Z-matrix input. cepa2; cc-pvdz H2O Test ACPF Energy/Properties. rasci-ne; Ne atom RASCI/cc-pVQZ Example of split-virtual CISD[TQ] from Sherrill and Schaefer, J. Phys. Chem. XXX This uses a “primary” virtual space 3s3p (RAS 2), a “secondary” virtual space 3d4s4p4d4f (RAS 3), and a “tertiary” virtual space consisting of the remaining virtuals. First, an initial CISD computation is run to get the natural orbitals; this allows a meaningful partitioning of the virtual orbitals into groups of different importance. Next, the RASCI is run. The split-virtual CISD[TQ] takes all singles and doubles, and all triples and quadruples with no more than 2 electrons in the secondary virtual subspace (RAS 3). If any electrons are present in the tertiary virtual subspace (RAS 4), then that excitation is only allowed if it is a single or double. cc5a; RHF CCSD(T) STO-3G frozen-core energy of C4NH4 Anion. ocepa2; OCEPA cc-pVDZ energy with B3LYP initial guess for the NO radical. mcscf3; RHF 6-31G** energy of water, using the MCSCF module and Z-matrix input. frac; Carbon/UHF Fractionally-Occupied SCF Test Case. pywrap-basis; SAPT calculation on bimolecular complex where monomers are unspecified so driver auto-fragments it. Basis set and auxiliary basis sets are assigned by atom type. psimrcc-sp1; Mk-MRCCSD single point. O2 state described using the Ms = 0 component of the triplet. Uses ROHF triplet orbitals. fd-freq-gradient; STO-3G frequencies for H2O by finite-differences of gradients. dfmp2-1; Density fitted MP2 cc-PVDZ/cc-pVDZ-RI computation of formic acid dimer binding energy using automatic counterpoise correction. Monomers are specified using Cartesian coordinates. cc13; UHF-CCSD/cc-pVDZ CH2 geometry optimization via analytic gradients. cc34; RHF-CCSD/cc-pVDZ energy of H2O partitioned into pair energy contributions. cepa3; cc-pvdz H2O Test coupled-pai",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodoc_testsuite-1.html:5271,energy,energy,5271,psi4manual/4.0b4/autodoc_testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodoc_testsuite-1.html,8,['energy'],['energy']
Energy Efficiency,"of iterations and is the number of roots. Type: string; Possible Values: RSP, OLSEN, MITRUSHENKOV, DAVIDSON, SEM, SEMTEST; Default: SEM. DIAGONAL_CCSD_T (PSIMRCC); PSIMRCC — Do include the diagonal corrections in (T) computations?. Type: boolean; Default: true. DIAGONALIZE_HEFF (PSIMRCC); PSIMRCC — Do diagonalize the effective Hamiltonian?. Type: boolean; Default: false. DIE_IF_NOT_CONVERGED (GLOBALS); GLOBALS (Expert) — PSI4 dies if energy does not converge. Type: boolean; Default: true. DIIS (CCENERGY); CCENERGY — Do use DIIS extrapolation to accelerate convergence?. Type: boolean; Default: true. DIIS (CCLAMBDA); CCLAMBDA — Do use DIIS extrapolation to accelerate convergence?. Type: boolean; Default: true. DIIS (CCRESPONSE); CCRESPONSE — Do use DIIS extrapolation to accelerate convergence?. Type: boolean; Default: true. DIIS (DETCI); DETCI — Do use DIIS extrapolation to accelerate CC convergence?. Type: boolean; Default: true. DIIS (MCSCF); MCSCF — Do use DIIS extrapolation to accelerate convergence of the SCF energy (MO coefficients only)?. Type: boolean; Default: true. DIIS (SCF); SCF — Do use DIIS extrapolation to accelerate convergence?. Type: boolean; Default: true. DIIS_FREQ (DETCI); DETCI — How often to do a DIIS extrapolation. 1 means do DIIS every iteration, 2 is every other iteration, etc. Type: integer; Default: 1. DIIS_MAX_VECS (CCENERGY); CCENERGY — Maximum number of error vectors stored for DIIS extrapolation. Type: integer; Default: 5. DIIS_MAX_VECS (DCFT); DCFT (Expert) — Maximum number of error vectors stored for DIIS extrapolation. Type: integer; Default: 6. DIIS_MAX_VECS (DETCI); DETCI — Maximum number of error vectors stored for DIIS extrapolation. Type: integer; Default: 5. DIIS_MAX_VECS (FNOCC); FNOCC — Desired number of DIIS vectors. Type: integer; Default: 8. DIIS_MAX_VECS (MCSCF); MCSCF — Maximum number of error vectors stored for DIIS extrapolation. Type: integer; Default: 7. DIIS_MAX_VECS (PSIMRCC); PSIMRCC — Maximum number of error vecto",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodoc_glossary_options_c-1.html:32223,energy,energy,32223,psi4manual/4.0b5/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodoc_glossary_options_c-1.html,2,['energy'],['energy']
Energy Efficiency,"of iterations and is the number of roots. Type: string; Possible Values: RSP, OLSEN, MITRUSHENKOV, DAVIDSON, SEM, SEMTEST; Default: SEM. DIAGONAL_CCSD_T (PSIMRCC); PSIMRCC — Do include the diagonal corrections in (T) computations?. Type: boolean; Default: true. DIAGONALIZE_HEFF (PSIMRCC); PSIMRCC — Do diagonalize the effective Hamiltonian?. Type: boolean; Default: false. DIE_IF_NOT_CONVERGED (GLOBALS); GLOBALS (Expert) — Psi4 dies if energy does not converge. Type: boolean; Default: true. DIIS (CCENERGY); CCENERGY — Do use DIIS extrapolation to accelerate convergence?. Type: boolean; Default: true. DIIS (CCLAMBDA); CCLAMBDA — Do use DIIS extrapolation to accelerate convergence?. Type: boolean; Default: true. DIIS (CCRESPONSE); CCRESPONSE — Do use DIIS extrapolation to accelerate convergence?. Type: boolean; Default: true. DIIS (DETCI); DETCI — Do use DIIS extrapolation to accelerate CC convergence?. Type: boolean; Default: true. DIIS (MCSCF); MCSCF — Do use DIIS extrapolation to accelerate convergence of the SCF energy (MO coefficients only)?. Type: boolean; Default: true. DIIS (SCF); SCF — Do use DIIS extrapolation to accelerate convergence?. Type: boolean; Default: true. DIIS_FREQ (DETCI); DETCI — How often to do a DIIS extrapolation. 1 means do DIIS every iteration, 2 is every other iteration, etc. Type: integer; Default: 1. DIIS_MAX_VECS (DCFT); DCFT (Expert) — Maximum number of error vectors stored for DIIS extrapolation. Type: integer; Default: 6. DIIS_MAX_VECS (DETCI); DETCI — Maximum number of error vectors stored for DIIS extrapolation. Type: integer; Default: 5. DIIS_MAX_VECS (FNOCC); FNOCC — Desired number of DIIS vectors. Type: integer; Default: 8. DIIS_MAX_VECS (MCSCF); MCSCF — Maximum number of error vectors stored for DIIS extrapolation. Type: integer; Default: 7. DIIS_MAX_VECS (PSIMRCC); PSIMRCC — Maximum number of error vectors stored for DIIS extrapolation. Type: integer; Default: 7. DIIS_MAX_VECS (SCF); SCF — Maximum number of error vectors stored ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html:103671,energy,energy,103671,psi4manual/1.0.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html,2,['energy'],['energy']
Energy Efficiency,"of magnitude 0.05 a.u. in the y direction and; 0.1 a.u. in the z direction, we can use the following keywords:; 1; 2; 3set perturb_h true; set perturb_with dipole; set perturb_dipole [ 0, 0.05, 0.1 ]. Note that if any specified fields do not fall along a symmetry axis, the; symmetry of the calculation should be reduced accordingly; if in doubt run the; calculation in C1 symmetry. For examples of SCF and MP2 calculations in an; external field, see scf7 and dfmp2-grad5. Convergence and Algorithm Defaults¶. SCF algorithm and convergence criteria defaults by calculation type [1]¶. Ab Initio Method; Calculation Type; E_CONVERGENCE; D_CONVERGENCE; SCF_TYPE. SCF of HF or DFT; energy; 6; 6; DF. optimization; 8; 8. frequency [7]; 8; 8. SCF of post-HF; energy; 8; 8; PK [3]. optimization; 10; 10. frequency [7]; 10; 10. CC property [2]; 10; 10. Post-SCF convergence criteria defaults by calculation type [4]¶. Ab Initio Method; Calculation Type; E_CONVERGENCE [5]; R_CONVERGENCE [6]. post-HF of post-HF; energy; 6;  . optimization; 8;  . frequency [7]; 8;  . CC property [2]; 8;  . Footnotes. [1]Note that this table applies only the SCF module,; not to the final convergence criteria for post-HF methods or to methods; that use an alternate starting point, like MCSCF. SAPT computations, too,; set tighter values. [2](1, 2) This applies to properties computed through the property() function. [3]Post-HF methods that do not rely upon the usual 4-index AO integrals use a; density-fitted SCF reference. That is, for DF-MP2 and SAPT, the default SCF_TYPE is DF. [4]Note that this table applies to the final convergence criteria for; all the post-SCF modules that define a E_CONVERGENCE keyword. [5]The E_CONVERGENCE keyword is implemented for most post-SCF modules.; See a list beginning at E_CONVERGENCE. [6]The R_CONVERGENCE keyword places a convergence check on an internal; residual error measure and is implemented for several post-SCF; modules (see list beginning at R_CONVERGENCE). It is define",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/scf-1.html:33585,energy,energy,33585,psi4manual/1.1.0/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/scf-1.html,6,['energy'],['energy']
Energy Efficiency,"of molecules, each built from one fragment. Center and; orientation of fragments is fixed so orientation info from self is; not lost. Loses chgmult and ghost/dummy info from self and contains; default chgmult.; Only provided if return_molecules is True.; Returned are of same type as self.; bfs_molecule (qcdb.Molecule or psi4.core.Molecule, optional) – Single molecule with same number of real atoms as self with atoms; reordered into adjacent fragments and fragment markers inserted.; Loses ghost/dummy info from self; keeps total charge but not total mult.; Only provided if return_molecule is True.; Returned is of same type as self. Notes. Relies upon van der Waals radii and so faulty for close (especially; hydrogen-bonded) fragments. See seed_atoms. Any existing fragmentation info/chgmult encoded in self is lost.; Original code from Michael S. Marshall, linear-scaling algorithm from; Trent M. Parker, revamped by Lori A. Burns. Z(self: psi4.core.Molecule, arg0: int) → float; Nuclear charge of atom arg0 (0-indexed without dummies). activate_all_fragments(self: psi4.core.Molecule) → None; Sets all fragments in the molecule to be active. add_atom(self: psi4.core.Molecule, Z: float, x: float, y: float, z: float, symbol: str, mass: float, charge: float, label: str, A: int) → None; Adds to self Molecule an atom with atomic number Z, Cartesian coordinates in Bohr (x, y, z), atomic symbol, mass, and charge, extended atomic label, and mass number A. atom_at_position(*args, **kwargs); Overloaded function. atom_at_position(self: psi4.core.Molecule, coord: float, tol: float) -> int. Tests to see if an atom is at the position coord with a given tolerance tol. atom_at_position(self: psi4.core.Molecule, coord: List[float[3]], tol: float) -> int. Tests to see if an atom is at the position coord with a given tolerance tol. basis_on_atom(self: psi4.core.Molecule, arg0: int) → str; Gets the label of the orbital basis set on a given atom arg0. center_of_mass(self: psi4.core.Molecule) → ps",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.molecule.html:41138,charge,charge,41138,psi4manual/1.3.2/api/psi4.core.molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.molecule.html,1,['charge'],['charge']
Energy Efficiency,"of molecules, each built from one fragment. Center and; orientation of fragments is fixed so orientation info from self is; not lost. Loses chgmult and ghost/dummy info from self and contains; default chgmult.; Only provided if return_molecules is True.; Returned are of same type as self.; bfs_molecule (qcdb.Molecule or psi4.core.Molecule, optional) – Single molecule with same number of real atoms as self with atoms; reordered into adjacent fragments and fragment markers inserted.; Loses ghost/dummy info from self; keeps total charge but not total mult.; Only provided if return_molecule is True.; Returned is of same type as self. Notes. Relies upon van der Waals radii and so faulty for close (especially; hydrogen-bonded) fragments. See seed_atoms. Any existing fragmentation info/chgmult encoded in self is lost.; Original code from Michael S. Marshall, linear-scaling algorithm from; Trent M. Parker, revamped by Lori A. Burns. Z(self: psi4.core.Molecule, arg0: int) → float¶; Nuclear charge of atom arg0 (0-indexed without dummies). activate_all_fragments(self: psi4.core.Molecule) → None¶; Sets all fragments in the molecule to be active. add_atom(self: psi4.core.Molecule, Z: float, x: float, y: float, z: float, symbol: str, mass: float, charge: float, label: str, A: int) → None¶; Adds to self Molecule an atom with atomic number Z, Cartesian coordinates in Bohr (x, y, z), atomic symbol, mass, and charge, extended atomic label, and mass number A. atom_at_position(*args, **kwargs)¶; Overloaded function. atom_at_position(self: psi4.core.Molecule, coord: float, tol: float) -> int. Tests to see if an atom is at the position coord with a given tolerance tol. atom_at_position(self: psi4.core.Molecule, coord: List[float[3]], tol: float) -> int. Tests to see if an atom is at the position coord with a given tolerance tol. basis_on_atom(self: psi4.core.Molecule, arg0: int) → str¶; Gets the label of the orbital basis set on a given atom arg0. center_of_mass(self: psi4.core.Molecule) ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.molecule.html:15385,charge,charge,15385,psi4manual/1.3.2/api/psi4.core.molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.molecule.html,3,['charge'],['charge']
Energy Efficiency,"of running the I-SAPT0/jun-cc-pVDZ computation for 2,4-pentanediol (targeting the intramolecular hydrogen bond between the two hydroxyl groups) The SIAO1 link partitioning algorithm is used. sapt-sf1; Tests the Psi4 SF-SAPT code. dft-jk; DFT JK on-disk test. omp2p5-grad1; OMP2.5 cc-pVDZ gradient for the H2O molecule. scf-auto-cholesky; Cholesky filter a complete basis. cc38; RHF-CC2-LR/cc-pVDZ static polarizabilities of HOF molecule. psimrcc-fd-freq1; Mk-MRCCSD single point. \(^3 \Sigma ^-\) O2 state described using the Ms = 0 component of the triplet. Uses ROHF triplet orbitals. opt5; 6-31G** UHF CH2 3B1 optimization. Uses a Z-Matrix with dummy atoms, just for demo and testing purposes. opt9; Various constrained energy minimizations of HOOH with cc-pvdz RHF. Cartesian-coordinate constrained optimizations of HOOH in internals. cc40; RHF-CC2-LR/cc-pVDZ optical rotation of H2O2. gauge = length, omega= (589 355 nm). fnocc2; Test G2 method for H2O. cbs-xtpl-wrapper; RHF aug-cc-pVQZ energy for the BH molecule, with Cartesian input. Various gradients for a strained helium dimer and water molecule. opt8; Various constrained energy minimizations of HOOH with cc-pvdz RHF. Cartesian-coordinate constrained optimizations of HOOH in Cartesians. remp-energy2; integral conventional unrestricted REMP/cc-pVDZ energies for the H2O+ molecule. results were independently verified against the initial wavels implementation. sapt6; checks that all SAPT physical components (elst, exch, indc, disp) and total IE are being computed correctly for SAPT2+3(CCD)dMP2/aug-cc-pvdz and all lesser methods thereof. fcidump; test FCIDUMP functionality for rhf/uhf. x2c2; Test of SFX2C-1e on Water cc-pVDZ-DK. In this test the Dirac equation is solved in the uncontracted cc-pVDZ-DK basis. The reference numbers are from Lan Cheng’s implementation in Cfour. props3; DF-SCF cc-pVDZ multipole moments of benzene, up to 7th order and electrostatic potentials evaluated at the nuclear coordinates. olccd-freq1; OLCCD",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html:47367,energy,energy,47367,psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"of the CI vector when the \(M_s = 0\) component is used (i.e., MS0 = TRUE), and (2) making sure the guess vector has the desired value of \(\langle S^2\rangle\) (if CALC_S_SQUARED is TRUE and ICORE = 1). Type: double; Default: 0.0. S_CHOLESKY_TOLERANCE (SCF)¶SCF — Tolerance for partial Cholesky decomposition of overlap matrix. Type: conv double; Default: 1e-8. S_ORTHOGONALIZATION (SCF)¶SCF — SO orthogonalization: automatic, symmetric, or canonical?. Type: string; Possible Values: AUTO, SYMMETRIC, CANONICAL, PARTIALCHOLESKY; Default: AUTO. S_TOLERANCE (SCF)¶SCF — Minimum S matrix eigenvalue to allow before linear dependencies are removed. Type: conv double; Default: 1e-7. SAD_CHOL_TOLERANCE (SCF)¶SCF (Expert) — SAD guess density decomposition threshold. Type: conv double; Default: 1e-7. SAD_D_CONVERGENCE (SCF)¶SCF — Convergence criterion for SCF density in the SAD guess, analogous to D_CONVERGENCE. Type: conv double; Default: 1e-5. SAD_E_CONVERGENCE (SCF)¶SCF — Convergence criterion for SCF energy in the SAD guess, analogous to E_CONVERGENCE. Type: conv double; Default: 1e-5. SAD_FRAC_OCC (SCF)¶SCF (Expert) — Do force an even distribution of occupations across the last partially occupied orbital shell?. Type: boolean; Default: true. SAD_MAXITER (SCF)¶SCF (Expert) — Maximum number of atomic SCF iterations within SAD. Type: integer; Default: 50. SAD_PRINT (SCF)¶SCF (Expert) — The amount of SAD information to print to the output. Type: integer; Default: 0. SAD_SCF_TYPE (SCF)¶SCF (Expert) — SCF type used for atomic calculations in SAD guess. Type: string; Possible Values: DIRECT, DF, MEM_DF, DISK_DF, PK, OUT_OF_CORE, CD, GTFOCK; Default: DF. SAD_SPIN_AVERAGE (SCF)¶SCF (Expert) — Do use spin-averaged occupations instead of atomic ground spin state in fractional SAD?. Type: boolean; Default: true. SAPT (SCF)¶SCF (Expert) — Are going to do SAPT? If so, what part?. Type: string; Default: FALSE. SAPT0_E10 (SAPT)¶SAPT (Expert) — For SAPT0 only, compute only first-order electros",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html:208405,energy,energy,208405,psi4manual/1.4.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html,2,['energy'],['energy']
Energy Efficiency,"of the above parameters are available, with only the ```wfn``` and ```basis``` keywords required. Other supported parameters are:. * ```wfn_lo```: the lower method from which the delta correction is to be calculated. By default, it is set to ```wfn``` from the previous field in the ```cbs_metadata``` array.; * ```basis_lo```: basis set to be used for the delta correction. By default, it is the same as the ```basis``` specified above. * Others. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> energy(cbs, scf_wfn='scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> energy(cbs, corl_wfn='mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> energy('cbs', scf_wfn='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme='scf_xtpl_helgaker_3'). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> energy('cbs', corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme='corl_xtpl_helgaker_2'). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme='corl_xtpl_helgaker_2', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme='corl_xtpl_helgaker_2'). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html:33503,energy,energy,33503,psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html,20,['energy'],['energy']
Energy Efficiency,"of the named method; from ground state to root n, and the transition is of irrep h. DFT; functional labeled if canonical. TD-fctl ROOT 0 -> ROOT n RIGHT EIGENVECTOR BETA¶; The right beta spin eigenvectors of the named method; from ground state to root n. DFT; functional labeled if canonical. TD-fctl ROOT 0 (IN h) -> ROOT n (IN i) RIGHT EIGENVECTOR BETA¶; The right beta spin eigenvectors of the named method; from ground state, which is in irrep h, to root n within irrep i. DFT; functional labeled if canonical. TD-fctl ROOT 0 (h) -> ROOT n (i) RIGHT EIGENVECTOR BETA¶; The right beta spin eigenvectors of the named method; from ground state, which is in irrep h, to root n, which is in irrep i. DFT; functional labeled if canonical. TD-fctl ROOT 0 -> ROOT n RIGHT EIGENVECTOR BETA - h TRANSITION¶; The right alpha and beta spin eigenvectors of the named method; from ground state to root n, and the transition is of irrep h. DFT; functional labeled if canonical. THERMAL ENERGY¶; Total thermal energy E [E_h] at given temperature. THERMAL ENERGY CORRECTION¶; Sum of electronic, translational, rotational, and vibrational corrections [E_h] to the thermal energy at given temperature. TWO-ELECTRON ENERGY¶; The two-electron energy contribution [E_h] to the total SCF energy.; Quantity \(E_{2e^-}\) in Eq. (4). UNCP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [E_h] considering only two-body interactions,; computed without counterpoise correction.; Related variable CP-CORRECTED 2-BODY INTERACTION ENERGY. \[E_{\text{IE}} = E_{dimer} - \sum_{monomer}^{n}{E_{monomer}^{\text{unCP}}}\]. WIBERG LOWDIN INDICES¶; Property of Wiberg bond indices using orthogonal Löwdin orbitals, (nat, nat). ZAPTn TOTAL ENERGY¶. ZAPTn CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the labeled Z-averaged perturbation theory level.; n is ZAPT perturbation order. ZERO K ENTHALPY¶; Total electronic and zero-point energy [E_h] at 0 [K]. ZPVE¶; Vibrati",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html:63097,energy,energy,63097,psi4manual/1.7.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html,4,['energy'],['energy']
Energy Efficiency,"of the requested database, either; 'small', a few of the smallest database members,; 'large', the largest of the database members, or; 'equilibrium', the equilibrium geometries for a database; composed of dissociation curves. 'BzBz_S' || 'FaOOFaON' || 'ArNe' || 'HB' || etc.; For databases composed of dissociation curves, or otherwise; divided into subsets, individual curves and subsets can be; called by name. Consult the database python files for available; molecular systems (case insensitive). [1,2,5] || ['1','2','5'] || ['BzMe-3.5', 'MeMe-5.0'] || etc.; Specify a list of database members to run. Consult the; database python files for available molecular systems. This; is the only portion of database input that is case sensitive;; choices for this keyword must match the database python file. Examples:. 1; 2>>> # [1] Two-stage SCF calculation on short, equilibrium, and long helium dimer; >>> db('scf','RGC10',cast_up='sto-3g',subset=['HeHe-0.85','HeHe-1.0','HeHe-1.5'], tabulate=['scf total energy','natom']). 1; 2; 3>>> # [2] Counterpoise-corrected interaction energies for three complexes in S22; >>> # Error statistics computed wrt an old benchmark, S22A; >>> database('mp2','S22',cp=1,subset=[16,17,8],benchmark='S22A'). 1; 2>>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). 1; 2>>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). 1; 2>>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). Output¶; At the beginning of a database job is printed a listing of the individual system; calculations which will be performed. The output snippet below is from the example job [1]; above. It shows each reagent required for the subset of database reactions requested.; Note that t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/db-1.html:5524,energy,energy,5524,psi4manual/1.2.1/db-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/db-1.html,4,['energy'],['energy']
Energy Efficiency,"of the response function, i.e. the excitation energies.; These are **expected** in atomic units of angular frequency.; residues; Residues of the linear response functions, i.e. transition dipole moments (OPA) and rotatory strengths (ECD).; These are **expected** in atomic units.; kind; {""opa"", ""ecd""}; Which kind of spectrum to generate, one-photon absorption (""opa"") or electronic circular dichroism (""ecd"").; Default is `opa`.; lineshape; {""gaussian"", ""lorentzian""}; The lineshape function to use in the fitting. Default is `gaussian`.; gamma; Full width at half maximum of the lineshape function.; Default is 0.2 au of angular frequency.; This value is **expected** in atomic units of angular frequency.; npoints; How many points to generate for the x axis. Default is 5000.; out_units; Units for the output array `x`, the x axis of the spectrum plot.; Default is wavelengths in nanometers.; Valid (and case-insensitive) values for the units are:. - `au` atomic units of angular frequency; - `Eh` atomic units of energy; - `eV`; - `nm`; - `THz`. Returns; -------; spectrum : Dict[str, numpy.ndarray]; The fitted electronic absorption spectrum, with units for the x axis specified by the `out_units` parameter.; This is a dictionary containing the convoluted (key: `convolution`) and the infinitely narrow spectra (key: `sticks`). .. code-block:: python. {""convolution"": {""x"": np.ndarray, ""y"": np.ndarray},; ""sticks"": {""poles"": np.ndarray, ""residues"": np.ndarray}}. Notes; -----; * Conversion of the broadening parameter :math:`\gamma`.; The lineshape functions are formulated as functions of the angular frequency :math:`\omega`.; When converting to other physical quantities, the broadening parameter has to be modified accordingly.; If :math:`\gamma_{\omega}` is the chosen broadening parameter then:. - Wavelength: :math:`gamma_{\lambda} = \frac{\lambda_{ij}^{2}}{2\pi c}\gamma_{\omega}`; - Frequency: :math:`gamma_{\nu} = \frac{\gamma_{\omega}}{2\pi}`; - Energy: :math:`gamma_{E} = \gamma_{\o",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/spectrum.html:8703,energy,energy,8703,psi4manual/1.7.x/_modules/psi4/driver/p4util/spectrum.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/spectrum.html,8,['energy'],['energy']
Energy Efficiency,"of the; linear decay rate of the atomic density. MBIS VOLUME RATIOS¶; Per-atom ratio between the atomic volume (<R^3>) and the free-atomic; volume, unitless. MCSCF TOTAL ENERGY¶; Multiconfigurational self-consistent-field energy [Eh] in the course of; a configuration interaction computation. May be single-root or state-averaged. mtd DIPOLE¶; Dipole array [e a0] for the named method, (3,). mtd QUADRUPOLE¶; Redundant quadrupole array [e a0^2] for the named method, (3, 3). mtd OCTUPOLE¶; Redundant octupole array [e a0^3] for the named method, (3, 3, 3). mtd HEXADECAPOLE¶; Redundant hexadecapole array [e a0^4] for the named method, (3, 3, 3, 3). mtd 32-POLE¶; Redundant 32-pole array [e a0^5] for the named method, (3, 3, 3, 3, 3). mtd 64-POLE¶; Redundant 64-pole array [e a0^6] for the named method, (3, 3, 3, 3, 3, 3). mtd 128-POLE¶; Redundant 128-pole array [e a0^7] for the named method, (3, 3, 3, 3, 3, 3, 3). MP2 TOTAL ENERGY¶. MP2 CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the MP2 level of theory. MP2 TOTAL GRADIENT¶. The total electronic gradient [E_h/a0] of the MP2 level of theory, ({nat}, 3).¶. MP2 DIPOLE GRADIENT¶; The derivative of the MP2 level of theory dipole [E_h a0/u] = [(e a0/a0)^2/u] with respect to nuclear perturbations; as a degree-of-freedom by dipole component array, (3 * {nat}, 3). MP2 TOTAL HESSIAN¶; The total electronic second derivative [Eh/a0/a0] for the MP2 level of theory, (3 * {nat}, 3 * {nat}). MP2.5 TOTAL ENERGY¶. MP2.5 CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the MP2.5 level of theory. MP3 TOTAL ENERGY¶. MP3 CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the MP3 level of theory. MP4(T) CORRECTION ENERGY¶; The MP4 triples component [Eh]. Quantity is second right-hand term in; Eq. (2). MP4(SDQ) TOTAL ENERGY¶. MP4(SDQ) CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/glossary_psivariables.html:35187,energy,energy,35187,psi4manual/1.6.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/glossary_psivariables.html,2,['energy'],['energy']
Energy Efficiency,"of theory. CFOUR ERROR CODE¶; The non-zero return value from a Cfour execution. CI DIPOLE¶; Dipole array [e a0] for the requested configuration interaction level of theory, (3,). CI QUADRUPOLE¶; Redundant quadrupole array [e a0^2] for the requested configuration interaction level of theory, (3, 3). CI ROOT n -> ROOT m DIPOLE¶; Transition dipole array [e a0] between roots n and m for the requested configuration interaction level of theory, (3,). CI ROOT n -> ROOT m QUADRUPOLE¶; Redundant transition quadrupole array [e a0^2] between roots n and m for the requested configuration interaction level of theory, (3, 3). CI ROOT n DIPOLE¶; Dipole array [e a0] for the requested configuration interaction level of theory and root n, (3,). CI ROOT n QUADRUPOLE¶; Redundant quadrupole array [e a0^2] for the requested configuration interaction level of theory and root n, (3, 3). CI ROOT n TOTAL ENERGY¶. CI ROOT n CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the requested configuration interaction level of theory and root; n (numbering starts at 0). CI STATE-AVERAGED TOTAL ENERGY¶. CI STATE-AVERAGED CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for state-averaged CI/CASSCF levels of theory. CI TOTAL ENERGY¶. CI CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the requested configuration interaction level of theory and root. CISD DIPOLE¶; Dipole array [e a0] for the configuration interaction singles and doubles level of theory, (3,). CISD QUADRUPOLE¶; Redundant quadrupole array [e a0^2] for the configuration interaction singles and doubles level of theory, (3, 3). CISD TOTAL ENERGY¶. CISD CORRELATION ENERGY¶. CISDT TOTAL ENERGY¶. CISDT CORRELATION ENERGY¶. CISDTQ CORRELATION ENERGY¶. CISDTQ TOTAL ENERGY¶. CIn CORRELATION ENERGY¶. CIn TOTAL ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the labeled conf",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/glossary_psivariables.html:21878,energy,energy,21878,psi4manual/1.6.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/glossary_psivariables.html,2,['energy'],['energy']
Energy Efficiency,"of; each computation are made available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of H2; and H atom:; molecule h2{; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h{; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol*(2*h_energy - h2_energy); print""De=%f""%D_e. The energy() function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation.; Generally, there are multiple quantities of interest. Appendix; PSI Variables by Module lists PSI variables variables set by each; module. These can be accessed through the get_variable() function.; For example, after performing a density fitted MP2 computation, both the; spin component scaled energy and the unscaled MP2 energy are made; available:; e_mp2=get_variable('MP2 TOTAL ENERGY'); e_scs_mp2=get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command print_variables(). Note that PSI variables; accumulate over a PSI4 instance and are not cleared by clean().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the last will; include both SCF TOTAL ENERGY and FCI; TOTAL ENERGY. Don’t get excited that you got a; high-quality calculation cheaply. Loops¶; Python provides many control structures, which can be used within PSI4; input files. For example, to loop over three basis sets, the following code can; be used:; basis_sets=[""cc-pVDZ"",""cc-pVTZ"",""cc-pVQZ""]; for basis_set in basis_sets:; set basis = $basis_set; energy('scf'). The declaration of basis_set is completely standard Python",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:23874,energy,energy,23874,psi4manual/4.0b4/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html,8,['energy'],['energy']
Energy Efficiency,"of; the SAPT energy components are negative; this means those are attractive; contributions (the zero of energy in a SAPT computation is defined as; non-interacting monomers). The exchange contributions are positive; (repulsive). In this example, the most attractive contribution between; ethylene and acetylene is an electrostatic term of -2.12 kcal mol-1; (Elst10,r where the 1 indicates the first-order; perturbation theory result with respect to the intermolecular interaction,; and the 0 indicates zeroth-order with respect to intramolecular electron; correlation). The next most attractive contribution is the Disp20; term (2nd order intermolecular dispersion, which looks like an MP2 in which; one excitation is placed on each monomer), contributing an attraction of; -1.21 kcal mol-1. It is not surprising that the electrostatic; contribution is dominant, because the geometry chosen for this example has the; acetylene perpendicular to the ethylene, with the acetylene hydrogen; pointing directly at the double bond in ethylene; this will be attractive; because the H atoms in acetylene bear a partial positive charge, while the; electron-rich double bond in ethylene bears a partial negative charge. At; the same time, the dispersion interaction should be smaller because the; perpendicular geometry does not allow much overlap between the monomers.; Hence, the SAPT analysis helps clarify (and quantify) our physical; understanding about the interaction between the two monomers. Potential Surface Scans and Counterpoise Correction Made Easy with Psithon¶; Finally, let’s consider an example that shows how the Python driver; in PSI4 simplifies some routine tasks. PSI4 can interpret; valid Python code in addition to the computational chemistry directives; we’ve seen in the previous examples; we call this mixture Psithon.; The Python computer language is very easy to pick up, and even users; previously unfamiliar with Python can use it to simplify tasks by; modifying some of the examp",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/tutorial-1.html:15256,charge,charge,15256,psi4manual/1.1.0/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/tutorial-1.html,46,['charge'],['charge']
Energy Efficiency,"of; the SAPT energy components are negative; this means those are attractive; contributions (the zero of energy in a SAPT computation is defined as; non-interacting monomers). The exchange contributions are positive; (repulsive). In this example, the most attractive contribution between; ethylene and acetylene is an electrostatic term of -2.12 kcal mol-1; (Elst10,r where the 1 indicates the first-order; perturbation theory result with respect to the intermolecular interaction,; and the 0 indicates zeroth-order with respect to intramolecular electron; correlation). The next most attractive contribution is the Disp20; term (2nd order intermolecular dispersion, which looks like an MP2 in which; one excitation is placed on each monomer), contributing an attraction of; -1.21 kcal mol-1. It is not surprising that the electrostatic; contribution is dominant, because the geometry chosen for this example has the; acetylene perpendicular to the ethylene, with the acetylene hydrogen; pointing directly at the double bond in ethylene; this will be attractive; because the H atoms in acetylene bear a partial positive charge, while the; electron-rich double bond in ethylene bears a partial negative charge. At; the same time, the dispersion interaction should be smaller because the; perpendicular geometry does not allow much overlap between the monomers.; Hence, the SAPT analysis helps clarify (and quantify) our physical; understanding about the interaction between the two monomers. Potential Surface Scans and Counterpoise Correction Made Easy with Psithon¶; Finally, let’s consider an example that shows how the Python driver; in Psi4 simplifies some routine tasks. Psi4 can interpret; valid Python code in addition to the computational chemistry directives; we’ve seen in the previous examples; we call this mixture Psithon.; The Python computer language is very easy to pick up, and even users; previously unfamiliar with Python can use it to simplify tasks by; modifying some of the examp",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/tutorial-1.html:14516,charge,charge,14516,psi4manual/1.0.0/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/tutorial-1.html,4,['charge'],['charge']
Energy Efficiency,"oftware Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. from __future__ import absolute_import; from __future__ import print_function; from __future__ import division; import os; import sys; import hashlib; import collections. import numpy as np. from .libmintsmolecule import *; from .psiutil import compare_values, compare_integers, compare_molrecs; from .util import unnp; from . import molparse; from .bfs import BFS. if sys.version_info >= (3,0):; basestring = str. class Molecule(LibmintsMolecule):; """"""Class to store the elements, coordinates, fragmentation pattern,; charge, multiplicity of a molecule. Largely replicates psi4's libmints; Molecule class, developed by Justin M. Turney and Andy M. Simmonett; with incremental improvements by other psi4 developers. Major. This class extends `qcdb.LibmintsMolecule` and occasionally; `psi4.core.Molecule` itself. """"""; def __init__(self,; molinit=None,; dtype=None,. geom=None,; elea=None,; elez=None,; elem=None,; mass=None,; real=None,; elbl=None,. name=None,; units='Angstrom',; input_units_to_au=None,; fix_com=None,; fix_orientation=None,; fix_symmetry=None,. fragment_separators=None,; fragment_charges=None,; fragment_multiplicities=None,. molecular_charge=None,; molecular_multiplicity=None,. enable_qm=True,; enable_efp=True,; missing_enabled_return_qm='none',; missing_enabled_return_efp='none',. missing_enabled_return='error',; tooclose=0.1,; zero_ghost_fragments=False,; nonphysical=False,; mtol=1.e-3,; verbose=1):; """"""Initialize Molecule object from LibmintsMolecule"""""";",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/qcdb/molecule.html:1604,charge,charge,1604,psi4manual/1.2.1/_modules/psi4/driver/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/qcdb/molecule.html,1,['charge'],['charge']
Energy Efficiency,"og(10) * (4 * np.pi * e_0) * hbar * c. return (numerator / denominator) * au_to_Coulomb_centimeter**2. [docs]def prefactor_ecd() -> float:; r""""""Prefactor for converting microscopic observable to decadic molar; extinction coefficient in electronic circular dichroism. Notes; -----; This function implements the calculation of the following prefactor:. .. math::. k = \frac{16\pi^{2}N_{\mathrm{A}}}{3\times 1000\times \ln(10) (4 \pi \epsilon_{0}) n \hbar c^{2}}. The prefactor is computed in SI units and then adjusted for the fact that; we use atomic units to express microscopic observables: excitation energies; and transition dipole moments.; The refractive index :math:`n` is, in general, frequency-dependent. We; assume it to be constant and equal to 1. """""". N_A = constants.get(""Avogadro constant""); c = constants.get(""speed of light in vacuum""); hbar = constants.get(""Planck constant over 2 pi""); e_0 = constants.get(""electric constant""). au_to_Coulomb_centimeter = constants.get(""elementary charge"") * constants.get(; ""Bohr radius"") * constants.conversion_factor(""m"", ""cm""); au_to_Joule_inverse_Tesla = 2.0 * constants.get(""Bohr magneton"") * constants.conversion_factor(""m"", ""cm""); conversion = au_to_Coulomb_centimeter * au_to_Joule_inverse_Tesla. numerator = 16.0 * np.pi**2 * N_A; denominator = 3 * 1000 * np.log(10) * (4 * np.pi * e_0) * hbar * c**2. return (numerator / denominator) * conversion. [docs]def spectrum(*,; poles: Union[List[float], np.ndarray],; residues: Union[List[float], np.ndarray],; kind: str = ""opa"",; lineshape: str = ""gaussian"",; gamma: float = 0.2,; npoints: int = 5000,; out_units: str = ""nm"") -> Dict[str, np.ndarray]:; r""""""One-photon absorption (OPA) or electronic circular dichroism (ECD); spectra with phenomenological line broadening. This function gives arrays of values ready to be plotted as OPA spectrum:. .. math::. \varepsilon(\omega) =; \frac{4\pi^{2}N_{\mathrm{A}}\omega}{3\times 1000\times \ln(10) (4 \pi \epsilon_{0}) n \hbar c}; \sum_{i \rightarrow",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/spectrum.html:6084,charge,charge,6084,psi4manual/1.7.x/_modules/psi4/driver/p4util/spectrum.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/spectrum.html,2,['charge'],['charge']
Energy Efficiency,"ogram [manual]. c4-scf; Hartree–Fock (HF). c4-mp2; 2nd-order Møller–Plesset perturbation theory (non-density-fitting) (MP2). c4-mp3; 3rd-order Møller–Plesset perturbation theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. 1; 2>>> # [1] Coupled-cluster singles and doubles calculation with psi code; >>> energy('ccsd'). 1; 2; 3; 4; 5>>> # [2] Charge-transfer SAPT calculation with scf projection from small into; >>> # requested basis, with specified projection fitting basis; >>> set basis_guess true; >>> set df_basis_guess jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). 1; 2>>> # [3] Arbitrary-order MPn calculation; >>> energy('mp7'). 1; 2; 3; 4; 5; 6; 7; 8; 9>>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> # Note that the integral transformation is not done automatically when detci is run in a separate step.; >>> molecule H2 {\n0 1\nH\nH 1 0.74\n}; >>> set basis cc-pVDZ; >>> set reference rohf; >>> scf_e, scf_wfn = energy('scf', return_wfn=True); >>> H2.set_multiplicity(3); >>> core.MintsHelper(scf_wfn.basisset()).integrals(); >>> energy('detci', ref_wfn=scf_wfn). 1; 2; 3; 4; 5>>> # [5] Run two CI calculations, keeping the integrals generated in the first one.; >>> molecule ne {\nNe\n}; >>> set basis cc-pVDZ; >>> cisd_e, cisd_wfn = energy('cisd', return_wfn=True); >>> energy('fci', ref_wfn=cisd_wfn). 1; 2>>> # [6] Can automatically perform complete basis set extrapolations; >>> energy(""CCSD/cc-pV[DT]Z""). 1; 2; 3; 4>>> # [7] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation fo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.energy.html:13721,energy,energy,13721,psi4manual/1.1.0/api/psi4.driver.energy.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.energy.html,3,['energy'],['energy']
Energy Efficiency,"ohr. sapt-exch-ind30-inf; SAPT2+3 with S^inf exch-ind30 Geometries taken from the S66x10 database, the shortest-range point (R = 0.7 R_e). dlpnomp2-2; comparison of DF-MP2 and DLPNO-MP2 with a CBS extrapolation. stability3; Test LDA stability analysis against QChem. dfmp2-grad3; DF-MP2 cc-pVDZ gradients for the H2O molecule. options1; check all variety of options parsing. scf4; RHF cc-pVDZ energy for water, automatically scanning the symmetric stretch and bending coordinates using Python’s built-in loop mechanisms. The geometry is specified using a Z-matrix with variables that are updated during the potential energy surface scan, and then the same procedure is performed using polar coordinates, converted to Cartesian coordinates. pywrap-checkrun-rohf; This checks that all energy methods can run with a minimal input and set symmetry. cbs-xtpl-opt; Various extrapolated optimization methods for the H2 molecule. dfomp2-1; OMP2 cc-pVDZ energy for the H2O molecule. dfccsd1; DF-CCSD cc-pVDZ energy for the H2O molecule. omp2p5-1; OMP2.5 cc-pVDZ energy for the H2O molecule. cc-module; check that CC is returning the same values btwn CC*, FNOCC, and DFOCC modules. opt-full-hess-every; SCF/sto-3g optimization with a hessian every step. cbs-xtpl-freq; Various gradients for a strained helium dimer and water molecule. dft-grac; Gradient regularized asymptotic correction (GRAC) test. cc13b; Tests RHF CCSD(T)gradients. sapt-sf1; Tests the Psi4 SF-SAPT code. tdscf-2; td-uhf test on triplet states of methylene (tda), wfn passing. x2c3; Test of SFX2C-1e on Water uncontracted cc-pVDZ The reference numbers are from Lan Cheng’s implementation in Cfour. ci-multi; BH single points, checking that program can run multiple instances of DETCI in a single input, without an intervening clean() call. mints-helper; A general test of the MintsHelper function. mcscf2; TCSCF cc-pVDZ energy of asymmetrically displaced ozone, with Z-matrix input. sapt9; usapt example with empty beta. dfmp2-1; Density fi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html:42260,energy,energy,42260,psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"oi.org/10.1002/9781118008720.ch2; """""". # Transmute inputs to np.ndarray; if isinstance(poles, list):; poles = np.array(poles); if isinstance(residues, list):; residues = np.array(residues); # Validate input arrays; if poles.shape != residues.shape:; raise ValueError(f""Shapes of poles ({poles.shape}) and residues ({residues.shape}) vectors do not match!""). # Validate kind of spectrum; kind = kind.lower(); valid_kinds = [""opa"", ""ecd""]; if kind not in valid_kinds:; raise ValueError(f""Spectrum kind {kind} not among recognized ({valid_kinds})""). # Validate output units; out_units = out_units.lower(); valid_out_units = [""au"", ""eh"", ""ev"", ""nm"", ""thz""]; if out_units not in valid_out_units:; raise ValueError(f""Output units {out_units} not among recognized ({valid_out_units})""). c = constants.get(""speed of light in vacuum""); c_nm = c * constants.conversion_factor(""m"", ""nm""); hbar = constants.get(""Planck constant over 2 pi""); h = constants.get(""Planck constant""); Eh = constants.get(""Hartree energy""); au_to_nm = 2.0 * np.pi * c_nm * hbar / Eh; au_to_THz = (Eh / h) * constants.conversion_factor(""Hz"", ""THz""); au_to_eV = constants.get(""Hartree energy in eV""). converters = {; ""au"": lambda x: x, # Angular frequency in atomic units; ""eh"": lambda x: x, # Energy in atomic units; ""ev"": lambda x: x * au_to_eV, # Energy in electronvolts; ""nm"": lambda x: au_to_nm / x, # Wavelength in nanometers; ""thz"": lambda x: x * au_to_THz, # Frequency in terahertz; }. # Perform conversion of poles from au of angular frequency to output units; poles = converters[out_units](poles). # Broadening functions; gammas = {; ""au"": lambda x_0: gamma, # Angular frequency in atomic units; ""eh"": lambda x_0: gamma, # Energy in atomic units; ""ev"": lambda x_0: gamma * au_to_eV, # Energy in electronvolts; ""nm"": lambda x_0: ((x_0**2 * gamma * (Eh / hbar)) / (2 * np.pi * c_nm)), # Wavelength in nanometers; ""thz"": lambda x_0: gamma * au_to_THz, # Frequency in terahertz; }. # Generate x axis; # Add a fifth of the range on e",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/spectrum.html:10903,energy,energy,10903,psi4manual/1.7.x/_modules/psi4/driver/p4util/spectrum.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/spectrum.html,8,['energy'],['energy']
Energy Efficiency,"oice of unrestricted orbitals; (unrestricted Hartree–Fock, or UHF), or restricted orbitals (restricted; open-shell Hartree–Fock, or ROHF). Usually, UHF is a little easier to; converge (although it may be more susceptible to spin contamination than; ROHF). Geometry Optimization and Vibrational Frequency Analysis¶; The above examples were simple single-point energy computations; (as specified by the energy() function). Of course there are other; kinds of computations to perform, such as geometry optimizations and; vibrational frequency computations. These can be specified by replacing; energy() with optimize() or frequency(), respectively.; Here’s an example of optimizing the H2O molecule using Hartree–Fock with; a cc-pVDZ basis set (located in; tu3-h2o-opt).; #! Optimize H2O HF/cc-pVDZ. molecule h2o {; O ; H 1 0.96; H 1 0.96 2 104.5; }. set basis cc-pVDZ; optimize('scf'). This should perform a series of gradient computations. The gradient points; which way is downhill in energy, and the optimizer then modifies the; geometry to follow the gradient. After a few cycles, the geometry should; converge with a message like Optimization is complete!. As indicated; in the following table (printed by the optimizer at the end of the; computation and grep-able with ~), the energy decreases with each step,; and the maximum force on each atom also decreases with each step (in; principle these numbers could increase in some iterations, but here they do; not).; --------------------------------------------------------------------------------------------------------------- ~; Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~; --------------------------------------------------------------------------------------------------------------- ~; 1 -76.026632734857 -76.026632734857 0.01523505 0.01245744 0.02742199 0.02277500 ~; 2 -76.027022668419 -0.000389933562 0.00178749 0.00142923 0.01007985 0.00594840 ~; 3 -76.027032729361 -0.000010060942 0.00014016 0.00008485 0.00077279 0",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/tutorial-1.html:6170,energy,energy,6170,psi4manual/1.4.0/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/tutorial-1.html,9,['energy'],['energy']
Energy Efficiency,"oice of unrestricted orbitals; (unrestricted Hartree–Fock, or UHF), or restricted orbitals (restricted; open-shell Hartree–Fock, or ROHF). Usually, UHF is a little easier to; converge (although it may be more susceptible to spin contamination than; ROHF). Geometry Optimization and Vibrational Frequency Analysis¶; The above examples were simple single-point energy computations; (as specified by the energy() function). Of course there are other; kinds of computations to perform, such as geometry optimizations and; vibrational frequency computations. These can be specified by replacing; energy() with optimize() or frequency(), respectively.; Here’s an example of optimizing the H2O molecule using Hartree–Fock with; a cc-pVDZ basis set (located in; tu3-h2o-opt).; #! Optimize H2O HF/cc-pVDZ. molecule h2o {; O ; H 1 0.96; H 1 0.96 2 104.5; }. set basis cc-pVDZ; optimize('scf'). This should perform a series of gradient computations. The gradient points; which way is downhill in energy, and the optimizer then modifies the; geometry to follow the gradient. After a few cycles, the geometry should; converge with a message like Optimization is complete!. As indicated; in the following table (printed by the optimizer at the end of the; computation and grep-able with ~), the energy decreases with each step,; and the maximum force on each atom also decreases with each step (in; principle these numbers could increase in some iterations, but here they do; not).; 1; 2; 3; 4; 5; 6; 7--------------------------------------------------------------------------------------------------------------- ~; Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~; --------------------------------------------------------------------------------------------------------------- ~; 1 -76.026632734857 -76.026632734857 0.01523505 0.01245744 0.02742199 0.02277500 ~; 2 -76.027022668419 -0.000389933562 0.00178749 0.00142923 0.01007985 0.00594840 ~; 3 -76.027032729361 -0.000010060942 0.00014016 0.00",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/tutorial-1.html:6133,energy,energy,6133,psi4manual/1.1.0/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/tutorial-1.html,6,['energy'],['energy']
Energy Efficiency,"oided. In the next RHF-ODC-12 computation, AO_BASIS=NONE is used, where four-virtual integrals are transformed into MO basis. fci-coverage; 6-31G H2O Test for coverage. scf-occ; force occupations in scf. scf7; Tests SCF gradient in the presence of a dipole field. omp2-4; SCS-OMP2 cc-pVDZ geometry optimization for the H2O molecule. pywrap-all; Intercalls among python wrappers- database, cbs, optimize, energy, etc. Though each call below functions individually, running them all in sequence or mixing up the sequence is aspirational at present. Also aspirational is using the intended types of gradients. rasci-c2-active; 6-31G* C2 Test RASCI Energy Point, testing two different ways of specifying the active space, either with the ACTIVE keyword, or with RAS1, RAS2, RESTRICTED_DOCC, and RESTRICTED_UOCC. cc21; ROHF-EOM-CCSD/DZ analytic gradient lowest \(^{2}A_1\) excited state of H2O+ (B1 excitation). omp3-4; SCS-OMP3 cc-pVDZ geometry optimization for the H2O molecule. dfomp2-4; OMP2 cc-pVDZ energy for the NO molecule. dft-grad-lr2; Tests CAM gradients with and without XC pieces to narrow grid error. dft-vv10; He Dimer VV10 functional test. notes: DFT_VV10_B/C overwrites the NL_.. tuple. mcscf2; TCSCF cc-pVDZ energy of asymmetrically displaced ozone, with Z-matrix input. dft-custom-hybrid; DFT (hybrids) test of implementations in: hybrid_superfuncs.py. cepa4; cc-pvdz H2O Test coupled-pair LCCD against DCFT CEPA0. omp2-2; OMP2 cc-pVDZ energy with ROHF initial guess orbitals for the NO radical. cc33; CC3(UHF)/cc-pVDZ H2O \(R_e\) geom from Olsen et al., JCP 104, 8007 (1996). pywrap-freq-e-sowreap; Finite difference of energies frequency, run in sow/reap mode. fsapt-allterms; This test case shows an example of running and analyzing a standard F-SAPT0/jun-cc-pvdz procedure for HSG-18-dimer from the HSG database. cc51; EOM-CC3/cc-pVTZ on H2O. opt12; SCF cc-pVDZ geometry optimzation of ketene, starting from bent structure. scf-ecp; Water-Argon complex with ECP present; check of ene",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html:37055,energy,energy,37055,psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,8,['energy'],['energy']
Energy Efficiency,"oing a full CI in the active space. This is called a; RASSCF. CASSCF and RASSCF computations are types of multi-configurational; self-consistent-field procedures, and are described in sec:mcscf.; As mentioned above, the DETCI module is designed for challenging; chemical systems for which simple CISD is not suitable. Because; CI wavefunctions which go beyond CISD (such as RAS CI) are fairly complex,; typically the DETCI code will be used in cases where the; tradeoffs between computational expense and completeness of the; model space are nontrivial. Hence, the user is advised to develop; a good working knowledge of multi-reference and RAS CI methods before; attempting to use the program for a production-level project. This user’s; manual will provide only an elementary introduction to the most; important keywords. Additional information is available in the complete; list of keywords for DETCI provided in Appendix DETCI.; For single-reference CI computations, the easiest way to invoke a CI; computation with DETCI is simply to call energy(), optimize(), etc.,; with the common name for that CI wavefunction, like energy('cisd'); for a CISD single-point energy. The Python driver; recognizes cisd, cisdt, and cisdtq. Higher order; single-reference CI wavefunctions, like those including singles through; 6-fold excitations, can be invoked using numbers, like ci6. A full; CI can be specified by fci. More complicated CI computations, like; RASCI, can be performed by setting the appropriate keywords and calling the; module generically like energy('detci'). The latter approach; will also work for any of the previously-mentioned CI wavefunctions for; which the driver has built-in shortcuts, so long as the relevant options; (especially EX_LEVEL) are set appropriately. Some; examples of single-refence CI, RASCI, and full CI computations are provided; in psi4/samples. Orbital spaces for CI computations¶. CI (e.g., CISD, FCI); RASCI; CASCI. FROZEN_UOCC; FROZEN_UOCC; FROZEN_UOCC [1]. (al",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/detci-1.html:4481,energy,energy,4481,psi4manual/1.2.1/detci-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/detci-1.html,6,['energy'],['energy']
Energy Efficiency,"oing to be used. Type: boolean; Default: true. EXCH_SCALE_ALPHA¶. Whether or not to perform exchange scaling for SAPT exchange components. Default is false, i.e. no scaling. If set to true, performs scaling with \(Exch10 / Exch10(S^2)\). If set to a value \(\alpha\), performs scaling with \((Exch10 / Exch10(S^2))^{\alpha}\). Type: string; Default: FALSE. INTS_TOLERANCE¶. Schwarz screening threshold. Minimum absolute value below which all three-index DF integrals and those contributing to four-index integrals are neglected. The default is conservative, but there isn’t much to be gained from loosening it, especially for higher-order SAPT. Type: conv double; Default: 1.0e-12. DENOMINATOR_DELTA¶. Maximum error allowed (Max error norm in Delta tensor) in the approximate energy denominators employed for most of the \(E_{disp}^{(20)}\) and \(E_{exch-disp}^{(20)}\) evaluation. Type: double; Default: 1.0e-6. DENOMINATOR_ALGORITHM¶. Denominator algorithm for PT methods. Laplace transformations are slightly more efficient. Type: string; Possible Values: LAPLACE, CHOLESKY; Default: LAPLACE. DEBUG¶. The amount of information to print to the output file. Type: integer; Default: 0. Specific open-shell SAPT0 keywords¶. SAPT_MEM_SAFETY¶. Memory safety. Type: double; Default: 0.9. COUPLED_INDUCTION¶. Solve the CPHF equations to compute coupled induction and exchange-induction. These are not available for ROHF, and the option is automatically false in this case. In all other cases, coupled induction is strongly recommended. Only turn it off if the induction energy is not going to be used. Type: boolean; Default: true. Higher-Order SAPT¶; For smaller systems (up to the size of a nucleic acid base pair), more; accurate interaction energies can be obtained through higher-order SAPT; computations. The SAPT module can perform density-fitted evaluations; of SAPT2, SAPT2+, SAPT2+(3), and SAPT2+3 energies for closed-shell systems; only. Publications resulting from the use of the higher-order S",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/sapt-1.html:18136,efficient,efficient,18136,psi4manual/1.3.2/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/sapt-1.html,2,['efficient'],['efficient']
Energy Efficiency,"oing to be used. Type: boolean; Default: true. EXCH_SCALE_ALPHA¶. Whether or not to perform exchange scaling for SAPT exchange components. Default is false, i.e. no scaling. If set to true, performs scaling with \(Exch10 / Exch10(S^2)\). If set to a value \(\alpha\), performs scaling with \((Exch10 / Exch10(S^2))^{\alpha}\). Type: string; Default: FALSE. INTS_TOLERANCE¶. Schwarz screening threshold. Minimum absolute value below which all three-index DF integrals and those contributing to four-index integrals are neglected. The default is conservative, but there isn’t much to be gained from loosening it, especially for higher-order SAPT. Type: conv double; Default: 1.0e-12. DENOMINATOR_DELTA¶. Maximum error allowed (Max error norm in Delta tensor) in the approximate energy denominators employed for most of the \(E_{disp}^{(20)}\) and \(E_{exch-disp}^{(20)}\) evaluation. Type: double; Default: 1.0e-6. DENOMINATOR_ALGORITHM¶. Denominator algorithm for PT methods. Laplace transformations are slightly more efficient. Type: string; Possible Values: LAPLACE, CHOLESKY; Default: LAPLACE. DEBUG¶. The amount of information to print to the output file. Type: integer; Default: 0. Specific open-shell SAPT0 keywords¶. SAPT_MEM_SAFETY¶. Memory safety. Type: double; Default: 0.9. COUPLED_INDUCTION¶. Solve the CPHF equations to compute coupled induction and exchange-induction. These are not available for ROHF, and the option is automatically false in this case. In all other cases, coupled induction is strongly recommended. Only turn it off if the induction energy is not going to be used. Type: boolean; Default: true. SAPT(DFT)¶; In general, SAPT(DFT) should provide more accurate interaction energy; components, and overall interaction energies, than SAPT0. The drawback; is SAPT(DFT) method is more computationally demanding than SAPT0,; SAPT(DFT) can still be applied to medium-sized or large systems. The; SAPT(DFT) module was employed successfully in computations of systems; with up to ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/sapt-1.html:20449,efficient,efficient,20449,psi4manual/1.4.0/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/sapt-1.html,9,['efficient'],['efficient']
Energy Efficiency,"oint CCSD(T)/qz2p on NH2 with ecc. cfour/kw-4; Basis set spherical/Cartesian with basis and puream. cfour/sp-rohf-ccsd-ao; single-point CCSD/qz2p on NH2 with aobasis. cfour/sp-rhf-ccsd-ao; single-point CCSD/qz2p on water with aobasis. cfour/sp-uhf-scf; single-point HF/qz2p on NH2. cfour/sp-rhf-ccsdt; single-point CCSDT/qz2p on water. cfour/sp-uhf-ccsd_t_-ao-ecc; single-point CCSD(T)/qz2p on NH2 with ecc, aobasis. cfour/sp-uhf-cc3; single-point CC3/qz2p on NH2. cfour/dfmp2-1; MP2/cc-PVDZ computation of formic acid dimer binding energy using automatic counterpoise correction. Monomers are specified using Cartesian coordinates. cfour/sp-rhf-scf; single-point HF/qz2p on water. cfour/sp-rohf-ccsdt; single-point CCSDT/qz2p on NH2. cfour/sp-rohf-mp2-sc; single-point MP2/qz2p on NH2. cfour/sp-rohf-mp4-sc; single-point MP4/qz2p on NH2. cfour/psi-ghost-grad; MP2 optimization of dimers with one momomer ghosted. Gradients after three opt cycles are compared with those from psi4. cfour/psi-mp4; MP4 energy components. Checks that computed identically between cfour and psi4. cfour/sp-rohf-scf; single-point HF/qz2p on NH2. cfour/opt-rhf-scf; optimization HF/svp on water. cfour/psi-uhf-scsmp2; UHF MP2 energy components. Checks that computed identically between cfour and psi4. cfour/sp-rhf-ccsd; single point CCSD/qz2p on water. cfour/kw-2; testing best practices options, part ii. cfour/sp-rhf-ccsd_t_-ao-ecc; single-point CCSD(T)/qc2p on water with ecc, aobasis. cfour/psi-uhf-mp3; UHF MP3 energy components. Checks that converted identically between cfour and psi4. cfour/mp2-1; All-electron MP2 6-31G** geometry optimization of water. cfour/kw-1; testing best practices options, part i. cfour/sp-rohf-ccsd_t_; single-point CCSD(T)/qz2p on NH2. cfour/kw-5; Basis set spherical/Cartesian with basis and cfour_spherical. cfour/sp-rohf-ccsd_t_-ao-ecc; single-point CCSD(T)/qz2p on NH2 with ecc, aobasis. cfour/sp-uhf-ccsdt; single-point CCSDT/qz2p on NH2. cfour/sp-rohf-ccsd; single-point CCSD/qz2",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_cfour-1.html:2902,energy,energy,2902,psi4manual/1.4.0/autodoc_testsuite_cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_cfour-1.html,2,['energy'],['energy']
Energy Efficiency,"oint CCSD/qz2p on water with aobasis. cfour/sp-uhf-scf; single-point HF/qz2p on NH2. cfour/sp-rhf-ccsdt; single-point CCSDT/qz2p on water. cfour/sp-uhf-ccsd_t_-ao-ecc; single-point CCSD(T)/qz2p on NH2 with ecc, aobasis. cfour/sp-uhf-cc3; single-point CC3/qz2p on NH2. cfour/dfmp2-1; MP2/cc-PVDZ computation of formic acid dimer binding energy using automatic counterpoise correction. Monomers are specified using Cartesian coordinates. cfour/sp-rhf-scf; single-point HF/qz2p on water. cfour/sp-rohf-ccsdt; single-point CCSDT/qz2p on NH2. cfour/sp-rohf-mp2-sc; single-point MP2/qz2p on NH2. cfour/sp-rohf-mp4-sc; single-point MP4/qz2p on NH2. cfour/psi-ghost-grad; MP2 optimization of dimers with one momomer ghosted. Gradients after three opt cycles are compared with those from psi4. cfour/psi-mp4; MP4 energy components. Checks that computed identically between cfour and psi4. cfour/sp-rohf-scf; single-point HF/qz2p on NH2. cfour/opt-rhf-scf; optimization HF/svp on water. cfour/psi-uhf-scsmp2; UHF MP2 energy components. Checks that computed identically between cfour and psi4. cfour/sp-rhf-ccsd; single point CCSD/qz2p on water. cfour/kw-2; testing best practices options, part ii. cfour/sp-rhf-ccsd_t_-ao-ecc; single-point CCSD(T)/qc2p on water with ecc, aobasis. cfour/psi-uhf-mp3; UHF MP3 energy components. Checks that converted identically between cfour and psi4. cfour/mp2-1; All-electron MP2 6-31G** geometry optimization of water. cfour/kw-1; testing best practices options, part i. cfour/sp-rohf-ccsd_t_; single-point CCSD(T)/qz2p on NH2. cfour/kw-5; Basis set spherical/Cartesian with basis and cfour_spherical. cfour/sp-rohf-ccsd_t_-ao-ecc; single-point CCSD(T)/qz2p on NH2 with ecc, aobasis. cfour/sp-uhf-ccsdt; single-point CCSDT/qz2p on NH2. cfour/sp-rohf-ccsd; single-point CCSD/qz2p on NH2. cfour/psi-rohf-scsmp2; ROHF MP2 energy components. Checks that computed identically between cfour and psi4. cfour/psi-rhf-scsmp2; MP2 energy components. Checks that computed identically be",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_cfour-1.html:3105,energy,energy,3105,psi4manual/1.4.0/autodoc_testsuite_cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_cfour-1.html,2,['energy'],['energy']
Energy Efficiency,"oint correlated extrapolation for """"""; """"""method: %s <==\n\n"""""" % (functionname.upper())); core.print_out("""""" LO-zeta (%s) Data\n"""""" % (str(zLO))); valueLO.print_out(); core.print_out("""""" HI-zeta (%s) Data\n"""""" % (str(zHI))); valueHI.print_out(); core.print_out("""""" Extrapolated Data:\n""""""); value.print_out(); core.print_out("""""" Alpha (exponent) Value: %16.8f\n"""""" % alpha); core.print_out("""""" Beta Data:\n""""""); beta.print_out(). # value.add(valueSCF); return value. else:; raise ValidationError(""corl_xtpl_helgaker_2: datatype is not recognized '%s'."" % type(valueLO)). def return_energy_components():; """"""Define some quantum chemical knowledge, namely what methods are subsumed in others."""""". # yapf: disable; VARH = {}; VARH['scf'] = {; 'scf': 'SCF TOTAL ENERGY'}; VARH['hf'] = {; 'hf': 'HF TOTAL ENERGY'}; VARH['mp2'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY'}; VARH['mp2d'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2d': 'MP2D TOTAL ENERGY'}; VARH['mp2.5'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'mp2.5': 'MP2.5 TOTAL ENERGY',; 'mp3': 'MP3 TOTAL ENERGY'}; VARH['mp3'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'mp2.5': 'MP2.5 TOTAL ENERGY',; 'mp3': 'MP3 TOTAL ENERGY'}; VARH['mp4(sdq)'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'mp2.5': 'MP2.5 TOTAL ENERGY',; 'mp3': 'MP3 TOTAL ENERGY',; 'mp4(sdq)': 'MP4(SDQ) TOTAL ENERGY'}; VARH['mp4'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'mp2.5': 'MP2.5 TOTAL ENERGY',; 'mp3': 'MP3 TOTAL ENERGY',; 'mp4(sdq)': 'MP4(SDQ) TOTAL ENERGY',; 'mp4': 'MP4 TOTAL ENERGY'}; VARH['omp2'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'omp2': 'OMP2 TOTAL ENERGY'}; VARH['omp2.5'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'mp2.5': 'MP2.5 TOTAL ENERGY',; 'omp2.5': 'OMP2.5 TOTAL ENERGY'}; VARH['omp3'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'mp3': 'MP3 TOTAL ENERGY',; 'omp3': 'OMP3 TOTAL ENERGY'}; VARH['olccd'] = {; 'hf': 'HF TOTAL EN",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:23727,ENERGY,ENERGY,23727,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,2,['ENERGY'],['ENERGY']
Energy Efficiency,"oint group; # symmetry_frame looks for the highest point group so that we can align; # the molecule according to its actual symmetry, rather than the symmetry; # the the user might have provided.; frame = self.symmetry_frame(); self.rotate_full(frame); #print ""after rotate:""; #self.print_full(). # Recompute point group of the molecule, so the symmetry info is updated to the new frame; self.set_point_group(self.find_point_group()); self.set_full_point_group(). # Disabling symmetrize for now if orientation is fixed, as it is not; # correct. We may want to fix this in the future, but in some cases of; # finite-differences the set geometry is not totally symmetric anyway.; # Symmetrize the molecule to remove any noise; self.symmetrize(); #print ""after symmetry:""; #self.print_full(). self.lock_frame = True. # <<< Methods for Miscellaneous >>>. [docs] def clear(self):; """"""Zero it out.""""""; self.lock_frame = False; self.atoms = []; self.full_atoms = []. [docs] def nuclear_repulsion_energy(self):; """"""Computes nuclear repulsion energy. >>> print H2OH2O.nuclear_repulsion_energy(); 36.6628478528. """"""; e = 0.0; for at1 in range(self.natom()):; for at2 in range(self.natom()):; if at2 < at1:; Zi = self.Z(at1); Zj = self.Z(at2); dist = distance(self.xyz(at1), self.xyz(at2)); e += Zi * Zj / dist; return e. [docs] def nuclear_repulsion_energy_deriv1(self):; """"""Computes nuclear repulsion energy derivatives. >>> print H2OH2O.nuclear_repulsion_energy_deriv1(); [[3.9020946901323774, 2.76201566471991, 0.0], [1.3172905807089021, -2.3486366050337293, 0.0], [-1.8107598525022435, -0.32511212499256564, 0.0], [-1.217656141385739, -2.6120090867576717, 0.0], [-1.0954846384766488, 1.2618710760320282, 2.1130743287465603], [-1.0954846384766488, 1.2618710760320282, -2.1130743287465603]]. """"""; de = []; for i in range(self.natom()):; entry = [0.0, 0.0, 0.0]; for j in range(self.natom()):; if i != j:; temp = distance(self.xyz(i), self.xyz(j)) ** 3.0; Zi = self.Z(i); Zj = self.Z(j); entry[0] -= (self.x(i",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:49486,energy,energy,49486,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,1,['energy'],['energy']
Energy Efficiency,"oint. CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. dfmp2-3; DF-MP2 cc-pVDZ frozen core gradient of benzene, computed at the DF-SCF cc-pVDZ geometry. mcscf1; ROHF 6-31G** energy of the state of CH2, with Z-matrix input. The occupations are specified explicitly. ci-multi; BH single points, checking that program can run multiple instances of DETCI in a single input, without an intervening clean() call. sapt5; SAPT0 aug-cc-pVTZ computation of the charge transfer energy of the water dimer. adc2; ADC/aug-cc-pVDZ on two water molecules that are distant from 1000 angstroms from each other. cc40; RHF-CC2-LR/cc-pVDZ optical rotation of H2O2. gauge = length, omega = (589 355 nm). dcft2; DCFT-06 calculation for the He dimer. This performs a two-step update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the MO Basis. cc32; CC3/cc-pVDZ H2O geom from Olsen et al., JCP 104, 8007 (1996). tu1-h2o-energy; Sample HF/cc-pVDZ H2O computation. dcft4; DCFT calculation for the HF+ using DCFT-06 functional. This performs both two-step and simultaneous update of the orbitals and cumulant using DIIS extrapolation. Four-virtual integrals are first handled in the MO Basis for the first two energy computations. In the next two the ao_basis=disk algorithm is used, where the transformation of integrals for four-virtual case is avoided. pywrap-db3; Test that Python Molecule class processes geometry like PsiMod Molecule class. fci-h2o; 6-31G H2O Test FCI Energy Point. psimrcc-pt2; Mk-MRPT2 single point. F2 state described using the Ms = 0 component of the singlet. Uses TCSCF singlet orbitals. cc46; EOM-CC2/cc-pVDZ on H2O2 with two excited states in each irrep. mints4; A demonstration of mixed Cartesian/ZMatrix geometry specification, using variables, for the benzene-hydronium complex. Atoms can be placed using ZMatrix coordinates, whether they belong to the same fragment or not. Note that the Cartesian specific",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_testsuite-1.html:1779,energy,energy,1779,psi4manual/4.0b3/autodoc_testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_testsuite-1.html,4,['energy'],['energy']
Energy Efficiency,"oint. cc17; Single point energies of multiple excited states with EOM-CCSD. tu3-h2o-opt; Optimize H2O HF/cc-pVDZ. mrcc2; CCSDT(Q) cc-pVDZ energy for the H2O molecule using MRCC. This example builds up from CCSD. First CCSD, then CCSDT, finally CCSDT(Q). cc21; ROHF-EOM-CCSD/DZ analytic gradient lowest excited state of H2O+ (B1 excitation). opt4; SCF cc-pVTZ geometry optimzation, with Z-matrix input. cc13a; UHF-CCSD(T)/cc-pVDZ CH2 geometry optimization via analytic gradients. mpn-bh; MP(n)/aug-cc-pVDZ BH Energy Point, with n=2-19. Compare against M. L. Leininger et al., J. Chem. Phys. 112, 9213 (2000). pywrap-checkrun-uhf; This checks that all energy methods can run with a minimal input and set symmetry. omp2_5-grad2; OMP2.5 cc-pVDZ gradient for the NO radical. cc38; RHF-CC2-LR/cc-pVDZ static polarizabilities of HOF molecule. mrcc3; CCSD(T) cc-pVDZ geometry optimization for the H2O molecule using MRCC. opt3; SCF cc-pVDZ geometry optimzation, with Z-matrix input. omp2_5-2; OMP2 cc-pVDZ energy for the H2O molecule. cc3; cc3: RHF-CCSD/6-31G** H2O geometry optimization and vibrational frequency analysis by finite-differences of gradients. scf-bz2; Benzene Dimer Out-of-Core HF/cc-pVDZ. cc51; EOM-CC3/cc-pVTZ on H2O. fci-h2o-2; 6-31G H2O Test FCI Energy Point. mp2-grad2; MP2 cc-pVDZ gradient for the NO radical. cc31; CCSD/sto-3g optical rotation calculation (both gauges) at two frequencies on methyloxirane. psimrcc-ccsd_t-1; Mk-MRCCSD(T) single point. CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. cc11; Frozen-core CCSD(ROHF)/cc-pVDZ on CN radical with disk-based AO algorithm. pywrap-checkrun-rhf; This checks that all energy methods can run with a minimal input and set symmetry. fd-freq-energy-large; SCF DZ finite difference frequencies by energies for C4NH4. cc33; CC3(UHF)/cc-pVDZ H2O geom from Olsen et al., JCP 104, 8007 (1996). dft-grad; DF-BP86-D2 cc-pVDZ frozen core gradient of S22 HCN. tu6-cp-ne2; Example potential energy surf",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodoc_testsuite-1.html:16406,energy,energy,16406,psi4manual/4.0b4/autodoc_testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodoc_testsuite-1.html,4,['energy'],['energy']
Energy Efficiency,"oints, for a given irrep. fd_geoms_freq_1((arg0: psi::Molecule, ...); Gets list of displacements needed fof a finite difference frequency computation, from gradients, for a given irrep. finalize(() -> None). fisapt((arg0: psi::Wavefunction) -> float); Runs the functional-group intramolecular symmetry adapted perturbation theory code. flush_outfile(() -> None); Flushes the output file. fnocc(...); Runs the fno-ccsd(t)/qcisd(t)/mp4/cepa energy code. get_active_efp(() -> psi4.core.EFP); Returns the currently active EFP object. get_active_molecule(() -> psi::Molecule); Returns the currently active molecule object. get_array_variable((arg0: str) -> psi::Matrix); Returns one of the PSI variables set internally by the modules or python driver (see manual for full listing of variables available). get_array_variables(() -> Dict[str, psi::Matrix]); Returns dictionary of the PSI variables set internally by the modules or python driver. get_atomic_point_charges(() -> psi::Vector); Returns the most recently computed atomic point charges, as a double * object. get_efp_torque(() -> psi::Matrix); Returns the most recently computed gradient for the EFP portion, as a Nefp by 6 Matrix object. get_environment((arg0: str) -> str); Get enviromental vairable. get_frequencies(() -> psi::Vector); Returns the most recently computed frequencies, as a 3N-6 Vector object. get_global_option((arg0: str) -> object); Given a string of a keyword name arg1, returns the value associated with the keyword from the global options. get_global_option_list(() -> List[str]); Returns a list of all global options. get_gradient(() -> psi::Matrix); Returns the most recently computed gradient, as a N by 3 Matrix object. get_legacy_molecule(() -> psi::Molecule); Returns the currently active molecule object. get_local_option((arg0: str, ...); Given a string of a keyword name arg2 and a particular module arg1, returns the value associated with the keyword in the module options scope. get_memory(() -> int); Returns t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psi4api-1.html:165385,charge,charges,165385,psi4manual/1.1.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psi4api-1.html,2,['charge'],['charges']
Energy Efficiency,"ol (option #16) in fort.56. Type: conv double; Default: 1e-6. E_CONVERGENCE (OCC); OCC — Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. E_CONVERGENCE (PSIMRCC); PSIMRCC — Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. E_CONVERGENCE (SAPT); SAPT — Convergence criterion for energy (change) in the SAPT \(E_{ind,resp}^{(20)}\) term during solution of the CPHF equations. Type: conv double; Default: 1e-10. E_CONVERGENCE (SCF); SCF — Convergence criterion for SCF energy. See Table SCF Convergence & Algorithm for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. EA_POLES (OCC); OCC — Do compute OCC poles for electron affinities? Only valid for OMP2. Type: boolean; Default: false. EFP_DISP (EFP); EFP — Do include dispersion energy term in EFP computation?. Type: boolean; Default: true. EFP_DISP_DAMPING (EFP); EFP — Fragment-fragment dispersion damping type. TT is a damping formula by Tang and Toennies. OVERLAP is overlap-based dispersion damping. Type: string; Possible Values: TT, OVERLAP, OFF; Default: OVERLAP. EFP_ELST (EFP); EFP — Do include electrostatics energy term in EFP computation?. Type: boolean; Default: true. EFP_ELST_DAMPING (EFP); EFP — Fragment-fragment electrostatic damping type. SCREEN is a damping formula based on screen group in the EFP potential. OVERLAP is damping that computes charge penetration energy. Type: string; Possible Values: SCREEN, OVERLAP, OFF; Default: SCREEN. EFP_EXCH (EFP); EFP — Do include exchange repulsion energy term in EFP computation?. Type: boolean; Default: true. EFP_IND (EFP); EFP — Do include polarization energy term in EFP computation? (EFP_POL c. v1.1). Type: boolean; Default: true. EFP_IND_DAMPING (EFP); EFP — Fragment-fragment polarization damping ty",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html:117951,energy,energy,117951,psi4manual/1.2.1/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html,4,['energy'],['energy']
Energy Efficiency,"ol (option #16) in fort.56. Type: conv double; Default: 1e-6. E_CONVERGENCE (OCC); OCC — Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. E_CONVERGENCE (PSIMRCC); PSIMRCC — Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. E_CONVERGENCE (SAPT); SAPT — Convergence criterion for energy (change) in the SAPT \(E_{ind,resp}^{(20)}\) term during solution of the CPHF equations. Type: conv double; Default: 1e-10. E_CONVERGENCE (SCF); SCF — Convergence criterion for SCF energy. See Table SCF Convergence & Algorithm for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. EA_POLES (OCC); OCC — Do compute OCC poles for electron affinities? Only valid for OMP2. Type: boolean; Default: false. EFP_DISP (EFP); EFP — Do include dispersion energy term in EFP computation?. Type: boolean; Default: true. EFP_DISP_DAMPING (EFP); EFP — Fragment-fragment dispersion damping type. TT is a damping formula by Tang and Toennies. OVERLAP is overlap-based dispersion damping. Type: string; Possible Values: TT, OVERLAP, OFF; Default: OVERLAP. EFP_ELST (EFP); EFP — Do include electrostatics energy term in EFP computation?. Type: boolean; Default: true. EFP_ELST_DAMPING (EFP); EFP — Fragment-fragment electrostatic damping type. SCREEN is a damping formula based on screen group in the EFP potential. OVERLAP is damping that computes charge penetration energy. Type: string; Possible Values: SCREEN, OVERLAP, OFF; Default: SCREEN. EFP_EXCH (EFP); EFP — Do include exchange repulsion energy term in EFP computation?. Type: boolean; Default: true. EFP_POL (EFP); EFP — Do include polarization energy term in EFP computation?. Type: boolean; Default: true. EFP_POL_DAMPING (EFP); EFP — Fragment-fragment polarization damping type. TT is a dampin",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodoc_glossary_options_c-1.html:116492,energy,energy,116492,psi4manual/1.1.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodoc_glossary_options_c-1.html,2,['energy'],['energy']
Energy Efficiency,"ol, mtd, der, opt). # #print self.method, self.molecule.nactive_fragments(); # if 'sapt' in self.method and self.molecule.nactive_fragments() != 2:; # raise FragmentCountError(""""""Requested molecule has %d, not 2, fragments."""""" % (self.molecule.nactive_fragments())); #; ## # memory in MB --> MW; ## self.memory = int(math.ceil(mem / 8.0)); ## # auxiliary basis sets; ## [self.unaugbasis, self.augbasis, self.auxbasis] = self.corresponding_aux_basis(). [docs] def format_infile_string(self):; """""". """"""; # Handle memory and comment; cmtcmd = """"""$comment\n%s\n$end\n\n"""""" % (self.molecule.tagline); memcmd, memkw = muster_memory(self.memory). # Handle molecule and basis set; molcmd, molkw = self.molecule.format_molecule_for_qchem(mixedbas=False); # TODO mixedbas=True once handling basis sets. # not translating basis at present; _bascmd, baskw = muster_basis(self.basis). # format global convergence directions; _cdscmd, cdskw = muster_cdsgroup_options(). # Handle calc type and quantum chemical method; mdccmd, mdckw = procedures['energy'][self.method](self.method, self.dertype). ## make options from imdb only user options (currently non-existent). set basis and castup from here.; # Handle driver vs input/default keyword reconciliation; userkw = self.options # p4util.prepare_options_for_modules(); userkw = options.reconcile_options2(userkw, memkw); userkw = options.reconcile_options2(userkw, molkw); userkw = options.reconcile_options2(userkw, baskw); #userkw = qcdb.options.reconcile_options(userkw, psikw); userkw = options.reconcile_options2(userkw, cdskw); userkw = options.reconcile_options2(userkw, mdckw). # Handle conversion of psi4 keyword structure into cfour format; optcmd = options.prepare_options_for_qchem(userkw). # Handle text to be passed untouched to psi4; litcmd = ''. # Assemble infile pieces; return cmtcmd + memcmd + molcmd + optcmd + mdccmd + litcmd. #'hf'; #'df-hf'; #'b3lyp'; #'blyp'; #'bp86'; #'fno-ccsd(t)'; #'df-ccsd(t)'; #'fno-df-ccsd(t)'; #'df-b97-d'; #'df-b97-d",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/qchem.html:9449,energy,energy,9449,psi4manual/1.0.0/_modules/qcdb/qchem.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/qchem.html,1,['energy'],['energy']
Energy Efficiency,"ol-1] of the requested method name; from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. db_name DATABASE ROOT-MEAN-SQUARE SIGNED DEVIATION¶; The rms deviation [kcal mol-1] of the requested method name; from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. DF-MP2 TOTAL ENERGY¶. DF-MP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the density-fitted MP2 level of theory. DFT FUNCTIONAL TOTAL ENERGY¶; The total electronic energy [H] for the underlying functional of the; requested DFT method, without any dispersion correction; the first four; terms in Eq. (3) or (1). Quantity; in Eqs. (3) and (1).; Unless the method includes a dispersion correction, this quantity is; equal to SCF TOTAL ENERGY. DFT TOTAL ENERGY¶; The total electronic energy [H] for the requested DFT method,; in Eq. (1). (1); Unless the method is a DFT double-hybrid, this quantity is equal to; SCF TOTAL ENERGY. If the method is neither a; double-hybrid, nor dispersion corrected, this quantity is equal to; DFT FUNCTIONAL TOTAL ENERGY. DFT XC ENERGY¶; The functional energy contribution [H] to the total SCF energy (DFT only).; Quantity in Eqs. (3) and (1). DISPERSION CORRECTION ENERGY¶; The dispersion correction [H] appended to an underlying functional; when a DFT-D method is requested. Quantity ; in Eqs. (3) and (1). DOUBLE-HYBRID CORRECTION ENERGY¶; The scaled MP2 correlation energy correction [H] appended to an; underlying functional when a DH-DFT method is requested.; Quantity in Eq. (1). FCI TOTAL ENERGY¶. FCI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the full configuration interaction level of theory. HF TOTAL ENERGY¶; The total electronic energy [H] for the Hartree–Fock method, without; any disper",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html:10507,energy,energy,10507,psi4manual/4.0b3/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html,2,['energy'],['energy']
Energy Efficiency,"ol0'); sup.set_description(' PBEsol0 SR-XC Functional (HJS Model)\n'); sup.set_x_omega(0.3); sup.set_x_alpha(0.25); return sup. [docs]def build_wblyp_superfunctional(name, npoints, deriv):. # Call this first; sup = PsiMod.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('wBLYP'); # Tab in, trailing newlines; sup.set_description(' BLYP SR-XC Functional (HJS Model)\n'); # Tab in, trailing newlines; sup.set_citation(' Henderson et. al., J. Chem. Phys., 128, 194105, 2008\n Weintraub, Henderson, and Scuseria, J. Chem. Theory. Comput., 5, 754 (2009)\n'). # Add member functionals; sup.add_x_functional(build_functional('wB88_X')); sup.add_c_functional(build_functional('LYP_C')). # Set GKS up after adding functionals; sup.set_x_omega(0.3); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_wb97_superfunctional(name, npoints, deriv):. # Call this first; sup = PsiMod.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('wB97'); # Tab in, trailing newlines; sup.set_description(' Parameterized LRC B97 GGA XC Functional\n'); # Tab in, trailing newlines; sup.set_citation(' J.-D. Chai and M. Head-Gordon, J. Chem. Phys., 128, 084106, 2008\n'). # Add member functionals; X = build_functional('wB97_X'); X.set_name('wB97_X'); X.set_alpha(1.0). X.set_parameter('B97_gamma', 0.004); X.set_parameter('B97_a0', 1.0); X.set_parameter('B97_a1', 1.13116E0); X.set_parameter('B97_a2', -2.74915E0); X.set_parameter('B97_a3', 1.20900E1); X.set_parameter('B97_a4', -5.71642E0). C = build_functional('B_C'); C.set_name('wB97_C'). C.set_parameter('B97_os_gamma', 0.006); C.set_parameter('B97_os_a0', 1.0); C.set_parameter('B97_os_a1', 3.99051E0); C.set_par",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/functional.html:44047,allocate,allocate,44047,psi4manual/4.0b2/_modules/functional.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/functional.html,6,['allocate'],['allocate']
Energy Efficiency,"ol\n"";; # print $handle ""eeexch=E1ex\n"";; # print $handle ""eeind=E2ind\n"";; # print $handle ""eeexind=E2exind\n"";; # print $handle ""eedisp=E2disp\n"";; # print $handle ""eeexdisp=E2exdisp\n\n"";; #; # ]; #'dft-sapt-pbe0ac': [; #; # if ( ($asyA eq '') || ($asyB eq '') ) {; # print ""ERROR: asymptotic correction not defined for one or more monomers in index $system.\n"";; # close(DIOUT);; # unlink(""$pathDIOUT"");; # }; #; # print $handle ""ca=2101.2; cb=2102.2\n\n"";; #; # $spin = $cgmp{MLPmol1} - 1;; # print $handle ""SET,CHARGE=$cgmp{CHGmol1}\nSET,SPIN=$spin\ndummy"";; # foreach $at (@monoBreal) { print $handle "",$at""; }; # print $handle ""\n{ks,pbe0; asymp,$asyA; save,\$ca}\n"";; # print $handle ""eehfa=energy; sapt; monomerA\n\n"";; #; # $spin = $cgmp{MLPmol2} - 1;; # print $handle ""SET,CHARGE=$cgmp{CHGmol2}\nSET,SPIN=$spin\ndummy"";; # foreach $at (@monoAreal) { print $handle "",$at""; }; # print $handle ""\n{ks,pbe0; asymp,$asyB; save,\$cb}\n"";; # print $handle ""eehfb=energy; sapt; monomerB\n\n"";; #; # $spin = $cgmp{MLPsyst} - 1;; # print $handle ""SET,CHARGE=$cgmp{CHGsyst}\nSET,SPIN=$spin\n"";; # print $handle ""{sapt; intermol,ca=\$ca,cb=\$cb,icpks=0}\n"";; # print $handle ""eeelst=E1pol\n"";; # print $handle ""eeexch=E1ex\n"";; # print $handle ""eeind=E2ind\n"";; # print $handle ""eeexind=E2exind\n"";; # print $handle ""eedisp=E2disp\n"";; # print $handle ""eeexdisp=E2exdisp\n\n"";; # ]; #'dft-sapt-pbe0acalda': [; #; # if ( ($asyA eq '') || ($asyB eq '') ) {; # print ""ERROR: asymptotic correction not defined for one or more monomers in index $system.\n"";; # close(DIOUT);; # unlink(""$pathDIOUT"");; # }; #; # print $handle ""ca=2101.2; cb=2102.2\n\n"";; #; # $spin = $cgmp{MLPmol1} - 1;; # print $handle ""SET,CHARGE=$cgmp{CHGmol1}\nSET,SPIN=$spin\ndummy"";; # foreach $at (@monoBreal) { print $handle "",$at""; }; # print $handle ""\n{ks,pbe0; asymp,$asyA; save,\$ca}\n"";; # print $handle ""eehfa=energy; sapt; monomerA\n\n"";; #; # $spin = $cgmp{MLPmol2} - 1;; # print $handle ""SET,CHARGE=$cgmp{CHGmol2}\nSET,SP",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro.html:10281,energy,energy,10281,psi4manual/1.0.0/_modules/qcdb/molpro.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro.html,2,['energy'],['energy']
Energy Efficiency,"ole array [e a0^2] for the requested configuration interaction level of theory, (3, 3). CI ROOT n -> ROOT m DIPOLE¶; Transition dipole array [e a0] between roots n and m for the requested configuration interaction level of theory, (3,). CI ROOT n -> ROOT m QUADRUPOLE¶; Redundant transition quadrupole array [e a0^2] between roots n and m for the requested configuration interaction level of theory, (3, 3). CI ROOT n DIPOLE¶; Dipole array [e a0] for the requested configuration interaction level of theory and root n, (3,). CI ROOT n QUADRUPOLE¶; Redundant quadrupole array [e a0^2] for the requested configuration interaction level of theory and root n, (3, 3). CI ROOT n TOTAL ENERGY¶. CI ROOT n CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the requested configuration interaction level of theory and root; n (numbering starts at 0). CI STATE-AVERAGED TOTAL ENERGY¶. CI STATE-AVERAGED CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for state-averaged CI/CASSCF levels of theory. CI TOTAL ENERGY¶. CI CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the requested configuration interaction level of theory and root. CISD DIPOLE¶; Dipole array [e a0] for the configuration interaction singles and doubles level of theory, (3,). CISD QUADRUPOLE¶; Redundant quadrupole array [e a0^2] for the configuration interaction singles and doubles level of theory, (3, 3). CISD TOTAL ENERGY¶. CISD CORRELATION ENERGY¶. CISDT TOTAL ENERGY¶. CISDT CORRELATION ENERGY¶. CISDTQ CORRELATION ENERGY¶. CISDTQ TOTAL ENERGY¶. CIn CORRELATION ENERGY¶. CIn TOTAL ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the labeled configuration interaction level of theory and root.; n is CI order for n > 4. CP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [Eh] considering only two-body interactions,; computed with counterpoise c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/glossary_psivariables.html:22119,energy,energy,22119,psi4manual/1.6.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/glossary_psivariables.html,2,['energy'],['energy']
Energy Efficiency,"ole moment computation, performed by applying a finite electric field and numerical differentiation. cc42; RHF-CC2-LR/STO-3G optical rotation of (S)-methyloxirane. gauge = length, omega = (589 355 nm). fci-dipole; 6-31G H2O Test FCI Energy Point. tu4-h2o-freq; Frequencies for H2O HF/cc-pVDZ at optimized geometry. dcft3; DCFT-06 calculation for the He dimer. This performs a simultaneous update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the AO Basis, using integrals stored on disk. cc4a; RHF-CCSD(T) cc-pVQZ frozen-core energy of the BH molecule, with Cartesian input. This version tests the FROZEN_DOCC option explicitly. cisd-h2o+-1; 6-31G** H2O+ Test CISD Energy Point. dft-psivar; HF and DFT variants single-points on zmat methane, mostly to test that PSI variables are set and computed correctly. pywrap-alias; Test parsed and exotic calls to energy() like zapt4, mp2.5, and cisd are working. cc8b; ROHF-CCSD cc-pVDZ frozen-core energy for the state of the CN radical, with Cartesian input. mints3; Test individual integral objects for correctness. omp3-2; SCS-OMP3 cc-pVDZ geometry optimization for the H2O molecule. cc2; 6-31G** H2O CCSD optimization by energies, with Z-Matrix input. cc45; RHF-EOM-CC2/cc-pVDZ lowest two states of each symmetry of H2O. fci-tdm-2; BH-H2+ FCI/cc-pVDZ Transition Dipole Moment. psimrcc-ccsd_t-2; Mk-MRCCSD(T) single point. CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. sad1; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. psimrcc-fd-freq1; Mk-MRCCSD single point. O2 state described using the Ms = 0 component of the triplet. Uses ROHF triplet orbitals. rasci-h2o; RASCI/6-31G** H2O",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_testsuite-1.html:12488,energy,energy,12488,psi4manual/4.0b3/autodoc_testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_testsuite-1.html,4,['energy'],['energy']
Energy Efficiency,"ole_start != -1:; # Dipole x, y, z are the last items 6 lines down in the dipole block; dipole_str_list = lines[dipole_start + 6].split()[-3:]; # Convert the dipole to debye; dipole = [float(i)*psi_dipmom_au2debye for i in dipole_str_list]; psivar['CURRENT DIPOLE X'] = dipole[0]; psivar['CURRENT DIPOLE Y'] = dipole[1]; psivar['CURRENT DIPOLE Z'] = dipole[2]. # Dipole magnitude is 8 line down in the dipole block; magnitude = float(lines[dipole_start + 8][-1]). [docs]def harvest_mp2(lines, psivar):; """"""Harvest the MP2 results""""""; """"""Sample MP2 energy line (works for both MP2 and RI-MP2)""""""; #---------------------------------------; #MP2 TOTAL ENERGY: -76.226803665 Eh; #---------------------------------------. """"""Sample MP2 correlation energy line (yes there is a space)""""""; #-----------------------------------------------; # MP2 CORRELATION ENERGY : -0.125436532 Eh; #-----------------------------------------------. """"""Sample RI-MP2 Correlation energy line (yes there is a space)""""""; #-----------------------------------------------; # RI-MP2 CORRELATION ENERGY: -0.125496692 Eh; #-----------------------------------------------. for line in reversed(lines):; if line[:16] == 'MP2 TOTAL ENERGY':; psivar['MP2 TOTAL ENERGY'] = line.split()[-2]; break; for line in reversed(lines):; if line[:23] == ' MP2 CORRELATION ENERGY' or\; line[:26] == ' RI-MP2 CORRELATION ENERGY':; psivar['MP2 CORRELATION ENERGY'] = line.split()[-2]; break. [docs]def harvest_coupled_cluster(lines, psivar):; """"""Harvest coupled cluster results; WARNING: Canonical and DLPNO print the coupled cluster results differently; """"""; """"""Sample (canonical) CCSD results block""""""; #----------------------; #COUPLED CLUSTER ENERGY; #----------------------; #; #E(0) ... -76.063720080; #E(CORR) ... -0.288938791; #E(TOT) ... -76.352658871; #Singles Norm <S|S>**1/2 ... 0.021106262; #T1 diagnostic ... 0.007462191; #. """"""Sample DLPNO coupled cluster block (CCSD)""""""; #----------------------; #COUPLED CLUSTER ENERGY; #------------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/orca.html:7042,energy,energy,7042,psi4manual/1.0.0/_modules/qcdb/orca.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/orca.html,1,['energy'],['energy']
Energy Efficiency,"olean; Default: false. PSIMRCC¶. Do specific arrangements for PSIMRCC?. Type: boolean; Default: false. QRHF¶. Do form quasi RHF (QRHF) orbitals?. Type: boolean; Default: false. REFERENCE¶. Reference wavefunction type. Type: string; Default: RHF. REORDER¶. Do reorder MOs?. Type: boolean; Default: false. RESTRICTED_DOCC¶. An array giving the number of restricted doubly-occupied orbitals per irrep (not excited in CI wavefunctions, but orbitals can be optimized in MCSCF). Type: array; Default: No Default. RESTRICTED_UOCC¶. An array giving the number of restricted unoccupied orbitals per irrep (not occupied in CI wavefunctions, but orbitals can be optimized in MCSCF). Type: array; Default: No Default. SORTED_TEI_FILE¶. MO-basis sorted two-electron integrals file. Type: integer; Default: PSIF_MO_TEI. SO_S_FILE¶. SO basis overlap matrix file. Type: integer; Default: PSIF_OEI. SO_TEI_FILE¶. SO basis two-electron integrals file. Type: integer; Default: PSIF_SO_TEI. SO_T_FILE¶. SO basis kinetic energy matrix file. Type: integer; Default: PSIF_OEI. SO_V_FILE¶. SO basis potential energy matrix file. Type: integer; Default: PSIF_OEI. TPDM_ADD_REF¶. Do add reference contribution to TPDM?. Type: boolean; Default: false. TPDM_FILE¶. MO-basis two-particle density matrix file. Type: integer; Default: PSIF_MO_TPDM. Expert¶. RAS1¶. An array giving the number of orbitals per irrep for RAS1. Type: array; Default: No Default. RAS2¶. An array giving the number of orbitals per irrep for RAS2. Type: array; Default: No Default. RAS3¶. An array giving the number of orbitals per irrep for RAS3. Type: array; Default: No Default. RAS4¶. An array giving the number of orbitals per irrep for RAS4. Type: array; Default: No Default. WFN¶. Wavefunction type. Type: string; Default: CCSD. Table Of Contents. TRANSQT; General; AA_M_FILE; AB_M_FILE; AO_BASIS; BB_M_FILE; CHECK_C_ORTHONORM; DELETE_AO; DELETE_RESTR_DOCC; DELETE_TPDM; DO_ALL_TEI; FIRST_TMP_FILE; FZC_A_FILE; FZC_B_FILE; FZC_FILE; INTS_TOLERANCE; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodir_options_c/module__transqt-1.html:4823,energy,energy,4823,psi4manual/4.0b3/autodir_options_c/module__transqt-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/module__transqt-1.html,12,['energy'],['energy']
Energy Efficiency,"olean; Default: true. DO_MBPT_DISP (SAPT)¶SAPT (Expert) — Do MBPT dispersion correction in SAPT2+, SAPT2+(3) or SAPT2+3, if also doing CCD?. Type: boolean; Default: true. DO_SCS (DFOCC)¶DFOCC — Do perform spin-component-scaled OMP2 (SCS-OMP2)? In all computation, SCS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SCS-OMP2, one needs to set ‘DO_SCS’ to true. Type: boolean; Default: false. DO_SCS (OCC)¶OCC — Removed in 1.4. Will raise an error in 1.5. Pass the method name, like scs-mp2, to energy instead. Type: boolean; Default: false. DO_SOS (DFOCC)¶DFOCC — Do perform spin-opposite-scaled OMP2 (SOS-OMP2)? In all computation, SOS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SOS-OMP2, one needs to set ‘DO_SOS’ to true. Type: boolean; Default: false. DO_SOS (OCC)¶OCC — Removed in 1.4. Will raise an error in 1.5. Pass the method name, like scs-mp2, to energy instead. Type: boolean; Default: false. DO_THIRD_ORDER (SAPT)¶SAPT (Expert) — Do compute third-order corrections?. Type: boolean; Default: false. DOCC (GLOBALS)¶GLOBALS — An array containing the number of doubly-occupied orbitals per irrep (in Cotton order). Type: array; Default: No Default. DOCC (MCSCF)¶MCSCF — The number of doubly occupied orbitals, per irrep. Type: array; Default: No Default. DOI_BASIS_TOLERANCE (DLPNO)¶DLPNO (Expert) — Screening criteria for basis function values on DOI grids. Type: conv double; Default: 1.0e-10. DOI_PRUNING_SCHEME (DLPNO)¶DLPNO (Expert) — Pruning scheme for DOI grids. Type: string; Possible Values: ROBUST, TREUTLER, NONE, FLAT, P_GAUSSIAN, D_GAUSSIAN, P_SLATER, D_SLATER, LOG_GAUSSIAN, LOG_SLATER, NONE; Default: ROBUST. DOI_RADIAL_POINTS (DLPNO)¶DLPNO (Expert) — Number of radial points in DOI grid. Type: integer; Default: 25. DOI_SPHERICAL_POINTS (DLPNO)¶DLPNO (Expert) — Number of spherical points in DOI grid. Type: integer; Defa",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_glossary_options_c.html:121528,energy,energy,121528,psi4manual/master/autodoc_glossary_options_c.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_glossary_options_c.html,1,['energy'],['energy']
Energy Efficiency,"olean; Default: true. DO_MBPT_DISP (SAPT)¶SAPT (Expert) — Do MBPT dispersion correction in SAPT2+, SAPT2+(3) or SAPT2+3, if also doing CCD?. Type: boolean; Default: true. DO_SCS (DFOCC)¶DFOCC — Do perform spin-component-scaled OMP2 (SCS-OMP2)? In all computation, SCS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SCS-OMP2, one needs to set ‘DO_SCS’ to true. Type: boolean; Default: false. DO_SCS (OCC)¶OCC — Removed in 1.4. Will raise an error in 1.5. Pass the method name, like scs-mp2, to energy instead. Type: boolean; Default: false. DO_SOS (DFOCC)¶DFOCC — Do perform spin-opposite-scaled OMP2 (SOS-OMP2)? In all computation, SOS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SOS-OMP2, one needs to set ‘DO_SOS’ to true. Type: boolean; Default: false. DO_SOS (OCC)¶OCC — Removed in 1.4. Will raise an error in 1.5. Pass the method name, like scs-mp2, to energy instead. Type: boolean; Default: false. DO_THIRD_ORDER (SAPT)¶SAPT (Expert) — Do compute third-order corrections?. Type: boolean; Default: false. DOCC (GLOBALS)¶GLOBALS — An array containing the number of doubly-occupied orbitals per irrep (in Cotton order). Type: array; Default: No Default. DOCC (MCSCF)¶MCSCF — The number of doubly occupied orbitals, per irrep. Type: array; Default: No Default. DYNAMIC_LEVEL (OPTKING)¶OPTKING — Starting level for dynamic optimization (0=nondynamic, higher=>more conservative). Type: integer; Default: 0. E3_SCALE (DFOCC)¶DFOCC — CEPA opposite-spin scaling value from SCS-CCSD. Type: double; Default: 0.25. E3_SCALE (OCC)¶OCC — Scaling value for 3rd order energy correction (S. Grimme, Vol. 24, pp. 1529, J. Comput. Chem.). Type: double; Default: 0.25. E_CONVERGENCE (CCENERGY)¶CCENERGY — Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Defa",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodoc_glossary_options_c-1.html:115858,energy,energy,115858,psi4manual/1.5.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodoc_glossary_options_c-1.html,5,['energy'],['energy']
Energy Efficiency,"olecule and commands that are dependent on the database; commands = '\n'; commands += """"""\ncore.set_global_option('BASIS', '%s')\n"""""" % (mc['f_basis']); commands += """"""core.set_global_option('WRITER_FILE_LABEL', '%s')\n"""""" % \; (user_writer_file_label + ('' if user_writer_file_label == '' else '-') + mc['f_wfn'].lower() + '-' + mc['f_basis'].lower()); exec(commands). # Make energy(), etc. call; response = func(molecule=molecule, **kwargs); if ptype == 'energy':; mc['f_energy'] = response; elif ptype == 'gradient':; mc['f_gradient'] = response; mc['f_energy'] = core.get_variable('CURRENT ENERGY'); if verbose > 1:; mc['f_gradient'].print_out(); elif ptype == 'hessian':; mc['f_hessian'] = response; mc['f_energy'] = core.get_variable('CURRENT ENERGY'); if verbose > 1:; mc['f_hessian'].print_out(); Njobs += 1; if verbose > 1:; core.print_out(""\nCURRENT ENERGY: %14.16f\n"" % mc['f_energy']). # Fill in energies for subsumed methods; if ptype == 'energy':; for wfn in VARH[mc['f_wfn']]:; for job in JOBS_EXT:; if (wfn == job['f_wfn']) and (mc['f_basis'] == job['f_basis']):; job['f_energy'] = core.get_variable(VARH[wfn][wfn]). if verbose > 1:; core.print_variables(); core.clean_variables(); core.clean(). # Copy data from 'run' to 'obtained' table; for mce in JOBS_EXT:; if (mc['f_wfn'] == mce['f_wfn']) and (mc['f_basis'] == mce['f_basis']):; mce['f_energy'] = mc['f_energy']; mce['f_gradient'] = mc['f_gradient']; mce['f_hessian'] = mc['f_hessian']. psioh.set_specific_retention(constants.PSIF_SCF_MOS, False). # Build string of title banner; cbsbanners = ''; cbsbanners += """"""core.print_out('\\n')\n""""""; cbsbanners += """"""p4util.banner(' CBS Results: %s ' % label)\n""""""; cbsbanners += """"""core.print_out('\\n')\n\n""""""; exec(cbsbanners). # Insert obtained energies into the array that stores the cbs stages; for stage in GRAND_NEED:; for lvl in stage['d_need'].items():; MODELCHEM.append(lvl[1]). for job in JOBS_EXT:; # Dont ask; if (((lvl[1]['f_wfn'] == job['f_wfn']) or; ((lvl[1]['f_wfn'][3",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver_cbs.html:48114,energy,energy,48114,psi4manual/1.1.0/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver_cbs.html,2,['energy'],['energy']
Energy Efficiency,"olecule and commands that are dependent on the database; commands = '\n'; commands += """"""\npsi4.set_global_option('BASIS', '%s')\n"""""" % (mc['f_basis']); commands += """"""psi4.set_global_option('WRITER_FILE_LABEL', '%s')\n"""""" % \; (user_writer_file_label + ('' if user_writer_file_label == '' else '-') + mc['f_wfn'].lower() + '-' + mc['f_basis'].lower()); exec(commands). # Make energy(), etc. call; response = func(molecule=molecule, **kwargs); if ptype == 'energy':; mc['f_energy'] = response; elif ptype == 'gradient':; mc['f_gradient'] = response; mc['f_energy'] = psi4.get_variable('CURRENT ENERGY'); if verbose > 1:; mc['f_gradient'].print_out(); elif ptype == 'hessian':; mc['f_hessian'] = response; mc['f_energy'] = psi4.get_variable('CURRENT ENERGY'); if verbose > 1:; mc['f_hessian'].print_out(); Njobs += 1; if verbose > 1:; psi4.print_out(""\nCURRENT ENERGY: %14.16f\n"" % mc['f_energy']). # Fill in energies for subsumed methods; if ptype == 'energy':; for wfn in VARH[mc['f_wfn']]:; for job in JOBS_EXT:; if (wfn == job['f_wfn']) and (mc['f_basis'] == job['f_basis']):; job['f_energy'] = psi4.get_variable(VARH[wfn][wfn]). if verbose > 1:; psi4.print_variables(); psi4.clean_variables(); psi4.clean(). # Copy data from 'run' to 'obtained' table; for mce in JOBS_EXT:; if (mc['f_wfn'] == mce['f_wfn']) and (mc['f_basis'] == mce['f_basis']):; mce['f_energy'] = mc['f_energy']; mce['f_gradient'] = mc['f_gradient']; mce['f_hessian'] = mc['f_hessian']. psioh.set_specific_retention(p4const.PSIF_SCF_MOS, False). # Build string of title banner; cbsbanners = ''; cbsbanners += """"""psi4.print_out('\\n')\n""""""; cbsbanners += """"""p4util.banner(' CBS Results: %s ' % label)\n""""""; cbsbanners += """"""psi4.print_out('\\n')\n\n""""""; exec(cbsbanners). # Insert obtained energies into the array that stores the cbs stages; for stage in GRAND_NEED:; for lvl in stage['d_need'].items():; MODELCHEM.append(lvl[1]). for job in JOBS_EXT:; # Dont ask; if (((lvl[1]['f_wfn'] == job['f_wfn']) or; ((lvl[1]['f_wfn'][3:]",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:47759,energy,energy,47759,psi4manual/1.0.0/_modules/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html,1,['energy'],['energy']
Energy Efficiency,"olecule keyword:; molecule{; H; H 1 0.9; }. or. molecule{; H; H 1 r; r = 0.9; }. or. molecule{; H1; H2 H1 0.9; }. or. molecule{; H 0.0 0.0 0.0; H 0.0 0.0 0.9; }. or. molecule{; H 0.0 0.0 0.0; H 0.0 0.0 r; r = 0.9; }. or. molecule{; H 0.0 0.0 -r; H 0.0 0.0 r; r = 0.45; }. Blank lines are ignored and, unlike regular Python syntax, indentation within; the molecule block does not matter, although the molecule keyword itself must; be aligned within the input according to standard Python syntax. For more; examples of geometry specification, see the mints1 input file in the samples; folder. It is also possible to mix Cartesian and Z-matrix geometry; specifications, as demonstrated in the mints4 sample input file. Multiple Molecules¶; To facilitate more elaborate computations, it is possible to provide a name for; each molecule, and tell PSI4 which one should be used in a given; calculation. For example, consider the following input file:; molecule h2{; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; energy('scf'). molecule h{; H; }. set basis cc-pvdz; set reference uhf; energy('scf'). Here, two separate jobs are performed on two different molecules; the first is; performed on H2, while the second is for H atom. The last molecule to be; specified is the “active” molecule by default. To explicitly activate a named; molecule, the activate keyword is provided. Using this keyword, the above input; file can be equivalently written as follows:; molecule h2{; H; H 1 0.9; }. molecule h{; H; }. activate(h2); set basis cc-pvdz; set reference rhf; energy('scf'). activate(h); set basis cc-pvdz; set reference uhf; energy('scf'). Note that whenever the molecule is changed, the basis set must be specified; again. The following section provides more details about the job control; keywords used in the above examples. Molecule Keywords¶; In addition to specifying the geometry, additional information can be provided; in the molecule block. If two integers are encountered on any line of th",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html:4964,energy,energy,4964,psi4manual/4.0b2/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html,4,['energy'],['energy']
Energy Efficiency,"olecule mol {; He; --; He 1 3; }; # Calculate interaction energies only (skips monomers in monomer basis):; energy('CCSD(T)', bsse_type='cp'); # Calculate interaction and total energies, return interaction energies:; energy('CCSD(T)', bsse_type=['cp','nocp']); # Calculate and return counterpoise-corrected gradient; # Useful for e.g. CP-corrected geometry optimization; gradient('CCSD(T)', bsse_type='cp', return_total_data=True). # noCP, VMFC, and CP energy for a helium cluster, limited at 3 bodies; molecule mol {; He 0 0 0; --; He 0 0 4; --; He 0 4 0; --; He 4 0 0; }. # Returns the nocp energy as its first in the list; energy('CCSD(T)', bsse_type=['nocp', 'cp', 'vmfc'], max_nbody=3). class psi4.driver.driver_nbody.ManyBodyComputer(**data)[source]¶. Parameters. molecule (Any) – The target molecule, if not the last molecule defined.; basis (str, Default: (auto)) – ; method (str, Default: (auto)) – ; driver ({energy,gradient,hessian,properties}) – The computation driver; i.e., energy, gradient, hessian.; keywords (Dict[Any], Default: {}) – The computation keywords/options.; bsse_type ({nocp,cp,vmfc}, Default: [<BsseEnum.cp: 'cp'>]) – Requested BSSE treatments. First in list determines which interaction or total energy/gradient/Hessian returned.; nfragments (int, Default: -1) – Number of distinct fragments comprising full molecular supersystem.; max_nbody (int, Default: -1) – Maximum number of bodies to include in the many-body treatment. Possible: max_nbody <= nfragments. Default: max_nbody = nfragments.; nbodies_per_mc_level (List[List[Union[int, ]]], Default: []) – Distribution of active n-body levels among model chemistry levels. All bodies in range [1, self.max_nbody] must be present exactly once. Number of items in outer list is how many different modelchems. Each inner list specifies what n-bodies to be run at the corresponding modelchem (e.g., [[1, 2]] has max_nbody=2 and 1-body and 2-body contributions computed at the same level of theory; [[1], [2]] has max_nbo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/nbody.html:4015,energy,energy,4015,psi4manual/1.6.x/nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/nbody.html,1,['energy'],['energy']
Energy Efficiency,"olecule, ""EFP"") else pp.pformat(molecule.to_dict())); core.print_out(""""""hessian() will perform analytic frequency computation.\n""""""); wfn = procedures['hessian'][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return hessian(): {wfn.energy()}""); logger.info(nppp(wfn.hessian().np)). wfn.set_gradient(G0); basisstash.restore(); optstash.restore(); optstash_conv.restore(). #if isinstance(lowername, str) and lowername in procedures['energy']:; # # this correctly filters out cbs fn and ""hf/cc-pvtz""; # # it probably incorrectly filters out mp5, but reconsider in DDD; # core.set_variable(f""CURRENT HESSIAN"", H); # core.set_variable(f""{lowername.upper()} TOTAL HESSIAN"", H); # core.set_variable(f""{lowername.upper()} TOTAL GRADIENT"", G0); # wfn.set_variable(f""{lowername.upper()} TOTAL HESSIAN"", H); # wfn.set_variable(f""{lowername.upper()} TOTAL GRADIENT"", G0); # TODO: check that current energy's being set to the right figure when this code is actually used; core.set_variable('CURRENT ENERGY', wfn.energy()); core.set_variable(""CURRENT GRADIENT"", G0); driver_findif.hessian_write(wfn). if return_wfn:; return (wfn.hessian(), wfn); else:; return wfn.hessian(). [docs]; def frequency(name, **kwargs):; r""""""Function to compute harmonic vibrational frequencies. :aliases: frequencies(), freq(). :returns: *float* |w--w| Total electronic energy in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:82924,ENERGY,ENERGY,82924,psi4manual/1.8.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html,3,['ENERGY'],['ENERGY']
Energy Efficiency,"olecule, ""EFP"") else pp.pformat(molecule.to_dict())); core.print_out(""""""hessian() will perform analytic frequency computation.\n""""""); wfn = procedures['hessian'][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return hessian(): {wfn.energy()}""); logger.info(nppp(wfn.hessian().np)). wfn.set_gradient(G0); basisstash.restore(); optstash.restore(); optstash_conv.restore(). #if isinstance(lowername, str) and lowername in procedures['energy']:; # # this correctly filters out cbs fn and ""hf/cc-pvtz""; # # it probably incorrectly filters out mp5, but reconsider in DDD; # core.set_variable(f""CURRENT HESSIAN"", H); # core.set_variable(f""{lowername.upper()} TOTAL HESSIAN"", H); # core.set_variable(f""{lowername.upper()} TOTAL GRADIENT"", G0); # wfn.set_variable(f""{lowername.upper()} TOTAL HESSIAN"", H); # wfn.set_variable(f""{lowername.upper()} TOTAL GRADIENT"", G0); # TODO: check that current energy's being set to the right figure when this code is actually used; core.set_variable('CURRENT ENERGY', wfn.energy()); core.set_variable(""CURRENT GRADIENT"", G0); driver_findif.hessian_write(wfn). if return_wfn:; return (wfn.hessian(), wfn); else:; return wfn.hessian(). [docs]def frequency(name, **kwargs):; r""""""Function to compute harmonic vibrational frequencies. :aliases: frequencies(), freq(). :returns: *float* |w--w| Total electronic energy in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as th",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html:74950,ENERGY,ENERGY,74950,psi4manual/1.6.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html,2,['ENERGY'],['ENERGY']
Energy Efficiency,"olecule. dft-jk; DFT JK on-disk test. cbs-xtpl-opt; Various extrapolated optimization methods for the H2 molecule. ci-multi; BH single points, checking that program can run multiple instances of DETCI in a single input, without an intervening clean() call. fd-freq-gradient-large; SCF DZ finite difference frequencies by gradients for C4NH4. soscf-ref; Triple and Singlet Oxygen energy SOSCF, also tests non-symmetric density matrices. cisd-h2o+-0; 6-31G** H2O+ Test CISD Energy Point. sapt-dft-lrc; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. serial-wfn; A simple hf/cc-pvdz water calculation. The resulting wavefunction is written to a file, and then a new wavefunction is generated from that file. The member variables of both wavefunctions should be identical in value. psimrcc-ccsd_t-4; Mk-MRCCSD(T) single point. \(^1A_1\) O$_3` state described using the Ms = 0 component of the singlet. Uses TCSCF orbitals. casscf-semi; CASSCF/6-31G** energy point. Check energy with frozen core/virtual orbs. after semicanonicalization. mp2-grad1; MP2 cc-pVDZ gradient for the H2O molecule. omp3-grad2; OMP3 cc-pVDZ gradient for the NO radical. fsapt1; This test case shows an example of running and analyzing a standard F-SAPT0/jun-cc-pvdz procedure for phenol dimer from the S22 database. extern1; External potential calculation involving a TIP3P water and a QM water. Finite different test of the gradient is performed to validate forces. cisd-h2o+-2; 6-31G** H2O+ Test CISD Energy Point. sapt1; SAPT0 cc-pVDZ computation of the ethene-ethyne interaction energy, using the cc-pVDZ-JKFIT RI basis for SCF and cc-pVDZ-RI for SAPT. Monomer geometries are specified using Cartesian coordinates. scf-upcast-custom-basis; test scf castup with custom basis sets. cc52; CCSD Response for H2O2. decontract; RHF/cc-pvdz-decontract HCl single-point energy Testing the in line -decontract option for basis sets. nbody-multi-level; Multilevel computation of water trimer energy (geometry from J. ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html:3212,energy,energy,3212,psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"olecule. scf-level-shift-rohf; SCF level shift on an ROHF computation. cc19; CCSD/cc-pVDZ dipole polarizability at two frequencies. dforemp-grad2; density fitted OO-REMP/cc-pVDZ engrad single points for the H2O+ molecule. scf3; File retention, docc, socc, and bond distances specified explicitly. opt16; SCF 6-31G(d) optimization of TS for HCN to HNC Performs finite difference hessian calculation. Then optimizes using previous orbitals for scf guess, in subsequent calculations. The last two displacements of the hessian break the plane of symemtry, This test confirms that only the reference geometry, with the correct symmetry, writes orbitals to disk. SCF will fail (ValidationError) otherwise. nbo; Generation of NBO file. fnocc6; Test method/basis with disk_df. dfomp2p5-grad2; DF-OMP2.5 cc-pVDZ gradients for the H2O+ cation. dfccsdl1; DF-CCSDL cc-pVDZ energy for the H2O molecule. opt1-fd; SCF STO-3G geometry optimzation, with Z-matrix input, by finite-differences. tu1-h2o-energy; Sample HF/cc-pVDZ H2O computation. mp2-grad1; MP2 cc-pVDZ gradient for the H2O molecule. dfep2-1; Compute three IP and 2 EA’s for the PH3 molecule. dct-grad1; Various DCT analytic gradients for the O2 molecule with 6-31G basis set. remp-energy2; integral conventional unrestricted REMP/cc-pVDZ energies for the H2O+ molecule. results were independently verified against the initial wavels implementation. dft-vv10; He Dimer VV10 functional test. notes: DFT_VV10_B/C overwrites the NL_DISPERSION_PARAMETERS tuple updated ‘bench’ reference values for new BraggSlater radii. olccd-grad2; OLCCD cc-pVDZ gradient for the NO radical. decontract; RHF/cc-pvdz-decontract HCl single-point energy Testing the in line -decontract option for basis sets. cc14; ROHF-CCSD/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. scf2; RI-SCF cc-pVTZ energy of water, with Z-matrix input and cc-pVTZ-RI auxilliary basis. scf-guess-read2; Test if the the guess read in the same basis converges. isapt1; This test",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html:35298,energy,energy,35298,psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"olecule.mass(1). maxit = 30; thres = 1.0e-9; for i in range(maxit):; if (npoints == 5):; grad= first_deriv_5pt(rvals, energies, optx); secd = second_deriv_5pt(rvals, energies, optx); energy = function_5pt(rvals, energies, optx); elif (npoints == 9):; grad = first_deriv_9pt(rvals, energies, optx); secd = second_deriv_9pt(rvals, energies, optx); energy = function_9pt(rvals, energies, optx); psi4.print_out("" E = %20.14f, x = %14.7f, grad = %20.14f\n"" % (energy, optx, grad)); if abs(grad) < thres:; break; optx -= grad / secd;; psi4.print_out("" Final E = %20.14f, x = %14.7f, grad = %20.14f\n"" % (function_5pt(rvals, energies, optx), optx, grad));. if optx < min(rvals):; raise Exception(""Minimum energy point is outside range of points provided. Use a lower range of r values.""); if optx > max(rvals):; raise Exception(""Minimum energy point is outside range of points provided. Use a higher range of r values.""). if (npoints == 5):; energy = function_5pt(rvals, energies, optx); first = first_deriv_5pt(rvals, energies, optx); secd = second_deriv_5pt(rvals, energies, optx) * p4const.psi_hartree2aJ; third = third_deriv_5pt(rvals, energies, optx) * p4const.psi_hartree2aJ; fourth = fourth_deriv_5pt(rvals, energies, optx) * p4const.psi_hartree2aJ; elif (npoints == 9):; energy = function_9pt(rvals, energies, optx); first = first_deriv_9pt(rvals, energies, optx); secd = second_deriv_9pt(rvals, energies, optx) * p4const.psi_hartree2aJ; third = third_deriv_9pt(rvals, energies, optx) * p4const.psi_hartree2aJ; fourth = fourth_deriv_9pt(rvals, energies, optx) * p4const.psi_hartree2aJ. psi4.print_out(""\nEquilibrium Energy %20.14f Hartrees\n"" % energy); psi4.print_out(""Gradient %20.14f\n"" % first); psi4.print_out(""Quadratic Force Constant %14.7f MDYNE/A\n"" % secd); psi4.print_out(""Cubic Force Constant %14.7f MDYNE/A**2\n"" % third); psi4.print_out(""Quartic Force Constant %14.7f MDYNE/A**3\n"" % fourth). hbar = p4const.psi_h / (2.0 * pi); mu = ((m1*m2)/(m1+m2))*p4const.psi_amu2kg; we = 5.3088375",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/diatomic.html:3995,energy,energy,3995,psi4manual/1.0.0/_modules/diatomic.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/diatomic.html,1,['energy'],['energy']
Energy Efficiency,"olecule.natom(); if coords is None:; coords = MDI_Recv(3 * natom, MDI_DOUBLE, self.comm); matrix = psi4.core.Matrix.from_array(np.array(coords).reshape(-1, 3)); self.molecule.set_geometry(matrix). # Respond to the >MASSES command; def recv_masses(self, masses=None):; """""" Receive a set of nuclear masses through MDI and assign them to the atoms in the current molecule. Arguments:; masses: New nuclear masses. If None, receive through MDI.; """"""; natom = self.molecule.natom(); if masses is None:; masses = MDI_Recv(natom, MDI_DOUBLE, self.comm). # Assign the mass of all atoms, taking care to avoid ghost atoms; jatom = 0; for iatom in range(natom):; while self.molecule.fZ(jatom) == 0 and jatom < self.molecule.nallatom():; jatom = jatom + 1; if jatom >= self.molecule.nallatom():; raise Exception('Unexpected number of ghost atoms when receiving masses'); self.molecule.set_mass(iatom, masses[jatom]); jatom = jatom + 1. # Set a lattice of point charges; def set_lattice_field(self):; """""" Set a field of lattice point charges using information received through MDI; """"""; self.lattice_field = psi4.QMMM(); unit_conv = self.length_conversion(); for ilat in range(self.nlattice):; latx = self.clattice[3 * ilat + 0] * unit_conv; laty = self.clattice[3 * ilat + 1] * unit_conv; latz = self.clattice[3 * ilat + 2] * unit_conv; self.lattice_field.extern.addCharge(self.lattice[ilat], latx, laty, latz); psi4.core.set_global_option_python('EXTERN', self.lattice_field.extern); self.set_lattice = True. # Respond to the >NLATTICE command; def recv_nlattice(self, nlattice=None):; """""" Receive the number of lattice point charges through MDI. Arguments:; nlattice: New number of point charges. If None, receive through MDI.; """"""; if nlattice is None:; self.nlattice = MDI_Recv(1, MDI_INT, self.comm); else:; self.nlattice = nlattice; self.clattice = [0.0 for ilat in range(3 * self.nlattice)]; self.lattice = [0.0 for ilat in range(self.nlattice)]; self.set_lattice_field(). # Respond to the >CLATTICE comman",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html:8471,charge,charges,8471,psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html,8,['charge'],['charges']
Energy Efficiency,"olecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] Optical rotation calculation; >>> property('cc2', properties=['rotation']). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Make sure the molecule the user provided is the active one; if ('molecule' in kwargs):; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); PsiMod.set_global_option('BASIS', PsiMod.get_global_option('BASIS')). # Allow specification of methods to arbitrary order; lowername, level = parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. try:; return procedures['property'][lowername](lowername, **kwargs); except KeyError:; raise ValidationError('Property method %s not available.' % (lowername)). ## Aliases ##; prop = property. [docs]def optimize(name, **kwargs):; r""""""Function to perform a geometry optimization. :aliases: opt(). :returns: (*float*) Total electronic energy of optimized structure in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY <CURRENTENERGY>`. .. note:: Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. .. _`table:grad_gen`:. +-------------------------+---------------------------------------------------------------------------------------+; | name | calls method |; +=========================+=======================================================================================+; | scf | Hartree--Fock (HF) or density functional theory (DFT) |; +-------------------------+---------------------------------------------------------------------------------------+; | dcft | density cumulant functional theory |; +-------------------------+---------------------------------------------------------------------------------------+; | mp2 | 2nd-order Moller-Plesset perturbation theory (MP2) |; +----------------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/driver.html:32935,energy,energy,32935,psi4manual/4.0b2/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/driver.html,2,['energy'],['energy']
Energy Efficiency,"olecules. General Options¶. AVG_STATES¶. Array giving the root numbers of the states to average in a state-averaged procedure such as SA-CASSCF. Root numbering starts from 0. Type: array; Default: No Default. AVG_WEIGHTS¶. Array giving the weights for each state in a state-averaged procedure. Type: array; Default: No Default. A_RAS3_MAX¶. maximum number of alpha electrons in RAS III. Type: integer; Default: -1. B_RAS3_MAX¶. maximum number of beta electrons in RAS III. Type: integer; Default: -1. CALC_S_SQUARED¶. Do calculate the value of \(\langle S^2\rangle\) for each root? Only supported for ICORE = 1. Type: boolean; Default: false. CIBLKS_PRINT¶. Do print a summary of the CI blocks?. Type: boolean; Default: false. CI_MAXITER¶. Maximum number of iterations to diagonalize the Hamiltonian. Type: integer; Default: 24. DETCI_FREEZE_CORE¶. Do freeze core orbitals?. Type: boolean; Default: true. EX_LEVEL¶. The CI excitation level. Type: integer; Default: 2. E_CONVERGENCE¶. Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. FCI¶. Do a full CI (FCI)? If TRUE, overrides the value of EX_LEVEL. Type: boolean; Default: false. ICORE¶. Specifies how to handle buffering of CI vectors. A value of 0 makes the program perform I/O one RAS subblock at a time; 1 uses entire CI vectors at a time; and 2 uses one irrep block at a time. Values of 0 or 2 cause some inefficiency in the I/O (requiring multiple reads of the C vector when constructing H in the iterative subspace if DIAG_METHOD = SEM), but require less core memory. Type: integer; Default: 1. ISTOP¶. Do stop DETCI after string information is formed and before integrals are read?. Type: boolean; Default: false. MS0¶. Do use the \(M_s = 0\) component of the state? Defaults to TRUE if closed-shell and FALSE otherwise. Related to the S option. Type: boolean; Default: false. NUM_DETS_PRINT¶. Number of important determinan",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__detci-1.html:1495,energy,energy,1495,psi4manual/1.3.2/autodir_options_c/module__detci-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__detci-1.html,24,['energy'],['energy']
Energy Efficiency,"oles(self.findifrec, self.metameta['irrep']); self.findifrec[""reference""][""dipole derivative""] = DD0. H0 = assemble_hessian_from_energies(self.findifrec, self.metameta['irrep']); self.findifrec[""reference""][self.driver.name] = H0. [docs]; def get_results(self, client: Optional[""qcportal.FractalClient""] = None) -> AtomicResult:; """"""Return results as FiniteDifference-flavored QCSchema."""""". instructions = ""\n"" + p4util.banner(f"" FiniteDifference Results"", strNotOutfile=True) + ""\n""; core.print_out(instructions). self._prepare_results(client=client) # assembled_results. # load QCVariables & properties; qcvars = self.task_list['reference'].get_results().extras['qcvars']; E0 = self.findifrec['reference']['energy']. properties = {; ""calcinfo_natom"": self.molecule.natom(),; ""nuclear_repulsion_energy"": self.molecule.nuclear_repulsion_energy(),; ""return_energy"": E0,; }. qcvars['FINDIF NUMBER'] = len(self.task_list); qcvars['NUCLEAR REPULSION ENERGY'] = self.molecule.nuclear_repulsion_energy(); qcvars['CURRENT ENERGY'] = E0. DD0 = self.findifrec['reference'].get('dipole derivative'); if DD0 is not None:; qcvars['CURRENT DIPOLE GRADIENT'] = DD0; qcvars[f""{self.method.upper()} DIPOLE GRADIENT""] = DD0. G0 = self.findifrec['reference'].get('gradient'); if G0 is not None:; qcvars['CURRENT GRADIENT'] = G0; qcvars[f""{self.method.upper()} TOTAL GRADIENT""] = G0; properties[""return_gradient""] = G0. H0 = self.findifrec['reference'].get('hessian'); if H0 is not None:; qcvars['CURRENT HESSIAN'] = H0; qcvars[f""{self.method.upper()} TOTAL HESSIAN""] = H0; properties[""return_hessian""] = H0. # if isinstance(lowername, str) and lowername in procedures['energy']:; # # this correctly filters out cbs fn and ""hf/cc-pvtz""; # # it probably incorrectly filters out mp5, but reconsider in DDD. findif_model = AtomicResult(; **{; 'driver': self.driver,; 'model': {; ""basis"": self.basis,; 'method': self.method,; },; 'molecule': self.molecule.to_schema(dtype=2),; 'properties': properties,; 'provenance': p4uti",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html:50897,ENERGY,ENERGY,50897,psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,3,['ENERGY'],['ENERGY']
Energy Efficiency,"ols import partial; from typing import Callable, Optional, Union; import logging. import numpy as np. from psi4 import core; from psi4.driver.p4util.exceptions import ValidationError; nppp = partial(np.array_str, max_line_width=120, precision=8, suppress_small=True) # when safe, ""from psi4.driver import nppp""; from psi4.driver.aliases import sherrill_gold_standard, allen_focal_point. logger = logging.getLogger(__name__). _zeta_val2sym = {k + 2: v for k, v in enumerate('dtq5678')}; Extrapolatable = Union[float, core.Matrix, core.Vector]. [docs]def xtpl_highest_1(functionname: str, zHI: int, valueHI: Extrapolatable, verbose: int = 1, **kwargs) -> Extrapolatable:; r""""""Scheme for total or correlation energies with a single basis or the highest; zeta-level among an array of bases. Used by :py:func:`~psi4.driver.cbs`. Parameters; ----------; functionname; Name of the CBS component (e.g., 'mp2') used in summary printing.; zHI; Zeta-level, only used for printing.; valueHI; Energy, gradient, or Hessian value at the basis set.; verbose; Controls volume of printing. Returns; -------; float or ~numpy.ndarray; Returns :math:`E_{total}^{\infty}` which is equal to valueHI.; Eponymous function applied to input zetas and values; type from `valueHI`. Notes; -----; .. math:: E_{total}^X = E_{total}^{\infty}. Examples; --------; >>> # [1] Fancy way to get HF/cc-pCVQZ; >>> psi4.energy('cbs', scf_wfn='hf', scf_basis='cc-pcvqz', scf_scheme='xtpl_highest_1'). """"""; if isinstance(valueHI, float):. if verbose:; # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += f""""""\n ==> {functionname.upper()} <==\n\n""""""; cbsscheme += f"""""" HI-zeta ({zHI}) Energy: {valueHI: 16.12f}\n"""""". core.print_out(cbsscheme); logger.debug(cbsscheme). return valueHI. elif isinstance(valueHI, np.ndarray):. if verbose > 2:; cbsscheme = f""""""\n ==> {functionname.upper()} <==\n\n""""""; cbsscheme += f"""""" HI-zeta ({zHI}) Data\n""""""; cbsscheme += nppp(valueHI); core.print_out(cbsscheme); logger.debug(cbsschem",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_cbs_helper.html:2126,Energy,Energy,2126,psi4manual/1.7.x/_modules/psi4/driver/driver_cbs_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_cbs_helper.html,1,['Energy'],['Energy']
Energy Efficiency,"olumn; indices. As the potential energy scan is performed, the results are stored; (line 22) and the final table is printed to the output file (line 24). The; table is converted from absolute energies to relative energies (in kcal mol-1); on line 26, before being printed again. The relative energies are reported with; respect to the lowest value in each column. More examples of how to control the; formatting of the tables can be found in the sample input files provided; see; Appendix Test Suite and Sample Inputs for a complete listing. Python Wrappers¶; The Python foundations of the PSI4 driver and Psithon syntax permit; many commonly performed post-processing procedures to be integrated into; the PSI4 suite.; As seen in the neon dimer example from the tutorial section,; the nbody() wrapper provides automatic computation of; counterpoise-corrected interaction energies between two molecules. For; example,; energy('mp2', bsse_type='cp'). will compute the counterpoise-corrected density-fitted MP2 interaction energy; between two molecules.; PSI4 also provides the cbs() wrapper,; which automatically computes a complete-basis-set extrapolation (and; automatically sets up the computations with different basis sets required to; do the extrapolation). For example,:; # all equivalent. energy('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). energy('mp2/cc-pv[dt]z'). will compute a 2-point Helgaker extrapolation of the correlation energy; using the cc-pVDZ and cc-pVTZ basis sets (with method MP2) and add this; extrapolated correlation energy to the Hartree–Fock energy in the; largest basis (cc-pVTZ). cbs() can; be configured behind-the-scenes with explicit arguments, as in the; first example, or the convenience syntax of the equivalent second; example can be used.; Another very useful and powerful feature of PSI4 is the ability; to compute results on entire databases of molecules at a time,; as provided by the database() wrapper. For example,:; database('mp2',",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/psithoninput.html:13667,energy,energy,13667,psi4manual/1.6.x/psithoninput.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psithoninput.html,1,['energy'],['energy']
Energy Efficiency,"olution. Because of this, in; practice level shifting is most useful in the initial phase of the; calculation to reduce the orbital error enough for DIIS to work; well. The level shift is controlled by the parameter; LEVEL_SHIFT, and it is turned off when the DIIS error is; smaller than LEVEL_SHIFT_CUTOFF. Reasonable values for; the shift and convergence threshold are 5.0 and 1e-2,; respectively. SOSCF [Off by Default]See Second-order Convergence. ERI Algorithms¶; The key difficulty in the SCF procedure is treatment of the four-index ERI; contributions to the Fock Matrix. A number of algorithms are available in; PSI4 for these terms. The algorithm is selected by the SCF_TYPE; keyword. Most consist of a single algorithm applied to; the construction of both the Coulomb and Exchange parts; of the Fock Matrix:. PK [Default]An out-of-core, presorted algorithm using exact ERIs. Quite fast for a; zero-error algorithm if enough memory is available. Integrals are; generated only once, and symmetry is utilized to reduce number of; integrals. OUT_OF_COREAn out-of-core, unsorted algorithm using exact ERIs. Overcomes the; memory bottleneck of the current PK algorithm. Integrals are generated; only once, and symmetry is utilized to reduce number of integrals. DIRECTA threaded, sieved, integral-direct algorithm, with full permutational; symmetry. This algorithm is brand new, but seems to be reasonably fast; up to 1500 basis functions, uses zero disk (if DF pre-iterations are; turned off), and can obtain significant; speedups with negligible error loss if INTS_TOLERANCE; is set to 1.0E-8 or so. DF [Default]A density-fitted algorithm designed for computations with thousands of; basis functions. This algorithm is highly optimized, and is threaded; with a mixture of parallel BLAS and OpenMP. Note that this algorithm; should use the -JKFIT series of auxiliary bases, not the -RI or; -MP2FIT bases. The default guess for auxiliary basis set should work; for most bases, otherwise the DF_BAS",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/scf.html:25890,reduce,reduce,25890,psi4manual/1.8.x/scf.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/scf.html,3,['reduce'],['reduce']
Energy Efficiency,"ol¶; Returns true if the alpha and beta densities are the same. same_a_b_orbs(self: psi4.core.Wavefunction) → bool¶; Returns true if the alpha and beta orbitals are the same. scalar_variable(self: psi4.core.Wavefunction, arg0: str) → float¶; Returns the requested (case-insensitive) double QC variable. scalar_variables(self: psi4.core.Wavefunction) → Dict[str, float]¶; Returns the dictionary of all double QC variables. set_array(key, val)¶. Deprecated since version 1.4: Use psi4.core.Wavefunction.set_variable() instead. set_array_variable(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.Matrix) → None¶; Sets the requested (case-insensitive) Matrix QC variable. Syncs with Wavefunction.gradient_ or hessian_ if CURRENT GRADIENT or HESSIAN. set_basisset(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.BasisSet) → None¶; Sets the requested auxiliary basis. set_energy(self: psi4.core.Wavefunction, arg0: float) → None¶; Sets the Wavefunction’s energy. Syncs with Wavefunction’s QC variable CURRENT ENERGY. set_external_potential(self: psi4.core.Wavefunction, arg0: psi4.core.ExternalPotential) → None¶; Sets the requested external potential. set_frequencies(val)¶. Deprecated since version 1.4. set_gradient(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunction’s gradient. Syncs with Wavefunction’s QC variable CURRENT GRADIENT. set_hessian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunction’s Hessian. Syncs with Wavefunction’s QC variable CURRENT HESSIAN. set_lagrangian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the orbital Lagrangian matrix. set_legacy_frequencies(self: psi4.core.Wavefunction, arg0: psi4.core.Vector) → None¶; Sets the frequencies of the Hessian. set_module(self: psi4.core.Wavefunction, module: str) → None¶; Sets name of the last/highest level of theory module (internal or external) touching the wavefunction. set_name(self: psi4.core.Wavefunction, arg0: str) →",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.wavefunction.html:20458,ENERGY,ENERGY,20458,psi4manual/1.4.0/api/psi4.core.wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.wavefunction.html,7,['ENERGY'],['ENERGY']
Energy Efficiency,"om 10.1063/1.3304922. mints-benchmark; run some BLAS benchmarks. density-screen-2; RKS Density Matrix based-Integral Screening Test for benzene. dfccsdt1; DF-CCSD(T) cc-pVDZ energy for the H2O molecule. scf-ecp; Water-Argon complex with ECP present; check of energies and forces. sapt-exch-ind30-inf; SAPT2+3 with S^inf exch-ind30 Geometries taken from the S66x10 database, the shortest-range point (R = 0.7 R_e). frac-sym; Fractional occupation with symmetry. dfccsd-t-grad1; DF-CCSD(T) cc-pVDZ gradients for the H2O molecule. cc41; RHF-CC2-LR/cc-pVDZ optical rotation of H2O2. gauge = both, omega = (589 355 nm). dct-grad2; RHF-ODC-12 analytic gradient computations for H2O use AO_BASIS=DISK and AO_BASIS=NONE, respectively. RHF-ODC-06 analytic gradient computations for H2O use AO_BASIS=DISK and AO_BASIS=NONE, respectively. opt-multi-dimer-c2h; Multi-fragment opt of C2h methane dimer with user-combined reference points. options1; check all variety of options parsing. dfccsd1; DF-CCSD cc-pVDZ energy for the H2O molecule. mbis-2; MBIS calculation on OH- (Expanded Arrays). scf-bz2; Benzene Dimer Out-of-Core HF/cc-pVDZ. fnocc3; Test FNO-QCISD(T) computation. dft-omega; Test omega is setable updated wb97x_20,wb97x_03 to account for new BraggSlater radii. cepa-module; routing check on lccd, lccsd, cepa(0). opt6; Various constrained energy minimizations of HOOH with cc-pvdz RHF Internal-coordinate constraints in internal-coordinate optimizations. dfomp2p5-1; DF-OMP2.5 cc-pVDZ energy for the H2O molecule. cc8a; ROHF-CCSD(T) cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Cartesian input. scf-dipder; Test SCF dipole derivatives against old Psi3 reference values. tu3-h2o-opt; Optimize H2O HF/cc-pVDZ. dft-dens-cut; LibXC density screening test. Tests empty, C-only, X-only and XC superfunctionals. ‘super_mix’ showcases how to use different screening values for X and C parts. SCF will fail or crash (nans) without screening!. aediis-2; EDIIS test case from",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html:22044,energy,energy,22044,psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"om 2. freeze_list = """"""; 2 xyz; """"""; set optking frozen_cartesian $freeze_list. To freeze only the y coordinates of atoms 2 and 3. freeze_list = """"""; 2 y; 3 y; """"""; set optking frozen_cartesian $freeze_list. To optimize toward a value of 0.95 Angstroms for the distance between; atoms 1 and 3, as well as that between 2 and 4. set optking {; ranged_distance = (""; 1 3 0.949 0.95; 2 4 0.949 0.95; ""); }. Note; The effect of the frozen and ranged keywords is generally independent of; how the geometry of the molecule was input (whether Z-matrix or Cartesian, etc.)..; At this time; however, enforcing Cartesian constraints when using a zmatrix for; molecular input is not supported. Freezing or constraining Cartesian coordinates; requires Cartesian molecule input. If numerical errors results in symmetry; breaking, while Cartesian constraints are active, symmetrization cannot occur and; an error will be raised, prompting you to restart the job. To scan the potential energy surface by optimizing at several fixed values; of the dihedral angle of HOOH. molecule hooh {; 0 1; H 0.850718 0.772960 0.563468; O 0.120432 0.684669 -0.035503; O -0.120432 -0.684669 -0.035503; H -0.850718 -0.772960 0.563468; }. set {; basis cc-pvdz; intrafrag_step_limit 0.1; }. lower_bound = [99.99, 109.99, 119.99, 129.99, 149.99]; upper_bound = [100, 110, 120, 130, 140, 150]; PES = []. for lower, upper in zip(lower_bound, upper_bound):; my_string = f""1 2 3 4 {lower} {upper}""; set optking ranged_dihedral = $my_string; E = optimize('scf'); PES.append((upper, E)). print(""\n\tcc-pVDZ SCF energy as a function of phi\n""); for point in PES:; print(""\t%5.1f%20.10f"" % (point[0], point[1])). To scan the potential energy surface without the RANGED_DIHEDRAL keyword, a zmatrix; can be used. Warning; Rotating dihedrals in large increments without allowing the molecule to relax; in between increments can lead to unphysical geometries with overlapping functional groups in larger molecules,; which may prevent successful con",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/optking.html:6981,energy,energy,6981,psi4manual/1.7.x/optking.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/optking.html,3,['energy'],['energy']
Energy Efficiency,"om energy points, for a given irrep.; ; fd_freq_1(...); fd_freq_1( (list)arg1, (int)arg2) -> PsiReturnType :; Performs a finite difference frequency computation, from gradients, for a given irrep.; ; fd_geoms_1_0(...); fd_geoms_1_0() -> matrix_vector :; Gets the list of displacements needed for a finite difference gradient computation, from energy points.; ; fd_geoms_freq_0(...); fd_geoms_freq_0( (int)arg1) -> matrix_vector :; Gets the list of displacements needed for a finite difference frequency computation, from energy points, for a given irrep.; ; fd_geoms_freq_1(...); fd_geoms_freq_1( (int)arg1) -> matrix_vector :; Gets the list of displacements needed fof a finite difference frequency computation, from gradients, for a given irrep; ; fd_geoms_hessian_0(...); fd_geoms_hessian_0() -> matrix_vector :; Gets the list of displacements needed fof a finite difference frequency computation, from energy points.; ; fd_hessian_0(...); fd_hessian_0( (list)arg1) -> PsiReturnType :; Performs a finite difference frequency computation, from energy points.; ; flush_outfile(...); flush_outfile() -> None :; Flushes the output file.; ; fnocc(...); fnocc() -> float :; Runs the fno-ccsd(t)/qcisd(t)/mp4/cepa energy code; ; get_active_molecule(...); get_active_molecule() -> Molecule :; Returns the currently active molecule object.; ; get_frequencies(...); get_frequencies() -> Vector :; Returns the most recently computed frequencies, as a 3N-6 Vector object.; ; get_global_option(...); get_global_option( (str)arg1) -> object :; Given a string of a keyword name, returns the value associated with the keyword from the global options. Returns error if keyword is not recognized.; ; get_global_option_list(...); get_global_option_list() -> list :; Returns a list of all global options.; ; get_gradient(...); get_gradient() -> Matrix :; Returns the most recently computed gradient, as a N by 3 Matrix object.; ; get_input_directory(...); get_input_directory() -> str :; Returns the location of the i",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/psimod-1.html:157172,energy,energy,157172,psi4manual/4.0b5/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/psimod-1.html,2,['energy'],['energy']
Energy Efficiency,"om energy points, for a given irrep.; ; fd_freq_1(...); fd_freq_1( (list)arg1, (int)arg2) -> PsiReturnType :; Performs a finite difference frequency computation, from gradients, for a given irrep.; ; fd_geoms_1_0(...); fd_geoms_1_0() -> matrix_vector :; Gets the list of displacements needed for a finite difference gradient computation, from energy points.; ; fd_geoms_freq_0(...); fd_geoms_freq_0( (int)arg1) -> matrix_vector :; Gets the list of displacements needed for a finite difference frequency computation, from energy points, for a given irrep.; ; fd_geoms_freq_1(...); fd_geoms_freq_1( (int)arg1) -> matrix_vector :; Gets the list of displacements needed fof a finite difference frequency computation, from gradients, for a given irrep; ; fd_geoms_hessian_0(...); fd_geoms_hessian_0() -> matrix_vector :; Gets the list of displacements needed fof a finite difference frequency computation, from energy points.; ; fd_hessian_0(...); fd_hessian_0( (list)arg1) -> PsiReturnType :; Performs a finite difference frequency computation, from energy points.; ; flush_outfile(...); flush_outfile() -> None :; Flushes the output file.; ; fnocc(...); fnocc() -> float :; Runs the fno-ccsd(t)/qcisd(t)/mp4/cepa energy code; ; get_active_molecule(...); get_active_molecule() -> Molecule :; Returns the currently active molecule object.; ; get_global_option(...); get_global_option( (str)arg1) -> object :; Given a string of a keyword name, returns the value associated with the keyword from the global options. Returns error if keyword is not recognized.; ; get_global_option_list(...); get_global_option_list() -> list :; Returns a list of all global options.; ; get_gradient(...); get_gradient() -> Matrix :; Returns the most recently computed gradient, as a N by 3 Matrix object.; ; get_input_directory(...); get_input_directory() -> str :; Returns the location of the input file.; ; get_local_option(...); get_local_option( (str)arg1, (str)arg2) -> object :; Given a string of a keyword name and a ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/psimod-1.html:107419,energy,energy,107419,psi4manual/4.0b4/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html,2,['energy'],['energy']
Energy Efficiency,"om energy points, for a given irrep.; ; fd_freq_1(...); fd_freq_1( (list)arg1, (int)arg2) -> PsiReturnType :; Performs a finite difference frequency computation, from gradients, for a given irrep.; ; fd_geoms_1_0(...); fd_geoms_1_0() -> matrix_vector :; Gets the list of displacements needed for a finite difference gradient computation, from energy points.; ; fd_geoms_freq_0(...); fd_geoms_freq_0( (int)arg1) -> matrix_vector :; Gets the list of displacements needed for a finite difference frequency computation, from energy points, for a given irrep.; ; fd_geoms_freq_1(...); fd_geoms_freq_1( (int)arg1) -> matrix_vector :; Gets the list of displacements needed fof a finite difference frequency computation, from gradients, for a given irrep; ; fd_geoms_hessian_0(...); fd_geoms_hessian_0() -> matrix_vector :; Gets the list of displacements needed fof a finite difference frequency computation, from energy points.; ; fd_hessian_0(...); fd_hessian_0( (list)arg1) -> PsiReturnType :; Performs a finite difference frequency computation, from energy points.; ; flush_outfile(...); flush_outfile() -> None :; Flushes the output file.; ; get_active_molecule(...); get_active_molecule() -> Molecule :; Returns the currently active molecule object.; ; get_global_option(...); get_global_option( (str)arg1) -> object :; Given a string of a keyword name, returns the value associated with the keyword from the global options. Returns error if keyword is not recognized.; ; get_global_option_list(...); get_global_option_list() -> list :; Returns a list of all global options.; ; get_gradient(...); get_gradient() -> Matrix :; Returns the most recently computed gradient, as a N by 3 Matrix object.; ; get_input_directory(...); get_input_directory() -> str :; Returns the location of the input file.; ; get_local_option(...); get_local_option( (str)arg1, (str)arg2) -> object :; Given a string of a keyword name and a particular module, returns the value associated with the keyword in the module options",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/psimod-1.html:106959,energy,energy,106959,psi4manual/4.0b3/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html,2,['energy'],['energy']
Energy Efficiency,"om frac import *. molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; symmetry c1 # FRAC jobs must be run in C1 symmetry; }. set {; reference uks # UKS, as we need to do all kinds of weird stuff; basis aug-cc-pvdz # Augmented functions are very important on the anion side; scf_type df; dft_functional wb97; }. # Argument is the molecule object.; # Many optional arguments are available, see the python file; frac_traverse(h2o). The other macro is frac_nuke(), which strips several electrons out of the; system to gather information on the MSIE over a range of orbitals. The input is; identical to the above, except that the frac_traverse() call is substituted; for something like:; 1; 2; 3; 4; 5# Argument is the molecule object.; # A useful optional argument is nmax, the total number of electrons to; # strip out of the molecule, in this case, 2.; # Many optional arguments are available, see the python file; frac_nuke(h2o, nmax = 2). Note: this feature is new/powerful enough that we have several papers pending on; it, and are interested in expanding this work. If you would like to publish; results using this code, please contact Rob Parrish to make arrangements for; collaboration. Dispersion Corrections¶; Dispersion corrections are discussed here.; HF-3c and PBEh-3c dispersion and BSSE corrections are discussed here. Recommendations¶; The KS-DFT code is quite new, but relatively complete. During code development,; emphasis was placed on flexibility of functional technology, efficiency for; medium to large systems in difficult electronic environments (e.g., compact; spatial extents, diffuse basis sets, low band-gaps, LRC and/or hybrid GKS; functionals), and time to code completion. We are very interested in optimizing; and extending the code, so expect performance gains and extensions to; gradients/hessians and TDDFT in future releases.; Some rough guidelines for using the KS-DFT code are as follows,. Use DF for the ERI algorithm wherever possible.; PSI4 is a “tight” code, meani",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/dft-1.html:25318,power,powerful,25318,psi4manual/1.1.0/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/dft-1.html,2,['power'],['powerful']
Energy Efficiency,"om ground state to root n. DFT; functional labeled if canonical. TD-fctl ROOT 0 (IN h) -> ROOT n (IN i) RIGHT EIGENVECTOR BETA¶; The right beta spin eigenvectors of the named method; from ground state, which is in irrep h, to root n within irrep i. DFT; functional labeled if canonical. TD-fctl ROOT 0 (h) -> ROOT n (i) RIGHT EIGENVECTOR BETA¶; The right beta spin eigenvectors of the named method; from ground state, which is in irrep h, to root n, which is in irrep i. DFT; functional labeled if canonical. TD-fctl ROOT 0 -> ROOT n RIGHT EIGENVECTOR BETA - h TRANSITION¶; The right alpha and beta spin eigenvectors of the named method; from ground state to root n, and the transition is of irrep h. DFT; functional labeled if canonical. THERMAL ENERGY¶; Total thermal energy E [Eh] at given temperature. THERMAL ENERGY CORRECTION¶; Sum of electronic, translational, rotational, and vibrational corrections [Eh] to the thermal energy at given temperature. TWO-ELECTRON ENERGY¶; The two-electron energy contribution [Eh] to the total SCF energy.; Quantity \(E_{2e^-}\) in Eq. (4). UNCP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [Eh] considering only two-body interactions,; computed without counterpoise correction.; Related variable CP-CORRECTED 2-BODY INTERACTION ENERGY. \[E_{\text{IE}} = E_{dimer} - \sum_{monomer}^{n}{E_{monomer}^{\text{unCP}}}\]. WIBERG LOWDIN INDICES¶; Property of Wiberg bond indices using orthogonal Löwdin orbitals, (nat, nat). ZAPTn TOTAL ENERGY¶. ZAPTn CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the labeled Z-averaged perturbation theory level.; n is ZAPT perturbation order. ZERO K ENTHALPY¶; Total electronic and zero-point energy [Eh] at 0 [K]. ZPVE¶; Vibrational zero-point energy [Eh] at 0 [K]. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Appendices; PSI Variables by Alpha. © Copyright 2022, The Psi4 Project.; Last updated on Thursda",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/glossary_psivariables.html:60229,energy,energy,60229,psi4manual/1.6.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/glossary_psivariables.html,2,['energy'],['energy']
Energy Efficiency,"om results of a FNOCC; # MP3 calculation.; #; # .. math:: E_{total}^{\text{MP2.5}} = E_{total,\; \text{SCF}} \; + E_{corl,\; \text{MP2}} + E_{corl, \; \text{MP3}}; #; # :PSI variables:; #; # .. hlist::; # :columns: 1; #; # * :psivar:`MP2.5 TOTAL ENERGY <MP2.5TOTALENERGY>`; # * :psivar:`MP2.5 CORRELATION ENERGY <MP2.5CORRELATIONENERGY>`; #; # >>> energy('mp2.5'); #; # """"""; # lowername = name.lower(); # kwargs = kwargs_lower(kwargs); #; # # Run detci calculation and collect conventional quantities; # energy('mp3', **kwargs); # e_scf = psi4.get_variable('SCF TOTAL ENERGY'); # ce_mp2 = psi4.get_variable('MP2 CORRELATION ENERGY'); # ce_mp3 = psi4.get_variable('MP3 CORRELATION ENERGY'); # e_mp2 = e_scf + ce_mp2; # e_mp3 = e_scf + ce_mp3; #; # # Compute quantities particular to MP2.5; # ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); # e_mp25 = e_scf + ce_mp25; # psi4.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25); # psi4.set_variable('MP2.5 TOTAL ENERGY', e_mp25); # psi4.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); # psi4.set_variable('CURRENT ENERGY', e_mp25); #; # # build string of title banner and print results; # banners = ''; # banners += """"""psi4.print_out('\\n')\n""""""; # banners += """"""banner(' MP2.5 ')\n""""""; # banners += """"""psi4.print_out('\\n')\n\n""""""; # exec(banners); #; # tables = ''; # tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); # tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); # tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); # tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); # tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); # tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); # tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); # psi4.print_out(tables); #; # return e_mp25. # A direct translation of a plugin input file into a function call. Function calls are the only; # way to call plugins in sow/reap mode for db(), opt(), etc. This isn't best practices; # but is an example of what to do f",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/aliases.html:7416,ENERGY,ENERGY,7416,psi4manual/4.0b5/_modules/aliases.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/aliases.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"om root m to root n.; DFT functional labeled if canonical. CCname ROOT m (IN h) -> ROOT n (IN i) ROTATORY STRENGTH (LEN)¶. TD-fctl ROOT 0 (IN h) -> ROOT n (IN i) ROTATORY STRENGTH (LEN)¶; The length-gauge oscillator strength of the transition from root m within irrep h; to root n within irrep i.; DFT functional labeled if canonical. CCname ROOT m (h) -> ROOT n (i) ROTATORY STRENGTH (LEN)¶. TD-fctl ROOT 0 (h) -> ROOT n (i) ROTATORY STRENGTH (LEN)¶; The length-gauge oscillator strength of the transition from root m to root n,; which are in irreps h and i, respectively..; DFT functional labeled if canonical. CCname ROOT m -> ROOT n ROTATORY STRENGTH (LEN) - h TRANSITION¶. TD-fctl ROOT 0 -> ROOT n ROTATORY STRENGTH (LEN) - h TRANSITION¶; The length-gauge oscillator strength of the transition from root m to root n,; and the transition is of irrep h.; DFT functional labeled if canonical. CC TOTAL ENERGY¶. CC CORRELATION ENERGY¶. CC CORRELATION KINETIC ENERGY¶; The correlation correction to the kinetic energy [E_h], as computed by a coupled cluster method. CC CORRELATION POTENTIAL ENERGY¶; The correlation correction to the potential energy [E_h], as computed by a coupled cluster method. CC CORRELATION VIRIAL RATIO¶; The correlation virial ratio, as defined in https://doi/org/10.1063/1.1535440 for basis set completeness analysis. Computed using coupled cluster. CC VIRIAL RATIO¶; The virial ratio, as computed by a coupled cluster method. Only defined for a fully quantum mechanical computation, i.e., not QM/MM or solvated. CC T1 DIAGNOSTIC¶. CC D1 DIAGNOSTIC¶. CC NEW D1 DIAGNOSTIC¶. CC D2 DIAGNOSTIC¶; Diagnostic of multireference character. CC2 TOTAL ENERGY¶. CC2 CORRELATION ENERGY¶. CC3 TOTAL ENERGY¶. CC3 CORRELATION ENERGY¶. CC4 TOTAL ENERGY¶. CC4 CORRELATION ENERGY¶. CCnn TOTAL ENERGY¶. CCnn CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the requested approximate coupled-cluster (CC2, CC3, up to CCnn); level of theory. CC ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html:13915,energy,energy,13915,psi4manual/1.7.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html,4,['energy'],['energy']
Energy Efficiency,"om second line if available. Body; accepts atom symbol or atom charge in first column. Arguments; no_com and no_reorient can be used to turn off shift and; rotation. If xyzfilename is a string of the contents of an XYZ; file, rather than the name of a file, set contentsNotFilename; to True.; NOTE: chg/mult NYI; >>> H2O = qcdb.Molecule.init_with_mol2('h2o.mol2'). classmethod init_with_xyz(xyzfilename, no_com=False, no_reorient=False, contentsNotFilename=False)[source]¶; Pull information from an XYZ file. No fragment info detected.; Bohr/Angstrom pulled from first line if available. Charge,; multiplicity, tagline pulled from second line if available. Body; accepts atom symbol or atom charge in first column. Arguments; no_com and no_reorient can be used to turn off shift and; rotation. If xyzfilename is a string of the contents of an XYZ; file, rather than the name of a file, set contentsNotFilename; to True.; >>> H2O = qcdb.Molecule.init_with_xyz('h2o.xyz'). move_to_coc()[source]¶; Moves molecule to center of charge. print_ring_planes(entity1, entity2, entity3=None, entity4=None)[source]¶; (reals only, 1-indexed). rotor_type(tol=1e-08)[source]¶; Returns the rotor type.; >>> H2OH2O.rotor_type(); RT_ASYMMETRIC_TOP. run_dftd3(func=None, dashlvl=None, dashparam=None, dertype=None, verbose=False)¶; Function to call Grimme’s dftd3 program (http://toc.uni-muenster.de/DFTD3/); to compute the -D correction of level dashlvl using parameters for; the functional func. The dictionary dashparam can be used to supply; a full set of dispersion parameters in the absense of func or to supply; individual overrides in the presence of func. Returns energy if dertype is 0,; gradient if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The dftd3 executable must be independently compiled and found in; PATH or PSIPATH.; self may be either a qcdb.Molecule (sensibly) or a psi4.Molecule; (works b/c psi4.Molecule has been extended by this method py-side and; only public int",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html:22959,charge,charge,22959,psi4manual/1.0.0/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html,2,['charge'],['charge']
Energy Efficiency,"om-*mp for occ --- not yet tested or mirrored in dfocc. .. include:: /autodoc_dft_energy.rst. .. include:: /mrcc_table_energy.rst. .. include:: /cfour_table_energy.rst. :examples:. >>> # [1] Coupled-cluster singles and doubles calculation with psi code; >>> energy('ccsd'). >>> # [2] Charge-transfer SAPT calculation with scf projection from small into; >>> # requested basis, with specified projection fitting basis; >>> set basis_guess true; >>> set df_basis_guess jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). >>> # [3] Arbitrary-order MPn calculation; >>> energy('mp7'). >>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> # Note that the integral transformation is not done automatically when detci is run in a separate step.; >>> molecule H2 {\n0 1\nH\nH 1 0.74\n}; >>> set basis cc-pVDZ; >>> set reference rohf; >>> scf_e, scf_wfn = energy('scf', return_wfn=True); >>> H2.set_multiplicity(3); >>> core.MintsHelper(scf_wfn.basisset()).integrals(); >>> energy('detci', ref_wfn=scf_wfn). >>> # [5] Run two CI calculations, keeping the integrals generated in the first one.; >>> molecule ne {\nNe\n}; >>> set basis cc-pVDZ; >>> cisd_e, cisd_wfn = energy('cisd', return_wfn=True); >>> energy('fci', ref_wfn=cisd_wfn). >>> # [6] Can automatically perform complete basis set extrapolations; >>> energy(""CCSD/cc-pV[DT]Z""). >>> # [7] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> energy(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). """"""; kwargs = p4util.kwargs_lower(kwargs). # Bounce to MDI (MolSSI driver interface) if mdi kwarg; use_mdi = kwargs.pop('mdi', False); if use_mdi:; return mdi_run(name, **kwargs). core.print_out(""\nScratch directory: %s\n"" % core.IOManager.shared_object().get_default_path()). basisstash = p4util.OptionsState(['BASIS']); return_wfn = kwargs.po",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html:35923,energy,energy,35923,psi4manual/1.7.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html,8,['energy'],['energy']
Energy Efficiency,"om-ccsd':; core.set_local_option('CCLAMBDA', 'WFN', 'EOM_CCSD'); core.set_local_option('CCDENSITY', 'WFN', 'EOM_CCSD'); ref_wfn = run_eom_cc(name, **kwargs); else:; core.print_out('DGAS: proc.py:1599 hitting an undefined sequence'); core.clean(); raise ValueError('Hit a wall in proc.py:1599'). core.set_local_option('CCLAMBDA', 'ZETA', 'FALSE'); core.set_local_option('CCDENSITY', 'ZETA', 'FALSE'); core.set_local_option('CCDENSITY', 'XI', 'TRUE'); core.cclambda(ref_wfn); core.ccdensity(ref_wfn); core.set_local_option('CCLAMBDA', 'ZETA', 'TRUE'); core.set_local_option('CCDENSITY', 'ZETA', 'TRUE'); core.set_local_option('CCDENSITY', 'XI', 'FALSE'); core.cclambda(ref_wfn); core.ccdensity(ref_wfn). derivobj = core.Deriv(ref_wfn); grad = derivobj.compute(). ref_wfn.set_gradient(grad). optstash.restore(); return ref_wfn. def run_adc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an algebraic diagrammatic construction calculation. .. caution:: Get rid of active molecule lines- should be handled in energy. """"""; if core.get_option('ADC', 'REFERENCE') != 'RHF':; raise ValidationError('ADC requires reference RHF'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). return core.adc(ref_wfn). def run_detci(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a configuration interaction calculation, namely FCI,; CIn, MPn, and ZAPTn. """"""; optstash = p4util.OptionsState(; ['DETCI', 'WFN'],; ['DETCI', 'MAX_NUM_VECS'],; ['DETCI', 'MPN_ORDER_SAVE'],; ['DETCI', 'MPN'],; ['DETCI', 'FCI'],; ['DETCI', 'EX_LEVEL']). if core.get_option('DETCI', 'REFERENCE') not in ['RHF', 'ROHF']:; raise ValidationError('Reference %s for DETCI is not available.' %; core.get_option('DETCI', 'REFERENCE')). if name == 'zapt':; core.set_local_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html:88116,energy,energy,88116,psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,2,['energy'],['energy']
Energy Efficiency,"om-ccsd':; core.set_local_option('CCLAMBDA', 'WFN', 'EOM_CCSD'); core.set_local_option('CCDENSITY', 'WFN', 'EOM_CCSD'); ref_wfn = run_eom_cc(name, **kwargs); else:; core.print_out('DGAS: proc.py:1599 hitting an undefined sequence'); core.clean(); raise ValueError('Hit a wall in proc.py:1599'). core.set_local_option('CCLAMBDA', 'ZETA', 'FALSE'); core.set_local_option('CCDENSITY', 'ZETA', 'FALSE'); core.set_local_option('CCDENSITY', 'XI', 'TRUE'); core.cclambda(ref_wfn); core.ccdensity(ref_wfn); core.set_local_option('CCLAMBDA', 'ZETA', 'TRUE'); core.set_local_option('CCDENSITY', 'ZETA', 'TRUE'); core.set_local_option('CCDENSITY', 'XI', 'FALSE'); core.cclambda(ref_wfn); core.ccdensity(ref_wfn). derivobj = core.Deriv(ref_wfn); grad = derivobj.compute(). ref_wfn.set_gradient(grad). optstash.restore(); return ref_wfn. def run_adc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an algebraic diagrammatic construction calculation. .. caution:: Get rid of active molecule lines- should be handled in energy. """"""; if core.get_option('ADC', 'REFERENCE') != 'RHF':; raise ValidationError('ADC requires reference RHF'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_option('SCF', 'SCF_TYPE'), ref_wfn). return core.adc(ref_wfn). def run_dft(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-functional-theory calculation. """"""; optstash = p4util.OptionsState(; ['SCF', 'DFT_FUNCTIONAL'],; ['SCF', 'REFERENCE'],; ['SCF', 'SCF_TYPE'],; ['DF_BASIS_MP2'],; ['DFMP2', 'MP2_OS_SCALE'],; ['DFMP2', 'MP2_SS_SCALE']). # Alter default algorithm; if not core.has_option_changed('SCF', 'SCF_TYPE'):; core.set_local_option('SCF', 'SCF_TYPE', 'DF'). core.set_local_option('SCF', 'DFT_FUNCTIONAL', name). user_ref = core.get_option('SCF', 'REFERENCE'); if (use",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html:82356,energy,energy,82356,psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,1,['energy'],['energy']
Energy Efficiency,"om_lbl[at],; width=prewidth - 8,; presp=presp); for vib in row:; if vib is None:; break; text += (""""""{:^{width}.{prec}f}"""""" * 3).format(*(vibinfo[normco].data[:, vib].reshape(nat, 3)[at]),; width=int(width / 3),; prec=ncprec); text += """"""{:{colsp}}"""""".format('', colsp=colsp); text += '\n'; else:; for at in range(nat):; for xyz in range(3):; text += """"""{:{presp}}{:5d} {} {:{width}}"""""".format('',; at + 1,; 'XYZ' [xyz],; atom_lbl[at],; width=prewidth - 14,; presp=presp); for vib in row:; if vib is None:; break; text += """"""{:^{width}.{prec}f}"""""".format((vibinfo[normco].data[3 * at + xyz, vib]),; width=width,; prec=ncprec); text += """"""{:{colsp}}"""""".format('', colsp=colsp); text += '\n'. return text. def thermo(vibinfo, T: float, P: float, multiplicity: int, molecular_mass: float, E0: float, sigma: int, rot_const: np.ndarray, rotor_type: str = None) -> Tuple[Dict[str, Datum], str]:; """"""Perform thermochemical analysis from vibrational output. Parameters; ----------; E0; Electronic energy [Eh] at well bottom at 0 [K], :psivar:`CURRENT ENERGY`.; molecular_mass; Mass in [u] of molecule under analysis.; multiplicity; Spin multiplicity of molecule under analysis.; rot_const; (3,) rotational constants in [cm^-1] of molecule under analysis.; sigma; The rotational or external symmetry number determined from the point group.; rotor_type; The rotor type for rotational stat mech purposes: RT_ATOM, RT_LINEAR, other.; T; Temperature in [K]. Psi default 298.15. Note that 273.15 is IUPAC STP.; P; Pressure in [Pa]. Psi default 101325. Note that 100000 is IUPAC STP. Returns; -------; dict, str; First is every thermochemistry component in atomic units along with input conditions.; Second is formatted presentation of analysis. """"""; sm = collections.defaultdict(float). # conditions; therminfo = {}; therminfo['E0'] = Datum('E0', 'Eh', E0); therminfo['B'] = Datum('rotational constants', 'cm^-1', rot_const); therminfo['sigma'] = Datum('external symmetry number', '', sigma); therminfo['T'] = Datu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/qcdb/vib.html:30832,energy,energy,30832,psi4manual/1.6.x/_modules/qcdb/vib.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcdb/vib.html,15,"['ENERGY', 'energy']","['ENERGY', 'energy']"
Energy Efficiency,"ome awareness of the chemical; environment into an otherwise largely heuristic correction. The -D3; dispersion has the following form, where and ; are the customary nonunity parameters fitted for individual functionals. (2). A modified damping scheme for DFT-D3 using the rational damping form of; Becke and Johnson was introduced in [Grimme:2011:1456]. The parameters; fit for individual functionals are now , ,; , and . All parameters characterizing the dispersion correction are taken from; http://toc.uni-muenster.de/DFTD3/; or else from the literature. Running DFTD3¶; A number of a posteriori dispersion corrections are available in; PSI4. While most are computed within PSI4’s codebase (-D1, -D2,; -CHG, -DAS2009, -DAS2010), the -D3 correction and its variants are; available only through the DFTD3 program. Once installed, the; dftd3/PSI4 interface is transparent, and all corrections are; interfaced exactly alike.; Dispersion corrections are built into DFT functionals, so appending an a; posteriori correction to a computation is as simple as; energy('b2plyp-d') vs. energy('b2plyp'). For example, the; following input file computes (with much redundant work) for water a; B3LYP, a B3LYP-D2, and a B3LYP-D3 (zero-damping) energy.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('b3lyp'); energy('b3lyp-d'); energy('b3lyp-d3'). Consult the table -D Functionals to see for each; functional what corrections are available and what default parameters; define them. The dispersion correction is available after a calculation in; the PSI variable DISPERSION CORRECTION ENERGY.; By default, the output from the dftd3; program is suppressed; to see it in the output file, set print > 2. Variants of S. Grimme’s -D correction. Extension [1]; Variant and Computing Program; DFT_DISPERSION_PARAMETERS. -D; alias to -D2P4;  . -D1; -D1 [2] within PSI4;  . -D2; alias to -D2P4;  . -D2P4; -D2 [3] within PSI4; []. -D2GR; -D2 [3] through dftd3; [, ]. -D3; alias to -D3ZERO",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/dftd3.html:3800,energy,energy,3800,psi4manual/4.0b3/dftd3.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/dftd3.html,5,['energy'],['energy']
Energy Efficiency,"ome awareness of the chemical; environment into an otherwise largely heuristic correction. The -D3; dispersion has the following form, where and ; are the customary nonunity parameters fitted for individual functionals. (2). A modified damping scheme for DFT-D3 using the rational damping form of; Becke and Johnson was introduced in [Grimme:2011:1456]. The parameters; fit for individual functionals are now , ,; , and . All parameters characterizing the dispersion correction are taken from; http://toc.uni-muenster.de/DFTD3/; or else from the literature. Running DFTD3¶; A number of a posteriori dispersion corrections are available in; Psi4. While most are computed within Psi4‘s codebase (-D1, -D2,; -CHG, -DAS2009, -DAS2010), the -D3 correction and its variants are; available only through the DFTD3 program. Once installed, the; dftd3/Psi4 interface is transparent, and all corrections are; interfaced exactly alike.; Dispersion corrections are built into DFT functionals, so appending an a; posteriori correction to a computation is as simple as; energy('b2plyp-d') vs. energy('b2plyp'). For example, the; following input file computes (with much redundant work) for water a; B3LYP, a B3LYP-D2, and a B3LYP-D3 (zero-damping) energy.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('b3lyp'); energy('b3lyp-d'); energy('b3lyp-d3'). Consult the table -D Functionals to see for each; functional what corrections are available and what default parameters; define them. The dispersion correction is available after a calculation in; the PSI variable DISPERSION CORRECTION ENERGY.; By default, the output from the dftd3; program is suppressed; to see it in the output file, set print > 2. Variants of S. Grimme’s -D correction¶. Extension [1]; Variant and Computing Program; DFT_DISPERSION_PARAMETERS. -D; alias to -D2P4;  . -D1; -D1 [2] within Psi4;  . -D2; alias to -D2P4;  . -D2P4; -D2 [3] within Psi4; []. -D2GR; -D2 [3] through dftd3; [, ]. -D3; alias to -D3ZER",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/dftd3-1.html:4514,energy,energy,4514,psi4manual/1.0.0/dftd3-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/dftd3-1.html,2,['energy'],['energy']
Energy Efficiency,"omega(0.3); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_wpbesol_x_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('wPBEsol_X'); # Tab in, trailing newlines; sup.set_description(' PBEsol Short-Range GGA Exchange (HJS Model)\n'); # Tab in, trailing newlines; sup.set_citation(' Henderson et. al., J. Chem. Phys., 128, 194105, 2008\n Weintraub, Henderson, and Scuseria, J. Chem. Theory. Comput., 5, 754 (2009)\n'). # Add member functionals; sup.add_x_functional(build_functional('wPBEsol_X')). # Set GKS up after adding functionals; sup.set_x_omega(0.3); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_wb88_x_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('wB88_X'); # Tab in, trailing newlines; sup.set_description(' B88 Short-Range GGA Exchange (HJS Model)\n'); # Tab in, trailing newlines; sup.set_citation(' Henderson et. al., J. Chem. Phys., 128, 194105, 2008\n Weintraub, Henderson, and Scuseria, J. Chem. Theory. Comput., 5, 754 (2009)\n'). # Add member functionals; sup.add_x_functional(build_functional('wB88_X')). # Set GKS up after adding functionals; sup.set_x_omega(0.3); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_svwn_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/functional.html:22119,allocate,allocate,22119,psi4manual/4.0b5/_modules/functional.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/functional.html,2,['allocate'],['allocate']
Energy Efficiency,"omega(0.3); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_wpbesol_x_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('wPBEsol_X'); # Tab in, trailing newlines; sup.set_description(' PBEsol Short-Range GGA Exchange (HJS Model)\n'); # Tab in, trailing newlines; sup.set_citation(' Henderson et. al., J. Chem. Phys., 128, 194105, 2008\n Weintraub, Henderson, and Scuseria, J. Chem. Theory. Comput., 5, 754 (2009)\n'). # Add member functionals; sup.add_x_functional(build_functional('wPBEsol_X')). # Set GKS up after adding functionals; sup.set_x_omega(0.3); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_wpw92_c_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('wPW92_C'); # Tab in, trailing newlines; sup.set_description(' Short-Range PW92 Correlation Functional\n'); # Tab in, trailing newlines; sup.set_citation(' TODO\n'). # Add member functionals; sup.add_c_functional(build_functional('wPW92_C')). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.3); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_wpbe_c_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/procedures/functional.html:22974,allocate,allocate,22974,psi4manual/1.0.0/_modules/procedures/functional.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/functional.html,1,['allocate'],['allocate']
Energy Efficiency,"omegas.append(omega_r); types.append('Right Limit'); E0s.append(E0r); E1s.append(E1r); IPs.append(IPr); kIPs.append(kIPr). # Use previous orbitals from here out; PsiMod.set_global_option(""GUESS"",""READ""); ; # Left endpoint; PsiMod.set_global_option('DFT_OMEGA',omega_l). # Neutral; PsiMod.IO.change_file_namespace(180,""neutral"",""ot""); mol.set_molecular_charge(charge0); mol.set_multiplicity(mult0); PsiMod.print_out('\n\t==> IP Fitting SCF: Neutral, Left Endpoint <==\n'); E0l = energy('scf'); ref = PsiMod.wavefunction(); eps_a = ref.epsilon_a(); eps_b = ref.epsilon_b(); E_HOMO = 0.0;; if (Nb == 0):; E_HOMO = eps_a[int(Na-1)]; else:; E_a = eps_a[int(Na - 1)] ; E_b = eps_b[int(Nb - 1)] ; if (E_a >= E_b):; E_HOMO = E_a;; else: ; E_HOMO = E_b;; E_HOMOl = E_HOMO;; PsiMod.IO.change_file_namespace(180,""ot"",""neutral""); ; # Cation; PsiMod.IO.change_file_namespace(180,""cation"",""ot""); mol.set_molecular_charge(charge1); mol.set_multiplicity(mult1); PsiMod.print_out('\n\t==> IP Fitting SCF: Cation, Left Endpoint <==\n'); E1l = energy('scf'); PsiMod.IO.change_file_namespace(180,""ot"",""cation""). IPl = E1l - E0l;; kIPl = -E_HOMOl;; delta_l = IPl - kIPl;. if (IPl < kIPl):; PsiMod.print_out('\n***IP Fitting Error: Left Omega limit should have kIP < IP'); sys.exit(1). omegas.append(omega_l); types.append('Left Limit'); E0s.append(E0l); E1s.append(E1l); IPs.append(IPl); kIPs.append(kIPl); ; converged = False; repeat_l = 0;; repeat_r = 0;; step = 0;; while True:. step = step + 1;; ; # Regula Falsi (modified); if (repeat_l > 1):; delta_l = delta_l / 2.0;; if (repeat_r > 1):; delta_r = delta_r / 2.0;; omega = - (omega_r - omega_l) / (delta_r - delta_l) * delta_l + omega_l;; PsiMod.set_global_option('DFT_OMEGA',omega). # Neutral; PsiMod.IO.change_file_namespace(180,""neutral"",""ot""); mol.set_molecular_charge(charge0); mol.set_multiplicity(mult0); PsiMod.print_out('\n\t==> IP Fitting SCF: Neutral, Omega = %11.3E <==\n' % omega); E0 = energy('scf'); ref = PsiMod.wavefunction(); eps_a = ref.epsilon_a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/frac.html:14804,energy,energy,14804,psi4manual/4.0b4/_modules/frac.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/frac.html,2,['energy'],['energy']
Energy Efficiency,"omer ghosted. Gradients after three opt cycles are compared with those from psi4. cfour/sp-rhf-ccsdt; single-point CCSDT/qz2p on water. cfour/opt-rhf-scf; optimization HF/svp on water. cfour/sp-rhf-mp2; single-point MP2/qz2p on water. cfour/psi-rohf-scsmp2; ROHF MP2 energy components. Checks that computed identically between cfour and psi4. cfour/pywrap-cbs1; Various basis set extrapolation tests only in Cfour instead of Psi4. cfour/kw-2; testing best practices options, part ii. cfour/sp-rohf-ccsdt; single-point CCSDT/qz2p on NH2. cfour/sp-rhf-ccsd-ao; single-point CCSD/qz2p on water with aobasis. cfour/kw-3; Basis set spherical/Cartesian with cfour_basis and cfour_spherical. cfour/sp-rohf-ccsd_t_-ao; single-point CCSD(T)/qz2p on NH2 with aobasis. cfour/sp-rohf-ccsd-ao; single-point CCSD/qz2p on NH2 with aobasis. cfour/mints5-grad; geometry after three optimization cycles for a variety of input formats, references from psi4. cfour/sp-rhf-scf; single-point HF/qz2p on water. cfour/puream; Basis set spherical/Cartesian behavior in cfour. cfour/psi-rhf-mp3; MP3 energy components. Checks that computed identically between cfour and psi4. cfour/opt-rhf-mp2; optimization MP2/cc-pvtz on water. cfour/kw-1; testing best practices options, part i. cfour/kw-6; Basis set spherical/Cartesian with cfour_basis and puream. cfour/sp-uhf-ccsd_t_-ao-ecc; single-point CCSD(T)/qz2p on NH2 with ecc, aobasis. cfour/psi-uhf-scsmp2; UHF MP2 energy components. Checks that computed identically between cfour and psi4. cfour/sp-uhf-ccsd; single-point CCSD/qz2p on NH2. cfour/kw-4; Basis set spherical/Cartesian with basis and puream. cfour/psi-mp4; MP4 energy components. Checks that computed identically between cfour and psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Appendices; Test Suite and Sample Inputs; CFOUR. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_cfour.html:4349,energy,energy,4349,psi4manual/1.7.x/autodoc_testsuite_cfour.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_cfour.html,3,['energy'],['energy']
Energy Efficiency,"omerA', 'monomerB'); psi4.IO.set_default_namespace('monomerB'); psi4.set_local_option('SCF', 'SAPT', '2-monomer_B'); psi4.print_out('\n'); p4util.banner('Monomer B HF'); psi4.print_out('\n'); e_monomerB = scf_helper('RHF', **kwargs); psi4.print_out('\n'); p4util.banner('Monomer B DFMP2'); psi4.print_out('\n'); e_monomerB_mp2 = psi4.dfmp2(); psi4.set_global_option('DF_INTS_IO', df_ints_io). psi4.IO.change_file_namespace(p4const.PSIF_SAPT_MONOMERA, 'monomerA', 'dimer'); psi4.IO.change_file_namespace(p4const.PSIF_SAPT_MONOMERB, 'monomerB', 'dimer'). activate(molecule); psi4.IO.set_default_namespace('dimer'); psi4.set_local_option('SAPT', 'E_CONVERGENCE', 10e-10); psi4.set_local_option('SAPT', 'D_CONVERGENCE', 10e-10); psi4.set_local_option('SAPT', 'SAPT_LEVEL', 'MP2C'); psi4.print_out('\n'); p4util.banner('MP2C'); psi4.print_out('\n'). psi4.set_variable('MP2C DIMER MP2 ENERGY', e_dimer_mp2); psi4.set_variable('MP2C MONOMER A MP2 ENERGY', e_monomerA_mp2); psi4.set_variable('MP2C MONOMER B MP2 ENERGY', e_monomerB_mp2). e_sapt = psi4.sapt(). optstash.restore(); return e_sapt. [docs]def run_sapt(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SAPT calculation of any level. """"""; optstash = p4util.OptionsState(; ['SCF', 'SCF_TYPE']). # Alter default algorithm; if not psi4.has_option_changed('SCF', 'SCF_TYPE'):; psi4.set_local_option('SCF', 'SCF_TYPE', 'DF'). molecule = psi4.get_active_molecule(); user_pg = molecule.schoenflies_symbol(); molecule.reset_point_group('c1'); molecule.fix_orientation(True); molecule.fix_com(True) # This should always have been set, very dangerous bug here; molecule.update_geometry(); if user_pg != 'c1':; psi4.print_out(' SAPT does not make use of molecular symmetry, further calculations in C1 point group.\n'). if (psi4.get_option('SCF','REFERENCE') != 'RHF' ):; raise ValidationError('SAPT requires requires \""reference rhf\"".'). nfrag = molecule.nfragments(); if nfrag != 2:; raise ValidationError('SAPT requires active mol",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/proc.html:48171,ENERGY,ENERGY,48171,psi4manual/4.0b5/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/proc.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"omer_ptype.copy(). else:; cp_energy_body_dict[n] -= bsse; if metadata['ptype'] != 'energy':; cp_ptype_body_dict[n] -= bsse_ptype. cp_interaction_energy = cp_energy_body_dict[metadata['max_nbody']] - cp_energy_body_dict[1]; nbody_dict['Counterpoise Corrected Interaction Energy'] = cp_interaction_energy. for n in nbody_range[1:]:; var_key = 'CP-CORRECTED %d-BODY INTERACTION ENERGY' % n; nbody_dict[var_key] = cp_energy_body_dict[n] - cp_energy_body_dict[1]. _print_nbody_energy(cp_energy_body_dict, ""Counterpoise Corrected (CP)"", metadata['embedding_charges']); cp_interaction_energy = cp_energy_body_dict[metadata['max_nbody']] - cp_energy_body_dict[1]; if monomer_energies != 0.0:; nbody_dict['Counterpoise Corrected Total Energy'] = cp_energy_body_dict[metadata['max_nbody']]; nbody_dict['Counterpoise Corrected Interaction Energy'] = cp_interaction_energy. # Compute nocp energy and ptype; if 'nocp' in metadata['bsse_type_list']:; for n in nbody_range:; if n == metadata['max_frag']:; nocp_energy_body_dict[n] = nocp_energy_by_level[n]; if metadata['ptype'] != 'energy':; nocp_ptype_body_dict[n][:] = nocp_ptype_by_level[n]; continue. for k in range(1, n + 1):; take_nk = nCr(metadata['max_frag'] - k - 1, n - k); sign = ((-1)**(n - k)); value = nocp_energy_by_level[k]; nocp_energy_body_dict[n] += take_nk * sign * value. if metadata['ptype'] != 'energy':; value = nocp_ptype_by_level[k]; nocp_ptype_body_dict[n] += take_nk * sign * value. _print_nbody_energy(nocp_energy_body_dict, ""Non-Counterpoise Corrected (NoCP)"", metadata['embedding_charges']); nocp_interaction_energy = nocp_energy_body_dict[metadata['max_nbody']] - nocp_energy_body_dict[1]; nbody_dict['Non-Counterpoise Corrected Total Energy'] = nocp_energy_body_dict[metadata['max_nbody']]; nbody_dict['Non-Counterpoise Corrected Interaction Energy'] = nocp_interaction_energy. for n in nbody_range[1:]:; var_key = 'NOCP-CORRECTED %d-BODY INTERACTION ENERGY' % n; nbody_dict[var_key] = nocp_energy_body_dict[n] - nocp_energy_body_di",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html:26864,energy,energy,26864,psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html,8,['energy'],['energy']
Energy Efficiency,"ometry()))); mol = molecule. m = np.asarray([mol.mass(at) for at in range(mol.natom())]); irrep_labels = mol.irrep_labels(). vibinfo, vibtext = qcdb.vib.harmonic_analysis(; nmwhess, geom, m, wfn.basisset(), irrep_labels, dipder=dipder, project_trans=project_trans, project_rot=project_rot); vibrec.update({k: qca.json() for k, qca in vibinfo.items()}). core.print_out(vibtext); core.print_out(qcdb.vib.print_vibs(vibinfo, shortlong=True, normco='x', atom_lbl=symbols)). if core.has_option_changed('THERMO', 'ROTATIONAL_SYMMETRY_NUMBER'):; rsn = core.get_option('THERMO', 'ROTATIONAL_SYMMETRY_NUMBER'); else:; rsn = mol.rotational_symmetry_number(). if irrep is None:; therminfo, thermtext = qcdb.vib.thermo(; vibinfo,; T=core.get_option(""THERMO"", ""T""), # 298.15 [K]; P=core.get_option(""THERMO"", ""P""), # 101325. [Pa]; multiplicity=mol.multiplicity(),; molecular_mass=np.sum(m),; sigma=rsn,; rotor_type=mol.rotor_type(),; rot_const=np.asarray(mol.rotational_constants()),; E0=core.variable('CURRENT ENERGY')) # someday, wfn.energy(); vibrec.update({k: qca.json() for k, qca in therminfo.items()}). core.set_variable(""ZPVE"", therminfo['ZPE_corr'].data) # P::e THERMO; core.set_variable(""THERMAL ENERGY CORRECTION"", therminfo['E_corr'].data) # P::e THERMO; core.set_variable(""ENTHALPY CORRECTION"", therminfo['H_corr'].data) # P::e THERMO; core.set_variable(""GIBBS FREE ENERGY CORRECTION"", therminfo['G_corr'].data) # P::e THERMO. core.set_variable(""ZERO K ENTHALPY"", therminfo['ZPE_tot'].data) # P::e THERMO; core.set_variable(""THERMAL ENERGY"", therminfo['E_tot'].data) # P::e THERMO; core.set_variable(""ENTHALPY"", therminfo['H_tot'].data) # P::e THERMO; core.set_variable(""GIBBS FREE ENERGY"", therminfo['G_tot'].data) # P::e THERMO. core.print_out(thermtext); else:; core.print_out(' Thermochemical analysis skipped for partial frequency calculation.\n'). if core.get_option('FINDIF', 'HESSIAN_WRITE'):; filename = core.get_writer_file_prefix(mol.name()) + "".vibrec""; with open(filename, 'w') as handle:;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:89859,ENERGY,ENERGY,89859,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,2,['ENERGY'],['ENERGY']
Energy Efficiency,"ommand psi4 input.dat output.dat; (actually, because psi4 by default looks for an input file named; input.dat and writes by default to a file called output.dat, in this; case one could also just type psi4). If it works, it should print; the final energy as; 1@UHF Final Energy: -38.92533462456894. Notice we added a new keyword, set reference uhf, to the input. For; open-shell molecules, we have a choice of unrestricted orbitals; (unrestricted Hartree–Fock, or UHF), or restricted orbitals (restricted; open-shell Hartree–Fock, or ROHF). Usually, UHF is a little easier to; converge (although it may be more susceptible to spin contamination than; ROHF). Geometry Optimization and Vibrational Frequency Analysis¶; The above examples were simple single-point energy computations; (as specified by the energy() function). Of course there are other; kinds of computations to perform, such as geometry optimizations and; vibrational frequency computations. These can be specified by replacing; energy() with optimize() or frequency(), respectively.; Here’s an example of optimizing the H2O molecule using Hartree–Fock with; a cc-pVDZ basis set (located in; tu3-h2o-opt).; #! Optimize H2O HF/cc-pVDZ. molecule h2o {; O ; H 1 0.96; H 1 0.96 2 104.5; }. set basis cc-pVDZ; optimize('scf'). This should perform a series of gradient computations. The gradient points; which way is downhill in energy, and the optimizer then modifies the; geometry to follow the gradient. After a few cycles, the geometry should; converge with a message like Optimization is complete!. As indicated; in the following table (printed by the optimizer at the end of the; computation and grep-able with ~), the energy decreases with each step,; and the maximum force on each atom also decreases with each step (in; principle these numbers could increase in some iterations, but here they do; not).; 1; 2; 3; 4; 5; 6; 7---------------------------------------------------------------------------------------------------------------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/tutorial-1.html:5739,energy,energy,5739,psi4manual/1.1.0/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/tutorial-1.html,6,['energy'],['energy']
Energy Efficiency,"omp3; * olccd; * lccd; * lccsd; * cepa(0); * cepa(1); * cepa(3); * acpf; * aqcc; * qcisd; * cc2; * ccsd; * fno-ccsd; * bccd; * cc3; * qcisd(t); * ccsd(t); * fno-ccsd(t); * bccd(t); * cisd; * cisdt; * cisdtq; * ci\ *n*; * fci; * mrccsd; * mrccsd(t); * mrccsdt; * mrccsdt(q). :type name: str; :param name: ``'scf'`` || ``'ccsd'`` || etc. First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be ``'scf'``. Overruled if stage_wfn keywords supplied. :type scf_wfn: str; :param scf_wfn: |dl| ``'scf'`` |dr| || ``'c4-scf'`` || etc. Indicates the energy method for which the reference energy is to be; obtained. Generally unnecessary, as 'scf' is *the* scf in |PSIfour| but; can be used to direct lone scf components to run in |PSIfour| or Cfour; in a mixed-program composite method. :type corl_wfn: str; :param corl_wfn: ``'mp2'`` || ``'ccsd(t)'`` || etc. Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with ``name`` or as the unlabeled; first argument to the function. :type delta_wfn: str; :param delta_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. :type delta_wfn_lesser: str; :param delta_wfn_lesser: |dl| ``corl_wfn`` |dr| || ``'mp2'`` || etc. Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. :type delta2_wfn: str; :param delta2_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta2_wfn_lesser: str; :param delta2_wfn_lesser: |dl| ``delta_wfn`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. * Basis Sets; Currently, the basis set set thro",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html:36530,energy,energy,36530,psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html,30,['energy'],['energy']
Energy Efficiency,"omplexity of the original equations. Just as in; the familiar CCSD(T) method, the effects of connected triple excitations; may be included noniteratively to yield the QCISD(T) method. Both the; QCISD(T) and CCSD(T) methods are implemented for closed-shell references; in the FNOCC module. Many-body perturbation theory¶; QCI and CC methods are closely related to perturbation theory, and the; MP2, MP3, and MP4(SDQ) correlation energies can be obtained as a free; by-product of a CCSD or QCISD computation. The following is an; example of the results for a computation run with the call; energy('fno-qcisd') to energy():; QCISD iterations converged!. OS MP2 FNO correction: -0.000819116338; SS MP2 FNO correction: -0.000092278158; MP2 FNO correction: -0.000911394496. OS MP2 correlation energy: -0.166478414245; SS MP2 correlation energy: -0.056669079827; MP2 correlation energy: -0.223147494072; * MP2 total energy: -76.258836941658. OS MP2.5 correlation energy: -0.171225850256; SS MP2.5 correlation energy: -0.054028401038; MP2.5 correlation energy: -0.225254251294; * MP2.5 total energy: -76.260943698880. OS MP3 correlation energy: -0.175973286267; SS MP3 correlation energy: -0.051387722248; MP3 correlation energy: -0.227361008515; * MP3 total energy: -76.263050456101. OS MP4(SDQ) correlation energy: -0.180324322304; SS MP4(SDQ) correlation energy: -0.048798468084; MP4(SDQ) correlation energy: -0.230995119324; * MP4(SDQ) total energy: -76.266684566910. OS QCISD correlation energy: -0.181578117924; SS QCISD correlation energy: -0.049853548145; QCISD correlation energy: -0.231431666069; * QCISD total energy: -76.267121113654. The first set of energies printed corresponds to the second-order FNO; correction mentioned previously. Results for many-body perturbation; theory through partial fourth order are then provided.; The notation MP4(SDQ) indicates that we have included all contributions to; the correlation energy through fourth order, with the exception of that; from connected tr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/fnocc-1.html:5661,energy,energy,5661,psi4manual/1.4.0/fnocc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/fnocc-1.html,15,['energy'],['energy']
Energy Efficiency,"omponent [E_h]; for the approximate coupled-cluster (CCSD(T)-1a, CCSDT(Q)-1a,; up to CCn-1a) level of theory. CCSDT-1b TOTAL ENERGY¶. CCSDT-1b CORRELATION ENERGY¶. CCSDTQ-1b TOTAL ENERGY¶. CCSDTQ-1b CORRELATION ENERGY¶. CCn-1b TOTAL ENERGY¶. CCn-1b CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the approximate coupled-cluster (CCSD(T)-1b, CCSDT(Q)-1b,; up to CCn-1b) level of theory. CCSDT-3 TOTAL ENERGY¶. CCSDT-3 CORRELATION ENERGY¶. CCSDTQ-3 TOTAL ENERGY¶. CCSDTQ-3 CORRELATION ENERGY¶. CCn-3 TOTAL ENERGY¶. CCn-3 CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the approximate coupled-cluster (CCSD(T)-3, CCSDT(Q)-3,; up to CCn-3) level of theory. CCSD(T)_L TOTAL ENERGY¶. CCSD(T)_L CORRELATION ENERGY¶. CCSDT(Q)_L TOTAL ENERGY¶. CCSDT(Q)_L CORRELATION ENERGY¶. CC(n-1)(n)_L TOTAL ENERGY¶. CC(n-1)(n)_L CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the approximate coupled-cluster (CCSD(T)_L, CCSDT(Q)_L,; up to CC(n-1)(n)L level of theory. CCSDT(Q)/A TOTAL ENERGY¶. CCSDT(Q)/A CORRELATION ENERGY¶. CCSDT(Q)/B TOTAL ENERGY¶. CCSDT(Q)/B CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the modified CCSDT(Q) level of theory. CEPA(0) DIPOLE¶; Dipole array [e a0] for the coupled electron pair approximation variant 0 level of theory, (3,). CEPA(0) QUADRUPOLE¶; Redundant quadrupole array [e a0^2] for the coupled electron pair approximation variant 0 level of theory, (3, 3). CEPA(0) TOTAL ENERGY¶. CEPA(0) CORRELATION ENERGY¶. CEPA(1) TOTAL ENERGY¶. CEPA(1) CORRELATION ENERGY¶. CEPA(2) TOTAL ENERGY¶. CEPA(2) CORRELATION ENERGY¶. CEPA(3) TOTAL ENERGY¶. CEPA(3) CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the requested variant of coupled electron pair approximation level of theory. CFOUR ERROR CODE¶; The non-zero return value from ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html:20165,energy,energy,20165,psi4manual/1.7.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html,8,['energy'],['energy']
Energy Efficiency,"omponent of the triplet. Uses ROHF triplet orbitals. cbs-xtpl-energy; Extrapolated water energies. mints6; Patch of a glycine with a methyl group, to make alanine, then DF-SCF energy calculation with the cc-pVDZ basis set. isapt2; This is a shorter version if isapt1 - does not do cube plots. See isapt1 for full details. casscf-sa-sp; Example of state-averaged CASSCF for the C2 molecule see C. D. Sherrill and P. Piecuch, J. Chem. Phys. 122, 124104 (2005). cbs-xtpl-wrapper; RHF aug-cc-pVQZ energy for the BH molecule, with Cartesian input. Various gradients for a strained helium dimer and water molecule. pywrap-align; apply linear fragmentation algorithm to a water cluster. dfccsd1; DF-CCSD cc-pVDZ energy for the H2O molecule. cc13b; Tests RHF CCSD(T)gradients. x2c1; Test of SFX2C-1e on water uncontracted cc-pVDZ-DK The reference numbers are from Lan Cheng’s implementation in Cfour. scf-property; UFH and B3LYP cc-pVQZ properties for the CH2 molecule. dfomp2p5-2; DF-OMP2.5 cc-pVDZ energy for the H2O+ cation. soscf-dft; Triple and Singlet Oxygen energy SOSCF, also tests non-symmetric density matrices. opt14; 6-31G(d) optimization of SF4 starting from linear bond angle that is not linear in the optimized structure but is in a symmetry plane of the molecule. dcft-grad1; DCFT DC-06 gradient for the O2 molecule with cc-pVDZ basis set. pywrap-checkrun-rhf; This checks that all energy methods can run with a minimal input and set symmetry. opt5; 6-31G** UHF CH2 3B1 optimization. Uses a Z-Matrix with dummy atoms, just for demo and testing purposes. cc53; Matches Table II a-CCSD(T)/cc-pVDZ H2O @ 2.5 * Re value from Crawford and Stanton, IJQC 98, 601-611 (1998). dfomp3-1; DF-OMP3 cc-pVDZ energy for the H2O molecule. psithon1; Spectroscopic constants of H2, and the full ci cc-pVTZ level of theory. scf-response1; Compute the dipole, quadrupole, and traceless quadrupoles for water. tu5-sapt; Example SAPT computation for ethene*ethine (i.e., ethylene*acetylene), test case 16 from the S",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html:15019,energy,energy,15019,psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"omponent-scaled OMP2 (SCS-OMP2)? In all computation, SCS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SCS-OMP2, one needs to set ‘DO_SCS’ to true. Type: boolean; Default: false. DO_SCS (OCC); OCC — Do perform spin-component-scaled OMP2 (SCS-OMP2)? In all computation, SCS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SCS-OMP2, one needs to set ‘DO_SCS’ to true. Type: boolean; Default: false. DO_SINGLETS (CPHF); CPHF — Do singlet states? Default true. Type: boolean; Default: true. DO_SOS (DFOCC); DFOCC — Do perform spin-opposite-scaled OMP2 (SOS-OMP2)? In all computation, SOS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SOS-OMP2, one needs to set ‘DO_SOS’ to true. Type: boolean; Default: false. DO_SOS (OCC); OCC — Do perform spin-opposite-scaled OMP2 (SOS-OMP2)? In all computation, SOS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SOS-OMP2, one needs to set ‘DO_SOS’ to true. Type: boolean; Default: false. DO_THIRD_ORDER (SAPT); SAPT (Expert) — Do compute third-order corrections?. Type: boolean; Default: false. DO_TRIPLETS (CPHF); CPHF — Do triplet states? Default true. Type: boolean; Default: true. DOCC (GLOBALS); GLOBALS — An array containing the number of doubly-occupied orbitals per irrep (in Cotton order). Type: array; Default: No Default. DOCC (MCSCF); MCSCF — The number of doubly occupied orbitals, per irrep. Type: array; Default: No Default. DYNAMIC_LEVEL (OPTKING); OPTKING — Starting level for dynamic optimization (0=nondynamic, higher=>more conservative). Type: integer; Default: 0. E3_SCALE (DFOCC); DFOCC — CEPA opposite-spin scaling value from SCS-CCSD. Type: double; Default: 0.25. E3_SCALE (OCC); OCC — Scaling value for 3rd order energy correction (S. G",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html:111887,energy,energy,111887,psi4manual/1.0.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html,8,['energy'],['energy']
Energy Efficiency,"omponents():; """"""Define some quantum chemical knowledge, namely what methods are subsumed in others."""""". # yapf: disable; VARH = {}; VARH['scf'] = {; 'scf': 'SCF TOTAL ENERGY'}; VARH['hf'] = {; 'hf': 'HF TOTAL ENERGY'}; VARH['mp2'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY'}; VARH['mp2d'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2d': 'MP2D TOTAL ENERGY'}; VARH['mp2.5'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'mp2.5': 'MP2.5 TOTAL ENERGY',; 'mp3': 'MP3 TOTAL ENERGY'}; VARH['mp3'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'mp2.5': 'MP2.5 TOTAL ENERGY',; 'mp3': 'MP3 TOTAL ENERGY'}; VARH['mp4(sdq)'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'mp2.5': 'MP2.5 TOTAL ENERGY',; 'mp3': 'MP3 TOTAL ENERGY',; 'mp4(sdq)': 'MP4(SDQ) TOTAL ENERGY'}; VARH['mp4'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'mp2.5': 'MP2.5 TOTAL ENERGY',; 'mp3': 'MP3 TOTAL ENERGY',; 'mp4(sdq)': 'MP4(SDQ) TOTAL ENERGY',; 'mp4': 'MP4 TOTAL ENERGY'}; VARH['omp2'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'omp2': 'OMP2 TOTAL ENERGY'}; VARH['omp2.5'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'mp2.5': 'MP2.5 TOTAL ENERGY',; 'omp2.5': 'OMP2.5 TOTAL ENERGY'}; VARH['omp3'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'mp3': 'MP3 TOTAL ENERGY',; 'omp3': 'OMP3 TOTAL ENERGY'}; VARH['olccd'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'olccd': 'OLCCD TOTAL ENERGY'}; VARH['lccd'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'lccd': 'LCCD TOTAL ENERGY'}; VARH['lccsd'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'lccsd': 'LCCSD TOTAL ENERGY'}; VARH['cepa(0)'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'cepa(0)': 'CEPA(0) TOTAL ENERGY'}; VARH['cepa(1)'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'cepa(1)': 'CEPA(1) TOTAL ENERGY'}; VARH['cepa(3)'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'cepa(3)': 'CEPA(3) ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:24223,ENERGY,ENERGY,24223,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,7,['ENERGY'],['ENERGY']
Energy Efficiency,"omprehend; }. set {; s_tolerance 0.0001 # Set an unreasonably tight; # tolerance to force canonical; basis aug-cc-pv5z # This diffuse basis will have; # small-ish eigenvalues for even H2O; print 3; }. energy('scf'). Output:; ==> Pre-Iterations <==. -------------------------------------------------------; Irrep Nso Nmo Nalpha Nbeta Ndocc Nsocc; -------------------------------------------------------; A 145 145 0 0 0 0; B 142 142 0 0 0 0; -------------------------------------------------------; Total 287 287 5 5 5 0; -------------------------------------------------------. ... Minimum eigenvalue in the overlap matrix is 1.6888063568E-05.; Using Canonical Orthogonalization with cutoff of 1.0000000000E-04.; Irrep 0, 1 of 145 possible MOs eliminated.; Irrep 1, 2 of 142 possible MOs eliminated.; Overall, 3 of 287 possible MOs eliminated. In this example, there are 287 AO basis functions after spherical harmonics are; applied. These are used to produce 287 symmetry adapted USOs, 145 of which are; assigned to irrep A, and 142 of which are assigned to irrep B. Within irrep A,; 144 OSOs fall above the eigenvalue cutoff, and within irrep B 140 OSOs fall; above the eigenvalue cutoff. In total, 284 molecular orbitals are chosen from; 287 AOs/USOs. Initial Guess¶; In each step of the SCF procedure, a new Fock or Kohn–Sham potential is built; according to the previous density, following which the potential is diagonalized; to produce new molecular orbitals, from which a new density is computed. This; procedure is continued until either convergence is reached or a preset maximum; number of iterations is exceeded. Convergence is determined by both change in; energy and root-mean-square change in density matrix values, which must be below; the user-specified E_CONVERGENCE and D_CONVERGENCE, respectively.; The maximum number of iterations is specified by the MAXITER option. It; should be noted that SCF is a chaotic process, and, as such, often requires; careful selection of initial or",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/scf-1.html:15447,adapt,adapted,15447,psi4manual/1.4.0/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/scf-1.html,9,['adapt'],['adapted']
Energy Efficiency,"omputation %d for item %d """""" % (os.getpid(), n + 1)); freagent.write(""""""yields electronic energy %20.12f\\n' % (electronic_energy))\n\n""""""). # S/R: Read energy from each displaced geometry output file and save in energies array; elif freq_mode == 'reap':; exec(banners); psi4.set_variable('NUCLEAR REPULSION ENERGY', moleculeclone.nuclear_repulsion_energy()); energies.append(p4util.extract_sowreap_from_output(rfile, 'HESSIAN', n, freq_linkage, True)). # S/R: Quit sow after writing files. Initialize skeleton wfn to receive grad for reap; if freq_mode == 'sow':; optstash.restore(); optstash_conv.restore(); if return_wfn:; return (None, None); else:; return None; elif freq_mode == 'reap':; # psi4.set_variable('CURRENT ENERGY', energies[-1]); wfn = psi4.new_wavefunction(molecule, psi4.get_global_option('BASIS')). # Assemble Hessian from energies; H = psi4.fd_freq_0(molecule, energies, irrep); wfn.set_hessian(H); wfn.set_frequencies(psi4.get_frequencies()). # The last item in the list is the reference energy, return it; psi4.set_variable('CURRENT ENERGY', energies[-1]). psi4.set_parent_symmetry(''); optstash.restore(); optstash_conv.restore(). if return_wfn:; return (wfn.hessian(), wfn); else:; return wfn.hessian(). [docs]def frequency(name, **kwargs):; r""""""Function to compute harmonic vibrational frequencies. :aliases: frequencies(), freq(). :returns: *float* |w--w| Total electronic energy in Hartrees. :returns: (*float*, :ref:`Wavefunction<sec:psimod_Wavefunction>`) |w--w| energy and wavefunction when **return_wfn** specified. :type name: string; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return th",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver.html:78435,energy,energy,78435,psi4manual/1.0.0/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver.html,1,['energy'],['energy']
Energy Efficiency,"omputation for a positively charged system, illustrating the cation-pi interaction. The SIAO1 link partitioning algorithm is used. The system is taken from http://dx.doi.org/10.1016/j.comptc.2014.02.008. fnocc7; Test fnocc with linear dependencies. fnocc6; Test method/basis with disk_df. tdscf-2; td-uhf test on triplet states of methylene (tda), wfn passing. cc26; Single-point gradient, analytic and via finite-differences of 2-1A1 state of H2O with EOM-CCSD. cc55; EOM-CCSD/6-31g excited state transition data for water with two excited states per irrep. dfmp2-1; Density fitted MP2 cc-PVDZ/cc-pVDZ-RI computation of formic acid dimer binding energy using automatic counterpoise correction. Monomers are specified using Cartesian coordinates. dct3; DC-06 calculation for the He dimer. This performs a simultaneous update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the AO Basis, using integrals stored on disk. pywrap-alias; Test parsed and exotic calls to energy() like zapt4, mp2.5, and cisd are working. cc6; Frozen-core CCSD(T)/cc-pVDZ on C4H4N anion with disk ao algorithm. omp3-4; SCS-OMP3 cc-pVDZ geometry optimization for the H2O molecule. sapt-ecp; sapt0 of charged system in ECP basis set. cisd-h2o+-0; 6-31G** H2O+ Test CISD Energy Point. oremp-grad2; integral conventional OO-REMP/cc-pVDZ engrad single points for the H2O molecule. single point energies were independently checked using the original wavels code. oremp-grad1; integral conventional OO-REMP/cc-pVDZ engrad single points for the H2O molecule. castup1; Test of SAD/Cast-up (mainly not dying due to file weirdness). phi-ao; Test computing values of basis functions (puream and non-puream) at points. omp2p5-grad1; OMP2.5 cc-pVDZ gradient for the H2O molecule. tu4-h2o-freq; Optimization followed by frequencies H2O HF/cc-pVDZ. dft-grad1; DF-BP86-D2 cc-pVDZ frozen core gradient of S22 HCN update ref gradient due to new BraggSlater radii. sapt-dft-lrc; SAPT(DFT) aug-cc-pV",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html:39974,energy,energy,39974,psi4manual/master/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"omputation in 1-indexed,; input-file order, while the second enumerates list over a, b,; …, c enumerates which fragments contribute basis functions to the; computation. For example, (1, 2)@(1, 2, 3, 4) indicates that the; fragments 1 and 2 are explicitly included in the energy computation,; with basis functions from each of fragments 1, 2, 3, & 4 included in; the basis set. Therefore, the basis functions from fragments 3 and 4; are included as ghost functions within the energy computation. NUCLEAR REPULSION ENERGY¶; The nuclear repulsion energy contribution [Eh] to the total SCF energy.; Quantity \(E_{NN}\) in Eq. (4). (3)¶\[E_{NN} = \sum_{i, j<i}^{N_{atom}}\frac{Z_i Z_j}{|\mathbf{R}_i - \mathbf{R}_j|}\]. OCEPA(0) TOTAL ENERGY¶. OCEPA(0) CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the orbital-optimized CEPA(0) level of theory. OLCCD TOTAL ENERGY¶. OLCCD CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the orbital-optimized linearized coupled cluster doubles level of theory. OLCCD REFERENCE CORRECTION ENERGY¶; The additional correction to the SCF reference energy [Eh]; for the orbital-optimized linearized coupled cluster doubles level of theory. OMP2 TOTAL ENERGY¶. OMP2 CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the orbital-optimized MP2 level of theory. OMP2.5 TOTAL ENERGY¶. OMP2.5 CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the orbital-optimized MP2.5 level of theory. OMP3 TOTAL ENERGY¶. OMP3 CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the orbital-optimized MP3 level of theory. ONE-ELECTRON ENERGY¶; The one-electron energy contribution [Eh] to the total SCF energy.; Quantity \(E_{1e^-}\) in Eq. (4). PCM POLARIZATION ENERGY¶; The energy contribution [Eh] from the polarizable continuum model for solvation. PE EN",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html:33296,energy,energy,33296,psi4manual/1.4.0/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html,10,['energy'],['energy']
Energy Efficiency,"omputation. If more than one electron is in RAS IV, then the holes in RAS I cannot exceed the number of particles in RAS III + RAS IV (i.e., EX_LEVEL , or else the string is discarded. Type: boolean; Default: false. RAS1¶. An array giving the number of orbitals per irrep for RAS1. Type: array; Default: No Default. RAS2¶. An array giving the number of orbitals per irrep for RAS2. Type: array; Default: No Default. RAS3¶. An array giving the number of orbitals per irrep for RAS3. Type: array; Default: No Default. RAS4¶. An array giving the number of orbitals per irrep for RAS4. Type: array; Default: No Default. SF_RESTRICT¶. Do eliminate determinants not valid for spin-complete spin-flip CI’s? [see J. S. Sears et al, J. Chem. Phys. 118, 9084-9094 (2003)]. Type: boolean; Default: false. Expert Diagonalization Methods¶. H0_BLOCKSIZE¶. This parameter specifies the size of the H0 block of the Hamiltonian which is solved exactly. The n determinants with the lowest SCF energy are selected, and a submatrix of the Hamiltonian is formed using these determinants. This submatrix is used to accelerate convergence of the CI iterations in the OLSEN and MITRUSHENKOV iteration schemes, and also to find a good starting guess for the SEM method if GUESS_VECTOR is H0_BLOCK. Defaults to 400. Note that the program may change the given size for Ms=0 cases MS0 is TRUE) if it determines that the H0 block includes only one member of a pair of determinants related by time reversal symmetry. For very small block sizes, this could conceivably eliminate the entire H0 block; the program should print warnings if this occurs. Type: integer; Default: 400. H0_BLOCK_COUPLING¶. Do use coupling block in preconditioner?. Type: boolean; Default: false. H0_BLOCK_COUPLING_SIZE¶. Parameters which specifies the size of the coupling block within the generalized davidson preconditioner. Type: integer; Default: 0. H0_GUESS_SIZE¶. size of H0 block for initial guess. Type: integer; Default: 400. HD_AVG¶. How to avera",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodir_options_c/module__detci-1.html:13532,energy,energy,13532,psi4manual/4.0b2/autodir_options_c/module__detci-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodir_options_c/module__detci-1.html,16,['energy'],['energy']
Energy Efficiency,"omputations of three-body dispersion; corrections. In DFT-D3, three-body dispersion is approximated with the; Axilrod-Teller-Muto model:. \[E_{disp}^{(3)}=-\frac{1}{6}\sum_{A\neq B\neq C}\frac{C_{9}^{ABC}(3\cos{\theta_a}\cos{\theta_b}\cos{\theta_c}+1)}{(r_{AB}r_{BC}r_{AC})^{3}}f_{damp}(\bar{r}_{ABC})\]; where \(\theta_a\) is the angle at atom A corresponding to the triangle formed by atoms A, B, and C,; and \(\bar{r}_{ABC}\) is the geometric mean of the corresponding atomic-pair distances.; The dispersion coefficients are defined as. \[C_{9}^{ABC} = \sqrt{C_{6}^{AB}C_{6}^{BC}C_{6}^{AC}}\]; See the DFT-D3 documentation; for more details.; For now, the three-body correction can be called by using the run_dftd3(); function with d3-atmgr as the passed functional string.; For example, the three-body ATM dispersion correction for a neon trimer could; be computed with:; molecule ne3 {; Ne 0.0 0.0 0.0; Ne 0.0 0.0 1.0; Ne 0.0 1.0 1.0; }; ne.update_geometry(); energy = m.run_dftd3('d3-atmgr', dertype=0); print(energy). Since v1.7, it is preferred to use s-dftd3 for ATM since the 3-body can be run concurrent; with the 2-body contribution.; Footnotes. [1]; Note that there are functionals with these extensions (e.g., wB97X-D) that,; not being Grimme corrections, won’t follow this table exactly. [2]; [Grimme:2004:1463]. [3]; [Grimme:2006:1787]. [4]; (1,2); [Grimme:2010:154104]. [5]; (1,2); [Grimme:2011:1456]. [6]; (1,2,3,4); [Smith:2016:2197]. [7]; [Hujo:2011:3866]. [8]; [Chai:2010:6615]. [9]; [Pernal:2009:263201]. [10]; [Podeszwa:2010:550]. [11]; Keyword not used for user-defined functionals where the dft_dict[""dispersion""][""params""]; is easily editable for this purpose. See Advanced Functional Use and Manipulation. [12]; [Caldeweyher:2019:154122]. A few practical examples:. DFT-D2 single point with default parameters (dftd3 not called); energy('bp86-d'). DFT-D3BJ optimization with default parameters; optimize('pbe-d3bj'). DFT-D2 optimization with custom s6 parameter; set dft_di",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/dftd3.html:11099,energy,energy,11099,psi4manual/1.9.x/dftd3.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/dftd3.html,2,['energy'],['energy']
Energy Efficiency,"omputations, one in the dimer basis and; one in the monomer basis. Finally, it will print a summary of the; charge-transfer results:; SAPT Charge Transfer Analysis; -----------------------------------------------------------------------------; SAPT Induction (Dimer Basis) -2.0970 mH -1.3159 kcal mol^-1; SAPT Induction (Monomer Basis) -1.1396 mH -0.7151 kcal mol^-1; SAPT Charge Transfer -0.9574 mH -0.6008 kcal mol^-1. These results are for the water dimer geometry shown above computed with; SAPT0/aug-cc-pVDZ. Monomer-Centered Basis Computations¶; The charge-transfer analysis above is carried out by taking the; difference between SAPT induction as calculated in the dimer-centered; basis (i.e., each monomer sees the basis functions on both monomers); vs. the monomer-centered basis (i.e., each monomer utilizes only its; own basis set). It is also possible to run a SAPT computation at any; level using only the monomer-centered basis. To do this, simply add; sapt_basis='monomer' to the energy function, such as; energy('sapt2',sapt_basis='monomer'). This procedure leads to faster compuations, but it converges more slowly; towards the complete basis set limit than the default procedure, which uses; the dimer-centered basis set. Hence, monomer-centered basis SAPT; computations are not recommended. Interpreting SAPT Results¶; We will examine the results of a SAPT2+3/aug-cc-pVDZ computation on the; water dimer. This computation can be performed with the following; input:; molecule water_dimer {; 0 1; O -1.551007 -0.114520 0.000000; H -1.934259 0.762503 0.000000; H -0.599677 0.040712 0.000000; --; 0 1; O 1.350625 0.111469 0.000000; H 1.680398 -0.373741 -0.758561; H 1.680398 -0.373741 0.758561; units angstrom; }. set globals {; basis aug-cc-pvdz; guess sad; scf_type df; }. set sapt {; print 1; nat_orbs_t2 true; freeze_core true; }. energy('sapt2+3'). To reiterate some of the options mentioned above: the; NAT_ORBS_T2 option will compute MP2 natural orbitals and use; them in the e",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/sapt-1.html:13647,energy,energy,13647,psi4manual/4.0b5/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/sapt-1.html,4,['energy'],['energy']
Energy Efficiency,"omputations. EFP TORQUE¶; The torque, not gradient for EFP/EFP computations. ENTHALPY¶; Total enthalpy H [Eh] at given temperature. ENTHALPY CORRECTION¶; Sum of electronic, translational, rotational, and vibrational corrections [Eh] to the enthalpy at given temperature. ESP AT CENTER n¶; Property of electrostatic potential [Eh / e] at location, usually atom center, n. FCI TOTAL ENERGY¶. FCI CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the full configuration interaction level of theory. GIBBS FREE ENERGY¶; Total Gibbs free energy [Eh], free enthalpy at given temperature. GIBBS FREE ENERGY CORRECTION¶; Sum of electronic, translational, rotational, and vibrational corrections [Eh] to the free enthalpy at given temperature. GRID ELECTRONS TOTAL¶. GRID ELECTRONS ALPHA¶. GRID ELECTRONS BETA¶; The number of electrons integrated by the xc quadrature grid. HF TOTAL ENERGY¶; The total electronic energy [Eh] for the Hartree–Fock method, without; any dispersion correction; the first three (or four, since; \(E_{xc} = 0\)) terms in Eq. (4). Quantity \(E_{\text{HF}}\); in Eq. (4). HF TOTAL GRADIENT¶; The total electronic gradient [E_h/a0] of the Hartree–Fock method, ({nat}, 3). HF DIPOLE GRADIENT¶; The derivative of the Hartree–Fock method dipole [E_h a0/u] = [(e a0/a0)^2/u] with respect to nuclear perturbations; as a degree-of-freedom by dipole component array, (3 * {nat}, 3). HF TOTAL HESSIAN¶; The total electronic second derivative [Eh/a0/a0] for the Hartree-Fock method, (3 * {nat}, 3 * {nat}). LCCD TOTAL ENERGY¶. LCCD CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the linearized coupled cluster doubles level of theory. LCCSD TOTAL ENERGY¶. LCCSD CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the linearized coupled cluster singles and doubles level of theory. LCC2 (+LMP2) TOTAL ENERGY¶; The total electronic energy [Eh] for the l",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html:23232,energy,energy,23232,psi4manual/1.4.0/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html,5,['energy'],['energy']
Energy Efficiency,"omputations. These are the starting points for most computations, so this code is called in most cases. DFT FUNCTIONAL TOTAL ENERGY; DFT TOTAL ENERGY; DFT TOTAL GRADIENT; DFT TOTAL HESSIAN; DFT VV10 ENERGY; DFT XC ENERGY; DISPERSION CORRECTION ENERGY; DOUBLE-HYBRID CORRECTION ENERGY; GRID ELECTRONS ALPHA; GRID ELECTRONS BETA; GRID ELECTRONS TOTAL; HF TOTAL ENERGY; HF TOTAL GRADIENT; HF TOTAL HESSIAN; NUCLEAR REPULSION ENERGY; ONE-ELECTRON ENERGY; SCF ITERATIONS; SCF STABILITY EIGENVALUES (array); SCF TOTAL ENERGY; SCF TOTAL GRADIENT; SCF TOTAL HESSIAN; TD-fctl ROOT 0 (IN h) -> ROOT n (IN i) EXCITATION ENERGY; TD-fctl ROOT 0 (IN h) -> ROOT n (IN i) OSCILLATOR STRENGTH (LEN); TD-fctl ROOT 0 (IN h) -> ROOT n (IN i) OSCILLATOR STRENGTH (VEL); TD-fctl ROOT 0 (IN h) -> ROOT n (IN i) ROTATORY STRENGTH (LEN); TD-fctl ROOT 0 (IN h) -> ROOT n (IN i) ROTATORY STRENGTH (VEL); TD-fctl ROOT 0 (h) -> ROOT n (i) EXCITATION ENERGY; TD-fctl ROOT 0 (h) -> ROOT n (i) OSCILLATOR STRENGTH (LEN); TD-fctl ROOT 0 (h) -> ROOT n (i) OSCILLATOR STRENGTH (VEL); TD-fctl ROOT 0 (h) -> ROOT n (i) ROTATORY STRENGTH (LEN); TD-fctl ROOT 0 (h) -> ROOT n (i) ROTATORY STRENGTH (VEL); TD-fctl ROOT 0 -> ROOT n EXCITATION ENERGY; TD-fctl ROOT 0 -> ROOT n EXCITATION ENERGY - h TRANSITION; TD-fctl ROOT 0 -> ROOT n OSCILLATOR STRENGTH (LEN); TD-fctl ROOT 0 -> ROOT n OSCILLATOR STRENGTH (LEN) - h TRANSITION; TD-fctl ROOT 0 -> ROOT n OSCILLATOR STRENGTH (VEL); TD-fctl ROOT 0 -> ROOT n OSCILLATOR STRENGTH (VEL) - h TRANSITION; TD-fctl ROOT 0 -> ROOT n ROTATORY STRENGTH (LEN); TD-fctl ROOT 0 -> ROOT n ROTATORY STRENGTH (LEN) - h TRANSITION; TD-fctl ROOT 0 -> ROOT n ROTATORY STRENGTH (VEL); TD-fctl ROOT 0 -> ROOT n ROTATORY STRENGTH (VEL) - h TRANSITION; TD-fctl ROOT n (IN h) TOTAL ENERGY; TD-fctl ROOT n (h) TOTAL ENERGY; TD-fctl ROOT n TOTAL ENERGY; TD-fctl ROOT n TOTAL ENERGY - h TRANSITION; TWO-ELECTRON ENERGY. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodir_psivariables/module__scf.html:326,ENERGY,ENERGY,326,psi4manual/1.6.x/autodir_psivariables/module__scf.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodir_psivariables/module__scf.html,19,['ENERGY'],['ENERGY']
Energy Efficiency,"ompute an MP2 guess. Type: string; Possible Values: CC, BCC, MP2, DCFT; Default: MP2. DCFT_TYPE (DCFT); DCFT — What algorithm to use for the DCFT computation. Type: string; Possible Values: CONV, DF; Default: CONV. DEBUG (CPHF); CPHF — The amount of debug information printed to the output file. Type: integer; Default: 0. DEBUG (GLOBALS); GLOBALS (Expert) — The amount of information to print to the output file. Type: integer; Default: 0. DELETE_TEI (CCTRANSORT); CCTRANSORT — Delete the SO two-electron integrals after the transformation?. Type: boolean; Default: true. DELETE_TEI (TRANSQT2); TRANSQT2 — Boolean to delete the SO-basis two-electron integral file after the transformation. Type: boolean; Default: true. DENOMINATOR_ALGORITHM (SAPT); SAPT — Denominator algorithm for PT methods. Laplace transformations are slightly more efficient. Type: string; Possible Values: LAPLACE, CHOLESKY; Default: LAPLACE. DENOMINATOR_DELTA (SAPT); SAPT — Maximum error allowed (Max error norm in Delta tensor) in the approximate energy denominators employed for most of the and evaluation. Type: double; Default: 1.0e-6. DERTYPE (EFP); EFP (Expert) — Do EFP gradient?. Type: string; Possible Values: NONE, FIRST; Default: NONE. DERTYPE (GLOBALS); GLOBALS (Expert) — Derivative level. Type: string; Possible Values: NONE, FIRST, SECOND, RESPONSE; Default: NONE. DETCI_FREEZE_CORE (DETCI); DETCI — Do freeze core orbitals?. Type: boolean; Default: true. DF_BASIS_CC (FNOCC); FNOCC — Auxilliary basis for df-ccsd(t). Type: string; Possible Values: basis string; Default: No Default. DF_BASIS_CC (GLOBALS); GLOBALS — The density fitting basis to use in coupled cluster computations. Type: string; Possible Values: basis string; Default: No Default. DF_BASIS_DCFT (DCFT); DCFT — Auxiliary basis set for DCFT density fitting computations. Defaults to a RI basis. Type: string; Possible Values: basis string; Default: No Default. DF_BASIS_ELST (SAPT); SAPT — Auxiliary basis set for SAPT Elst10 and Exch10 densit",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html:94852,energy,energy,94852,psi4manual/1.0.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html,2,['energy'],['energy']
Energy Efficiency,"ompute the IRC for HCN <-> NCH interconversion at the RHF/DZP level of theory. sapt3; SAPT2+3(CCD) aug-cc-pVDZ+midbond computation of the water dimer interaction energy, using the aug-cc-pVDZ-JKFIT DF basis for SCF and aug-cc-pVDZ-RI for SAPT. dft-grad-lr2; Tests CAM gradients with and without XC pieces to narrow grid error. cc13; UHF-CCSD/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. dct11; Restricted DF-DCT ODC-12 energies with linearly dependent basis functions. cdoremp-energy1; Cholesky decomposed OO-REMP/cc-pVDZ energy for the H2O molecule. dfcasscf-sp; CASSCF/6-31G** energy point. dforemp-grad1; density fitted OO-REMP/cc-pVDZ engrad single points for the H2O molecule. cc56; EOM-CCSD/6-31g excited state transition data for water cation. fsapt-ext-abc2; FSAPT with external charge on dimer. stability1; UHF->UHF stability analysis test for BH with cc-pVDZ Test direct SCF with and without symmetry, test PK without symmetry. tu6-cp-ne2; Example potential energy surface scan and CP-correction for Ne2. ci-multi; BH single points, checking that program can run multiple instances of DETCI in a single input, without an intervening clean() call. sapt9; usapt example with empty beta. cc8b; ROHF-CCSD cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Cartesian input. ao-dfcasscf-sp; CASSCF/6-31G** energy point. pywrap-basis; SAPT calculation on bimolecular complex where monomers are unspecified so driver auto-fragments it. Basis set and auxiliary basis sets are assigned by atom type. dfmp2-grad1; DF-MP2 cc-pVDZ gradients for the H2O molecule. dct8; DCT calculation for the NH3+ radical using the ODC-12 and ODC-13 functionals. This performs both simultaneous and QC update of the orbitals and cumulant using DIIS extrapolation. Four-virtual integrals are first handled in the MO Basis for the first two energy computations. In the next computation ao_basis=disk algorithm is used, where the transformation of integrals for four-vi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html:17988,energy,energy,17988,psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"ompute the contribution to the nuclear repulsion energy for the given molecule. computePotentialMatrix(self, basis); Compute the external potential matrix in the given basis set. getCharges(self); Get the vector of charge tuples. print_out(self); Print python print helper to the outfile. setName(self, arg0); Sets the name. Methods Documentation. addBasis(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet, coefs: psi4.core.Vector) → None¶; Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self: psi4.core.ExternalPotential, Z: float, x: float, y: float, z: float) → None¶; Add a charge Z at (x,y,z). appendCharges(self: psi4.core.ExternalPotential, arg0: List[Tuple[float, float, float, float]]) → None¶; Append a vector of charge tuples to a current ExternalPotential. clear(self: psi4.core.ExternalPotential) → None¶; Reset the field to zero (eliminates all entries). computeExternExternInteraction(self: psi4.core.ExternalPotential, arg0: psi4.core.ExternalPotential) → float¶; Compute the interaction between this potential and other external potential. computeNuclearEnergy(self: psi4.core.ExternalPotential, arg0: psi4.core.Molecule) → float¶; Compute the contribution to the nuclear repulsion energy for the given molecule. computePotentialMatrix(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet) → psi4.core.Matrix¶; Compute the external potential matrix in the given basis set. getCharges(self: psi4.core.ExternalPotential) → List[Tuple[float, float, float, float]]¶; Get the vector of charge tuples. print_out(self: psi4.core.ExternalPotential) → None¶; Print python print helper to the outfile. setName(self: psi4.core.ExternalPotential, arg0: str) → None¶; Sets the name. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. PSI4 API: Linking C++ and Python; ExternalPotential. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.ExternalPotential.html:2016,energy,energy,2016,psi4manual/1.6.x/api/psi4.core.ExternalPotential.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.ExternalPotential.html,4,"['charge', 'energy']","['charge', 'energy']"
Energy Efficiency,"ompute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. cphf_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix]) → List[psi4.core.Matrix]; CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self: psi4.core.HF) → bool; Adds occupied guess alpha orbitals. cphf_solve(self: psi4.core.HF, x_vec: List[psi4.core.Matrix], conv_tol: float, max_iter: int, print_lvl: int=2) → List[psi4.core.Matrix]; Solves the CPHF equations for a given set of x vectors. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Deep copies the internal data. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunctions energy. epsilon_a(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Alpha Eigenvalues subset. epsilon_b(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Beta Eigenvalues subset. esp_at_nuclei(self: psi4.core.Wavefunction) → psi4.core.Vector¶; returns electrostatic potentials at nuclei. finalize_E(self: psi4.core.HF) → float; Computes the final SCF energy. force_doccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶; Specialized expert use only. Sets the number of doubly occupied oribtals per irrep. Note that this results in inconsistent Wavefunction objects for SCF, so caution is advised. force_soccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/api/psi4.core.hf.html:8465,energy,energy,8465,psi4manual/1.2.1/api/psi4.core.hf.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/api/psi4.core.hf.html,1,['energy'],['energy']
Energy Efficiency,"ompute_list(; [""nocp""], list(range(1, self.max_nbody + 1)), self.nfragments, self.return_total_data; ); else:; compute_dict = build_nbody_compute_list(self.bsse_type, nbodies, self.nfragments, self.return_total_data). def labeler(item) -> str:; mc_level_lbl = mc_level_idx + 1; return str(mc_level_lbl) + ""_"" + str(item). # Add current compute list to the master task list; # * `pair` looks like `((1,), (1, 3))` where first is real (not ghost) fragment indices; # and second is basis set fragment indices, all 1-indexed; for nb in compute_dict[""all""]:; for pair in compute_dict[""all""][nb]:; lbl = labeler(pair); if lbl in self.task_list:; continue. data = template; ghost = list(set(pair[1]) - set(pair[0])); data[""molecule""] = self.molecule.extract_subsets(list(pair[0]), ghost); if self.embedding_charges:; embedding_frags = list(set(range(1, self.nfragments + 1)) - set(pair[1])); charges = []; for frag in embedding_frags:; positions = self.molecule.extract_subsets(frag).geometry().np.tolist(); charges.extend([[chg, i] for i, chg in zip(positions, self.embedding_charges[frag])]); data['keywords']['function_kwargs'].update({'external_potentials': charges}). self.task_list[lbl] = mb_computer(**data); count += 1. return count. [docs] def plan(self):; # uncalled function; return [t.plan() for t in self.task_list.values()]. [docs] def compute(self, client: Optional[""qcportal.FractalClient""] = None):; """"""Run quantum chemistry."""""". info = ""\n"" + p4util.banner(f"" ManyBody Computations "", strNotOutfile=True) + ""\n""; #core.print_out(info); logger.info(info). with p4util.hold_options_state():; for t in self.task_list.values():; t.compute(client=client). [docs] def prepare_results(; self,; results: Optional[Dict[str, SubTaskComputers]] = None,; client: Optional[""qcportal.FractalClient""] = None,; ) -> Dict[str, Any]:; """"""Process the results from all n-body component molecular systems and model chemistry levels into final quantities. Parameters; ----------; results; A set of tasks to proc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_nbody.html:38937,charge,charges,38937,psi4manual/1.7.x/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_nbody.html,2,['charge'],['charges']
Energy Efficiency,"ompute_list(; [""nocp""], list(range(1, self.max_nbody + 1)), self.nfragments, self.return_total_data; ); else:; compute_dict = build_nbody_compute_list(self.bsse_type, nbodies, self.nfragments, self.return_total_data). def labeler(item) -> str:; mc_level_lbl = mc_level_idx + 1; return str(mc_level_lbl) + ""_"" + str(item). # Add current compute list to the master task list; # * `pair` looks like `((1,), (1, 3))` where first is real (not ghost) fragment indices; # and second is basis set fragment indices, all 1-indexed; for nb in compute_dict[""all""]:; for pair in compute_dict[""all""][nb]:; lbl = labeler(pair); if lbl in self.task_list:; continue. data = template; ghost = list(set(pair[1]) - set(pair[0])); data[""molecule""] = self.molecule.extract_subsets(list(pair[0]), ghost); if self.embedding_charges:; embedding_frags = list(set(range(1, self.nfragments + 1)) - set(pair[1])); charges = []; for frag in embedding_frags:; positions = self.molecule.extract_subsets(frag).geometry().np.tolist(); charges.extend([[chg, i] for i, chg in zip(positions, self.embedding_charges[frag])]); data['keywords']['function_kwargs'].update({'external_potentials': charges}). self.task_list[lbl] = mb_computer(**data); count += 1. return count. [docs]; def plan(self):; # uncalled function; return [t.plan() for t in self.task_list.values()]. [docs]; def compute(self, client: Optional[""qcportal.FractalClient""] = None):; """"""Run quantum chemistry."""""". info = ""\n"" + p4util.banner(f"" ManyBody Computations "", strNotOutfile=True) + ""\n""; #core.print_out(info); logger.info(info). with p4util.hold_options_state():; for t in self.task_list.values():; t.compute(client=client). [docs]; def prepare_results(; self,; results: Optional[Dict[str, SubTaskComputers]] = None,; client: Optional[""qcportal.FractalClient""] = None,; ) -> Dict[str, Any]:; """"""Process the results from all n-body component molecular systems and model chemistry levels into final quantities. Parameters; ----------; results; A set of tasks to p",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:39021,charge,charges,39021,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,6,['charge'],['charges']
Energy Efficiency,"ompute_list(; [""nocp""], list(range(1, self.max_nbody + 1)), self.nfragments, self.return_total_data; ); else:; compute_dict = build_nbody_compute_list(self.bsse_type, nbodies, self.nfragments, self.return_total_data). def labeler(item) -> str:; mc_level_lbl = mc_level_idx + 1; return str(mc_level_lbl) + ""_"" + str(item). # Add current compute list to the master task list; # * `pair` looks like `((1,), (1, 3))` where first is real (not ghost) fragment indices; # and second is basis set fragment indices, all 1-indexed; for nb in compute_dict[""all""]:; for pair in compute_dict[""all""][nb]:; lbl = labeler(pair); if lbl in self.task_list:; continue. data = template; ghost = list(set(pair[1]) - set(pair[0])); data[""molecule""] = self.molecule.extract_subsets(list(pair[0]), ghost); if self.embedding_charges:; embedding_frags = list(set(range(1, self.nfragments + 1)) - set(pair[1])); charges = []; for frag in embedding_frags:; positions = self.molecule.extract_subsets(frag).geometry().np.tolist(); charges.extend([[chg, i] for i, chg in zip(positions, self.embedding_charges[frag])]); data['keywords']['function_kwargs'].update({'external_potentials': charges}). self.task_list[lbl] = mb_computer(**data); count += 1. return count. def plan(self):; # uncalled function; return [t.plan() for t in self.task_list.values()]. [docs] def compute(self, client: Optional[""FractalClient""] = None):; """"""Run quantum chemistry."""""". info = ""\n"" + p4util.banner(f"" ManyBody Computations "", strNotOutfile=True) + ""\n""; #core.print_out(info); logger.info(info). with p4util.hold_options_state():; for t in self.task_list.values():; t.compute(client=client). [docs] def prepare_results(; self,; results: Optional[Dict[str, SubTaskComputers]] = None,; client: Optional[""FractalClient""] = None,; ) -> Dict[str, Any]:; """"""Process the results from all n-body component molecular systems and model chemistry levels into final quantities. Parameters; ----------; results; A set of tasks to process instead of self.task_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html:38537,charge,charges,38537,psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html,2,['charge'],['charges']
Energy Efficiency,"ompute_spin_contamination(self); docstring. cphf_Hx(self, arg0); CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self); Adds occupied guess alpha orbitals. cphf_solve(self, x_vec, conv_tol, max_iter); Solves the CPHF equations for a given set of x vectors. damping_update(self, arg0); docstring. deep_copy(self, arg0); Deep copies the internal data. del_array_variable(self, arg0); Removes the requested (case-insensitive) Matrix QC variable. del_potential_variable(self, arg0); Removes the requested (case-insensitive) ExternalPotential QC variable. del_scalar_variable(self, arg0); Removes the requested (case-insensitive) double QC variable. del_variable(key); Removes scalar or array QCVariable key from cls if present. density_fitted(self); Returns whether this wavefunction was obtained using density fitting or not. diis(self); docstring. doccpi(self); Returns the number of doubly occupied orbitals per irrep. efzc(self); Returns the frozen-core energy. energy(self); Returns the Wavefunction's energy. epsilon_a(self); Returns the Alpha Eigenvalues. epsilon_a_subset(self, basis, subset); Returns the requested Alpha orbital energies subset. epsilon_b(self); Returns the Beta Eigenvalues. epsilon_b_subset(self, basis, subset); Returns the requested Beta orbital energies subset. esp_at_nuclei(self); returns electrostatic potentials at nuclei. external_pot(self); Gets the requested external potential. finalize(self); Cleans up the the Wavefunction's temporary data. finalize_energy(); Performs stability analysis and calls back SCF with new guess if needed, Returns the SCF energy. find_occupation(self); docstring. force_doccpi(self, arg0); Specialized expert use only. force_soccpi(self, arg0); Specialized expert use only. form_C(self[, shift]); Forms the Orbital Matrices from the current Fock Matrices. form_D(self); Forms the Density Matrices from the current Orbitals Matrices. form_F(self); Forms the F matrix. form_FDSmSDF(self, arg0, arg1); Forms the residual of S",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.core.cuhf.html:4212,energy,energy,4212,psi4manual/1.5.0/api/psi4.core.cuhf.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.core.cuhf.html,20,['energy'],['energy']
Energy Efficiency,"omputed with cc-pVDZ-ri density fitting with ROHF. cc42; RHF-CC2-LR/STO-3G optical rotation of (S)-methyloxirane. gauge = length, omega = (589 355 nm). opt-irc-2; Compute the IRC for HCN <-> NCH interconversion at the RHF/DZP level of theory. cc3; cc3: RHF-CCSD/6-31G** H2O geometry optimization and vibrational frequency analysis by finite-differences of gradients. dft-freq; Frequencies for H2O B3LYP/6-31G* at optimized geometry. cc23; ROHF-EOM-CCSD/DZ analytic gradient lowest \(^{2}B_1\) state of H2O+ (A1 excitation). fnocc3; Test FNO-QCISD(T) computation. scf3; File retention, docc, socc, and bond distances specified explicitly. adc2; ADC/aug-cc-pVDZ on two water molecules that are distant from 1000 angstroms from each other. dfcasscf-sp; CASSCF/6-31G** energy point. opt10; 6-31G MP2 transition-state optimization with initial, computed Hessian. scf1; RHF cc-pVQZ energy for the BH molecule, with Cartesian input. pubchem2; Superficial test of PubChem interface. omp2p5-1; OMP2 cc-pVDZ energy for the H2O molecule. ao-dfcasscf-sp; CASSCF/6-31G** energy point. omp2-grad2; OMP2 cc-pVDZ gradient for the NO radical. dcft7; DCFT calculation for the triplet O2 using ODC-06 and ODC-12 functionals. Only simultaneous algorithm is tested. scf-guess-read1; Sample UHF/cc-pVDZ H2O computation on a doublet cation, using RHF/cc-pVDZ orbitals for the closed-shell neutral as a guess. cc43; RHF-CC2-LR/STO-3G optical rotation of (S)-methyloxirane. gauge = both, omega = (589 355 nm). cc41; RHF-CC2-LR/cc-pVDZ optical rotation of H2O2. gauge = both, omega = (589 355 nm). molden2; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. dfcasscf-sa-sp; Example of state-averaged CASSCF for the C2 molecule. dfomp3-grad2; DF-OMP3",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/testsuite-1.html:21649,energy,energy,21649,psi4manual/1.1.0/testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/testsuite-1.html,4,['energy'],['energy']
Energy Efficiency,"omputed wrt an old benchmark, S22A; >>> database('dfmp2','S22',cp=1,subset=[16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(); if not('db_name' in kwargs) and db_name:; kwargs['db_name'] = db_name. # Establish function to call; if not('db_func' in kwargs):; if ('func' in kwargs):; kwargs['db_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['db_func'] = energy; func = kwargs['db_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper database.' % (func.__name__)); if (func is cp):; raise ValidationError('Wrapper database is unhappy to be calling function \'%s\'. Use the cp keyword within database instead.' % (func.__name__)). # Define path and load module for requested database; sys.path.append('%sdatabases' % (PsiMod.Process.environment[""PSIDATADIR""])); sys.path.append('%s/lib/databases' % PsiMod.psi_top_srcdir()); database = import_ignorecase(db_name); if database is None:; PsiMod.print_out('\nPython module for database %s failed to load\n\n' % (db_name)); PsiMod.print_out('\nSearch path that was tried:\n'); PsiMod.print_out("", "".join(map(str, sys.path))); raise ValidationError(""Python module loading problem for database "" + str(db_name)); else:; dbse = database.dbse; HRXN = database.HRXN; ACTV = database.ACTV; RXNM = database.RXNM; BIND = database.BIND; TAGL = database.TAG",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html:29604,energy,energy,29604,psi4manual/4.0b3/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html,2,['energy'],['energy']
Energy Efficiency,"omputed. Examples:. >>> # [1] Moments with specific label; >>> E, wfn = energy('hf', return_wfn=True); >>> oeprop(wfn, 'DIPOLE', 'QUADRUPOLE', title='H3O+ SCF'). PSI4 is capable of computing a number of one-electron properties; summarized in the table below. Current one-electron property capabilities of PSI4¶. Feature; Keyword; Notes. Electric dipole moment; DIPOLE;  . Electric quadrupole moment; QUADRUPOLE; Raw (traced) moments and traceless multipoles. All moments up order N; MULTIPOLE(N); Only raw (traced) moments. Sets global variables e.g. “DIPOLE X”, “32-POLE XYYZZ”. Electrostatic potential, at nuclei; ESP_AT_NUCLEI; Sets global variables “ESP AT CENTER n”, n = 1 to natoms. Electrostatic potential, on grid; GRID_ESP; Generates V at each point in grid_esp.dat. See Properties evaluated on a grid. Electric field, on grid; GRID_FIELD; Generates {Ex,Ey,Ez} at each point grid_field.dat. See Properties evaluated on a grid. Molecular orbital extents; MO_EXTENTS;  . Mulliken atomic charges; MULLIKEN_CHARGES;  . Löwdin atomic charges; LOWDIN_CHARGES;  . Wiberg bond indices; WIBERG_LOWDIN_INDICES; Uses (Löwdin) symmetrically orthogonalized orbitals. Mayer bond indices; MAYER_INDICES;  . Natural orbital occupations; NO_OCCUPATIONS;  . There are two ways the computation of one-electron properties can be requested.; Firstly, the properties can be evaluated from the last; computed one-particle density, using the following syntax:; 1oeprop(""MO_EXTENTS"", ""MULTIPOLE(4)"", title = ""hello!""). Note that it is the user’s responsibility to ensure that the relaxed density; matrix is computed using the method of interest, which may require setting; additional keywords (see the method’s manual section for details). The named; argument, title, is completely optional and is prepended to any; globals variables set during the computation. The unnamed arguments are the; properties to be computed. These can appear in any order, and multiple; properties may be requested, as in the example abov",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/oeprop-1.html:1604,charge,charges,1604,psi4manual/1.3.2/oeprop-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/oeprop-1.html,2,['charge'],['charges']
Energy Efficiency,"omputed. Examples:. >>> # [1] Moments with specific label; >>> E, wfn = energy('hf', return_wfn=True); >>> oeprop(wfn, 'DIPOLE', 'QUADRUPOLE', title='H3O+ SCF'). Psi4 is capable of computing a number of one-electron properties; summarized in the table below. Current one-electron property capabilities of Psi4¶. Feature; Keyword; Notes. Electric dipole moment; DIPOLE;  . Electric quadrupole moment; QUADRUPOLE; Raw (traced) moments and traceless multipoles. All moments up order N; MULTIPOLE(N); Only raw (traced) moments. Sets global variables e.g. “DIPOLE X”, “32-POLE XYYZZ”. Electrostatic potential, at nuclei; ESP_AT_NUCLEI; Sets global variables “ESP AT CENTER n”, n = 1 to natoms. Electrostatic potential, on grid; GRID_ESP; Generates V at each point in grid_esp.dat. See Properties evaluated on a grid. Electric field, on grid; GRID_FIELD; Generates {Ex,Ey,Ez} at each point grid_field.dat. See Properties evaluated on a grid. Molecular orbital extents; MO_EXTENTS;  . Mulliken atomic charges; MULLIKEN_CHARGES;  . Löwdin atomic charges; LOWDIN_CHARGES;  . Wiberg bond indices; WIBERG_LOWDIN_INDICES; Uses (Löwdin) symmetrically orthogonalized orbitals. Mayer bond indices; MAYER_INDICES;  . Natural orbital occupations; NO_OCCUPATIONS;  . There are two ways the computation of one-electron properties can be requested.; Firstly, the properties can be evaluated from the last; computed one-particle density, using the following syntax:; oeprop(""MO_EXTENTS"", ""MULTIPOLE(4)"", title = ""hello!""). Note that it is the user’s responsibility to ensure that the relaxed density; matrix is computed using the method of interest, which may require setting; additional keywords (see the method’s manual section for details). The named; argument, title, is completely optional and is prepended to any; globals variables set during the computation. The unnamed arguments are the; properties to be computed. These can appear in any order, and multiple; properties may be requested, as in the example above",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/oeprop-1.html:1645,charge,charges,1645,psi4manual/1.0.0/oeprop-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/oeprop-1.html,2,['charge'],['charges']
Energy Efficiency,"oms; self.PYnunique = 0; # Number of equivalent atoms per unique atom (length nunique); self.nequiv = 0; # Equivalent atom mapping array; self.equiv = 0; # Atom to unique atom mapping array (length natom); self.PYatom_to_unique = 0. if psi4molstr:; self.create_molecule_from_string(psi4molstr). # <<< Simple Methods for Basic Molecule Information >>>. [docs] def name(self):; """"""Get molecule name. >>> print H2OH2O.name(); water_dimer. """"""; return self.PYname. [docs] def set_name(self, name):; """"""Set molecule name. >>> H2OH2O.set_name('water_dimer'). """"""; self.PYname = name. [docs] def natom(self):; """"""Number of atoms. >>> print H2OH2O.natom(); 6. """"""; return len(self.atoms). [docs] def nallatom(self):; """"""Number of all atoms (includes dummies). >>> print H2OH2O.nallatom(); 7. """"""; return len(self.full_atoms). [docs] def molecular_charge(self):; """"""Gets the molecular charge. >>> print H2OH2O.molecular_charge(); -2. """"""; return self.PYmolecular_charge. [docs] def set_molecular_charge(self, charge):; """"""Sets the molecular charge. >>> H2OH2O.set_molecular_charge(-2). """"""; self.PYcharge_specified = True; self.PYmolecular_charge = charge. [docs] def charge_specified(self):; """"""Whether the charge was given by the user. >>> print H2OH2O.charge_specified(); True. """"""; return self.PYcharge_specified. [docs] def multiplicity(self):; """"""Get the multiplicity (defined as 2Ms + 1). >>> print H2OH2O.multiplicity(). """"""; return self.PYmultiplicity. [docs] def set_multiplicity(self, mult):; """"""Sets the multiplicity (defined as 2Ms + 1). >>> H2OH2O.set_multiplicity(3). """"""; self.PYmultiplicity_specified = True; self.PYmultiplicity = mult. [docs] def multiplicity_specified(self):; """"""Whether the multiplicity was given by the user. >>> print H2OH2O.multiplicity_specified(); True. """"""; return self.PYmultiplicity_specified. [docs] def units(self):; """"""Gets the geometry units. >>> print H2OH2O.units(); Angstrom. """"""; return self.PYunits. [docs] def set_units(self, units):; """"""Sets the geometr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html:4525,charge,charge,4525,psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html,12,['charge'],['charge']
Energy Efficiency,"on -c ""import psi4"". How to run Psi4 as Python module after compilation¶; Substituting the full installation directory prefix and a; suitable scratch directory, issue the following commands directly in your; terminal or place them into your “rc” file and open a new terminal. (To; use a staged installation directory, substitute; objdir/stage for prefix.); # csh, tcsh: add to shell or ~/.tcshrc file; setenv PYTHONPATH {prefix}/lib:$PYTHONPATH; setenv PSI_SCRATCH /path/to/existing/writable/local-not-network/directory/for/scratch/files. # sh, bash: add to shell or ~/.bashrc (Linux/Windows) or ~/.bash_profile (Mac) file; export PYTHONPATH={prefix}/lib:$PYTHONPATH; export PSI_SCRATCH=/path/to/existing/writable/local-not-network/directory/for/scratch/files. How to configure paths for PsiAPI. Run PSI4.; 1; 2; 3; 4; 5; 6; 7; 8; 9>>> cat sample.py; import psi4; mol = psi4.geometry(""""""; He; """"""); psi4.energy('hf/cc-pvdz'); psi4.compare_values(-2.85518839, psi4.core.get_variable('current energy'), 5, 'SCF E'); >>> python sample.py; SCF E.............................................................PASSED. How to run Psi4 as executable or Python module from conda installation¶; The configuration commands below are generic versions of the ones printed; to your screen as advice upon installing PSI4 into a Anaconda,; Miniconda, or Psi4conda distribution, condadist =; ana|mini|psi4conda. To see the message again after initial installation,; with the conda environment active, run .psi4-post-link.sh.; If which conda python psi4 points to your; condadist and echo $PSI_SCRATCH is set, skip ahead to the; “Run PSI4” commands below. Otherwise, issue the following; commands directly in your terminal or place them into your “rc” file and; open a new terminal.; If you installed the Psi4conda distribution or installed the PSI4; conda package into the main environment of an Anaconda or Miniconda; distribution and added that to your PATH, as prompted, then; which psi4 likely yields condadist/bin/p",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/build_planning-1.html:25582,energy,energy,25582,psi4manual/1.3.2/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/build_planning-1.html,2,['energy'],['energy']
