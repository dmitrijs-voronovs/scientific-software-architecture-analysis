quality_attribute,sentence,source,author,repo,version,id,keyword,matched_word,match_idx,filename,wiki,url,total_similar,target_keywords,target_matched_words
Energy Efficiency,"2VirtualXProxy.cxx:168; TGraphErrors.h; TLegend.h; TMath.h; TRandom.h; TAttLine::SetLineWidthvirtual void SetLineWidth(Width_t lwidth)Set the line width.Definition TAttLine.h:43; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TAttMarker::SetMarkerColorvirtual void SetMarkerColor(Color_t mcolor=1)Set the marker color.Definition TAttMarker.h:38; TCanvasThe Canvas class.Definition TCanvas.h:23; TF11-Dim function classDefinition TF1.h:233; TGraphErrorsA TGraphErrors is a TGraph with error bars.Definition TGraphErrors.h:26; TGraph::GetFunctionTF1 * GetFunction(const char *name) constReturn pointer to function with name.Definition TGraph.cxx:1416; TGraph::Fitvirtual TFitResultPtr Fit(const char *formula, Option_t *option="""", Option_t *goption="""", Axis_t xmin=0, Axis_t xmax=0)Fit this graph with function with name fname.Definition TGraph.cxx:1254; TGraph::Drawvoid Draw(Option_t *chopt="""") overrideDraw this graph with its current attributes.Definition TGraph.cxx:831; TLegendThis class displays a legend box (TPaveText) containing several legend entries.Definition TLegend.h:23; TNamed::SetNamevirtual void SetName(const char *name)Set the name of the TNamed.Definition TNamed.cxx:140; TPad::SetGridvoid SetGrid(Int_t valuex=1, Int_t valuey=1) overrideDefinition TPad.h:335; TRandomThis is the base class for the ROOT Random number generators.Definition TRandom.h:27; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; leglegDefinition legend1.C:34; TMath::ExpDouble_t Exp(Double_t x)Returns the base-e exponential function of x, which is e raised to the power x.Definition TMath.h:709; TMath::SinDouble_t Sin(Double_t)Returns the sine of an angle of x radians.Definition TMath.h:588; AuthorAnna Kreshuk ; Definition in file fitLinear.C. tutorialsfitfitLinear.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/fitLinear_8C.html:5807,power,power,5807,doc/master/fitLinear_8C.html,https://root.cern,https://root.cern/doc/master/fitLinear_8C.html,1,['power'],['power']
Energy Efficiency,"2].blue = 138;; 79 colors[13].red = 20; colors[13].green = 20; colors[13].blue = 184;; 80 colors[14].red = 71; colors[14].green = 71; colors[14].blue = 235;; 81 colors[15].red = 117; colors[15].green = 117; colors[15].blue = 240;; 82 colors[16].red = 138; colors[16].green = 138; colors[16].blue = 15;; 83 colors[17].red = 184; colors[17].green = 184; colors[17].blue = 20;; 84 colors[18].red = 235; colors[18].green = 235; colors[18].blue = 71;; 85 colors[19].red = 240; colors[19].green = 240; colors[19].blue = 117;; 86 colors[20].red = 138; colors[20].green = 15; colors[20].blue = 138;; 87 colors[21].red = 184; colors[21].green = 20; colors[21].blue = 184;; 88 colors[22].red = 235; colors[22].green = 71; colors[22].blue = 235;; 89 colors[23].red = 240; colors[23].green = 117; colors[23].blue = 240;; 90 colors[24].red = 15; colors[24].green = 138; colors[24].blue = 138;; 91 colors[25].red = 20; colors[25].green = 184; colors[25].blue = 184;; 92 colors[26].red = 71; colors[26].green = 235; colors[26].blue = 235;; 93 colors[27].red = 117; colors[27].green = 240; colors[27].blue = 240;; 94 }; 95 ; 96 ; 97 /*; 98 * Allocate memory for segments; 99 */; 100 ; 101 if (gSize3D.numSegs) {; 102 segs = (segment *) calloc (gSize3D.numSegs, sizeof (segment));; 103 if (!segs) {; 104 puts (""Unable to allocate memory for segments !"");; 105 ret = 0;; 106 }; 107 }; 108 ; 109 ; 110 /*; 111 * Allocate memory for polygons; 112 */; 113 ; 114 if (gSize3D.numPolys) {; 115 polys = (polygon *) calloc(gSize3D.numPolys, sizeof (polygon));; 116 if (!polys) {; 117 puts (""Unable to allocate memory for polygons !"");; 118 ret = 0;; 119 }; 120 }; 121 ; 122 /*; 123 * In case of error, free allocated memory; 124 */; 125 ; 126 ; 127 if (!ret) {; 128 if (points) free (points);; 129 if (colors) free (colors);; 130 if (segs) free (segs);; 131 if (polys) free (polys);; 132 ; 133 points = NULL;; 134 colors = NULL;; 135 segs = NULL;; 136 polys = NULL;; 137 }; 138 ; 139 return (ret);; 140}; 141 ; 142void FillX3D",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/X3DBuffer_8c_source.html:3552,green,green,3552,doc/master/X3DBuffer_8c_source.html,https://root.cern,https://root.cern/doc/master/X3DBuffer_8c_source.html,1,['green'],['green']
Energy Efficiency,"3 ; 2974void TGX11::MakeOpaqueColors(Int_t percent, ULong_t *orgcolors, Int_t ncolors); 2975{; 2976 if (ncolors == 0) return;; 2977 ; 2978 RXColor *xcol = new RXColor[ncolors];; 2979 ; 2980 int i;; 2981 for (i = 0; i < ncolors; i++) {; 2982 xcol[i].pixel = orgcolors[i];; 2983 xcol[i].red = xcol[i].green = xcol[i].blue = 0;; 2984 xcol[i].flags = DoRed | DoGreen | DoBlue;; 2985 }; 2986 QueryColors(fColormap, xcol, ncolors);; 2987 ; 2988 UShort_t add = percent * kBIGGEST_RGB_VALUE / 100;; 2989 ; 2990 Int_t val;; 2991 for (i = 0; i < ncolors; i++) {; 2992 val = xcol[i].red + add;; 2993 if (val > kBIGGEST_RGB_VALUE) val = kBIGGEST_RGB_VALUE;; 2994 xcol[i].red = (UShort_t) val;; 2995 val = xcol[i].green + add;; 2996 if (val > kBIGGEST_RGB_VALUE) val = kBIGGEST_RGB_VALUE;; 2997 xcol[i].green = (UShort_t) val;; 2998 val = xcol[i].blue + add;; 2999 if (val > kBIGGEST_RGB_VALUE) val = kBIGGEST_RGB_VALUE;; 3000 xcol[i].blue = (UShort_t) val;; 3001 if (!AllocColor(fColormap, &xcol[i])); 3002 Warning(""MakeOpaqueColors"", ""failed to allocate color %hd, %hd, %hd"",; 3003 xcol[i].red, xcol[i].green, xcol[i].blue);; 3004 // assumes that in case of failure xcol[i].pixel is not changed; 3005 }; 3006 ; 3007 gCws->fNewColors = new ULong_t[ncolors];; 3008 gCws->fNcolors = ncolors;; 3009 ; 3010 for (i = 0; i < ncolors; i++); 3011 gCws->fNewColors[i] = xcol[i].pixel;; 3012 ; 3013 delete [] xcol;; 3014}; 3015 ; 3016////////////////////////////////////////////////////////////////////////////////; 3017/// Returns index in orgcolors (and fNewColors) for pixel.; 3018 ; 3019Int_t TGX11::FindColor(ULong_t pixel, ULong_t *orgcolors, Int_t ncolors); 3020{; 3021 for (int i = 0; i < ncolors; i++); 3022 if (pixel == orgcolors[i]) return i;; 3023 ; 3024 Error(""FindColor"", ""did not find color, should never happen!"");; 3025 ; 3026 return 0;; 3027}; 3028 ; 3029////////////////////////////////////////////////////////////////////////////////; 3030/// Set color intensities for given color index.; 3031///; 3032/",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGX11_8cxx_source.html:100103,allocate,allocate,100103,doc/master/TGX11_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html,1,['allocate'],['allocate']
Energy Efficiency,"3 of file MethodBoost.h. ◆ fDataSetManager. DataSetManager* TMVA::MethodBoost::fDataSetManager. private . DSMTEST. ; Definition at line 193 of file MethodBoost.h. ◆ fDetailedMonitoring. Bool_t TMVA::MethodBoost::fDetailedMonitoring. private . produce detailed monitoring histograms (boost-wise) ; Definition at line 157 of file MethodBoost.h. ◆ fHistoricBoolOption. Bool_t TMVA::MethodBoost::fHistoricBoolOption. private . historic variable, only needed for ""CompatibilityOptions"" ; Definition at line 195 of file MethodBoost.h. ◆ fHistoricOption. TString TMVA::MethodBoost::fHistoricOption. private . historic variable, only needed for ""CompatibilityOptions"" ; Definition at line 194 of file MethodBoost.h. ◆ fMethodError. Double_t TMVA::MethodBoost::fMethodError. private . estimation of the level error of the classifier ; Definition at line 183 of file MethodBoost.h. ◆ fMonitorBoostedMethod. Bool_t TMVA::MethodBoost::fMonitorBoostedMethod. private . monitor the MVA response of every classifier ; Definition at line 167 of file MethodBoost.h. ◆ fMonitorTree. TTree* TMVA::MethodBoost::fMonitorTree. private . tree to monitor values during the boosting ; Definition at line 181 of file MethodBoost.h. ◆ fMVAvalues. std::vector<Float_t>* TMVA::MethodBoost::fMVAvalues. private . mva values for the last trained method ; Definition at line 191 of file MethodBoost.h. ◆ fOverlap_integral. Double_t TMVA::MethodBoost::fOverlap_integral. private . Definition at line 189 of file MethodBoost.h. ◆ fRandomSeed. UInt_t TMVA::MethodBoost::fRandomSeed. private . seed for random number generator used for bagging ; Definition at line 160 of file MethodBoost.h. ◆ fROC_training. Double_t TMVA::MethodBoost::fROC_training. private . roc integral of last trained method (on training sample) ; Definition at line 185 of file MethodBoost.h. ◆ fTestBgdMVAHist. std::vector< TH1* > TMVA::MethodBoost::fTestBgdMVAHist. private . Definition at line 178 of file MethodBoost.h. ◆ fTestSigMVAHist. std::vector< TH1* > ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodBoost.html:44351,monitor,monitor,44351,doc/master/classTMVA_1_1MethodBoost.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodBoost.html,1,['monitor'],['monitor']
Energy Efficiency,"3 of file RooDataHist.cxx. ◆ printArgs(). void RooDataHist::printArgs ; (; std::ostream & ; os); const. overridevirtual . Print argument of dataset, i.e. the observable names. ; Reimplemented from RooPrintable.; Definition at line 2263 of file RooDataHist.cxx. ◆ printDataHistogram(). void RooDataHist::printDataHistogram ; (; std::ostream & ; os, . RooRealVar * ; obs . ); const. Definition at line 2320 of file RooDataHist.cxx. ◆ printMultiline(). void RooDataHist::printMultiline ; (; std::ostream & ; os, . Int_t ; content, . bool ; verbose = false, . TString ; indent = """" . ); const. overridevirtual . Print the details on the dataset contents. ; Reimplemented from RooAbsData.; Definition at line 2299 of file RooDataHist.cxx. ◆ printValue(). void RooDataHist::printValue ; (; std::ostream & ; os); const. overridevirtual . Print value of the dataset, i.e. the sum of weights contained in the dataset. ; Reimplemented from RooPrintable.; Definition at line 2252 of file RooDataHist.cxx. ◆ reduceEng(). std::unique_ptr< RooAbsData > RooDataHist::reduceEng ; (; const RooArgSet & ; varSubset, . const RooFormulaVar * ; cutVar, . const char * ; cutRange = nullptr, . std::size_t ; nStart = 0, . std::size_t ; nStop = std::numeric_limits<std::size_t>::max() . ); const. overrideprotectedvirtual . Implementation of RooAbsData virtual method that drives the RooAbsData::reduce() methods. ; Implements RooAbsData.; Definition at line 916 of file RooDataHist.cxx. ◆ registerWeightArraysToDataStore(). void RooDataHist::registerWeightArraysToDataStore ; (; ); const. private . Hand over pointers to our weight arrays to the data store implementation. ; Definition at line 2413 of file RooDataHist.cxx. ◆ removeSelfFromDir(). void RooDataHist::removeSelfFromDir ; (; ). inline . Definition at line 164 of file RooDataHist.h. ◆ reset(). void RooDataHist::reset ; (; ). overridevirtual . Reset all bin weights to zero. ; Reimplemented from RooAbsData.; Definition at line 2158 of file RooDataHist.cxx. ◆ s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooDataHist.html:73910,reduce,reduceEng,73910,doc/master/classRooDataHist.html,https://root.cern,https://root.cern/doc/master/classRooDataHist.html,1,['reduce'],['reduceEng']
Energy Efficiency,"3./255., 167./255., 211./255., 117./255., 0./255., 0./255., 0./255.};; 3549 Double_t blue[9] = { 51./255., 203./255., 177./255., 26./255., 10./255., 9./255., 8./255., 3./255., 0./255.};; 3550 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3551 }; 3552 break;; 3553 ; 3554 // Water Melon; 3555 case 108:; 3556 {; 3557 Double_t red[9] = { 19./255., 42./255., 64./255., 88./255., 118./255., 147./255., 175./255., 187./255., 205./255.};; 3558 Double_t green[9] = { 19./255., 55./255., 89./255., 125./255., 154./255., 169./255., 161./255., 129./255., 70./255.};; 3559 Double_t blue[9] = { 19./255., 32./255., 47./255., 70./255., 100./255., 128./255., 145./255., 130./255., 75./255.};; 3560 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3561 }; 3562 break;; 3563 ; 3564 // Cool; 3565 case 109:; 3566 {; 3567 Double_t red[9] = { 33./255., 31./255., 42./255., 68./255., 86./255., 111./255., 141./255., 172./255., 227./255.};; 3568 Double_t green[9] = { 255./255., 175./255., 145./255., 106./255., 88./255., 55./255., 15./255., 0./255., 0./255.};; 3569 Double_t blue[9] = { 255./255., 205./255., 202./255., 203./255., 208./255., 205./255., 203./255., 206./255., 231./255.};; 3570 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3571 }; 3572 break;; 3573 ; 3574 // Copper; 3575 case 110:; 3576 {; 3577 Double_t red[9] = { 0./255., 25./255., 50./255., 79./255., 110./255., 145./255., 181./255., 201./255., 254./255.};; 3578 Double_t green[9] = { 0./255., 16./255., 30./255., 46./255., 63./255., 82./255., 101./255., 124./255., 179./255.};; 3579 Double_t blue[9] = { 0./255., 12./255., 21./255., 29./255., 39./255., 49./255., 61./255., 74./255., 103./255.};; 3580 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3581 }; 3582 break;; 3583 ; 3584 // Gist Earth; 3585 case 111:; 3586 {; 3587 Double_t red[9] = { 0./255., 13./255., 30./255., 44./255., 72./255., 120./255., 156./255.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TColor_8cxx_source.html:141992,green,green,141992,doc/master/TColor_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html,1,['green'],['green']
Energy Efficiency,"3025 case 55:; 3026 {; 3027 Double_t red[9] = { 0./255., 5./255., 15./255., 35./255., 102./255., 196./255., 208./255., 199./255., 110./255.};; 3028 Double_t green[9] = { 0./255., 48./255., 124./255., 192./255., 206./255., 226./255., 97./255., 16./255., 0./255.};; 3029 Double_t blue[9] = { 99./255., 142./255., 198./255., 201./255., 90./255., 22./255., 13./255., 8./255., 2./255.};; 3030 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3031 }; 3032 break;; 3033 ; 3034 // Inverted Dark Body Radiator; 3035 case 56:; 3036 {; 3037 Double_t red[9] = { 242./255., 234./255., 237./255., 230./255., 212./255., 156./255., 99./255., 45./255., 0./255.};; 3038 Double_t green[9] = { 243./255., 238./255., 238./255., 168./255., 101./255., 45./255., 0./255., 0./255., 0./255.};; 3039 Double_t blue[9] = { 230./255., 95./255., 11./255., 8./255., 9./255., 3./255., 1./255., 1./255., 0./255.};; 3040 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3041 }; 3042 break;; 3043 ; 3044 // Bird; 3045 case 57:; 3046 {; 3047 Double_t red[9] = { 0.2082, 0.0592, 0.0780, 0.0232, 0.1802, 0.5301, 0.8186, 0.9956, 0.9764};; 3048 Double_t green[9] = { 0.1664, 0.3599, 0.5041, 0.6419, 0.7178, 0.7492, 0.7328, 0.7862, 0.9832};; 3049 Double_t blue[9] = { 0.5293, 0.8684, 0.8385, 0.7914, 0.6425, 0.4662, 0.3499, 0.1968, 0.0539};; 3050 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3051 }; 3052 break;; 3053 ; 3054 // Cubehelix; 3055 case 58:; 3056 {; 3057 Double_t red[9] = { 0.0000, 0.0956, 0.0098, 0.2124, 0.6905, 0.9242, 0.7914, 0.7596, 1.0000};; 3058 Double_t green[9] = { 0.0000, 0.1147, 0.3616, 0.5041, 0.4577, 0.4691, 0.6905, 0.9237, 1.0000};; 3059 Double_t blue[9] = { 0.0000, 0.2669, 0.3121, 0.1318, 0.2236, 0.6741, 0.9882, 0.9593, 1.0000};; 3060 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3061 }; 3062 break;; 3063 ; 3064 // Green Red Violet; 3065 case 59:; 3066 {; 3067 Double_t red",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TColor_8cxx_source.html:114666,green,green,114666,doc/master/TColor_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html,1,['green'],['green']
Energy Efficiency,"3106 {; 3107 Double_t red[9] = { 50./255., 56./255., 63./255., 68./255., 93./255., 121./255., 165./255., 192./255., 241./255.};; 3108 Double_t green[9] = { 66./255., 81./255., 91./255., 96./255., 111./255., 128./255., 155./255., 189./255., 241./255.};; 3109 Double_t blue[9] = { 97./255., 91./255., 75./255., 65./255., 77./255., 103./255., 143./255., 167./255., 217./255.};; 3110 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3111 }; 3112 break;; 3113 ; 3114 // Aquamarine; 3115 case 64:; 3116 {; 3117 Double_t red[9] = { 145./255., 166./255., 167./255., 156./255., 131./255., 114./255., 101./255., 112./255., 132./255.};; 3118 Double_t green[9] = { 158./255., 178./255., 179./255., 181./255., 163./255., 154./255., 144./255., 152./255., 159./255.};; 3119 Double_t blue[9] = { 190./255., 199./255., 201./255., 192./255., 176./255., 169./255., 160./255., 166./255., 190./255.};; 3120 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3121 }; 3122 break;; 3123 ; 3124 // Army; 3125 case 65:; 3126 {; 3127 Double_t red[9] = { 93./255., 91./255., 99./255., 108./255., 130./255., 125./255., 132./255., 155./255., 174./255.};; 3128 Double_t green[9] = { 126./255., 124./255., 128./255., 129./255., 131./255., 121./255., 119./255., 153./255., 173./255.};; 3129 Double_t blue[9] = { 103./255., 94./255., 87./255., 85./255., 80./255., 85./255., 107./255., 120./255., 146./255.};; 3130 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3131 }; 3132 break;; 3133 ; 3134 // Atlantic; 3135 case 66:; 3136 {; 3137 Double_t red[9] = { 24./255., 40./255., 69./255., 90./255., 104./255., 114./255., 120./255., 132./255., 103./255.};; 3138 Double_t green[9] = { 29./255., 52./255., 94./255., 127./255., 150./255., 162./255., 159./255., 151./255., 101./255.};; 3139 Double_t blue[9] = { 29./255., 52./255., 96./255., 132./255., 162./255., 181./255., 184./255., 186./255., 131./255.};; 3140 Idx = TColor::CreateGradientColor",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TColor_8cxx_source.html:118698,green,green,118698,doc/master/TColor_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html,1,['green'],['green']
Energy Efficiency,"3265 case 79:; 3266 {; 3267 Double_t red[9] = { 49./255., 59./255., 72./255., 88./255., 114./255., 141./255., 176./255., 205./255., 222./255.};; 3268 Double_t green[9] = { 78./255., 72./255., 66./255., 57./255., 59./255., 75./255., 106./255., 142./255., 173./255.};; 3269 Double_t blue[9] = { 78./255., 55./255., 46./255., 40./255., 39./255., 39./255., 40./255., 41./255., 47./255.};; 3270 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3271 }; 3272 break;; 3273 ; 3274 // Fruit Punch; 3275 case 80:; 3276 {; 3277 Double_t red[9] = { 243./255., 222./255., 201./255., 185./255., 165./255., 158./255., 166./255., 187./255., 219./255.};; 3278 Double_t green[9] = { 94./255., 108./255., 132./255., 135./255., 125./255., 96./255., 68./255., 51./255., 61./255.};; 3279 Double_t blue[9] = { 7./255., 9./255., 12./255., 19./255., 45./255., 89./255., 118./255., 146./255., 118./255.};; 3280 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3281 }; 3282 break;; 3283 ; 3284 // Fuchsia; 3285 case 81:; 3286 {; 3287 Double_t red[9] = { 19./255., 44./255., 74./255., 105./255., 137./255., 166./255., 194./255., 206./255., 220./255.};; 3288 Double_t green[9] = { 19./255., 28./255., 40./255., 55./255., 82./255., 110./255., 159./255., 181./255., 220./255.};; 3289 Double_t blue[9] = { 19./255., 42./255., 68./255., 96./255., 129./255., 157./255., 188./255., 203./255., 220./255.};; 3290 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3291 }; 3292 break;; 3293 ; 3294 // Grey Yellow; 3295 case 82:; 3296 {; 3297 Double_t red[9] = { 33./255., 44./255., 70./255., 99./255., 140./255., 165./255., 199./255., 211./255., 216./255.};; 3298 Double_t green[9] = { 38./255., 50./255., 76./255., 105./255., 140./255., 165./255., 191./255., 189./255., 167./255.};; 3299 Double_t blue[9] = { 55./255., 67./255., 97./255., 124./255., 140./255., 166./255., 163./255., 129./255., 52./255.};; 3300 Idx = TColor::CreateGradientColor",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TColor_8cxx_source.html:127074,green,green,127074,doc/master/TColor_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html,1,['green'],['green']
Energy Efficiency,"334///; 1335/// Works on arguments (min and max from fBuffer) and internal inputs: fXmin,; 1336/// fXmax, NBinsX (from fXaxis), ...; 1337/// Result save internally in fXaxis.; 1338///; 1339/// Overloaded by TH2 and TH3.; 1340///; 1341/// Return -1 if internal inputs are inconsistent, 0 otherwise.; 1342 ; 1343Int_t TH1::AutoP2FindLimits(Double_t xmi, Double_t xma); 1344{; 1345 // We need meaningful raw limits; 1346 if (xmi >= xma); 1347 return -1;; 1348 ; 1349 THLimitsFinder::GetLimitsFinder()->FindGoodLimits(this, xmi, xma);; 1350 Double_t xhmi = fXaxis.GetXmin();; 1351 Double_t xhma = fXaxis.GetXmax();; 1352 ; 1353 // Now adjust; 1354 if (TMath::Abs(xhma) > TMath::Abs(xhmi)) {; 1355 // Start from the upper limit; 1356 xhma = TH1::AutoP2GetPower2(xhma);; 1357 xhmi = xhma - TH1::AutoP2GetPower2(xhma - xhmi);; 1358 } else {; 1359 // Start from the lower limit; 1360 xhmi = TH1::AutoP2GetPower2(xhmi, kFALSE);; 1361 xhma = xhmi + TH1::AutoP2GetPower2(xhma - xhmi);; 1362 }; 1363 ; 1364 // Round the bins to the next power of 2; take into account the possible inflation; 1365 // of the range; 1366 Double_t rr = (xhma - xhmi) / (xma - xmi);; 1367 Int_t nb = TH1::AutoP2GetBins((Int_t)(rr * GetNbinsX()));; 1368 ; 1369 // Adjust using the same bin width and offsets; 1370 Double_t bw = (xhma - xhmi) / nb;; 1371 // Bins to left free on each side; 1372 Double_t autoside = gEnv->GetValue(""Hist.Binning.Auto.Side"", 0.05);; 1373 Int_t nbside = (Int_t)(nb * autoside);; 1374 ; 1375 // Side up; 1376 Int_t nbup = (xhma - xma) / bw;; 1377 if (nbup % 2 != 0); 1378 nbup++; // Must be even; 1379 if (nbup != nbside) {; 1380 // Accounts also for both case: larger or smaller; 1381 xhma -= bw * (nbup - nbside);; 1382 nb -= (nbup - nbside);; 1383 }; 1384 ; 1385 // Side low; 1386 Int_t nblw = (xmi - xhmi) / bw;; 1387 if (nblw % 2 != 0); 1388 nblw++; // Must be even; 1389 if (nblw != nbside) {; 1390 // Accounts also for both case: larger or smaller; 1391 xhmi += bw * (nblw - nbside);; 1392 nb -= (nbl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:53658,power,power,53658,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,1,['power'],['power']
Energy Efficiency,"3357 Double_t red[9] = { 123./255., 108./255., 109./255., 126./255., 154./255., 172./255., 188./255., 196./255., 218./255.};; 3358 Double_t green[9] = { 184./255., 138./255., 130./255., 133./255., 154./255., 175./255., 188./255., 196./255., 218./255.};; 3359 Double_t blue[9] = { 208./255., 130./255., 109./255., 99./255., 110./255., 122./255., 150./255., 171./255., 218./255.};; 3360 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3361 }; 3362 break;; 3363 ; 3364 // Mint; 3365 case 89:; 3366 {; 3367 Double_t red[9] = { 105./255., 106./255., 122./255., 143./255., 159./255., 172./255., 176./255., 181./255., 207./255.};; 3368 Double_t green[9] = { 252./255., 197./255., 194./255., 187./255., 174./255., 162./255., 153./255., 136./255., 125./255.};; 3369 Double_t blue[9] = { 146./255., 133./255., 144./255., 155./255., 163./255., 167./255., 166./255., 162./255., 174./255.};; 3370 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3371 }; 3372 break;; 3373 ; 3374 // Neon; 3375 case 90:; 3376 {; 3377 Double_t red[9] = { 171./255., 141./255., 145./255., 152./255., 154./255., 159./255., 163./255., 158./255., 177./255.};; 3378 Double_t green[9] = { 236./255., 143./255., 100./255., 63./255., 53./255., 55./255., 44./255., 31./255., 6./255.};; 3379 Double_t blue[9] = { 59./255., 48./255., 46./255., 44./255., 42./255., 54./255., 82./255., 112./255., 179./255.};; 3380 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3381 }; 3382 break;; 3383 ; 3384 // Pastel; 3385 case 91:; 3386 {; 3387 Double_t red[9] = { 180./255., 190./255., 209./255., 223./255., 204./255., 228./255., 205./255., 152./255., 91./255.};; 3388 Double_t green[9] = { 93./255., 125./255., 147./255., 172./255., 181./255., 224./255., 233./255., 198./255., 158./255.};; 3389 Double_t blue[9] = { 236./255., 218./255., 160./255., 133./255., 114./255., 132./255., 162./255., 220./255., 218./255.};; 3390 Idx = TColor::CreateGradientColor",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TColor_8cxx_source.html:131845,green,green,131845,doc/master/TColor_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html,1,['green'],['green']
Energy Efficiency,"3387 Double_t red[9] = { 180./255., 190./255., 209./255., 223./255., 204./255., 228./255., 205./255., 152./255., 91./255.};; 3388 Double_t green[9] = { 93./255., 125./255., 147./255., 172./255., 181./255., 224./255., 233./255., 198./255., 158./255.};; 3389 Double_t blue[9] = { 236./255., 218./255., 160./255., 133./255., 114./255., 132./255., 162./255., 220./255., 218./255.};; 3390 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3391 }; 3392 break;; 3393 ; 3394 // Pearl; 3395 case 92:; 3396 {; 3397 Double_t red[9] = { 225./255., 183./255., 162./255., 135./255., 115./255., 111./255., 119./255., 145./255., 211./255.};; 3398 Double_t green[9] = { 205./255., 177./255., 166./255., 135./255., 124./255., 117./255., 117./255., 132./255., 172./255.};; 3399 Double_t blue[9] = { 186./255., 165./255., 155./255., 135./255., 126./255., 130./255., 150./255., 178./255., 226./255.};; 3400 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3401 }; 3402 break;; 3403 ; 3404 // Pigeon; 3405 case 93:; 3406 {; 3407 Double_t red[9] = { 39./255., 43./255., 59./255., 63./255., 80./255., 116./255., 153./255., 177./255., 223./255.};; 3408 Double_t green[9] = { 39./255., 43./255., 59./255., 74./255., 91./255., 114./255., 139./255., 165./255., 223./255.};; 3409 Double_t blue[9] = { 39./255., 50./255., 59./255., 70./255., 85./255., 115./255., 151./255., 176./255., 223./255.};; 3410 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3411 }; 3412 break;; 3413 ; 3414 // Plum; 3415 case 94:; 3416 {; 3417 Double_t red[9] = { 0./255., 38./255., 60./255., 76./255., 84./255., 89./255., 101./255., 128./255., 204./255.};; 3418 Double_t green[9] = { 0./255., 10./255., 15./255., 23./255., 35./255., 57./255., 83./255., 123./255., 199./255.};; 3419 Double_t blue[9] = { 0./255., 11./255., 22./255., 40./255., 63./255., 86./255., 97./255., 94./255., 85./255.};; 3420 Idx = TColor::CreateGradientColorTable(9, stops, red, gree",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TColor_8cxx_source.html:133428,green,green,133428,doc/master/TColor_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html,1,['green'],['green']
Energy Efficiency,"3455 case 98:; 3456 {; 3457 Double_t red[9] = { 149./255., 140./255., 164./255., 179./255., 182./255., 181./255., 131./255., 87./255., 61./255.};; 3458 Double_t green[9] = { 62./255., 70./255., 107./255., 136./255., 144./255., 138./255., 117./255., 87./255., 74./255.};; 3459 Double_t blue[9] = { 40./255., 38./255., 45./255., 49./255., 49./255., 49./255., 38./255., 32./255., 34./255.};; 3460 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3461 }; 3462 break;; 3463 ; 3464 // Sienna; 3465 case 99:; 3466 {; 3467 Double_t red[9] = { 99./255., 112./255., 148./255., 165./255., 179./255., 182./255., 183./255., 183./255., 208./255.};; 3468 Double_t green[9] = { 39./255., 40./255., 57./255., 79./255., 104./255., 127./255., 148./255., 161./255., 198./255.};; 3469 Double_t blue[9] = { 15./255., 16./255., 18./255., 33./255., 51./255., 79./255., 103./255., 129./255., 177./255.};; 3470 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3471 }; 3472 break;; 3473 ; 3474 // Solar; 3475 case 100:; 3476 {; 3477 Double_t red[9] = { 99./255., 116./255., 154./255., 174./255., 200./255., 196./255., 201./255., 201./255., 230./255.};; 3478 Double_t green[9] = { 0./255., 0./255., 8./255., 32./255., 58./255., 83./255., 119./255., 136./255., 173./255.};; 3479 Double_t blue[9] = { 5./255., 6./255., 7./255., 9./255., 9./255., 14./255., 17./255., 19./255., 24./255.};; 3480 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3481 }; 3482 break;; 3483 ; 3484 // South West; 3485 case 101:; 3486 {; 3487 Double_t red[9] = { 82./255., 106./255., 126./255., 141./255., 155./255., 163./255., 142./255., 107./255., 66./255.};; 3488 Double_t green[9] = { 62./255., 44./255., 69./255., 107./255., 135./255., 152./255., 149./255., 132./255., 119./255.};; 3489 Double_t blue[9] = { 39./255., 25./255., 31./255., 60./255., 73./255., 68./255., 49./255., 72./255., 188./255.};; 3490 Idx = TColor::CreateGradientColorTable(9, stops,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TColor_8cxx_source.html:137047,green,green,137047,doc/master/TColor_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html,1,['green'],['green']
Energy Efficiency,3e-04; : 3 : myvar2 : -2.045e-02; : 4 : var3 : -2.655e-02; : -------------------------------------; LikelihoodPCA : Ranking result (top variable is best ranked); : -------------------------------------; : Rank : Variable : Delta Separation; : -------------------------------------; : 1 : var4 : 2.888e-01; : 2 : myvar1 : 6.310e-02; : 3 : var3 : 1.768e-02; : 4 : myvar2 : 1.165e-02; : -------------------------------------; : No variable ranking supplied by classifier: PDERS; PDEFoam : Ranking result (top variable is best ranked); : ----------------------------------------; : Rank : Variable : Variable Importance; : ----------------------------------------; : 1 : var4 : 3.830e-01; : 2 : myvar1 : 2.979e-01; : 3 : var3 : 1.915e-01; : 4 : myvar2 : 1.277e-01; : ----------------------------------------; : No variable ranking supplied by classifier: KNN; LD : Ranking result (top variable is best ranked); : ---------------------------------; : Rank : Variable : Discr. power; : ---------------------------------; : 1 : var4 : 7.053e-01; : 2 : myvar1 : 3.094e-01; : 3 : var3 : 1.423e-01; : 4 : myvar2 : 1.019e-01; : ---------------------------------; : No variable ranking supplied by classifier: FDA_GA; MLPBNN : Ranking result (top variable is best ranked); : -------------------------------; : Rank : Variable : Importance; : -------------------------------; : 1 : var4 : 1.360e+00; : 2 : myvar2 : 1.009e+00; : 3 : myvar1 : 8.834e-01; : 4 : var3 : 3.562e-01; : -------------------------------; : No variable ranking supplied by classifier: DNN_CPU; : No variable ranking supplied by classifier: SVM; BDT : Ranking result (top variable is best ranked); : ----------------------------------------; : Rank : Variable : Variable Importance; : ----------------------------------------; : 1 : var4 : 2.697e-01; : 2 : myvar1 : 2.467e-01; : 3 : myvar2 : 2.460e-01; : 4 : var3 : 2.377e-01; : ----------------------------------------; RuleFit : Ranking result (top variable is best ranked); : -------------,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAClassification_8C.html:61683,power,power,61683,doc/master/TMVAClassification_8C.html,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html,1,['power'],['power']
Energy Efficiency,"4 // Green Red Violet; 3065 case 59:; 3066 {; 3067 Double_t red[9] = {13./255., 23./255., 25./255., 63./255., 76./255., 104./255., 137./255., 161./255., 206./255.};; 3068 Double_t green[9] = {95./255., 67./255., 37./255., 21./255., 0./255., 12./255., 35./255., 52./255., 79./255.};; 3069 Double_t blue[9] = { 4./255., 3./255., 2./255., 6./255., 11./255., 22./255., 49./255., 98./255., 208./255.};; 3070 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3071 }; 3072 break;; 3073 ; 3074 // Blue Red Yellow; 3075 case 60:; 3076 {; 3077 Double_t red[9] = {0./255., 61./255., 89./255., 122./255., 143./255., 160./255., 185./255., 204./255., 231./255.};; 3078 Double_t green[9] = {0./255., 0./255., 0./255., 0./255., 14./255., 37./255., 72./255., 132./255., 235./255.};; 3079 Double_t blue[9] = {0./255., 140./255., 224./255., 144./255., 4./255., 5./255., 6./255., 9./255., 13./255.};; 3080 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3081 }; 3082 break;; 3083 ; 3084 // Ocean; 3085 case 61:; 3086 {; 3087 Double_t red[9] = { 14./255., 7./255., 2./255., 0./255., 5./255., 11./255., 55./255., 131./255., 229./255.};; 3088 Double_t green[9] = {105./255., 56./255., 26./255., 1./255., 42./255., 74./255., 131./255., 171./255., 229./255.};; 3089 Double_t blue[9] = { 2./255., 21./255., 35./255., 60./255., 92./255., 113./255., 160./255., 185./255., 229./255.};; 3090 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3091 }; 3092 break;; 3093 ; 3094 // Color Printable On Grey; 3095 case 62:; 3096 {; 3097 Double_t red[9] = { 0./255., 0./255., 0./255., 70./255., 148./255., 231./255., 235./255., 237./255., 244./255.};; 3098 Double_t green[9] = { 0./255., 0./255., 0./255., 0./255., 0./255., 69./255., 67./255., 216./255., 244./255.};; 3099 Double_t blue[9] = { 0./255., 102./255., 228./255., 231./255., 177./255., 124./255., 137./255., 20./255., 244./255.};; 3100 Idx = TColor::CreateGradientColorTable(9, sto",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TColor_8cxx_source.html:116602,green,green,116602,doc/master/TColor_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html,1,['green'],['green']
Energy Efficiency,"4- Uniform(Double_t); 95- Landau(Double_t mean, Double_t sigma); 96- Poisson(Double_t mean); 97- Binomial(Int_t ntot, Double_t prob); 98 ; 99Random numbers distributed according to 1-d, 2-d or 3-d distributions contained in TF1, TF2 or TF3 objects can also be; 100generated. For example, to get a random number distributed following abs(sin(x)/x)*sqrt(x) you can do : \code{.cpp} TF1; 101*f1 = new TF1(""f1"",""abs(sin(x)/x)*sqrt(x)"",0,10); double r = f1->GetRandom(); \endcode or you can use the UNURAN; 102package. You need in this case to initialize UNURAN to the function you would like to generate. \code{.cpp} TUnuran u;; 103 u.Init(TUnuranDistrCont(f1));; 104 double r = u.Sample();; 105\endcode; 106 ; 107The techniques of using directly a TF1,2 or 3 function is powerful and; 108can be used to generate numbers in the defined range of the function.; 109Getting a number from a TF1,2,3 function is also quite fast.; 110UNURAN is a powerful and flexible tool which contains various methods for; 111generate random numbers for continuous distributions of one and multi-dimension.; 112It requires some set-up (initialization) phase and can be very fast when the distribution; 113parameters are not changed for every call.; 114 ; 115The following table shows some timings (in nanosecond/call); 116for basic functions, TF1 functions and using UNURAN obtained running; 117the tutorial math/testrandom.C; 118Numbers have been obtained on an Intel Xeon Quad-core Harpertown (E5410) 2.33 GHz running; 119Linux SLC4 64 bit and compiled with gcc 3.4; 120 ; 121~~~~; 122Distribution nanoseconds/call; 123 TRandom TRandom1 TRandom2 TRandom3; 124Rndm.............. 5.000 105.000 7.000 10.000; 125RndmArray......... 4.000 104.000 6.000 9.000; 126Gaus.............. 36.000 180.000 40.000 48.000; 127Rannor............ 118.000 220.000 120.000 124.000; 128Landau............ 22.000 123.000 26.000 31.000; 129Exponential....... 93.000 198.000 98.000 104.000; 130Binomial(5,0.5)... 30.000 548.000 46.000 65.000; 131B",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TRandom_8cxx_source.html:7316,power,powerful,7316,doc/master/TRandom_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TRandom_8cxx_source.html,1,['power'],['powerful']
Energy Efficiency,"40) {; 12636 /* Inflate the data received if bit RSV1 is set. */; 12637 if (!conn->websocket_deflate_initialized) {; 12638 if (websocket_deflate_initialize(conn, 1) != Z_OK); 12639 exit_by_callback = 1;; 12640 }; 12641 if (!exit_by_callback) {; 12642 size_t inflate_buf_size_old = 0;; 12643 size_t inflate_buf_size =; 12644 data_len; 12645 * 4; // Initial guess of the inflated message; 12646 // size. We double the memory when needed.; 12647 Bytef *inflated = NULL;; 12648 Bytef *new_mem = NULL;; 12649 conn->websocket_inflate_state.avail_in =; 12650 (uInt)(data_len + 4);; 12651 conn->websocket_inflate_state.next_in = data;; 12652 // Add trailing 0x00 0x00 0xff 0xff bytes; 12653 data[data_len] = '\x00';; 12654 data[data_len + 1] = '\x00';; 12655 data[data_len + 2] = '\xff';; 12656 data[data_len + 3] = '\xff';; 12657 do {; 12658 if (inflate_buf_size_old == 0) {; 12659 new_mem =; 12660 (Bytef *)mg_calloc(inflate_buf_size,; 12661 sizeof(Bytef));; 12662 } else {; 12663 inflate_buf_size *= 2;; 12664 new_mem =; 12665 (Bytef *)mg_realloc(inflated,; 12666 inflate_buf_size);; 12667 }; 12668 if (new_mem == NULL) {; 12669 mg_cry_internal(; 12670 conn,; 12671 ""Out of memory: Cannot allocate ""; 12672 ""inflate buffer of %lu bytes"",; 12673 (unsigned long)inflate_buf_size);; 12674 exit_by_callback = 1;; 12675 break;; 12676 }; 12677 inflated = new_mem;; 12678 conn->websocket_inflate_state.avail_out =; 12679 (uInt)(inflate_buf_size; 12680 - inflate_buf_size_old);; 12681 conn->websocket_inflate_state.next_out =; 12682 inflated + inflate_buf_size_old;; 12683 ret = inflate(&conn->websocket_inflate_state,; 12684 Z_SYNC_FLUSH);; 12685 if (ret == Z_NEED_DICT || ret == Z_DATA_ERROR; 12686 || ret == Z_MEM_ERROR) {; 12687 mg_cry_internal(; 12688 conn,; 12689 ""ZLIB inflate error: %i %s"",; 12690 ret,; 12691 (conn->websocket_inflate_state.msg; 12692 ? conn->websocket_inflate_state.msg; 12693 : ""<no error message>""));; 12694 exit_by_callback = 1;; 12695 break;; 12696 }; 12697 inflate_buf_size_old = inf",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:368280,allocate,allocate,368280,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['allocate'],['allocate']
Energy Efficiency,"40) {; 12637 /* Inflate the data received if bit RSV1 is set. */; 12638 if (!conn->websocket_deflate_initialized) {; 12639 if (websocket_deflate_initialize(conn, 1) != Z_OK); 12640 exit_by_callback = 1;; 12641 }; 12642 if (!exit_by_callback) {; 12643 size_t inflate_buf_size_old = 0;; 12644 size_t inflate_buf_size =; 12645 data_len; 12646 * 4; // Initial guess of the inflated message; 12647 // size. We double the memory when needed.; 12648 Bytef *inflated = NULL;; 12649 Bytef *new_mem = NULL;; 12650 conn->websocket_inflate_state.avail_in =; 12651 (uInt)(data_len + 4);; 12652 conn->websocket_inflate_state.next_in = data;; 12653 // Add trailing 0x00 0x00 0xff 0xff bytes; 12654 data[data_len] = '\x00';; 12655 data[data_len + 1] = '\x00';; 12656 data[data_len + 2] = '\xff';; 12657 data[data_len + 3] = '\xff';; 12658 do {; 12659 if (inflate_buf_size_old == 0) {; 12660 new_mem =; 12661 (Bytef *)mg_calloc(inflate_buf_size,; 12662 sizeof(Bytef));; 12663 } else {; 12664 inflate_buf_size *= 2;; 12665 new_mem =; 12666 (Bytef *)mg_realloc(inflated,; 12667 inflate_buf_size);; 12668 }; 12669 if (new_mem == NULL) {; 12670 mg_cry_internal(; 12671 conn,; 12672 ""Out of memory: Cannot allocate ""; 12673 ""inflate buffer of %lu bytes"",; 12674 (unsigned long)inflate_buf_size);; 12675 exit_by_callback = 1;; 12676 break;; 12677 }; 12678 inflated = new_mem;; 12679 conn->websocket_inflate_state.avail_out =; 12680 (uInt)(inflate_buf_size; 12681 - inflate_buf_size_old);; 12682 conn->websocket_inflate_state.next_out =; 12683 inflated + inflate_buf_size_old;; 12684 ret = inflate(&conn->websocket_inflate_state,; 12685 Z_SYNC_FLUSH);; 12686 if (ret == Z_NEED_DICT || ret == Z_DATA_ERROR; 12687 || ret == Z_MEM_ERROR) {; 12688 mg_cry_internal(; 12689 conn,; 12690 ""ZLIB inflate error: %i %s"",; 12691 ret,; 12692 (conn->websocket_inflate_state.msg; 12693 ? conn->websocket_inflate_state.msg; 12694 : ""<no error message>""));; 12695 exit_by_callback = 1;; 12696 break;; 12697 }; 12698 inflate_buf_size_old = inf",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:368313,allocate,allocate,368313,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['allocate'],['allocate']
Energy Efficiency,"404 // Pigeon; 3405 case 93:; 3406 {; 3407 Double_t red[9] = { 39./255., 43./255., 59./255., 63./255., 80./255., 116./255., 153./255., 177./255., 223./255.};; 3408 Double_t green[9] = { 39./255., 43./255., 59./255., 74./255., 91./255., 114./255., 139./255., 165./255., 223./255.};; 3409 Double_t blue[9] = { 39./255., 50./255., 59./255., 70./255., 85./255., 115./255., 151./255., 176./255., 223./255.};; 3410 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3411 }; 3412 break;; 3413 ; 3414 // Plum; 3415 case 94:; 3416 {; 3417 Double_t red[9] = { 0./255., 38./255., 60./255., 76./255., 84./255., 89./255., 101./255., 128./255., 204./255.};; 3418 Double_t green[9] = { 0./255., 10./255., 15./255., 23./255., 35./255., 57./255., 83./255., 123./255., 199./255.};; 3419 Double_t blue[9] = { 0./255., 11./255., 22./255., 40./255., 63./255., 86./255., 97./255., 94./255., 85./255.};; 3420 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3421 }; 3422 break;; 3423 ; 3424 // Red Blue; 3425 case 95:; 3426 {; 3427 Double_t red[9] = { 94./255., 112./255., 141./255., 165./255., 167./255., 140./255., 91./255., 49./255., 27./255.};; 3428 Double_t green[9] = { 27./255., 46./255., 88./255., 135./255., 166./255., 161./255., 135./255., 97./255., 58./255.};; 3429 Double_t blue[9] = { 42./255., 52./255., 81./255., 106./255., 139./255., 158./255., 155./255., 137./255., 116./255.};; 3430 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3431 }; 3432 break;; 3433 ; 3434 // Rose; 3435 case 96:; 3436 {; 3437 Double_t red[9] = { 30./255., 49./255., 79./255., 117./255., 135./255., 151./255., 146./255., 138./255., 147./255.};; 3438 Double_t green[9] = { 63./255., 60./255., 72./255., 90./255., 94./255., 94./255., 68./255., 46./255., 16./255.};; 3439 Double_t blue[9] = { 18./255., 28./255., 41./255., 56./255., 62./255., 63./255., 50./255., 36./255., 21./255.};; 3440 Idx = TColor::CreateGradientColorTable(9, stops, r",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TColor_8cxx_source.html:134454,green,green,134454,doc/master/TColor_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html,1,['green'],['green']
Energy Efficiency,"41 /*; 42 * Allocate memory for points; 43 */; 44 ; 45 if (gSize3D.numPoints) {; 46 points = (point *) calloc(gSize3D.numPoints, sizeof (point));; 47 if (!points) {; 48 puts (""Unable to allocate memory for points !"");; 49 ret = 0;; 50 }; 51 }; 52 else return (0); /* if there are no points, return back */; 53 ; 54 ; 55 ; 56 /*; 57 * Allocate memory for colors; 58 */; 59 ; 60 colors = (Color *) calloc(28+4, sizeof (Color));; 61 if(!colors) {; 62 puts (""Unable to allocate memory for colors !"");; 63 ret = 0;; 64 }; 65 else {; 66 colors[ 0].red = 92; colors[ 0].green = 92; colors[0].blue = 92;; 67 colors[ 1].red = 122; colors[ 1].green = 122; colors[1].blue = 122;; 68 colors[ 2].red = 184; colors[ 2].green = 184; colors[2].blue = 184;; 69 colors[ 3].red = 215; colors[ 3].green = 215; colors[3].blue = 215;; 70 colors[ 4].red = 138; colors[ 4].green = 15; colors[4].blue = 15;; 71 colors[ 5].red = 184; colors[ 5].green = 20; colors[5].blue = 20;; 72 colors[ 6].red = 235; colors[ 6].green = 71; colors[6].blue = 71;; 73 colors[ 7].red = 240; colors[ 7].green = 117; colors[7].blue = 117;; 74 colors[ 8].red = 15; colors[ 8].green = 138; colors[8].blue = 15;; 75 colors[ 9].red = 20; colors[ 9].green = 184; colors[9].blue = 20;; 76 colors[10].red = 71; colors[10].green = 235; colors[10].blue = 71;; 77 colors[11].red = 117; colors[11].green = 240; colors[11].blue = 117;; 78 colors[12].red = 15; colors[12].green = 15; colors[12].blue = 138;; 79 colors[13].red = 20; colors[13].green = 20; colors[13].blue = 184;; 80 colors[14].red = 71; colors[14].green = 71; colors[14].blue = 235;; 81 colors[15].red = 117; colors[15].green = 117; colors[15].blue = 240;; 82 colors[16].red = 138; colors[16].green = 138; colors[16].blue = 15;; 83 colors[17].red = 184; colors[17].green = 184; colors[17].blue = 20;; 84 colors[18].red = 235; colors[18].green = 235; colors[18].blue = 71;; 85 colors[19].red = 240; colors[19].green = 240; colors[19].blue = 117;; 86 colors[20].red = 138; colors[20].green = 15",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/X3DBuffer_8c_source.html:2119,green,green,2119,doc/master/X3DBuffer_8c_source.html,https://root.cern,https://root.cern/doc/master/X3DBuffer_8c_source.html,1,['green'],['green']
Energy Efficiency,"43E20 6,43e20; 6.43e-20 6.43E-20 6,43e-20. TString Itoa(Int_t value, Int_t base); Converts an Int_t to a TString with respect to the base specified (2-36).; Thus it is an enhanced version of sprintf (adapted from versions 0.4 of; http://www.jb.man.ac.uk/~slowe/cpp/itoa.html).; Usage: the following statement produce the same output, namely ""1111""; cout << TString::Itoa(15,2) ;; cout << TString::Itoa(0xF,2) ; /// 0x prefix to handle hex; cout << TString::Itoa(017,2) ; /// 0 prefix to handle oct; In case of error returns the ""!"" string. TString UItoa(UInt_t value, Int_t base); Converts a UInt_t (twice the range of an Int_t) to a TString with respect; to the base specified (2-36). Thus it is an enhanced version of sprintf; (adapted from versions 0.4 of http://www.jb.man.ac.uk/~slowe/cpp/itoa.html).; In case of error returns the ""!"" string. TString LLtoa(Long64_t value, Int_t base); Converts a Long64_t to a TString with respect to the base specified (2-36).; Thus it is an enhanced version of sprintf (adapted from versions 0.4 of; http://www.jb.man.ac.uk/~slowe/cpp/itoa.html).; In case of error returns the ""!"" string. TString ULLtoa(ULong64_t value, Int_t base); Converts a ULong64_t (twice the range of an Long64_t) to a TString with; respect to the base specified (2-36). Thus it is an enhanced version of; sprintf (adapted from versions 0.4 of http://www.jb.man.ac.uk/~slowe/cpp/itoa.html).; In case of error returns the ""!"" string. TString BaseConvert(const TString& s_in, Int_t base_in, Int_t base_out); Converts string from base base_in to base base_out. Supported bases; are 2-36. At most 64 bit data can be converted. Bool_t EndsWith(const char* pat, TString::ECaseCompare cmp = kExact) const; Return true if string ends with the specified string. TObjArray * Tokenize(const TString& delim) const; This function is used to isolate sequential tokens in a TString.; These tokens are separated in the string by at least one of the; characters in delim. The returned array contains the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TString.html:18848,adapt,adapted,18848,root/html534/TString.html,https://root.cern,https://root.cern/root/html534/TString.html,1,['adapt'],['adapted']
Energy Efficiency,"45 if (!out.is_open()) {; 146 throw std::runtime_error(""Could not open output file \"""" + outputFile + ""\""for reading"");; 147 }; 148 ; 149 out << dotGraph;; 150 out.close();; 151}; 152 ; 153// clang-format off; 154/// Cast a RDataFrame node to the common type ROOT::RDF::RNode; 155/// \param[in] node Any node of a RDataFrame graph; 156// clang-format on; 157template <typename NodeType>; 158RNode AsRNode(NodeType node); 159{; 160 return node;; 161}; 162 ; 163// clang-format off; 164/// Trigger the event loop of multiple RDataFrames concurrently; 165/// \param[in] handles A vector of RResultHandles; 166/// \return The number of distinct computation graphs that have been processed; 167///; 168/// This function triggers the event loop of all computation graphs which relate to the; 169/// given RResultHandles. The advantage compared to running the event loop implicitly by accessing the; 170/// RResultPtr is that the event loops will run concurrently. Therefore, the overall; 171/// computation of all results is generally more efficient.; 172/// It should be noted that user-defined operations (e.g., Filters and Defines) of the different RDataFrame graphs are assumed to be safe to call concurrently.; 173///; 174/// ~~~{.cpp}; 175/// ROOT::RDataFrame df1(""tree1"", ""file1.root"");; 176/// auto r1 = df1.Histo1D(""var1"");; 177///; 178/// ROOT::RDataFrame df2(""tree2"", ""file2.root"");; 179/// auto r2 = df2.Sum(""var2"");; 180///; 181/// // RResultPtr -> RResultHandle conversion is automatic; 182/// ROOT::RDF::RunGraphs({r1, r2});; 183/// ~~~; 184// clang-format on; 185unsigned int RunGraphs(std::vector<RResultHandle> handles);; 186 ; 187namespace Experimental {; 188 ; 189/// \brief Produce all required systematic variations for the given result.; 190/// \param[in] resPtr The result for which variations should be produced.; 191/// \return A \ref ROOT::RDF::Experimental::RResultMap ""RResultMap"" object with full variation names as strings; 192/// (e.g. ""pt:down"") and the corresponding varied",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDFHelpers_8hxx_source.html:7644,efficient,efficient,7644,doc/master/RDFHelpers_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RDFHelpers_8hxx_source.html,1,['efficient'],['efficient']
Energy Efficiency,"45 of file TFoam.cxx. ◆ Initialize() [1/2]. void TFoam::Initialize ; (; ). virtual . Basic initialization of FOAM invoked by the user. ; IMPORTANT: Random number generator and the distribution object has to be provided using SetPseRan and SetRho prior to invoking this initialiser! ; Definition at line 321 of file TFoam.cxx. ◆ Initialize() [2/2]. void TFoam::Initialize ; (; TRandom * ; PseRan, . TFoamIntegrand * ; fun . ). virtual . Basic initialization of FOAM invoked by the user. Mandatory!; This method starts the process of the cell build-up. User must invoke Initialize with two arguments or Initialize without arguments. This is done BEFORE generating first MC event and AFTER allocating FOAM object and resetting (optionally) its internal parameters/switches. The overall operational scheme of the FOAM is the following:. This method invokes several other methods:; InitCells initializes memory storage for cells and begins exploration process from the root cell. The empty cells are allocated/filled using CellFill. The procedure Grow which loops over cells, picks up the cell with the biggest `‘driver integral’', see Computer Physics Communications 152 152 (2003) 55 for explanations, with the help of PeekMax procedure. The chosen cell is split using Divide. Subsequently, the procedure Explore called by the Divide (and by InitCells for the root cell) does the most important job in the FOAM object build-up: it performs a small MC run for each newly allocated daughter cell. Explore calculates how profitable the future split of the cell will be and defines the optimal cell division geometry with the help of Carver or Varedu procedures, for maximum weight or variance optimization respectively. All essential results of the exploration are written into the explored cell object. At the very end of the foam build-up, Finally, MakeActiveList is invoked to create a list of pointers to all active cells, for the purpose of the quick access during the MC generation. The procedure Expl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFoam.html:32659,allocate,allocated,32659,doc/master/classTFoam.html,https://root.cern,https://root.cern/doc/master/classTFoam.html,1,['allocate'],['allocated']
Energy Efficiency,"4541 of file TStreamerInfo.cxx. ◆ IsA(). TClass * TStreamerInfo::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TNamed.; Definition at line 254 of file TStreamerInfo.h. ◆ ls(). void TStreamerInfo::ls ; (; Option_t * ; option = """"); const. overridevirtual . List the TStreamerElement list and also the precomputed tables if option contains the string ""incOrig"", also prints the original (non-optimized elements in the list of compiled elements. ; Implements TVirtualStreamerInfo.; Definition at line 4684 of file TStreamerInfo.cxx. ◆ MatchLegacyCheckSum(). Bool_t TStreamerInfo::MatchLegacyCheckSum ; (; UInt_t ; checksum); const. Return true if the checksum passed as argument is one of the checksum value produced by the older checksum calculation algorithm. ; Definition at line 3270 of file TStreamerInfo.cxx. ◆ New(). void * TStreamerInfo::New ; (; void * ; obj = nullptr). overridevirtual . An emulated object is created at address obj, if obj is null we allocate memory for the object. ; Implements TVirtualStreamerInfo.; Definition at line 4769 of file TStreamerInfo.cxx. ◆ NewArray(). void * TStreamerInfo::NewArray ; (; Long_t ; nElements, . void * ; ary = nullptr . ). overridevirtual . An array of emulated objects is created at address ary, if ary is null, we allocate memory for the array. ; Implements TVirtualStreamerInfo.; Definition at line 4918 of file TStreamerInfo.cxx. ◆ NewInfo(). TVirtualStreamerInfo * TStreamerInfo::NewInfo ; (; TClass * ; cl). inlineoverridevirtual . Implements TVirtualStreamerInfo.; Definition at line 198 of file TStreamerInfo.h. ◆ operator=(). TStreamerInfo & TStreamerInfo::operator= ; (; const TStreamerInfo & ; ). privatedelete . ◆ PrintValue(). void TStreamerInfo::PrintValue ; (; const char * ; name, . char * ; pointer, . Int_t ; i, . Int_t ; len, . Int_t ; lenmax = 1000 . ); const. print value of element i in object at pointer The function may be called in two ways: -method1 len < 0 i i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTStreamerInfo.html:60001,allocate,allocate,60001,doc/master/classTStreamerInfo.html,https://root.cern,https://root.cern/doc/master/classTStreamerInfo.html,1,['allocate'],['allocate']
Energy Efficiency,"484 */; 485 bool Settings::hasConverged (double testError); 486 {; 487 // std::cout << ""check convergence; minError "" << m_minError << "" current "" << testError; 488 // << "" current convergence count "" << m_convergenceCount << std::endl;; 489 if (testError < m_minError*0.999); 490 {; 491 m_convergenceCount = 0;; 492 m_minError = testError;; 493 }; 494 else; 495 {; 496 ++m_convergenceCount;; 497 m_maxConvergenceCount = std::max (m_convergenceCount, m_maxConvergenceCount);; 498 }; 499 ; 500 ; 501 if (m_convergenceCount >= convergenceSteps () || testError <= 0); 502 return true;; 503 ; 504 return false;; 505 }; 506 ; 507 ; 508 ; 509 /** \brief set the weight sums to be scaled to (preparations for monitoring output); 510 *; 511 */; 512 void ClassificationSettings::setWeightSums (double sumOfSigWeights, double sumOfBkgWeights); 513 {; 514 m_sumOfSigWeights = sumOfSigWeights; m_sumOfBkgWeights = sumOfBkgWeights;; 515 }; 516 ; 517 /** \brief preparation for monitoring output; 518 *; 519 */; 520 void ClassificationSettings::setResultComputation (; 521 std::string _fileNameNetConfig,; 522 std::string _fileNameResult,; 523 std::vector<Pattern>* _resultPatternContainer); 524 {; 525 m_pResultPatternContainer = _resultPatternContainer;; 526 m_fileNameResult = _fileNameResult;; 527 m_fileNameNetConfig = _fileNameNetConfig;; 528 }; 529 ; 530 ; 531 ; 532 ; 533 ; 534 ; 535 ; 536 ; 537 /** \brief compute the number of weights given the size of the input layer; 538 *; 539 */; 540 size_t Net::numWeights (size_t trainingStartLayer) const ; 541 {; 542 size_t num (0);; 543 size_t index (0);; 544 size_t prevNodes (inputSize ());; 545 for (auto& layer : m_layers); 546 {; 547 if (index >= trainingStartLayer); 548 num += layer.numWeights (prevNodes);; 549 prevNodes = layer.numNodes ();; 550 ++index;; 551 }; 552 return num;; 553 }; 554 ; 555 ; 556 size_t Net::numNodes (size_t trainingStartLayer) const ; 557 {; 558 size_t num (0);; 559 size_t index (0);; 560 for (auto& layer : m_layers); 561 {; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/NeuralNet_8cxx_source.html:17495,monitor,monitoring,17495,doc/master/NeuralNet_8cxx_source.html,https://root.cern,https://root.cern/doc/master/NeuralNet_8cxx_source.html,2,['monitor'],['monitoring']
Energy Efficiency,"4Used to switch between different type of interpretations of the data (64 bits) ;  ►Nwriter;  Cwriter;  C_root_std_complex;  C_Ulp_ExponentVector;  C_Ulp_ExponentVector< Vc::sfloat_v >;  C_UnitTest_Compare;  C_UnitTest_Failure;  C_UnitTest_Global_Object;  C_x3d_data_;  C_x3d_sizeof_;  CADD_PASS;  CAnyCollectionProxy;  CAnyCollectionStreamer;  CApplicationWindowMain Qt&Root Application Window: ;  ►CBaker;  COptions;  CBalancerInfo;  CBaseSelectionRule;  Cbasic_string_view;  ►CBidirMMapPipeBidirMMapPipe creates a bidirectional channel between the current process and a child it forks ;  CPollEntryFor poll() interface ;  CBinaryOpPolicy;  CBinomialNeymanInterval;  CBinomialProbHelper;  CClassSelectionRule;  CClusterD;  CColorStruct_t;  CCompareAsc;  CcompareBAasc;  CcompareBAdesc;  CCompareDesc;  CContDistFree functions adapter needed by UNURAN for onedimensional continuous distributions ;  CContextSmall helper to keep current directory context ;  CCpuInfo_t;  CDiscrDistFree functions adapter needed by UNURAN for one-dimensional discrete distribution ;  Cdrr_func_cache;  Cdrr_func_entry;  CDUMMY;  CEditor;  CEvent_t;  CExceptionContext_t;  CexponentToDivisor;  CexponentToDivisor< 1, center >;  CexponentToDivisor< 1024, center >;  CexponentToDivisor< 128, center >;  CexponentToDivisor< 256, center >;  CexponentToDivisor< 384, center >;  CexponentToDivisor< 512, center >;  CexponentToDivisor< 640, center >;  CexponentToDivisor< 768, center >;  CexponentToDivisor< 896, center >;  CexponentToDivisor< center, center >;  CexponentToMultiplier;  CexponentToMultiplier< -1, center >;  CexponentToMultiplier< -128, center >;  CexponentToMultiplier< -256, center >;  CexponentToMultiplier< -384, center >;  CexponentToMultiplier< -512, center >;  CexponentToMultiplier< -640, center >;  CexponentToMultiplier< -768, center >;  CexponentToMultiplier< -896, center >;  CexponentToMultiplier< center, center >;  CexponentToMultiplier<-1024, center >;  CFeldmanCousinsBinomialInterval;  CFeld",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html606/annotated.html:76864,adapt,adapter,76864,root/html606/annotated.html,https://root.cern,https://root.cern/root/html606/annotated.html,1,['adapt'],['adapter']
Energy Efficiency,4_t* TTreeCloner::fBasketEntry. private . [fMaxBaskets] list of basket start entries. ; Definition at line 50 of file TTreeCloner.h. ◆ fBasketIndex. UInt_t* TTreeCloner::fBasketIndex. private . [fMaxBaskets] ordered list of basket indices to be written. ; Definition at line 51 of file TTreeCloner.h. ◆ fBasketNum. UInt_t* TTreeCloner::fBasketNum. private . [fMaxBaskets] index of the basket within the branch. ; Definition at line 47 of file TTreeCloner.h. ◆ fBasketSeek. Long64_t* TTreeCloner::fBasketSeek. private . [fMaxBaskets] list of basket position to be read. ; Definition at line 49 of file TTreeCloner.h. ◆ fCacheSize. Long64_t TTreeCloner::fCacheSize. private . Requested size of the file cache. ; Definition at line 58 of file TTreeCloner.h. ◆ fCloneMethod. UInt_t TTreeCloner::fCloneMethod. private . Indicates which cloning method was selected. ; Definition at line 55 of file TTreeCloner.h. ◆ fFileCache. TFileCacheRead* TTreeCloner::fFileCache. private . File Cache used to reduce the number of individual reads. ; Definition at line 59 of file TTreeCloner.h. ◆ fFromBranches. TObjArray TTreeCloner::fFromBranches. private . Definition at line 42 of file TTreeCloner.h. ◆ fFromTree. TTree* TTreeCloner::fFromTree. private . Definition at line 37 of file TTreeCloner.h. ◆ fIsValid. bool TTreeCloner::fIsValid. private . Definition at line 34 of file TTreeCloner.h. ◆ fMaxBaskets. UInt_t TTreeCloner::fMaxBaskets. private . Definition at line 45 of file TTreeCloner.h. ◆ fMethod. Option_t* TTreeCloner::fMethod. private . Definition at line 41 of file TTreeCloner.h. ◆ fNeedConversion. bool TTreeCloner::fNeedConversion. private . True if the fast merge is not possible but a slow merge might possible. ; Definition at line 35 of file TTreeCloner.h. ◆ fOptions. UInt_t TTreeCloner::fOptions. private . Definition at line 36 of file TTreeCloner.h. ◆ fPidOffset. UShort_t TTreeCloner::fPidOffset. private . Offset to be added to the copied key/basket. ; Definition at line 53 of file TTr,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeCloner.html:13612,reduce,reduce,13612,doc/master/classTTreeCloner.html,https://root.cern,https://root.cern/doc/master/classTTreeCloner.html,1,['reduce'],['reduce']
Energy Efficiency,"5 of file RooDataHist.cxx. ◆ importTH1(). void RooDataHist::importTH1 ; (; const RooArgList & ; vars, . const TH1 & ; histo, . double ; initWgt, . bool ; doDensityCorrection . ). protected . Import data from given TH1/2/3 into this RooDataHist. ; Definition at line 374 of file RooDataHist.cxx. ◆ importTH1Set(). void RooDataHist::importTH1Set ; (; const RooArgList & ; vars, . RooCategory & ; indexCat, . std::map< std::string, TH1 * > ; hmap, . double ; wgt, . bool ; doDensityCorrection . ). protected . Import data from given set of TH1/2/3 into this RooDataHist. ; The category indexCat labels the sources in the constructed RooDataHist. The stl map provides the mapping between the indexCat state labels and the import source ; Definition at line 497 of file RooDataHist.cxx. ◆ initialize(). void RooDataHist::initialize ; (; const char * ; binningName = nullptr, . bool ; fillTree = true . ). protected . Initialization procedure: allocate weights array, calculate multipliers needed for N-space to 1-dim array jump table, and fill the internal tree with all bin center coordinates. ; Definition at line 783 of file RooDataHist.cxx. ◆ initializeAsymErrArrays(). void RooDataHist::initializeAsymErrArrays ; (; ); const. private . Definition at line 1551 of file RooDataHist.cxx. ◆ interpolateDim(). double RooDataHist::interpolateDim ; (; int ; iDim, . double ; xval, . size_t ; centralIdx, . int ; intOrder, . bool ; correctForBinSize, . bool ; cdfBoundaries . ). protected . Perform boundary safe 'intOrder'-th interpolation of weights in dimension 'dim' at current value 'xval'. ; Parameters. [in]iDimIndex of the histogram dimension along which to interpolate. ; [in]xvalValue of histogram variable at dimension iDim for which we want to interpolate the histogram weight. ; [in]centralIdxIndex of the bin that the point at which we interpolate the histogram weight falls into (can be obtained with RooDataHist::calcTreeIndex). ; [in]intOrderInterpolation order, i.e. how many neighbouring b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooDataHist.html:62466,allocate,allocate,62466,doc/master/classRooDataHist.html,https://root.cern,https://root.cern/doc/master/classRooDataHist.html,1,['allocate'],['allocate']
Energy Efficiency,"5 }; 2966 ; 2967 orgcolors[ncolors++] = pixel;; 2968}; 2969 ; 2970////////////////////////////////////////////////////////////////////////////////; 2971/// Get RGB values for orgcolors, add percent neutral to the RGB and; 2972/// allocate fNewColors.; 2973 ; 2974void TGX11::MakeOpaqueColors(Int_t percent, ULong_t *orgcolors, Int_t ncolors); 2975{; 2976 if (ncolors == 0) return;; 2977 ; 2978 RXColor *xcol = new RXColor[ncolors];; 2979 ; 2980 int i;; 2981 for (i = 0; i < ncolors; i++) {; 2982 xcol[i].pixel = orgcolors[i];; 2983 xcol[i].red = xcol[i].green = xcol[i].blue = 0;; 2984 xcol[i].flags = DoRed | DoGreen | DoBlue;; 2985 }; 2986 QueryColors(fColormap, xcol, ncolors);; 2987 ; 2988 UShort_t add = percent * kBIGGEST_RGB_VALUE / 100;; 2989 ; 2990 Int_t val;; 2991 for (i = 0; i < ncolors; i++) {; 2992 val = xcol[i].red + add;; 2993 if (val > kBIGGEST_RGB_VALUE) val = kBIGGEST_RGB_VALUE;; 2994 xcol[i].red = (UShort_t) val;; 2995 val = xcol[i].green + add;; 2996 if (val > kBIGGEST_RGB_VALUE) val = kBIGGEST_RGB_VALUE;; 2997 xcol[i].green = (UShort_t) val;; 2998 val = xcol[i].blue + add;; 2999 if (val > kBIGGEST_RGB_VALUE) val = kBIGGEST_RGB_VALUE;; 3000 xcol[i].blue = (UShort_t) val;; 3001 if (!AllocColor(fColormap, &xcol[i])); 3002 Warning(""MakeOpaqueColors"", ""failed to allocate color %hd, %hd, %hd"",; 3003 xcol[i].red, xcol[i].green, xcol[i].blue);; 3004 // assumes that in case of failure xcol[i].pixel is not changed; 3005 }; 3006 ; 3007 gCws->fNewColors = new ULong_t[ncolors];; 3008 gCws->fNcolors = ncolors;; 3009 ; 3010 for (i = 0; i < ncolors; i++); 3011 gCws->fNewColors[i] = xcol[i].pixel;; 3012 ; 3013 delete [] xcol;; 3014}; 3015 ; 3016////////////////////////////////////////////////////////////////////////////////; 3017/// Returns index in orgcolors (and fNewColors) for pixel.; 3018 ; 3019Int_t TGX11::FindColor(ULong_t pixel, ULong_t *orgcolors, Int_t ncolors); 3020{; 3021 for (int i = 0; i < ncolors; i++); 3022 if (pixel == orgcolors[i]) return i;; 3023 ; 3024 E",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGX11_8cxx_source.html:99770,green,green,99770,doc/master/TGX11_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html,1,['green'],['green']
Energy Efficiency,"5., 127./255., 150./255., 162./255., 159./255., 151./255., 101./255.};; 3139 Double_t blue[9] = { 29./255., 52./255., 96./255., 132./255., 162./255., 181./255., 184./255., 186./255., 131./255.};; 3140 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3141 }; 3142 break;; 3143 ; 3144 // Aurora; 3145 case 67:; 3146 {; 3147 Double_t red[9] = { 46./255., 38./255., 61./255., 92./255., 113./255., 121./255., 132./255., 150./255., 191./255.};; 3148 Double_t green[9] = { 46./255., 36./255., 40./255., 69./255., 110./255., 135./255., 131./255., 92./255., 34./255.};; 3149 Double_t blue[9] = { 46./255., 80./255., 74./255., 70./255., 81./255., 105./255., 165./255., 211./255., 225./255.};; 3150 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3151 }; 3152 break;; 3153 ; 3154 // Avocado; 3155 case 68:; 3156 {; 3157 Double_t red[9] = { 0./255., 4./255., 12./255., 30./255., 52./255., 101./255., 142./255., 190./255., 237./255.};; 3158 Double_t green[9] = { 0./255., 40./255., 86./255., 121./255., 140./255., 172./255., 187./255., 213./255., 240./255.};; 3159 Double_t blue[9] = { 0./255., 9./255., 14./255., 18./255., 21./255., 23./255., 27./255., 35./255., 101./255.};; 3160 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3161 }; 3162 break;; 3163 ; 3164 // Beach; 3165 case 69:; 3166 {; 3167 Double_t red[9] = { 198./255., 206./255., 206./255., 211./255., 198./255., 181./255., 161./255., 171./255., 244./255.};; 3168 Double_t green[9] = { 103./255., 133./255., 150./255., 172./255., 178./255., 174./255., 163./255., 175./255., 244./255.};; 3169 Double_t blue[9] = { 49./255., 54./255., 55./255., 66./255., 91./255., 130./255., 184./255., 224./255., 244./255.};; 3170 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3171 }; 3172 break;; 3173 ; 3174 // Black Body; 3175 case 70:; 3176 {; 3177 Double_t red[9] = { 243./255., 243./255., 240./255., 240./255., 241./255., 239./25",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TColor_8cxx_source.html:120495,green,green,120495,doc/master/TColor_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html,1,['green'],['green']
Energy Efficiency,"5., 127./255., 167./255., 205./255., 245./255.};; 3509 Double_t blue[9] = { 0./255., 68./255., 75./255., 43./255., 16./255., 22./255., 55./255., 128./255., 245./255.};; 3510 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3511 }; 3512 break;; 3513 ; 3514 // Temperature Map; 3515 case 104:; 3516 {; 3517 Double_t red[9] = { 34./255., 70./255., 129./255., 187./255., 225./255., 226./255., 216./255., 193./255., 179./255.};; 3518 Double_t green[9] = { 48./255., 91./255., 147./255., 194./255., 226./255., 229./255., 196./255., 110./255., 12./255.};; 3519 Double_t blue[9] = { 234./255., 212./255., 216./255., 224./255., 206./255., 110./255., 53./255., 40./255., 29./255.};; 3520 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3521 }; 3522 break;; 3523 ; 3524 // Thermometer; 3525 case 105:; 3526 {; 3527 Double_t red[9] = { 30./255., 55./255., 103./255., 147./255., 174./255., 203./255., 188./255., 151./255., 105./255.};; 3528 Double_t green[9] = { 0./255., 65./255., 138./255., 182./255., 187./255., 175./255., 121./255., 53./255., 9./255.};; 3529 Double_t blue[9] = { 191./255., 202./255., 212./255., 208./255., 171./255., 140./255., 97./255., 57./255., 30./255.};; 3530 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3531 }; 3532 break;; 3533 ; 3534 // Valentine; 3535 case 106:; 3536 {; 3537 Double_t red[9] = { 112./255., 97./255., 113./255., 125./255., 138./255., 159./255., 178./255., 188./255., 225./255.};; 3538 Double_t green[9] = { 16./255., 17./255., 24./255., 37./255., 56./255., 81./255., 110./255., 136./255., 189./255.};; 3539 Double_t blue[9] = { 38./255., 35./255., 46./255., 59./255., 78./255., 103./255., 130./255., 152./255., 201./255.};; 3540 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3541 }; 3542 break;; 3543 ; 3544 // Visible Spectrum; 3545 case 107:; 3546 {; 3547 Double_t red[9] = { 18./255., 72./255., 5./255., 23./255., 29./255., 201",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TColor_8cxx_source.html:139905,green,green,139905,doc/master/TColor_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html,1,['green'],['green']
Energy Efficiency,"5., 135./255., 124./255., 117./255., 117./255., 132./255., 172./255.};; 3399 Double_t blue[9] = { 186./255., 165./255., 155./255., 135./255., 126./255., 130./255., 150./255., 178./255., 226./255.};; 3400 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3401 }; 3402 break;; 3403 ; 3404 // Pigeon; 3405 case 93:; 3406 {; 3407 Double_t red[9] = { 39./255., 43./255., 59./255., 63./255., 80./255., 116./255., 153./255., 177./255., 223./255.};; 3408 Double_t green[9] = { 39./255., 43./255., 59./255., 74./255., 91./255., 114./255., 139./255., 165./255., 223./255.};; 3409 Double_t blue[9] = { 39./255., 50./255., 59./255., 70./255., 85./255., 115./255., 151./255., 176./255., 223./255.};; 3410 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3411 }; 3412 break;; 3413 ; 3414 // Plum; 3415 case 94:; 3416 {; 3417 Double_t red[9] = { 0./255., 38./255., 60./255., 76./255., 84./255., 89./255., 101./255., 128./255., 204./255.};; 3418 Double_t green[9] = { 0./255., 10./255., 15./255., 23./255., 35./255., 57./255., 83./255., 123./255., 199./255.};; 3419 Double_t blue[9] = { 0./255., 11./255., 22./255., 40./255., 63./255., 86./255., 97./255., 94./255., 85./255.};; 3420 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3421 }; 3422 break;; 3423 ; 3424 // Red Blue; 3425 case 95:; 3426 {; 3427 Double_t red[9] = { 94./255., 112./255., 141./255., 165./255., 167./255., 140./255., 91./255., 49./255., 27./255.};; 3428 Double_t green[9] = { 27./255., 46./255., 88./255., 135./255., 166./255., 161./255., 135./255., 97./255., 58./255.};; 3429 Double_t blue[9] = { 42./255., 52./255., 81./255., 106./255., 139./255., 158./255., 155./255., 137./255., 116./255.};; 3430 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3431 }; 3432 break;; 3433 ; 3434 // Rose; 3435 case 96:; 3436 {; 3437 Double_t red[9] = { 30./255., 49./255., 79./255., 117./255., 135./255., 151./255., 146./255., 13",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TColor_8cxx_source.html:134172,green,green,134172,doc/master/TColor_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html,1,['green'],['green']
Energy Efficiency,"5., 37./255., 56./255., 81./255., 110./255., 136./255., 189./255.};; 3539 Double_t blue[9] = { 38./255., 35./255., 46./255., 59./255., 78./255., 103./255., 130./255., 152./255., 201./255.};; 3540 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3541 }; 3542 break;; 3543 ; 3544 // Visible Spectrum; 3545 case 107:; 3546 {; 3547 Double_t red[9] = { 18./255., 72./255., 5./255., 23./255., 29./255., 201./255., 200./255., 98./255., 29./255.};; 3548 Double_t green[9] = { 0./255., 0./255., 43./255., 167./255., 211./255., 117./255., 0./255., 0./255., 0./255.};; 3549 Double_t blue[9] = { 51./255., 203./255., 177./255., 26./255., 10./255., 9./255., 8./255., 3./255., 0./255.};; 3550 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3551 }; 3552 break;; 3553 ; 3554 // Water Melon; 3555 case 108:; 3556 {; 3557 Double_t red[9] = { 19./255., 42./255., 64./255., 88./255., 118./255., 147./255., 175./255., 187./255., 205./255.};; 3558 Double_t green[9] = { 19./255., 55./255., 89./255., 125./255., 154./255., 169./255., 161./255., 129./255., 70./255.};; 3559 Double_t blue[9] = { 19./255., 32./255., 47./255., 70./255., 100./255., 128./255., 145./255., 130./255., 75./255.};; 3560 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3561 }; 3562 break;; 3563 ; 3564 // Cool; 3565 case 109:; 3566 {; 3567 Double_t red[9] = { 33./255., 31./255., 42./255., 68./255., 86./255., 111./255., 141./255., 172./255., 227./255.};; 3568 Double_t green[9] = { 255./255., 175./255., 145./255., 106./255., 88./255., 55./255., 15./255., 0./255., 0./255.};; 3569 Double_t blue[9] = { 255./255., 205./255., 202./255., 203./255., 208./255., 205./255., 203./255., 206./255., 231./255.};; 3570 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3571 }; 3572 break;; 3573 ; 3574 // Copper; 3575 case 110:; 3576 {; 3577 Double_t red[9] = { 0./255., 25./255., 50./255., 79./255., 110./255., 145./255., 181./2",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TColor_8cxx_source.html:141473,green,green,141473,doc/master/TColor_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html,1,['green'],['green']
Energy Efficiency,"5., 72./255., 90./255., 94./255., 94./255., 68./255., 46./255., 16./255.};; 3439 Double_t blue[9] = { 18./255., 28./255., 41./255., 56./255., 62./255., 63./255., 50./255., 36./255., 21./255.};; 3440 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3441 }; 3442 break;; 3443 ; 3444 // Rust; 3445 case 97:; 3446 {; 3447 Double_t red[9] = { 0./255., 30./255., 63./255., 101./255., 143./255., 152./255., 169./255., 187./255., 230./255.};; 3448 Double_t green[9] = { 0./255., 14./255., 28./255., 42./255., 58./255., 61./255., 67./255., 74./255., 91./255.};; 3449 Double_t blue[9] = { 39./255., 26./255., 21./255., 18./255., 15./255., 14./255., 14./255., 13./255., 13./255.};; 3450 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3451 }; 3452 break;; 3453 ; 3454 // Sandy Terrain; 3455 case 98:; 3456 {; 3457 Double_t red[9] = { 149./255., 140./255., 164./255., 179./255., 182./255., 181./255., 131./255., 87./255., 61./255.};; 3458 Double_t green[9] = { 62./255., 70./255., 107./255., 136./255., 144./255., 138./255., 117./255., 87./255., 74./255.};; 3459 Double_t blue[9] = { 40./255., 38./255., 45./255., 49./255., 49./255., 49./255., 38./255., 32./255., 34./255.};; 3460 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3461 }; 3462 break;; 3463 ; 3464 // Sienna; 3465 case 99:; 3466 {; 3467 Double_t red[9] = { 99./255., 112./255., 148./255., 165./255., 179./255., 182./255., 183./255., 183./255., 208./255.};; 3468 Double_t green[9] = { 39./255., 40./255., 57./255., 79./255., 104./255., 127./255., 148./255., 161./255., 198./255.};; 3469 Double_t blue[9] = { 15./255., 16./255., 18./255., 33./255., 51./255., 79./255., 103./255., 129./255., 177./255.};; 3470 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3471 }; 3472 break;; 3473 ; 3474 // Solar; 3475 case 100:; 3476 {; 3477 Double_t red[9] = { 99./255., 116./255., 154./255., 174./255., 200./255., 196./255., 201./",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TColor_8cxx_source.html:136237,green,green,136237,doc/master/TColor_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html,1,['green'],['green']
Energy Efficiency,"5., 88./255., 135./255., 166./255., 161./255., 135./255., 97./255., 58./255.};; 3429 Double_t blue[9] = { 42./255., 52./255., 81./255., 106./255., 139./255., 158./255., 155./255., 137./255., 116./255.};; 3430 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3431 }; 3432 break;; 3433 ; 3434 // Rose; 3435 case 96:; 3436 {; 3437 Double_t red[9] = { 30./255., 49./255., 79./255., 117./255., 135./255., 151./255., 146./255., 138./255., 147./255.};; 3438 Double_t green[9] = { 63./255., 60./255., 72./255., 90./255., 94./255., 94./255., 68./255., 46./255., 16./255.};; 3439 Double_t blue[9] = { 18./255., 28./255., 41./255., 56./255., 62./255., 63./255., 50./255., 36./255., 21./255.};; 3440 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3441 }; 3442 break;; 3443 ; 3444 // Rust; 3445 case 97:; 3446 {; 3447 Double_t red[9] = { 0./255., 30./255., 63./255., 101./255., 143./255., 152./255., 169./255., 187./255., 230./255.};; 3448 Double_t green[9] = { 0./255., 14./255., 28./255., 42./255., 58./255., 61./255., 67./255., 74./255., 91./255.};; 3449 Double_t blue[9] = { 39./255., 26./255., 21./255., 18./255., 15./255., 14./255., 14./255., 13./255., 13./255.};; 3450 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3451 }; 3452 break;; 3453 ; 3454 // Sandy Terrain; 3455 case 98:; 3456 {; 3457 Double_t red[9] = { 149./255., 140./255., 164./255., 179./255., 182./255., 181./255., 131./255., 87./255., 61./255.};; 3458 Double_t green[9] = { 62./255., 70./255., 107./255., 136./255., 144./255., 138./255., 117./255., 87./255., 74./255.};; 3459 Double_t blue[9] = { 40./255., 38./255., 45./255., 49./255., 49./255., 49./255., 38./255., 32./255., 34./255.};; 3460 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3461 }; 3462 break;; 3463 ; 3464 // Sienna; 3465 case 99:; 3466 {; 3467 Double_t red[9] = { 99./255., 112./255., 148./255., 165./255., 179./255., 182./255., 183./255",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TColor_8cxx_source.html:135717,green,green,135717,doc/master/TColor_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html,1,['green'],['green']
Energy Efficiency,"5.34.18 (has no typedef at all); 115 kNoRangeCheck = 6, // Up to v5.34.18 and v5.99/06; 116 kNoBaseCheckSum = 7, // Up to v5.34.18 and v5.99/06; 117 kLatestCheckSum = 8; 118 };; 119 ; 120 // Describe the current state of the TClass itself.; 121 enum EState {; 122 kNoInfo, // The state has not yet been initialized, i.e. the TClass; 123 // was just created and/or there is no trace of it in the interpreter.; 124 kForwardDeclared, // The interpreted knows the entity is a class but that's it.; 125 kEmulated, // The information about the class only comes from a TStreamerInfo; 126 kInterpreted, // The class is described completely/only in the interpreter database.; 127 kHasTClassInit, // The class has a TClass proper bootstrap coming from a run; 128 // through rootcling/genreflex/TMetaUtils and the library; 129 // containing this dictionary has been loaded in memory.; 130 kLoaded = kHasTClassInit,; 131 kNamespaceForMeta // Very transient state necessary to bootstrap namespace entries; 132 // in ROOT Meta w/o interpreter information; 133 };; 134 ; 135 // ""Typed"" pointer that recalls how TClass::New allocated the object.; 136 // It is returned by TClass:NewObject and should be passed to TClass::DeleteArray or TClass::Destructor; 137 // to delete the object.; 138 // It is also used in TVirtualCollectionProxy for the same reasons.; 139 struct ObjectPtr; 140 {; 141 void *fPtr = nullptr;; 142 ; 143 TVirtualStreamerInfo *fAllocator = nullptr;; 144 ; 145 ObjectPtr(void *ptr = nullptr, TVirtualStreamerInfo *allocator = nullptr) : fPtr(ptr), fAllocator(allocator) {}; 146 ; 147 void *GetPtr() const { return fPtr; }; 148 ; 149 TVirtualStreamerInfo *GetAllocator() const { return fAllocator; }; 150 ; 151 operator bool() const { return fPtr != nullptr; }; 152 };; 153 ; 154private:; 155 ; 156 ; 157 ; 158 class TDeclNameRegistry {; 159 // A class which is used to collect decl names starting from normalised; 160 // names (typedef resolution is excluded here, just string manipulation; 161 // ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8h_source.html:4684,allocate,allocated,4684,doc/master/TClass_8h_source.html,https://root.cern,https://root.cern/doc/master/TClass_8h_source.html,2,['allocate'],['allocated']
Energy Efficiency,"513 path.Form(""%s/BUILD.sh"", proofinf);; 3514#ifdef R__WINGCC; 3515 FILE *f = fopen(path.Data(), ""wb"");; 3516#else; 3517 FILE *f = fopen(path.Data(), ""w"");; 3518#endif; 3519 if (!f) {; 3520 Error(""MakeProjectParProofInf"", ""cannot create file '%s' (errno: %d)"",; 3521 path.Data(), TSystem::GetErrno());; 3522 return -1;; 3523 }; 3524 ; 3525 fprintf(f, ""#! /bin/sh\n"");; 3526 fprintf(f, ""# Build libEvent library.\n"");; 3527 fprintf(f, ""\n"");; 3528 fprintf(f, ""#\n"");; 3529 fprintf(f, ""# The environment variables ROOTPROOFLITE and ROOTPROOFCLIENT can be used to\n"");; 3530 fprintf(f, ""# adapt the script to the calling environment\n"");; 3531 fprintf(f, ""#\n"");; 3532 fprintf(f, ""# if test ! \""x$ROOTPROOFLITE\"" = \""x\""; then\n"");; 3533 fprintf(f, ""# echo \""event-BUILD: PROOF-Lite node (session has $ROOTPROOFLITE workers)\""\n"");; 3534 fprintf(f, ""# elif test ! \""x$ROOTPROOFCLIENT\"" = \""x\""; then\n"");; 3535 fprintf(f, ""# echo \""event-BUILD: PROOF client\""\n"");; 3536 fprintf(f, ""# else\n"");; 3537 fprintf(f, ""# echo \""event-BUILD: standard PROOF node\""\n"");; 3538 fprintf(f, ""# fi\n"");; 3539 fprintf(f, ""\n"");; 3540 fprintf(f, ""if [ \""\"" = \""clean\"" ]; then\n"");; 3541 fprintf(f, "" make distclean\n"");; 3542 fprintf(f, "" exit 0\n"");; 3543 fprintf(f, ""fi\n"");; 3544 fprintf(f, ""\n"");; 3545 fprintf(f, ""make\n"");; 3546 fprintf(f, ""rc=$?\n"");; 3547 fprintf(f, ""echo \""rc=$?\""\n"");; 3548 fprintf(f, ""if [ $? != \""0\"" ] ; then\n"");; 3549 fprintf(f, "" exit 1\n"");; 3550 fprintf(f, ""fi\n"");; 3551 fprintf(f, ""exit 0\n"");; 3552 ; 3553 // Close the file; 3554 fclose(f);; 3555 ; 3556 // Then SETUP.C; 3557 path.Form(""%s/SETUP.C"", proofinf);; 3558#ifdef R__WINGCC; 3559 f = fopen(path.Data(), ""wb"");; 3560#else; 3561 f = fopen(path.Data(), ""w"");; 3562#endif; 3563 if (!f) {; 3564 Error(""MakeProjectParProofInf"", ""cannot create file '%s' (errno: %d)"",; 3565 path.Data(), TSystem::GetErrno());; 3566 return -1;; 3567 }; 3568 ; 3569 fprintf(f, ""Int_t SETUP()\n"");; 3570 fprintf(f, ""{\n"");; 3571 fprintf(f, ""\n"");;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:128214,adapt,adapt,128214,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,1,['adapt'],['adapt']
Energy Efficiency,"516 {; 3517 Double_t red[9] = { 34./255., 70./255., 129./255., 187./255., 225./255., 226./255., 216./255., 193./255., 179./255.};; 3518 Double_t green[9] = { 48./255., 91./255., 147./255., 194./255., 226./255., 229./255., 196./255., 110./255., 12./255.};; 3519 Double_t blue[9] = { 234./255., 212./255., 216./255., 224./255., 206./255., 110./255., 53./255., 40./255., 29./255.};; 3520 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3521 }; 3522 break;; 3523 ; 3524 // Thermometer; 3525 case 105:; 3526 {; 3527 Double_t red[9] = { 30./255., 55./255., 103./255., 147./255., 174./255., 203./255., 188./255., 151./255., 105./255.};; 3528 Double_t green[9] = { 0./255., 65./255., 138./255., 182./255., 187./255., 175./255., 121./255., 53./255., 9./255.};; 3529 Double_t blue[9] = { 191./255., 202./255., 212./255., 208./255., 171./255., 140./255., 97./255., 57./255., 30./255.};; 3530 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3531 }; 3532 break;; 3533 ; 3534 // Valentine; 3535 case 106:; 3536 {; 3537 Double_t red[9] = { 112./255., 97./255., 113./255., 125./255., 138./255., 159./255., 178./255., 188./255., 225./255.};; 3538 Double_t green[9] = { 16./255., 17./255., 24./255., 37./255., 56./255., 81./255., 110./255., 136./255., 189./255.};; 3539 Double_t blue[9] = { 38./255., 35./255., 46./255., 59./255., 78./255., 103./255., 130./255., 152./255., 201./255.};; 3540 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3541 }; 3542 break;; 3543 ; 3544 // Visible Spectrum; 3545 case 107:; 3546 {; 3547 Double_t red[9] = { 18./255., 72./255., 5./255., 23./255., 29./255., 201./255., 200./255., 98./255., 29./255.};; 3548 Double_t green[9] = { 0./255., 0./255., 43./255., 167./255., 211./255., 117./255., 0./255., 0./255., 0./255.};; 3549 Double_t blue[9] = { 51./255., 203./255., 177./255., 26./255., 10./255., 9./255., 8./255., 3./255., 0./255.};; 3550 Idx = TColor::CreateGradientColorTable(9, sto",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TColor_8cxx_source.html:140196,green,green,140196,doc/master/TColor_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html,1,['green'],['green']
Energy Efficiency,"53 * and return allocated buffer. */; 6854static int; 6855alloc_vprintf(char **out_buf,; 6856 char *prealloc_buf,; 6857 size_t prealloc_size,; 6858 const char *fmt,; 6859 va_list ap); 6860{; 6861 va_list ap_copy;; 6862 int len;; 6863 ; 6864 /* Windows is not standard-compliant, and vsnprintf() returns -1 if; 6865 * buffer is too small. Also, older versions of msvcrt.dll do not have; 6866 * _vscprintf(). However, if size is 0, vsnprintf() behaves correctly.; 6867 * Therefore, we make two passes: on first pass, get required message; 6868 * length.; 6869 * On second pass, actually print the message. */; 6870 va_copy(ap_copy, ap);; 6871 len = vsnprintf_impl(NULL, 0, fmt, ap_copy);; 6872 va_end(ap_copy);; 6873 ; 6874 if (len < 0) {; 6875 /* C runtime is not standard compliant, vsnprintf() returned -1.; 6876 * Switch to alternative code path that uses incremental; 6877 * allocations.; 6878 */; 6879 va_copy(ap_copy, ap);; 6880 len = alloc_vprintf2(out_buf, fmt, ap_copy);; 6881 va_end(ap_copy);; 6882 ; 6883 } else if ((size_t)(len) >= prealloc_size) {; 6884 /* The pre-allocated buffer not large enough. */; 6885 /* Allocate a new buffer. */; 6886 *out_buf = (char *)mg_malloc((size_t)(len) + 1);; 6887 if (!*out_buf) {; 6888 /* Allocation failed. Return -1 as ""out of memory"" error. */; 6889 return -1;; 6890 }; 6891 /* Buffer allocation successful. Store the string there. */; 6892 va_copy(ap_copy, ap);; 6893 IGNORE_UNUSED_RESULT(; 6894 vsnprintf_impl(*out_buf, (size_t)(len) + 1, fmt, ap_copy));; 6895 va_end(ap_copy);; 6896 ; 6897 } else {; 6898 /* The pre-allocated buffer is large enough.; 6899 * Use it to store the string and return the address. */; 6900 va_copy(ap_copy, ap);; 6901 IGNORE_UNUSED_RESULT(; 6902 vsnprintf_impl(prealloc_buf, prealloc_size, fmt, ap_copy));; 6903 va_end(ap_copy);; 6904 *out_buf = prealloc_buf;; 6905 }; 6906 ; 6907 return len;; 6908}; 6909 ; 6910 ; 6911#if defined(GCC_DIAGNOSTIC); 6912/* Enable format-nonliteral warning again. */; 6913#pragma GCC diag",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:199271,allocate,allocated,199271,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['allocate'],['allocated']
Energy Efficiency,"5373 // -- Caller wants us to allocate the STL container, but they will own it.; 5374 *pp = proxy->New();; 5375 if (!(*pp)) {; 5376 Error(""SetAddress"", ""Failed to allocate STL container for branch '%s'"", GetName());; 5377 // FIXME: Should we do this? Lots of other code wants; 5378 // fAddress to be zero if no fObject, but is; 5379 // that a good thing?; 5380 fAddress = nullptr;; 5381 ResetBit(kAddressSet);; 5382 }; 5383 }; 5384 fObject = (char*) *pp;; 5385 } else {; 5386 // -- We are a pointer to an STL container.; 5387 // Note: We do this so that the default constructor,; 5388 // or the i/o constructor can be lazy.; 5389 void** pp = (void**) fAddress;; 5390 if (!*pp) {; 5391 // -- Caller wants us to allocate the STL container, but they will own it.; 5392 *pp = proxy->New();; 5393 if (!(*pp)) {; 5394 Error(""SetAddress"", ""Failed to allocate STL container for branch '%s'"", GetName());; 5395 // FIXME: Should we do this? Lots of other code wants; 5396 // fAddress to be zero if no fObject, but is; 5397 // that a good thing?; 5398 fAddress = nullptr;; 5399 ResetBit(kAddressSet);; 5400 }; 5401 }; 5402 fObject = (char*) *pp;; 5403 }; 5404 }; 5405 } else {; 5406 // -- We have been given a zero address, allocate for top-level only.; 5407 if ((fStreamerType == TVirtualStreamerInfo::kObject) ||; 5408 (fStreamerType == TVirtualStreamerInfo::kAny) ||; 5409 (fStreamerType == TVirtualStreamerInfo::kSTL)) {; 5410 // We are *not* a top-level branch and we are *not* a pointer to an STL container.; 5411 // Case of an embedded STL container.; 5412 // Note: We test for the kObject and kAny types to support; 5413 // the (unwise) choice of inheriting from an STL container.; 5414 Error(""SetAddress"", ""Embedded STL container given a zero address for branch '%s'"", GetName());; 5415 } else {; 5416 // We are either a top-level branch or sub-branch which is a pointer to an STL container.; 5417 // Streamer type should be -1 (for a top-level branch) or kSTLp here.; 5418 if ((fStreamerType != -1) &&",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBranchElement_8cxx_source.html:200195,allocate,allocate,200195,doc/master/TBranchElement_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html,2,['allocate'],['allocate']
Energy Efficiency,"54 * and return allocated buffer. */; 6855static int; 6856alloc_vprintf(char **out_buf,; 6857 char *prealloc_buf,; 6858 size_t prealloc_size,; 6859 const char *fmt,; 6860 va_list ap); 6861{; 6862 va_list ap_copy;; 6863 int len;; 6864 ; 6865 /* Windows is not standard-compliant, and vsnprintf() returns -1 if; 6866 * buffer is too small. Also, older versions of msvcrt.dll do not have; 6867 * _vscprintf(). However, if size is 0, vsnprintf() behaves correctly.; 6868 * Therefore, we make two passes: on first pass, get required message; 6869 * length.; 6870 * On second pass, actually print the message. */; 6871 va_copy(ap_copy, ap);; 6872 len = vsnprintf_impl(NULL, 0, fmt, ap_copy);; 6873 va_end(ap_copy);; 6874 ; 6875 if (len < 0) {; 6876 /* C runtime is not standard compliant, vsnprintf() returned -1.; 6877 * Switch to alternative code path that uses incremental; 6878 * allocations.; 6879 */; 6880 va_copy(ap_copy, ap);; 6881 len = alloc_vprintf2(out_buf, fmt, ap_copy);; 6882 va_end(ap_copy);; 6883 ; 6884 } else if ((size_t)(len) >= prealloc_size) {; 6885 /* The pre-allocated buffer not large enough. */; 6886 /* Allocate a new buffer. */; 6887 *out_buf = (char *)mg_malloc((size_t)(len) + 1);; 6888 if (!*out_buf) {; 6889 /* Allocation failed. Return -1 as ""out of memory"" error. */; 6890 return -1;; 6891 }; 6892 /* Buffer allocation successful. Store the string there. */; 6893 va_copy(ap_copy, ap);; 6894 IGNORE_UNUSED_RESULT(; 6895 vsnprintf_impl(*out_buf, (size_t)(len) + 1, fmt, ap_copy));; 6896 va_end(ap_copy);; 6897 ; 6898 } else {; 6899 /* The pre-allocated buffer is large enough.; 6900 * Use it to store the string and return the address. */; 6901 va_copy(ap_copy, ap);; 6902 IGNORE_UNUSED_RESULT(; 6903 vsnprintf_impl(prealloc_buf, prealloc_size, fmt, ap_copy));; 6904 va_end(ap_copy);; 6905 *out_buf = prealloc_buf;; 6906 }; 6907 ; 6908 return len;; 6909}; 6910 ; 6911 ; 6912#if defined(GCC_DIAGNOSTIC); 6913/* Enable format-nonliteral warning again. */; 6914#pragma GCC diag",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:199303,allocate,allocated,199303,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['allocate'],['allocated']
Energy Efficiency,"55 case 68:; 3156 {; 3157 Double_t red[9] = { 0./255., 4./255., 12./255., 30./255., 52./255., 101./255., 142./255., 190./255., 237./255.};; 3158 Double_t green[9] = { 0./255., 40./255., 86./255., 121./255., 140./255., 172./255., 187./255., 213./255., 240./255.};; 3159 Double_t blue[9] = { 0./255., 9./255., 14./255., 18./255., 21./255., 23./255., 27./255., 35./255., 101./255.};; 3160 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3161 }; 3162 break;; 3163 ; 3164 // Beach; 3165 case 69:; 3166 {; 3167 Double_t red[9] = { 198./255., 206./255., 206./255., 211./255., 198./255., 181./255., 161./255., 171./255., 244./255.};; 3168 Double_t green[9] = { 103./255., 133./255., 150./255., 172./255., 178./255., 174./255., 163./255., 175./255., 244./255.};; 3169 Double_t blue[9] = { 49./255., 54./255., 55./255., 66./255., 91./255., 130./255., 184./255., 224./255., 244./255.};; 3170 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3171 }; 3172 break;; 3173 ; 3174 // Black Body; 3175 case 70:; 3176 {; 3177 Double_t red[9] = { 243./255., 243./255., 240./255., 240./255., 241./255., 239./255., 186./255., 151./255., 129./255.};; 3178 Double_t green[9] = { 0./255., 46./255., 99./255., 149./255., 194./255., 220./255., 183./255., 166./255., 147./255.};; 3179 Double_t blue[9] = { 6./255., 8./255., 36./255., 91./255., 169./255., 235./255., 246./255., 240./255., 233./255.};; 3180 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3181 }; 3182 break;; 3183 ; 3184 // Blue Green Yellow; 3185 case 71:; 3186 {; 3187 Double_t red[9] = { 22./255., 19./255., 19./255., 25./255., 35./255., 53./255., 88./255., 139./255., 210./255.};; 3188 Double_t green[9] = { 0./255., 32./255., 69./255., 108./255., 135./255., 159./255., 183./255., 198./255., 215./255.};; 3189 Double_t blue[9] = { 77./255., 96./255., 110./255., 116./255., 110./255., 100./255., 90./255., 78./255., 70./255.};; 3190 Idx = TColor::CreateGradientC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TColor_8cxx_source.html:121309,green,green,121309,doc/master/TColor_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html,1,['green'],['green']
Energy Efficiency,"55., 135./255., 152./255., 149./255., 132./255., 119./255.};; 3489 Double_t blue[9] = { 39./255., 25./255., 31./255., 60./255., 73./255., 68./255., 49./255., 72./255., 188./255.};; 3490 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3491 }; 3492 break;; 3493 ; 3494 // Starry Night; 3495 case 102:; 3496 {; 3497 Double_t red[9] = { 18./255., 29./255., 44./255., 72./255., 116./255., 158./255., 184./255., 208./255., 221./255.};; 3498 Double_t green[9] = { 27./255., 46./255., 71./255., 105./255., 146./255., 177./255., 189./255., 190./255., 183./255.};; 3499 Double_t blue[9] = { 39./255., 55./255., 80./255., 108./255., 130./255., 133./255., 124./255., 100./255., 76./255.};; 3500 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3501 }; 3502 break;; 3503 ; 3504 // Sunset; 3505 case 103:; 3506 {; 3507 Double_t red[9] = { 0./255., 48./255., 119./255., 173./255., 212./255., 224./255., 228./255., 228./255., 245./255.};; 3508 Double_t green[9] = { 0./255., 13./255., 30./255., 47./255., 79./255., 127./255., 167./255., 205./255., 245./255.};; 3509 Double_t blue[9] = { 0./255., 68./255., 75./255., 43./255., 16./255., 22./255., 55./255., 128./255., 245./255.};; 3510 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3511 }; 3512 break;; 3513 ; 3514 // Temperature Map; 3515 case 104:; 3516 {; 3517 Double_t red[9] = { 34./255., 70./255., 129./255., 187./255., 225./255., 226./255., 216./255., 193./255., 179./255.};; 3518 Double_t green[9] = { 48./255., 91./255., 147./255., 194./255., 226./255., 229./255., 196./255., 110./255., 12./255.};; 3519 Double_t blue[9] = { 234./255., 212./255., 216./255., 224./255., 206./255., 110./255., 53./255., 40./255., 29./255.};; 3520 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3521 }; 3522 break;; 3523 ; 3524 // Thermometer; 3525 case 105:; 3526 {; 3527 Double_t red[9] = { 30./255., 55./255., 103./255., 147./255., 174./255.,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TColor_8cxx_source.html:138845,green,green,138845,doc/master/TColor_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html,1,['green'],['green']
Energy Efficiency,"55., 238./255., 243./255.};; 3009 Double_t blue[9] = { 0./255., 1./255., 1./255., 3./255., 9./255., 8./255., 11./255., 95./255., 230./255.};; 3010 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3011 }; 3012 break;; 3013 ; 3014 // Two-color hue (dark blue through neutral gray to bright yellow); 3015 case 54:; 3016 {; 3017 Double_t red[9] = { 0./255., 22./255., 44./255., 68./255., 93./255., 124./255., 160./255., 192./255., 237./255.};; 3018 Double_t green[9] = { 0./255., 16./255., 41./255., 67./255., 93./255., 125./255., 162./255., 194./255., 241./255.};; 3019 Double_t blue[9] = { 97./255., 100./255., 99./255., 99./255., 93./255., 68./255., 44./255., 26./255., 74./255.};; 3020 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3021 }; 3022 break;; 3023 ; 3024 // Rain Bow; 3025 case 55:; 3026 {; 3027 Double_t red[9] = { 0./255., 5./255., 15./255., 35./255., 102./255., 196./255., 208./255., 199./255., 110./255.};; 3028 Double_t green[9] = { 0./255., 48./255., 124./255., 192./255., 206./255., 226./255., 97./255., 16./255., 0./255.};; 3029 Double_t blue[9] = { 99./255., 142./255., 198./255., 201./255., 90./255., 22./255., 13./255., 8./255., 2./255.};; 3030 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3031 }; 3032 break;; 3033 ; 3034 // Inverted Dark Body Radiator; 3035 case 56:; 3036 {; 3037 Double_t red[9] = { 242./255., 234./255., 237./255., 230./255., 212./255., 156./255., 99./255., 45./255., 0./255.};; 3038 Double_t green[9] = { 243./255., 238./255., 238./255., 168./255., 101./255., 45./255., 0./255., 0./255., 0./255.};; 3039 Double_t blue[9] = { 230./255., 95./255., 11./255., 8./255., 9./255., 3./255., 1./255., 1./255., 0./255.};; 3040 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3041 }; 3042 break;; 3043 ; 3044 // Bird; 3045 case 57:; 3046 {; 3047 Double_t red[9] = { 0.2082, 0.0592, 0.0780, 0.0232, 0.1802, 0.5301, 0.8186, 0.9956, 0.9",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TColor_8cxx_source.html:113851,green,green,113851,doc/master/TColor_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html,1,['green'],['green']
Energy Efficiency,"55., 59./255., 74./255., 91./255., 114./255., 139./255., 165./255., 223./255.};; 3409 Double_t blue[9] = { 39./255., 50./255., 59./255., 70./255., 85./255., 115./255., 151./255., 176./255., 223./255.};; 3410 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3411 }; 3412 break;; 3413 ; 3414 // Plum; 3415 case 94:; 3416 {; 3417 Double_t red[9] = { 0./255., 38./255., 60./255., 76./255., 84./255., 89./255., 101./255., 128./255., 204./255.};; 3418 Double_t green[9] = { 0./255., 10./255., 15./255., 23./255., 35./255., 57./255., 83./255., 123./255., 199./255.};; 3419 Double_t blue[9] = { 0./255., 11./255., 22./255., 40./255., 63./255., 86./255., 97./255., 94./255., 85./255.};; 3420 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3421 }; 3422 break;; 3423 ; 3424 // Red Blue; 3425 case 95:; 3426 {; 3427 Double_t red[9] = { 94./255., 112./255., 141./255., 165./255., 167./255., 140./255., 91./255., 49./255., 27./255.};; 3428 Double_t green[9] = { 27./255., 46./255., 88./255., 135./255., 166./255., 161./255., 135./255., 97./255., 58./255.};; 3429 Double_t blue[9] = { 42./255., 52./255., 81./255., 106./255., 139./255., 158./255., 155./255., 137./255., 116./255.};; 3430 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3431 }; 3432 break;; 3433 ; 3434 // Rose; 3435 case 96:; 3436 {; 3437 Double_t red[9] = { 30./255., 49./255., 79./255., 117./255., 135./255., 151./255., 146./255., 138./255., 147./255.};; 3438 Double_t green[9] = { 63./255., 60./255., 72./255., 90./255., 94./255., 94./255., 68./255., 46./255., 16./255.};; 3439 Double_t blue[9] = { 18./255., 28./255., 41./255., 56./255., 62./255., 63./255., 50./255., 36./255., 21./255.};; 3440 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3441 }; 3442 break;; 3443 ; 3444 // Rust; 3445 case 97:; 3446 {; 3447 Double_t red[9] = { 0./255., 30./255., 63./255., 101./255., 143./255., 152./255., 169./255., 187./2",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TColor_8cxx_source.html:134686,green,green,134686,doc/master/TColor_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html,1,['green'],['green']
Energy Efficiency,"55., 67./255., 91./255., 132./255., 185./255., 251./255.};; 3229 Double_t blue[9] = { 37./255., 32./255., 33./255., 45./255., 66./255., 98./255., 137./255., 187./255., 251./255.};; 3230 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3231 }; 3232 break;; 3233 ; 3234 // Coffee; 3235 case 76:; 3236 {; 3237 Double_t red[9] = { 79./255., 100./255., 119./255., 137./255., 153./255., 172./255., 192./255., 205./255., 250./255.};; 3238 Double_t green[9] = { 63./255., 79./255., 93./255., 103./255., 115./255., 135./255., 167./255., 196./255., 250./255.};; 3239 Double_t blue[9] = { 51./255., 59./255., 66./255., 61./255., 62./255., 70./255., 110./255., 160./255., 250./255.};; 3240 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3241 }; 3242 break;; 3243 ; 3244 // Dark Rain Bow; 3245 case 77:; 3246 {; 3247 Double_t red[9] = { 43./255., 44./255., 50./255., 66./255., 125./255., 172./255., 178./255., 155./255., 157./255.};; 3248 Double_t green[9] = { 63./255., 63./255., 85./255., 101./255., 138./255., 163./255., 122./255., 51./255., 39./255.};; 3249 Double_t blue[9] = { 121./255., 101./255., 58./255., 44./255., 47./255., 55./255., 57./255., 44./255., 43./255.};; 3250 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3251 }; 3252 break;; 3253 ; 3254 // Dark Terrain; 3255 case 78:; 3256 {; 3257 Double_t red[9] = { 0./255., 41./255., 62./255., 79./255., 90./255., 87./255., 99./255., 140./255., 228./255.};; 3258 Double_t green[9] = { 0./255., 57./255., 81./255., 93./255., 85./255., 70./255., 71./255., 125./255., 228./255.};; 3259 Double_t blue[9] = { 95./255., 91./255., 91./255., 82./255., 60./255., 43./255., 44./255., 112./255., 228./255.};; 3260 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3261 }; 3262 break;; 3263 ; 3264 // Fall; 3265 case 79:; 3266 {; 3267 Double_t red[9] = { 49./255., 59./255., 72./255., 88./255., 114./255., 141./255., 176./255., 205.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TColor_8cxx_source.html:125230,green,green,125230,doc/master/TColor_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html,1,['green'],['green']
Energy Efficiency,"555 case 108:; 3556 {; 3557 Double_t red[9] = { 19./255., 42./255., 64./255., 88./255., 118./255., 147./255., 175./255., 187./255., 205./255.};; 3558 Double_t green[9] = { 19./255., 55./255., 89./255., 125./255., 154./255., 169./255., 161./255., 129./255., 70./255.};; 3559 Double_t blue[9] = { 19./255., 32./255., 47./255., 70./255., 100./255., 128./255., 145./255., 130./255., 75./255.};; 3560 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3561 }; 3562 break;; 3563 ; 3564 // Cool; 3565 case 109:; 3566 {; 3567 Double_t red[9] = { 33./255., 31./255., 42./255., 68./255., 86./255., 111./255., 141./255., 172./255., 227./255.};; 3568 Double_t green[9] = { 255./255., 175./255., 145./255., 106./255., 88./255., 55./255., 15./255., 0./255., 0./255.};; 3569 Double_t blue[9] = { 255./255., 205./255., 202./255., 203./255., 208./255., 205./255., 203./255., 206./255., 231./255.};; 3570 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3571 }; 3572 break;; 3573 ; 3574 // Copper; 3575 case 110:; 3576 {; 3577 Double_t red[9] = { 0./255., 25./255., 50./255., 79./255., 110./255., 145./255., 181./255., 201./255., 254./255.};; 3578 Double_t green[9] = { 0./255., 16./255., 30./255., 46./255., 63./255., 82./255., 101./255., 124./255., 179./255.};; 3579 Double_t blue[9] = { 0./255., 12./255., 21./255., 29./255., 39./255., 49./255., 61./255., 74./255., 103./255.};; 3580 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3581 }; 3582 break;; 3583 ; 3584 // Gist Earth; 3585 case 111:; 3586 {; 3587 Double_t red[9] = { 0./255., 13./255., 30./255., 44./255., 72./255., 120./255., 156./255., 200./255., 247./255.};; 3588 Double_t green[9] = { 0./255., 36./255., 84./255., 117./255., 141./255., 153./255., 151./255., 158./255., 247./255.};; 3589 Double_t blue[9] = { 0./255., 94./255., 100./255., 82./255., 56./255., 66./255., 76./255., 131./255., 247./255.};; 3590 Idx = TColor::CreateGradientColorTable(9, stops,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TColor_8cxx_source.html:142285,green,green,142285,doc/master/TColor_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html,1,['green'],['green']
Energy Efficiency,"58- [Example](\ref example); 1359- [Arithmetic operations, logical operations and mathematical functions](\ref operationsandfunctions); 1360- [Owning and adopting memory](\ref owningandadoptingmemory); 1361- [Sorting and manipulation of indices](\ref sorting); 1362- [Usage in combination with RDataFrame](\ref usagetdataframe); 1363- [Reference for the RVec class](\ref RVecdoxyref); 1364- [Reference for RVec helper functions](https://root.cern/doc/master/namespaceROOT_1_1VecOps.html); 1365 ; 1366\anchor example; 1367## Example; 1368Suppose to have an event featuring a collection of muons with a certain pseudorapidity,; 1369momentum and charge, e.g.:; 1370~~~{.cpp}; 1371std::vector<short> mu_charge {1, 1, -1, -1, -1, 1, 1, -1};; 1372std::vector<float> mu_pt {56, 45, 32, 24, 12, 8, 7, 6.2};; 1373std::vector<float> mu_eta {3.1, -.2, -1.1, 1, 4.1, 1.6, 2.4, -.5};; 1374~~~; 1375Suppose you want to extract the transverse momenta of the muons satisfying certain; 1376criteria, for example consider only negatively charged muons with a pseudorapidity; 1377smaller or equal to 2 and with a transverse momentum greater than 10 GeV.; 1378Such a selection would require, among the other things, the management of an explicit; 1379loop, for example:; 1380~~~{.cpp}; 1381std::vector<float> goodMuons_pt;; 1382const auto size = mu_charge.size();; 1383for (size_t i=0; i < size; ++i) {; 1384 if (mu_pt[i] > 10 && abs(mu_eta[i]) <= 2. && mu_charge[i] == -1) {; 1385 goodMuons_pt.emplace_back(mu_pt[i]);; 1386 }; 1387}; 1388~~~; 1389These operations become straightforward with RVec - we just need to *write what; 1390we mean*:; 1391~~~{.cpp}; 1392auto goodMuons_pt = mu_pt[ (mu_pt > 10.f && abs(mu_eta) <= 2.f && mu_charge == -1) ]; 1393~~~; 1394Now the clean collection of transverse momenta can be used within the rest of the data analysis, for; 1395example to fill a histogram.; 1396 ; 1397\anchor operationsandfunctions; 1398## Arithmetic operations, logical operations and mathematical functions; 139",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RVec_8hxx_source.html:48212,charge,charged,48212,doc/master/RVec_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html,2,['charge'],['charged']
Energy Efficiency,"6 * <table>; 907 * <tr><th> Mode <th> Description; 908 * <tr><td> **none** - *default* <td> No offsetting.; 909 * <tr><td> **initial** <td> Offset likelihood by initial value (so that starting value of FCN in minuit is zero).; 910 * This can improve numeric stability in simultaneous fits with components with large likelihood values.; 911 * <tr><td> **bin** <td> Offset likelihood bin-by-bin with a template histogram model based on the obersved data.; 912 * This results in per-bin values that are all in the same order of magnitude, which reduces precision loss in the sum,; 913 * which can drastically improve numeric stability.; 914 * Furthermore, \f$2\cdot \text{NLL}\f$ defined like this is approximately chi-square distributed, allowing for goodness-of-fit tests.; 915 * </table>; 916 * <tr><td> `IntegrateBins(double precision)` <td> In binned fits, integrate the PDF over the bins instead of using the probability density at the bin centre.; 917 * This can reduce the bias observed when fitting functions with high curvature to binned data.; 918 * - precision > 0: Activate bin integration everywhere. Use precision between 0.01 and 1.E-6, depending on binning.; 919 * Note that a low precision such as 0.01 might yield identical results to 1.E-4, since the integrator might reach 1.E-4 already in its first; 920 * integration step. If lower precision is desired (more speed), a RooBinSamplingPdf has to be created manually, and its integrator; 921 * has to be manipulated directly.; 922 * - precision = 0: Activate bin integration only for continuous PDFs fit to a RooDataHist.; 923 * - precision < 0: Deactivate.; 924 * \see RooBinSamplingPdf; 925 * <tr><td> `ModularL(bool flag)` <td> Enable or disable modular likelihoods, which will become the default in a future release.; 926 * This does not change any user-facing code, but only enables a different likelihood class in the back-end. Note that this; 927 * should be set to true for parallel minimization of likelihoods!; 928 * Note t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html:41728,reduce,reduce,41728,doc/master/RooAbsPdf_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html,1,['reduce'],['reduce']
Energy Efficiency,"6 of file RooCrystalBall.h. ◆ RooCrystalBall() [2/5]. RooCrystalBall::RooCrystalBall ; (; const char * ; name, . const char * ; title, . RooAbsReal & ; x, . RooAbsReal & ; x0, . RooAbsReal & ; sigmaL, . RooAbsReal & ; sigmaR, . RooAbsReal & ; alphaL, . RooAbsReal & ; nL, . RooAbsReal & ; alphaR, . RooAbsReal & ; nR . ). Creates the fully parametrized crystal ball shape with asymmetric Gaussian core and asymmetric tails. ; Parameters. nameName that identifies the PDF in computations. ; titleTitle for plotting. ; xThe variable of the PDF. ; x0Location parameter of the Gaussian component. ; sigmaLWidth parameter of the left side of the Gaussian component. ; sigmaRWidth parameter of the right side of the Gaussian component. ; alphaLLocation of transition to a power law on the left, in standard deviations away from the mean. ; nLExponent of power-law tail on the left. ; alphaRLocation of transition to a power law on the right, in standard deviations away from the mean. ; nRExponent of power-law tail on the right. . Definition at line 73 of file RooCrystalBall.cxx. ◆ RooCrystalBall() [3/5]. RooCrystalBall::RooCrystalBall ; (; const char * ; name, . const char * ; title, . RooAbsReal & ; x, . RooAbsReal & ; x0, . RooAbsReal & ; sigmaLR, . RooAbsReal & ; alphaL, . RooAbsReal & ; nL, . RooAbsReal & ; alphaR, . RooAbsReal & ; nR . ). Create a crystal ball shape with symmetric Gaussian core and asymmetric tails (just like RooDSCBShape). ; Parameters. nameName that identifies the PDF in computations. ; titleTitle for plotting. ; xThe variable of the PDF. ; x0Location parameter of the Gaussian component. ; sigmaLRWidth parameter of the Gaussian component. ; alphaLLocation of transition to a power law on the left, in standard deviations away from the mean. ; nLExponent of power-law tail on the left. ; alphaRLocation of transition to a power law on the right, in standard deviations away from the mean. ; nRExponent of power-law tail on the right. . Definition at line 102 of file Roo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCrystalBall.html:76311,power,power-law,76311,doc/master/classRooCrystalBall.html,https://root.cern,https://root.cern/doc/master/classRooCrystalBall.html,1,['power'],['power-law']
Energy Efficiency,"6.43e-20 6.43E-20 6,43e-20. TString Itoa(Int_t value, Int_t base); Converts an Int_t to a TString with respect to the base specified (2-36).; Thus it is an enhanced version of sprintf (adapted from versions 0.4 of; http://www.jb.man.ac.uk/~slowe/cpp/itoa.html).; Usage: the following statement produce the same output, namely ""1111""; std::cout << TString::Itoa(15,2) ;; std::cout << TString::Itoa(0xF,2) ; /// 0x prefix to handle hex; std::cout << TString::Itoa(017,2) ; /// 0 prefix to handle oct; In case of error returns the ""!"" string. TString UItoa(UInt_t value, Int_t base); Converts a UInt_t (twice the range of an Int_t) to a TString with respect; to the base specified (2-36). Thus it is an enhanced version of sprintf; (adapted from versions 0.4 of http://www.jb.man.ac.uk/~slowe/cpp/itoa.html).; In case of error returns the ""!"" string. TString LLtoa(Long64_t value, Int_t base); Converts a Long64_t to a TString with respect to the base specified (2-36).; Thus it is an enhanced version of sprintf (adapted from versions 0.4 of; http://www.jb.man.ac.uk/~slowe/cpp/itoa.html).; In case of error returns the ""!"" string. TString ULLtoa(ULong64_t value, Int_t base); Converts a ULong64_t (twice the range of an Long64_t) to a TString with; respect to the base specified (2-36). Thus it is an enhanced version of; sprintf (adapted from versions 0.4 of http://www.jb.man.ac.uk/~slowe/cpp/itoa.html).; In case of error returns the ""!"" string. TString BaseConvert(const TString& s_in, Int_t base_in, Int_t base_out); Converts string from base base_in to base base_out. Supported bases; are 2-36. At most 64 bit data can be converted. Bool_t EndsWith(const char* pat, TString::ECaseCompare cmp = kExact) const; Return true if string ends with the specified string. TObjArray * Tokenize(const TString& delim) const; This function is used to isolate sequential tokens in a TString.; These tokens are separated in the string by at least one of the; characters in delim. The returned array contains the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TString.html:19175,adapt,adapted,19175,root/html602/TString.html,https://root.cern,https://root.cern/root/html602/TString.html,2,['adapt'],['adapted']
Energy Efficiency,"60; ROOT::Math::LorentzVector::isSpacelikebool isSpacelike() constDetermine if momentum-energy is spacelike, and represents a tachyon.Definition LorentzVector.h:545; ROOT::Math::LorentzVector::zScalar z() constDefinition LorentzVector.h:644; ROOT::Math::LorentzVector::RScalar R() constreturn the spatial (3D) magnitude ( sqrt(X**2 + Y**2 + Z**2) )Definition LorentzVector.h:310; ROOT::Math::LorentzVector::ScalarCoordSystem::Scalar ScalarDefinition LorentzVector.h:65; ROOT::Math::LorentzVector::P2Scalar P2() constreturn the square of the spatial (3D) magnitude ( X**2 + Y**2 + Z**2 )Definition LorentzVector.h:315; ROOT::Math::LorentzVector::Et2Scalar Et2() constreturn the transverse energy squaredDefinition LorentzVector.h:343; ROOT::Math::LorentzVector::mag2Scalar mag2() constDefinition LorentzVector.h:657; ROOT::Math::LorentzVector::LorentzVectorLorentzVector()default constructor of an empty vector (Px = Py = Pz = E = 0 )Definition LorentzVector.h:71; ROOT::Math::LorentzVector::energyScalar energy() constDefinition LorentzVector.h:664; ROOT::Math::LorentzVector::mtScalar mt() constDefinition LorentzVector.h:659; ROOT::Math::LorentzVector::isTimelikebool isTimelike() constDetermine if momentum-energy can represent a physical massive particle.Definition LorentzVector.h:528; ROOT::Math::LorentzVector::operator-=LorentzVector & operator-=(const OtherLorentzVector &q)Self subtraction of another Vector from this ( v-= q ) Enable the addition with any other LorentzVect...Definition LorentzVector.h:411; ROOT::Math::LorentzVector::PxScalar Px() constspatial X componentDefinition LorentzVector.h:279; ROOT::Math::LorentzVector::etaScalar eta() constDefinition LorentzVector.h:654; ROOT::Math::LorentzVector::MtScalar Mt() constreturn the transverse massDefinition LorentzVector.h:337; ROOT::Math::LorentzVector::xScalar x() constDefinition LorentzVector.h:642; ROOT::Math::LorentzVector::mass2Scalar mass2() constDefinition LorentzVector.h:666; ROOT::Math::LorentzVector::Dimensionunsig",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/GenVector_2LorentzVector_8h_source.html:35740,energy,energyScalar,35740,doc/master/GenVector_2LorentzVector_8h_source.html,https://root.cern,https://root.cern/doc/master/GenVector_2LorentzVector_8h_source.html,2,['energy'],"['energy', 'energyScalar']"
Energy Efficiency,"659 /// \brief Execute a user-defined reduce operation on the values of a column.; 1660 /// \tparam F The type of the reduce callable. Automatically deduced.; 1661 /// \tparam T The type of the column to apply the reduction to. Automatically deduced.; 1662 /// \param[in] f A callable with signature `T(T,T)`; 1663 /// \param[in] columnName The column to be reduced. If omitted, the first default column is used instead.; 1664 /// \return the reduced quantity wrapped in a ROOT::RDF:RResultPtr.; 1665 ///; 1666 /// A reduction takes two values of a column and merges them into one (e.g.; 1667 /// by summing them, taking the maximum, etc). This action performs the; 1668 /// specified reduction operation on all processed column values, returning; 1669 /// a single value of the same type. The callable f must satisfy the general; 1670 /// requirements of a *processing function* besides having signature `T(T,T)`; 1671 /// where `T` is the type of column columnName.; 1672 ///; 1673 /// The returned reduced value of each thread (e.g. the initial value of a sum) is initialized to a; 1674 /// default-constructed T object. This is commonly expected to be the neutral/identity element for the specific; 1675 /// reduction operation `f` (e.g. 0 for a sum, 1 for a product). If a default-constructed T does not satisfy this; 1676 /// requirement, users should explicitly specify an initialization value for T by calling the appropriate `Reduce`; 1677 /// overload.; 1678 ///; 1679 /// ### Example usage:; 1680 /// ~~~{.cpp}; 1681 /// auto sumOfIntCol = d.Reduce([](int x, int y) { return x + y; }, ""intCol"");; 1682 /// ~~~; 1683 ///; 1684 /// This action is *lazy*: upon invocation of this method the calculation is; 1685 /// booked but not executed. Also see RResultPtr.; 1686 // clang-format on; 1687 template <typename F, typename T = typename TTraits::CallableTraits<F>::ret_type>; 1688 RResultPtr<T> Reduce(F f, std::string_view columnName = """"); 1689 {; 1690 static_assert(; 1691 std::is_default_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RInterface_8hxx_source.html:93716,reduce,reduced,93716,doc/master/RInterface_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RInterface_8hxx_source.html,1,['reduce'],['reduced']
Energy Efficiency,"65:; 3126 {; 3127 Double_t red[9] = { 93./255., 91./255., 99./255., 108./255., 130./255., 125./255., 132./255., 155./255., 174./255.};; 3128 Double_t green[9] = { 126./255., 124./255., 128./255., 129./255., 131./255., 121./255., 119./255., 153./255., 173./255.};; 3129 Double_t blue[9] = { 103./255., 94./255., 87./255., 85./255., 80./255., 85./255., 107./255., 120./255., 146./255.};; 3130 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3131 }; 3132 break;; 3133 ; 3134 // Atlantic; 3135 case 66:; 3136 {; 3137 Double_t red[9] = { 24./255., 40./255., 69./255., 90./255., 104./255., 114./255., 120./255., 132./255., 103./255.};; 3138 Double_t green[9] = { 29./255., 52./255., 94./255., 127./255., 150./255., 162./255., 159./255., 151./255., 101./255.};; 3139 Double_t blue[9] = { 29./255., 52./255., 96./255., 132./255., 162./255., 181./255., 184./255., 186./255., 131./255.};; 3140 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3141 }; 3142 break;; 3143 ; 3144 // Aurora; 3145 case 67:; 3146 {; 3147 Double_t red[9] = { 46./255., 38./255., 61./255., 92./255., 113./255., 121./255., 132./255., 150./255., 191./255.};; 3148 Double_t green[9] = { 46./255., 36./255., 40./255., 69./255., 110./255., 135./255., 131./255., 92./255., 34./255.};; 3149 Double_t blue[9] = { 46./255., 80./255., 74./255., 70./255., 81./255., 105./255., 165./255., 211./255., 225./255.};; 3150 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3151 }; 3152 break;; 3153 ; 3154 // Avocado; 3155 case 68:; 3156 {; 3157 Double_t red[9] = { 0./255., 4./255., 12./255., 30./255., 52./255., 101./255., 142./255., 190./255., 237./255.};; 3158 Double_t green[9] = { 0./255., 40./255., 86./255., 121./255., 140./255., 172./255., 187./255., 213./255., 240./255.};; 3159 Double_t blue[9] = { 0./255., 9./255., 14./255., 18./255., 21./255., 23./255., 27./255., 35./255., 101./255.};; 3160 Idx = TColor::CreateGradientColorTable(9, stops, re",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TColor_8cxx_source.html:119748,green,green,119748,doc/master/TColor_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html,1,['green'],['green']
Energy Efficiency,"66 paletteType = ncolors;; 2967 ; 2968 // restore the palette transparency if needed; 2969 if (alphas>0 && !same_alpha) {; 2970 TColor *ca;; 2971 for (i=0;i<255;i++) {; 2972 ca = gROOT->GetColor(Idx+i);; 2973 ca->SetAlpha(alpha);; 2974 }; 2975 fgPalettesList.fArray[paletteType-51] = (Double_t)Idx+alpha/10.;; 2976 }; 2977 return;; 2978 }; 2979 ; 2980 TColor::InitializeColors();; 2981 Double_t stops[9] = { 0.0000, 0.1250, 0.2500, 0.3750, 0.5000, 0.6250, 0.7500, 0.8750, 1.0000};; 2982 ; 2983 switch (ncolors) {; 2984 // Deep Sea; 2985 case 51:; 2986 {; 2987 Double_t red[9] = { 0./255., 9./255., 13./255., 17./255., 24./255., 32./255., 27./255., 25./255., 29./255.};; 2988 Double_t green[9] = { 0./255., 0./255., 0./255., 2./255., 37./255., 74./255., 113./255., 160./255., 221./255.};; 2989 Double_t blue[9] = { 28./255., 42./255., 59./255., 78./255., 98./255., 129./255., 154./255., 184./255., 221./255.};; 2990 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 2991 }; 2992 break;; 2993 ; 2994 // Grey Scale; 2995 case 52:; 2996 {; 2997 Double_t red[9] = { 0./255., 32./255., 64./255., 96./255., 128./255., 160./255., 192./255., 224./255., 255./255.};; 2998 Double_t green[9] = { 0./255., 32./255., 64./255., 96./255., 128./255., 160./255., 192./255., 224./255., 255./255.};; 2999 Double_t blue[9] = { 0./255., 32./255., 64./255., 96./255., 128./255., 160./255., 192./255., 224./255., 255./255.};; 3000 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3001 }; 3002 break;; 3003 ; 3004 // Dark Body Radiator; 3005 case 53:; 3006 {; 3007 Double_t red[9] = { 0./255., 45./255., 99./255., 156./255., 212./255., 230./255., 237./255., 234./255., 242./255.};; 3008 Double_t green[9] = { 0./255., 0./255., 0./255., 45./255., 101./255., 168./255., 238./255., 238./255., 243./255.};; 3009 Double_t blue[9] = { 0./255., 1./255., 1./255., 3./255., 9./255., 8./255., 11./255., 95./255., 230./255.};; 3010 Idx = TColor::CreateGradientColorTable(9,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TColor_8cxx_source.html:112006,green,green,112006,doc/master/TColor_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html,1,['green'],['green']
Energy Efficiency,"6636; TH1::fDirectoryTDirectory * fDirectory! Pointer to directory holding this histogramDefinition TH1.h:109; TH1::GetOptionOption_t * GetOption() const overrideDefinition TH1.h:303; TH1::Resetvirtual void Reset(Option_t *option="""")Reset this histogram: contents, errors, etc.Definition TH1.cxx:7103; TH1::SetNameTitlevoid SetNameTitle(const char *name, const char *title) overrideChange the name and title of this histogram.Definition TH1.cxx:8974; TH1::GetXaxisTAxis * GetXaxis()Definition TH1.h:324; TH1::GetBinXYZvirtual void GetBinXYZ(Int_t binglobal, Int_t &binx, Int_t &biny, Int_t &binz) constReturn binx, biny, binz corresponding to the global bin number globalbin see TH1::GetBin function abo...Definition TH1.cxx:4974; TH1::GetCumulativeTH1 * GetCumulative(Bool_t forward=kTRUE, const char *suffix=""_cumulative"") constReturn a pointer to a histogram containing the cumulative content.Definition TH1.cxx:2616; TH1::AutoP2GetPower2static Double_t AutoP2GetPower2(Double_t x, Bool_t next=kTRUE)Auxiliary function to get the power of 2 next (larger) or previous (smaller) a given x.Definition TH1.cxx:1308; TH1::GetNcellsvirtual Int_t GetNcells() constDefinition TH1.h:300; TH1::ShowPeaksvirtual Int_t ShowPeaks(Double_t sigma=2, Option_t *option="""", Double_t threshold=0.05)Interface to TSpectrum::Search.Definition TH1.cxx:9301; TH1::GetBufferLengthInt_t GetBufferLength() constDefinition TH1.h:237; TH1::RecomputeAxisLimitsstatic Bool_t RecomputeAxisLimits(TAxis &destAxis, const TAxis &anAxis)Finds new limits for the axis for the Merge function.Definition TH1.cxx:5908; TH1::GetTitleFontvirtual Style_t GetTitleFont(Option_t *axis=""X"") constReturn the ""axis"" title font.Definition Haxis.cxx:118; TH1::SetNdivisionsvirtual void SetNdivisions(Int_t n=510, Option_t *axis=""X"")Set the number of divisions to draw an axis.Definition Haxis.cxx:170; TH1::GetLabelFontvirtual Style_t GetLabelFont(Option_t *axis=""X"") constReturn the ""axis"" label font.Definition Haxis.cxx:66; TH1::GetTickLengthvi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8h_source.html:62117,power,power,62117,doc/master/TH1_8h_source.html,https://root.cern,https://root.cern/doc/master/TH1_8h_source.html,1,['power'],['power']
Energy Efficiency,"6; THnSparse::fBinsTExMap fBins! Filled binsDefinition THnSparse.h:42; THnSparse::fBinsContinuedTExMap fBinsContinued! Filled bins for non-unique hashes, containing pairs of (bin index 0, bin index 1)Definition THnSparse.h:43; THnSparse::AddBinContentvoid AddBinContent(const Int_t *idx, Double_t v=1.)Forwards to THnBase::AddBinContent().Definition THnSparse.h:113; THnSparse::Reservevoid Reserve(Long64_t nbins) overrideInitialize storage for nbins.Definition THnSparse.cxx:689; THnSparse::fChunkSizeInt_t fChunkSizeNumber of entries for each chunk.Definition THnSparse.h:39; THnSparse::Sumw2void Sumw2() overrideEnable calculation of errors.Definition THnSparse.cxx:948; THnSparse::GetNbinsLong64_t GetNbins() const overrideDefinition THnSparse.h:93; THnSparse::CreateIterROOT::Internal::THnBaseBinIter * CreateIter(Bool_t respectAxisRange) const overrideCreate an iterator over all filled bins of a THnSparse.Definition THnSparse.cxx:896; THnSparse::GetBinIndexForCurrentBinLong64_t GetBinIndexForCurrentBin(Bool_t allocate)Return the index for fCurrentBinIndex.Definition THnSparse.cxx:789; TIterDefinition TCollection.h:235; TObjArray::GetEntriesFastInt_t GetEntriesFast() constDefinition TObjArray.h:58; TObjArray::LastTObject * Last() const overrideReturn the object in the last filled slot. Returns 0 if no entries.Definition TObjArray.cxx:506; TObjArray::GetEntriesInt_t GetEntries() const overrideReturn the number of objects in array (i.e.Definition TObjArray.cxx:523; TObjArray::Deletevoid Delete(Option_t *option="""") overrideRemove all objects from the array AND delete all heap based objects.Definition TObjArray.cxx:356; TObjArray::AddLastvoid AddLast(TObject *obj) overrideAdd object in the next empty slot in the array.Definition TObjArray.cxx:178; TObject::Clearvirtual void Clear(Option_t *="""")Definition TObject.h:119; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::Errorvirtual vo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THnSparse_8cxx_source.html:49853,allocate,allocate,49853,doc/master/THnSparse_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html,1,['allocate'],['allocate']
Energy Efficiency,"6{; 1837 SetPointEX(i, exL, exH);; 1838 SetPointEY(i, ne, eyL, eyH);; 1839}; 1840 ; 1841////////////////////////////////////////////////////////////////////////////////; 1842/// Set ex values for point `i`.; 1843 ; 1844void TGraphMultiErrors::SetPointEX(Int_t i, Double_t exL, Double_t exH); 1845{; 1846 SetPointEXlow(i, exL);; 1847 SetPointEXhigh(i, exH);; 1848}; 1849 ; 1850////////////////////////////////////////////////////////////////////////////////; 1851/// Set exL value for point `i`.; 1852 ; 1853void TGraphMultiErrors::SetPointEXlow(Int_t i, Double_t exL); 1854{; 1855 if (i < 0); 1856 return;; 1857 ; 1858 if (i >= fNpoints) {; 1859 // re-allocate the object; 1860 TGraphMultiErrors::SetPoint(i, 0., 0.);; 1861 }; 1862 ; 1863 fExL[i] = exL;; 1864}; 1865 ; 1866////////////////////////////////////////////////////////////////////////////////; 1867/// Set exH value for point `i`.; 1868 ; 1869void TGraphMultiErrors::SetPointEXhigh(Int_t i, Double_t exH); 1870{; 1871 if (i < 0); 1872 return;; 1873 ; 1874 if (i >= fNpoints) {; 1875 // re-allocate the object; 1876 TGraphMultiErrors::SetPoint(i, 0., 0.);; 1877 }; 1878 ; 1879 fExH[i] = exH;; 1880}; 1881 ; 1882////////////////////////////////////////////////////////////////////////////////; 1883/// Set ey values for point `i`.; 1884 ; 1885void TGraphMultiErrors::SetPointEY(Int_t i, Int_t ne, const Double_t *eyL, const Double_t *eyH); 1886{; 1887 SetPointEYlow(i, ne, eyL);; 1888 SetPointEYhigh(i, ne, eyH);; 1889}; 1890 ; 1891////////////////////////////////////////////////////////////////////////////////; 1892/// Set eyL values for point `i`.; 1893 ; 1894void TGraphMultiErrors::SetPointEYlow(Int_t i, Int_t ne, const Double_t *eyL); 1895{; 1896 for (Int_t j = 0; j < fNYErrors; j++) {; 1897 if (j < ne); 1898 SetPointEYlow(i, j, eyL[j]);; 1899 else; 1900 SetPointEYlow(i, j, 0.);; 1901 }; 1902}; 1903 ; 1904////////////////////////////////////////////////////////////////////////////////; 1905/// Set eyH values for point `i`.; 190",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:63608,allocate,allocate,63608,doc/master/TGraphMultiErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html,1,['allocate'],['allocate']
Energy Efficiency,"7 """"""; 58using ROOT::RVecF;; 59using ROOT::RVecI;; 60bool GoodElectronsAndMuons(const RVecI &type, const RVecF &pt, const RVecF &eta, const RVecF &phi, const RVecF &e, const RVecF &trackd0pv, const RVecF &tracksigd0pv, const RVecF &z0); 61{; 62 for (size_t i = 0; i < type.size(); i++) {; 63 ROOT::Math::PtEtaPhiEVector p(0.001*pt[i], eta[i], phi[i], 0.001*e[i]);; 64 if (type[i] == 11) {; 65 if (pt[i] < 7000 || abs(eta[i]) > 2.47 || abs(trackd0pv[i] / tracksigd0pv[i]) > 5 || abs(z0[i] * sin(p.Theta())) > 0.5) return false;; 66 } else {; 67 if (abs(trackd0pv[i] / tracksigd0pv[i]) > 5 || abs(z0[i] * sin(p.Theta())) > 0.5) return false;; 68 }; 69 }; 70 return true;; 71}; 72""""""; 73); 74 ; 75# Select electron or muon trigger; 76df = df.Filter(""trigE || trigM""); 77 ; 78# Select events with exactly four good leptons conserving charge and lepton numbers; 79# Note that all collections are RVecs and good_lep is the mask for the good leptons.; 80# The lepton types are PDG numbers and set to 11 or 13 for an electron or muon; 81# irrespective of the charge.; 82 ; 83df = (; 84 df.Define(; 85 ""good_lep"",; 86 ""abs(lep_eta) < 2.5 && lep_pt > 5000 && lep_ptcone30 / lep_pt < 0.3 && lep_etcone20 / lep_pt < 0.3"",; 87 ); 88 .Filter(""Sum(good_lep) == 4""); 89 .Filter(""Sum(lep_charge[good_lep]) == 0""); 90 .Define(""goodlep_sumtypes"", ""Sum(lep_type[good_lep])""); 91 .Filter(""goodlep_sumtypes == 44 || goodlep_sumtypes == 52 || goodlep_sumtypes == 48""); 92); 93 ; 94# Apply additional cuts depending on lepton flavour; 95df = df.Filter(; 96 ""GoodElectronsAndMuons(lep_type[good_lep], lep_pt[good_lep], lep_eta[good_lep], lep_phi[good_lep], lep_E[good_lep], lep_trackd0pvunbiased[good_lep], lep_tracksigd0pvunbiased[good_lep], lep_z0[good_lep])""; 97); 98 ; 99# Create new columns with the kinematics of good leptons; 100df = (; 101 df.Define(""goodlep_pt"", ""lep_pt[good_lep]""); 102 .Define(""goodlep_eta"", ""lep_eta[good_lep]""); 103 .Define(""goodlep_phi"", ""lep_phi[good_lep]""); 104 .Define(""goodlep_E"", ""lep_E[goo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/df106__HiggsToFourLeptons_8py_source.html:4045,charge,charge,4045,doc/master/df106__HiggsToFourLeptons_8py_source.html,https://root.cern,https://root.cern/doc/master/df106__HiggsToFourLeptons_8py_source.html,1,['charge'],['charge']
Energy Efficiency,"7 // Append the negative sign; 2108 if (value < 0) buf += '-';; 2109 std::reverse(buf.begin(), buf.end());; 2110 return (TString(buf.data()));; 2111}; 2112 ; 2113////////////////////////////////////////////////////////////////////////////////; 2114/// Converts a UInt_t (twice the range of an Int_t) to a TString with respect; 2115/// to the base specified (2-36). Thus it is an enhanced version of sprintf; 2116/// (adapted from versions 0.4 of http://www.jb.man.ac.uk/~slowe/cpp/itoa.html).; 2117/// In case of error returns the ""!"" string.; 2118 ; 2119TString TString::UItoa(UInt_t value, Int_t base); 2120{; 2121 std::string buf;; 2122 // check that the base if valid; 2123 if (base < 2 || base > 36) {; 2124 Error(""TString::UItoa"", ""base %d is not supported. Supported bases are {2,3,...,36}."",base);; 2125 return (TString(""!""));; 2126 }; 2127 buf.reserve(35); // Pre-allocate enough space (35=kMaxDigits); 2128 UInt_t quotient = value;; 2129 // Translating number to string with base:; 2130 do {; 2131 buf += ""0123456789abcdefghijklmnopqrstuvwxyz""[ quotient % base ];; 2132 quotient /= base;; 2133 } while (quotient);; 2134 std::reverse(buf.begin(), buf.end());; 2135 return (TString(buf.data()));; 2136}; 2137 ; 2138////////////////////////////////////////////////////////////////////////////////; 2139/// Converts a Long64_t to a TString with respect to the base specified (2-36).; 2140/// Thus it is an enhanced version of sprintf (adapted from versions 0.4 of; 2141/// http://www.jb.man.ac.uk/~slowe/cpp/itoa.html).; 2142/// In case of error returns the ""!"" string.; 2143 ; 2144TString TString::LLtoa(Long64_t value, Int_t base); 2145{; 2146 std::string buf;; 2147 // check that the base if valid; 2148 if (base < 2 || base > 36) {; 2149 Error(""TString::LLtoa"", ""base %d is not supported. Supported bases are {2,3,...,36}."",base);; 2150 return (TString(""!""));; 2151 }; 2152 buf.reserve(35); // Pre-allocate enough space (35=kMaxDigits); 2153 Long64_t quotient = value;; 2154 // Translating ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TString_8cxx_source.html:66975,allocate,allocate,66975,doc/master/TString_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TString_8cxx_source.html,1,['allocate'],['allocate']
Energy Efficiency,"7 Double_t red[9] = { 0./255., 32./255., 64./255., 96./255., 128./255., 160./255., 192./255., 224./255., 255./255.};; 2998 Double_t green[9] = { 0./255., 32./255., 64./255., 96./255., 128./255., 160./255., 192./255., 224./255., 255./255.};; 2999 Double_t blue[9] = { 0./255., 32./255., 64./255., 96./255., 128./255., 160./255., 192./255., 224./255., 255./255.};; 3000 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3001 }; 3002 break;; 3003 ; 3004 // Dark Body Radiator; 3005 case 53:; 3006 {; 3007 Double_t red[9] = { 0./255., 45./255., 99./255., 156./255., 212./255., 230./255., 237./255., 234./255., 242./255.};; 3008 Double_t green[9] = { 0./255., 0./255., 0./255., 45./255., 101./255., 168./255., 238./255., 238./255., 243./255.};; 3009 Double_t blue[9] = { 0./255., 1./255., 1./255., 3./255., 9./255., 8./255., 11./255., 95./255., 230./255.};; 3010 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3011 }; 3012 break;; 3013 ; 3014 // Two-color hue (dark blue through neutral gray to bright yellow); 3015 case 54:; 3016 {; 3017 Double_t red[9] = { 0./255., 22./255., 44./255., 68./255., 93./255., 124./255., 160./255., 192./255., 237./255.};; 3018 Double_t green[9] = { 0./255., 16./255., 41./255., 67./255., 93./255., 125./255., 162./255., 194./255., 241./255.};; 3019 Double_t blue[9] = { 97./255., 100./255., 99./255., 99./255., 93./255., 68./255., 44./255., 26./255., 74./255.};; 3020 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3021 }; 3022 break;; 3023 ; 3024 // Rain Bow; 3025 case 55:; 3026 {; 3027 Double_t red[9] = { 0./255., 5./255., 15./255., 35./255., 102./255., 196./255., 208./255., 199./255., 110./255.};; 3028 Double_t green[9] = { 0./255., 48./255., 124./255., 192./255., 206./255., 226./255., 97./255., 16./255., 0./255.};; 3029 Double_t blue[9] = { 99./255., 142./255., 198./255., 201./255., 90./255., 22./255., 13./255., 8./255., 2./255.};; 3030 Idx = TColor::CreateGradie",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TColor_8cxx_source.html:113050,green,green,113050,doc/master/TColor_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html,1,['green'],['green']
Energy Efficiency,"7 Double_t red[9] = { 31./255., 71./255., 123./255., 160./255., 210./255., 222./255., 214./255., 199./255., 183./255.};; 3348 Double_t green[9] = { 40./255., 117./255., 171./255., 211./255., 231./255., 220./255., 190./255., 132./255., 65./255.};; 3349 Double_t blue[9] = { 234./255., 214./255., 228./255., 222./255., 210./255., 160./255., 105./255., 60./255., 34./255.};; 3350 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3351 }; 3352 break;; 3353 ; 3354 // Light Terrain; 3355 case 88:; 3356 {; 3357 Double_t red[9] = { 123./255., 108./255., 109./255., 126./255., 154./255., 172./255., 188./255., 196./255., 218./255.};; 3358 Double_t green[9] = { 184./255., 138./255., 130./255., 133./255., 154./255., 175./255., 188./255., 196./255., 218./255.};; 3359 Double_t blue[9] = { 208./255., 130./255., 109./255., 99./255., 110./255., 122./255., 150./255., 171./255., 218./255.};; 3360 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3361 }; 3362 break;; 3363 ; 3364 // Mint; 3365 case 89:; 3366 {; 3367 Double_t red[9] = { 105./255., 106./255., 122./255., 143./255., 159./255., 172./255., 176./255., 181./255., 207./255.};; 3368 Double_t green[9] = { 252./255., 197./255., 194./255., 187./255., 174./255., 162./255., 153./255., 136./255., 125./255.};; 3369 Double_t blue[9] = { 146./255., 133./255., 144./255., 155./255., 163./255., 167./255., 166./255., 162./255., 174./255.};; 3370 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3371 }; 3372 break;; 3373 ; 3374 // Neon; 3375 case 90:; 3376 {; 3377 Double_t red[9] = { 171./255., 141./255., 145./255., 152./255., 154./255., 159./255., 163./255., 158./255., 177./255.};; 3378 Double_t green[9] = { 236./255., 143./255., 100./255., 63./255., 53./255., 55./255., 44./255., 31./255., 6./255.};; 3379 Double_t blue[9] = { 59./255., 48./255., 46./255., 44./255., 42./255., 54./255., 82./255., 112./255., 179./255.};; 3380 Idx = TColor::CreateGradientColor",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TColor_8cxx_source.html:131313,green,green,131313,doc/master/TColor_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html,1,['green'],['green']
Energy Efficiency,"7 of file TSpectrum2Fit.cxx. ◆ SetBackgroundParameters(). void TSpectrum2Fit::SetBackgroundParameters ; (; Double_t ; a0Init, . Bool_t ; fixA0, . Double_t ; axInit, . Bool_t ; fixAx, . Double_t ; ayInit, . Bool_t ; fixAy . ). This function sets the following fitting parameters of background: . a0Init - initial value of a0 parameter (background is estimated as a0+ax*x+ay*y); fixA0 - logical value of a0 parameter, which allows to fix the parameter (not to fit); axInit - initial value of ax parameter; fixAx - logical value of ax parameter, which allows to fix the parameter (not to fit); ayInit - initial value of ay parameter; fixAy - logical value of ay parameter, which allows to fix the parameter (not to fit) . Definition at line 5652 of file TSpectrum2Fit.cxx. ◆ SetFitParameters(). void TSpectrum2Fit::SetFitParameters ; (; Int_t ; xmin, . Int_t ; xmax, . Int_t ; ymin, . Int_t ; ymax, . Int_t ; numberIterations, . Double_t ; alpha, . Int_t ; statisticType, . Int_t ; alphaOptim, . Int_t ; power, . Int_t ; fitTaylor . ). This function sets the following fitting parameters: . xmin, xmax, ymin, ymax - fitting region; numberIterations - # of desired iterations in the fit; alpha - convergence coefficient, it should be positive number and <=1, for details see references; statisticType - type of statistics, possible values kFitOptimChiCounts (chi square statistics with counts as weighting coefficients), kFitOptimChiFuncValues (chi square statistics with function values as weighting coefficients),kFitOptimMaxLikelihood; alphaOptim - optimization of convergence algorithm, possible values kFitAlphaHalving, kFitAlphaOptimal; power - possible values kFitPower2,4,6,8,10,12, for details see references. It applies only for Awmi fitting function.; fitTaylor - order of Taylor expansion, possible values kFitTaylorOrderFirst, kFitTaylorOrderSecond. It applies only for Awmi fitting function. . Definition at line 5525 of file TSpectrum2Fit.cxx. ◆ SetPeakParameters(). void TSpectrum2Fit::Set",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSpectrum2Fit.html:70777,power,power,70777,doc/master/classTSpectrum2Fit.html,https://root.cern,https://root.cern/doc/master/classTSpectrum2Fit.html,1,['power'],['power']
Energy Efficiency,"73:; 3206 {; 3207 Double_t red[9] = { 61./255., 99./255., 136./255., 181./255., 213./255., 225./255., 198./255., 136./255., 24./255.};; 3208 Double_t green[9] = { 149./255., 140./255., 96./255., 83./255., 132./255., 178./255., 190./255., 135./255., 22./255.};; 3209 Double_t blue[9] = { 214./255., 203./255., 168./255., 135./255., 110./255., 100./255., 111./255., 113./255., 22./255.};; 3210 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3211 }; 3212 break;; 3213 ; 3214 // Candy; 3215 case 74:; 3216 {; 3217 Double_t red[9] = { 76./255., 120./255., 156./255., 183./255., 197./255., 180./255., 162./255., 154./255., 140./255.};; 3218 Double_t green[9] = { 34./255., 35./255., 42./255., 69./255., 102./255., 137./255., 164./255., 188./255., 197./255.};; 3219 Double_t blue[9] = { 64./255., 69./255., 78./255., 105./255., 142./255., 177./255., 205./255., 217./255., 198./255.};; 3220 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3221 }; 3222 break;; 3223 ; 3224 // Cherry; 3225 case 75:; 3226 {; 3227 Double_t red[9] = { 37./255., 102./255., 157./255., 188./255., 196./255., 214./255., 223./255., 235./255., 251./255.};; 3228 Double_t green[9] = { 37./255., 29./255., 25./255., 37./255., 67./255., 91./255., 132./255., 185./255., 251./255.};; 3229 Double_t blue[9] = { 37./255., 32./255., 33./255., 45./255., 66./255., 98./255., 137./255., 187./255., 251./255.};; 3230 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3231 }; 3232 break;; 3233 ; 3234 // Coffee; 3235 case 76:; 3236 {; 3237 Double_t red[9] = { 79./255., 100./255., 119./255., 137./255., 153./255., 172./255., 192./255., 205./255., 250./255.};; 3238 Double_t green[9] = { 63./255., 79./255., 93./255., 103./255., 115./255., 135./255., 167./255., 196./255., 250./255.};; 3239 Double_t blue[9] = { 51./255., 59./255., 66./255., 61./255., 62./255., 70./255., 110./255., 160./255., 250./255.};; 3240 Idx = TColor::CreateGradientColorTable(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TColor_8cxx_source.html:123948,green,green,123948,doc/master/TColor_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html,1,['green'],['green']
Energy Efficiency,"76 *((char**) fAddress) = nullptr;; 4677 }; 4678 ResetBit(kDeleteObject);; 4679 if (fType == 3) {; 4680 // -- We are a TClonesArray master branch.; 4681 TClonesArray::Class()->Destructor(fObject);; 4682 fObject = nullptr;; 4683 if ((fStreamerType == TVirtualStreamerInfo::kObjectp) ||; 4684 (fStreamerType == TVirtualStreamerInfo::kObjectP)) {; 4685 // -- We are a pointer to a TClonesArray.; 4686 // We must zero the pointer in the object.; 4687 *((char**) fAddress) = nullptr;; 4688 }; 4689 } else if (fType == 4) {; 4690 // -- We are an STL container master branch.; 4691 TVirtualCollectionProxy* proxy = GetCollectionProxy();; 4692 ; 4693 if (!proxy) {; 4694 Warning(""ReleaseObject"", ""Cannot delete allocated STL container because I do not have a proxy! branch: %s"", GetName());; 4695 fObject = nullptr;; 4696 } else {; 4697 bool needDelete = proxy->GetProperties()&TVirtualCollectionProxy::kNeedDelete;; 4698 if (needDelete && fID >= 0) {; 4699 TVirtualStreamerInfo* si = GetInfoImp();; 4700 TStreamerElement* se = (TStreamerElement*) si->GetElement(fID);; 4701 needDelete = !se->TestBit(TStreamerElement::kDoNotDelete);; 4702 }; 4703 if (needDelete) {; 4704 TVirtualCollectionProxy::TPushPop helper(proxy,fObject);; 4705 proxy->Clear(""force"");; 4706 }; 4707 proxy->Destructor(fObject);; 4708 fObject = nullptr;; 4709 }; 4710 if (fStreamerType == TVirtualStreamerInfo::kSTLp) {; 4711 // -- We are a pointer to an STL container.; 4712 // We must zero the pointer in the object.; 4713 *((char**) fAddress) = nullptr;; 4714 }; 4715 } else {; 4716 // We are *not* a TClonesArray master branch and we are *not* an STL container master branch.; 4717 TClass* cl = fBranchClass.GetClass();; 4718 if (!cl) {; 4719 Warning(""ReleaseObject"", ""Cannot delete allocated object because I cannot instantiate a TClass object for its class! branch: '%s' class: '%s'"", GetName(), fBranchClass.GetClassName());; 4720 fObject = nullptr;; 4721 } else {; 4722 TVirtualCollectionProxy* proxy = cl->GetCollectionProxy();;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBranchElement_8cxx_source.html:173941,allocate,allocated,173941,doc/master/TBranchElement_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html,1,['allocate'],['allocated']
Energy Efficiency,"76:; 3236 {; 3237 Double_t red[9] = { 79./255., 100./255., 119./255., 137./255., 153./255., 172./255., 192./255., 205./255., 250./255.};; 3238 Double_t green[9] = { 63./255., 79./255., 93./255., 103./255., 115./255., 135./255., 167./255., 196./255., 250./255.};; 3239 Double_t blue[9] = { 51./255., 59./255., 66./255., 61./255., 62./255., 70./255., 110./255., 160./255., 250./255.};; 3240 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3241 }; 3242 break;; 3243 ; 3244 // Dark Rain Bow; 3245 case 77:; 3246 {; 3247 Double_t red[9] = { 43./255., 44./255., 50./255., 66./255., 125./255., 172./255., 178./255., 155./255., 157./255.};; 3248 Double_t green[9] = { 63./255., 63./255., 85./255., 101./255., 138./255., 163./255., 122./255., 51./255., 39./255.};; 3249 Double_t blue[9] = { 121./255., 101./255., 58./255., 44./255., 47./255., 55./255., 57./255., 44./255., 43./255.};; 3250 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3251 }; 3252 break;; 3253 ; 3254 // Dark Terrain; 3255 case 78:; 3256 {; 3257 Double_t red[9] = { 0./255., 41./255., 62./255., 79./255., 90./255., 87./255., 99./255., 140./255., 228./255.};; 3258 Double_t green[9] = { 0./255., 57./255., 81./255., 93./255., 85./255., 70./255., 71./255., 125./255., 228./255.};; 3259 Double_t blue[9] = { 95./255., 91./255., 91./255., 82./255., 60./255., 43./255., 44./255., 112./255., 228./255.};; 3260 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3261 }; 3262 break;; 3263 ; 3264 // Fall; 3265 case 79:; 3266 {; 3267 Double_t red[9] = { 49./255., 59./255., 72./255., 88./255., 114./255., 141./255., 176./255., 205./255., 222./255.};; 3268 Double_t green[9] = { 78./255., 72./255., 66./255., 57./255., 59./255., 75./255., 106./255., 142./255., 173./255.};; 3269 Double_t blue[9] = { 78./255., 55./255., 46./255., 40./255., 39./255., 39./255., 40./255., 41./255., 47./255.};; 3270 Idx = TColor::CreateGradientColorTable(9, stops, red, gr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TColor_8cxx_source.html:125518,green,green,125518,doc/master/TColor_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html,1,['green'],['green']
Energy Efficiency,"79 indobj++;; 280 }; 281 ; 282 // Add the non-mergeable objects, if any; 283 if (notmergeable && notmergeable->GetSize() > 0) {; 284 TIter nxnm(notmergeable);; 285 while (auto onm = nxnm()); 286 Add(onm->Clone());; 287 SafeDelete(notmergeable);; 288 }; 289 ; 290 return nmerged;; 291}; SafeDelete#define SafeDelete(p)Definition RConfig.hxx:525; b#define b(i)Definition RSha256.hxx:100; a#define a(i)Definition RSha256.hxx:99; Longptr_tlong Longptr_tDefinition RtypesCore.h:75; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; Long64_tlong long Long64_tDefinition RtypesCore.h:69; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; ClassImp#define ClassImp(name)Definition Rtypes.h:382; TClass.h; TCollection.h; gCollectionMutexR__EXTERN TVirtualMutex * gCollectionMutexDefinition TCollection.h:45; TMethodCall.h; TSeqCollection.h; TVirtualMutex.h; R__LOCKGUARD2#define R__LOCKGUARD2(mutex)Definition TVirtualMutex.h:96; TClass::Newvoid * New(ENewType defConstructor=kClassNew, Bool_t quiet=kFALSE) constReturn a pointer to a newly allocated object of this class.Definition TClass.cxx:5045; TCollectionCollection abstract base class.Definition TCollection.h:65; TCollection::SetOwnervirtual void SetOwner(Bool_t enable=kTRUE)Set whether this collection is the owner (enable==true) of its content.Definition TCollection.cxx:746; TCollection::IsEmptyvirtual Bool_t IsEmpty() constDefinition TCollection.h:188; TCollection::GetSizevirtual Int_t GetSize() constReturn the capacity of the collection, i.e.Definition TCollection.h:184; TIterDefinition TCollection.h:235; TIter::Resetvoid Reset()Definition TCollection.h:254; TMethodCallMethod or function calling interface.Definition TMethodCall.h:37; TMethodCall::Executevoid Execute(const char *, const char *, int *=nullptr) overrideExecute method on this object with the given parameter string, e.g.Definition TMethodCall.h:64; TMethodCall::IsValidBool_t IsValid() constReturn true if the method call has been properly initialized and is usa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSeqCollection_8cxx_source.html:10632,allocate,allocated,10632,doc/master/TSeqCollection_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSeqCollection_8cxx_source.html,1,['allocate'],['allocated']
Energy Efficiency,"7; TMVA::DNN::Settings::learningRatedouble learningRate() constget the learning rateDefinition NeuralNet.h:771; TMVA::DNN::Settings::m_dropRepetitionsdouble m_dropRepetitionsDefinition NeuralNet.h:849; TMVA::DNN::Settings::dropFractionsconst std::vector< double > & dropFractions() constDefinition NeuralNet.h:762; TMVA::DNN::Settings::addPointvoid addPoint(std::string histoName, double x)for monitoringDefinition NeuralNet.h:821; TMVA::DNN::Settings::~Settingsvirtual ~Settings()d'torDefinition NeuralNet.cxx:261; TMVA::DNN::Settings::m_convergenceCountsize_t m_convergenceCountDefinition NeuralNet.h:857; TMVA::DNN::Settings::m_regularizationEnumRegularization m_regularizationDefinition NeuralNet.h:847; TMVA::DNN::Settings::repetitionsint repetitions() consthow many steps have to be gone until the batch is changedDefinition NeuralNet.h:773; TMVA::DNN::Settings::m_minErrordouble m_minErrorDefinition NeuralNet.h:859; TMVA::DNN::Settings::testSamplevirtual void testSample(double, double, double, double)virtual function to be used for monitoring (callback)Definition NeuralNet.h:781; TMVA::DNN::Settings::plotvoid plot(std::string histoName, std::string options, int pad, EColor color)for monitoringDefinition NeuralNet.h:823; TMVA::DNN::Settings::startTrainCyclevirtual void startTrainCycle()Definition NeuralNet.h:782; TMVA::DNN::Settings::convergenceStepssize_t convergenceSteps() consthow many steps until training is deemed to have convergedDefinition NeuralNet.h:766; TMVA::DNN::Settings::m_factorWeightDecaydouble m_factorWeightDecayDefinition NeuralNet.h:840; TMVA::DNN::Settings::factorWeightDecaydouble factorWeightDecay() constget the weight-decay factorDefinition NeuralNet.h:769; TMVA::DNN::Settings::count_mb_dEsize_t count_mb_dEDefinition NeuralNet.h:845; TMVA::DNN::Settings::m_useMultithreadingbool m_useMultithreadingDefinition NeuralNet.h:863; TMVA::DNN::Settings::count_mb_Esize_t count_mb_EDefinition NeuralNet.h:844; TMVA::DNN::Settings::existsbool exists(std::string hist",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/NeuralNet_8h_source.html:75611,monitor,monitoring,75611,doc/master/NeuralNet_8h_source.html,https://root.cern,https://root.cern/doc/master/NeuralNet_8h_source.html,1,['monitor'],['monitoring']
Energy Efficiency,"7; TVirtualCollectionProxy::TPushPopRAII helper class that ensures that PushProxy() / PopProxy() are called when entering / leaving a C++...Definition TVirtualCollectionProxy.h:75; TVirtualCollectionProxyDefines a common interface to inspect/change the contents of an object that represents a collection.Definition TVirtualCollectionProxy.h:52; TVirtualCollectionProxy::GetWriteMemberWiseActionsvirtual TStreamerInfoActions::TActionSequence * GetWriteMemberWiseActions()=0; TVirtualCollectionProxy::GetValueClassvirtual TClass * GetValueClass() const =0If the value type is a user-defined class, return a pointer to the TClass representing the value type...; TVirtualCollectionProxy::GetFunctionDeleteTwoIteratorsvirtual DeleteTwoIterators_t GetFunctionDeleteTwoIterators(Bool_t read=kTRUE)=0; TVirtualCollectionProxy::Sizevirtual UInt_t Size() const =0Return the current number of elements in the container.; TVirtualCollectionProxy::fgIteratorArenaSizestatic const Int_t fgIteratorArenaSizeThe size of a small buffer that can be allocated on the stack to store iterator-specific information.Definition TVirtualCollectionProxy.h:207; TVirtualCollectionProxy::GetFunctionCreateIteratorsvirtual CreateIterators_t GetFunctionCreateIterators(Bool_t read=kTRUE)=0Return a pointer to a function that can create an iterator pair, where each iterator points to the be...; TVirtualStreamerInfo::GetStreamMemberWisestatic Bool_t GetStreamMemberWise()Return whether the TStreamerInfos will save the collections in ""member-wise"" order whenever possible.Definition TVirtualStreamerInfo.cxx:155; TVirtualStreamerInfo::kStreamer@ kStreamerDefinition TVirtualStreamerInfo.h:130; TVirtualStreamerInfo::kULong64@ kULong64Definition TVirtualStreamerInfo.h:122; TVirtualStreamerInfo::kObjectp@ kObjectpDefinition TVirtualStreamerInfo.h:123; TVirtualStreamerInfo::kLong@ kLongDefinition TVirtualStreamerInfo.h:118; TVirtualStreamerInfo::kObjectP@ kObjectPDefinition TVirtualStreamerInfo.h:123; TVirtualStreamerInfo::kCach",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfoWriteBuffer_8cxx_source.html:47377,allocate,allocated,47377,doc/master/TStreamerInfoWriteBuffer_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfoWriteBuffer_8cxx_source.html,1,['allocate'],['allocated']
Energy Efficiency,"8 SetObjectStat(statsave);; 5139 }; 5140 ; 5141 if (!p) {; 5142 Error(""New"", ""Failed to construct class '%s' using streamer info"", GetName());; 5143 }; 5144 ; 5145 return p;; 5146 } else {; 5147 Fatal(""New"", ""This cannot happen!"");; 5148 }; 5149 ; 5150 return p;; 5151}; 5152 ; 5153////////////////////////////////////////////////////////////////////////////////; 5154/// Return a pointer to a newly allocated object of this class.; 5155/// The class must have a default constructor. For meaning of; 5156/// defConstructor, see TClass::IsCallingNew().; 5157 ; 5158void *TClass::New(void *arena, ENewType defConstructor) const; 5159{; 5160 auto obj = NewObject(arena, defConstructor);; 5161 if (obj.GetPtr() && obj.GetAllocator()) {; 5162 // Register the object for special handling in the destructor.; 5163 RegisterAddressInRepository(""TClass::New with placement"", obj.GetPtr(), this);; 5164 }; 5165 return obj.GetPtr();; 5166}; 5167 ; 5168////////////////////////////////////////////////////////////////////////////////; 5169/// Return a pointer to a newly allocated object of this class.; 5170/// The class must have a default constructor. For meaning of; 5171/// defConstructor, see TClass::IsCallingNew().; 5172 ; 5173TClass::ObjectPtr TClass::NewObject(void *arena, ENewType defConstructor) const; 5174{; 5175 ObjectPtr p;; 5176 ; 5177 if (fNew) {; 5178 // We have the new operator wrapper function,; 5179 // so there is a dictionary and it was generated; 5180 // by rootcint, so there should be a default; 5181 // constructor we can call through the wrapper.; 5182 {; 5183 TClass__GetCallingNewRAII callingNew(defConstructor);; 5184 p = fNew(arena);; 5185 }; 5186 if (!p) {; 5187 Error(""New with placement"", ""cannot create object of class %s version %d at address %p"", GetName(), fClassVersion, arena);; 5188 }; 5189 } else if (HasInterpreterInfo()) {; 5190 // We have the dictionary but do not have the; 5191 // constructor wrapper, so the dictionary was; 5192 // not generated by rootcint. Le",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:197303,allocate,allocated,197303,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['allocate'],['allocated']
Energy Efficiency,"8. Double_t Interpolate(Double_t x, Double_t y, Double_t z); illegal for a TH2. Double_t KolmogorovTest(const TH1* h2, Option_t* option = """") const; Statistical test of compatibility in shape between; THIS histogram and h2, using Kolmogorov test.; Default: Ignore under- and overflow bins in comparison. option is a character string to specify options; ""U"" include Underflows in test; ""O"" include Overflows; ""N"" include comparison of normalizations; ""D"" Put out a line of ""Debug"" printout; ""M"" Return the Maximum Kolmogorov distance instead of prob. The returned function value is the probability of test; (much less than one means NOT compatible). The KS test uses the distance between the pseudo-CDF's obtained; from the histogram. Since in 2D the order for generating the pseudo-CDF is; arbitrary, two pairs of pseudo-CDF are used, one starting from the x axis the; other from the y axis and the maximum distance is the average of the two maximum; distances obtained. Code adapted by Rene Brun from original HBOOK routine HDIFF. Long64_t Merge(TCollection* list); Add all histograms in the collection to this histogram.; This function computes the min/max for the axes,; compute a new number of bins, if necessary,; add bin contents, errors and statistics.; If overflows are present and limits are different the function will fail.; The function returns the total number of entries in the result histogram; if the merge is successfull, -1 otherwise. IMPORTANT remark. The 2 axis x and y may have different number; of bins and different limits, BUT the largest bin width must be; a multiple of the smallest bin width and the upper limit must also; be a multiple of the bin width. TH2 * RebinX(Int_t ngroup = 2, const char* newname = """"); Rebin only the X axis; see Rebin2D. TH2 * RebinY(Int_t ngroup = 2, const char* newname = """"); Rebin only the Y axis; see Rebin2D. TH2 * Rebin2D(Int_t nxgroup = 2, Int_t nygroup = 2, const char* newname = """"); -*-*-*Rebin this histogram grouping nxgroup/nygroup ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TH2.html:40367,adapt,adapted,40367,root/html528/TH2.html,https://root.cern,https://root.cern/root/html528/TH2.html,4,['adapt'],['adapted']
Energy Efficiency,"8. Double_t Interpolate(Double_t x, Double_t y, Double_t z); illegal for a TH2. Double_t KolmogorovTest(const TH1* h2, Option_t* option = """") const; Statistical test of compatibility in shape between; THIS histogram and h2, using Kolmogorov test.; Default: Ignore under- and overflow bins in comparison. option is a character string to specify options; ""U"" include Underflows in test; ""O"" include Overflows; ""N"" include comparison of normalizations; ""D"" Put out a line of ""Debug"" printout; ""M"" Return the Maximum Kolmogorov distance instead of prob. The returned function value is the probability of test; (much less than one means NOT compatible). The KS test uses the distance between the pseudo-CDF's obtained; from the histogram. Since in 2D the order for generating the pseudo-CDF is; arbitrary, two pairs of pseudo-CDF are used, one starting from the x axis the; other from the y axis and the maximum distance is the average of the two maximum; distances obtained. Code adapted by Rene Brun from original HBOOK routine HDIFF. Long64_t Merge(TCollection* list); Add all histograms in the collection to this histogram.; This function computes the min/max for the axes,; compute a new number of bins, if necessary,; add bin contents, errors and statistics.; If overflows are present and limits are different the function will fail.; The function returns the total number of entries in the result histogram; if the merge is successfull, -1 otherwise. IMPORTANT remark. The 2 axis x and y may have different number; of bins and different limits, BUT the largest bin width must be; a multiple of the smallest bin width and the upper limit must also; be a multiple of the bin width. TH2 * RebinX(Int_t ngroup = 2, const char* newname = """"); Rebin only the X axis; see Rebin2D. TH2 * RebinY(Int_t ngroup = 2, const char* newname = """"); Rebin only the Y axis; see Rebin2D. TH2 * Rebin2D(Int_t nxgroup = 2, Int_t nygroup = 2, const char* newname = """"); Rebin this histogram grouping nxgroup/nygroup bins a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TH2.html:44837,adapt,adapted,44837,root/html602/TH2.html,https://root.cern,https://root.cern/root/html602/TH2.html,2,['adapt'],['adapted']
Energy Efficiency,"8./255., 174./255., 163./255., 175./255., 244./255.};; 3169 Double_t blue[9] = { 49./255., 54./255., 55./255., 66./255., 91./255., 130./255., 184./255., 224./255., 244./255.};; 3170 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3171 }; 3172 break;; 3173 ; 3174 // Black Body; 3175 case 70:; 3176 {; 3177 Double_t red[9] = { 243./255., 243./255., 240./255., 240./255., 241./255., 239./255., 186./255., 151./255., 129./255.};; 3178 Double_t green[9] = { 0./255., 46./255., 99./255., 149./255., 194./255., 220./255., 183./255., 166./255., 147./255.};; 3179 Double_t blue[9] = { 6./255., 8./255., 36./255., 91./255., 169./255., 235./255., 246./255., 240./255., 233./255.};; 3180 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3181 }; 3182 break;; 3183 ; 3184 // Blue Green Yellow; 3185 case 71:; 3186 {; 3187 Double_t red[9] = { 22./255., 19./255., 19./255., 25./255., 35./255., 53./255., 88./255., 139./255., 210./255.};; 3188 Double_t green[9] = { 0./255., 32./255., 69./255., 108./255., 135./255., 159./255., 183./255., 198./255., 215./255.};; 3189 Double_t blue[9] = { 77./255., 96./255., 110./255., 116./255., 110./255., 100./255., 90./255., 78./255., 70./255.};; 3190 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3191 }; 3192 break;; 3193 ; 3194 // Brown Cyan; 3195 case 72:; 3196 {; 3197 Double_t red[9] = { 68./255., 116./255., 165./255., 182./255., 189./255., 180./255., 145./255., 111./255., 71./255.};; 3198 Double_t green[9] = { 37./255., 82./255., 135./255., 178./255., 204./255., 225./255., 221./255., 202./255., 147./255.};; 3199 Double_t blue[9] = { 16./255., 55./255., 105./255., 147./255., 196./255., 226./255., 232./255., 224./255., 178./255.};; 3200 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3201 }; 3202 break;; 3203 ; 3204 // CMYK; 3205 case 73:; 3206 {; 3207 Double_t red[9] = { 61./255., 99./255., 136./255., 181./255., 213./255., 225./2",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TColor_8cxx_source.html:122075,green,green,122075,doc/master/TColor_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html,1,['green'],['green']
Energy Efficiency,"8/// serv->AddLocation(""mydir/"", ""/home/user/specials"");; 329///; 330/// Than files from this directory could be addressed via server like `http://localhost:8080/mydir/myfile.root`; 331 ; 332void THttpServer::AddLocation(const char *prefix, const char *path); 333{; 334 if (!prefix || (*prefix == 0)); 335 return;; 336 ; 337 if (!path); 338 fLocations.erase(fLocations.find(prefix));; 339 else; 340 fLocations[prefix] = path;; 341}; 342 ; 343////////////////////////////////////////////////////////////////////////////////; 344/// Set location of JSROOT to use with the server; 345///; 346/// One could specify address like:; 347///; 348/// * https://root.cern/js/7.6.0/; 349/// * https://jsroot.gsi.de/7.6.0/; 350///; 351/// This allows to get new JSROOT features with old server,; 352/// reduce load on THttpServer instance, also startup time can be improved; 353/// When empty string specified (default), local copy of JSROOT is used (distributed with ROOT); 354 ; 355void THttpServer::SetJSROOT(const char *location); 356{; 357 fJSROOT = location ? location : """";; 358}; 359 ; 360////////////////////////////////////////////////////////////////////////////////; 361/// Set default HTML page; 362///; 363/// Sets file name, delivered by the server when http address is opened in the browser.; 364///; 365/// By default, $ROOTSYS/js/files/online.htm page is used; 366/// When empty filename is specified, default page will be used; 367 ; 368void THttpServer::SetDefaultPage(const std::string &filename); 369{; 370 if (!filename.empty()); 371 fDefaultPage = filename;; 372 else; 373 fDefaultPage = fJSROOTSYS + ""/files/online.htm"";; 374 ; 375 // force to read page content next time again; 376 fDefaultPageCont.clear();; 377}; 378 ; 379////////////////////////////////////////////////////////////////////////////////; 380/// Set drawing HTML page; 381///; 382/// Set file name of HTML page, delivered by the server when; 383/// objects drawing page is requested from the browser; 384/// By default, $",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THttpServer_8cxx_source.html:11525,reduce,reduce,11525,doc/master/THttpServer_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THttpServer_8cxx_source.html,1,['reduce'],['reduce']
Energy Efficiency,"83////////////////////////////////////////////////////////////////////////////////; 684/// Returns the nearest integer of `TMath::Floor(x)`.; 685 ; 686inline Int_t TMath::FloorNint(Double_t x); 687 { return TMath::Nint(floor(x)); }; 688 ; 689////////////////////////////////////////////////////////////////////////////////; 690/// Round to nearest integer. Rounds half integers to the nearest even integer.; 691 ; 692template<typename T>; 693inline Int_t TMath::Nint(T x); 694{; 695 int i;; 696 if (x >= 0) {; 697 i = int(x + 0.5);; 698 if ( i & 1 && x + 0.5 == T(i) ) i--;; 699 } else {; 700 i = int(x - 0.5);; 701 if ( i & 1 && x - 0.5 == T(i) ) i++;; 702 }; 703 return i;; 704}; 705 ; 706////////////////////////////////////////////////////////////////////////////////; 707/// Returns the base-e exponential function of x, which is e raised to the power `x`.; 708 ; 709inline Double_t TMath::Exp(Double_t x); 710 { return exp(x); }; 711 ; 712////////////////////////////////////////////////////////////////////////////////; 713/// Returns the result of multiplying `x` (the significant) by 2 raised to the power of `exp` (the exponent).; 714 ; 715inline Double_t TMath::Ldexp(Double_t x, Int_t exp); 716 { return ldexp(x, exp); }; 717 ; 718////////////////////////////////////////////////////////////////////////////////; 719/// Returns `x` raised to the power `y`.; 720 ; 721inline LongDouble_t TMath::Power(LongDouble_t x, LongDouble_t y); 722 { return std::pow(x,y); }; 723 ; 724////////////////////////////////////////////////////////////////////////////////; 725/// Returns `x` raised to the power `y`.; 726 ; 727inline LongDouble_t TMath::Power(LongDouble_t x, Long64_t y); 728 { return std::pow(x,(LongDouble_t)y); }; 729 ; 730////////////////////////////////////////////////////////////////////////////////; 731/// Returns `x` raised to the power `y`.; 732 ; 733inline LongDouble_t TMath::Power(Long64_t x, Long64_t y); 734 { return std::pow(x,y); }; 735 ; 736/////////////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMath_8h_source.html:26785,power,power,26785,doc/master/TMath_8h_source.html,https://root.cern,https://root.cern/doc/master/TMath_8h_source.html,1,['power'],['power']
Energy Efficiency,"8GB memory, THnSparse ""wins""; 548starting with a TH3 with 30 bins per dimension. Using a THnSparse for a; 549one-dimensional histogram is only reasonable if it has a huge number of bins.; 550 ; 551## Projections; 552The dimensionality of a THnSparse can be reduced by projecting it to; 5531, 2, 3, or n dimensions, which can be represented by a TH1, TH2, TH3, or; 554a THnSparse. See the Projection() members. To only project parts of the; 555histogram, call; 556 ; 557 THnSparse::GetAxis(12)->SetRange(from_bin, to_bin);; 558 ; 559## Internal Representation; 560An entry for a filled bin consists of its n-dimensional coordinates and; 561its bin content. The coordinates are compacted to use as few bits as; 562possible; e.g. a histogram with 10 bins in x and 20 bins in y will only; 563use 4 bits for the x representation and 5 bits for the y representation.; 564This is handled by the internal class THnSparseCompactBinCoord.; 565Bin data (content and coordinates) are allocated in chunks of size; 566fChunkSize; this parameter can be set when constructing a THnSparse. Each; 567chunk is represented by an object of class THnSparseArrayChunk.; 568 ; 569Translation from an n-dimensional bin coordinate to the linear index within; 570the chunks is done by GetBin(). It creates a hash from the compacted bin; 571coordinates (the hash of a bin coordinate is the compacted coordinate itself; 572if it takes less than 8 bytes, the size of a Long64_t.; 573This hash is used to lookup the linear index in the TExMap member fBins;; 574the coordinates of the entry fBins points to is compared to the coordinates; 575passed to GetBin(). If they do not match, these two coordinates have the same; 576hash - which is extremely unlikely but (for the case where the compact bin; 577coordinates are larger than 4 bytes) possible. In this case, fBinsContinued; 578contains a chain of linear indexes with the same hash. Iterating through this; 579chain and comparing each bin coordinates with the one passed to Get",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THnSparse_8cxx_source.html:21130,allocate,allocated,21130,doc/master/THnSparse_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html,1,['allocate'],['allocated']
Energy Efficiency,"9 Temple Place, Suite *; 21 * 330, Boston, MA 02111-1307 USA, or contact the author. *; 22 * *; 23 **********************************************************************/; 24 ; 25// Header file for class GSLFunctionWrapper; 26//; 27// Created by: moneta at Sat Nov 13 14:54:41 2004; 28//; 29// Last update: Sat Nov 13 14:54:41 2004; 30//; 31#ifndef ROOT_Math_GSLFunctionWrapper; 32#define ROOT_Math_GSLFunctionWrapper; 33 ; 34#include ""gsl/gsl_math.h""; 35 ; 36#include ""Math/GSLFunctionAdapter.h""; 37 ; 38#include <cassert>; 39 ; 40namespace ROOT {; 41namespace Math {; 42 ; 43 ; 44 ; 45typedef double ( * GSLFuncPointer ) ( double, void *);; 46typedef void ( * GSLFdfPointer ) ( double, void *, double *, double *);; 47 ; 48 ; 49/**; 50 Wrapper class to the gsl_function C structure.; 51 This class to fill the GSL C structure gsl_function with; 52 the C++ function objcet.; 53 Use the class ROOT::Math::GSLFunctionAdapter to adapt the; 54 C++ function object to the right signature (function pointer type); 55 requested by GSL; 56*/; 57class GSLFunctionWrapper {; 58 ; 59public:; 60 ; 61 GSLFunctionWrapper(); 62 {; 63 fFunc.function = nullptr;; 64 fFunc.params = nullptr;; 65 }; 66 ; 67 /// set in the GSL C struct the pointer to the function evaluation; 68 void SetFuncPointer( GSLFuncPointer f) { fFunc.function = f; }; 69 ; 70 /// set in the GSL C struct the extra-object pointer; 71 void SetParams ( void * p) { fFunc.params = p; }; 72 ; 73 /// fill the GSL C struct from a generic C++ callable object; 74 /// implementing operator(); 75 template<class FuncType>; 76 void SetFunction(const FuncType &f) {; 77 const void * p = &f;; 78 assert (p != nullptr);; 79 SetFuncPointer(&GSLFunctionAdapter<FuncType >::F);; 80 SetParams(const_cast<void *>(p));; 81 }; 82 ; 83 gsl_function * GetFunc() { return &fFunc; }; 84 ; 85 GSLFuncPointer FunctionPtr() { return fFunc.function; }; 86 ; 87 // evaluate the function; 88 double operator() (double x) { return GSL_FN_EVAL(&fFunc, x); }; 89 ; 90 /// check",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/GSLFunctionWrapper_8h_source.html:2083,adapt,adapt,2083,doc/master/GSLFunctionWrapper_8h_source.html,https://root.cern,https://root.cern/doc/master/GSLFunctionWrapper_8h_source.html,1,['adapt'],['adapt']
Energy Efficiency,"9/// internally and the branch is the owner of the allocated; 4860/// object, not the caller. However the caller may obtain; 4861/// a pointer to the branch object with GetObject().; 4862/// The pointer is reset to zero (nullptr) when the relevant; 4863/// branch object is destroyed.; 4864///; 4865/// Example:; 4866/// ~~~ {.cpp}; 4867/// branch->SetAddress(0);; 4868/// Event* event = branch->GetObject();; 4869/// ... Do some work.; 4870/// ~~~; 4871/// If addr is not zero, but the pointer addr points at is; 4872/// zero, then we allocate a branch object and set the passed; 4873/// pointer to point at the allocated object. The caller; 4874/// owns the allocated object and is responsible for deleting; 4875/// it when it is no longer needed.; 4876///; 4877/// Example:; 4878/// ~~~ {.cpp}; 4879/// Event* event = 0;; 4880/// branch->SetAddress(&event);; 4881/// ... Do some work.; 4882/// delete event;; 4883/// event = 0;; 4884/// ~~~; 4885/// If addr is not zero and the pointer addr points at is; 4886/// also not zero, then the caller has allocated a branch; 4887/// object and is asking us to use it. The caller owns it; 4888/// and must delete it when it is no longer needed.; 4889///; 4890/// Example:; 4891/// ~~~ {.cpp}; 4892/// Event* event = new Event();; 4893/// branch->SetAddress(&event);; 4894/// ... Do some work.; 4895/// delete event;; 4896/// event = 0;; 4897/// ~~~; 4898/// These rules affect users of TTree::Branch(),; 4899/// TTree::SetBranchAddress(), and TChain::SetBranchAddress(); 4900/// as well because those routines call this one.; 4901///; 4902/// An example of a tree with branches with objects allocated; 4903/// and owned by us:; 4904/// ~~~ {.cpp}; 4905/// TFile* f1 = new TFile(""myfile_original.root"");; 4906/// TTree* t1 = (TTree*) f->Get(""MyTree"");; 4907/// TFile* f2 = new TFile(""myfile_copy.root"", ""recreate"");; 4908/// TTree* t2 = t1->Clone(0);; 4909/// for (Int_t i = 0; i < 10; ++i) {; 4910/// t1->GetEntry(i);; 4911/// t2->Fill();; 4912/// }; 4913",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBranchElement_8cxx_source.html:180715,allocate,allocated,180715,doc/master/TBranchElement_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html,1,['allocate'],['allocated']
Energy Efficiency,"90:; 3376 {; 3377 Double_t red[9] = { 171./255., 141./255., 145./255., 152./255., 154./255., 159./255., 163./255., 158./255., 177./255.};; 3378 Double_t green[9] = { 236./255., 143./255., 100./255., 63./255., 53./255., 55./255., 44./255., 31./255., 6./255.};; 3379 Double_t blue[9] = { 59./255., 48./255., 46./255., 44./255., 42./255., 54./255., 82./255., 112./255., 179./255.};; 3380 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3381 }; 3382 break;; 3383 ; 3384 // Pastel; 3385 case 91:; 3386 {; 3387 Double_t red[9] = { 180./255., 190./255., 209./255., 223./255., 204./255., 228./255., 205./255., 152./255., 91./255.};; 3388 Double_t green[9] = { 93./255., 125./255., 147./255., 172./255., 181./255., 224./255., 233./255., 198./255., 158./255.};; 3389 Double_t blue[9] = { 236./255., 218./255., 160./255., 133./255., 114./255., 132./255., 162./255., 220./255., 218./255.};; 3390 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3391 }; 3392 break;; 3393 ; 3394 // Pearl; 3395 case 92:; 3396 {; 3397 Double_t red[9] = { 225./255., 183./255., 162./255., 135./255., 115./255., 111./255., 119./255., 145./255., 211./255.};; 3398 Double_t green[9] = { 205./255., 177./255., 166./255., 135./255., 124./255., 117./255., 117./255., 132./255., 172./255.};; 3399 Double_t blue[9] = { 186./255., 165./255., 155./255., 135./255., 126./255., 130./255., 150./255., 178./255., 226./255.};; 3400 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3401 }; 3402 break;; 3403 ; 3404 // Pigeon; 3405 case 93:; 3406 {; 3407 Double_t red[9] = { 39./255., 43./255., 59./255., 63./255., 80./255., 116./255., 153./255., 177./255., 223./255.};; 3408 Double_t green[9] = { 39./255., 43./255., 59./255., 74./255., 91./255., 114./255., 139./255., 165./255., 223./255.};; 3409 Double_t blue[9] = { 39./255., 50./255., 59./255., 70./255., 85./255., 115./255., 151./255., 176./255., 223./255.};; 3410 Idx = TColor::CreateGradientColo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TColor_8cxx_source.html:132895,green,green,132895,doc/master/TColor_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html,1,['green'],['green']
Energy Efficiency,"91 ; 292inline TIter TCollection::begin() const { return ++(TIter(this)); }; 293inline TIter TCollection::end() const { return TIter::End(); }; 294 ; 295namespace ROOT {; 296namespace Internal {; 297 ; 298const TCollection &EmptyCollection();; 299bool ContaineeInheritsFrom(TClass *cl, TClass *base);; 300 ; 301} // namespace Internal; 302 ; 303/// Special implementation of ROOT::RRangeCast for TCollection, including a; 304/// check that the cast target type inherits from TObject and a new constructor; 305/// that takes the TCollection by pointer.; 306/// \tparam T The new type to convert to.; 307/// \tparam isDynamic If `true`, `dynamic_cast` is used, otherwise `static_cast` is used.; 308namespace Detail {; 309 ; 310template <typename T, bool isDynamic>; 311class TRangeCast : public ROOT::RRangeCast<T*, isDynamic, TCollection const&> {; 312public:; 313 TRangeCast(TCollection const& col) : ROOT::RRangeCast<T*, isDynamic, TCollection const&>{col} {; 314 static_assert(std::is_base_of<TObject, T>::value, ""Containee type must inherit from TObject"");; 315 }; 316 TRangeCast(TCollection const* col) : TRangeCast{col != nullptr ? *col : ROOT::Internal::EmptyCollection()} {}; 317};; 318 ; 319/// @brief TRangeStaticCast is an adapter class that allows the typed iteration; 320/// through a TCollection. This requires the collection to contain elements; 321/// of the type requested (or a derived class). Any deviation from this expectation; 322/// will only be caught/reported by an assert in debug builds.; 323///; 324/// This is best used with a TClonesArray, for other cases prefered TRangeDynCast.; 325///; 326/// The typical use is:; 327/// ```{.cpp}; 328/// for(auto bcl : TRangeStaticCast<TBaseClass>( *tbaseClassClonesArrayPtr )) {; 329/// ... use bcl as a TBaseClass*; 330/// }; 331/// for(auto bcl : TRangeStaticCast<TBaseClass>( tbaseClassClonesArrayPtr )) {; 332/// ... use bcl as a TBaseClass*; 333/// }; 334/// ```; 335/// \tparam T The new type to convert to.; 336template <type",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCollection_8h_source.html:12451,adapt,adapter,12451,doc/master/TCollection_8h_source.html,https://root.cern,https://root.cern/doc/master/TCollection_8h_source.html,1,['adapt'],['adapter']
Energy Efficiency,"92:; 3396 {; 3397 Double_t red[9] = { 225./255., 183./255., 162./255., 135./255., 115./255., 111./255., 119./255., 145./255., 211./255.};; 3398 Double_t green[9] = { 205./255., 177./255., 166./255., 135./255., 124./255., 117./255., 117./255., 132./255., 172./255.};; 3399 Double_t blue[9] = { 186./255., 165./255., 155./255., 135./255., 126./255., 130./255., 150./255., 178./255., 226./255.};; 3400 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3401 }; 3402 break;; 3403 ; 3404 // Pigeon; 3405 case 93:; 3406 {; 3407 Double_t red[9] = { 39./255., 43./255., 59./255., 63./255., 80./255., 116./255., 153./255., 177./255., 223./255.};; 3408 Double_t green[9] = { 39./255., 43./255., 59./255., 74./255., 91./255., 114./255., 139./255., 165./255., 223./255.};; 3409 Double_t blue[9] = { 39./255., 50./255., 59./255., 70./255., 85./255., 115./255., 151./255., 176./255., 223./255.};; 3410 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3411 }; 3412 break;; 3413 ; 3414 // Plum; 3415 case 94:; 3416 {; 3417 Double_t red[9] = { 0./255., 38./255., 60./255., 76./255., 84./255., 89./255., 101./255., 128./255., 204./255.};; 3418 Double_t green[9] = { 0./255., 10./255., 15./255., 23./255., 35./255., 57./255., 83./255., 123./255., 199./255.};; 3419 Double_t blue[9] = { 0./255., 11./255., 22./255., 40./255., 63./255., 86./255., 97./255., 94./255., 85./255.};; 3420 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3421 }; 3422 break;; 3423 ; 3424 // Red Blue; 3425 case 95:; 3426 {; 3427 Double_t red[9] = { 94./255., 112./255., 141./255., 165./255., 167./255., 140./255., 91./255., 49./255., 27./255.};; 3428 Double_t green[9] = { 27./255., 46./255., 88./255., 135./255., 166./255., 161./255., 135./255., 97./255., 58./255.};; 3429 Double_t blue[9] = { 42./255., 52./255., 81./255., 106./255., 139./255., 158./255., 155./255., 137./255., 116./255.};; 3430 Idx = TColor::CreateGradientColorTable(9, stops, re",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TColor_8cxx_source.html:133947,green,green,133947,doc/master/TColor_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html,1,['green'],['green']
Energy Efficiency,"94./255., 220./255., 183./255., 166./255., 147./255.};; 3179 Double_t blue[9] = { 6./255., 8./255., 36./255., 91./255., 169./255., 235./255., 246./255., 240./255., 233./255.};; 3180 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3181 }; 3182 break;; 3183 ; 3184 // Blue Green Yellow; 3185 case 71:; 3186 {; 3187 Double_t red[9] = { 22./255., 19./255., 19./255., 25./255., 35./255., 53./255., 88./255., 139./255., 210./255.};; 3188 Double_t green[9] = { 0./255., 32./255., 69./255., 108./255., 135./255., 159./255., 183./255., 198./255., 215./255.};; 3189 Double_t blue[9] = { 77./255., 96./255., 110./255., 116./255., 110./255., 100./255., 90./255., 78./255., 70./255.};; 3190 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3191 }; 3192 break;; 3193 ; 3194 // Brown Cyan; 3195 case 72:; 3196 {; 3197 Double_t red[9] = { 68./255., 116./255., 165./255., 182./255., 189./255., 180./255., 145./255., 111./255., 71./255.};; 3198 Double_t green[9] = { 37./255., 82./255., 135./255., 178./255., 204./255., 225./255., 221./255., 202./255., 147./255.};; 3199 Double_t blue[9] = { 16./255., 55./255., 105./255., 147./255., 196./255., 226./255., 232./255., 224./255., 178./255.};; 3200 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3201 }; 3202 break;; 3203 ; 3204 // CMYK; 3205 case 73:; 3206 {; 3207 Double_t red[9] = { 61./255., 99./255., 136./255., 181./255., 213./255., 225./255., 198./255., 136./255., 24./255.};; 3208 Double_t green[9] = { 149./255., 140./255., 96./255., 83./255., 132./255., 178./255., 190./255., 135./255., 22./255.};; 3209 Double_t blue[9] = { 214./255., 203./255., 168./255., 135./255., 110./255., 100./255., 111./255., 113./255., 22./255.};; 3210 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3211 }; 3212 break;; 3213 ; 3214 // Candy; 3215 case 74:; 3216 {; 3217 Double_t red[9] = { 76./255., 120./255., 156./255., 183./255., 197./255., 180./2",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TColor_8cxx_source.html:122602,green,green,122602,doc/master/TColor_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html,1,['green'],['green']
Energy Efficiency,"95 }; 96 else; 97 t = 1.0;; 98 pkm2 = pkm1;; 99 pkm1 = pk;; 100 qkm2 = qkm1;; 101 qkm1 = qk;; 102 if( std::abs(pk) > kBig ); 103 {; 104 pkm2 *= kBiginv;; 105 pkm1 *= kBiginv;; 106 qkm2 *= kBiginv;; 107 qkm1 *= kBiginv;; 108 }; 109 }; 110 while( t > kMACHEP );; 111 ; 112 return( ans * ax );; 113}; 114 ; 115 ; 116 ; 117/* left tail of incomplete gamma function:; 118 *; 119 * inf. k; 120 * a -x - x; 121 * x e > ----------; 122 * - -; 123 * k=0 | (a+k+1); 124 *; 125 */; 126 ; 127double igam( double a, double x ); 128{; 129 double ans, ax, c, r;; 130 ; 131 // LM: for negative values returns 1.0 instead of zero; 132 // This is correct if a is a negative integer since Gamma(-n) = +/- inf; 133 if (a <= 0) return 1.0;; 134 ; 135 if (x <= 0) return 0.0;; 136 ; 137 if( (x > 1.0) && (x > a ) ); 138 return( 1.0 - igamc(a,x) );; 139 ; 140/* Compute x**a * exp(-x) / gamma(a) */; 141 ax = a * std::log(x) - x - lgam(a);; 142 if( ax < -kMAXLOG ); 143 return( 0.0 );; 144 ; 145 ax = std::exp(ax);; 146 ; 147/* power series */; 148 r = a;; 149 c = 1.0;; 150 ans = 1.0;; 151 ; 152 do; 153 {; 154 r += 1.0;; 155 c *= x/r;; 156 ans += c;; 157 }; 158 while( c/ans > kMACHEP );; 159 ; 160 return( ans * ax/a );; 161}; 162 ; 163/*---------------------------------------------------------------------------*/; 164 ; 165/* Logarithm of gamma function */; 166/* A[]: Stirling's formula expansion of log gamma; 167 * B[], C[]: log gamma function between 2 and 3; 168 */; 169 ; 170static double A[] = {; 171 8.11614167470508450300E-4,; 172 -5.95061904284301438324E-4,; 173 7.93650340457716943945E-4,; 174 -2.77777777730099687205E-3,; 175 8.33333333333331927722E-2; 176};; 177 ; 178static double B[] = {; 179 -1.37825152569120859100E3,; 180 -3.88016315134637840924E4,; 181 -3.31612992738871184744E5,; 182 -1.16237097492762307383E6,; 183 -1.72173700820839662146E6,; 184 -8.53555664245765465627E5; 185};; 186 ; 187static double C[] = {; 188/* 1.00000000000000000000E0, */; 189 -3.51815701436523470549E2,; 190 -1.706421066",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/SpecFuncCephes_8cxx_source.html:3083,power,power,3083,doc/master/SpecFuncCephes_8cxx_source.html,https://root.cern,https://root.cern/doc/master/SpecFuncCephes_8cxx_source.html,1,['power'],['power']
Energy Efficiency,"95./255., 67./255., 37./255., 21./255., 0./255., 12./255., 35./255., 52./255., 79./255.};; 3069 Double_t blue[9] = { 4./255., 3./255., 2./255., 6./255., 11./255., 22./255., 49./255., 98./255., 208./255.};; 3070 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3071 }; 3072 break;; 3073 ; 3074 // Blue Red Yellow; 3075 case 60:; 3076 {; 3077 Double_t red[9] = {0./255., 61./255., 89./255., 122./255., 143./255., 160./255., 185./255., 204./255., 231./255.};; 3078 Double_t green[9] = {0./255., 0./255., 0./255., 0./255., 14./255., 37./255., 72./255., 132./255., 235./255.};; 3079 Double_t blue[9] = {0./255., 140./255., 224./255., 144./255., 4./255., 5./255., 6./255., 9./255., 13./255.};; 3080 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3081 }; 3082 break;; 3083 ; 3084 // Ocean; 3085 case 61:; 3086 {; 3087 Double_t red[9] = { 14./255., 7./255., 2./255., 0./255., 5./255., 11./255., 55./255., 131./255., 229./255.};; 3088 Double_t green[9] = {105./255., 56./255., 26./255., 1./255., 42./255., 74./255., 131./255., 171./255., 229./255.};; 3089 Double_t blue[9] = { 2./255., 21./255., 35./255., 60./255., 92./255., 113./255., 160./255., 185./255., 229./255.};; 3090 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3091 }; 3092 break;; 3093 ; 3094 // Color Printable On Grey; 3095 case 62:; 3096 {; 3097 Double_t red[9] = { 0./255., 0./255., 0./255., 70./255., 148./255., 231./255., 235./255., 237./255., 244./255.};; 3098 Double_t green[9] = { 0./255., 0./255., 0./255., 0./255., 0./255., 69./255., 67./255., 216./255., 244./255.};; 3099 Double_t blue[9] = { 0./255., 102./255., 228./255., 231./255., 177./255., 124./255., 137./255., 20./255., 244./255.};; 3100 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3101 }; 3102 break;; 3103 ; 3104 // Alpine; 3105 case 63:; 3106 {; 3107 Double_t red[9] = { 50./255., 56./255., 63./255., 68./255., 93./255., 121./255., 165",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TColor_8cxx_source.html:116824,green,green,116824,doc/master/TColor_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html,1,['green'],['green']
Energy Efficiency,"991 }; 992}; 993 ; 994template <typename T>; 995RVecImpl<T> &RVecImpl<T>::operator=(const RVecImpl<T> &RHS); 996{; 997 // Avoid self-assignment.; 998 if (this == &RHS); 999 return *this;; 1000 ; 1001 // If we already have sufficient space, assign the common elements, then; 1002 // destroy any excess.; 1003 size_t RHSSize = RHS.size();; 1004 size_t CurSize = this->size();; 1005 if (CurSize >= RHSSize) {; 1006 // Assign common elements.; 1007 iterator NewEnd;; 1008 if (RHSSize); 1009 NewEnd = std::copy(RHS.begin(), RHS.begin() + RHSSize, this->begin());; 1010 else; 1011 NewEnd = this->begin();; 1012 ; 1013 // Destroy excess elements.; 1014 if (this->Owns()); 1015 this->destroy_range(NewEnd, this->end());; 1016 ; 1017 // Trim.; 1018 this->set_size(RHSSize);; 1019 return *this;; 1020 }; 1021 ; 1022 // If we have to grow to have enough elements, destroy the current elements.; 1023 // This allows us to avoid copying them during the grow.; 1024 // From the original LLVM implementation:; 1025 // FIXME: don't do this if they're efficiently moveable.; 1026 if (this->capacity() < RHSSize) {; 1027 if (this->Owns()) {; 1028 // Destroy current elements.; 1029 this->destroy_range(this->begin(), this->end());; 1030 }; 1031 this->set_size(0);; 1032 CurSize = 0;; 1033 this->grow(RHSSize);; 1034 } else if (CurSize) {; 1035 // Otherwise, use assignment for the already-constructed elements.; 1036 std::copy(RHS.begin(), RHS.begin() + CurSize, this->begin());; 1037 }; 1038 ; 1039 // Copy construct the new elements in place.; 1040 this->uninitialized_copy(RHS.begin() + CurSize, RHS.end(), this->begin() + CurSize);; 1041 ; 1042 // Set end.; 1043 this->set_size(RHSSize);; 1044 return *this;; 1045}; 1046 ; 1047template <typename T>; 1048RVecImpl<T> &RVecImpl<T>::operator=(RVecImpl<T> &&RHS); 1049{; 1050 // Avoid self-assignment.; 1051 if (this == &RHS); 1052 return *this;; 1053 ; 1054 // If the RHS isn't small, clear this vector and then steal its buffer.; 1055 if (!RHS.isSmall()) {; 1056 if (",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RVec_8hxx_source.html:35856,efficient,efficiently,35856,doc/master/RVec_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html,2,['efficient'],['efficiently']
Energy Efficiency,"9:; 3366 {; 3367 Double_t red[9] = { 105./255., 106./255., 122./255., 143./255., 159./255., 172./255., 176./255., 181./255., 207./255.};; 3368 Double_t green[9] = { 252./255., 197./255., 194./255., 187./255., 174./255., 162./255., 153./255., 136./255., 125./255.};; 3369 Double_t blue[9] = { 146./255., 133./255., 144./255., 155./255., 163./255., 167./255., 166./255., 162./255., 174./255.};; 3370 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3371 }; 3372 break;; 3373 ; 3374 // Neon; 3375 case 90:; 3376 {; 3377 Double_t red[9] = { 171./255., 141./255., 145./255., 152./255., 154./255., 159./255., 163./255., 158./255., 177./255.};; 3378 Double_t green[9] = { 236./255., 143./255., 100./255., 63./255., 53./255., 55./255., 44./255., 31./255., 6./255.};; 3379 Double_t blue[9] = { 59./255., 48./255., 46./255., 44./255., 42./255., 54./255., 82./255., 112./255., 179./255.};; 3380 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3381 }; 3382 break;; 3383 ; 3384 // Pastel; 3385 case 91:; 3386 {; 3387 Double_t red[9] = { 180./255., 190./255., 209./255., 223./255., 204./255., 228./255., 205./255., 152./255., 91./255.};; 3388 Double_t green[9] = { 93./255., 125./255., 147./255., 172./255., 181./255., 224./255., 233./255., 198./255., 158./255.};; 3389 Double_t blue[9] = { 236./255., 218./255., 160./255., 133./255., 114./255., 132./255., 162./255., 220./255., 218./255.};; 3390 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3391 }; 3392 break;; 3393 ; 3394 // Pearl; 3395 case 92:; 3396 {; 3397 Double_t red[9] = { 225./255., 183./255., 162./255., 135./255., 115./255., 111./255., 119./255., 145./255., 211./255.};; 3398 Double_t green[9] = { 205./255., 177./255., 166./255., 135./255., 124./255., 117./255., 117./255., 132./255., 172./255.};; 3399 Double_t blue[9] = { 186./255., 165./255., 155./255., 135./255., 126./255., 130./255., 150./255., 178./255., 226./255.};; 3400 Idx = TColor::Creat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TColor_8cxx_source.html:132363,green,green,132363,doc/master/TColor_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html,1,['green'],['green']
Energy Efficiency,": get all branches. The function returns the number of bytes read from the input buffer.; If entry does not exist the function returns 0.; If an I/O error occurs, the function returns -1. If the Tree has friends, also read the friends entry. To activate/deactivate one or more branches, use TBranch::SetBranchStatus; For example, if you have a Tree with several hundred branches, and you; are interested only by branches named ""a"" and ""b"", do; mytree.SetBranchStatus(""*"",0); //disable all branches; mytree.SetBranchStatus(""a"",1);; mytree.SetBranchStatus(""b"",1);; when calling mytree.GetEntry(i); only branches ""a"" and ""b"" will be read. WARNING!!; If your Tree has been created in split mode with a parent branch ""parent"",; mytree.SetBranchStatus(""parent"",1);; will not activate the sub-branches of ""parent"". You should do:; mytree.SetBranchStatus(""parent*"",1);. An alternative is to call directly; brancha.GetEntry(i); branchb.GetEntry(i);. IMPORTANT NOTE. By default, GetEntry reuses the space allocated by the previous object; for each branch. You can force the previous object to be automatically; deleted if you call mybranch.SetAutoDelete(kTRUE) (default is kFALSE).; Example:; Consider the example in $ROOTSYS/test/Event.h; The top level branch in the tree T is declared with:; Event *event = 0; //event must be null or point to a valid object; //it must be initialized; T.SetBranchAddress(""event"",&event);; When reading the Tree, one can choose one of these 3 options:. OPTION 1. for (Long64_t i=0;i<nentries;i++) {; T.GetEntry(i);; // the object event has been filled at this point; }; The default (recommended). At the first entry an object of the class; Event will be created and pointed by event. At the following entries,; event will be overwritten by the new data. All internal members that are; TObject* are automatically deleted. It is important that these members; be in a valid state when GetEntry is called. Pointers must be correctly; initialized. However these internal members wil",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTree.html:92275,allocate,allocated,92275,root/html532/TTree.html,https://root.cern,https://root.cern/root/html532/TTree.html,1,['allocate'],['allocated']
Energy Efficiency,": get all branches. The function returns the number of bytes read from the input buffer.; If entry does not exist the function returns 0.; If an I/O error occurs, the function returns -1. If the Tree has friends, also read the friends entry. To activate/deactivate one or more branches, use TBranch::SetBranchStatus; For example, if you have a Tree with several hundred branches, and you; are interested only by branches named ""u"" and ""v"", do; mytree.SetBranchStatus(""*"",0); //disable all branches; mytree.SetBranchStatus(""a"",1);; mytree.SetBranchStatus(""b"",1);; when calling mytree.GetEntry(i); only branches ""a"" and ""b"" will be read. WARNING!!; If your Tree has been created in split mode with a parent branch ""parent"",; mytree.SetBranchStatus(""parent"",1);; will not activate the sub-branches of ""parent"". You should do:; mytree.SetBranchStatus(""parent*"",1);. An alternative is to call directly; brancha.GetEntry(i); branchb.GetEntry(i);. IMPORTANT NOTE. By default, GetEntry reuses the space allocated by the previous object; for each branch. You can force the previous object to be automatically; deleted if you call mybranch.SetAutoDelete(kTRUE) (default is kFALSE).; Example:; Consider the example in $ROOTSYS/test/Event.h; The top level branch in the tree T is declared with:; Event *event = 0; //event must be null or point to a valid object; //it must be initialized; T.SetBranchAddress(""event"",&event);; When reading the Tree, one can choose one of these 3 options:. OPTION 1. for (Long64_t i=0;i<nentries;i++) {; T.GetEntry(i);; // the object event has been filled at this point; }; The default (recommended). At the first entry an object of the; class Event will be created and pointed by event.; At the following entries, event will be overwritten by the new data.; All internal members that are TObject* are automatically deleted.; It is important that these members be in a valid state when GetEntry; is called. Pointers must be correctly initialized.; However these internal members wi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTree.html:88078,allocate,allocated,88078,root/html528/TTree.html,https://root.cern,https://root.cern/root/html528/TTree.html,2,['allocate'],['allocated']
Energy Efficiency,": ␛[0;36mdataset/weights/TMVAClassification_FDA_GA.weights.xml␛[0m; : Creating standalone class: ␛[0;36mdataset/weights/TMVAClassification_FDA_GA.class.C␛[0m; Factory : Training finished; : ; Factory : Train method: MLPBNN for Classification; : ; : ; : ␛[1m================================================================␛[0m; : ␛[1mH e l p f o r M V A m e t h o d [ MLPBNN ] :␛[0m; : ; : ␛[1m--- Short description:␛[0m; : ; : The MLP artificial neural network (ANN) is a traditional feed-; : forward multilayer perceptron implementation. The MLP has a user-; : defined hidden layer architecture, while the number of input (output); : nodes is determined by the input variables (output classes, i.e., ; : signal and one background). ; : ; : ␛[1m--- Performance optimisation:␛[0m; : ; : Neural networks are stable and performing for a large variety of ; : linear and non-linear classification problems. However, in contrast; : to (e.g.) boosted decision trees, the user is advised to reduce the ; : number of input variables that have only little discrimination power. ; : ; : In the tests we have carried out so far, the MLP and ROOT networks; : (TMlpANN, interfaced via TMVA) performed equally well, with however; : a clear speed advantage for the MLP. The Clermont-Ferrand neural ; : net (CFMlpANN) exhibited worse classification performance in these; : tests, which is partly due to the slow convergence of its training; : (at least 10k training cycles are required to achieve approximately; : competitive results).; : ; : ␛[1mOvertraining: ␛[0monly the TMlpANN performs an explicit separation of the; : full training sample into independent training and validation samples.; : We have found that in most high-energy physics applications the ; : available degrees of freedom (training events) are sufficient to ; : constrain the weights of the relatively simple architectures required; : to achieve good performance. Hence no overtraining should occur, and ; : the use of validation samples would o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAClassification_8C.html:42336,reduce,reduce,42336,doc/master/TMVAClassification_8C.html,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html,2,"['power', 'reduce']","['power', 'reduce']"
Energy Efficiency,":. Double_tPDK(Double_t a, Double_t b, Double_t c). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. Double_tfBeta[3]betas of decaying particle; TLorentzVectorfDecPro[18]kinematics of the generated particles ; Double_tfMass[18]masses of particles; Int_tfNtnumber of decay particles; Double_tfTeCmTmtotal energy in the C.M. minus the total mass; Double_tfWtMaxmaximum weigth . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Double_t PDK(Double_t a, Double_t b, Double_t c); the PDK function. TGenPhaseSpace(const TGenPhaseSpace& gen); copy constructor. Double_t Generate(); Generate a random final state.; The function returns the weigth of the current event.; The TLorentzVector of each decay product can be obtained using GetDecay(n). Note that Momentum, Energy units are Gev/C, GeV. TLorentzVector * GetDecay(Int_t n); return Lorentz vector corresponding to decay n. Bool_t SetDecay(TLorentzVector& P, Int_t nt, Double_t* mass, Option_t* opt = """"); input:; TLorentzVector &P: decay particle (Momentum, Energy units are Gev/C, GeV); Int_t nt: number of decay products; Double_t *mass: array of decay product masses; Option_t *opt: default -> constant cross section; ""Fermi"" -> Fermi energy dependece; return value:; kTRUE: the decay is permitted by kinematics; kFALSE: the decay is forbidden by kinematics. TGenPhaseSpace(); {}. virtual ~TGenPhaseSpace(); {}. Int_t GetNt() const; { return fNt;}. Double_t GetWtMax() const; { return fWtMax;}. » Last changed: root/physics:$Id: TGenPhaseSpace.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:08; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGenPhaseSpace.html:6935,energy,energy,6935,root/html528/TGenPhaseSpace.html,https://root.cern,https://root.cern/root/html528/TGenPhaseSpace.html,1,['energy'],['energy']
Energy Efficiency,":. File descriptors; Signal actions; Shared libraries; Inter-process communication tools (such as message queues, pipes, semaphores, or shared memory). 23.1.2 Thread Properties; A thread is the schedulable entity. It has only those properties that are required to ensure its independent flow of control. These include the following properties:. Stack; Scheduling properties (such as policy or priority); Set of pending and blocked signals; Some thread-specific data (TSD). An example of thread-specific data is the error indicator, errno. In multi-threaded systems, errno is no longer a global variable, but usually a subroutine returning a thread-specific errno value. Some other systems may provide other implementations of errno. With respect to ROOT, a thread specific data is for example the gPad pointer, which is treated in a different way, whether it is accessed from any thread or the main thread.; Threads within a process must not be considered as a group of processes (even though in Linux each thread receives an own process id, so that it can be scheduled by the kernel scheduler). All threads share the same address space. This means that two pointers having the same value in two threads refer to the same data. Also, if any thread changes one of the shared system resources, all threads within the process are affected. For example, if a thread closes a file, the file is closed for all threads.; 23.1.3 The Initial Thread; When a process is created, one thread is automatically created. This thread is called the initial thread or the main thread. The initial thread executes the main routine in multi-threaded programs.; Note: At the end of this chapter is a glossary of thread specific terms; 23.2 Implementation of Threads in ROOT; The TThread class has been developed to provide a platform independent interface to threads for ROOT.; 23.2.1 Installation; For the time being, it is still necessary to compile a threaded version of ROOT to enable some very special treatments of th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1102955,schedul,scheduled,1102955,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['schedul'],"['scheduled', 'scheduler']"
Energy Efficiency,":152; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::Classstatic TClass * Class(); TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Comparevirtual Int_t Compare(const TObject *obj) constCompare abstract method.Definition TObject.cxx:244; TSeqCollectionSequenceable collection abstract base class.Definition TSeqCollection.h:28; TSeqCollection::Changedvirtual void Changed()Definition TSeqCollection.h:34; TSeqCollection::QSortstatic void QSort(TObject **a, Int_t first, Int_t last)Sort array of TObject pointers using a quicksort algorithm.Definition TSeqCollection.cxx:70; TSeqCollection::fSortedBool_t fSortedDefinition TSeqCollection.h:31; TStorage::Allocstatic void * Alloc(size_t size)Allocate a block of memory, that later can be resized using TStorage::ReAlloc().Definition TStorage.cxx:152; TStorage::Deallocstatic void Dealloc(void *ptr)De-allocate block of memory, that was allocated via TStorage::Alloc().Definition TStorage.cxx:170; TStorage::ReAllocstatic void * ReAlloc(void *vp, size_t size, size_t oldsize)Reallocate (i.e.Definition TStorage.cxx:183; TString::Streamervirtual void Streamer(TBuffer &)Stream a string object.Definition TString.cxx:1412; bool; int; unsigned int; ROOT::Detail::HasBeenDeletedR__ALWAYS_INLINE bool HasBeenDeleted(const TObject *obj)Check if the TObject's memory has been deleted.Definition TObject.h:402; ROOT::gCoreMutexR__EXTERN TVirtualRWMutex * gCoreMutexDefinition TVirtualRWMutex.h:37; TMath::MaxShort_t Max(Short_t a, Short_t b)Returns the largest of a and b.Definition TMathBase.h:250; TMath::MinShort_t Min(Short_t a, Short_t b)Returns the smallest of a and b.Definition TMathBase.h:198; v@ vDefinition rootcling_impl.cxx:3699. corecontsrcTObjArray.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:09 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TObjArray_8cxx_source.html:42445,allocate,allocate,42445,doc/master/TObjArray_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TObjArray_8cxx_source.html,2,['allocate'],"['allocate', 'allocated']"
Energy Efficiency,":70; y2Option_t Option_t TPoint TPoint const char y2Definition TGWin32VirtualXProxy.cxx:70; y1Option_t Option_t TPoint TPoint const char y1Definition TGWin32VirtualXProxy.cxx:70; gPad#define gPadDefinition TVirtualPad.h:308; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; c2return c2Definition legend2.C:14; I#define I(x, y, z); v2@ v2Definition rootcling_impl.cxx:3702; v@ vDefinition rootcling_impl.cxx:3699. Definition at line 75 of file TPoints3DABC.cxx. ◆ DistancetoPrimitive(). Int_t TPoints3DABC::DistancetoPrimitive ; (; Int_t ; px, . Int_t ; py . ). overridepure virtual . Computes distance from point (px,py) to the object. ; This member function must be implemented for each graphics primitive. This default function returns a big number (999999). ; Reimplemented from TObject. ◆ GetLastPosition(). virtual Int_t TPoints3DABC::GetLastPosition ; (; ); const. pure virtual . ◆ GetN(). Int_t TPoints3DABC::GetN ; (; ); const. virtual . GetN() returns the number of allocated cells if any. ; GetN() > 0 shows how many cells can be available via GetP() method. GetN() == 0 then GetP() must return 0 as well ; Definition at line 119 of file TPoints3DABC.cxx. ◆ GetOption(). Option_t * TPoints3DABC::GetOption ; (; ); const. overridepure virtual . Reimplemented from TObject. ◆ GetP(). Float_t * TPoints3DABC::GetP ; (; ); const. virtual . GetP() returns the pointer to the float point array of points if available The number of the available cells can be found via GetN() method. ; GetN() > 0 shows how many cells ; Definition at line 131 of file TPoints3DABC.cxx. ◆ GetX(). virtual Float_t TPoints3DABC::GetX ; (; Int_t ; idx); const. pure virtual . ◆ GetXYZ() [1/2]. Float_t * TPoints3DABC::GetXYZ ; (; Float_t * ; xyz, . Int_t ; idx, . Int_t ; num = 1 . ); const. virtual . GetXYZ(Float_t *xyz,Int_t idx,Int_t num=1) fills the buffer supplied by the calling code with the points information. ; Input parameters:. Float_t *xyz : an external user supplied floating",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPoints3DABC.html:15404,allocate,allocated,15404,doc/master/classTPoints3DABC.html,https://root.cern,https://root.cern/doc/master/classTPoints3DABC.html,1,['allocate'],['allocated']
Energy Efficiency,"::DNN::ClassificationSettings::m_weightsstd::vector< double > m_weightsDefinition NeuralNet.h:998; TMVA::DNN::ClassificationSettings::m_fileNameNetConfigstd::string m_fileNameNetConfigDefinition NeuralNet.h:1011; TMVA::DNN::ClassificationSettings::m_targetsstd::vector< double > m_targetsDefinition NeuralNet.h:997; TMVA::DNN::ClassificationSettings::testSamplevoid testSample(double error, double output, double target, double weight)action to be done after the computation of a test sample (e.g.Definition NeuralNet.cxx:304; TMVA::DNN::ClassificationSettings::m_scaleToNumEventssize_t m_scaleToNumEventsDefinition NeuralNet.h:1006; TMVA::DNN::ClassificationSettings::startTestCyclevirtual void startTestCycle()action to be done when the test cycle is started (e.g.Definition NeuralNet.cxx:316; TMVA::DNN::ClassificationSettings::m_sumOfBkgWeightsdouble m_sumOfBkgWeightsDefinition NeuralNet.h:1005; TMVA::DNN::ClassificationSettings::setWeightSumsvoid setWeightSums(double sumOfSigWeights, double sumOfBkgWeights)set the weight sums to be scaled to (preparations for monitoring output)Definition NeuralNet.cxx:512; TMVA::DNN::ClassificationSettings::m_cutValuedouble m_cutValueDefinition NeuralNet.h:1008; TMVA::DNN::ClassificationSettings::m_outputstd::vector< double > m_outputDefinition NeuralNet.h:996; TMVA::DNN::LayerData::m_itInputBeginconst_iterator_type m_itInputBeginiterator to the first of the nodes in the input node vectorDefinition NeuralNet.h:639; TMVA::DNN::LayerData::m_deltasstd::vector< double > m_deltasstores the deltas for the DNN trainingDefinition NeuralNet.h:642; TMVA::DNN::LayerData::iterator_typecontainer_type::iterator iterator_typeDefinition NeuralNet.h:441; TMVA::DNN::LayerData::LayerDataLayerData(const_iterator_type itInputBegin, const_iterator_type itInputEnd, ModeOutputValues eModeOutput=ModeOutputValues::DIRECT)c'tor of LayerDataDefinition NeuralNet.cxx:81; TMVA::DNN::LayerData::container_typestd::vector< double > container_typeDefinition NeuralNet.h:439; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/NeuralNet_8cxx_source.html:23659,monitor,monitoring,23659,doc/master/NeuralNet_8cxx_source.html,https://root.cern,https://root.cern/doc/master/NeuralNet_8cxx_source.html,1,['monitor'],['monitoring']
Energy Efficiency,"::DNN::TCudaTensor< AFloat >::GetNrows ; (; ); const. inline . Definition at line 299 of file CudaTensor.h. ◆ GetShape(). template<typename AFloat > . const Shape_t & TMVA::DNN::TCudaTensor< AFloat >::GetShape ; (; ); const. inline . Definition at line 188 of file CudaTensor.h. ◆ GetSize(). template<typename AFloat > . size_t TMVA::DNN::TCudaTensor< AFloat >::GetSize ; (; ); const. inline . Definition at line 192 of file CudaTensor.h. ◆ GetStrides(). template<typename AFloat > . const Shape_t & TMVA::DNN::TCudaTensor< AFloat >::GetStrides ; (; ); const. inline . Definition at line 189 of file CudaTensor.h. ◆ GetWSize(). template<typename AFloat > . size_t TMVA::DNN::TCudaTensor< AFloat >::GetWSize ; (; ); const. inline . Definition at line 289 of file CudaTensor.h. ◆ InitializeCuda(). template<typename AFloat > . void TMVA::DNN::TCudaTensor< AFloat >::InitializeCuda. private . Initializes all shared devices resource and makes sure that a sufficient number of curand states are allocated on the device and initialized as well as that the one-vector for the summation over columns has the right size. ; Definition at line 366 of file CudaTensor.cu. ◆ InitializeCurandStates(). template<typename AFloat > . void TMVA::DNN::TCudaTensor< AFloat >::InitializeCurandStates. private . Definition at line 377 of file CudaTensor.cu. ◆ isEqual() [1/2]. template<typename AFloat > . bool TMVA::DNN::TCudaTensor< AFloat >::isEqual ; (; const AFloat * ; hostBufferOther, . size_t ; otherSize . ). inline . Definition at line 238 of file CudaTensor.h. ◆ isEqual() [2/2]. template<typename AFloat > . bool TMVA::DNN::TCudaTensor< AFloat >::isEqual ; (; TCudaTensor< AFloat > & ; other). inline . Definition at line 220 of file CudaTensor.h. ◆ operator TMatrixT(). template<typename AFloat > . TMVA::DNN::TCudaTensor< AFloat >::operator TMatrixT. Convert cuda matrix to Root TMatrix. ; Performs synchronous data transfer. ; Definition at line 175 of file CudaTensor.cu. ◆ operator()() [1/3]. template<typ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TCudaTensor.html:13969,allocate,allocated,13969,doc/master/classTMVA_1_1DNN_1_1TCudaTensor.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TCudaTensor.html,1,['allocate'],['allocated']
Energy Efficiency,"::EProperty) ;  ; char * operator[] (UInt_t idx) const;  Return the address of the value at index idx ;  . Protected Member Functions; void Expand (UInt_t nCurr, UInt_t left);  ; TGenCollectionProxy * InitializeEx (Bool_t silent) override;  Proxy initializer. ;  ; void ReadItems (int nElements, TBuffer &b);  ; void Shrink (UInt_t nCurr, UInt_t left, Bool_t force);  ; void WriteItems (int nElements, TBuffer &b);  ;  Protected Member Functions inherited from TGenCollectionProxy; void CheckFunctions () const;  Check existence of function pointers. ;  ; virtual void DeleteItem (Bool_t force, void *ptr) const;  Call to delete/destruct individual item. ;  ; TGenCollectionProxy * Initialize (Bool_t silent) const;  Proxy initializer. ;  . Private Member Functions; TEmulatedCollectionProxy & operator= (const TEmulatedCollectionProxy &);  . Friends; class TCollectionProxy;  . Additional Inherited Members;  Static Public Attributes inherited from TVirtualCollectionProxy; static const Int_t fgIteratorArenaSize = 16;  The size of a small buffer that can be allocated on the stack to store iterator-specific information. ;  ;  Protected Types inherited from TGenCollectionProxy; typedef void *(* ArrIterfunc_t) (void *from, size_t size);  ; typedef void *(* Collectfunc_t) (void *from, void *to);  ; typedef ROOT::Detail::TCollectionProxyInfo::Environ< char[64]> Env_t;  ; typedef ROOT::Detail::TCollectionProxyInfo::EnvironBase EnvironBase_t;  ; typedef void *(* Feedfunc_t) (void *from, void *to, size_t size);  ; typedef std::vector< EnvironBase_t * > Proxies_t;  ; typedef void(* Sizing_t) (void *obj, size_t size);  ; typedef std::vector< TStaging * > Staged_t;  Collection of pre-allocated staged array for associative containers. ;  ;  Protected Attributes inherited from TGenCollectionProxy; Method fClear;  Method cache for container accessors: clear container. ;  ; Collectfunc_t fCollect;  Method to collect objects from container. ;  ; ArrIterfunc_t fConstruct;  Container accessors: bl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEmulatedCollectionProxy.html:10477,allocate,allocated,10477,doc/master/classTEmulatedCollectionProxy.html,https://root.cern,https://root.cern/doc/master/classTEmulatedCollectionProxy.html,1,['allocate'],['allocated']
Energy Efficiency,"::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TDecompSVD::(anonymous)kWorkMax; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Int_tTDecompBase::fColLwbColumn lower bound of decomposed matrix; Double_tTDecompBase::fConditionmatrix condition number; Double_tTDecompBase::fDet1determinant mantissa; Double_tTDecompBase::fDet2determinant exponent for powers of 2; Int_tTDecompBase::fRowLwbRow lower bound of decomposed matrix; TVectorDfSigdiagonal of diagonal matrix; Double_tTDecompBase::fTolsqrt(epsilon); epsilon is smallest number number so that 1+epsilon > 1; TMatrixDfUorthogonal matrix; TMatrixDfVorthogonal matrix; static TDecompBase::EMatrixDecompStatTDecompBase::kCondition; static TDecompBase::EMatrixDecompStatTDecompBase::kDecomposed; static TDecompBase::EMatrixDecompStatTDecompBase::kDetermined; static TDecompBase::EMatrixDecompStatTDecompBase::kInit; static TDecompBase::EMatrixDecompStatTDecompBase::kMatrixSet; static TDecompBase::EMatrixDecompStatTDecompBase::kPatternSet; static TDecompBase::EMatrixDecompStatTDecompBase::kSingular; static TDecompBase::EMatrixDecompStatTDecompBase::kValuesSet; static TDecompBase::(anonymous)TDecompBase::kWorkMax. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TDecompSVD(Int_t nrows, Int_t ncols); Constructor for (nrows x ncols) matrix. TDecompSVD(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb); Constructor for ([row_lwb..row_upb] x [col_lwb..col_upb]) matrix. TDecompSVD(const TMatrixD& m, Double_t tol = 0.); Constructor for general matrix A . TDecompSVD(const TDecompSVD& another); Copy constructor. Bool_t Decompose(); SVD decomp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TDecompSVD.html:8557,power,powers,8557,root/html602/TDecompSVD.html,https://root.cern,https://root.cern/root/html602/TDecompSVD.html,2,['power'],['powers']
Energy Efficiency,"::HandleElementPaste(TEveElement* el); virtual Bool_tTObject::HandleTimer(TTimer* timer); Bool_tTEveElement::HasChild(TEveElement* el); Bool_tTEveElement::HasChildren() const; virtual ULong_tTNamed::Hash() const; virtual Bool_tTEveElement::HasMainColor() const; virtual Bool_tTEveElement::HasMainTrans() const; Bool_tTEveElement::HasParents() const; virtual Bool_tTEveProjectable::HasProjecteds() const; virtual voidTEveElement::HighlightElement(Bool_t state); voidTEveElement::IncDenyDestroy(); virtual voidTEveElement::IncImpliedHighlighted(); virtual voidTEveElement::IncImpliedSelected(); voidTEveElement::IncParentIgnoreCnt(); virtual voidTEveRefBackPtr::IncRefCount(TEveElement* re); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTEveElement::InitMainTrans(Bool_t can_edit = kTRUE); voidInitTrack(const TEveVectorD& v, Int_t charge); voidInitTrack(const TEveVectorF& v, Int_t charge); virtual voidTObject::Inspect() constMENU ; Bool_tIntersectPlane(const TEveVectorD& p, const TEveVectorD& point, const TEveVectorD& normal, TEveVectorD& itsect); voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; static Bool_tIsOutsideBounds(const TEveVectorD& point, Double_t maxRsqr, Double_t maxZ); Bool_tTEveElement::IsPickable() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; TEveElement*TEveElement::LastChild() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTEveElement::NameTitleChanged(); virtual Bool_tTObject::Notify(); Int_tTEveElement::NumChildren() const; Int_tTEveElement::NumParents() const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedF",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TEveTrackPropagator.html:10927,charge,charge,10927,root/html530/TEveTrackPropagator.html,https://root.cern,https://root.cern/root/html530/TEveTrackPropagator.html,5,['charge'],['charge']
Energy Efficiency,"::IntegratorMultiDim&). Data Members; private:. ROOT::Math::VirtualIntegratorMultiDim*fIntegratorpointer to multi-dimensional integrator base class. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; IntegratorMultiDim(ROOT::Math::IntegrationMultiDim::Type type = IntegrationMultiDim::kADAPTIVE, double absTol = 1.E-9, double relTol = 1E-6, unsigned int ncall = 100000); Generic constructor of multi dimensional Integrator. By default uses the Adaptive integration method. @param type integration type (adaptive, MC methods, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. IntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, ROOT::Math::IntegrationMultiDim::Type type = IntegrationMultiDim::kADAPTIVE, double absTol = 1.E-9, double relTol = 1E-6, unsigned int ncall = 100000); Generic Constructor of multi dimensional Integrator passing a function. By default uses the adaptive integration method. @param f integration function (multi-dim interface); @param type integration type (adaptive, MC methods, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param ncall number of function calls (apply only to MC integratioon methods). SetFunction(const ROOT::Math::IMultiGenFunction& f). IntegratorMultiDim(const Function & f, unsigned int dim, IntegrationMultiDim::Type type = IntegrationMultiDim::kADAPTIVE, double absTol = 1.E-9, double relTol = 1E-6, unsigned int ncall = 100000); Template Constructor of multi dimensional Integrator passing a generic function. By default uses the adaptive integration method. @param f integration function (generic function implementin operator()(const double *); @param dim function dimension; @param type integration type (adaptive, MC methods, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param ncall number of function calls (apply only to MC integratioon met",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__IntegratorMultiDim.html:2888,adapt,adaptive,2888,root/html526/ROOT__Math__IntegratorMultiDim.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__IntegratorMultiDim.html,1,['adapt'],['adaptive']
Energy Efficiency,"::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. UShort_tfDetIdCustom detector id.; Int_tfEvaLabelLabel of primary particle, ancestor of label.; Int_tfLabelLabel of particle that produced the hit.; UShort_tfSubdetIdCustom sub-detector id.; TEveVectorfVHit position. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEveMCTrack& operator=(const TEveHit& ); { *((TParticle*)this) = p; return *this; }. TEveHit(); Float_t charge; probably specific. {}. virtual ~TEveHit(); {}. » Last changed: root/eve:$Id: TEveVSDStructs.h 31517 2009-12-03 11:56:23Z matevz $ » Last generated: 2010-09-23 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEveHit.html:5395,charge,charge,5395,root/html528/TEveHit.html,https://root.cern,https://root.cern/root/html528/TEveHit.html,1,['charge'],['charge']
Energy Efficiency,"::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. UShort_tfDetIdCustom detector id.; Int_tfEvaLabelLabel of primary particle, ancestor of label.; Int_tfLabelLabel of particle that produced the hit.; UShort_tfSubdetIdCustom sub-detector id.; TEveVectorfVHit position. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEveMCTrack& operator=(const TEveHit& ); { *((TParticle*)this) = p; return *this; }. TEveHit(); Float_t charge; probably specific. {}. virtual ~TEveHit(); {}. » Last changed: root/eve:$Id: TEveVSDStructs.h 38721 2011-04-04 13:37:12Z matevz $ » Last generated: 2011-07-04 15:26; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TEveHit.html:5464,charge,charge,5464,root/html530/TEveHit.html,https://root.cern,https://root.cern/root/html530/TEveHit.html,1,['charge'],['charge']
Energy Efficiency,"::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. UShort_tfDetIdCustom detector id.; Int_tfEvaLabelLabel of primary particle, ancestor of label.; Int_tfLabelLabel of particle that produced the hit.; UShort_tfSubdetIdCustom sub-detector id.; TEveVectorfVHit position. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEveMCTrack& operator=(const TEveHit& ); { *((TParticle*)this) = p; return *this; }. TEveHit(); Float_t charge; probably specific. {}. virtual ~TEveHit(); {}. » Last changed: root/eve:$Id: TEveVSDStructs.h 38721 2011-04-04 13:37:12Z matevz $ » Last generated: 2011-11-03 20:12; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEveHit.html:5464,charge,charge,5464,root/html532/TEveHit.html,https://root.cern,https://root.cern/root/html532/TEveHit.html,1,['charge'],['charge']
Energy Efficiency,"::ShortType( fClassName, TClassEdit::kDropStlDefault );; 2729 TString othername = TClassEdit::ShortType( other.fClassName, TClassEdit::kDropStlDefault );; 2730 if (name != othername) {; 2731 TClass *cl = TClass::GetClass(name);; 2732 TClass *otherCl = TClass::GetClass(othername);; 2733 if (!CollectionMatch(cl,otherCl)) {; 2734 TClass *oldFixedClass = FixCollectionV5(fParent,cl,otherCl);; 2735 if (!oldFixedClass || !CollectionMatch(oldFixedClass,otherCl)) {; 2736 return kTRUE;; 2737 }; 2738 }; 2739 }; 2740 } else {; 2741 return kTRUE;; 2742 }; 2743 }; 2744 return fComment != other.fComment;; 2745 }; 2746 };; 2747}; 2748 ; 2749////////////////////////////////////////////////////////////////////////////////; 2750/// Emulated a call ShowMembers() on the obj of this class type, passing insp and parent.; 2751 ; 2752void TStreamerInfo::CallShowMembers(const void* obj, TMemberInspector &insp, Bool_t isTransient) const; 2753{; 2754 TIter next(fElements);; 2755 TStreamerElement* element = (TStreamerElement*) next();; 2756 ; 2757 TString elementName;; 2758 ; 2759 for (; element; element = (TStreamerElement*) next()) {; 2760 ; 2761 // Skip elements which have not been allocated memory.; 2762 if (element->GetOffset() == kMissing) {; 2763 continue;; 2764 }; 2765 ; 2766 char* eaddr = ((char*)obj) + element->GetOffset();; 2767 ; 2768 if (element->IsBase()) {; 2769 // Nothing to do this round.; 2770 } else if (element->IsaPointer()) {; 2771 elementName.Form(""*%s"",element->GetFullName());; 2772 insp.Inspect(fClass, insp.GetParent(), elementName.Data(), eaddr, isTransient);; 2773 } else {; 2774 insp.Inspect(fClass, insp.GetParent(), element->GetFullName(), eaddr, isTransient);; 2775 Int_t etype = element->GetType();; 2776 switch(etype) {; 2777 case kObject:; 2778 case kAny:; 2779 case kTObject:; 2780 case kTString:; 2781 case kTNamed:; 2782 case kSTL:; 2783 {; 2784 TClass *ecl = element->GetClassPointer();; 2785 if (ecl && (fClass!=ecl /* This happens 'artificially for stl container s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:110117,allocate,allocated,110117,doc/master/TStreamerInfo_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html,1,['allocate'],['allocated']
Energy Efficiency,"::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. TGLLightSet(const TGLLightSet&); TGLLightSet&operator=(const TGLLightSet&). Data Members; public:. enum ELight { kLightFront; kLightTop; kLightBottom; kLightLeft; kLightRight; kLightMask; kLightSpecular; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Float_tfFrontPower! power of the front lamp; UInt_tfLightState! light states (on/off) mask; Float_tfSidePower! power of the side lamps; Float_tfSpecularPower! power of specular lamp; Bool_tfUseSpecular!. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLLightSet(); Constructor. void ToggleLight(TGLLightSet::ELight light); Toggle light on/off. void SetLight(TGLLightSet::ELight light, Bool_t on); Set a light on/off. void StdSetupLights(const TGLBoundingBox& bbox, const TGLCamera& camera, Bool_t debug = kFALSE); Setup lights for current given bounding box and camera.; This is called by standard GL viewer.; Expects matrix-mode to be model-view. TGLLightSet(const TGLLightSet& ). TGLLightSet& operator=(const TGLLightSet& ). virtual ~TGLLightSet(); {}. UInt_t GetLightState(); { return fLightState; }. Bool_t GetUseSpecular() const; { return fUseSpecular; }. void SetUseSpecular(Bool_t s); { fUseSpecular = s; }. Float_t GetFrontPower() const; { return fFrontPower; }. Float_t GetSidePower() const; { return fSidePower; }. Float_t GetSpecularPower() cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGLLightSet.html:5657,power,power,5657,root/html528/TGLLightSet.html,https://root.cern,https://root.cern/root/html528/TGLLightSet.html,12,['power'],['power']
Energy Efficiency,"::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. ULong_tfBlackPixelValue of black pixel in colormap; Int_tfBlueDivBlue value divider; Int_tfBlueShiftBits to left shift blue; Float_tfCharacterUpXCharacter Up vector along X; Float_tfCharacterUpYCharacter Up vector along Y; unsigned longfColormapDefault colormap, 0 if b/w; Int_tfDepthNumber of color planes; Display*fDisplayPointer to display; TVirtualX::EDrawModeTVirtualX::fDrawModeDrawing mode; Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; Int_tfGreenDivGreen value divider; Int_tfGreenShiftBits to left shift green; Bool_tfHasTTFontsTrue when TrueType fonts are used; Bool_tfHasXftTrue when XftFonts are used; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; Color_tTAttMarker::fMarkerColorMarker color index; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; TStringTNamed::fNameobject identifier; Int_tfRedDivRed value divider, -1 if no TrueColor visual; Int_tfRedShiftBits to left shift red, -1 if no TrueColor visual; unsigned longfRootWinRoot window used as parent of all windows; Int_tfScreenNumberScreen number; Int_tfTextAlignText alignment (set in SetTextAlign); Short_tTAttText::fTextAlignText alignment; Int_tfTextAlignHText Alignment Horizontal; Int_tfTextAlignVText Alignment Vertical; Float_tTAttText::fTextAngleText angle; Color_tTAttText::fTextColorText color index; Font_tTAttText::fTextFontText font number; Float_tfTextMagnitudeText Magnitude; Float_tTAttText::fTextSizeText size; TStringTNamed::fTitleobject title; unsigned longfVisRootWinRoot window with fVisual to be used to create GC's and XImages; Visual*fVisualPointer to visual used by all windows; ULong_tfWhitePixelValue of white pixel in colormap. private:. TExMap*fColorsHash list of colors; unsigned longfCursors[19]List of cursors; Int_tfMaxNumberOfWindo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGX11.html:24362,green,green,24362,root/html534/TGX11.html,https://root.cern,https://root.cern/root/html534/TGX11.html,1,['green'],['green']
Energy Efficiency,"::batchSize ; (; ); const. inline . mini-batch size ; Definition at line 767 of file NeuralNet.h. ◆ clear(). void TMVA::DNN::Settings::clear ; (; std::string ; histoName). inline . for monitoring ; Definition at line 824 of file NeuralNet.h. ◆ computeResult(). virtual void TMVA::DNN::Settings::computeResult ; (; const Net & ; , . std::vector< double > & ;  . ). inlinevirtual . callback for monitoring and logging ; Definition at line 809 of file NeuralNet.h. ◆ convergenceCount(). size_t TMVA::DNN::Settings::convergenceCount ; (; ); const. inline . returns the current convergence count ; Definition at line 827 of file NeuralNet.h. ◆ convergenceSteps(). size_t TMVA::DNN::Settings::convergenceSteps ; (; ); const. inline . how many steps until training is deemed to have converged ; Definition at line 766 of file NeuralNet.h. ◆ create() [1/2]. void TMVA::DNN::Settings::create ; (; std::string ; histoName, . int ; bins, . double ; min, . double ; max . ). inline . for monitoring ; Definition at line 819 of file NeuralNet.h. ◆ create() [2/2]. void TMVA::DNN::Settings::create ; (; std::string ; histoName, . int ; bins, . double ; min, . double ; max, . int ; bins2, . double ; min2, . double ; max2 . ). inline . for monitoring ; Definition at line 820 of file NeuralNet.h. ◆ cycle(). virtual void TMVA::DNN::Settings::cycle ; (; double ; progress, . TString ; text . ). inlinevirtual . Parameters. textadvance on the progress bar; progressthe new value; texta label . Definition at line 799 of file NeuralNet.h. ◆ drawSample(). virtual void TMVA::DNN::Settings::drawSample ; (; const std::vector< double > & ; , . const std::vector< double > & ; , . const std::vector< double > & ; , . double ;  . ). inlinevirtual . callback for monitoring and logging ; Definition at line 807 of file NeuralNet.h. ◆ dropFractions(). const std::vector< double > & TMVA::DNN::Settings::dropFractions ; (; ); const. inline . Definition at line 762 of file NeuralNet.h. ◆ dropRepetitions(). size_t TMVA::DNN::S",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1Settings.html:6906,monitor,monitoring,6906,doc/master/classTMVA_1_1DNN_1_1Settings.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1Settings.html,1,['monitor'],['monitoring']
Energy Efficiency,"::createvoid create(std::string histoName, int bins, double min, double max, int bins2, double min2, double max2)for monitoringDefinition NeuralNet.h:820; TMVA::DNN::Settings::useMultithreadingbool useMultithreading() constis multithreading turned on?Definition NeuralNet.h:815; TMVA::DNN::Settings::regularizationEnumRegularization regularization() constsome regularization of the DNN is turned on?Definition NeuralNet.h:813; TMVA::DNN::Settings::convergenceCountsize_t convergenceCount() constreturns the current convergence countDefinition NeuralNet.h:827; TMVA::DNN::Settings::momentumdouble momentum() constget the momentum (e.g. for SGD)Definition NeuralNet.h:772; TMVA::DNN::Settings::count_Esize_t count_EDefinition NeuralNet.h:842; TMVA::DNN::Settings::m_timerTimer m_timertimer for monitoringDefinition NeuralNet.h:832; TMVA::DNN::Settings::testRepetitionssize_t testRepetitions() consthow often is the test data testedDefinition NeuralNet.h:768; TMVA::DNN::Settings::clearvoid clear(std::string histoName)for monitoringDefinition NeuralNet.h:824; TMVA::DNN::Settings::endTestCyclevirtual void endTestCycle()callback for monitoring and logggingDefinition NeuralNet.h:805; TMVA::DNN::Settings::fMinimizerTypeMinimizerType fMinimizerTypeDefinition NeuralNet.h:855; TMVA::DNN::Settings::addPointvoid addPoint(std::string histoName, double x, double y)for monitoringDefinition NeuralNet.h:822; TMVA::DNN::Settings::setMonitoringvoid setMonitoring(std::shared_ptr< Monitoring > ptrMonitoring)prepared for monitoringDefinition NeuralNet.h:764; TMVA::DNN::Settings::testIterationvirtual void testIteration()callback for monitoring and logggingDefinition NeuralNet.h:806; TMVA::DNN::Settings::m_convergenceStepssize_t m_convergenceStepsnumber of steps without improvement to consider the DNN to have convergedDefinition NeuralNet.h:837; TMVA::DNN::Settings::hasConvergedvirtual bool hasConverged(double testError)has this training converged already?Definition NeuralNet.cxx:485; TMVA::DNN::Settings:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/NeuralNet_8h_source.html:72485,monitor,monitoringDefinition,72485,doc/master/NeuralNet_8h_source.html,https://root.cern,https://root.cern/doc/master/NeuralNet_8h_source.html,1,['monitor'],['monitoringDefinition']
Energy Efficiency,"::fNNumber of array elements; TStringTNamed::fNameobject identifier; TDataSet*TDataSet::fParentpointer to mother of the directory; Long_tTTable::fSizeSize of the one element (row) of the table; Char_t*TTable::fTableArray of (fN*fSize) longs; TStringTNamed::fTitleobject title; static TDataSet*TDataSet::fgMainSetpointer the main dataset;. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGenericTable(const TTableDescriptor& dsc, const char* name). Create TGenericTable by TTableDescriptor pointer:. dsc - Pointer to the table descriptor; name - The name of this object. TGenericTable(const TTableDescriptor& dsc, Int_t n). Create TGenericTable by TTableDescriptor pointer:. dsc - Pointer to the table descriptor; name - ""TGenericTable""; n - The initial number of allocated rows. TGenericTable(const TTableDescriptor& dsc, const char* name, Int_t n). Create TGenericTable by TTableDescriptor pointer:. dsc - Pointer to the table descriptor; name - The name of this object; n - The initial number of allocated rows. TGenericTable(const char* structName, const char* name). Create TGenericTable by C structure name provided:. dsc - Pointer to the table descriptor; name - The name of this object; n - The initial number of allocated rows. TGenericTable(const char* structName, Int_t n). Create TGenericTable by C structure name provided:. dsc - Pointer to the table descriptor; name - The name of this object; n - The initial number of allocated rows. TGenericTable(const char* structName, const char* name, Int_t n). Create TGenericTable by C structure name provided:. dsc - Pointer to the table descriptor; name - The name of this object; n - The initial number of allocated rows. ~TGenericTable(); destructor. TTableDescriptor * GetDescriptorPointer() const; { return fColDescriptors;}. void SetDescriptorPointer(TTableDescriptor* list); { fColDescriptors = list;}. void SetGenericType(); { TTable::SetType(GetDescriptorPointer()->GetName()); }. TGenericTab",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGenericTable.html:16898,allocate,allocated,16898,root/html528/TGenericTable.html,https://root.cern,https://root.cern/root/html528/TGenericTable.html,4,['allocate'],['allocated']
Energy Efficiency,"::fNNumber of array elements; TStringTNamed::fNameobject identifier; TDataSet*TDataSet::fParentpointer to mother of the directory; Long_tTTable::fSizeSize of the one element (row) of the table; Char_t*TTable::fTableArray of (fN*fSize) longs; TStringTNamed::fTitleobject title; static TDataSet*TDataSet::fgMainSetpointer the main dataset;. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGenericTable(const TTableDescriptor& dsc, const char* name). Create TGenericTable by TTableDescriptor pointer:. dsc - Pointer to the table descriptor; name - The name of this object. TGenericTable(const TTableDescriptor& dsc, Int_t n). Create TGenericTable by TTableDescriptor pointer:. dsc - Pointer to the table descriptor; name - ""TGenericTable""; n - The initial number of allocated rows. TGenericTable(const TTableDescriptor& dsc, const char* name, Int_t n). Create TGenericTable by TTableDescriptor pointer:. dsc - Pointer to the table descriptor; name - The name of this object; n - The initial number of allocated rows. TGenericTable(const char* structName, const char* name). Create TGenericTable by C structure name provided:. dsc - Pointer to the table descriptor; name - The name of this object; n - The initial number of allocated rows. TGenericTable(const char* structName, Int_t n). Create TGenericTable by C structure name provided:. dsc - Pointer to the table descriptor; name - The name of this object; n - The initial number of allocated rows. TGenericTable(const char* structName, const char* name, Int_t n). Create TGenericTable by C structure name provided:. dsc - Pointer to the table descriptor; name - The name of this object; n - The initial number of allocated rows. ~TGenericTable(); destructor. TTableDescriptor * GetDescriptorPointer() const; { return fColDescriptors;}. void SetDescriptorPointer(TTableDescriptor* list); { fColDescriptors = list;}. void SetGenericType(); { TTable::SetType(GetDescriptorPointer()->GetName()); }. iterator & ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGenericTable.html:18394,allocate,allocated,18394,root/html602/TGenericTable.html,https://root.cern,https://root.cern/root/html602/TGenericTable.html,2,['allocate'],['allocated']
Energy Efficiency,"::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooNDKeysPdf(const char* name, const char* title, const RooArgList& varList, RooDataSet& data, TString options = ""a"", Double_t rho = 1, Double_t nSigma = 3, Bool_t rotate = kTRUE); Construct N-dimensional kernel estimation p.d.f. in observables 'varList'; from dataset 'data'. Options can be. 'a' = Use adaptive kernels (width varies with local event density); 'm' = Mirror data points over observable boundaries. Improves modeling; behavior at edges for distributions that are not close to zero; at edge; 'd' = Debug flag; 'v' = Verbose flag. The parameter rho (default = 1) provides an overall scale factor that can; be applied to the bandwith calculated for each kernel. The nSigma parameter; determines the size of the box that is used to search for contributing kernels; around a given point in observable space. The nSigma parameters is used; in case of non-adaptive bandwidths and for the 1st non-adaptive pass for; the calculation of adaptive keys p.d.f.s. The optional weight arguments allows to specify an observable or function; expression in observables that specifies the weight of each event. RooNDKeysPdf(const char* name, const char* title, RooAbsReal& x, RooDataSet& data, RooNDKeysPdf::Mirror mirror = NoMirror, Double_t rho = 1, Double_t nSigma = 3, Bool_t rotate = kTRUE); Backward compatibility constructor for (1-dim) RooKeysPdf. If you are a new user,; please use the first constructor form. RooNDKeysPdf(const char* name, const char* title, RooAbsReal& x, RooAbsReal& y, RooDataSet& data, TString options = ""a"", Double_t rho = 1.0, Double_t nSigma = 3, Bool_t rotate = kTRUE); Backward compatibility constructor for Roo2DKeysPdf. If you are a new user,; please use the first constructor form. RooNDKeysPdf(const RooNDKeysPdf& other, const char* name = 0); Constructor. ~RooNDKeysPdf(). createPdf(Bool_t firstCall = kTRUE) const; evaluation order of constructor. se",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooNDKeysPdf.html:44104,adapt,adaptive,44104,root/html528/RooNDKeysPdf.html,https://root.cern,https://root.cern/root/html528/RooNDKeysPdf.html,9,['adapt'],['adaptive']
Energy Efficiency,"::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooNDKeysPdf(const char* name, const char* title, const RooArgList& varList, RooDataSet& data, TString options = ""a"", Double_t rho = 1, Double_t nSigma = 3, Bool_t rotate = kTRUE); Construct N-dimensional kernel estimation p.d.f. in observables 'varList'; from dataset 'data'. Options can be. 'a' = Use adaptive kernels (width varies with local event density); 'm' = Mirror data points over observable boundaries. Improves modeling; behavior at edges for distributions that are not close to zero; at edge; 'd' = Debug flag; 'v' = Verbose flag. The parameter rho (default = 1) provides an overall scale factor that can; be applied to the bandwith calculated for each kernel. The nSigma parameter; determines the size of the box that is used to search for contributing kernels; around a given point in observable space. The nSigma parameters is used; in case of non-adaptive bandwidths and for the 1st non-adaptive pass for; the calculation of adaptive keys p.d.f.s. The optional weight arguments allows to specify an observable or function; expression in observables that specifies the weight of each event. RooNDKeysPdf(const char* name, const char* title, const RooArgList& varList, RooDataSet& data, const TVectorD& rho, TString options = ""a"", Double_t nSigma = 3, Bool_t rotate = kTRUE); Constructor. RooNDKeysPdf(const char* name, const char* title, RooAbsReal& x, RooDataSet& data, RooNDKeysPdf::Mirror mirror = NoMirror, Double_t rho = 1, Double_t nSigma = 3, Bool_t rotate = kTRUE); Backward compatibility constructor for (1-dim) RooKeysPdf. If you are a new user,; please use the first constructor form. RooNDKeysPdf(const char* name, const char* title, RooAbsReal& x, RooAbsReal& y, RooDataSet& data, TString options = ""a"", Double_t rho = 1., Double_t nSigma = 3, Bool_t rotate = kTRUE); Backward compatibility constructor for Roo2DKeysPdf. If you are a new user,; please use the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooNDKeysPdf.html:49556,adapt,adaptive,49556,root/html602/RooNDKeysPdf.html,https://root.cern,https://root.cern/root/html602/RooNDKeysPdf.html,6,['adapt'],['adaptive']
Energy Efficiency,"::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooNDKeysPdf(const char* name, const char* title, const RooArgList& varList, RooDataSet& data, TString options = ""a"", Double_t rho = 1, Double_t nSigma = 3, Bool_t rotate = kTRUE); Construct N-dimensional kernel estimation p.d.f. in observables 'varList'; from dataset 'data'. Options can be. 'a' = Use adaptive kernels (width varies with local event density); 'm' = Mirror data points over observable boundaries. Improves modeling; behavior at edges for distributions that are not close to zero; at edge; 'd' = Debug flag; 'v' = Verbose flag. The parameter rho (default = 1) provides an overall scale factor that can; be applied to the bandwith calculated for each kernel. The nSigma parameter; determines the size of the box that is used to search for contributing kernels; around a given point in observable space. The nSigma parameters is used; in case of non-adaptive bandwidths and for the 1st non-adaptive pass for; the calculation of adaptive keys p.d.f.s. The optional weight arguments allows to specify an observable or function; expression in observables that specifies the weight of each event. RooNDKeysPdf(const char* name, const char* title, const RooArgList& varList, RooDataSet& data, const TVectorD& rho, TString options = ""a"", Double_t nSigma = 3, Bool_t rotate = kTRUE); Constructor. RooNDKeysPdf(const char* name, const char* title, RooAbsReal& x, RooDataSet& data, RooNDKeysPdf::Mirror mirror = NoMirror, Double_t rho = 1, Double_t nSigma = 3, Bool_t rotate = kTRUE); Backward compatibility constructor for (1-dim) RooKeysPdf. If you are a new user,; please use the first constructor form. RooNDKeysPdf(const char* name, const char* title, RooAbsReal& x, RooAbsReal& y, RooDataSet& data, TString options = ""a"", Double_t rho = 1.0, Double_t nSigma = 3, Bool_t rotate = kTRUE); Backward compatibility constructor for Roo2DKeysPdf. If you are a new user,; please use th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooNDKeysPdf.html:47646,adapt,adaptive,47646,root/html534/RooNDKeysPdf.html,https://root.cern,https://root.cern/root/html534/RooNDKeysPdf.html,3,['adapt'],['adaptive']
Energy Efficiency,"::kInitHashTableCapacity, Int_t rehash = 0); Create a THashTable object. Capacity is the initial hashtable capacity; (i.e. number of slots), by default kInitHashTableCapacity = 17, and; rehashlevel is the value at which a rehash will be triggered. I.e. when; the average size of the linked lists at a slot becomes longer than; rehashlevel then the hashtable will be resized and refilled to reduce; the collision rate to about 1. The higher the collision rate, i.e. the; longer the linked lists, the longer lookup will take. If rehashlevel=0; the table will NOT automatically be rehashed. Use Rehash() for manual; rehashing. ~THashTable(); Delete a hashtable. Objects are not deleted unless the THashTable is the; owner (set via SetOwner()). void Add(TObject* obj); Add object to the hash table. Its position in the table will be; determined by the value returned by its Hash() function. void AddAll(const TCollection* col); Add all objects from collection col to this collection.; Implemented for more efficient rehashing. void Clear(Option_t* option = """"); Remove all objects from the table. Does not delete the objects; unless the THashTable is the owner (set via SetOwner()). Int_t Collisions(const char* name) const; Returns the number of collisions for an object with a certain name; (i.e. number of objects in same slot in the hash table, i.e. length; of linked list). Int_t Collisions(TObject* obj) const; Returns the number of collisions for an object (i.e. number of objects; in same slot in the hash table, i.e. length of linked list). void Delete(Option_t* option = """"); Remove all objects from the table AND delete all heap based objects. TObject * FindObject(const char* name) const; Find object using its name. Uses the hash value returned by the; TString::Hash() after converting name to a TString. TObject * FindObject(const TObject* obj) const; Find object using its hash value (returned by its Hash() member). TList * GetListForObject(const char* name) const; Return the TList corres",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/THashTable.html:9321,efficient,efficient,9321,root/html528/THashTable.html,https://root.cern,https://root.cern/root/html528/THashTable.html,3,['efficient'],['efficient']
Energy Efficiency,"::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidResetStep(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidSetCharge(Int_t charge); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetField(Double_t bx, Double_t by, Double_t bz, Bool_t is_normalized = kTRUE); voidSetHelixStep(Double_t hstep); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); voidSetXYcurvature(Double_t curvature); virtual voidShowMembers(TMemberInspector& insp) const; voidStep(Double_t step); Double_tStepToPlane(Double_t* point, Double_t* norm); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TGeoHelix(); TGeoHelix(Double_t curvature, Double_t step, Int_t charge = 1); voidUpdateHelix(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoHelix.html:6180,charge,charge,6180,root/html602/TGeoHelix.html,https://root.cern,https://root.cern/root/html602/TGeoHelix.html,2,['charge'],['charge']
Energy Efficiency,"::operator[] ; (; size_t ; idx). inline . Definition at line 164 of file xRooNode.h. ◆ parentPdf(). std::shared_ptr< xRooNode > xRooNode::parentPdf ; (; ); const. like a parent but only for use by getObject ; Definition at line 6936 of file xRooNode.cxx. ◆ pars(). xRooNode xRooNode::pars ; (; ); const. List of parameters (non-observables) of this node. ; Definition at line 5318 of file xRooNode.cxx. ◆ poi(). xRooNode xRooNode::poi ; (; ); const. List of parameters of interest: parameters marked as ""of interest"" These parameters have the ""poi"" attribute. ; Definition at line 5372 of file xRooNode.cxx. ◆ pp(). xRooNode xRooNode::pp ; (; ); const. List of prespecified parameters: non-floatable parameters. ; Definition at line 5407 of file xRooNode.cxx. ◆ Print(). void xRooNode::Print ; (; Option_t * ; option = """"); const. overridevirtual . Print TNamed name and title. ; Reimplemented from TNamed.; Definition at line 2336 of file xRooNode.cxx. ◆ reduced(). xRooNode xRooNode::reduced ; (; const std::string & ; range = """", . bool ; invert = false . ); const. Definition at line 6946 of file xRooNode.cxx. ◆ Remove(). xRooNode xRooNode::Remove ; (; const xRooNode & ; child). Definition at line 1345 of file xRooNode.cxx. ◆ Replace(). xRooNode xRooNode::Replace ; (; const xRooNode & ; node). Definition at line 3059 of file xRooNode.cxx. ◆ robs(). xRooNode xRooNode::robs ; (; ); const. List of regular observables of this node. ; Definition at line 5302 of file xRooNode.cxx. ◆ SaveAs(). void xRooNode::SaveAs ; (; const char * ; filename = """", . Option_t * ; option = """" . ); const. overridevirtual . Save this object in the file specified by filename. . if ""filename"" contains "".root"" the object is saved in filename as root binary file.; if ""filename"" contains "".xml"" the object is saved in filename as a xml ascii file.; if ""filename"" contains "".cc"" the object is saved in filename as C code independant from ROOT. The code is generated via SavePrimitive(). Specific code should be imp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1XRooFit_1_1xRooNode.html:41377,reduce,reduced,41377,doc/master/classROOT_1_1Experimental_1_1XRooFit_1_1xRooNode.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1XRooFit_1_1xRooNode.html,1,['reduce'],['reduced']
Energy Efficiency,":; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLLogicalShape. class TGLLogicalShape. Abstract logical shape - a GL 'drawable' - base for all shapes -; faceset sphere etc. Logical shapes are a unique piece of geometry,; described in it's local frame - e.g if we have three spheres in :; Sphere A - Radius r1, center v1; Sphere B - Radius r2, center v2; Sphere C - Radius r1, center v3. Spheres A and C can share a common logical sphere of radius r1 - and; place them with two physicals with translations of v1 & v2. Sphere B; requires a different logical (radius r2), placed with physical with; translation v2. Physical shapes know about and can share logicals. Logicals do not; about (aside from reference counting) physicals or share them. This sharing of logical shapes greatly reduces memory consumption and; scene (re)build times in typical detector geometries which have many; repeated objects placements. TGLLogicalShapes have reference counting, performed by the client; physical shapes which are using it. Display list information is also stored here, possibly per LOD; level. Most classes do not support LOD (only sphere and tube) and; therefore reasonable defaults are encoded in the following virtual; functions:. * ELODAxes SupportedLODAxes() { return kLODAxesNone; }; * Int_t DLCacheSize() { return 1; }; * UInt_t DLOffset(lod); // Transform lod into DL offset.; * Short_t QuantizeShapeLOD(); // Quantize lod. Classes that have per-LOD display-lists than override these functions.; 'UShort_t fDLValid' is used as a bit-field determining validity of; each quantized LOD-level; hopefully one will not have more than 16; LOD levels per class.; See also: TGLPhysicalShape::CalculateShapeLOD() where LOD is calculated. See base/src/TVirtualViewer3D for description of common external 3D; viewer architecture and how e",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGLLogicalShape.html:985,reduce,reduces,985,root/html532/TGLLogicalShape.html,https://root.cern,https://root.cern/root/html532/TGLLogicalShape.html,8,"['consumption', 'reduce']","['consumption', 'reduces']"
Energy Efficiency,":; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLLogicalShape. class TGLLogicalShape. Abstract logical shape - a GL 'drawable' - base for all shapes -; faceset sphere etc. Logical shapes are a unique piece of geometry,; described in it's local frame - e.g if we have three spheres in :; Sphere A - Radius r1, center v1; Sphere B - Radius r2, center v2; Sphere C - Radius r1, center v3. Spheres A and C can share a common logical sphere of radius r1 - and; place them with two physicals with translations of v1 & v2. Sphere B; requires a different logical (radius r2), placed with physical with; translation v2. Physical shapes know about and can share logicals. Logicals do not; about (aside from reference counting) physicals or share them. This sharing of logical shapes greatly reduces memory consumption and; scene (re)build times in typical detector geometries which have many; repeated objects placements. TGLLogicalShapes have reference counting, performed by the client; physical shapes which are using it. Display list information is also stored here, possibly per LOD; level. Most classes does not support LOD (only sphere and tube) and; therefore reasonable defaults are encoded in the following virtual; functions:. * ELODAxes SupportedLODAxes() { return kLODAxesNone; }; * Int_t DLCacheSize() { return 1; }; * UInt_t DLOffset(lod); // Transform lod into DL offset.; * Short_t QuantizeShapeLOD(); // Quantize lod. Classes that have per-LOD display-lists than override these functions.; 'UShort_t fDLValid' is used as a bit-field determining validity of; each quantized LOD-level; hopefully one will not have more than 16; LOD levels per class.; See also: TGLPhysicalShape::CalculateShapeLOD() where LOD is calculated. See base/src/TVirtualViewer3D for description of common external 3D; viewer architecture and how",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGLLogicalShape.html:985,reduce,reduces,985,root/html528/TGLLogicalShape.html,https://root.cern,https://root.cern/root/html528/TGLLogicalShape.html,4,"['consumption', 'reduce']","['consumption', 'reduces']"
Energy Efficiency,":; a,b: One-dimensional arrays of length na, nb, respectively.; The elements of a and b must be given in ascending order.; option is a character string to specify options; ""D"" Put out a line of ""Debug"" printout; ""M"" Return the Maximum Kolmogorov distance instead of prob. Output:; The returned value prob is a calculated confidence level which gives a; statistical test for compatibility of a and b.; Values of prob close to zero are taken as indicating a small probability; of compatibility. For two point sets drawn randomly from the same parent; distribution, the value of prob should be uniformly distributed between; zero and one.; in case of error the function return -1; If the 2 sets have a different number of points, the minimum of; the two sets is used. Method:; The Kolmogorov test is used. The test statistic is the maximum deviation; between the two integrated distribution functions, multiplied by the; normalizing factor (rdmax*sqrt(na*nb/(na+nb)). Code adapted by Rene Brun from CERNLIB routine TKOLMO (Fred James); (W.T. Eadie, D. Drijard, F.E. James, M. Roos and B. Sadoulet,; Statistical Methods in Experimental Physics, (North-Holland,; Amsterdam 1971) 269-271). Method Improvement by Jason A Detwiler (JADetwiler@lbl.gov). The nuts-and-bolts of the TMath::KolmogorovTest() algorithm is a for-loop; over the two sorted arrays a and b representing empirical distribution; functions. The for-loop handles 3 cases: when the next points to be; evaluated satisfy a>b, a<b, or a=b:. for (Int_t i=0;i<na+nb;i++) {; if (a[ia-1] < b[ib-1]) {; rdiff -= sa;; ia++;; if (ia > na) {ok = kTRUE; break;}; } else if (a[ia-1] > b[ib-1]) {; rdiff += sb;; ib++;; if (ib > nb) {ok = kTRUE; break;}; } else {; rdiff += sb - sa;; ia++;; ib++;; if (ia > na) {ok = kTRUE; break;}; if (ib > nb) {ok = kTRUE; break;}; }; rdmax = TMath::Max(rdmax,TMath::Abs(rdiff));; }. For the last case, a=b, the algorithm advances each array by one index in an; attempt to move through the equality. However, this is in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMath.html:18508,adapt,adapted,18508,root/html528/TMath.html,https://root.cern,https://root.cern/root/html528/TMath.html,6,['adapt'],['adapted']
Energy Efficiency,":AMultB ; (; const TMatrixT< Element > & ; a, . const TMatrixTSparse< Element > & ; b, . Int_t ; constr = 0 . ). inlineprotected . Definition at line 54 of file TMatrixTSparse.h. ◆ AMultB() [2/3]. template<class Element > . void TMatrixTSparse< Element >::AMultB ; (; const TMatrixTSparse< Element > & ; a, . const TMatrixT< Element > & ; b, . Int_t ; constr = 0 . ). inlineprotected . Definition at line 51 of file TMatrixTSparse.h. ◆ AMultB() [3/3]. template<class Element > . void TMatrixTSparse< Element >::AMultB ; (; const TMatrixTSparse< Element > & ; a, . const TMatrixTSparse< Element > & ; b, . Int_t ; constr = 0 . ). inlineprotected . Definition at line 48 of file TMatrixTSparse.h. ◆ AMultBt() [1/3]. template<class Element > . void TMatrixTSparse< Element >::AMultBt ; (; const TMatrixT< Element > & ; a, . const TMatrixTSparse< Element > & ; b, . Int_t ; constr = 0 . ). protected . General matrix multiplication. ; Replace this matrix with C such that C = A * B'. Note, matrix C is allocated for constr=1. ; Definition at line 753 of file TMatrixTSparse.cxx. ◆ AMultBt() [2/3]. template<class Element > . void TMatrixTSparse< Element >::AMultBt ; (; const TMatrixTSparse< Element > & ; a, . const TMatrixT< Element > & ; b, . Int_t ; constr = 0 . ). protected . General matrix multiplication. ; Replace this matrix with C such that C = A * B'. Note, matrix C is allocated for constr=1. ; Definition at line 662 of file TMatrixTSparse.cxx. ◆ AMultBt() [3/3]. template<class Element > . void TMatrixTSparse< Element >::AMultBt ; (; const TMatrixTSparse< Element > & ; a, . const TMatrixTSparse< Element > & ; b, . Int_t ; constr = 0 . ). inlineprotected . Definition at line 57 of file TMatrixTSparse.h. ◆ APlusB() [1/3]. template<class Element > . void TMatrixTSparse< Element >::APlusB ; (; const TMatrixT< Element > & ; a, . const TMatrixTSparse< Element > & ; b, . Int_t ; constr = 0 . ). inlineprotected . Definition at line 67 of file TMatrixTSparse.h. ◆ APlusB() [2/3]. template<",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMatrixTSparse.html:35734,allocate,allocated,35734,doc/master/classTMatrixTSparse.html,https://root.cern,https://root.cern/doc/master/classTMatrixTSparse.html,1,['allocate'],['allocated']
Energy Efficiency,":ECompoundSelectionColorBitsTEveElement::kCSCBApplyMainTransparencyToAllChildren; static TEveElement::ECompoundSelectionColorBitsTEveElement::kCSCBApplyMainTransparencyToMatchingChildren; static TEveElement::ECompoundSelectionColorBitsTEveElement::kCSCBImplySelectAllChildren; static TEveElement::ECompoundSelectionColorBitsTEveElement::kCSCBTakeAnyParentAsMaster; static TEveElement::EDestructTEveElement::kNone; static TEveElement::EDestructTEveElement::kStandard. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEveJetCone(const Text_t* n = ""TEveJetCone"", const Text_t* t = """"); Constructor. void ComputeBBox(); Compute bounding-box of the data. TClass* ProjectedClass(const TEveProjection* p) const; Virtual from TEveProjectable, returns TEveJetConeProjected class. Int_t AddCone(Float_t eta, Float_t phi, Float_t cone_r, Float_t length = 0); Add jet cone.; parameters are :; * (eta,phi) : of the center/leading particle; * cone_r : cone radius in eta-phi space; * length : length of the cone; * if cylinder is set and length is adapted to cylinder.; - if length is given, it will be used as scalar factor; * if cylinder is not set, length is used as length of the cone; Return 0 on sucess. Int_t AddEllipticCone(Float_t eta, Float_t phi, Float_t reta, Float_t rphi, Float_t length = 0); Add jet cone.; parameters are :; * (eta,phi) : of the center/leading particle; * (reta, rphi) : radius of cone in eta-phi space; * length : length of the cone; * if cylinder is set and length is adapted to cylinder.; - if length is given, it will be used as scalar factor; * if cylinder is not set, length is used as length of the cone; Returns 0 on sucess. TEveVector CalcEtaPhiVec(Float_t eta, Float_t phi) const; Fill TEveVector with eta and phi, magnitude 1. TEveVector CalcBaseVec(Float_t eta, Float_t phi) const; Returns point on the base of the cone with given eta and phi. TEveVector CalcBaseVec(Float_t alpha) const; Returns point on the base of the cone w",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEveJetCone.html:24356,adapt,adapted,24356,root/html602/TEveJetCone.html,https://root.cern,https://root.cern/root/html602/TEveJetCone.html,2,['adapt'],['adapted']
Energy Efficiency,":GetSinkInternal::RPageSink & GetSink()Definition RNTupleWriter.hxx:77; ROOT::Experimental::RNTupleWriter::GetMetricsconst Detail::RNTupleMetrics & GetMetrics() constDefinition RNTupleWriter.hxx:138; ROOT::Experimental::RNTupleWriter::GetLastCommittedClusterGroupNTupleSize_t GetLastCommittedClusterGroup() constReturn the entry number that was last committed in a cluster group.Definition RNTupleWriter.hxx:133; ROOT::Experimental::RNTupleWriter::fZipTasksstd::unique_ptr< Internal::RPageStorage::RTaskScheduler > fZipTasksThe page sink's parallel page compression scheduler if IMT is on.Definition RNTupleWriter.hxx:68; ROOT::Experimental::RNTupleWriter::FillNoFlushvoid FillNoFlush(REntry &entry, RNTupleFillStatus &status)Fill an entry into this ntuple, but don't commit the cluster.Definition RNTupleWriter.hxx:112; ROOT::Experimental::RNTupleWriter::GetModelconst RNTupleModel & GetModel() constDefinition RNTupleWriter.hxx:140; ROOT::Experimental::RNTupleWriter::FlushColumnsvoid FlushColumns()Flush column data, preparing for CommitCluster or to reduce memory usage.Definition RNTupleWriter.hxx:115; ROOT::Experimental::RNTupleWriter::Fillstd::size_t Fill()The simplest user interface if the default entry that comes with the ntuple model is used.Definition RNTupleWriter.hxx:105; ROOT::Experimental::RNTupleWriter::GetLastFlushedNTupleSize_t GetLastFlushed() constReturn the entry number that was last flushed in a cluster.Definition RNTupleWriter.hxx:129; ROOT::Experimental::RNTupleWriter::CreateEntrystd::unique_ptr< REntry > CreateEntry()Definition RNTupleWriter.hxx:126; ROOT::Experimental::RNTupleWriter::Createstatic std::unique_ptr< RNTupleWriter > Create(std::unique_ptr< RNTupleModel > model, std::unique_ptr< Internal::RPageSink > sink, const RNTupleWriteOptions &options)Create a writer, potentially wrapping the sink in a RPageSinkBuf.Definition RNTupleWriter.cxx:58; ROOT::Experimental::RNTupleWriter::GetUpdatableModelRNTupleModel & GetUpdatableModel()Definition RNTupleWriter",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RNTupleWriter_8hxx_source.html:12506,reduce,reduce,12506,doc/master/RNTupleWriter_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RNTupleWriter_8hxx_source.html,1,['reduce'],['reduce']
Energy Efficiency,":Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidResetStep(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidSetCharge(Int_t charge); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetField(Double_t bx, Double_t by, Double_t bz, Bool_t is_normalized = kTRUE); voidSetHelixStep(Double_t hstep); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); voidSetXYcurvature(Double_t curvature); virtual voidShowMembers(TMemberInspector& insp) const; voidStep(Double_t step); Double_tStepToPlane(Double_t* point, Double_t* norm); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TGeoHelix(); TGeoHelix(Double_t curvature, Double_t step, Int_t charge = 1); voidUpdateHelix(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoHelix.html:5365,charge,charge,5365,root/html602/TGeoHelix.html,https://root.cern,https://root.cern/root/html602/TGeoHelix.html,2,['charge'],['charge']
Energy Efficiency,":PDF::fHistAvgEvtPerBin. private . avg event per source hist bin ; Definition at line 180 of file PDF.h. ◆ fHistDefinedNBins. Int_t TMVA::PDF::fHistDefinedNBins. private . source hist bin num set by user ; Definition at line 181 of file PDF.h. ◆ fHistOriginal. TH1* TMVA::PDF::fHistOriginal. private . the input histogram ; Definition at line 176 of file PDF.h. ◆ fIGetVal. TF1* TMVA::PDF::fIGetVal. private . integration interface ; Definition at line 178 of file PDF.h. ◆ fInterpolateString. TString TMVA::PDF::fInterpolateString. private . Definition at line 186 of file PDF.h. ◆ fInterpolMethod. TMVA::PDF::EInterpolateMethod TMVA::PDF::fInterpolMethod. private . interpolation method ; Definition at line 172 of file PDF.h. ◆ fKDEborder. KDEKernel::EKernelBorder TMVA::PDF::fKDEborder. private . The method to take care about ""border"" effects (string) ; Definition at line 190 of file PDF.h. ◆ fKDEiter. KDEKernel::EKernelIter TMVA::PDF::fKDEiter. private . Number of iterations (adaptive or not) ; Definition at line 189 of file PDF.h. ◆ fKDEiterString. TString TMVA::PDF::fKDEiterString. private . Definition at line 184 of file PDF.h. ◆ fKDEtype. KDEKernel::EKernelType TMVA::PDF::fKDEtype. private . Kernel type to use for KDE. ; Definition at line 188 of file PDF.h. ◆ fKDEtypeString. TString TMVA::PDF::fKDEtypeString. private . strings used to read definitions ; Definition at line 183 of file PDF.h. ◆ fLogger. MsgLogger* TMVA::PDF::fLogger. mutableprivate . ! message logger ; Definition at line 199 of file PDF.h. ◆ fMaxNsmooth. Int_t TMVA::PDF::fMaxNsmooth. private . Max number of smoothing iterations. ; Definition at line 169 of file PDF.h. ◆ fMinNsmooth. Int_t TMVA::PDF::fMinNsmooth. private . Min number of smoothing iterations. ; Definition at line 168 of file PDF.h. ◆ fNormalize. Bool_t TMVA::PDF::fNormalize. private . normalize histogram (false for cumulative distribution used in GaussTranform) ; Definition at line 196 of file PDF.h. ◆ fNsmooth. Int_t TMVA::PDF::fNsmooth.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1PDF.html:29966,adapt,adaptive,29966,doc/master/classTMVA_1_1PDF.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1PDF.html,1,['adapt'],['adaptive']
Energy Efficiency,":RooNonCPEigenDecay ; (; const RooNonCPEigenDecay & ; other, . const char * ; name = nullptr . ). Copy constructor. ; Definition at line 177 of file RooNonCPEigenDecay.cxx. Member Function Documentation. ◆ Class(). static TClass * RooNonCPEigenDecay::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooNonCPEigenDecay::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooNonCPEigenDecay::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 119 of file RooNonCPEigenDecay.h. ◆ clone(). TObject * RooNonCPEigenDecay::clone ; (; const char * ; newname); const. inlineoverridevirtual . Implements RooAbsArg.; Definition at line 80 of file RooNonCPEigenDecay.h. ◆ coefAnalyticalIntegral(). double RooNonCPEigenDecay::coefAnalyticalIntegral ; (; Int_t ; coef, . Int_t ; code, . const char * ; rangeName = nullptr . ); const. overridevirtual . correct for the right/wrong charge... ; Reimplemented from RooAbsAnaConvPdf.; Definition at line 279 of file RooNonCPEigenDecay.cxx. ◆ coefficient(). double RooNonCPEigenDecay::coefficient ; (; Int_t ; basisIndex); const. overridevirtual . B0 : _tag == -1; B0bar : _tag == +1; rho+ : _rhoQ == +1; rho- : _rhoQ == -1; the charge correction factor ""_correctQ"" serves to implement misidentified charges . Implements RooAbsAnaConvPdf.; Definition at line 209 of file RooNonCPEigenDecay.cxx. ◆ DeclFileName(). static const char * RooNonCPEigenDecay::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 119 of file RooNonCPEigenDecay.h. ◆ generateEvent(). void RooNonCPEigenDecay::generateEvent ; (; Int_t ; code). overridevirtual . Interface for generation of an event using the algorithm corresponding to the specified code. ; The meaning of each code is defined by the getGenerator() implementation. The default implementation does nothing. ; Reimplemented f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooNonCPEigenDecay.html:81108,charge,charge,81108,doc/master/classRooNonCPEigenDecay.html,https://root.cern,https://root.cern/doc/master/classRooNonCPEigenDecay.html,1,['charge'],['charge']
Energy Efficiency,":Settings::minimizerTypeMinimizerType minimizerType() constwhich minimizer shall be used (e.g. SGD)Definition NeuralNet.h:774; TMVA::DNN::Settings::m_dropOutstd::vector< double > m_dropOutDefinition NeuralNet.h:850; TMVA::DNN::Settings::m_minProgressdouble m_minProgresscurrent limits for the progress barDefinition NeuralNet.h:833; TMVA::DNN::Settings::cyclevirtual void cycle(double progress, TString text)Definition NeuralNet.h:799; TMVA::DNN::Settings::setProgressLimitsvirtual void setProgressLimits(double minProgress=0, double maxProgress=100)Definition NeuralNet.h:790; TMVA::DNN::Settings::m_maxProgressdouble m_maxProgresscurrent limits for the progress barDefinition NeuralNet.h:834; TMVA::DNN::Settings::endTrainCyclevirtual void endTrainCycle(double)callback for monitoring and loggingDefinition NeuralNet.h:788; TMVA::DNN::Settings::count_dEsize_t count_dEDefinition NeuralNet.h:843; TMVA::DNN::Settings::drawSamplevirtual void drawSample(const std::vector< double > &, const std::vector< double > &, const std::vector< double > &, double)callback for monitoring and loggingDefinition NeuralNet.h:807; TMVA::DNN::Settings::learningRatedouble learningRate() constget the learning rateDefinition NeuralNet.h:771; TMVA::DNN::Settings::m_dropRepetitionsdouble m_dropRepetitionsDefinition NeuralNet.h:849; TMVA::DNN::Settings::dropFractionsconst std::vector< double > & dropFractions() constDefinition NeuralNet.h:762; TMVA::DNN::Settings::addPointvoid addPoint(std::string histoName, double x)for monitoringDefinition NeuralNet.h:821; TMVA::DNN::Settings::~Settingsvirtual ~Settings()d'torDefinition NeuralNet.cxx:261; TMVA::DNN::Settings::m_convergenceCountsize_t m_convergenceCountDefinition NeuralNet.h:857; TMVA::DNN::Settings::m_regularizationEnumRegularization m_regularizationDefinition NeuralNet.h:847; TMVA::DNN::Settings::repetitionsint repetitions() consthow many steps have to be gone until the batch is changedDefinition NeuralNet.h:773; TMVA::DNN::Settings::m_minErrordouble m",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/NeuralNet_8h_source.html:74522,monitor,monitoring,74522,doc/master/NeuralNet_8h_source.html,https://root.cern,https://root.cern/doc/master/NeuralNet_8h_source.html,1,['monitor'],['monitoring']
Energy Efficiency,":ShapeDistancetoPrimitive(Int_t numPoints, Int_t px, Int_t py). private:. voidDumpPoints(int npoints, float* pointbuff) const; voidDumpPolygons(int npolygons, int* polybuff, int buffsize) const; voidDumpSegments(int nsegments, int* segbuff) const. Data Members; public:. enum EXYChecked { kUncheckedXY; kMalformedXY; kConvexCCW; kConvexCW; kConcaveCCW; kConcaveCW; };; enum EZChecked { kUncheckedZ; kMalformedZ; kConvexIncZ; kConvexDecZ; kConcaveIncZ; kConcaveDecZ; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TMaterial*TShape::fMaterialPointer to material; TStringTNamed::fNameobject identifier; Int_tTShape::fNumberShape number; Int_tfNxynumber of x-y points in the cross section; Int_tfNxyAllocnumber of x-y points allocated; Int_tfNznumber of z planes; Int_tfNzAllocnumber of z planes allocated; TXTRU::EXYCheckedfPolygonShapeCCW vs. CW, convex vs. concave; Float_t*fScale[fNzAlloc] array of scale factors (for each z); Bool_tfSplitConcave; TStringTNamed::fTitleobject title; Int_tTShape::fVisibilityVisibility flag; Float_t*fX0[fNzAlloc] array of x offsets (for each z); Float_t*fXvtx[fNxyAlloc] array of x positions; Float_t*fY0[fNzAlloc] array of y offsets (for each z); Float_t*fYvtx[fNxyAlloc] array of y positions; Float_t*fZ[fNzAlloc] array of z planes; TXTRU::EZCheckedfZOrderingincreasing or decreasing. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TXTRU(); TXTRU shape - default constructor. TXTRU(const char* name, const char* title, const char* material, Int_t nyx, Int_t nz); TXTRU shape - normal constructor",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TXTRU.html:10416,allocate,allocated,10416,root/html528/TXTRU.html,https://root.cern,https://root.cern/root/html528/TXTRU.html,8,['allocate'],['allocated']
Energy Efficiency,":TCudaMatrix< AFloat >::GetNcols ; (; ); const. inline . Definition at line 160 of file CudaMatrix.h. ◆ GetNDim(). template<typename AFloat > . static size_t TMVA::DNN::TCudaMatrix< AFloat >::GetNDim ; (; ). inlinestatic . Definition at line 158 of file CudaMatrix.h. ◆ GetNoElements(). template<typename AFloat > . size_t TMVA::DNN::TCudaMatrix< AFloat >::GetNoElements ; (; ); const. inline . Definition at line 161 of file CudaMatrix.h. ◆ GetNrows(). template<typename AFloat > . size_t TMVA::DNN::TCudaMatrix< AFloat >::GetNrows ; (; ); const. inline . Definition at line 159 of file CudaMatrix.h. ◆ GetOnes(). template<typename AFloat > . static AFloat * TMVA::DNN::TCudaMatrix< AFloat >::GetOnes ; (; ). inlinestatic . Definition at line 125 of file CudaMatrix.h. ◆ InitializeCuda(). template<typename AFloat > . void TMVA::DNN::TCudaMatrix< AFloat >::InitializeCuda. inlineprivate . Initializes all shared devices resource and makes sure that a sufficient number of curand states are allocated on the device and initialized as well as that the one-vector for the summation over columns has the right size. ; Definition at line 103 of file CudaMatrix.cu. ◆ InitializeCurandStates(). template<typename AFloat > . void TMVA::DNN::TCudaMatrix< AFloat >::InitializeCurandStates. private . Definition at line 140 of file CudaMatrix.cu. ◆ operator TMatrixT(). template<typename AFloat > . TMVA::DNN::TCudaMatrix< AFloat >::operator TMatrixT. Convert cuda matrix to Root TMatrix. ; Performs synchronous data transfer. ; Definition at line 150 of file CudaMatrix.cu. ◆ operator()(). template<typename AFloat > . TCudaDeviceReference< AFloat > TMVA::DNN::TCudaMatrix< AFloat >::operator() ; (; size_t ; i, . size_t ; j . ); const. Access to elements of device matrices provided through TCudaDeviceReference class. ; Note that access is synchronous end enforces device synchronization on all streams. Only used for testing. ; Definition at line 310 of file CudaMatrix.h. ◆ operator=() [1/2]. template<type",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TCudaMatrix.html:8117,allocate,allocated,8117,doc/master/classTMVA_1_1DNN_1_1TCudaMatrix.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TCudaMatrix.html,1,['allocate'],['allocated']
Energy Efficiency,":VecOps::SmallVectorBase; size_t capacity () const noexcept;  ; bool empty () const;  ; void set_size (size_t N);  Set the array size to N, which the current array must have enough capacity for. ;  ; size_t size () const;  . Protected Member Functions;  SmallVectorTemplateBase (size_t Size);  ; void grow (size_t MinSize=0);  Grow the allocated memory (without initializing new elements), doubling the size of the allocated memory. ;  ;  Protected Member Functions inherited from ROOT::Internal::VecOps::SmallVectorTemplateCommon< T >;  SmallVectorTemplateCommon (size_t Size);  ; void grow_pod (size_t MinSize, size_t TSize);  ; bool isSmall () const;  Return true if this is a smallvector which has not had dynamic memory allocated for it. ;  ; void resetToSmall ();  Put this vector in a state of being small. ;  ;  Protected Member Functions inherited from ROOT::Internal::VecOps::SmallVectorBase;  SmallVectorBase ()=delete;  ;  SmallVectorBase (void *FirstEl, size_t TotalCapacity);  ; void grow_pod (void *FirstEl, size_t MinSize, size_t TSize);  This is an implementation of the grow() method which only works on POD-like data types and is out of line to reduce code duplication. ;  ; bool Owns () const;  If false, the RVec is in ""memory adoption"" mode, i.e. it is acting as a view on a memory buffer it does not own. ;  . Static Protected Member Functions; static void destroy_range (T *S, T *E);  ; template<typename It1 , typename It2 > ; static void uninitialized_copy (It1 I, It1 E, It2 Dest);  Copy the range [I, E) onto the uninitialized memory starting with ""Dest"", constructing elements as needed. ;  ; template<typename It1 , typename It2 > ; static void uninitialized_move (It1 I, It1 E, It2 Dest);  Move the range [I, E) into the uninitialized memory starting with ""Dest"", constructing elements as needed. ;  ;  Static Protected Member Functions inherited from ROOT::Internal::VecOps::SmallVectorBase; static void report_at_maximum_capacity ();  Report that this vector is alread",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Internal_1_1VecOps_1_1SmallVectorTemplateBase.html:3596,reduce,reduce,3596,doc/master/classROOT_1_1Internal_1_1VecOps_1_1SmallVectorTemplateBase.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Internal_1_1VecOps_1_1SmallVectorTemplateBase.html,1,['reduce'],['reduce']
Energy Efficiency,":Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. static TGridJobStatus::EGridJobStatuskABORTED; static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TGridJobStatus::EGridJobStatuskDONE; static TGridJobStatus::EGridJobStatuskFAIL; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TGridJobStatus::EGridJobStatuskRUNNING; static TObject::(anonymous)TObject::kSingleKey; static TGridJobStatus::EGridJobStatuskUNKNOWN; static TGridJobStatus::EGridJobStatuskWAITING; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGridJobStatus(); { }. virtual ~TGridJobStatus(); { }. EGridJobStatus GetStatus() const; These functions reduces the possible job states to the subset given above; in EGridJobStatus, for detailed status information query the specific; implementation. » Author: Jan Fiete Grosse-Oetringhaus 06/10/2004 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/net:$Id$ » Last generated: 2015-06-02 13:43; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGridJobStatus.html:6647,reduce,reduces,6647,root/html602/TGridJobStatus.html,https://root.cern,https://root.cern/root/html602/TGridJobStatus.html,1,['reduce'],['reduces']
Energy Efficiency,":Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. static TGridJobStatus::EGridJobStatuskABORTED; static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TGridJobStatus::EGridJobStatuskDONE; static TGridJobStatus::EGridJobStatuskFAIL; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TGridJobStatus::EGridJobStatuskRUNNING; static TObject::(anonymous)TObject::kSingleKey; static TGridJobStatus::EGridJobStatuskUNKNOWN; static TGridJobStatus::EGridJobStatuskWAITING; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGridJobStatus(); { }. virtual ~TGridJobStatus(); { }. EGridJobStatus GetStatus() const; These functions reduces the possible job states to the subset given above; in EGridJobStatus, for detailed status information query the specific; implementation. » Author: Jan Fiete Grosse-Oetringhaus 06/10/2004 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/net:$Id$ » Last generated: 2015-06-02 16:06; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGridJobStatus.html:6647,reduce,reduces,6647,root/html604/TGridJobStatus.html,https://root.cern,https://root.cern/root/html604/TGridJobStatus.html,1,['reduce'],['reduces']
Energy Efficiency,":fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsData(); Destructor. Bool_t changeObservableName(const char* from, const char* to). void fill(). Int_t numEntries() const. void reset(). const RooArgSet* get(Int_t index) const. void cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0); Internal method -- Cache given set of functions with data. void resetCache(); Internal method -- Remove cached function values. void attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); Internal method -- Attach dataset copied with cache contents to copied instances of functions. void setArgStatus(const RooArgSet& set, Bool_t active). void setDirtyProp(Bool_t flag); Control propagation of dirty flags from observables in dataset. RooAbsData* reduce(const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); Create a reduced copy of this dataset. The caller takes ownership of the returned dataset. The following optional named arguments are accepted. SelectVars(const RooArgSet& vars) -- Only retain the listed observables in the output dataset; Cut(const char* expression) -- Only retain event surviving the given cut expression; Cut(const RooFormulaVar& expr) -- Only retain event surviving the given cut formula; CutRange(const char* name) -- Only retain events inside range with given name. Multiple CutRange; arguments may be given to select multiple ranges; EventRange(int lo, int hi) -- Only retain events with given sequential event numbers; Name(const char* name) -- Give specified name to output dataset; Title(const char* name) -- Give specified title to output dataset. RooAbsData* reduce(const char* cut); Create a subset of the data set by applying the given cu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsData.html:14698,reduce,reduce,14698,root/html528/RooAbsData.html,https://root.cern,https://root.cern/root/html528/RooAbsData.html,2,['reduce'],"['reduce', 'reduced']"
Energy Efficiency,":kWorkMax. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void TMatrixTSparse<Element> Allocate(Int_t nrows, Int_t ncols, Int_t row_lwb = 0, Int_t col_lwb = 0, Int_t init = 0, Int_t nr_nonzeros = 0); Allocate new matrix. Arguments are number of rows, columns, row lowerbound (0 default); and column lowerbound (0 default), 0 initialization flag and number of non-zero; elements (only relevant for sparse format). TMatrixTBase<Element> &TMatrixTSparse<Element> InsertRow(Int_t row, Int_t col, const float* v, Int_t n = -1); Insert in row rown, n elements of array v at column coln. void TMatrixTSparse<Element> ExtractRow(Int_t row, Int_t col, float* v, Int_t n = -1) const; Store in array v, n matrix elements of row rown starting at column coln. void TMatrixTSparse<Element> AMultBt(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMultBt(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMultBt(const TMatrixT<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixTSparse<Element> &a,const TMatrixT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMatrixTSparse_float_.html:18537,allocate,allocated,18537,root/html602/TMatrixTSparse_float_.html,https://root.cern,https://root.cern/root/html602/TMatrixTSparse_float_.html,2,['allocate'],['allocated']
Energy Efficiency,":kXor; static TObject::(anonymous)TObject::kZombie. protected:. ULong_tTGX11::fBlackPixelValue of black pixel in colormap; Int_tTGX11::fBlueDivBlue value divider; Int_tTGX11::fBlueShiftBits to left shift blue; Float_tTGX11::fCharacterUpXCharacter Up vector along X; Float_tTGX11::fCharacterUpYCharacter Up vector along Y; ColormapTGX11::fColormapDefault colormap, 0 if b/w; Int_tTGX11::fDepthNumber of color planes; void*TGX11::fDisplayPointer to display; TVirtualX::EDrawModeTVirtualX::fDrawModeDrawing mode; Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; Int_tTGX11::fGreenDivGreen value divider; Int_tTGX11::fGreenShiftBits to left shift green; Bool_tTGX11::fHasTTFontsTrue when TrueType fonts are used; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; Color_tTAttMarker::fMarkerColorMarker color index; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; TStringTNamed::fNameobject identifier; Int_tTGX11::fRedDivRed value divider, -1 if no TrueColor visual; Int_tTGX11::fRedShiftBits to left shift red, -1 if no TrueColor visual; DrawableTGX11::fRootWinRoot window used as parent of all windows; Int_tTGX11::fScreenNumberScreen number; Int_tTGX11::fTextAlignText alignment (set in SetTextAlign); Short_tTAttText::fTextAlignText alignment; Int_tTGX11::fTextAlignHText Alignment Horizontal; Int_tTGX11::fTextAlignVText Alignment Vertical; Float_tTAttText::fTextAngleText angle; Color_tTAttText::fTextColorText color index; Font_tTAttText::fTextFontText font number; Float_tTGX11::fTextMagnitudeText Magnitude; Float_tTAttText::fTextSizeText size; TStringTNamed::fTitleobject title; DrawableTGX11::fVisRootWinRoot window with fVisual to be used to create GC's and XImages; RVisual*TGX11::fVisualPointer to visual used by all windows; ULong_tTGX11::fWhitePixelValue of white pixel in colormap. private:. FT_VectorfAlignalignment vector; TXftFontHash*fXftFo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGX11TTF.html:25203,green,green,25203,root/html602/TGX11TTF.html,https://root.cern,https://root.cern/root/html602/TGX11TTF.html,1,['green'],['green']
Energy Efficiency,":none()) const; virtual voidTObject::Pop(); virtual voidRooAbsData::Print(Option_t* options = 0) const; virtual voidRooPrintable::printAddress(ostream& os) const; virtual voidRooPrintable::printArgs(ostream& os) const; virtual voidRooAbsData::printClassName(ostream& os) const; virtual voidRooPrintable::printExtras(ostream& os) const; virtual voidRooAbsData::printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; virtual voidRooAbsData::printName(ostream& os) const; virtual voidRooPrintable::printStream(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidRooAbsData::printTitle(ostream& os) const; virtual voidRooPrintable::printTree(ostream& os, TString indent = """") const; virtual voidRooPrintable::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); RooAbsData*RooAbsData::reduce(const char* cut); RooAbsData*RooAbsData::reduce(const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const char* cut = 0); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(RooCmdArg arg1, RooCmdArg arg2 = RooCmdArg(), RooCmdArg arg3 = RooCmdArg(), RooCmdArg arg4 = RooCmdArg(), RooCmdArg arg5 = RooCmdArg(), RooCmdArg arg6 = RooCmdArg(), RooCmdArg arg7 = RooCmdArg(), RooCmdArg arg8 = RooCmdArg()); virtual voidRooAbsData::reset(); voidTObject::ResetBit(UInt_t f); RooRealVar*RooAbsData::rmsVar(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidRooAbsData::setDirtyProp(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MEN",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooTreeData.html:8168,reduce,reduce,8168,root/html526/RooTreeData.html,https://root.cern,https://root.cern/root/html526/RooTreeData.html,2,['reduce'],['reduce']
Energy Efficiency,":none()) const; virtual voidTObject::Pop(); virtual voidRooAbsData::Print(Option_t* options = 0) const; virtual voidRooPrintable::printAddress(ostream& os) const; virtual voidRooPrintable::printArgs(ostream& os) const; virtual voidRooAbsData::printClassName(ostream& os) const; virtual voidRooPrintable::printExtras(ostream& os) const; virtual voidRooAbsData::printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; virtual voidRooAbsData::printName(ostream& os) const; virtual voidRooPrintable::printStream(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidRooAbsData::printTitle(ostream& os) const; virtual voidRooPrintable::printTree(ostream& os, TString indent = """") const; virtual voidRooPrintable::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); RooAbsData*RooAbsData::reduce(const char* cut); RooAbsData*RooAbsData::reduce(const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const char* cut = 0); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); static Bool_tRooAbsData::releaseVars(RooAbsData*); virtual voidRooAbsData::reset(); voidTObject::ResetBit(UInt_t f); RooRealVar*RooAbsData::rmsVar(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidRooAbsData::setDirtyPro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooTreeData.html:8487,reduce,reduce,8487,root/html530/RooTreeData.html,https://root.cern,https://root.cern/root/html530/RooTreeData.html,1,['reduce'],['reduce']
Energy Efficiency,":none()) const; virtual voidTObject::Pop(); virtual voidRooAbsData::Print(Option_t* options = 0) const; virtual voidRooPrintable::printAddress(ostream& os) const; virtual voidRooPrintable::printArgs(ostream& os) const; virtual voidRooAbsData::printClassName(ostream& os) const; virtual voidRooPrintable::printExtras(ostream& os) const; virtual voidRooAbsData::printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; virtual voidRooAbsData::printName(ostream& os) const; virtual voidRooPrintable::printStream(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidRooAbsData::printTitle(ostream& os) const; virtual voidRooPrintable::printTree(ostream& os, TString indent = """") const; virtual voidRooPrintable::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); RooAbsData*RooAbsData::reduce(const char* cut); RooAbsData*RooAbsData::reduce(const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const char* cut = 0); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); static Bool_tRooAbsData::releaseVars(RooAbsData*); virtual voidRooAbsData::reset(); voidTObject::ResetBit(UInt_t f); voidRooAbsData::resetBuffers(); RooRealVar*RooAbsData::rmsVar(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; RooTreeData(); RooTreeData(const RooTreeData&); RooTreeData(RooTreeData&&); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooTreeData.html:8724,reduce,reduce,8724,root/html602/RooTreeData.html,https://root.cern,https://root.cern/root/html602/RooTreeData.html,2,['reduce'],['reduce']
Energy Efficiency,":none()) const; virtual voidTObject::Pop(); virtual voidRooAbsData::Print(Option_t* options = 0) const; virtual voidRooPrintable::printAddress(ostream& os) const; virtual voidRooPrintable::printArgs(ostream& os) const; virtual voidRooAbsData::printClassName(ostream& os) const; virtual voidRooPrintable::printExtras(ostream& os) const; virtual voidRooAbsData::printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; virtual voidRooAbsData::printName(ostream& os) const; virtual voidRooPrintable::printStream(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidRooAbsData::printTitle(ostream& os) const; virtual voidRooPrintable::printTree(ostream& os, TString indent = """") const; virtual voidRooPrintable::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); RooAbsData*RooAbsData::reduce(const char* cut); RooAbsData*RooAbsData::reduce(const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const char* cut = 0); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); static Bool_tRooAbsData::releaseVars(RooAbsData*); virtual voidRooAbsData::reset(); voidTObject::ResetBit(UInt_t f); voidRooAbsData::resetBuffers(); RooRealVar*RooAbsData::rmsVar(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooTreeData.html:8583,reduce,reduce,8583,root/html532/RooTreeData.html,https://root.cern,https://root.cern/root/html532/RooTreeData.html,2,['reduce'],['reduce']
Energy Efficiency,":operator new[](size_t sz, void* vp); TMultiDimFit&operator=(const TMultiDimFit&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidPrint(Option_t* option = ""ps"") constMENU ; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidSetBinVarX(Int_t nbbinvarx); voidSetBinVarY(Int_t nbbinvary); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetMaxAngle(Double_t angle = 0); voidSetMaxFunctions(Int_t n); voidSetMaxPowers(const Int_t* powers); voidSetMaxStudy(Int_t n); voidSetMaxTerms(Int_t terms); voidSetMinAngle(Double_t angle = 1); voidSetMinRelativeError(Double_t error); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidSetPowerLimit(Double_t limit = 1e-3); virtual voidSetPowers(const Int_t* powers, Int_t terms); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector&); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMultiDimFit.html:20157,power,powers,20157,root/html534/TMultiDimFit.html,https://root.cern,https://root.cern/root/html534/TMultiDimFit.html,1,['power'],['powers']
Energy Efficiency,":printValue ; (; std::ostream & ; os); const. overridevirtual . Print the value of the fit result, i.e.g the status, minimized FCN, edm and covariance quality code. ; Reimplemented from RooPrintable.; Definition at line 1428 of file RooFitResult.cxx. ◆ randomizePars(). const RooArgList & RooFitResult::randomizePars ; (; ); const. Generate random perturbations of the final parameters using the covariance matrix. ; Return a list of floating parameter values that are perturbed from the final fit values by random amounts sampled from the covariance matrix.; The returned object is overwritten with each call and belongs to the RooFitResult. Uses the ""square root method"" to decompose the covariance matrix, which makes inverting it unnecessary. ; Definition at line 336 of file RooFitResult.cxx. ◆ reducedCovarianceMatrix(). TMatrixDSym RooFitResult::reducedCovarianceMatrix ; (; const RooArgList & ; params); const. Return a reduced covariance matrix (Note that Vred is a simple sub-matrix of V, row/columns are ordered to matched the convention given in input argument 'params'. ; Definition at line 1124 of file RooFitResult.cxx. ◆ setConstParList(). void RooFitResult::setConstParList ; (; const RooArgList & ; list). Fill the list of constant parameters. ; Definition at line 136 of file RooFitResult.cxx. ◆ setCovarianceMatrix(). void RooFitResult::setCovarianceMatrix ; (; TMatrixDSym & ; V). Store externally provided correlation matrix in this RooFitResult ;. ; Definition at line 1052 of file RooFitResult.cxx. ◆ setCovQual(). void RooFitResult::setCovQual ; (; Int_t ; val). inline . Definition at line 169 of file RooFitResult.h. ◆ setEDM(). void RooFitResult::setEDM ; (; double ; val). inline . Definition at line 167 of file RooFitResult.h. ◆ setFinalParList(). void RooFitResult::setFinalParList ; (; const RooArgList & ; list). Fill the list of final values of the floating parameters. ; Definition at line 170 of file RooFitResult.cxx. ◆ setInitParList(). void RooFitResult::setIn",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooFitResult.html:36171,reduce,reduced,36171,doc/master/classRooFitResult.html,https://root.cern,https://root.cern/doc/master/classRooFitResult.html,1,['reduce'],['reduced']
Energy Efficiency,":size_t ; nStop = std::numeric_limits<std::size_t>::max() . ). overridevirtual . Implements RooAbsDataStore.; Definition at line 280 of file RooCompositeDataStore.cxx. ◆ merge(). RooAbsDataStore * RooCompositeDataStore::merge ; (; const RooArgSet & ; allvars, . std::list< RooAbsDataStore * > ; dstoreList . ). overridevirtual . Implements RooAbsDataStore.; Definition at line 335 of file RooCompositeDataStore.cxx. ◆ numEntries(). Int_t RooCompositeDataStore::numEntries ; (; ); const. overridevirtual . Implements RooAbsDataStore.; Definition at line 359 of file RooCompositeDataStore.cxx. ◆ recalculateCache(). void RooCompositeDataStore::recalculateCache ; (; const RooArgSet * ; proj, . Int_t ; firstEvent, . Int_t ; lastEvent, . Int_t ; stepSize, . bool ; skipZeroWeights . ). overridevirtual . Forward recalculate request to all subsets. ; Reimplemented from RooAbsDataStore.; Definition at line 149 of file RooCompositeDataStore.cxx. ◆ reduce(). std::unique_ptr< RooAbsDataStore > RooCompositeDataStore::reduce ; (; RooStringView ; name, . RooStringView ; title, . const RooArgSet & ; vars, . const RooFormulaVar * ; cutVar, . const char * ; cutRange, . std::size_t ; nStart, . std::size_t ; nStop . ). overridevirtual . Implements RooAbsDataStore.; Definition at line 122 of file RooCompositeDataStore.cxx. ◆ reset(). void RooCompositeDataStore::reset ; (; ). overridevirtual . Implements RooAbsDataStore.; Definition at line 373 of file RooCompositeDataStore.cxx. ◆ resetBuffers(). void RooCompositeDataStore::resetBuffers ; (; ). overridevirtual . Implements RooAbsDataStore.; Definition at line 447 of file RooCompositeDataStore.cxx. ◆ resetCache(). void RooCompositeDataStore::resetCache ; (; ). overridevirtual . Implements RooAbsDataStore.; Definition at line 423 of file RooCompositeDataStore.cxx. ◆ setArgStatus(). void RooCompositeDataStore::setArgStatus ; (; const RooArgSet & ; set, . bool ; active . ). overridevirtual . Implements RooAbsDataStore.; Definition at line 395 of fil",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCompositeDataStore.html:28121,reduce,reduce,28121,doc/master/classRooCompositeDataStore.html,https://root.cern,https://root.cern/doc/master/classRooCompositeDataStore.html,1,['reduce'],['reduce']
Energy Efficiency,"; ""nested function"" are 100% his .; You can see him and his code in action at http://okmij.org/ftp; 2. Chris R. Birchenhall,; We adapted his idea of the implementation for the decomposition; classes instead of our messy installation of matrix inversion; His installation of matrix condition number, using an iterative; scheme using the Hage algorithm is worth looking at !; Chris has a nice writeup (matdoc.ps) on his matrix classes at; ftp://ftp.mcc.ac.uk/pub/matclass/; 3. Mark Fischler and Steven Haywood of CLHEP; They did the slave labor of spelling out all sub-determinants; for Cramer inversion of (4x4),(5x5) and (6x6) matrices; The stack storage for small matrices was also taken from them; 4. Roldan Pozo of TNT (http://math.nist.gov/tnt/); He converted the EISPACK routines for the eigen-vector analysis to; C++ . We started with his implementation; 5. Siegmund Brandt (http://siux00.physik.uni-siegen.de/~brandt/datan; We adapted his (very-well) documented SVD routines. How to efficiently use this package. 1. Never return complex objects (matrices or vectors); Danger: For example, when the following snippet:; TMatrixD foo(int n); {; TMatrixD foom(n,n); fill_in(foom); return foom;; }; TMatrixD m = foo(5);; runs, it constructs matrix foo:foom, copies it onto stack as a; return value and destroys foo:foom. Return value (a matrix); from foo() is then copied over to m (via a copy constructor),; and the return value is destroyed. So, the matrix constructor is; called 3 times and the destructor 2 times. For big matrices,; the cost of multiple constructing/copying/destroying of objects; may be very large. *Some* optimized compilers can cut down on 1; copying/destroying, but still it leaves at least two calls to; the constructor. Note, TMatrixDLazy (see below) can construct; TMatrixD m ""inplace"", with only a _single_ call to the; constructor. 2. Use ""two-address instructions""; ""void TMatrixD::operator += (const TMatrixD &B);""; as much as possible.; That is, to add two matrices,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMatrixTBase_double_.html:3315,efficient,efficiently,3315,root/html528/TMatrixTBase_double_.html,https://root.cern,https://root.cern/root/html528/TMatrixTBase_double_.html,12,['efficient'],['efficiently']
Energy Efficiency,"; (; const Double_t * ; x, . const Double_t * ; coeff = nullptr . ); const. virtual . Evaluate parameterization at point x. ; Optional argument coeff is a vector of coefficients for the parameterisation, fNCoefficients elements long. ; Definition at line 876 of file TMultiDimFit.cxx. ◆ EvalControl(). Double_t TMultiDimFit::EvalControl ; (; const Int_t * ; powers); const. protectedvirtual . PRIVATE METHOD: Calculate the control parameter from the passed powers. ; Definition at line 937 of file TMultiDimFit.cxx. ◆ EvalError(). Double_t TMultiDimFit::EvalError ; (; const Double_t * ; x, . const Double_t * ; coeff = nullptr . ); const. virtual . Evaluate parameterization error at point x. ; Optional argument coeff is a vector of coefficients for the parameterisation, fNCoefficients elements long. ; Definition at line 904 of file TMultiDimFit.cxx. ◆ EvalFactor(). Double_t TMultiDimFit::EvalFactor ; (; Int_t ; p, . Double_t ; x . ); const. protectedvirtual . PRIVATE METHOD: Evaluate function with power p at variable value x. ; Definition at line 952 of file TMultiDimFit.cxx. ◆ FindParameterization(). void TMultiDimFit::FindParameterization ; (; Option_t * ; option = """"). virtual . Find the parameterization. ; Options: None so far; For detailed description of what this entails, please refer to the class description ; Definition at line 994 of file TMultiDimFit.cxx. ◆ Fit(). void TMultiDimFit::Fit ; (; Option_t * ; option = """"). virtual . Try to fit the found parameterisation to the test sample. ; Options M use Minuit to improve coefficients; Also, refer to class description ; Definition at line 1013 of file TMultiDimFit.cxx. ◆ GetChi2(). Double_t TMultiDimFit::GetChi2 ; (; ); const. inline . Definition at line 140 of file TMultiDimFit.h. ◆ GetCoefficients(). const TVectorD * TMultiDimFit::GetCoefficients ; (; ); const. inline . Definition at line 142 of file TMultiDimFit.h. ◆ GetCoefficientsRMS(). const TVectorD * TMultiDimFit::GetCoefficientsRMS ; (; ); const. inline . De",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMultiDimFit.html:43335,power,power,43335,doc/master/classTMultiDimFit.html,https://root.cern,https://root.cern/doc/master/classTMultiDimFit.html,1,['power'],['power']
Energy Efficiency,"; (; const char * ; keyname); const. Returns the number of collisions for a key with a certain name (i.e. ; number of objects in same slot in the hash table, i.e. length of linked list). ; Definition at line 116 of file TMap.cxx. ◆ Collisions() [2/2]. Int_t TMap::Collisions ; (; TObject * ; key); const. Returns the number of collisions for a key (i.e. ; number of objects in same slot in the hash table, i.e. length of linked list). ; Definition at line 125 of file TMap.cxx. ◆ DeclFileName(). static const char * TMap::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 90 of file TMap.h. ◆ Delete(). void TMap::Delete ; (; Option_t * ; option = """"). overridevirtual . Remove all (key,value) pairs from the map AND delete the keys when they are allocated on the heap. ; Implements TCollection.; Definition at line 134 of file TMap.cxx. ◆ DeleteAll(). void TMap::DeleteAll ; (; ). Remove all (key,value) pairs from the map AND delete the keys AND values when they are allocated on the heap. ; Definition at line 168 of file TMap.cxx. ◆ DeleteEntry(). Bool_t TMap::DeleteEntry ; (; TObject * ; key). Remove (key,value) pair with key from the map. ; Returns true if the key was found and removed, false otherwise. The key and value objects are deleted if map is the owner of keys and values respectively. ; Definition at line 190 of file TMap.cxx. ◆ DeleteKeys(). void TMap::DeleteKeys ; (; ). inline . Definition at line 68 of file TMap.h. ◆ DeleteValues(). void TMap::DeleteValues ; (; ). Remove all (key,value) pairs from the map AND delete the values when they are allocated on the heap. ; Definition at line 151 of file TMap.cxx. ◆ FindObject() [1/2]. TObject * TMap::FindObject ; (; const char * ; keyname); const. overridevirtual . Check if a (key,value) pair exists with keyname as name of the key. ; Returns a TPair* (need to downcast from TObject). Use Key() and Value() to get the pointers to the key and value, respectively. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMap.html:20193,allocate,allocated,20193,doc/master/classTMap.html,https://root.cern,https://root.cern/doc/master/classTMap.html,1,['allocate'],['allocated']
Energy Efficiency,"; ). overridevirtual . Start the SVG page. ; This function initialize the pad conversion coefficients and output the <svg> directive which is close later in the the function Close. ; Implements TVirtualPS.; Definition at line 1564 of file TSVG.cxx. ◆ Off(). void TSVG::Off ; (; ). Deactivate an already open SVG file. ; Definition at line 203 of file TSVG.cxx. ◆ On(). void TSVG::On ; (; ). Activate an already open SVG file. ; Definition at line 187 of file TSVG.cxx. ◆ Open(). void TSVG::Open ; (; const char * ; filename, . Int_t ; type = -111 . ). overridevirtual . Open a SVG file. ; Implements TVirtualPS.; Definition at line 113 of file TSVG.cxx. ◆ Range(). void TSVG::Range ; (; Float_t ; xrange, . Float_t ; yrange . ). Set the range for the paper in centimetres. ; Definition at line 1596 of file TSVG.cxx. ◆ SetColor() [1/2]. void TSVG::SetColor ; (; Float_t ; r, . Float_t ; g, . Float_t ; b . ). overridevirtual . Set color with its R G B components. . r: % of red in [0,1] –g: % of green in [0,1]; b: % of blue in [0,1] . Implements TVirtualPS.; Definition at line 1733 of file TSVG.cxx. ◆ SetColor() [2/2]. void TSVG::SetColor ; (; Int_t ; color = 1). Set RGB (without alpha channel) color with its color index. ; Definition at line 1715 of file TSVG.cxx. ◆ SetColorAlpha(). void TSVG::SetColorAlpha ; (; Int_t ; color = 1). Set RGBa color with its color index. ; Definition at line 1699 of file TSVG.cxx. ◆ SetFillColor(). void TSVG::SetFillColor ; (; Color_t ; cindex = 1). overridevirtual . Set color index for fill areas. ; Reimplemented from TAttFill.; Definition at line 1606 of file TSVG.cxx. ◆ SetLineCap(). void TSVG::SetLineCap ; (; Int_t ; linecap = 0). Set the value of the global parameter TSVG::fgLineCap. ; This parameter determines the appearance of line caps in a SVG output. It takes one argument which may be:; 0 (butt caps); 1 (round caps); 2 (projecting caps) The default value is 0 (butt caps). To change the line cap behaviour just do: gStyle->SetCapLinePS(2); /",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSVG.html:32208,green,green,32208,doc/master/classTSVG.html,https://root.cern,https://root.cern/doc/master/classTSVG.html,1,['green'],['green']
Energy Efficiency,"; ). privatedelete . ◆ TODBCRow() [2/2]. TODBCRow::TODBCRow ; (; SQLHSTMT ; stmt, . Int_t ; fieldcount . ). Single row of query result. ; Definition at line 22 of file TODBCRow.cxx. ◆ ~TODBCRow(). TODBCRow::~TODBCRow ; (; ). virtual . Destroy row object. ; Definition at line 44 of file TODBCRow.cxx. Member Function Documentation. ◆ Class(). static TClass * TODBCRow::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TODBCRow::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TODBCRow::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 50 of file TODBCRow.h. ◆ Close(). void TODBCRow::Close ; (; Option_t * ; opt = """"). finalvirtual . Close row. ; Implements TSQLRow.; Definition at line 52 of file TODBCRow.cxx. ◆ CopyFieldValue(). void TODBCRow::CopyFieldValue ; (; Int_t ; field). protected . Extracts field value from statement. ; First allocates 128 bytes for buffer. If there is not enouth space, bigger buffer is allocated and request is repeated ; Definition at line 73 of file TODBCRow.cxx. ◆ DeclFileName(). static const char * TODBCRow::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 50 of file TODBCRow.h. ◆ GetField(). const char * TODBCRow::GetField ; (; Int_t ; field). finalvirtual . Get specified field from row (0 <= field < GetFieldCount()). ; Implements TSQLRow.; Definition at line 125 of file TODBCRow.cxx. ◆ GetFieldLength(). ULong_t TODBCRow::GetFieldLength ; (; Int_t ; field). finalvirtual . Get length in bytes of specified field. ; Implements TSQLRow.; Definition at line 114 of file TODBCRow.cxx. ◆ IsA(). TClass * TODBCRow::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 50 of file TODBCRow.h. ◆ operator=(). TODBCRow & TODBCRow::operator= ; (; const TODBCRow & ; ). pr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTODBCRow.html:12349,allocate,allocates,12349,doc/master/classTODBCRow.html,https://root.cern,https://root.cern/doc/master/classTODBCRow.html,1,['allocate'],['allocates']
Energy Efficiency,"; ); const. overridevirtual . Get number of bytes read. ; Implements TVirtualPerfStats.; Definition at line 637 of file TPerfStats.cxx. ◆ GetMemValues(). void TPerfStats::GetMemValues ; (; Long_t & ; vmax, . Long_t & ; rmax . ). static . Get memory usage. ; Definition at line 790 of file TPerfStats.cxx. ◆ GetNumEvents(). Long64_t TPerfStats::GetNumEvents ; (; ); const. inlineoverridevirtual . Implements TVirtualPerfStats.; Definition at line 134 of file TPerfStats.h. ◆ IsA(). TClass * TPerfStats::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 153 of file TPerfStats.h. ◆ PacketEvent(). void TPerfStats::PacketEvent ; (; const char * ; slave, . const char * ; slavename, . const char * ; filename, . Long64_t ; eventsprocessed, . Double_t ; latency, . Double_t ; proctime, . Double_t ; cputime, . Long64_t ; bytesRead . ). overridevirtual . Packet event. ; See WriteQueryLog for the descripition of the structure sent for monitoring when fMonitorPerPacket is kTRUE. ; Implements TVirtualPerfStats.; Definition at line 413 of file TPerfStats.cxx. ◆ PrintBasketInfo(). void TPerfStats::PrintBasketInfo ; (; Option_t * ; = """"); const. inlineoverridevirtual . Implements TVirtualPerfStats.; Definition at line 136 of file TPerfStats.h. ◆ RateEvent(). void TPerfStats::RateEvent ; (; Double_t ; proctime, . Double_t ; deltatime, . Long64_t ; eventsprocessed, . Long64_t ; bytesRead . ). overridevirtual . Rate event. ; Implements TVirtualPerfStats.; Definition at line 607 of file TPerfStats.cxx. ◆ SetBytesRead(). void TPerfStats::SetBytesRead ; (; Long64_t ; num). overridevirtual . Set number of bytes read. ; Implements TVirtualPerfStats.; Definition at line 629 of file TPerfStats.cxx. ◆ SetFile(). void TPerfStats::SetFile ; (; TFile * ; ). inlineoverrideprivatevirtual . Implements TVirtualPerfStats.; Definition at line 114 of file TPerfStats.h. ◆ SetLoaded() [1/2]. void TPerfStats::SetLoaded ; (; size_t ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPerfStats.html:17896,monitor,monitoring,17896,doc/master/classTPerfStats.html,https://root.cern,https://root.cern/doc/master/classTPerfStats.html,1,['monitor'],['monitoring']
Energy Efficiency,"; , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TGraphErrors; Double_t ** Allocate (Int_t size) override;  Allocate internal data structures for newsize points. ;  ; void CopyAndRelease (Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin) override;  Copy and release. ;  ; Bool_t CopyPoints (Double_t **arrays, Int_t ibegin, Int_t iend, Int_t obegin) override;  Copy errors from fEX and fEY to arrays[0] and arrays[1] or to fEX and fEY if arrays == 0 and ibegin != iend. ;  ; Bool_t CtorAllocate ();  Constructor allocate. ;  ; Bool_t DoMerge (const TGraph *g) override;  Protected function to perform the merge operation of a graph with errors. ;  ; void FillZero (Int_t begin, Int_t end, Bool_t from_ctor=kTRUE) override;  Set zero values for point arrays in the range [begin, end]. ;  ; void SwapPoints (Int_t pos1, Int_t pos2) override;  Swap points. ;  ; void UpdateArrays (const std::vector< Int_t > &sorting_indices, Int_t numSortedPoints, Int_t low) override;  Update the fX, fY, fEX, and fEY arrays with the sorted values. ;  ;  Protected Member Functions inherited from TGraph; Double_t ** AllocateArrays (Int_t Narrays, Int_t arraySize);  Allocate arrays. ;  ; Bool_t CtorAllocate ();  In constructors set fNpoints than call this method. ;  ; Double_t ** ExpandAndCopy (Int_t size, Int_t iend);  if size > fMaxSize allocate new arrays of 2*size points and copy iend first points. ;  ; TString SaveArray (std::ostream &out, const char *suffix, Int_t frameNumber, Double_t *arr);  Save a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGraphPolar.html:34139,allocate,allocate,34139,doc/master/classTGraphPolar.html,https://root.cern,https://root.cern/doc/master/classTGraphPolar.html,1,['allocate'],['allocate']
Energy Efficiency,"; -- Read leaves into i/o buffers for this branch.; Case of a data member within a TClonesArray (fType == 31). void ReadLeavesMember(TBuffer& b); -- Read leaves into i/o buffers for this branch.; For split-class branch, base class branch, data member branch, or top-level branch.; which do not have a branch count and are not a counter. void ReadLeavesMemberBranchCount(TBuffer& b); -- Read leaves into i/o buffers for this branch.; For split-class branch, base class branch, data member branch, or top-level branch.; which do have a branch count and are not a counter. void ReadLeavesMemberCounter(TBuffer& b); -- Read leaves into i/o buffers for this branch.; For split-class branch, base class branch, data member branch, or top-level branch.; which do not have a branch count and are a counter. void ReadLeavesCustomStreamer(TBuffer& b); -- Read leaves into i/o buffers for this branch.; Non TObject, Non collection classes with a custom streamer. void ReleaseObject(); -- Delete any object we may have allocated on a previous call to SetAddress. void Reset(Option_t* option = """"); -- Reset a Branch. Existing i/o buffers are deleted.; Entries, max and min are reset. void ResetAddress(); Set branch address to zero and free all allocated memory. void ResetDeleteObject(); -- Release ownership of any allocated objects. Note: This interface was added so that clone trees could; be told they do not own the allocated objects. void SetAddress(void* addobj); -- Point this branch at an object. For a sub-branch, addr is a pointer to the branch object. For a top-level branch the meaning of addr is as follows:. If addr is zero, then we allocate a branch object; internally and the branch is the owner of the allocated; object, not the caller. However the caller may obtain; a pointer to the branch object with GetObject(). Example:. branch->SetAddress(0);; Event* event = branch->GetObject();; ... Do some work. If addr is not zero, but the pointer addr points at is; zero, then we allocate a branch ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TBranchElement.html:26534,allocate,allocated,26534,root/html528/TBranchElement.html,https://root.cern,https://root.cern/root/html528/TBranchElement.html,2,['allocate'],['allocated']
Energy Efficiency,; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Types |; Public Member Functions |; Private Member Functions |; Private Attributes |; List of all members ; ROOT::Math::MultiDimParamGradFunctionAdapter Class ReferenceMath » MathCore » Function Classes and Interfaces » Parametric Function Evaluation Interfaces. ; MultiDimParamGradFunctionAdapter class to wrap a one-dimensional parametric gradient function in a multi dimensional parametric gradient function interface This is used typically in fitting where internally the function is stored as multidimensional. ; To wrap a non-parametric one-dim gradient function in a multi-dim interface one can use simply a a ROOT::Math::GradFunctor; The parameters are not stored in the adapter class and by default the pointer to the 1D function is owned. This means that deleting the class deletes also the 1D function and copying the class copies also the 1D function This class differs from WrappedParamFunction in the fact that the parameters are not stored in the adapter class and optionally it keeps a cloned and managed copy of the adapter class. ; Definition at line 172 of file MultiDimParamFunctionAdapter.h. Public Types; typedef IParamMultiGradFunction::BaseFunc BaseFunc;  ;  Public Types inherited from ROOT::Math::IParametricGradFunctionMultiDimTempl< T >; using BaseFunc = typename IParametricFunctionMultiDimTempl< T >::BaseFunc;  ; using BaseGradFunc = IGradientFunctionMultiDimTempl< T >;  ; using BaseParamFunc = IParametricFunctionMultiDimTempl< T >;  ;  Public Types inherited from ROOT::Math::IParametricFunctionMultiDimTempl< T >; typedef IBaseFunctionMultiDimTempl< T > BaseFunc;  ;  Public Types inherited from ROOT::Math::IBaseFunctionMultiDimTempl< T >; typedef T BackendType;  ; typedef IBaseFunctionMultiDimTempl< T > BaseFunc;  . Public Member Functions;  MultiDimParamGradFunctionAdapter (const IParamGradFunction &f);  Constructor from a param one dim function interface ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1MultiDimParamGradFunctionAdapter.html:1143,adapt,adapter,1143,doc/master/classROOT_1_1Math_1_1MultiDimParamGradFunctionAdapter.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1MultiDimParamGradFunctionAdapter.html,2,['adapt'],['adapter']
Energy Efficiency,"; 1055 ; 1056void TGraph::ExecuteEvent(Int_t event, Int_t px, Int_t py); 1057{; 1058 TVirtualGraphPainter *painter = TVirtualGraphPainter::GetPainter();; 1059 if (painter) painter->ExecuteEventHelper(this, event, px, py);; 1060}; 1061 ; 1062////////////////////////////////////////////////////////////////////////////////; 1063/// If array sizes <= newsize, expand storage to 2*newsize.; 1064 ; 1065void TGraph::Expand(Int_t newsize); 1066{; 1067 Double_t **ps = ExpandAndCopy(newsize, fNpoints);; 1068 CopyAndRelease(ps, 0, 0, 0);; 1069}; 1070 ; 1071////////////////////////////////////////////////////////////////////////////////; 1072/// If graph capacity is less than newsize points then make array sizes; 1073/// equal to least multiple of step to contain newsize points.; 1074 ; 1075void TGraph::Expand(Int_t newsize, Int_t step); 1076{; 1077 if (newsize <= fMaxSize) {; 1078 return;; 1079 }; 1080 Double_t **ps = Allocate(step * (newsize / step + (newsize % step ? 1 : 0)));; 1081 CopyAndRelease(ps, 0, fNpoints, 0);; 1082}; 1083 ; 1084////////////////////////////////////////////////////////////////////////////////; 1085/// if size > fMaxSize allocate new arrays of 2*size points and copy iend first; 1086/// points.; 1087/// Return pointer to new arrays.; 1088 ; 1089Double_t **TGraph::ExpandAndCopy(Int_t size, Int_t iend); 1090{; 1091 if (size <= fMaxSize); 1092 return nullptr;; 1093 Double_t **newarrays = Allocate(2 * size);; 1094 CopyPoints(newarrays, 0, iend, 0);; 1095 return newarrays;; 1096}; 1097 ; 1098////////////////////////////////////////////////////////////////////////////////; 1099/// Set zero values for point arrays in the range [begin, end); 1100/// Should be redefined in descendant classes; 1101 ; 1102void TGraph::FillZero(Int_t begin, Int_t end, Bool_t); 1103{; 1104 memset(fX + begin, 0, (end - begin)*sizeof(Double_t));; 1105 memset(fY + begin, 0, (end - begin)*sizeof(Double_t));; 1106}; 1107 ; 1108///////////////////////////////////////////////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraph_8cxx_source.html:36027,allocate,allocate,36027,doc/master/TGraph_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html,1,['allocate'],['allocate']
Energy Efficiency,"; 122 ; 123 ; 124 gsl_function_fdf * GetFunc() { return &fFunc; }; 125 ; 126 // evaluate the function and derivatives; 127 double operator() (double x) { return GSL_FN_FDF_EVAL_F(&fFunc, x); }; 128 ; 129 double Derivative (double x) { return GSL_FN_FDF_EVAL_DF(&fFunc, x); }; 130 ; 131 void Fdf(double x, double & f, double & df) {; 132 return GSL_FN_FDF_EVAL_F_DF(&fFunc, x, &f, &df);; 133 }; 134 ; 135 /// check if function is valid (has been set); 136 bool IsValid() {; 137 return (fFunc.f != nullptr ) ? true : false;; 138 }; 139 ; 140 private:; 141 gsl_function_fdf fFunc;; 142 ; 143 };; 144 ; 145 ; 146 ; 147} // namespace Math; 148} // namespace ROOT; 149 ; 150#endif /* ROOT_Math_GSLFunctionWrapper */; GSLFunctionAdapter.h; f#define f(i)Definition RSha256.hxx:104; GSL_FN_EVAL#define GSL_FN_EVAL(F, x)Definition RooAdaptiveGaussKronrodIntegrator1D.cxx:68; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; ROOT::Math::GSLFunctionAdapterClass for adapting any C++ functor class to C function pointers used by GSL.Definition GSLFunctionAdapter.h:63; ROOT::Math::GSLFunctionDerivWrapperclass to wrap a gsl_function_fdf (with derivatives)Definition GSLFunctionWrapper.h:105; ROOT::Math::GSLFunctionDerivWrapper::SetDerivPointervoid SetDerivPointer(GSLFuncPointer f)Definition GSLFunctionWrapper.h:119; ROOT::Math::GSLFunctionDerivWrapper::fFuncgsl_function_fdf fFuncDefinition GSLFunctionWrapper.h:141; ROOT::Math::GSLFunctionDerivWrapper::IsValidbool IsValid()check if function is valid (has been set)Definition GSLFunctionWrapper.h:136; ROOT::Math::GSLFunctionDerivWrapper::operator()double operator()(double x)Definition GSLFunctionWrapper.h:127; ROOT::Math::GSLFunctionDerivWrapper::GSLFunctionDerivWrapperGSLFunctionDerivWrapper()Definition GSLFunctionWrapper.h:109; ROOT::Math::GSLFunctionDerivWrapper::SetFdfPointervoid SetFdfPointer(GSLFdfPointer f)Definition GSLFunctionWrapper.h:120; ROOT::Math::GSLFunctionDerivWrapper::SetParamsvoid SetParams(void",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/GSLFunctionWrapper_8h_source.html:4871,adapt,adapting,4871,doc/master/GSLFunctionWrapper_8h_source.html,https://root.cern,https://root.cern/doc/master/GSLFunctionWrapper_8h_source.html,1,['adapt'],['adapting']
Energy Efficiency,"; 15import ROOT; 16 ; 17# To mark a Python callable to be used from C++, you have to use the decorator; 18# provided by PyROOT passing the C++ types of the input arguments and the return; 19# value.; 20@ROOT.Numba.Declare(['float', 'int'], 'float'); 21def pypow(x, y):; 22 return x**y; 23 ; 24# The Python callable is now available from C++ in the Numba namespace.; 25# For example, we can use it from the interpreter.; 26ROOT.gInterpreter.ProcessLine('cout << ""2^3 = "" << Numba::pypow(2, 3) << endl;'); 27 ; 28# Or we can use the callable as well within a RDataFrame workflow.; 29data = ROOT.RDataFrame(4).Define('x', '(float)rdfentry_')\; 30 .Define('x_pow3', 'Numba::pypow(x, 3)')\; 31 .AsNumpy(); 32 ; 33print('pypow({}, 3) = {}'.format(data['x'], data['x_pow3'])); 34 ; 35# ROOT uses the numba Python package to create C++ functions from python ones.; 36# We support as input and return types of the callable fundamental types and; 37# ROOT::RVec thereof. See the following callable computing the power of the; 38# elements in an array.; 39@ROOT.Numba.Declare(['RVecF', 'int'], 'RVecF'); 40def pypowarray(x, y):; 41 return x**y; 42 ; 43ROOT.gInterpreter.ProcessLine('''; 44ROOT::RVecF x = {0, 1, 2, 3};; 45cout << ""pypowarray("" << x << "", 3) = "" << Numba::pypowarray(x, 3) << endl;; 46'''); 47 ; 48# and now with RDataFrame; 49s = ROOT.RDataFrame(1).Define('x', 'ROOT::RVecF{1,2,3}')\; 50 .Define('x2', 'Numba::pypowarray(x, 2)')\; 51 .Sum('x2') # 1 + 4 + 9 == 14; 52print('sum(pypowarray({ 1, 2, 3 }, 2)) = ', s.GetValue()); formatOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/pyroot004__NumbaDeclare_8py_source.html:1689,power,power,1689,doc/master/pyroot004__NumbaDeclare_8py_source.html,https://root.cern,https://root.cern/doc/master/pyroot004__NumbaDeclare_8py_source.html,1,['power'],['power']
Energy Efficiency,"; 1623// fprintf(stderr,""an associative read iterator\n"");; 1624// else; 1625// fprintf(stderr,""a generic iterator\n"");; 1626 ; 1627 // TODO could we do better than SlowCreateIterators for RVec?; 1628 if (fSTL_type==ROOT::kSTLvector || (fProperties & kIsEmulated)); 1629 return fFunctionCreateIterators = TGenCollectionProxy__VectorCreateIterators;; 1630 else if ( (fProperties & kIsAssociative) && read); 1631 return TGenCollectionProxy__StagingCreateIterators;; 1632 else; 1633 return fFunctionCreateIterators = TGenCollectionProxy__SlowCreateIterators;; 1634}; 1635 ; 1636////////////////////////////////////////////////////////////////////////////////; 1637/// See typedef void (*CopyIterator_t)(void *&dest, const void *source);; 1638/// Copy the iterator source, into dest. dest should contain should contain the location of memory arena of size fgIteratorSize.; 1639/// If the collection iterator are of that size or less, the iterator will be constructed in place in this location (new with placement); 1640/// Otherwise the iterator will be allocated via a regular new and its address returned by modifying the value of dest.; 1641 ; 1642TVirtualCollectionProxy::CopyIterator_t TGenCollectionProxy::GetFunctionCopyIterator(Bool_t read); 1643{; 1644 if (read) {; 1645 if ( !fValue.load(std::memory_order_relaxed) ) InitializeEx(kFALSE);; 1646 if ( (fProperties & kIsAssociative) && read); 1647 return TGenCollectionProxy__StagingCopyIterator;; 1648 }; 1649 ; 1650 if ( fFunctionCopyIterator ) return fFunctionCopyIterator;; 1651 ; 1652 if ( !fValue.load(std::memory_order_relaxed) ) InitializeEx(kFALSE);; 1653 ; 1654 // TODO can we do better than the default for RVec?; 1655 if (fSTL_type==ROOT::kSTLvector || (fProperties & kIsEmulated)); 1656 return fFunctionCopyIterator = TGenCollectionProxy__VectorCopyIterator;; 1657 else if ( (fProperties & kIsAssociative) && read); 1658 return TGenCollectionProxy__StagingCopyIterator;; 1659 else; 1660 return fFunctionCopyIterator = TGenCollectionPr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:53752,allocate,allocated,53752,doc/master/TGenCollectionProxy_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html,1,['allocate'],['allocated']
Energy Efficiency,"; 1900 SetPointEYlow(i, j, 0.);; 1901 }; 1902}; 1903 ; 1904////////////////////////////////////////////////////////////////////////////////; 1905/// Set eyH values for point `i`.; 1906 ; 1907void TGraphMultiErrors::SetPointEYhigh(Int_t i, Int_t ne, const Double_t *eyH); 1908{; 1909 for (Int_t j = 0; j < fNYErrors; j++) {; 1910 if (j < ne); 1911 SetPointEYhigh(i, j, eyH[j]);; 1912 else; 1913 SetPointEYhigh(i, j, 0.);; 1914 }; 1915}; 1916 ; 1917////////////////////////////////////////////////////////////////////////////////; 1918/// Set error e ey values for point `i`.; 1919 ; 1920void TGraphMultiErrors::SetPointEY(Int_t i, Int_t e, Double_t eyL, Double_t eyH); 1921{; 1922 SetPointEYlow(i, e, eyL);; 1923 SetPointEYhigh(i, e, eyH);; 1924}; 1925 ; 1926////////////////////////////////////////////////////////////////////////////////; 1927/// Set error e eyL value for point `i`.; 1928 ; 1929void TGraphMultiErrors::SetPointEYlow(Int_t i, Int_t e, Double_t eyL); 1930{; 1931 if (i < 0 || e < 0); 1932 return;; 1933 ; 1934 if (i >= fNpoints); 1935 // re-allocate the object; 1936 TGraphMultiErrors::SetPoint(i, 0., 0.);; 1937 ; 1938 while (e >= fNYErrors); 1939 AddYError(fNpoints);; 1940 ; 1941 fEyL[e][i] = eyL;; 1942 if (fEyLSum); 1943 fEyLSum[i] = GetErrorYlow(i);; 1944 else; 1945 CalcYErrorsSum();; 1946}; 1947 ; 1948////////////////////////////////////////////////////////////////////////////////; 1949/// Set error e eyH value for point `i`.; 1950 ; 1951void TGraphMultiErrors::SetPointEYhigh(Int_t i, Int_t e, Double_t eyH); 1952{; 1953 if (i < 0 || e < 0); 1954 return;; 1955 ; 1956 if (i >= fNpoints); 1957 // re-allocate the object; 1958 TGraphMultiErrors::SetPoint(i, 0., 0.);; 1959 ; 1960 while (e >= fNYErrors); 1961 AddYError(fNpoints);; 1962 ; 1963 fEyH[e][i] = eyH;; 1964 if (fEyHSum); 1965 fEyHSum[i] = GetErrorYhigh(i);; 1966 else; 1967 CalcYErrorsSum();; 1968}; 1969 ; 1970////////////////////////////////////////////////////////////////////////////////; 1971/// Set error e e",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:65433,allocate,allocate,65433,doc/master/TGraphMultiErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html,1,['allocate'],['allocate']
Energy Efficiency,"; 2052/// ~~~; 2053 ; 2054Double_t TString::Atof() const; 2055{; 2056 //look for a comma and some whitespace; 2057 Int_t comma = Index("","");; 2058 Int_t end = Index("" "");; 2059 //if no commas & no whitespace in string, just use atof(); 2060 if (comma == -1 && end == -1) return atof(Data());; 2061 TString tmp = *this;; 2062 if (comma > -1) {; 2063 //replace comma with decimal point; 2064 tmp.Replace(comma, 1, ""."");; 2065 }; 2066 //no whitespace ?; 2067 if (end == -1) return atof(tmp.Data());; 2068 //remove whitespace; 2069 Int_t start = 0;; 2070 TString tmp2;; 2071 while (end > -1) {; 2072 tmp2 += tmp(start, end-start);; 2073 start = end+1; end = tmp.Index("" "", start);; 2074 }; 2075 end = tmp.Length();; 2076 tmp2 += tmp(start, end-start);; 2077 return atof(tmp2.Data());; 2078}; 2079 ; 2080////////////////////////////////////////////////////////////////////////////////; 2081/// Converts an Int_t to a TString with respect to the base specified (2-36).; 2082/// Thus it is an enhanced version of sprintf (adapted from versions 0.4 of; 2083/// http://www.jb.man.ac.uk/~slowe/cpp/itoa.html).; 2084/// Usage: the following statement produce the same output, namely ""1111""; 2085/// ~~~ {.cpp}; 2086/// std::cout << TString::Itoa(15,2) ;; 2087/// std::cout << TString::Itoa(0xF,2) ; /// 0x prefix to handle hex; 2088/// std::cout << TString::Itoa(017,2) ; /// 0 prefix to handle oct; 2089/// ~~~; 2090/// In case of error returns the ""!"" string.; 2091 ; 2092TString TString::Itoa(Int_t value, Int_t base); 2093{; 2094 std::string buf;; 2095 // check that the base if valid; 2096 if (base < 2 || base > 36) {; 2097 Error(""TString::Itoa"", ""base %d is not supported. Supported bases are {2,3,...,36}."",base) ;; 2098 return (TString(""!""));; 2099 }; 2100 buf.reserve(35); // Pre-allocate enough space (35=kMaxDigits); 2101 Int_t quotient = value;; 2102 // Translating number to string with base:; 2103 do {; 2104 buf += ""0123456789abcdefghijklmnopqrstuvwxyz""[ TMath::Abs(quotient % base) ];; 2105 quot",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TString_8cxx_source.html:65072,adapt,adapted,65072,doc/master/TString_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TString_8cxx_source.html,1,['adapt'],['adapted']
Energy Efficiency,"; 246}; 247 ; 248////////////////////////////////////////////////////////////////////////////////; 249/// Delete a TString.; 250 ; 251TString::~TString(); 252{; 253 UnLink();; 254}; 255 ; 256////////////////////////////////////////////////////////////////////////////////; 257/// Private member function returning an empty string representation of; 258/// size capacity and containing nchar characters.; 259/// \warning If nchar > MaxSize(), then Fatal() is raised and only MaxSize() elements are allocated; 260 ; 261char *TString::Init(Ssiz_t capacity, Ssiz_t nchar); 262{; 263 if (capacity < 0) {; 264 Error(""TString::Init"", ""Negative length!"");; 265 capacity = 0;; 266 }; 267 if (nchar < 0) {; 268 Error(""*TString::Init"", ""Negative length!"");; 269 nchar = 0;; 270 }; 271 if (nchar > capacity) {; 272 Error(""TString::Init"", ""capacity is smaller than nchar (%d > %d)"", nchar, capacity);; 273 nchar = capacity;; 274 }; 275 if (capacity > MaxSize()) {; 276 Fatal(""TString::Init"", ""capacity too large (%d, max = %d)"", capacity, MaxSize());; 277 capacity = MaxSize();; 278 if (nchar > capacity); 279 nchar = capacity;; 280 }; 281 ; 282 char *data;; 283 if (capacity < kMinCap) {; 284 SetShortSize(nchar);; 285 data = GetShortPointer();; 286 } else {; 287 Ssiz_t cap = Recommend(capacity);; 288 data = new char[cap+1];; 289 SetLongCap(cap+1);; 290 SetLongSize(nchar);; 291 SetLongPointer(data);; 292 }; 293 data[nchar] = 0; // terminating null; 294 ; 295 return data;; 296}; 297 ; 298////////////////////////////////////////////////////////////////////////////////; 299/// Assign character c to TString.; 300 ; 301TString& TString::operator=(char c); 302{; 303 if (!c) {; 304 UnLink();; 305 Zero();; 306 return *this;; 307 }; 308 return Replace(0, Length(), &c, 1);; 309}; 310 ; 311////////////////////////////////////////////////////////////////////////////////; 312/// Assign string cs to TString.; 313 ; 314TString& TString::operator=(const char *cs); 315{; 316 if (!cs || !*cs) {; 317 UnLink();; 318 Z",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TString_8cxx_source.html:7970,allocate,allocated,7970,doc/master/TString_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TString_8cxx_source.html,1,['allocate'],['allocated']
Energy Efficiency,"; 3015 case 54:; 3016 {; 3017 Double_t red[9] = { 0./255., 22./255., 44./255., 68./255., 93./255., 124./255., 160./255., 192./255., 237./255.};; 3018 Double_t green[9] = { 0./255., 16./255., 41./255., 67./255., 93./255., 125./255., 162./255., 194./255., 241./255.};; 3019 Double_t blue[9] = { 97./255., 100./255., 99./255., 99./255., 93./255., 68./255., 44./255., 26./255., 74./255.};; 3020 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3021 }; 3022 break;; 3023 ; 3024 // Rain Bow; 3025 case 55:; 3026 {; 3027 Double_t red[9] = { 0./255., 5./255., 15./255., 35./255., 102./255., 196./255., 208./255., 199./255., 110./255.};; 3028 Double_t green[9] = { 0./255., 48./255., 124./255., 192./255., 206./255., 226./255., 97./255., 16./255., 0./255.};; 3029 Double_t blue[9] = { 99./255., 142./255., 198./255., 201./255., 90./255., 22./255., 13./255., 8./255., 2./255.};; 3030 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3031 }; 3032 break;; 3033 ; 3034 // Inverted Dark Body Radiator; 3035 case 56:; 3036 {; 3037 Double_t red[9] = { 242./255., 234./255., 237./255., 230./255., 212./255., 156./255., 99./255., 45./255., 0./255.};; 3038 Double_t green[9] = { 243./255., 238./255., 238./255., 168./255., 101./255., 45./255., 0./255., 0./255., 0./255.};; 3039 Double_t blue[9] = { 230./255., 95./255., 11./255., 8./255., 9./255., 3./255., 1./255., 1./255., 0./255.};; 3040 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3041 }; 3042 break;; 3043 ; 3044 // Bird; 3045 case 57:; 3046 {; 3047 Double_t red[9] = { 0.2082, 0.0592, 0.0780, 0.0232, 0.1802, 0.5301, 0.8186, 0.9956, 0.9764};; 3048 Double_t green[9] = { 0.1664, 0.3599, 0.5041, 0.6419, 0.7178, 0.7492, 0.7328, 0.7862, 0.9832};; 3049 Double_t blue[9] = { 0.5293, 0.8684, 0.8385, 0.7914, 0.6425, 0.4662, 0.3499, 0.1968, 0.0539};; 3050 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3051 }; 3052 break;; 3053 ; 3054 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TColor_8cxx_source.html:114136,green,green,114136,doc/master/TColor_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html,1,['green'],['green']
Energy Efficiency,"; 3040 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3041 }; 3042 break;; 3043 ; 3044 // Bird; 3045 case 57:; 3046 {; 3047 Double_t red[9] = { 0.2082, 0.0592, 0.0780, 0.0232, 0.1802, 0.5301, 0.8186, 0.9956, 0.9764};; 3048 Double_t green[9] = { 0.1664, 0.3599, 0.5041, 0.6419, 0.7178, 0.7492, 0.7328, 0.7862, 0.9832};; 3049 Double_t blue[9] = { 0.5293, 0.8684, 0.8385, 0.7914, 0.6425, 0.4662, 0.3499, 0.1968, 0.0539};; 3050 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3051 }; 3052 break;; 3053 ; 3054 // Cubehelix; 3055 case 58:; 3056 {; 3057 Double_t red[9] = { 0.0000, 0.0956, 0.0098, 0.2124, 0.6905, 0.9242, 0.7914, 0.7596, 1.0000};; 3058 Double_t green[9] = { 0.0000, 0.1147, 0.3616, 0.5041, 0.4577, 0.4691, 0.6905, 0.9237, 1.0000};; 3059 Double_t blue[9] = { 0.0000, 0.2669, 0.3121, 0.1318, 0.2236, 0.6741, 0.9882, 0.9593, 1.0000};; 3060 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3061 }; 3062 break;; 3063 ; 3064 // Green Red Violet; 3065 case 59:; 3066 {; 3067 Double_t red[9] = {13./255., 23./255., 25./255., 63./255., 76./255., 104./255., 137./255., 161./255., 206./255.};; 3068 Double_t green[9] = {95./255., 67./255., 37./255., 21./255., 0./255., 12./255., 35./255., 52./255., 79./255.};; 3069 Double_t blue[9] = { 4./255., 3./255., 2./255., 6./255., 11./255., 22./255., 49./255., 98./255., 208./255.};; 3070 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3071 }; 3072 break;; 3073 ; 3074 // Blue Red Yellow; 3075 case 60:; 3076 {; 3077 Double_t red[9] = {0./255., 61./255., 89./255., 122./255., 143./255., 160./255., 185./255., 204./255., 231./255.};; 3078 Double_t green[9] = {0./255., 0./255., 0./255., 0./255., 14./255., 37./255., 72./255., 132./255., 235./255.};; 3079 Double_t blue[9] = {0./255., 140./255., 224./255., 144./255., 4./255., 5./255., 6./255., 9./255., 13./255.};; 3080 Idx = TColor::CreateGradientColorTable(9, stops, red, gre",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TColor_8cxx_source.html:115573,green,green,115573,doc/master/TColor_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html,1,['green'],['green']
Energy Efficiency,"; 3167 Double_t red[9] = { 198./255., 206./255., 206./255., 211./255., 198./255., 181./255., 161./255., 171./255., 244./255.};; 3168 Double_t green[9] = { 103./255., 133./255., 150./255., 172./255., 178./255., 174./255., 163./255., 175./255., 244./255.};; 3169 Double_t blue[9] = { 49./255., 54./255., 55./255., 66./255., 91./255., 130./255., 184./255., 224./255., 244./255.};; 3170 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3171 }; 3172 break;; 3173 ; 3174 // Black Body; 3175 case 70:; 3176 {; 3177 Double_t red[9] = { 243./255., 243./255., 240./255., 240./255., 241./255., 239./255., 186./255., 151./255., 129./255.};; 3178 Double_t green[9] = { 0./255., 46./255., 99./255., 149./255., 194./255., 220./255., 183./255., 166./255., 147./255.};; 3179 Double_t blue[9] = { 6./255., 8./255., 36./255., 91./255., 169./255., 235./255., 246./255., 240./255., 233./255.};; 3180 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3181 }; 3182 break;; 3183 ; 3184 // Blue Green Yellow; 3185 case 71:; 3186 {; 3187 Double_t red[9] = { 22./255., 19./255., 19./255., 25./255., 35./255., 53./255., 88./255., 139./255., 210./255.};; 3188 Double_t green[9] = { 0./255., 32./255., 69./255., 108./255., 135./255., 159./255., 183./255., 198./255., 215./255.};; 3189 Double_t blue[9] = { 77./255., 96./255., 110./255., 116./255., 110./255., 100./255., 90./255., 78./255., 70./255.};; 3190 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3191 }; 3192 break;; 3193 ; 3194 // Brown Cyan; 3195 case 72:; 3196 {; 3197 Double_t red[9] = { 68./255., 116./255., 165./255., 182./255., 189./255., 180./255., 145./255., 111./255., 71./255.};; 3198 Double_t green[9] = { 37./255., 82./255., 135./255., 178./255., 204./255., 225./255., 221./255., 202./255., 147./255.};; 3199 Double_t blue[9] = { 16./255., 55./255., 105./255., 147./255., 196./255., 226./255., 232./255., 224./255., 178./255.};; 3200 Idx = TColor::CreateGradient",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TColor_8cxx_source.html:121837,green,green,121837,doc/master/TColor_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html,1,['green'],['green']
Energy Efficiency,"; 3176 {; 3177 Double_t red[9] = { 243./255., 243./255., 240./255., 240./255., 241./255., 239./255., 186./255., 151./255., 129./255.};; 3178 Double_t green[9] = { 0./255., 46./255., 99./255., 149./255., 194./255., 220./255., 183./255., 166./255., 147./255.};; 3179 Double_t blue[9] = { 6./255., 8./255., 36./255., 91./255., 169./255., 235./255., 246./255., 240./255., 233./255.};; 3180 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3181 }; 3182 break;; 3183 ; 3184 // Blue Green Yellow; 3185 case 71:; 3186 {; 3187 Double_t red[9] = { 22./255., 19./255., 19./255., 25./255., 35./255., 53./255., 88./255., 139./255., 210./255.};; 3188 Double_t green[9] = { 0./255., 32./255., 69./255., 108./255., 135./255., 159./255., 183./255., 198./255., 215./255.};; 3189 Double_t blue[9] = { 77./255., 96./255., 110./255., 116./255., 110./255., 100./255., 90./255., 78./255., 70./255.};; 3190 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3191 }; 3192 break;; 3193 ; 3194 // Brown Cyan; 3195 case 72:; 3196 {; 3197 Double_t red[9] = { 68./255., 116./255., 165./255., 182./255., 189./255., 180./255., 145./255., 111./255., 71./255.};; 3198 Double_t green[9] = { 37./255., 82./255., 135./255., 178./255., 204./255., 225./255., 221./255., 202./255., 147./255.};; 3199 Double_t blue[9] = { 16./255., 55./255., 105./255., 147./255., 196./255., 226./255., 232./255., 224./255., 178./255.};; 3200 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3201 }; 3202 break;; 3203 ; 3204 // CMYK; 3205 case 73:; 3206 {; 3207 Double_t red[9] = { 61./255., 99./255., 136./255., 181./255., 213./255., 225./255., 198./255., 136./255., 24./255.};; 3208 Double_t green[9] = { 149./255., 140./255., 96./255., 83./255., 132./255., 178./255., 190./255., 135./255., 22./255.};; 3209 Double_t blue[9] = { 214./255., 203./255., 168./255., 135./255., 110./255., 100./255., 111./255., 113./255., 22./255.};; 3210 Idx = TColor::CreateGradientC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TColor_8cxx_source.html:122366,green,green,122366,doc/master/TColor_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html,1,['green'],['green']
Energy Efficiency,"; 3434 // Rose; 3435 case 96:; 3436 {; 3437 Double_t red[9] = { 30./255., 49./255., 79./255., 117./255., 135./255., 151./255., 146./255., 138./255., 147./255.};; 3438 Double_t green[9] = { 63./255., 60./255., 72./255., 90./255., 94./255., 94./255., 68./255., 46./255., 16./255.};; 3439 Double_t blue[9] = { 18./255., 28./255., 41./255., 56./255., 62./255., 63./255., 50./255., 36./255., 21./255.};; 3440 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3441 }; 3442 break;; 3443 ; 3444 // Rust; 3445 case 97:; 3446 {; 3447 Double_t red[9] = { 0./255., 30./255., 63./255., 101./255., 143./255., 152./255., 169./255., 187./255., 230./255.};; 3448 Double_t green[9] = { 0./255., 14./255., 28./255., 42./255., 58./255., 61./255., 67./255., 74./255., 91./255.};; 3449 Double_t blue[9] = { 39./255., 26./255., 21./255., 18./255., 15./255., 14./255., 14./255., 13./255., 13./255.};; 3450 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3451 }; 3452 break;; 3453 ; 3454 // Sandy Terrain; 3455 case 98:; 3456 {; 3457 Double_t red[9] = { 149./255., 140./255., 164./255., 179./255., 182./255., 181./255., 131./255., 87./255., 61./255.};; 3458 Double_t green[9] = { 62./255., 70./255., 107./255., 136./255., 144./255., 138./255., 117./255., 87./255., 74./255.};; 3459 Double_t blue[9] = { 40./255., 38./255., 45./255., 49./255., 49./255., 49./255., 38./255., 32./255., 34./255.};; 3460 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3461 }; 3462 break;; 3463 ; 3464 // Sienna; 3465 case 99:; 3466 {; 3467 Double_t red[9] = { 99./255., 112./255., 148./255., 165./255., 179./255., 182./255., 183./255., 183./255., 208./255.};; 3468 Double_t green[9] = { 39./255., 40./255., 57./255., 79./255., 104./255., 127./255., 148./255., 161./255., 198./255.};; 3469 Double_t blue[9] = { 15./255., 16./255., 18./255., 33./255., 51./255., 79./255., 103./255., 129./255., 177./255.};; 3470 Idx = TColor::CreateGradientColorTable(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TColor_8cxx_source.html:135998,green,green,135998,doc/master/TColor_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html,1,['green'],['green']
Energy Efficiency,"; 3526 {; 3527 Double_t red[9] = { 30./255., 55./255., 103./255., 147./255., 174./255., 203./255., 188./255., 151./255., 105./255.};; 3528 Double_t green[9] = { 0./255., 65./255., 138./255., 182./255., 187./255., 175./255., 121./255., 53./255., 9./255.};; 3529 Double_t blue[9] = { 191./255., 202./255., 212./255., 208./255., 171./255., 140./255., 97./255., 57./255., 30./255.};; 3530 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3531 }; 3532 break;; 3533 ; 3534 // Valentine; 3535 case 106:; 3536 {; 3537 Double_t red[9] = { 112./255., 97./255., 113./255., 125./255., 138./255., 159./255., 178./255., 188./255., 225./255.};; 3538 Double_t green[9] = { 16./255., 17./255., 24./255., 37./255., 56./255., 81./255., 110./255., 136./255., 189./255.};; 3539 Double_t blue[9] = { 38./255., 35./255., 46./255., 59./255., 78./255., 103./255., 130./255., 152./255., 201./255.};; 3540 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3541 }; 3542 break;; 3543 ; 3544 // Visible Spectrum; 3545 case 107:; 3546 {; 3547 Double_t red[9] = { 18./255., 72./255., 5./255., 23./255., 29./255., 201./255., 200./255., 98./255., 29./255.};; 3548 Double_t green[9] = { 0./255., 0./255., 43./255., 167./255., 211./255., 117./255., 0./255., 0./255., 0./255.};; 3549 Double_t blue[9] = { 51./255., 203./255., 177./255., 26./255., 10./255., 9./255., 8./255., 3./255., 0./255.};; 3550 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3551 }; 3552 break;; 3553 ; 3554 // Water Melon; 3555 case 108:; 3556 {; 3557 Double_t red[9] = { 19./255., 42./255., 64./255., 88./255., 118./255., 147./255., 175./255., 187./255., 205./255.};; 3558 Double_t green[9] = { 19./255., 55./255., 89./255., 125./255., 154./255., 169./255., 161./255., 129./255., 70./255.};; 3559 Double_t blue[9] = { 19./255., 32./255., 47./255., 70./255., 100./255., 128./255., 145./255., 130./255., 75./255.};; 3560 Idx = TColor::CreateGradientColorTable(9, stops",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TColor_8cxx_source.html:140722,green,green,140722,doc/master/TColor_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html,1,['green'],['green']
Energy Efficiency,"; 3563//______________________________________________________________________________; 3564//; 3565// Command IMPROVE; 3566//; 3567 if( !strncmp(comd.Data(),""IMP"",3) ) {; 3568 Printf("" ***>IMPROVE [maxcalls]"");; 3569 Printf("" If a previous minimization has converged, and the current"");; 3570 Printf("" values of the parameters therefore correspond to a local"");; 3571 Printf("" minimum of the function, this command requests a search for"");; 3572 Printf("" additional distinct local minima."");; 3573 Printf("" The optional argument [maxcalls] specifies the (approximate"");; 3574 Printf("" maximum number of function calls after which the calculation"");; 3575 Printf("" will be stopped."");; 3576 goto L99;; 3577 }; 3578//______________________________________________________________________________; 3579//; 3580// Command MIGRAD; 3581//; 3582 if( !strncmp(comd.Data(),""MIG"",3) ) {; 3583 Printf("" ***>MIGrad [maxcalls] [tolerance]"");; 3584 Printf("" Causes minimization of the function by the method of Migrad,"");; 3585 Printf("" the most efficient and complete single method, recommended"");; 3586 Printf("" for general functions (see also MINImize)."");; 3587 Printf("" The minimization produces as a by-product the error matrix"");; 3588 Printf("" of the parameters, which is usually reliable unless warning"");; 3589 Printf("" messages are produced."");; 3590 Printf("" The optional argument [maxcalls] specifies the (approximate)"");; 3591 Printf("" maximum number of function calls after which the calculation"");; 3592 Printf("" will be stopped even if it has not yet converged."");; 3593 Printf("" The optional argument [tolerance] specifies required tolerance"");; 3594 Printf("" on the function value at the minimum."");; 3595 Printf("" The default tolerance is 0.1, and the minimization will stop"");; 3596 Printf("" when the estimated vertical distance to the minimum (EDM) is"");; 3597 Printf("" less than 0.001*[tolerance]*UP (see [SET ERRordef])."");; 3598 goto L99;; 3599 }; 3600//___________________________________",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMinuit_8cxx_source.html:115086,efficient,efficient,115086,doc/master/TMinuit_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html,1,['efficient'],['efficient']
Energy Efficiency,"; 37 inline Int_t getIntColorF () {return TColor::GetColor( ""#33aa77"" );} // novel green; 38 ; 39 ; 40 inline Int_t getSigColorT () {return 10;}; 41 inline Int_t getBkgColorT () {return 10;}; 42 inline Int_t getIntColorT () {return 10;}; 43 ; 44 ; 45 ; 46 class StatDialogBDT {; 47 ; 48 RQ_OBJECT(""StatDialogBDT""); 49 ; 50 public:; 51 ; 52 StatDialogBDT(TString dataset, const TGWindow* p, TString wfile,; 53 TString methName = ""BDT"", Int_t itree = 0 );; 54 virtual ~StatDialogBDT() {; 55 TMVA::DecisionTreeNode::SetIsTraining(false);; 56 fThis = nullptr;; 57 fMain->CloseWindow();; 58 fMain->Cleanup();; 59 if(gROOT->GetListOfCanvases()->FindObject(fCanvas)); 60 delete fCanvas;; 61 }; 62 ; 63 // draw method; 64 void DrawTree(Int_t itree );; 65 ; 66 void RaiseDialog() { if (fMain) { fMain->RaiseWindow(); fMain->Layout(); fMain->MapWindow();",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/BDT_8h_source.html:1240,green,green,1240,doc/master/BDT_8h_source.html,https://root.cern,https://root.cern/doc/master/BDT_8h_source.html,1,['green'],['green']
Energy Efficiency,"; 403 /// \brief Define a new column.; 404 /// \param[in] name The name of the defined column.; 405 /// \param[in] expression Function, lambda expression, functor class or any other callable object producing the defined value. Returns the value that will be assigned to the defined column.; 406 /// \param[in] columns Names of the columns/branches in input to the producer function.; 407 /// \return the first node of the computation graph for which the new quantity is defined.; 408 ///; 409 /// Define a column that will be visible from all subsequent nodes; 410 /// of the functional chain. The `expression` is only evaluated for entries that pass; 411 /// all the preceding filters.; 412 /// A new variable is created called `name`, accessible as if it was contained; 413 /// in the dataset from subsequent transformations/actions.; 414 ///; 415 /// Use cases include:; 416 /// * caching the results of complex calculations for easy and efficient multiple access; 417 /// * extraction of quantities of interest from complex objects; 418 ///; 419 /// An exception is thrown if the name of the new column is already in use in this branch of the computation graph.; 420 ///; 421 /// ### Example usage:; 422 /// ~~~{.cpp}; 423 /// // assuming a function with signature:; 424 /// double myComplexCalculation(const RVec<float> &muon_pts);; 425 /// // we can pass it directly to Define; 426 /// auto df_with_define = df.Define(""newColumn"", myComplexCalculation, {""muon_pts""});; 427 /// // alternatively, we can pass the body of the function as a string, as in Filter:; 428 /// auto df_with_define = df.Define(""newColumn"", ""x*x + y*y"");; 429 /// ~~~; 430 ///; 431 /// \note If the body of the string expression contains an explicit `return` statement (even if it is in a nested; 432 /// scope), RDataFrame _will not_ add another one in front of the expression. So this will not work:; 433 /// ~~~{.cpp}; 434 /// df.Define(""x2"", ""Map(v, [](float e) { return e*e; })""); 435 /// ~~~; 436 /// but instead thi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RInterface_8hxx_source.html:20422,efficient,efficient,20422,doc/master/RInterface_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RInterface_8hxx_source.html,1,['efficient'],['efficient']
Energy Efficiency,; 43 ; 44 @ingroup FitData; 45*/; 46class UnBinData : public FitData {; 47 ; 48public :; 49 ; 50 /**; 51 constructor from dimension of point and max number of points (to pre-allocate vector); 52 ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/UnBinData_8h_source.html:1980,allocate,allocate,1980,doc/master/UnBinData_8h_source.html,https://root.cern,https://root.cern/doc/master/UnBinData_8h_source.html,1,['allocate'],['allocate']
Energy Efficiency,"; 4745////////////////////////////////////////////////////////////////////////////////; 4746/// Reset a Branch.; 4747///; 4748/// Existing i/o buffers are deleted.; 4749/// Entries, max and min are reset.; 4750///; 4751 ; 4752void TBranchElement::Reset(Option_t* option); 4753{; 4754 Int_t nbranches = fBranches.GetEntriesFast();; 4755 for (Int_t i = 0; i < nbranches; ++i) {; 4756 TBranch* branch = (TBranch*) fBranches[i];; 4757 branch->Reset(option);; 4758 }; 4759 fBranchID = -1;; 4760 TBranch::Reset(option);; 4761}; 4762 ; 4763////////////////////////////////////////////////////////////////////////////////; 4764/// Reset a Branch after a Merge operation (drop data but keep customizations); 4765///; 4766 ; 4767void TBranchElement::ResetAfterMerge(TFileMergeInfo *info); 4768{; 4769 Int_t nbranches = fBranches.GetEntriesFast();; 4770 for (Int_t i = 0; i < nbranches; ++i) {; 4771 TBranch* branch = (TBranch*) fBranches[i];; 4772 branch->ResetAfterMerge(info);; 4773 }; 4774 TBranch::ResetAfterMerge(info);; 4775}; 4776 ; 4777////////////////////////////////////////////////////////////////////////////////; 4778/// Set branch address to zero and free all allocated memory.; 4779 ; 4780void TBranchElement::ResetAddress(); 4781{; 4782 for (Int_t i = 0; i < fNleaves; ++i) {; 4783 TLeaf* leaf = (TLeaf*) fLeaves.UncheckedAt(i);; 4784 //if (leaf) leaf->SetAddress(0);; 4785 leaf->SetAddress(nullptr);; 4786 }; 4787 ; 4788 // Note: We *must* do the sub-branches first, otherwise; 4789 // we may delete the object containing the sub-branches; 4790 // before giving them a chance to cleanup.; 4791 Int_t nbranches = fBranches.GetEntriesFast();; 4792 for (Int_t i = 0; i < nbranches; ++i) {; 4793 TBranch* br = (TBranch*) fBranches[i];; 4794 if (br) br->ResetAddress();; 4795 }; 4796 ; 4797 //; 4798 // SetAddress may have allocated an object.; 4799 //; 4800 ; 4801 ReleaseObject();; 4802 ; 4803 ResetBit(kAddressSet);; 4804 fAddress = nullptr;; 4805 fObject = nullptr;; 4806}; 4807 ; 4808/////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBranchElement_8cxx_source.html:177056,allocate,allocated,177056,doc/master/TBranchElement_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html,1,['allocate'],['allocated']
Energy Efficiency,"; 5253 if(fSTLtype != ROOT::kSTLvector && GetCollectionProxy()->HasPointers() && fSplitLevel > TTree::kSplitCollectionOfPointers ) {; 5254 fPtrIterators = new TVirtualCollectionPtrIterators(GetCollectionProxy());; 5255 } else if (fCollProxy->GetProperties() & TVirtualCollectionProxy::kIsAssociative) {; 5256 fWriteIterators = new TVirtualCollectionIterators(fCollProxy,false);; 5257 fIterators = new TVirtualCollectionIterators(fCollProxy);; 5258 } else {; 5259 fIterators = new TVirtualCollectionIterators(GetCollectionProxy());; 5260 }; 5261 }; 5262 }; 5263 }; 5264 ; 5265 //; 5266 // Establish the semantics of fObject and fAddress.; 5267 //; 5268 // Top-level branch:; 5269 // fObject is a ptr to the object,; 5270 // fAddress is a ptr to a pointer to the object.; 5271 //; 5272 // Sub-branch:; 5273 // fObject is a ptr to the object,; 5274 // fAddress is the same as fObject.; 5275 //; 5276 //; 5277 // There are special cases for TClonesArray and STL containers.; 5278 // If there is no user-provided object, we allocate one. We must; 5279 // also initialize any STL container proxy.; 5280 //; 5281 ; 5282 if (fType == 3) {; 5283 // -- We are a TClonesArray master branch.; 5284 if (fAddress) {; 5285 // -- We have been given a non-zero address, allocate if necessary.; 5286 if (fStreamerType == TVirtualStreamerInfo::kObject) {; 5287 // -- We are *not* a top-level branch and we are *not* a pointer to a TClonesArray.; 5288 // Case of an embedded TClonesArray.; 5289 fObject = fAddress;; 5290 // Check if it has already been properly built.; 5291 TClonesArray* clones = (TClonesArray*) fObject;; 5292 if (!clones->GetClass()) {; 5293 new(fObject) TClonesArray(fClonesClass);; 5294 }; 5295 } else {; 5296 // -- We are either a top-level branch or we are a subbranch which is a pointer to a TClonesArray.; 5297 // Streamer type should be -1 (for a top-level branch) or kObject(p|P) here.; 5298 if ((fStreamerType != -1) &&; 5299 (fStreamerType != TVirtualStreamerInfo::kObjectp) &&; 5300 (fStrea",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBranchElement_8cxx_source.html:194903,allocate,allocate,194903,doc/master/TBranchElement_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html,1,['allocate'],['allocate']
Energy Efficiency,"; 5407 if ((fStreamerType == TVirtualStreamerInfo::kObject) ||; 5408 (fStreamerType == TVirtualStreamerInfo::kAny) ||; 5409 (fStreamerType == TVirtualStreamerInfo::kSTL)) {; 5410 // We are *not* a top-level branch and we are *not* a pointer to an STL container.; 5411 // Case of an embedded STL container.; 5412 // Note: We test for the kObject and kAny types to support; 5413 // the (unwise) choice of inheriting from an STL container.; 5414 Error(""SetAddress"", ""Embedded STL container given a zero address for branch '%s'"", GetName());; 5415 } else {; 5416 // We are either a top-level branch or sub-branch which is a pointer to an STL container.; 5417 // Streamer type should be -1 (for a top-level branch) or kSTLp here.; 5418 if ((fStreamerType != -1) && (fStreamerType != TVirtualStreamerInfo::kSTLp)) {; 5419 Error(""SetAddress"",; 5420 ""Branch %s is a split STL container (fStreamerType is: %d), the address can not be set directly."",; 5421 GetName(), fStreamerType);; 5422 } else if (fStreamerType == -1) {; 5423 // -- We are a top-level branch, allocate.; 5424 SetBit(kDeleteObject);; 5425 fObject = (char*) proxy->New();; 5426 if (fObject) {; 5427 fAddress = (char*) &fObject;; 5428 } else {; 5429 Error(""SetAddress"", ""Failed to allocate STL container for branch '%s'"", GetName());; 5430 // FIXME: Should we do this? Lots of other code wants; 5431 // fAddress to be zero if no fObject, but is; 5432 // that a good thing?; 5433 fAddress = nullptr;; 5434 ResetBit(kAddressSet);; 5435 }; 5436 } else {; 5437 // -- We are a sub-branch which is a pointer to an STL container.; 5438 Error(""SetAddress"", ""Embedded pointer to an STL container given a zero address for branch '%s'"", GetName());; 5439 }; 5440 }; 5441 }; 5442 } else if (fType == 41) {; 5443 // -- We are an STL container sub-branch.; 5444 // Initialize fCollProxy.; 5445 GetCollectionProxy();; 5446 // We are not at top-level branch.; 5447 fObject = fAddress;; 5448 } else if (fID < 0) {; 5449 // -- We are a top-level branch.; 5450 c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBranchElement_8cxx_source.html:201646,allocate,allocate,201646,doc/master/TBranchElement_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html,1,['allocate'],['allocate']
Energy Efficiency,"; 60 }; 61 if (ymin < ymax) {; 62 RangeSet ry(1);; 63 ry[0] = std::make_pair(ymin, ymax);; 64 fRanges[1] = ry;; 65 }; 66 if (zmin < zmax) {; 67 RangeSet rz(1);; 68 rz[0] = std::make_pair(zmin, zmax);; 69 fRanges[2] = rz;; 70 }; 71}; 72 ; 73bool lessRange( const std::pair<double,double> & r1, const std::pair<double,double> & r2 ) {; 74 // compare ranges using max position so in case of included ranges smaller one comes first; 75 return r1.second < r2.second;; 76}; 77 ; 78std::pair<double, double> DataRange::operator() (unsigned int icoord,unsigned int irange) const {; 79 if ( Size(icoord) > irange ); 80 return fRanges[icoord].at(irange);; 81 else if (irange == 0) {; 82 // return [-inf +inf] for the other dimension; 83 double xmin = 0; double xmax = 0;; 84 GetInfRange(xmin,xmax);; 85 return std::make_pair(xmin,xmax);; 86 }; 87 else {; 88 // in case the irange-th does not exist for the given coordinate; 89 MATH_ERROR_MSG(""DataRange::operator()"",""invalid range number - return (0,0)"");; 90 return std::pair<double,double>(0,0);; 91 }; 92}; 93 ; 94void DataRange::AddRange(unsigned int icoord , double xmin, double xmax ) {; 95 // add a range [xmin,xmax] for the new coordinate icoord; 96 ; 97 if (xmin >= xmax) return; // no op in case of bad values; 98 ; 99 // case the coordinate is larger than the current allocated vector size; 100 if (icoord >= fRanges.size() ) {; 101 RangeSet rx(1);; 102 rx[0] = std::make_pair(xmin, xmax);; 103 fRanges.resize(icoord+1);; 104 fRanges[icoord] = rx;; 105 return;; 106 }; 107 RangeSet & rs = fRanges[icoord];; 108 // case the vector of the ranges is empty in the given coordinate; 109 if ( rs.empty()) {; 110 rs.push_back(std::make_pair(xmin,xmax) );; 111 return;; 112 }; 113 // case of an already existing range; 114 // need to establish a policy (use OR or AND ); 115 ; 116 CleanRangeSet(icoord,xmin,xmax);; 117 // add the new one; 118 rs.push_back(std::make_pair(xmin,xmax) );; 119 // sort range in increasing values of xmax; 120 std::sort( rs.begin(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/DataRange_8cxx_source.html:3037,allocate,allocated,3037,doc/master/DataRange_8cxx_source.html,https://root.cern,https://root.cern/doc/master/DataRange_8cxx_source.html,1,['allocate'],['allocated']
Energy Efficiency,"; 61 if(!colors) {; 62 puts (""Unable to allocate memory for colors !"");; 63 ret = 0;; 64 }; 65 else {; 66 colors[ 0].red = 92; colors[ 0].green = 92; colors[0].blue = 92;; 67 colors[ 1].red = 122; colors[ 1].green = 122; colors[1].blue = 122;; 68 colors[ 2].red = 184; colors[ 2].green = 184; colors[2].blue = 184;; 69 colors[ 3].red = 215; colors[ 3].green = 215; colors[3].blue = 215;; 70 colors[ 4].red = 138; colors[ 4].green = 15; colors[4].blue = 15;; 71 colors[ 5].red = 184; colors[ 5].green = 20; colors[5].blue = 20;; 72 colors[ 6].red = 235; colors[ 6].green = 71; colors[6].blue = 71;; 73 colors[ 7].red = 240; colors[ 7].green = 117; colors[7].blue = 117;; 74 colors[ 8].red = 15; colors[ 8].green = 138; colors[8].blue = 15;; 75 colors[ 9].red = 20; colors[ 9].green = 184; colors[9].blue = 20;; 76 colors[10].red = 71; colors[10].green = 235; colors[10].blue = 71;; 77 colors[11].red = 117; colors[11].green = 240; colors[11].blue = 117;; 78 colors[12].red = 15; colors[12].green = 15; colors[12].blue = 138;; 79 colors[13].red = 20; colors[13].green = 20; colors[13].blue = 184;; 80 colors[14].red = 71; colors[14].green = 71; colors[14].blue = 235;; 81 colors[15].red = 117; colors[15].green = 117; colors[15].blue = 240;; 82 colors[16].red = 138; colors[16].green = 138; colors[16].blue = 15;; 83 colors[17].red = 184; colors[17].green = 184; colors[17].blue = 20;; 84 colors[18].red = 235; colors[18].green = 235; colors[18].blue = 71;; 85 colors[19].red = 240; colors[19].green = 240; colors[19].blue = 117;; 86 colors[20].red = 138; colors[20].green = 15; colors[20].blue = 138;; 87 colors[21].red = 184; colors[21].green = 20; colors[21].blue = 184;; 88 colors[22].red = 235; colors[22].green = 71; colors[22].blue = 235;; 89 colors[23].red = 240; colors[23].green = 117; colors[23].blue = 240;; 90 colors[24].red = 15; colors[24].green = 138; colors[24].blue = 138;; 91 colors[25].red = 20; colors[25].green = 184; colors[25].blue = 184;; 92 colors[26].red = 71; colors[26].gree",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/X3DBuffer_8c_source.html:2544,green,green,2544,doc/master/X3DBuffer_8c_source.html,https://root.cern,https://root.cern/doc/master/X3DBuffer_8c_source.html,1,['green'],['green']
Energy Efficiency,; 63 ret = 0;; 64 }; 65 else {; 66 colors[ 0].red = 92; colors[ 0].green = 92; colors[0].blue = 92;; 67 colors[ 1].red = 122; colors[ 1].green = 122; colors[1].blue = 122;; 68 colors[ 2].red = 184; colors[ 2].green = 184; colors[2].blue = 184;; 69 colors[ 3].red = 215; colors[ 3].green = 215; colors[3].blue = 215;; 70 colors[ 4].red = 138; colors[ 4].green = 15; colors[4].blue = 15;; 71 colors[ 5].red = 184; colors[ 5].green = 20; colors[5].blue = 20;; 72 colors[ 6].red = 235; colors[ 6].green = 71; colors[6].blue = 71;; 73 colors[ 7].red = 240; colors[ 7].green = 117; colors[7].blue = 117;; 74 colors[ 8].red = 15; colors[ 8].green = 138; colors[8].blue = 15;; 75 colors[ 9].red = 20; colors[ 9].green = 184; colors[9].blue = 20;; 76 colors[10].red = 71; colors[10].green = 235; colors[10].blue = 71;; 77 colors[11].red = 117; colors[11].green = 240; colors[11].blue = 117;; 78 colors[12].red = 15; colors[12].green = 15; colors[12].blue = 138;; 79 colors[13].red = 20; colors[13].green = 20; colors[13].blue = 184;; 80 colors[14].red = 71; colors[14].green = 71; colors[14].blue = 235;; 81 colors[15].red = 117; colors[15].green = 117; colors[15].blue = 240;; 82 colors[16].red = 138; colors[16].green = 138; colors[16].blue = 15;; 83 colors[17].red = 184; colors[17].green = 184; colors[17].blue = 20;; 84 colors[18].red = 235; colors[18].green = 235; colors[18].blue = 71;; 85 colors[19].red = 240; colors[19].green = 240; colors[19].blue = 117;; 86 colors[20].red = 138; colors[20].green = 15; colors[20].blue = 138;; 87 colors[21].red = 184; colors[21].green = 20; colors[21].blue = 184;; 88 colors[22].red = 235; colors[22].green = 71; colors[22].blue = 235;; 89 colors[23].red = 240; colors[23].green = 117; colors[23].blue = 240;; 90 colors[24].red = 15; colors[24].green = 138; colors[24].blue = 138;; 91 colors[25].red = 20; colors[25].green = 184; colors[25].blue = 184;; 92 colors[26].red = 71; colors[26].green = 235; colors[26].blue = 235;; 93 colors[27].red = 117; colors[27].gr,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/X3DBuffer_8c_source.html:2615,green,green,2615,doc/master/X3DBuffer_8c_source.html,https://root.cern,https://root.cern/doc/master/X3DBuffer_8c_source.html,1,['green'],['green']
Energy Efficiency,"; 696 if (x >= 0) {; 697 i = int(x + 0.5);; 698 if ( i & 1 && x + 0.5 == T(i) ) i--;; 699 } else {; 700 i = int(x - 0.5);; 701 if ( i & 1 && x - 0.5 == T(i) ) i++;; 702 }; 703 return i;; 704}; 705 ; 706////////////////////////////////////////////////////////////////////////////////; 707/// Returns the base-e exponential function of x, which is e raised to the power `x`.; 708 ; 709inline Double_t TMath::Exp(Double_t x); 710 { return exp(x); }; 711 ; 712////////////////////////////////////////////////////////////////////////////////; 713/// Returns the result of multiplying `x` (the significant) by 2 raised to the power of `exp` (the exponent).; 714 ; 715inline Double_t TMath::Ldexp(Double_t x, Int_t exp); 716 { return ldexp(x, exp); }; 717 ; 718////////////////////////////////////////////////////////////////////////////////; 719/// Returns `x` raised to the power `y`.; 720 ; 721inline LongDouble_t TMath::Power(LongDouble_t x, LongDouble_t y); 722 { return std::pow(x,y); }; 723 ; 724////////////////////////////////////////////////////////////////////////////////; 725/// Returns `x` raised to the power `y`.; 726 ; 727inline LongDouble_t TMath::Power(LongDouble_t x, Long64_t y); 728 { return std::pow(x,(LongDouble_t)y); }; 729 ; 730////////////////////////////////////////////////////////////////////////////////; 731/// Returns `x` raised to the power `y`.; 732 ; 733inline LongDouble_t TMath::Power(Long64_t x, Long64_t y); 734 { return std::pow(x,y); }; 735 ; 736////////////////////////////////////////////////////////////////////////////////; 737/// Returns `x` raised to the power `y`.; 738 ; 739inline Double_t TMath::Power(Double_t x, Double_t y); 740 { return pow(x, y); }; 741 ; 742////////////////////////////////////////////////////////////////////////////////; 743/// Returns `x` raised to the power `y`.; 744 ; 745inline Double_t TMath::Power(Double_t x, Int_t y) {; 746#ifdef R__ANSISTREAM; 747 return std::pow(x, y);; 748#else; 749 return pow(x, (Double_t) y);; 750#en",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMath_8h_source.html:27276,power,power,27276,doc/master/TMath_8h_source.html,https://root.cern,https://root.cern/doc/master/TMath_8h_source.html,1,['power'],['power']
Energy Efficiency,"; 916 ; 917 void insert(iterator I, std::initializer_list<T> IL) { insert(I, IL.begin(), IL.end()); }; 918 ; 919 template <typename... ArgTypes>; 920 reference emplace_back(ArgTypes &&...Args); 921 {; 922 if (R__unlikely(this->size() >= this->capacity())); 923 this->grow();; 924 ::new ((void *)this->end()) T(std::forward<ArgTypes>(Args)...);; 925 this->set_size(this->size() + 1);; 926 return this->back();; 927 }; 928 ; 929 RVecImpl &operator=(const RVecImpl &RHS);; 930 ; 931 RVecImpl &operator=(RVecImpl &&RHS);; 932};; 933 ; 934template <typename T>; 935void RVecImpl<T>::swap(RVecImpl<T> &RHS); 936{; 937 if (this == &RHS); 938 return;; 939 ; 940 // We can only avoid copying elements if neither vector is small.; 941 if (!this->isSmall() && !RHS.isSmall()) {; 942 std::swap(this->fBeginX, RHS.fBeginX);; 943 std::swap(this->fSize, RHS.fSize);; 944 std::swap(this->fCapacity, RHS.fCapacity);; 945 return;; 946 }; 947 ; 948 // This block handles the swap of a small and a non-owning vector; 949 // It is more efficient to first move the non-owning vector, hence the 2 cases; 950 if (this->isSmall() && !RHS.Owns()) { // the right vector is non-owning; 951 RVecImpl<T> temp(0);; 952 temp = std::move(RHS);; 953 RHS = std::move(*this);; 954 *this = std::move(temp);; 955 return;; 956 } else if (RHS.isSmall() && !this->Owns()) { // the left vector is non-owning; 957 RVecImpl<T> temp(0);; 958 temp = std::move(*this);; 959 *this = std::move(RHS);; 960 RHS = std::move(temp);; 961 return;; 962 }; 963 ; 964 if (RHS.size() > this->capacity()); 965 this->grow(RHS.size());; 966 if (this->size() > RHS.capacity()); 967 RHS.grow(this->size());; 968 ; 969 // Swap the shared elements.; 970 size_t NumShared = this->size();; 971 if (NumShared > RHS.size()); 972 NumShared = RHS.size();; 973 for (size_type i = 0; i != NumShared; ++i); 974 std::iter_swap(this->begin() + i, RHS.begin() + i);; 975 ; 976 // Copy over the extra elts.; 977 if (this->size() > RHS.size()) {; 978 size_t EltDiff = this->size()",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RVec_8hxx_source.html:33244,efficient,efficient,33244,doc/master/RVec_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html,2,['efficient'],['efficient']
Energy Efficiency,"; : Creating xml weight file: ␛[0;36mdataset/weights/TMVAClassification_CutsD.weights.xml␛[0m; : Creating standalone class: ␛[0;36mdataset/weights/TMVAClassification_CutsD.class.C␛[0m; : TMVAC.root:/dataset/Method_Cuts/CutsD; Factory : Training finished; : ; Factory : Train method: Likelihood for Classification; : ; : ; : ␛[1m================================================================␛[0m; : ␛[1mH e l p f o r M V A m e t h o d [ Likelihood ] :␛[0m; : ; : ␛[1m--- Short description:␛[0m; : ; : The maximum-likelihood classifier models the data with probability ; : density functions (PDF) reproducing the signal and background; : distributions of the input variables. Correlations among the ; : variables are ignored.; : ; : ␛[1m--- Performance optimisation:␛[0m; : ; : Required for good performance are decorrelated input variables; : (PCA transformation via the option ""VarTransform=Decorrelate""; : may be tried). Irreducible non-linear correlations may be reduced; : by precombining strongly correlated input variables, or by simply; : removing one of the variables.; : ; : ␛[1m--- Performance tuning via configuration options:␛[0m; : ; : High fidelity PDF estimates are mandatory, i.e., sufficient training ; : statistics is required to populate the tails of the distributions; : It would be a surprise if the default Spline or KDE kernel parameters; : provide a satisfying fit to the data. The user is advised to properly; : tune the events per bin and smooth options in the spline cases; : individually per variable. If the KDE kernel is used, the adaptive; : Gaussian kernel may lead to artefacts, so please always also try; : the non-adaptive one.; : ; : All tuning parameters must be adjusted individually for each input; : variable!; : ; : <Suppress this message by specifying ""!H"" in the booking option>; : ␛[1m================================================================␛[0m; : ; : Filling reference histograms; : Building PDF out of reference histograms; : Elapsed time for t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAClassification_8C.html:28250,reduce,reduced,28250,doc/master/TMVAClassification_8C.html,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html,1,['reduce'],['reduced']
Energy Efficiency,"; ; // Let's not look at another example: a power law \f[x^a\f].; RooRealVar a{""a"", ""a"", -0.3, -5.0, 5.0};; RooPowerSum powerlaw{""powerlaw"", ""powerlaw"", x, RooConst(1.0), a};; std::unique_ptr<RooAbsData> powerlawData{generateBinnedAsimov(powerlaw, x, 10000)};; ; // Again, if you do a vanilla fit, you'll get a bias; std::unique_ptr<RooFitResult> fit3{powerlaw.fitTo(*powerlawData, Save(), PrintLevel(-1), SumW2Error(false))};; fit3->Print();; ; // This time, the bias is not the same factor in each bin! This means our; // trick by sampling the integral in the same way doesn't cancel out the; // bias completely. The average bias is canceled, but there are per-bin; // biases that remain. Still, this method has some value: it is cheaper than; // rigurously correcting the bias by integrating the pdf in each bin. So if; // you know your per-bin bias variations are small or performance is an; // issue, this approach can be sufficient.; enableBinIntegrator(powerlaw, x.numBins());; std::unique_ptr<RooFitResult> fit4{powerlaw.fitTo(*powerlawData, Save(), PrintLevel(-1), SumW2Error(false))};; fit4->Print();; disableBinIntegrator(powerlaw);; ; // To get rid of the binning effects in the general case, one can use the; // IntegrateBins() command argument. Now, the pdf is not evaluated at the; // bin centers, but numerically integrated over each bin and divided by the; // bin width. The parameter for IntegrateBins() is the required precision; // for the numeric integrals. This is computationally expensive, but the; // bias is now not a problem anymore.; std::unique_ptr<RooFitResult> fit5{; powerlaw.fitTo(*powerlawData, IntegrateBins(1e-3), Save(), PrintLevel(-1), SumW2Error(false))};; fit5->Print();; ; // Improving numerical stability; // -----------------------------; ; // There is one more problem with binned fits that is related to the binning; // effects because often, a binned fit is affected by both problems.; //; // The issue is numerical stability for fits with a greatly diffe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf614__binned__fit__problems_8C.html:5147,power,powerlaw,5147,doc/master/rf614__binned__fit__problems_8C.html,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8C.html,1,['power'],['powerlaw']
Energy Efficiency,"; ; void tree2w(); {; //create a Tree file tree2.root; ; //create the file, the Tree and a few branches with; //a subset of gctrak; TFile f(""tree2.root"",""recreate"");; TTree t2(""t2"",""a Tree with data from a fake Geant3"");; Gctrak_t gstep;; t2.Branch(""vect"",gstep.vect,""vect[7]/F"");; t2.Branch(""getot"",&gstep.getot);; t2.Branch(""gekin"",&gstep.gekin);; t2.Branch(""nmec"",&gstep.nmec);; t2.Branch(""lmec"",gstep.lmec,""lmec[nmec]/I"");; t2.Branch(""destep"",&gstep.destep);; t2.Branch(""pid"",&gstep.pid);; ; //Initialize particle parameters at first point; Float_t px,py,pz,p,charge=0;; Float_t vout[7];; Float_t mass = 0.137;; Bool_t newParticle = kTRUE;; gstep.step = 0.1;; gstep.destep = 0;; gstep.nmec = 0;; gstep.pid = 0;; ; //transport particles; for (Int_t i=0;i<10000;i++) {; //generate a new particle if necessary; if (newParticle) {; px = gRandom->Gaus(0,.02);; py = gRandom->Gaus(0,.02);; pz = gRandom->Gaus(0,.02);; p = TMath::Sqrt(px*px+py*py+pz*pz);; charge = 1; if (gRandom->Rndm() < 0.5) charge = -1;; gstep.pid += 1;; gstep.vect[0] = 0;; gstep.vect[1] = 0;; gstep.vect[2] = 0;; gstep.vect[3] = px/p;; gstep.vect[4] = py/p;; gstep.vect[5] = pz/p;; gstep.vect[6] = p*charge;; gstep.getot = TMath::Sqrt(p*p + mass*mass);; gstep.gekin = gstep.getot - mass;; newParticle = kFALSE;; }; ; // fill the Tree with current step parameters; t2.Fill();; ; //transport particle in magnetic field; helixStep(gstep.step, gstep.vect, vout); //make one step; ; //apply energy loss; gstep.destep = gstep.step*gRandom->Gaus(0.0002,0.00001);; gstep.gekin -= gstep.destep;; gstep.getot = gstep.gekin + mass;; gstep.vect[6] = charge*TMath::Sqrt(gstep.getot*gstep.getot - mass*mass);; gstep.vect[0] = vout[0];; gstep.vect[1] = vout[1];; gstep.vect[2] = vout[2];; gstep.vect[3] = vout[3];; gstep.vect[4] = vout[4];; gstep.vect[5] = vout[5];; gstep.nmec = (Int_t)(5*gRandom->Rndm());; for (Int_t l=0;l<gstep.nmec;l++) gstep.lmec[l] = l;; if (gstep.gekin < 0.001) newParticle = kTRUE;; if (TMath::Abs(gstep.vect[2]) > 30) n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tree2_8C.html:3245,charge,charge,3245,doc/master/tree2_8C.html,https://root.cern,https://root.cern/doc/master/tree2_8C.html,1,['charge'],['charge']
Energy Efficiency,"; Class Index; Class Hierarchy. Search. Source:; header file. viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Fit::BinData. class ROOT::Fit::BinData: public ROOT::Fit::FitData. Class describing the binned data sets :; vectors of x coordinates, y values and optionally error on y values and error on coordinates; The dimension of the coordinate is free; There are 4 different options:; - only coordinates and values (for binned likelihood fits) : kNoError; - coordinate, values and error on values (for normal least square fits) : kValueError; - coordinate, values, error on values and coordinates (for effective least square fits) : kCoordError; - corrdinate, values, error on coordinates and asymmettric error on valyes : kAsymError. In addition there is the option to construct Bindata copying the data in (using the DataVector class); or using pointer to external data (DataWrapper) class.; In general is found to be more efficient to copy the data.; In case of really large data sets for limiting memory consumption then the other option can be used; Specialized constructor exists for data up to 3 dimensions. When the data are copying in the number of points can be set later (or re-set) using Initialize and; the data are inserted one by one using the Add method.; It is mandatory to set the size before using the Add method. @ingroup FitData. Function Members (Methods); public:. virtual~BinData(); voidAdd(double x, double y); voidAdd(const double* x, double val); voidAdd(double x, double y, double ey); voidAdd(const double* x, double val, double eval); voidAdd(double x, double y, double ex, double ey); voidAdd(const double* x, double val, const double* ex, double eval); voidAdd(double x, double y, double ex, double eyl, double eyh); voidAdd(const double* x, double val, const double* ex, double elval, double ehval); voidAddBinUpEdge(const double* xup); ROOT::Fit::BinDataBinData(const ROOT::Fit::BinData&)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Fit__BinData.html:1052,efficient,efficient,1052,root/html528/ROOT__Fit__BinData.html,https://root.cern,https://root.cern/root/html528/ROOT__Fit__BinData.html,1,['efficient'],['efficient']
Energy Efficiency,"; Class Index; Class Hierarchy. Search. Source:; header file. viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Fit::BinData. class ROOT::Fit::BinData: public ROOT::Fit::FitData. Class describing the binned data sets :; vectors of x coordinates, y values and optionally error on y values and error on coordinates; The dimension of the coordinate is free; There are 4 different options:; - only coordinates and values (for binned likelihood fits) : kNoError; - coordinate, values and error on values (for normal least square fits) : kValueError; - coordinate, values, error on values and coordinates (for effective least square fits) : kCoordError; - corrdinate, values, error on coordinates and asymmettric error on valyes : kAsymError. In addition there is the option to construct Bindata copying the data in (using the DataVector class); or using pointer to external data (DataWrapper) class.; In general is found to be more efficient to copy the data.; In case of really large data sets for limiting memory consumption then the other option can be used; Specialized constructor exists for data up to 3 dimensions. When the data are copying in the number of points can be set later (or re-set) using Initialize and; the data are inserted one by one using the Add method.; It is mandatory to set the size before using the Add method. @ingroup FitData. Function Members (Methods); public:. virtual~BinData(); voidAdd(double x, double y); voidAdd(const double* x, double val); voidAdd(double x, double y, double ey); voidAdd(const double* x, double val, double eval); voidAdd(double x, double y, double ex, double ey); voidAdd(const double* x, double val, const double* ex, double eval); voidAdd(double x, double y, double ex, double eyl, double eyh); voidAddBinUpEdge(const double* binwidth); ROOT::Fit::BinDataBinData(const ROOT::Fit::BinData&); ROOT::Fit::BinDataBinData(unsigned int maxpoints = 0, unsigned int dim = 1, R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Fit__BinData.html:1052,efficient,efficient,1052,root/html526/ROOT__Fit__BinData.html,https://root.cern,https://root.cern/root/html526/ROOT__Fit__BinData.html,1,['efficient'],['efficient']
Energy Efficiency,"; Class for computing numerical derivative of a function. ; Presently this class is implemented only using the numerical derivatives algorithms provided by GSL using the implementation class ROOT::Math::GSLDerivator; This class does not support copying ; Definition at line 61 of file Derivator.h. Public Types; typedef double(* GSLFuncPointer) (double, void *);  signature for function pointers used by GSL ;  . Public Member Functions;  Derivator ();  Empty Construct for a Derivator class Need to set the function afterwards with Derivator::SetFunction. ;  ;  Derivator (const GSLFuncPointer &f, void *p=nullptr);  Construct using a GSL function pointer type. ;  ;  Derivator (const IGenFunction &f);  Construct using a ROOT::Math::IGenFunction interface. ;  ; virtual ~Derivator ();  destructor ;  ; double Eval (double x, double h=1E-8) const;  Computes the numerical derivative of a function f at a point x. ;  ; double EvalBackward (double x, double h=1E-8) const;  Computes the numerical derivative at a point x using an adaptive backward difference algorithm with a step size h. ;  ; double EvalCentral (double x, double h=1E-8) const;  Computes the numerical derivative at a point x using an adaptive central difference algorithm with a step size h. ;  ; double EvalForward (double x, double h=1E-8) const;  Computes the numerical derivative at a point x using an adaptive forward difference algorithm with a step size h. ;  ; void SetFunction (const GSLFuncPointer &f, void *p=nullptr);  Set the function f for evaluating the derivative using a GSL function pointer type. ;  ; void SetFunction (const IGenFunction &f);  Set the function for calculating the derivatives. ;  . Private Member Functions;  Derivator (const Derivator &);  ; Derivator & operator= (const Derivator &);  . — Static methods —; This methods don't require to use a Derivator object, and are designed to be used in fast calculation.; Error and status code cannot be retrieved in this case . GSLDerivator * fDerivator;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1Derivator.html:1396,adapt,adaptive,1396,doc/master/classROOT_1_1Math_1_1Derivator.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1Derivator.html,1,['adapt'],['adaptive']
Energy Efficiency,"; Definition at line 192 of file MethodMLP.h. ◆ fBPMode. EBPTrainingMode TMVA::MethodMLP::fBPMode. private . backprop learning mode (sequential or batch) ; Definition at line 190 of file MethodMLP.h. ◆ fBpModeS. TString TMVA::MethodMLP::fBpModeS. private . backprop learning mode option string (sequential or batch) ; Definition at line 191 of file MethodMLP.h. ◆ fCalculateErrors. bool TMVA::MethodMLP::fCalculateErrors. private . compute inverse hessian matrix at the end of the training ; Definition at line 165 of file MethodMLP.h. ◆ fDecayRate. Double_t TMVA::MethodMLP::fDecayRate. private . decay rate for above learning rate ; Definition at line 189 of file MethodMLP.h. ◆ fDeviationsFromTargets. std::vector<std::pair<Float_t,Float_t> >* TMVA::MethodMLP::fDeviationsFromTargets. private . deviation from the targets, event weight ; Definition at line 204 of file MethodMLP.h. ◆ fEpochMon. Bool_t TMVA::MethodMLP::fEpochMon. private . create and fill epoch-wise monitoring histograms (makes outputfile big!) ; Definition at line 194 of file MethodMLP.h. ◆ fGA_nsteps. Int_t TMVA::MethodMLP::fGA_nsteps. private . GA settings: number of steps. ; Definition at line 197 of file MethodMLP.h. ◆ fGA_preCalc. Int_t TMVA::MethodMLP::fGA_preCalc. private . GA settings: number of pre-calc steps. ; Definition at line 198 of file MethodMLP.h. ◆ fGA_SC_factor. Double_t TMVA::MethodMLP::fGA_SC_factor. private . GA settings: SC_factor. ; Definition at line 201 of file MethodMLP.h. ◆ fGA_SC_rate. Int_t TMVA::MethodMLP::fGA_SC_rate. private . GA settings: SC_rate. ; Definition at line 200 of file MethodMLP.h. ◆ fGA_SC_steps. Int_t TMVA::MethodMLP::fGA_SC_steps. private . GA settings: SC_steps. ; Definition at line 199 of file MethodMLP.h. ◆ fgPRINT_BATCH. const Bool_t TMVA::MethodMLP::fgPRINT_BATCH = kFALSE. staticprivate . debug flags ; Definition at line 217 of file MethodMLP.h. ◆ fgPRINT_ESTIMATOR_INC. const Int_t TMVA::MethodMLP::fgPRINT_ESTIMATOR_INC = 10. staticprivate . debug flags ; De",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodMLP.html:50813,monitor,monitoring,50813,doc/master/classTMVA_1_1MethodMLP.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodMLP.html,1,['monitor'],['monitoring']
Energy Efficiency,"; Definition at line 78 of file TGraphErrors.h. ◆ ComputeRange(). void TGraphErrors::ComputeRange ; (; Double_t & ; xmin, . Double_t & ; ymin, . Double_t & ; xmax, . Double_t & ; ymax . ); const. overridevirtual . Compute range. ; Reimplemented from TGraph.; Definition at line 480 of file TGraphErrors.cxx. ◆ CopyAndRelease(). void TGraphErrors::CopyAndRelease ; (; Double_t ** ; newarrays, . Int_t ; ibegin, . Int_t ; iend, . Int_t ; obegin . ). overrideprotectedvirtual . Copy and release. ; Reimplemented from TGraph.; Definition at line 510 of file TGraphErrors.cxx. ◆ CopyPoints(). Bool_t TGraphErrors::CopyPoints ; (; Double_t ** ; arrays, . Int_t ; ibegin, . Int_t ; iend, . Int_t ; obegin . ). overrideprotectedvirtual . Copy errors from fEX and fEY to arrays[0] and arrays[1] or to fEX and fEY if arrays == 0 and ibegin != iend. ; Reimplemented from TGraph.; Definition at line 532 of file TGraphErrors.cxx. ◆ CtorAllocate(). Bool_t TGraphErrors::CtorAllocate ; (; ). protected . Constructor allocate. ; Note: This function should be called only from the constructor since it does not delete previously existing arrays. ; Definition at line 557 of file TGraphErrors.cxx. ◆ DeclFileName(). static const char * TGraphErrors::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 78 of file TGraphErrors.h. ◆ DoMerge(). Bool_t TGraphErrors::DoMerge ; (; const TGraph * ; g). overrideprotectedvirtual . Protected function to perform the merge operation of a graph with errors. ; Reimplemented from TGraph.; Definition at line 573 of file TGraphErrors.cxx. ◆ FillZero(). void TGraphErrors::FillZero ; (; Int_t ; begin, . Int_t ; end, . Bool_t ; from_ctor = kTRUE . ). overrideprotectedvirtual . Set zero values for point arrays in the range [begin, end]. ; Reimplemented from TGraph.; Definition at line 598 of file TGraphErrors.cxx. ◆ GetErrorX(). Double_t TGraphErrors::GetErrorX ; (; Int_t ; bin); const. overridevirtual . It return",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGraphErrors.html:40635,allocate,allocate,40635,doc/master/classTGraphErrors.html,https://root.cern,https://root.cern/doc/master/classTGraphErrors.html,1,['allocate'],['allocate']
Energy Efficiency,"; Definition at line 93 of file Derivator.cxx. ◆ Eval() [4/5]. double ROOT::Math::Derivator::Eval ; (; IParamFunction & ; f, . double ; x, . const double * ; p, . unsigned int ; ipar = 0, . double ; h = 1E-8 . ). static . Evaluate the derivative with respect a parameter for one-dim parameteric function at the point ( x,p[]) with respect the parameter p_ipar. ; Definition at line 134 of file Derivator.cxx. ◆ Eval() [5/5]. double ROOT::Math::Derivator::Eval ; (; IParamMultiFunction & ; f, . const double * ; x, . const double * ; p, . unsigned int ; ipar = 0, . double ; h = 1E-8 . ). static . Evaluate the derivative with respect a parameter for a multi-dim parameteric function at the point ( x[],p[]) with respect the parameter p_ipar. ; Definition at line 143 of file Derivator.cxx. ◆ EvalBackward() [1/2]. double ROOT::Math::Derivator::EvalBackward ; (; const IGenFunction & ; f, . double ; x, . double ; h = 1E-8 . ). static . Computes the numerical derivative of a function f at a point x using an adaptive backward difference algorithm with a step size h. ; The function is evaluated only at points less than x and at x itself ; Definition at line 122 of file Derivator.cxx. ◆ EvalBackward() [2/2]. double ROOT::Math::Derivator::EvalBackward ; (; double ; x, . double ; h = 1E-8 . ); const. Computes the numerical derivative at a point x using an adaptive backward difference algorithm with a step size h. ; The function is evaluated only at points less than x and at x itself. ; Definition at line 105 of file Derivator.cxx. ◆ EvalCentral() [1/2]. double ROOT::Math::Derivator::EvalCentral ; (; const IGenFunction & ; f, . double ; x, . double ; h = 1E-8 . ). static . Computes the numerical derivative of a function f at a point x using an adaptive central difference algorithm with a step size h. ; Definition at line 114 of file Derivator.cxx. ◆ EvalCentral() [2/2]. double ROOT::Math::Derivator::EvalCentral ; (; double ; x, . double ; h = 1E-8 . ); const. Computes the numerical deriv",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1Derivator.html:7694,adapt,adaptive,7694,doc/master/classROOT_1_1Math_1_1Derivator.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1Derivator.html,1,['adapt'],['adaptive']
Energy Efficiency,"; Handbook of Mathematical Functions by Abramowitz and Stegun, formula 6.5.1 on page 260 .; Its normalization is such that TMath::Gamma(a,+infinity) = 1 . --- Nve 14-nov-1998 UU-SAP Utrecht. Double_t BreitWigner(Double_t x, Double_t mean = 0, Double_t gamma = 1); Calculate a Breit Wigner function with mean and gamma. Double_t Gaus(Double_t x, Double_t mean = 0, Double_t sigma = 1, Bool_t norm = kFALSE); Calculate a gaussian function with mean and sigma.; If norm=kTRUE (default is kFALSE) the result is divided; by sqrt(2*Pi)*sigma. Double_t Landau(Double_t x, Double_t mpv = 0, Double_t sigma = 1, Bool_t norm = kFALSE); The LANDAU function.; mpv is a location parameter and correspond approximatly to the most probable value; and sigma is a scale parameter (not the sigma of the full distribution which is not defined); Note that for mpv=0 and sigma=1 (default values) the exact location of the maximum of the distribution (most proble value) is at; x = -0.22278; This function has been adapted from the CERNLIB routine G110 denlan.; If norm=kTRUE (default is kFALSE) the result is divided by sigma. Double_t LnGamma(Double_t z); Computation of ln[gamma(z)] for all z. C.Lanczos, SIAM Journal of Numerical Analysis B1 (1964), 86. The accuracy of the result is better than 2e-10. --- Nve 14-nov-1998 UU-SAP Utrecht. Float_t Normalize(Float_t v[3]); Normalize a vector v in place.; Returns the norm of the original vector. Double_t Normalize(Double_t v[3]); Normalize a vector v in place.; Returns the norm of the original vector.; This implementation (thanks Kevin Lynch <krlynch@bu.edu>) is protected; against possible overflows. Double_t Poisson(Double_t x, Double_t par); compute the Poisson distribution function for (x,par); The Poisson PDF is implemented by means of Euler's Gamma-function; (for the factorial), so for all integer arguments it is correct.; BUT for non-integer values it IS NOT equal to the Poisson distribution.; see TMath::PoissonI to get a non-smooth function.; Note that",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMath.html:14318,adapt,adapted,14318,root/html528/TMath.html,https://root.cern,https://root.cern/root/html528/TMath.html,3,['adapt'],['adapted']
Energy Efficiency,"; It shows all the classes derived from the base class TH1. /*. */. The ClassTree class uses the services of the class TPaveClass to; show the class names. By clicking with the right mouse button in; one TPaveClass object, one can invoke the following functions of TClassTree:; - ShowLinks(option) with by default option = ""HMR""; - Draw(classes). By default the class drawn is the one being pointed; - ShowClassesUsedBy(classes) (by default the pointed class); - ShowClassesUsing(classes) (by default the pointed class). The following picture has been generated with the following statements; TClassTree tc1(""tc1"",""TObject"");; tc1.SetShowLinks(""HMR"");. /*. */. Note that in case of embedded classes or pointers to classes,; the corresponding dashed lines or arrows respectively start; in the TPaveClass object at an X position reflecting the position; in the list of data members. - References by data members to other classes are show with a full red line; - Multiple inheritance is shown with a dashed blue line; - ""Has a"" relation is shown with a dotted cyan line; - References from code is shown by a full green line. Use TClassTree::SetSourceDir to specify the search path for source files.; By default the search path includes the ROOTSYS/src directory, the current; directory and the subdirectory src. The first time TClassTree::Draw is invoked, all the classes in the; current application are processed, including the parsing of the code; to find all classes referenced by the include statements.; This process may take a few seconds. The following commands will be; much faster. A TClassTree object may be saved in a Root file.; This object can be processed later by a Root program that ignores; the original classes. This interesting possibility allows to send; the class structure of an application to a colleague who does not have; your classes.; Example:; TFile f(""myClasses.root"",""recreate""); TClassTree *ct = new TClassTree(""ct"",""ATLF*""); ct->Write();; You can send at this point the fi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TClassTree.html:3321,green,green,3321,root/html526/TClassTree.html,https://root.cern,https://root.cern/root/html526/TClassTree.html,7,['green'],['green']
Energy Efficiency,"; Returns gVirtualX global. void GetWindowAttributes(Window_t id, WindowAttributes_t& attr); The WindowAttributes_t structure is set to default. Bool_t ParseColor(Colormap_t cmap, const char* cname, ColorStruct_t& color); Looks up the string name of a color ""cname"" with respect to the screen; associated with the specified colormap. It returns the exact color value.; If the color name is not in the Host Portable Character Encoding,; the result is implementation dependent. cmap - the colormap; cname - the color name string; use of uppercase or lowercase; does not matter; color - returns the exact color value for later use. The ColorStruct_t structure is set to default. Let system think we; could parse color. Bool_t AllocColor(Colormap_t cmap, ColorStruct_t& color); Allocates a read-only colormap entry corresponding to the closest RGB; value supported by the hardware. If no cell could be allocated it; returns kFALSE, otherwise kTRUE. The pixel value is set to default. Let system think we could allocate; color. cmap - the colormap; color - specifies and returns the values actually used in the cmap. void QueryColor(Colormap_t cmap, ColorStruct_t& color); Returns the current RGB value for the pixel in the ""color"" structure. The color components are set to default. cmap - the colormap; color - specifies and returns the RGB values for the pixel specified; in the structure. void NextEvent(Event_t& event); The ""event"" is set to default event.; This method however, should never be called. void GetPasteBuffer(Window_t id, Atom_t atom, TString& text, Int_t& nchar, Bool_t del); Gets contents of the paste buffer ""atom"" into the string ""text"".; (nchar = number of characters) If ""del"" is true deletes the paste; buffer afterwards. Bool_t Init(void* display = 0); Initializes the X system. Returns kFALSE in case of failure.; It is implementation dependent. void ClearWindow(); Clears the entire area of the current window. void CloseWindow(); Deletes current window. void ClosePixmap(); De",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualX.html:22372,allocate,allocate,22372,root/html528/TVirtualX.html,https://root.cern,https://root.cern/root/html528/TVirtualX.html,6,['allocate'],['allocate']
Energy Efficiency,"; See WriteQueryLog for the descripition of the structure sent for monitoring; when fMonitorPerPacket is kTRUE. void FileEvent(const char* slave, const char* slavename, const char* nodename, const char* filename, Bool_t isStart); File event. void FileOpenEvent(TFile* file, const char* filename, Double_t start); Open file event. void FileReadEvent(TFile* file, Int_t len, Double_t start); Read file event. void UnzipEvent(TObject* tree, Long64_t pos, Double_t start, Int_t complen, Int_t objlen); Record TTree file unzip event.; start is the TimeStamp before unzip; pos is where in the file the compressed buffer came from; complen is the length of the compressed buffer; objlen is the length of the de-compressed buffer. void RateEvent(Double_t proctime, Double_t deltatime, Long64_t eventsprocessed, Long64_t bytesRead); Rate event. void SetBytesRead(Long64_t num); Set number of bytes read. Long64_t GetBytesRead() const; Get number of bytes read. void WriteQueryLog(); Send to the connected monitoring servers information related to this query.; The information is of three types: 'summary', 'dataset' and 'files'.; Actual 'table' formatting is done by the relevant sender, implementation of; TProofMonSender, where the details are given. void Setup(TList* input); Setup the PROOF input list with requested statistics and tracing options. void Start(TList* input, TList* output); Initialize PROOF statistics run. void Stop(); Terminate the PROOF statistics run. void SetMemValues(); Record memory usage. void GetMemValues(Long_t& vmax, Long_t& rmax); Get memory usage. TPerfStats(TList* input, TList* output). void SetNumEvents(Long64_t num); { fNumEvents = num; }. Long64_t GetNumEvents() const; { return fNumEvents; }. » Author: Kristjan Gulbrandsen 11/05/04 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/proofplayer:$Id$ » Last generated: 2015-06-02 16:27; This page has been automatically generated. For comments or suggestions regarding the documentation",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TPerfStats.html:10535,monitor,monitoring,10535,root/html604/TPerfStats.html,https://root.cern,https://root.cern/root/html604/TPerfStats.html,1,['monitor'],['monitoring']
Energy Efficiency,"; See WriteQueryLog for the descripition of the structure sent for monitoring; when fMonitorPerPacket is kTRUE. void FileEvent(const char* slave, const char* slavename, const char* nodename, const char* filename, Bool_t isStart); File event. void FileOpenEvent(TFile* file, const char* filename, Double_t start); Open file event. void FileReadEvent(TFile* file, Int_t len, Double_t start); Read file event. void UnzipEvent(TObject* tree, Long64_t pos, Double_t start, Int_t complen, Int_t objlen); Record TTree file unzip event.; start is the TimeStamp before unzip; pos is where in the file the compressed buffer came from; complen is the length of the compressed buffer; objlen is the length of the de-compressed buffer. void RateEvent(Double_t proctime, Double_t deltatime, Long64_t eventsprocessed, Long64_t bytesRead); Rate event. void SetBytesRead(Long64_t num); Set number of bytes read. Long64_t GetBytesRead() const; Get number of bytes read. void WriteQueryLog(); Send to the connected monitoring servers information related to this query.; The information is of three types: 'summary', 'dataset' and 'files'.; Actual 'table' formatting is done by the relevant sender, implementation of; TProofMonSender, where the details are given. void Setup(TList* input); Setup the PROOF input list with requested statistics and tracing options. void Start(TList* input, TList* output); Initialize PROOF statistics run. void Stop(); Terminate the PROOF statistics run. void SetMemValues(); Record memory usage. void GetMemValues(Long_t& vmax, Long_t& rmax); Get memory usage. TPerfStats(TList* input, TList* output). void SetNumEvents(Long64_t num); { fNumEvents = num; }. Long64_t GetNumEvents() const; { return fNumEvents; }. » Author: Kristjan Gulbrandsen 11/05/04 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/proofplayer:$Id$ » Last generated: 2015-06-30 15:25; This page has been automatically generated. For comments or suggestions regarding the documentation",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TPerfStats.html:10535,monitor,monitoring,10535,root/html602/TPerfStats.html,https://root.cern,https://root.cern/root/html602/TPerfStats.html,1,['monitor'],['monitoring']
Energy Efficiency,"; See WriteQueryLog for the descripition of the structure sent for monitoring; when fMonitorPerPacket is kTRUE. void FileEvent(const char* slave, const char* slavename, const char* nodename, const char* filename, Bool_t isStart); File event. void FileOpenEvent(TFile* file, const char* filename, Double_t start); Open file event. void FileReadEvent(TFile* file, Int_t len, Double_t start); Read file event. void UnzipEvent(TObject* tree, Long64_t pos, Double_t start, Int_t complen, Int_t objlen); Record TTree file unzip event.; start is the TimeStamp before unzip; pos is where in the file the compressed buffer came from; complen is the length of the compressed buffer; objlen is the length of the de-compressed buffer. void RateEvent(Double_t proctime, Double_t deltatime, Long64_t eventsprocessed, Long64_t bytesRead); Rate event. void SetBytesRead(Long64_t num); Set number of bytes read. Long64_t GetBytesRead() const; Get number of bytes read. void WriteQueryLog(); Send to the connected monitoring servers information related to this query.; The information is of three types: 'summary', 'dataset' and 'files'.; Actual 'table' formatting is done by the relevant sender, implementation of; TProofMonSender, where the details are given. void Setup(TList* input); Setup the PROOF input list with requested statistics and tracing options. void Start(TList* input, TList* output); Initialize PROOF statistics run. void Stop(); Terminate the PROOF statistics run. void SetMemValues(); Record memory usage. void GetMemValues(Long_t& vmax, Long_t& rmax); Get memory usage. void SetNumEvents(Long64_t num); { fNumEvents = num; }. Long64_t GetNumEvents() const; { return fNumEvents; }. » Author: Kristjan Gulbrandsen 11/05/04 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/proofplayer:$Id$ » Last generated: 2015-03-14 16:46; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TPerfStats.html:9626,monitor,monitoring,9626,root/html534/TPerfStats.html,https://root.cern,https://root.cern/root/html534/TPerfStats.html,1,['monitor'],['monitoring']
Energy Efficiency,"; TBufferIO::MapObjectvoid MapObject(const TObject *obj, UInt_t offset=1) overrideAdd object to the fMap container.Definition TBufferIO.cxx:163; TBufferIO::ResetMapvoid ResetMap() overrideDelete existing fMap and reset map counter.Definition TBufferIO.cxx:288; TBufferJSON::ExportToFilestatic Int_t ExportToFile(const char *filename, const TObject *obj, const char *option=nullptr)Convert object into JSON and store in text file Returns size of the produce file Used in TObject::Sav...Definition TBufferJSON.cxx:751; TBufferBuffer base class used for serializing objects.Definition TBuffer.h:43; TBuffer::kWrite@ kWriteDefinition TBuffer.h:73; TBuffer::SetBufferOffsetvoid SetBufferOffset(Int_t offset=0)Definition TBuffer.h:93; TBuffer::SetReadModevoid SetReadMode()Set buffer in read mode.Definition TBuffer.cxx:302; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClass::Newvoid * New(ENewType defConstructor=kClassNew, Bool_t quiet=kFALSE) constReturn a pointer to a newly allocated object of this class.Definition TClass.cxx:5045; TClass::GetDirectoryAutoAddROOT::DirAutoAdd_t GetDirectoryAutoAdd() constReturn the wrapper around the directory auto add function.Definition TClass.cxx:7554; TClass::BuildRealDatavoid BuildRealData(void *pointer=nullptr, Bool_t isTransient=kFALSE)Build a full list of persistent data members.Definition TClass.cxx:2098; TClass::IsTObjectBool_t IsTObject() constReturn kTRUE is the class inherits from TObject.Definition TClass.cxx:6005; TClass::GetStreamerInfoTVirtualStreamerInfo * GetStreamerInfo(Int_t version=0, Bool_t isTransient=kFALSE) constreturns a pointer to the TVirtualStreamerInfo object for version If the object does not exist,...Definition TClass.cxx:4666; TClass::GetBaseClassOffsetInt_t GetBaseClassOffset(const TClass *toBase, void *address=nullptr, bool isDerivedObject=true)Definition TClass.cxx:2858; TClass::GetCollectionProxyTVirtualCollectionProxy * GetCollectionProxy() c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TDirectoryFile_8cxx_source.html:80830,allocate,allocated,80830,doc/master/TDirectoryFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TDirectoryFile_8cxx_source.html,1,['allocate'],['allocated']
Energy Efficiency,"; TGraph2D::SetHistogramvirtual void SetHistogram(TH2 *h, Option_t *option="""")Sets the histogram to be filled.Definition TGraph2D.cxx:1568; TGraph2D::SetMaximumvoid SetMaximum(Double_t maximum=-1111)Set maximum.Definition TGraph2D.cxx:1619; TGraph2D::Addvirtual void Add(TF2 *f, Double_t c1=1)Performs the operation: z = z + c1*f(x,y,z) Errors are not recalculated.Definition TGraph2D.cxx:642; TGraph2D::GetYmaxDouble_t GetYmax() constReturns the Y maximum.Definition TGraph2D.cxx:1175; TGraph2D::DistancetoPrimitiveInt_t DistancetoPrimitive(Int_t px, Int_t py) overrideComputes distance from point px,py to a graph.Definition TGraph2D.cxx:730; TGraph2D::SetDirectoryvirtual void SetDirectory(TDirectory *dir)By default when an 2D graph is created, it is added to the list of 2D graph objects in the current di...Definition TGraph2D.cxx:1544; TGraph2D::fDirectoryTDirectory * fDirectory!Pointer to directory holding this 2D graphDefinition TGraph2D.h:60; TGraph2D::Clearvoid Clear(Option_t *option="""") overrideFree all memory allocated by this object.Definition TGraph2D.cxx:681; TGraph2D::Scalevirtual void Scale(Double_t c1=1., Option_t *option=""z"")Multiply the values of a TGraph2D by a constant c1.Definition TGraph2D.cxx:1506; TGraph2D::DirectoryAutoAddvirtual void DirectoryAutoAdd(TDirectory *)Perform the automatic addition of the graph to the given directory.Definition TGraph2D.cxx:715; TGraph2D::CreateInterpolatorvoid CreateInterpolator(Bool_t oldInterp)Add a TGraphDelaunay in the list of the fHistogram's functions.Definition TGraph2D.cxx:968; TGraph2D::fNpyInt_t fNpyNumber of bins along Y in fHistogram.Definition TGraph2D.h:47; TGraph2D::fFunctionsTList * fFunctionsPointer to list of functions (fits and user)Definition TGraph2D.h:57; TGraph2D::SetPointvirtual void SetPoint(Int_t point, Double_t x, Double_t y, Double_t z)Sets point number n.Definition TGraph2D.cxx:1715; TGraph2D::Paintvoid Paint(Option_t *option="""") overridePaints this 2D graph with its current attributes.Defin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraph2D_8cxx_source.html:72777,allocate,allocated,72777,doc/master/TGraph2D_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraph2D_8cxx_source.html,1,['allocate'],['allocated']
Energy Efficiency,"; TMath::MedianDouble_t Median(Long64_t n, const T *a, const Double_t *w=nullptr, Long64_t *work=nullptr)Same as RMS.Definition TMath.h:1272; TMath::QuietNaNDouble_t QuietNaN()Returns a quiet NaN as defined by IEEE 754.Definition TMath.h:902; TMath::FloorDouble_t Floor(Double_t x)Rounds x downward, returning the largest integral value that is not greater than x.Definition TMath.h:680; TMath::ATanDouble_t ATan(Double_t)Returns the principal value of the arc tangent of x, expressed in radians.Definition TMath.h:640; TMath::CeilDouble_t Ceil(Double_t x)Rounds x upward, returning the smallest integral value that is not less than x.Definition TMath.h:668; TMath::MinElementT MinElement(Long64_t n, const T *a)Returns minimum of array a of length n.Definition TMath.h:960; TMath::LogDouble_t Log(Double_t x)Returns the natural logarithm of x.Definition TMath.h:756; TMath::SqrtDouble_t Sqrt(Double_t x)Returns the square root of x.Definition TMath.h:662; TMath::PowerLongDouble_t Power(LongDouble_t x, LongDouble_t y)Returns x raised to the power y.Definition TMath.h:721; TMath::MinShort_t Min(Short_t a, Short_t b)Returns the smallest of a and b.Definition TMathBase.h:198; TMath::Piconstexpr Double_t Pi()Definition TMath.h:37; TMath::AreEqualRelBool_t AreEqualRel(Double_t af, Double_t bf, Double_t relPrec)Comparing floating points.Definition TMath.h:426; TMath::AreEqualAbsBool_t AreEqualAbs(Double_t af, Double_t bf, Double_t epsilon)Comparing floating points.Definition TMath.h:418; TMath::KolmogorovProbDouble_t KolmogorovProb(Double_t z)Calculates the Kolmogorov distribution function,.Definition TMath.cxx:679; TMath::Sortvoid Sort(Index n, const Element *a, Index *index, Bool_t down=kTRUE)Sort the n elements of the array a of generic templated type Element.Definition TMathBase.h:431; TMath::BinarySearchLong64_t BinarySearch(Long64_t n, const T *array, T value)Binary search in an array of n values to locate value.Definition TMathBase.h:347; TMath::Log10Double_t Log10(Double_t x)Ret",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:476918,power,power,476918,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,1,['power'],['power']
Energy Efficiency,"; TString::ToUppervoid ToUpper()Change string to upper case.Definition TString.cxx:1195; TString::RemoveTString & Remove(Ssiz_t pos)Definition TString.h:685; TString::Formvoid Form(const char *fmt,...)Formats a string using a printf style format descriptor.Definition TString.cxx:2356; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; TText::PaintTextvirtual void PaintText(Double_t x, Double_t y, const char *text)Draw this text with new coordinates.Definition TText.cxx:752; bool; double; int; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; TMath::ACosDouble_t ACos(Double_t)Returns the principal value of the arc cosine of x, expressed in radians.Definition TMath.h:632; TMath::ASinDouble_t ASin(Double_t)Returns the principal value of the arc sine of x, expressed in radians.Definition TMath.h:624; TMath::PiOver2constexpr Double_t PiOver2()Definition TMath.h:51; TMath::LogDouble_t Log(Double_t x)Returns the natural logarithm of x.Definition TMath.h:756; TMath::SqrtDouble_t Sqrt(Double_t x)Returns the square root of x.Definition TMath.h:662; TMath::PowerLongDouble_t Power(LongDouble_t x, LongDouble_t y)Returns x raised to the power y.Definition TMath.h:721; TMath::MinShort_t Min(Short_t a, Short_t b)Returns the smallest of a and b.Definition TMathBase.h:198; TMath::CosDouble_t Cos(Double_t)Returns the cosine of an angle of x radians.Definition TMath.h:594; TMath::Piconstexpr Double_t Pi()Definition TMath.h:37; TMath::SinDouble_t Sin(Double_t)Returns the sine of an angle of x radians.Definition TMath.h:588; TMath::TanDouble_t Tan(Double_t)Returns the tangent of an angle of x radians.Definition TMath.h:600; TMath::AbsShort_t Abs(Short_t d)Returns the absolute value of parameter Short_t d.Definition TMathBase.h:123. graf2dgrafsrcTGraphPolargram.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:18 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphPolargram_8cxx_source.html:44888,power,power,44888,doc/master/TGraphPolargram_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphPolargram_8cxx_source.html,1,['power'],['power']
Energy Efficiency,"; TTimefPreviousEventTimeExecution time of the previously replayed event.; TRecorder*fRecorderReference to recorder (owner of this state) is kept in order to switch; Int_tfRegWinCounterCounter of registered windows when replaying; Bool_tfShowMouseCursorSpecifies if mouse cursor should be also replayed; TTimer*fTimerTimer used for replaying; Bool_tfWaitingForWindowSignalizes that we wait for a window to be registered in order; ULong64_tfWinWindow ID being currenty mapped; TTree*fWinTreeTTree with recorded windows (=registered during recording); Int_tfWinTreeEntriesNumber of registered windows during _recording_; TList*fWindowListList of TRecWinPair objects. Mapping of window IDs is stored here. Class Charts. Inheritance Chart:. TRecorderState. ←; TRecorderReplaying. Function documentation; TRecorderReplaying(const char* filename); Allocates all necessary data structures used for replaying; What is allocated here is deleted in destructor. ~TRecorderReplaying(); Closes all signal-slot connections; Frees all memory allocated in contructor. Bool_t Initialize(TRecorder* r, Bool_t showMouseCursor, TRecorder::EReplayModes mode); Initialization of data structures for replaying.; Start of replaying. Return value:; - kTRUE = everything is OK and replaying has begun; - kFALSE = non existing or invalid log file, replaying has not started. void RegisterWindow(Window_t w); Creates mapping for the newly registered window w and adds this; mapping to fWindowList. Called by signal whenever a new window is registered during replaying. The new window ID is mapped to the old one with the same number in the; list of registered windows.; It means that 1st new window is mapped to the 1st original,; 2nd to the 2nd, Nth new to the Nth original. Bool_t RemapWindowReferences(); All references to the old windows (IDs) in fNextEvent are replaced by; new ones according to the mappings in fWindowList. Bool_t FilterEvent(TRecGuiEvent* e). Bool_t PrepareNextEvent(); Finds the next event in log file to",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TRecorderReplaying.html:3789,allocate,allocated,3789,root/html602/TRecorderReplaying.html,https://root.cern,https://root.cern/root/html602/TRecorderReplaying.html,2,['allocate'],['allocated']
Energy Efficiency,"; TTree* t1 = (TTree*) f->Get(""MyTree"");; TFile* f2 = new TFile(""myfile_copy.root"", ""recreate"");; TTree* t2 = t1->Clone(0);; for (Int_t i = 0; i < 10; ++i) {; t1->GetEntry(i);; t2->Fill();; }; t2->Write(); delete f2;; f2 = 0;; delete f1;; f1 = 0;; f#define f(i)Definition RSha256.hxx:104; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TNamed::CloneTObject * Clone(const char *newname="""") const overrideMake a clone of an object using the Streamer facility.Definition TNamed.cxx:74; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; TTree::Fillvirtual Int_t Fill()Fill all branches.Definition TTree.cxx:4603; TTree::WriteInt_t Write(const char *name=nullptr, Int_t option=0, Int_t bufsize=0) overrideWrite this object to the current directory.Definition TTree.cxx:9753; int; f1TF1 * f1Definition legend1.C:11; t1auto * t1Definition textangle.C:20; An example of a branch with an object allocated by us, but owned by the caller: TFile* f = new TFile(""myfile.root"", ""recreate"");; TTree* t = new TTree(""t"", ""A test tree.""); Event* event = 0;; TBranchElement* br = t->Branch(""event."", &event);; for (Int_t i = 0; i < 10; ++i) {; ... Fill event with meaningful data in some way.; t->Fill();; }; t->Write();; delete event;; event = 0;; delete f;; f = 0;; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; TBranchElementA Branch for the case of an object.Definition TBranchElement.h:39; TBranch::TTreefriend class TTreeDefinition TBranch.h:99; TBranch::FillInt_t Fill()Definition TBranch.h:205; forfor(Int_t i=0;i< n;i++)Definition legend1.C:18; Notice that the only difference between this example and the following example is that the event pointer is zero when the branch is created.; An example of a branch with an object allocated and owned by th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBranchElement.html:68750,allocate,allocated,68750,doc/master/classTBranchElement.html,https://root.cern,https://root.cern/doc/master/classTBranchElement.html,1,['allocate'],['allocated']
Energy Efficiency,"; The AD 2 sample test formula are derived from the paper F.W Scholz, M.A. Stephens ""k-Sample Anderson-Darling Test"".; The test is implemented in root in the ROOT::Math::GoFTest class It is the same formula ( (6) in the paper), and also shown in this preprint; Binned data are considered as un-binned data with identical observation happening in the bin center.; Parameters. [in]h2Pointer to 1D histogram ; [in]optionis a character string to specify options; ""D"" Put out a line of ""Debug"" printout; ""T"" Return the normalized A-D test statistic. Note1: Underflow and overflow are not considered in the test; Note2: The test works only for un-weighted histogram (i.e. representing counts); Note3: The histograms are not required to have the same X axis; Note4: The test works only for 1-dimensional histograms . Definition at line 8062 of file TH1.cxx. ◆ AutoP2FindLimits(). Int_t TH1::AutoP2FindLimits ; (; Double_t ; xmi, . Double_t ; xma . ). protectedvirtual . Buffer-based estimate of the histogram range using the power of 2 algorithm. ; Used by the autobin power of 2 algorithm.; Works on arguments (min and max from fBuffer) and internal inputs: fXmin, fXmax, NBinsX (from fXaxis), ... Result save internally in fXaxis.; Overloaded by TH2 and TH3.; Return -1 if internal inputs are inconsistent, 0 otherwise. ; Definition at line 1343 of file TH1.cxx. ◆ AutoP2GetBins(). Int_t TH1::AutoP2GetBins ; (; Int_t ; n). inlinestaticprotected . Auxiliary function to get the next power of 2 integer value larger then n. ; Used by the autobin power of 2 algorithm ; Definition at line 1321 of file TH1.cxx. ◆ AutoP2GetPower2(). Double_t TH1::AutoP2GetPower2 ; (; Double_t ; x, . Bool_t ; next = kTRUE . ). inlinestaticprotected . Auxiliary function to get the power of 2 next (larger) or previous (smaller) a given x. ; next = kTRUE : next larger next = kFALSE : previous smaller; Used by the autobin power of 2 algorithm ; Definition at line 1308 of file TH1.cxx. ◆ AxisChoice(). Int_t TH1::AxisChoice ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH1.html:81305,power,power,81305,doc/master/classTH1.html,https://root.cern,https://root.cern/doc/master/classTH1.html,1,['power'],['power']
Energy Efficiency,"; The layout of the main page coming from THttpServer is very similar to normal JSROOT page. One could browse existing items and display them. A snapshot of running server can be seen on the demo page.; One could also specify similar URL parameters to configure the displayed items and drawing options.; It is also possible to display one single item from the THttpServer server like:; https://root.cern/js/latest/httpserver.C/Files/job1.root/hpxpy/draw.htm?opt=colz; 1.10 Data monitoring with JSROOT; 1.10.1 Monitoring with http server; The best possibility to organize the monitoring of data from a running application is to use THttpServer. In such case the client can always access the latest changes and request only the items currently displayed in the browser. To enable monitoring, one should activate the appropriate checkbox or provide monitoring parameter in the URL string like:; https://root.cern/js/latest/httpserver.C/Files/job1.root/hprof/draw.htm?monitoring=1000; The parameter value is the update interval in milliseconds.; 1.10.2 JSON file-based monitoring; Solid file-based monitoring (without integration of THttpServer into application) can be implemented in JSON format. There is the TBufferJSON class, which is capable to convert any (beside TTree) ROOT object into JSON. Any ROOT application can use such class to create JSON files for selected objects and write such files in a directory, which can be accessed via web server. Then one can use JSROOT to read such files and display objects in a web browser.; There is a demonstration page showing such functionality: https://root.cern/js/latest/demo/update_draw.htm. This demo page reads in cycle 20 json files and displays them.; If one has a web server which already provides such JSON file, one could specify the URL to this file like:; https://root.cern/js/latest/demo/update_draw.htm?addr=../httpserver.C/Canvases/c1/root.json.gz; Here the same problem with Cross-Origin Request can appear. If the web server configurat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:19783,monitor,monitoring,19783,root/htmldoc/guides/JSROOT/JSROOT.html,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html,1,['monitor'],['monitoring']
Energy Efficiency,"; This constructor is needed in the case FuncPtr is a std::unique_ptr which has a copy ctor taking non const objects ; Definition at line 166 of file WrappedParamFunction.h. ◆ WrappedParamFunctionGen() [3/3]. template<typename FuncPtr = FreeMultiFunctionPtr> . ROOT::Math::WrappedParamFunctionGen< FuncPtr >::WrappedParamFunctionGen ; (; const WrappedParamFunctionGen< FuncPtr > & ; ). privatedelete . Member Function Documentation. ◆ Clone(). template<typename FuncPtr = FreeMultiFunctionPtr> . IMultiGenFunction * ROOT::Math::WrappedParamFunctionGen< FuncPtr >::Clone ; (; ); const. inlineoverridevirtual . clone the function ; Implements ROOT::Math::IBaseFunctionMultiDimTempl< T >.; Definition at line 177 of file WrappedParamFunction.h. ◆ DoEval(). template<typename FuncPtr = FreeMultiFunctionPtr> . double ROOT::Math::WrappedParamFunctionGen< FuncPtr >::DoEval ; (; const double * ; x); const. inlineoverrideprivatevirtual . evaluate the function (re-implement for being more efficient) ; Reimplemented from ROOT::Math::IParametricFunctionMultiDimTempl< double >.; Definition at line 213 of file WrappedParamFunction.h. ◆ DoEvalPar(). template<typename FuncPtr = FreeMultiFunctionPtr> . double ROOT::Math::WrappedParamFunctionGen< FuncPtr >::DoEvalPar ; (; const double * ; x, . const double * ; p . ); const. inlineoverrideprivatevirtual . implement the required IParamFunction interface ; Implements ROOT::Math::IParametricFunctionMultiDimTempl< double >.; Definition at line 240 of file WrappedParamFunction.h. ◆ DoInit(). template<typename FuncPtr = FreeMultiFunctionPtr> . void ROOT::Math::WrappedParamFunctionGen< FuncPtr >::DoInit ; (; ). inlineprivate . Definition at line 246 of file WrappedParamFunction.h. ◆ NDim(). template<typename FuncPtr = FreeMultiFunctionPtr> . unsigned int ROOT::Math::WrappedParamFunctionGen< FuncPtr >::NDim ; (; ); const. inlineoverridevirtual . Retrieve the dimension of the function. ; Implements ROOT::Math::IBaseFunctionMultiDimTempl< T >.; Definition ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1WrappedParamFunctionGen.html:6077,efficient,efficient,6077,doc/master/classROOT_1_1Math_1_1WrappedParamFunctionGen.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1WrappedParamFunctionGen.html,1,['efficient'],['efficient']
Energy Efficiency,"; This methods don't require to use a Derivator object, and are designed to be used in; fast calculation. Error and status code cannot be retrieved in this case. Computes the numerical derivative of a function f at a point x.; It uses Derivator::EvalCentral to compute the derivative using an; adaptive central difference algorithm with a step size h. double EvalCentral(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8). Computes the numerical derivative of a function f at a point x using an adaptive central; difference algorithm with a step size h. double EvalForward(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8). Computes the numerical derivative of a function f at a point x using an adaptive forward; difference algorithm with a step size h.; The function is evaluated only at points greater than x and at x itself. double EvalBackward(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8). Computes the numerical derivative of a function f at a point x using an adaptive backward; difference algorithm with a step size h.; The function is evaluated only at points less than x and at x itself. double Eval(const ROOT::Math::IMultiGenFunction& f, const double* x, unsigned int icoord = 0, double h = 1E-8); Derivatives for multi-dimension functions. Evaluate the partial derivative of a multi-dim function; with respect coordinate x_icoord at the point x[]. double Eval(IParamFunction & f, double x, const double * p, unsigned int ipar = 0, double h = 1E-8). Evaluate the derivative with respect a parameter for one-dim parameteric function; at the point ( x,p[]) with respect the parameter p_ipar. double Eval(IParamMultiFunction & f, const double * x, const double * p, unsigned int ipar = 0, double h = 1E-8). Evaluate the derivative with respect a parameter for a multi-dim parameteric function; at the point ( x[],p[]) with respect the parameter p_ipar. int Status() const. return the error status of the last derivative calculation. double Result() co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__Derivator.html:5098,adapt,adaptive,5098,root/html526/ROOT__Math__Derivator.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__Derivator.html,1,['adapt'],['adaptive']
Energy Efficiency,"; This methods don't require to use a Derivator object, and are designed to be used in; fast calculation. Error and status code cannot be retrieved in this case. Computes the numerical derivative of a function f at a point x.; It uses Derivator::EvalCentral to compute the derivative using an; adaptive central difference algorithm with a step size h. double EvalCentral(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8). Computes the numerical derivative of a function f at a point x using an adaptive central; difference algorithm with a step size h. double EvalForward(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8). Computes the numerical derivative of a function f at a point x using an adaptive forward; difference algorithm with a step size h.; The function is evaluated only at points greater than x and at x itself. double EvalBackward(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8). Computes the numerical derivative of a function f at a point x using an adaptive backward; difference algorithm with a step size h.; The function is evaluated only at points less than x and at x itself. double Eval(const ROOT::Math::IMultiGenFunction& f, const double* x, unsigned int icoord = 0, double h = 1E-8); Derivatives for multi-dimension functions. Evaluate the partial derivative of a multi-dim function; with respect coordinate x_icoord at the point x[]. double Eval(ROOT::Math::IParamFunction& f, double x, const double* p, unsigned int ipar = 0, double h = 1E-8). Evaluate the derivative with respect a parameter for one-dim parameteric function; at the point ( x,p[]) with respect the parameter p_ipar. double Eval(ROOT::Math::IParamMultiFunction& f, const double* x, const double* p, unsigned int ipar = 0, double h = 1E-8). Evaluate the derivative with respect a parameter for a multi-dim parameteric function; at the point ( x[],p[]) with respect the parameter p_ipar. int Status() const. return the error status of the last derivative calculation.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__Derivator.html:5098,adapt,adaptive,5098,root/html528/ROOT__Math__Derivator.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__Derivator.html,4,['adapt'],['adaptive']
Energy Efficiency,"; This two step method is much more efficient than calling for; every invocation TInterpreter::Execute(...). TMethodCall(const TMethodCall& org); Copy ctor. TMethodCall & operator=(const TMethodCall& rhs); Assignement operator. ~TMethodCall(); TMethodCall dtor. TObject * Clone(const char* newname = """") const; Return an exact copy of this object. void Init(TClass* cl, CallFunc_t* func, Long_t offset = 0); Initialize the method invocation environment based on; the CallFunc object and the TClass describing the function context. void Init(TFunction* func); Initialize the method invocation environment based on; the TFunction object. void Init(TClass* cl, const char* method, const char* params, Bool_t objectIsConst = kFALSE); Initialize the method invocation environment. Necessary input; information: the class, method name and the parameter string; of the form ""\""aap\"", 3, 4.35"".; To execute the method call TMethodCall::Execute(object,...).; This two step method is much more efficient than calling for; every invocation TInterpreter::Execute(...). void Init(const char* function, const char* params); Initialize the function invocation environment. Necessary input; information: the function name and the parameter string of; the form ""\""aap\"", 3, 4.35"".; To execute the method call TMethodCall::Execute(...).; This two step method is much more efficient than calling for; every invocation TInterpreter::Execute(...). void InitImplementation(const char* methodname, const char* params, const char* proto, Bool_t objectIsConst, TClass* cl, const ClassInfo_t* cinfo, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch); This function implements Init and InitWithPrototype. void InitWithPrototype(TClass* cl, const char* method, const char* proto, Bool_t objectIsConst = kFALSE, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch); Initialize the method invocation environment. Necessary input; information: the class, method name and the prototype string of; the form: ""char*,int,float",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMethodCall.html:10639,efficient,efficient,10639,root/html602/TMethodCall.html,https://root.cern,https://root.cern/root/html602/TMethodCall.html,2,['efficient'],['efficient']
Energy Efficiency,"; XMLDocPointer_t ; xmldoc). returns root node of document ; Definition at line 1339 of file TXMLEngine.cxx. ◆ DocSetRootElement(). void TXMLEngine::DocSetRootElement ; (; XMLDocPointer_t ; xmldoc, . XMLNodePointer_t ; xmlnode . ). set main (root) node for document ; Definition at line 1326 of file TXMLEngine.cxx. ◆ FindNs(). XMLNsPointer_t TXMLEngine::FindNs ; (; XMLNodePointer_t ; xmlnode, . const char * ; nsname . ). protected . define if namespace of that name exists for xmlnode ; Definition at line 1562 of file TXMLEngine.cxx. ◆ FreeAllAttr(). void TXMLEngine::FreeAllAttr ; (; XMLNodePointer_t ; xmlnode). Free all attributes of the node. ; Definition at line 647 of file TXMLEngine.cxx. ◆ FreeAttr(). void TXMLEngine::FreeAttr ; (; XMLNodePointer_t ; xmlnode, . const char * ; name . ). remove attribute from xmlnode ; Definition at line 622 of file TXMLEngine.cxx. ◆ FreeDoc(). void TXMLEngine::FreeDoc ; (; XMLDocPointer_t ; xmldoc). frees allocated document data and deletes document itself ; Definition at line 1288 of file TXMLEngine.cxx. ◆ FreeNode(). void TXMLEngine::FreeNode ; (; XMLNodePointer_t ; xmlnode). release all memory, allocated from this node and destroys node itself ; Definition at line 1037 of file TXMLEngine.cxx. ◆ GetAttr(). const char * TXMLEngine::GetAttr ; (; XMLNodePointer_t ; xmlnode, . const char * ; name . ). returns value of attribute for xmlnode ; Definition at line 555 of file TXMLEngine.cxx. ◆ GetAttrName(). const char * TXMLEngine::GetAttrName ; (; XMLAttrPointer_t ; xmlattr). return name of the attribute ; Definition at line 692 of file TXMLEngine.cxx. ◆ GetAttrValue(). const char * TXMLEngine::GetAttrValue ; (; XMLAttrPointer_t ; xmlattr). return value of attribute ; Definition at line 703 of file TXMLEngine.cxx. ◆ GetChild(). XMLNodePointer_t TXMLEngine::GetChild ; (; XMLNodePointer_t ; xmlnode, . Bool_t ; realnode = kTRUE . ). returns first child of xmlnode ; Definition at line 1146 of file TXMLEngine.cxx. ◆ GetFirstAttr(). XMLAttr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTXMLEngine.html:25203,allocate,allocated,25203,doc/master/classTXMLEngine.html,https://root.cern,https://root.cern/doc/master/classTXMLEngine.html,1,['allocate'],['allocated']
Energy Efficiency,"; auto t = new TText(0.05, 0.7, ""Can you see the text?"");; t->Draw();; ; //We create a nested pad on top to render a TPie in,; //this way we still have a text (below) + TPie with; //a fancy colour on top.; auto pad = new TPad(""p"", ""p"", 0., 0., 1., 1.);; ; //TPad itself is fully transparent:; auto transparentFill = TColor::GetColor((Float_t) 1., 1., 1., 0.);; pad->SetFillColor(transparentFill);; //Add our pad into the canvas:; pad->Draw();; pad->cd();; ; ; //Radial gradient fill for a TPie object:; auto col3 = TColor::GetColor((Float_t) 1., 0.8, 0., 1.); /*opaque orange at the start:*/; auto col4 = TColor::GetColor((Float_t) 1., 0.2, 0., 0.65); /*transparent red at the end:*/; ; //'Simple' radial gradient with radius 0.4; auto radialFill = TColor::GetRadialGradient(0.4, {col3, col4});; ; ; //Linear gradient fill (with an axis angle == 45):; auto col1 = TColor::GetColor((Float_t) 0.2, 0.2, 0.2); /*gray*/; auto col2 = TColor::GetColor((Float_t) 0.8, 1., 0.9); /*pale green*/; auto linearFill = TColor::GetLinearGradient(45., {col1, col2}); //45 degrees:; ; //Set as a background color in the canvas:; c->SetFillColor(linearFill);; ; ; const UInt_t nSlices = 5;; //Values for a TPie (non-const, that's how TPie's ctor is declared):; Double_t values[nSlices] = {0.8, 1.2, 1.2, 0.8, 1.};; Int_t colors[nSlices] = {radialFill, radialFill, radialFill,; radialFill, radialFill};; ; TPie * const pie = new TPie(""pie"", ""TPie:"", nSlices, values, colors);; //One slice is slightly shifted:; pie->SetEntryRadiusOffset(2, 0.05);; //Move labels to the center (to fit the pad's space):; pie->SetLabelsOffset(-0.08);; //; pie->SetRadius(0.4);; pie->Draw(""rsc"");; }; c#define c(i)Definition RSha256.hxx:101; Int_tint Int_tDefinition RtypesCore.h:45; UInt_tunsigned int UInt_tDefinition RtypesCore.h:46; Float_tfloat Float_tDefinition RtypesCore.h:57; Double_tdouble Double_tDefinition RtypesCore.h:59; TCanvas.h; TColorGradient.h; TError.h; Warningvoid Warning(const char *location, const char *msgfmt,...)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/gl_2gradients_8C.html:2563,green,green,2563,doc/master/gl_2gradients_8C.html,https://root.cern,https://root.cern/doc/master/gl_2gradients_8C.html,1,['green'],['green']
Energy Efficiency,"; colors[5].blue = 20;; 72 colors[ 6].red = 235; colors[ 6].green = 71; colors[6].blue = 71;; 73 colors[ 7].red = 240; colors[ 7].green = 117; colors[7].blue = 117;; 74 colors[ 8].red = 15; colors[ 8].green = 138; colors[8].blue = 15;; 75 colors[ 9].red = 20; colors[ 9].green = 184; colors[9].blue = 20;; 76 colors[10].red = 71; colors[10].green = 235; colors[10].blue = 71;; 77 colors[11].red = 117; colors[11].green = 240; colors[11].blue = 117;; 78 colors[12].red = 15; colors[12].green = 15; colors[12].blue = 138;; 79 colors[13].red = 20; colors[13].green = 20; colors[13].blue = 184;; 80 colors[14].red = 71; colors[14].green = 71; colors[14].blue = 235;; 81 colors[15].red = 117; colors[15].green = 117; colors[15].blue = 240;; 82 colors[16].red = 138; colors[16].green = 138; colors[16].blue = 15;; 83 colors[17].red = 184; colors[17].green = 184; colors[17].blue = 20;; 84 colors[18].red = 235; colors[18].green = 235; colors[18].blue = 71;; 85 colors[19].red = 240; colors[19].green = 240; colors[19].blue = 117;; 86 colors[20].red = 138; colors[20].green = 15; colors[20].blue = 138;; 87 colors[21].red = 184; colors[21].green = 20; colors[21].blue = 184;; 88 colors[22].red = 235; colors[22].green = 71; colors[22].blue = 235;; 89 colors[23].red = 240; colors[23].green = 117; colors[23].blue = 240;; 90 colors[24].red = 15; colors[24].green = 138; colors[24].blue = 138;; 91 colors[25].red = 20; colors[25].green = 184; colors[25].blue = 184;; 92 colors[26].red = 71; colors[26].green = 235; colors[26].blue = 235;; 93 colors[27].red = 117; colors[27].green = 240; colors[27].blue = 240;; 94 }; 95 ; 96 ; 97 /*; 98 * Allocate memory for segments; 99 */; 100 ; 101 if (gSize3D.numSegs) {; 102 segs = (segment *) calloc (gSize3D.numSegs, sizeof (segment));; 103 if (!segs) {; 104 puts (""Unable to allocate memory for segments !"");; 105 ret = 0;; 106 }; 107 }; 108 ; 109 ; 110 /*; 111 * Allocate memory for polygons; 112 */; 113 ; 114 if (gSize3D.numPolys) {; 115 polys = (polygon *) callo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/X3DBuffer_8c_source.html:3047,green,green,3047,doc/master/X3DBuffer_8c_source.html,https://root.cern,https://root.cern/doc/master/X3DBuffer_8c_source.html,1,['green'],['green']
Energy Efficiency,"; difference between consecutive ""Stops"" values gives the fraction of ; space in the whole table that should be used for the interval between ; the corresponding color values.; ; Normally the first element of Stops should be 0 and the last should be 1.; If this is not true, fewer than NColors will be used in proportion with; the total interval between the first and last elements of Stops.; ; This definition is similar to the povray-definition of gradient; color tables.; ; For instance:; ; UInt_t Number = 3;; Double_t Red[3] = { 0.0, 1.0, 1.0 };; Double_t Green[3] = { 0.0, 0.0, 1.0 };; Double_t Blue[3] = { 1.0, 0.0, 1.0 };; Double_t Stops[3] = { 0.0, 0.4, 1.0 };; ; This defines a table in which there are three color end points:; RGB = {0, 0, 1}, {1, 0, 0}, and {1, 1, 1} = blue, red, white; The first 40% of the table is used to go linearly from blue to red.; The remaining 60% of the table is used to go linearly from red to white.; ; If you define a very short interval such that less than one color fits; in it, no colors at all will be allocated. If this occurs for all; intervals, ROOT will revert to the default palette.; ; Original code by Andreas Zoglauer (zog@mpe.mpg.de); ; . void SetPalette(Int_t ncolors, Int_t* colors). Static function.; The color palette is used by the histogram classes; (see TH1::Draw options).; For example TH1::Draw(""col"") draws a 2-D histogram with cells; represented by a box filled with a color CI function of the cell content.; if the cell content is N, the color CI used will be the color number; in colors[N],etc. If the maximum cell content is > ncolors, all; cell contents are scaled to ncolors.; ; if ncolors <= 0 a default palette (see below) of 50 colors is; defined. The colors defined in this palette are OK for coloring pads, labels.; ; if ncolors == 1 && colors == 0, then a Pretty Palette with a; Spectrum Violet->Red is created. It is recommended to use this Pretty; palette when drawing legos, surfaces or contours.; ; if ncolors > 50 and",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TColor.html:24561,allocate,allocated,24561,root/html526/TColor.html,https://root.cern,https://root.cern/root/html526/TColor.html,1,['allocate'],['allocated']
Energy Efficiency,"; doubleDerivative(const double* x) const; virtual voidFdF(double x, double& f, double& df) const; voidFdF(const double* x, double& f, double* df) const; voidGradient(const double* x, double* g) const; ROOT::Math::IGradientOneDim&operator=(const ROOT::Math::IGradientOneDim&). private:. virtual doubleDoDerivative(double x) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Gradient(const double* x, double* g) const. Evaluate all the vector of function derivatives (gradient) at a point x.; Derived classes must re-implement if it is more efficient than evaluting one at a time. double Derivative(const double * x, unsigned int icoord = 0). Return the partial derivative with respect to the passed coordinate. return DoDerivative(x, icoord). void FdF(const double* x, double& f, double* df) const. Optimized method to evaluate at the same time the function value and derivative at a point x.; Often both value and derivatives are needed and it is often more efficient to compute them at the same time.; Derived class should implement this method if performances play an important role and if it is faster to; evaluate value and derivative at the same time. virtual ~IGradientOneDim(); virtual destructor. {}. double Derivative(double x) const. Return the derivative of the function at a point x; Use the private method DoDerivative. void FdF(double x, double& f, double& df) const. Optimized method to evaluate at the same time the function value and derivative at a point x.; Often both value and derivatives are needed and it is often more efficient to compute them at the same time.; Derived class should implement this method if performances play an important role and if it is faster to; evaluate value and derivative at the same time. » Last changed: root/mathcore:$Id$ » Last generated: 2015-09-08 16:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a m",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__IGradientOneDim.html:2281,efficient,efficient,2281,root/html534/ROOT__Math__IGradientOneDim.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__IGradientOneDim.html,1,['efficient'],['efficient']
Energy Efficiency,"; doubleDerivative(const double* x) const; virtual voidFdF(double x, double& f, double& df) const; voidFdF(const double* x, double& f, double* df) const; voidGradient(const double* x, double* g) const; ROOT::Math::IGradientOneDim&operator=(const ROOT::Math::IGradientOneDim&). private:. virtual doubleDoDerivative(double x) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Gradient(const double* x, double* g) const. Evaluate all the vector of function derivatives (gradient) at a point x.; Derived classes must re-implement if it is more efficient than evaluting one at a time. double Derivative(const double * x, unsigned int icoord = 0). Return the partial derivative with respect to the passed coordinate. return DoDerivative(x, icoord). void FdF(const double* x, double& f, double* df) const. Optimized method to evaluate at the same time the function value and derivative at a point x.; Often both value and derivatives are needed and it is often more efficient to compute them at the same time.; Derived class should implement this method if performances play an important role and if it is faster to; evaluate value and derivative at the same time. virtual ~IGradientOneDim(); virtual destructor. {}. double Derivative(double x) const. Return the derivative of the function at a point x; Use the private method DoDerivative. void FdF(double x, double& f, double& df) const. Optimized method to evaluate at the same time the function value and derivative at a point x.; Often both value and derivatives are needed and it is often more efficient to compute them at the same time.; Derived class should implement this method if performances play an important role and if it is faster to; evaluate value and derivative at the same time. » Last changed: root/mathcore:$Id: IFunction.h 24482 2008-06-23 15:33:08Z moneta $ » Last generated: 2010-09-23 19:56; This page has been automatically generated. For comments or suggestions regarding the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__IGradientOneDim.html:2279,efficient,efficient,2279,root/html528/ROOT__Math__IGradientOneDim.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__IGradientOneDim.html,1,['efficient'],['efficient']
Energy Efficiency,"; doubleDerivative(const double* x) const; virtual voidFdF(double x, double& f, double& df) const; voidFdF(const double* x, double& f, double* df) const; voidGradient(const double* x, double* g) const; ROOT::Math::IGradientOneDim&operator=(const ROOT::Math::IGradientOneDim&). private:. virtual doubleDoDerivative(double x) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Gradient(const double* x, double* g) const. Evaluate all the vector of function derivatives (gradient) at a point x.; Derived classes must re-implement if it is more efficient than evaluting one at a time. double Derivative(const double * x, unsigned int icoord = 0). Return the partial derivative with respect to the passed coordinate. return DoDerivative(x, icoord). void FdF(const double* x, double& f, double* df) const. Optimized method to evaluate at the same time the function value and derivative at a point x.; Often both value and derivatives are needed and it is often more efficient to compute them at the same time.; Derived class should implement this method if performances play an important role and if it is faster to; evaluate value and derivative at the same time. virtual ~IGradientOneDim(); virtual destructor. {}. double Derivative(double x) const. Return the derivative of the function at a point x; Use the private method DoDerivative. void FdF(double x, double& f, double& df) const. Optimized method to evaluate at the same time the function value and derivative at a point x.; Often both value and derivatives are needed and it is often more efficient to compute them at the same time.; Derived class should implement this method if performances play an important role and if it is faster to; evaluate value and derivative at the same time. » Last changed: root/mathcore:$Id: IFunction.h 24482 2008-06-23 15:33:08Z moneta $ » Last generated: 2011-07-04 15:19; This page has been automatically generated. For comments or suggestions regarding the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ROOT__Math__IGradientOneDim.html:2281,efficient,efficient,2281,root/html530/ROOT__Math__IGradientOneDim.html,https://root.cern,https://root.cern/root/html530/ROOT__Math__IGradientOneDim.html,1,['efficient'],['efficient']
Energy Efficiency,"; doubleDerivative(const double* x) const; virtual voidFdF(double x, double& f, double& df) const; voidFdF(const double* x, double& f, double* df) const; voidGradient(const double* x, double* g) const; ROOT::Math::IGradientOneDim&operator=(const ROOT::Math::IGradientOneDim&). private:. virtual doubleDoDerivative(double x) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Gradient(const double* x, double* g) const. Evaluate all the vector of function derivatives (gradient) at a point x.; Derived classes must re-implement if it is more efficient than evaluting one at a time. double Derivative(const double * x, unsigned int icoord = 0). Return the partial derivative with respect to the passed coordinate. return DoDerivative(x, icoord). void FdF(const double* x, double& f, double* df) const. Optimized method to evaluate at the same time the function value and derivative at a point x.; Often both value and derivatives are needed and it is often more efficient to compute them at the same time.; Derived class should implement this method if performances play an important role and if it is faster to; evaluate value and derivative at the same time. virtual ~IGradientOneDim(); virtual destructor. {}. double Derivative(double x) const. Return the derivative of the function at a point x; Use the private method DoDerivative. void FdF(double x, double& f, double& df) const. Optimized method to evaluate at the same time the function value and derivative at a point x.; Often both value and derivatives are needed and it is often more efficient to compute them at the same time.; Derived class should implement this method if performances play an important role and if it is faster to; evaluate value and derivative at the same time. » Last changed: root/mathcore:$Id: IFunction.h 24482 2008-06-23 15:33:08Z moneta $ » Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ROOT__Math__IGradientOneDim.html:2281,efficient,efficient,2281,root/html532/ROOT__Math__IGradientOneDim.html,https://root.cern,https://root.cern/root/html532/ROOT__Math__IGradientOneDim.html,1,['efficient'],['efficient']
Energy Efficiency,"; i++) source[i]=back->GetBinContent(i + 1);; s->Background(source,nbins,6,TSpectrum::kBackDecreasingWindow,; TSpectrum::kBackOrder2,kFALSE,; TSpectrum::kBackSmoothing3,kFALSE);; for (i = 0; i < nbins; i++) d2->SetBinContent(i + 1,source[i]);; d2->SetLineColor(kOrange);; d2->Draw(""SAME L"");; ; for (i = 0; i < nbins; i++) source[i]=back->GetBinContent(i + 1);; s->Background(source,nbins,8,TSpectrum::kBackDecreasingWindow,; TSpectrum::kBackOrder2,kFALSE,; TSpectrum::kBackSmoothing3,kFALSE);; for (i = 0; i < nbins; i++) d3->SetBinContent(i + 1,source[i]);; d3->SetLineColor(kGreen);; d3->Draw(""SAME L"");; }; kOrange@ kOrangeDefinition Rtypes.h:67; kGreen@ kGreenDefinition Rtypes.h:66; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; . Example 4 script Background_width2.C:; another example for very complex spectrum is given here.; Example of the influence of clipping window width on the estimated background for numberIterations=10 (red line), 20 (blue line), 30 (green line) and 40 (magenta line) using decreasing clipping window algorithm.; ; void Background_width2() {; Int_t i;; const Int_t nbins = 4096;; Double_t xmin = 0;; Double_t xmax = 4096;; Double_t source[nbins];; gROOT->ForceStyle();; ; TH1F *d1 = new TH1F(""d1"","""",nbins,xmin,xmax);; TH1F *d2 = new TH1F(""d2"","""",nbins,xmin,xmax);; TH1F *d3 = new TH1F(""d3"","""",nbins,xmin,xmax);; TH1F *d4 = new TH1F(""d4"","""",nbins,xmin,xmax);; ; TString dir = gROOT->GetTutorialDir();; TString file = dir+""/spectrum/TSpectrum.root"";; TFile *f = new TFile(file.Data());; TH1F *back = (TH1F*) f->Get(""back2"");; ; back->SetTitle(""Influence of clipping window width on the estimated background"");; back->SetAxisRange(0,1000);; back->SetMaximum(7000);; back->Draw(""L"");; ; TSpectrum *s = new TSpectrum();; ; for (i = 0; i < nbins; i++) source[i]=back->GetBinContent(i + 1);; s->Background(source,nbins,10,TSpectrum::kBackDecreasingWindow,; TSpectrum::kBackOrder2,kFALSE,; TSpectrum::kBackSmooth",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSpectrum.html:28460,green,green,28460,doc/master/classTSpectrum.html,https://root.cern,https://root.cern/doc/master/classTSpectrum.html,1,['green'],['green']
Energy Efficiency,"; intermediate formula objects, use the equivalent constructor; accepting RooFormulaVar reference as cut specification. For most uses the RooAbsData::reduce() wrapper function, which; uses this constructor, is the most convenient way to create a; subset of an existing data. RooDataSet(const char* name, const char* title, RooDataSet* data, const RooArgSet& vars, const RooFormulaVar& cutVar, const char* wgtVarName = 0); Constructor of a data set from (part of) an existing data; set. The dimensions of the data set are defined by the 'vars'; RooArgSet, which can be identical to 'dset' dimensions, or a; subset thereof. The 'cutVar' formula variable is used to select; the subset of data points to be copied. For subsets without; selection on the data points, or involving cuts operating; exclusively and directly on the data set dimensions, the; equivalent constructor with a string based cut expression is; recommended. For most uses the RooAbsData::reduce() wrapper function, which; uses this constructor, is the most convenient way to create a; subset of an existing data. RooDataSet(const char* name, const char* title, TTree* t, const RooArgSet& vars, const RooFormulaVar& cutVar, const char* wgtVarName = 0); Constructor of a data set from (part of) an ROOT TTRee. The dimensions; of the data set are defined by the 'vars' RooArgSet. For each dimension; specified, the TTree must have a branch with the same name. For category; branches, this branch should contain the numeric index value. Real dimensions; can be constructed from either 'Double_t' or 'Float_t' tree branches. In the; latter case, an automatic conversion is applied. The 'cutVar' formula variable; is used to select the subset of data points to be copied.; For subsets without selection on the data points, or involving cuts; operating exclusively and directly on the data set dimensions, the equivalent; constructor with a string based cut expression is recommended. RooDataSet(const char* name, const char* title, TTree* nt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooDataSet.html:21473,reduce,reduce,21473,root/html528/RooDataSet.html,https://root.cern,https://root.cern/root/html528/RooDataSet.html,6,['reduce'],['reduce']
Energy Efficiency,"; ladder->SetLineColor(kBlue);; ; // Add nodes; top->AddNode(ladder,1);; for (Int_t i=0; i<10; i++); top->AddNode(chip, i+1, new TGeoTranslation(0, -225.+50.*i, 10));; ; gGeoManager->CloseGeometry();; TGeoParallelWorld *pw = nullptr;; if (usepw) pw = gGeoManager->CreateParallelWorld(""priority_sensors"");; // Align chips; align();; if (usepw) {; if (useovlp) pw->AddOverlap(ladder);; pw->CloseGeometry();; gGeoManager->SetUseParallelWorldNav(kTRUE);; }; TString cname;; cname = usepw ? ""cpw"" : ""cnopw"";; TCanvas *c = (TCanvas*)gROOT->GetListOfCanvases()->FindObject(cname);; if (c) c->cd();; else c = new TCanvas(cname, """",800,600);; top->Draw();; // top->RandomRays(0,0,0,0,sensor->GetName());; // Track random ""particles"" coming from the block side and draw only the tracklets; // actually crossing one of the sensors. Note that some of the tracks coming; // from the outer side may see the full sensor, while the others only part of it.; TStopwatch timer;; timer.Start();; top->RandomRays(100000,0,0,-30,sensor->GetName());; timer.Stop();; timer.Print();; TView3D *view = (TView3D*)gPad->GetView();; if (view) {; view->SetParallel();; view->Side();; }; if (usepw) pw->PrintDetectedOverlaps();; }; ; //______________________________________________________________________________; void align(); {; // Aligning 2 sensors so they will overlap with the support. One sensor is positioned; // normally while the other using the shared matrix; TGeoPhysicalNode *node;; TGeoParallelWorld *pw = gGeoManager->GetParallelWorld();; Double_t sag;; for (Int_t i=0; i<10; i++) {; node = gGeoManager->MakePhysicalNode(TString::Format(""/TOP_1/chip_%d"",i+1));; sag = 8.-0.494*(i-4.5)*(i-4.5);; TGeoTranslation *tr = new TGeoTranslation(0., -225.+50.*i, 10-sag);; node->Align(tr);; if (pw) pw->AddNode(TString::Format(""/TOP_1/chip_%d"",i+1));; }; }; c#define c(i)Definition RSha256.hxx:101; Bool_tbool Bool_tDefinition RtypesCore.h:63; Int_tint Int_tDefinition RtypesCore.h:45; Double_tdouble Double_tDefinition Rtyp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/parallel__world_8C.html:3434,sensor,sensor,3434,doc/master/parallel__world_8C.html,https://root.cern,https://root.cern/doc/master/parallel__world_8C.html,1,['sensor'],['sensor']
Energy Efficiency,"; m.AddLine(""model.compile(loss = 'binary_crossentropy', optimizer = Adam(learning_rate = 0.001), weighted_metrics = ['accuracy'])"");; m.AddLine(""model.save('Higgs_model.h5')"");; m.AddLine(""model.summary()"");; ; m.SaveSource(""make_higgs_model.py"");; // execute; auto ret = (TString *)gROOT->ProcessLine(""TMVA::Python_Executable()"");; TString python_exe = (ret) ? *(ret) : ""python"";; gSystem->Exec(python_exe + "" make_higgs_model.py"");; ; if (gSystem->AccessPathName(""Higgs_model.h5"")) {; Warning(""TMVA_Higgs_Classification"", ""Error creating Keras model file - skip using Keras"");; } else {; // book PyKeras method only if Keras model could be created; Info(""TMVA_Higgs_Classification"", ""Booking tf.Keras Dense model"");; factory.BookMethod(; loader, TMVA::Types::kPyKeras, ""PyKeras"",; ""H:!V:VarTransform=None:FilenameModel=Higgs_model.h5:tf.keras:""; ""FilenameTrainedModel=Higgs_trained_model.h5:NumEpochs=20:BatchSize=100:""; ""GpuOptions=allow_growth=True""); // needed for RTX NVidia card and to avoid TF allocates all GPU memory; }; }; ; /**; ## Train Methods; ; Here we train all the previously booked methods.; ; */; ; factory.TrainAllMethods();; ; /**; ## Test all methods; ; Now we test and evaluate all methods using the test data set; */; ; factory.TestAllMethods();; ; factory.EvaluateAllMethods();; ; /// after we get the ROC curve and we display; ; auto c1 = factory.GetROCCurve(loader);; c1->Draw();; ; /// at the end we close the output file which contains the evaluation result of all methods and it can be used by TMVAGUI; /// to display additional plots; ; outputFile->Close();; ; ; }; Double_tdouble Double_tDefinition RtypesCore.h:59; Infovoid Info(const char *location, const char *msgfmt,...)Use this function for informational messages.Definition TError.cxx:218; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; Warningvoid Warning(const char *location, const char *msgfmt,...)Use this function in wa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__Higgs__Classification_8C.html:69057,allocate,allocates,69057,doc/master/TMVA__Higgs__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__Higgs__Classification_8C.html,1,['allocate'],['allocates']
Energy Efficiency,"; only after the creation of the DataSet which might be later. Bool_t PrepareTransformation(const vector<TMVA::Event*,allocator<TMVA::Event*> >& ); calculate the principal components using the ROOT class TPrincipal; and the normalization. const TMVA::Event* Transform(const TMVA::Event *const , Int_t cls) const; apply the principal component analysis. const TMVA::Event* InverseTransform(const TMVA::Event *const , Int_t cls) const; apply the principal component analysis; TODO: implementation of inverse transformation. void CalculatePrincipalComponents(const vector<TMVA::Event*,allocator<TMVA::Event*> >& ); calculate the principal components for the signal and the background data; it uses the MakePrincipal method of ROOT's TPrincipal class. std::vector<Float_t> X2P(const vector<Float_t>& , Int_t cls) const; Calculate the principal components from the original data vector; x, and return it in p (function extracted from TPrincipal::X2P); It's the users responsibility to make sure that both x and p are; of the right size (i.e., memory must be allocated for p). void WriteTransformationToStream(ostream& ) const; write mean values to stream. void AttachXMLTo(void* parent); create XML description of PCA transformation. void ReadFromXML(void* trfnode); Read the transformation matrices from the xml node. void ReadTransformationFromStream(istream& , const TString& ); Read mean values from input stream. void MakeFunction(ostream& fout, const TString& fncName, Int_t part, UInt_t trCounter, Int_t cls); creates C++ code fragment of the PCA transform for inclusion in standalone C++ class. VariablePCATransform( DataSetInfo& dsi ). » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id: VariablePCATransform.h 33993 2010-06-19 11:25:14Z stelzer $ » Last generated: 2010-11-26 14:27; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__VariablePCATransform.html:9458,allocate,allocated,9458,root/html528/TMVA__VariablePCATransform.html,https://root.cern,https://root.cern/root/html528/TMVA__VariablePCATransform.html,1,['allocate'],['allocated']
Energy Efficiency,"; process the options specified by the user. void InitMonitorNtuple(); initialize the monitoring ntuple. void Init(); default initialization. void InitEventSample( void ); write all Events from the Tree into a vector of Events, that are; more easily manipulated.; This method should never be called without existing trainingTree, as it; the vector of events from the ROOT training tree. void Train( void ). void TrainTMVARuleFit( void ); training of rules using TMVA implementation. void TrainJFRuleFit( void ); training of rules using Jerome Friedmans implementation. const TMVA::Ranking* CreateRanking(); computes ranking of input variables. void AddWeightsXMLTo(void* parent) const; add the rules to XML node. void ReadWeightsFromStream(istream& istr); read rules from an istream. void ReadWeightsFromXML(void* wghtnode); read rules from XML node. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); returns MVA value for given event. void WriteMonitoringHistosToFile( void ); write special monitoring histograms to file (here ntuple). void MakeClassSpecific(ostream& , const TString& ) const; write specific classifier response. void MakeClassRuleCuts(ostream& ) const; print out the rule cuts. void MakeClassLinear(ostream& ) const; print out the linear terms. void GetHelpMessage() const; get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". Bool_t UseBoost() const; { return fUseBoost; }. RuleFit* GetRuleFitPtr(); accessors. { return &fRuleFit; }. const RuleFit* GetRuleFitConstPtr() const; { return &fRuleFit; }. TDirectory* GetMethodBaseDir() const; { return BaseDir(); }. const std::vector<TMVA::Event*>& GetTrainingEvents() const; { return fEventSample; }. const std::vector<TMVA::DecisionTree*>& GetForest() const; { return fForest; }. Int_t GetNTrees() const; { return fNTrees; }. Double_t GetTreeEveFrac() const; { return fTreeEveFrac; }. const SeparationBase* GetSeparationBaseConst() const; { return fSe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MethodRuleFit.html:22060,monitor,monitoring,22060,root/html528/TMVA__MethodRuleFit.html,https://root.cern,https://root.cern/root/html528/TMVA__MethodRuleFit.html,3,['monitor'],['monitoring']
Energy Efficiency,"; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; ROOT::Math::GSLMultiRootDerivFunctionWrapperwrapper to a multi-dim function with derivatives for multi roots algorithmDefinition GSLMultiRootFunctionWrapper.h:96; ROOT::Math::GSLMultiRootDerivFunctionWrapper::GSLMultiRootDerivFunctionWrapperGSLMultiRootDerivFunctionWrapper()Definition GSLMultiRootFunctionWrapper.h:100; ROOT::Math::GSLMultiRootDerivFunctionWrapper::GetFunctionsgsl_multiroot_function_fdf * GetFunctions()Definition GSLMultiRootFunctionWrapper.h:122; ROOT::Math::GSLMultiRootDerivFunctionWrapper::fFuncgsl_multiroot_function_fdf fFuncDefinition GSLMultiRootFunctionWrapper.h:127; ROOT::Math::GSLMultiRootDerivFunctionWrapper::SetFunctionsvoid SetFunctions(const FuncVector &f, unsigned int n)Fill gsl function structure from a C++ function iterator and size and number of residuals.Definition GSLMultiRootFunctionWrapper.h:112; ROOT::Math::GSLMultiRootFunctionAdapterClass for adapting a C++ functor class to C function pointers used by GSL MultiRoot Algorithm The tem...Definition GSLMultiRootFunctionAdapter.h:68; ROOT::Math::GSLMultiRootFunctionWrapperwrapper to a multi-dim function without derivatives for multi roots algorithmDefinition GSLMultiRootFunctionWrapper.h:57; ROOT::Math::GSLMultiRootFunctionWrapper::fFuncgsl_multiroot_function fFuncDefinition GSLMultiRootFunctionWrapper.h:84; ROOT::Math::GSLMultiRootFunctionWrapper::GetFunctionsgsl_multiroot_function * GetFunctions()Definition GSLMultiRootFunctionWrapper.h:79; ROOT::Math::GSLMultiRootFunctionWrapper::GSLMultiRootFunctionWrapperGSLMultiRootFunctionWrapper()Definition GSLMultiRootFunctionWrapper.h:61; ROOT::Math::GSLMultiRootFunctionWrapper::SetFunctionsvoid SetFunctions(const FuncVector &f, unsigned int n)Fill gsl function structure from a C++ function iterator and size and number of residuals.Definition GSLMultiRootFunctionWrapper.h:71; double; nconst Int_t nDefinition legend1.C:16; MathNamespace for new Math clas",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/GSLMultiRootFunctionWrapper_8h_source.html:5160,adapt,adapting,5160,doc/master/GSLMultiRootFunctionWrapper_8h_source.html,https://root.cern,https://root.cern/doc/master/GSLMultiRootFunctionWrapper_8h_source.html,1,['adapt'],['adapting']
Energy Efficiency,"; s, . Ssiz_t ; patlen, . Ssiz_t ; i, . ECaseCompare ; cmp . ); const. inline . Definition at line 657 of file TString.h. ◆ Index() [7/8]. Ssiz_t TString::Index ; (; TPRegexp & ; r, . Ssiz_t * ; extent, . Ssiz_t ; start = 0 . ); const. Find the first occurrence of the regexp in string and return the position. ; Extent is length of the matched string and start is the offset at which the matching should start. ; Definition at line 628 of file TPRegexp.cxx. ◆ Index() [8/8]. Ssiz_t TString::Index ; (; TPRegexp & ; r, . Ssiz_t ; start = 0 . ); const. Find the first occurrence of the regexp in string and return the position. ; Start is the offset at which the search should start. ; Definition at line 613 of file TPRegexp.cxx. ◆ Init(). char * TString::Init ; (; Ssiz_t ; capacity, . Ssiz_t ; nchar . ). private . Private member function returning an empty string representation of size capacity and containing nchar characters. ; WarningIf nchar > MaxSize(), then Fatal() is raised and only MaxSize() elements are allocated ; Definition at line 261 of file TString.cxx. ◆ InitChar(). void TString::InitChar ; (; char ; c). protected . Initialize a string with a single character. ; Definition at line 148 of file TString.cxx. ◆ InitialCapacity(). Ssiz_t TString::InitialCapacity ; (; Ssiz_t ; ic = 15). static . Set default initial capacity for all TStrings. Default is 15. ; Definition at line 1593 of file TString.cxx. ◆ Insert() [1/4]. TString & TString::Insert ; (; Ssiz_t ; pos, . const char * ; s . ). inline . Definition at line 661 of file TString.h. ◆ Insert() [2/4]. TString & TString::Insert ; (; Ssiz_t ; pos, . const char * ; s, . Ssiz_t ; extent . ). inline . Definition at line 664 of file TString.h. ◆ Insert() [3/4]. TString & TString::Insert ; (; Ssiz_t ; pos, . const TString & ; s . ). inline . Definition at line 667 of file TString.h. ◆ Insert() [4/4]. TString & TString::Insert ; (; Ssiz_t ; pos, . const TString & ; s, . Ssiz_t ; extent . ). inline . Definition at line 67",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTString.html:37120,allocate,allocated,37120,doc/v632/classTString.html,https://root.cern,https://root.cern/doc/v632/classTString.html,2,['allocate'],['allocated']
Energy Efficiency,"; static TObject::(anonymous)TObject::kZombie. protected:. Int_tTProofMonSender::fDataSetInfoVrsVersion of the dataset info 'table'; Int_tTProofMonSender::fFileInfoVrsVersion of the file info 'table'; TStringTNamed::fNameobject identifier; Int_tTProofMonSender::fSummaryVrsVersion of the summary 'table'; TStringTNamed::fTitleobject title; static TProofMonSender::EConfigBitsTProofMonSender::kSendDataSetInfo; static TProofMonSender::EConfigBitsTProofMonSender::kSendFileInfo; static TProofMonSender::EConfigBitsTProofMonSender::kSendSummary. private:. TVirtualMonitoringWriter*fWriterWriter instance connect to backend. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofMonSenderML(const char* serv, const char* tag, const char* id = 0, const char* subid = 0, const char* opt = """"); Main constructor. ~TProofMonSenderML(); Destructor. Int_t SendSummary(TList* , const char* ); Send summary record. There are three versions of this record, corresponding the evolution; in time of the monitoring requirements. The default version 2 contains the following information. user XRD_STRING; proofgroup XRD_STRING; begin XRD_STRING; end XRD_STRING; walltime XRD_REAL64; cputime XRD_REAL64; bytesread XRD_REAL64; events XRD_REAL64; totevents XRD_REAL64; workers XRD_REAL64; vmemmxw XRD_REAL64; rmemmxw XRD_REAL64; vmemmxm XRD_REAL64; rmemmxm XRD_REAL64; numfiles XRD_REAL64; missfiles XRD_REAL64; status XRD_REAL64; rootver XRD_STRING. Version 1 contains the following information; (no 'status', 'missfiles', 'rootver'; 'dataset' field with name(s) of; processed dataset(s)). user XRD_STRING; proofgroup XRD_STRING; begin XRD_STRING; end XRD_STRING; walltime XRD_REAL64; cputime XRD_REAL64; bytesread XRD_REAL64; events XRD_REAL64; totevents XRD_REAL64; workers XRD_REAL64; vmemmxw XRD_REAL64; rmemmxw XRD_REAL64; vmemmxm XRD_REAL64; rmemmxm XRD_REAL64; numfiles XRD_REAL64; dataset XRD_STRING. Version 0 contains the following information; ('group' instead of '",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofMonSenderML.html:7304,monitor,monitoring,7304,root/html602/TProofMonSenderML.html,https://root.cern,https://root.cern/root/html602/TProofMonSenderML.html,2,['monitor'],['monitoring']
Energy Efficiency,; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Double_tfBeginTimetime when monitoring starts; Int_tfBtIDback trace identifier; Int_t*fBufBtIDback trace identifier; Int_tfBufNcurrent number of alloc or free in the buffer; Int_t*fBufNBytesnumber of bytes allocated/freed; ULong64_t*fBufPosposition in memory where alloc/free happens; Int_t*fBufTimems10000*(current time - begin time); Int_tfBufferSizemax number of malloc/free to keep in the buffer; TFile*fDumpFile!file to dump current information; TTree*fDumpTree!tree to dump information; Int_t*fIndexarray to sort fBufPos; Int_tfMaxCallsmax number of malloc/frees to register in the output Tree; Bool_t*fMustWriteflag to write or not the entry; Int_tfNBytesnumber of bytes allocated/freed; ULong64_tfPosposition in memory where alloc/free happens; TMemStatHook::FreeHookFunc_tfPreviousFreeHook!old free function; TMemStatHook::MallocHookFunc_tfPreviousMallocHook!old malloc function; TTimeStampfTimeStamp; Int_tfTimems10000*(current time - begin time); Bool_tfUseGNUBuiltinBacktrace; static Memstat::TMemStatMng*fgInstancepointer to instance; static void*fgStackTopstack top pointer. private:. Memstat::TMemStatMng::CRCSet_tfBTChecksums; Int_tfBTCount; UInt_tfBTIDCount; Memstat::TMemStatFAddrContainerfFAddrs; TObjArray*fFAddrsList; TH1I*fHbtids; TNamed*fSysInfo. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMemStatMng(); Default constructor. void Init(); Initialize MemStat manager - used only by instance method. TMemStatMng* GetInstance(); GetInstance - a static function; Initialize a s,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/Memstat__TMemStatMng.html:6223,monitor,monitoring,6223,root/html602/Memstat__TMemStatMng.html,https://root.cern,https://root.cern/root/html602/Memstat__TMemStatMng.html,6,"['allocate', 'monitor']","['allocated', 'monitoring']"
Energy Efficiency,"; std::unique_ptr<RooFitResult> fit1{expo.fitTo(*expoData, Save(), PrintLevel(-1), SumW2Error(false))};; fit1->Print();; ; // In the case of an exponential function, the bias that you get by; // evaluating the pdf only at the bin centers is a constant scale factor in; // each bin. Here, we can do a trick to get rid of the bias: we also; // evaluate the normalization integral for the pdf the same way, i.e.,; // summing the values of the unnormalized pdf at the bin centers. Like this; // the bias cancels out. You can achieve this by customizing the way how the; // pdf is integrated (see also the rf901_numintconfig tutorial).; enableBinIntegrator(expo, x.numBins());; std::unique_ptr<RooFitResult> fit2{expo.fitTo(*expoData, Save(), PrintLevel(-1), SumW2Error(false))};; fit2->Print();; disableBinIntegrator(expo);; ; // Power law example; // -----------------; ; // Let's not look at another example: a power law \f[x^a\f].; RooRealVar a{""a"", ""a"", -0.3, -5.0, 5.0};; RooPowerSum powerlaw{""powerlaw"", ""powerlaw"", x, RooConst(1.0), a};; std::unique_ptr<RooAbsData> powerlawData{generateBinnedAsimov(powerlaw, x, 10000)};; ; // Again, if you do a vanilla fit, you'll get a bias; std::unique_ptr<RooFitResult> fit3{powerlaw.fitTo(*powerlawData, Save(), PrintLevel(-1), SumW2Error(false))};; fit3->Print();; ; // This time, the bias is not the same factor in each bin! This means our; // trick by sampling the integral in the same way doesn't cancel out the; // bias completely. The average bias is canceled, but there are per-bin; // biases that remain. Still, this method has some value: it is cheaper than; // rigurously correcting the bias by integrating the pdf in each bin. So if; // you know your per-bin bias variations are small or performance is an; // issue, this approach can be sufficient.; enableBinIntegrator(powerlaw, x.numBins());; std::unique_ptr<RooFitResult> fit4{powerlaw.fitTo(*powerlawData, Save(), PrintLevel(-1), SumW2Error(false))};; fit4->Print();; disableBinIntegrator(po",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf614__binned__fit__problems_8C.html:4247,power,powerlaw,4247,doc/master/rf614__binned__fit__problems_8C.html,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8C.html,3,['power'],['powerlaw']
Energy Efficiency,"; std::vector< double > GetConfidenceIntervals (double cl=0.95, bool norm=false) const;  evaluate confidence interval for the data set used in the last fit the confidence interval are returned as a vector of data points ;  ; void GetConfidenceIntervals (unsigned int n, unsigned int stride1, unsigned int stride2, const double *x, double *ci, double cl=0.95, bool norm=false) const;  get confidence intervals for an array of n points x. ;  ; template<class Matrix > ; void GetCorrelationMatrix (Matrix &mat) const;  fill a correlation matrix elements using a generic symmetric matrix class implementing operator(i,j) the matrix must be previously allocates with right size (npar * npar) ;  ; template<class Matrix > ; void GetCovarianceMatrix (Matrix &mat) const;  fill covariance matrix elements using a generic matrix class implementing operator(i,j) the matrix must be previously allocates with right size (npar * npar) ;  ; const double * GetErrors () const;  parameter errors (return const pointer) ;  ; std::string GetParameterName (unsigned int ipar) const;  get name of parameter (deprecated) ;  ; const double * GetParams () const;  parameter values (return const pointer) ;  ; double GlobalCC (unsigned int i) const;  parameter global correlation coefficient ;  ; bool HasMinosError (unsigned int i) const;  query if parameter i has the Minos error ;  ; int Index (const std::string &name) const;  get index for parameter name (return -1 if not found) ;  ; bool IsEmpty () const;  True if a fit result does not exist (even invalid) with parameter values. ;  ; bool IsParameterBound (unsigned int ipar) const;  query if a parameter is bound ;  ; bool IsParameterFixed (unsigned int ipar) const;  query if a parameter is fixed ;  ; bool IsValid () const;  True if fit successful, otherwise false. ;  ; double LowerError (unsigned int i) const;  lower Minos error. If Minos has not run for parameter i return the parabolic error ;  ; double MinFcnValue () const;  Return value of the objective",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Fit_1_1FitResult.html:3815,allocate,allocates,3815,doc/master/classROOT_1_1Fit_1_1FitResult.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Fit_1_1FitResult.html,4,['allocate'],['allocates']
Energy Efficiency,"; struct  is_array_class< std::vector< T > >;  ; struct  make_indices_;  ; struct  make_indices_impl;  ; struct  make_indices_impl< First, Step, N, typename std::enable_if<(N > 1 &&N % 2==0)>::type >;  ; struct  make_indices_impl< First, Step, N, typename std::enable_if<(N > 1 &&N % 2==1)>::type >;  ; struct  make_indices_impl< First, Step, N, typename std::enable_if<(N==0)>::type >;  ; struct  make_indices_impl< First, Step, N, typename std::enable_if<(N==1)>::type >;  ; struct  make_indices_next;  ; struct  make_indices_next2;  ; struct  make_indices_next2< indices< Indices... >, Next, Tail >;  ; struct  make_indices_next< indices< Indices... >, Next >;  ; class  TBranchProxy;  Base class for all the proxy object. More...;  ; class  TCollectionProxyInfo;  ; class  TRangeCast;  ; class  TSchemaRuleSet;  ; class  TStatusBitsChecker;  . Typedefs; template<size_t Start, size_t Last, size_t Step = 1> ; using make_indices = typename make_indices_< Start, Last, Step >::type;  ; template<typename T > ; using TRangeStaticCast = TRangeCast< T, false >;  TRangeStaticCast is an adapter class that allows the typed iteration through a TCollection. ;  . Functions; R__ALWAYS_INLINE bool HasBeenDeleted (const TObject *obj);  Check if the TObject's memory has been deleted. ;  ; template<typename T > ; constexpr bool HasCallOp (char);  ; template<typename T > ; constexpr auto HasCallOp (int) -> decltype(&T::operator(), true);  ; template<class ArrayL , class ArrayR > ; bool operator_equal_impl (ArrayL const &lhs, size_t const lhs_size, ArrayR const &rhs, size_t const rhs_size);  . Detailed Description; Special implementation of ROOT::RRangeCast for TCollection, including a check that the cast target type inherits from TObject and a new constructor that takes the TCollection by pointer. ; Template Parameters. TThe new type to convert to. ; isDynamicIf true, dynamic_cast is used, otherwise static_cast is used. . Typedef Documentation. ◆ make_indices. template<size_t Start, size_t Last",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1Detail.html:2112,adapt,adapter,2112,doc/master/namespaceROOT_1_1Detail.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1Detail.html,2,['adapt'],['adapter']
Energy Efficiency,"; subType particle subType as in Geant4; antiEncoding anti encoding; magMoment magnetic moment; excitation excitation energy [GeV]. Bool_t DefineIon(const char* name, Int_t Z, Int_t A, Int_t Q, Double_t excEnergy, Double_t mass = 0.); Set a user defined particle; Function is ignored if particle with specified pdg; already exists and error report is printed.; pdg PDG encoding; name particle name; mcType VMC Particle type; mass mass [GeV]; charge charge [eplus]; lifetime time of life [s]; pType particle type as in Geant4; width width [GeV]; iSpin spin; iParity parity; iConjugation conjugation; iIsospin isospin; iIsospinZ isospin - #rd component; gParity gParity; lepton lepton number; baryon baryon number; stable stability; shortlived is shorlived?; subType particle subType as in Geant4; antiEncoding anti encoding; magMoment magnetic moment; excitation excitation energy [GeV]; Set a user defined ion.; name ion name; Z atomic number; A atomic mass; Q charge [eplus}; excitation excitation energy [GeV]; mass mass [GeV] (if not specified by user, approximative; mass is calculated). Double_t Xsec(char* , Double_t , Int_t , Int_t ); Set a user phase space decay for a particle; pdg particle PDG encoding; bratios the array with branching ratios (in %); mode[6][3] the array with daughters particles PDG codes for each; decay channel; Calculate X-sections; (Geant3 only). Int_t IdFromPDG(Int_t pdg) const. particle table usage. Return MC specific code from a PDG and pseudo ENDF code (pdg). Int_t PDGFromId(Int_t id) const; Return PDG code and pseudo ENDF code from MC specific code (id). TString ParticleName(Int_t pdg) const. get methods. Return name of the particle specified by pdg. Double_t ParticleMass(Int_t pdg) const; Return mass of the particle specified by pdg. Double_t ParticleCharge(Int_t pdg) const; Return charge (in e units) of the particle specified by pdg. Double_t ParticleLifeTime(Int_t pdg) const; Return life time of the particle specified by pdg. TMCParticleType Partic",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualMC.html:29666,charge,charge,29666,root/html528/TVirtualMC.html,https://root.cern,https://root.cern/root/html528/TVirtualMC.html,2,"['charge', 'energy']","['charge', 'energy']"
Energy Efficiency,"; subType particle subType as in Geant4; antiEncoding anti encoding; magMoment magnetic moment; excitation excitation energy [GeV]. Bool_t DefineIon(const char* name, Int_t Z, Int_t A, Int_t Q, Double_t excEnergy, Double_t mass = 0.); Set a user defined particle; Function is ignored if particle with specified pdg; already exists and error report is printed.; pdg PDG encoding; name particle name; mcType VMC Particle type; mass mass [GeV]; charge charge [eplus]; lifetime time of life [s]; pType particle type as in Geant4; width width [GeV]; iSpin spin; iParity parity; iConjugation conjugation; iIsospin isospin; iIsospinZ isospin - #rd component; gParity gParity; lepton lepton number; baryon baryon number; stable stability; shortlived is shorlived?; subType particle subType as in Geant4; antiEncoding anti encoding; magMoment magnetic moment; excitation excitation energy [GeV]; Set a user defined ion.; name ion name; Z atomic number; A atomic mass; Q charge [eplus}; excitation excitation energy [GeV]; mass mass [GeV] (if not specified by user, approximative; mass is calculated). Double_t Xsec(char* , Double_t , Int_t , Int_t ); Set a user phase space decay for a particle; pdg particle PDG encoding; bratios the array with branching ratios (in %); mode[6][3] the array with daughters particles PDG codes for each; decay channel; Calculate X-sections; (Geant3 only); Deprecated. Int_t IdFromPDG(Int_t pdg) const. particle table usage. Return MC specific code from a PDG and pseudo ENDF code (pdg). Int_t PDGFromId(Int_t id) const; Return PDG code and pseudo ENDF code from MC specific code (id). TString ParticleName(Int_t pdg) const. get methods. Return name of the particle specified by pdg. Double_t ParticleMass(Int_t pdg) const; Return mass of the particle specified by pdg. Double_t ParticleCharge(Int_t pdg) const; Return charge (in e units) of the particle specified by pdg. Double_t ParticleLifeTime(Int_t pdg) const; Return life time of the particle specified by pdg. TMCParticl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TVirtualMC.html:29335,charge,charge,29335,root/html530/TVirtualMC.html,https://root.cern,https://root.cern/root/html530/TVirtualMC.html,10,"['charge', 'energy']","['charge', 'energy']"
Energy Efficiency,"; t2.Branch(""vect"",gstep.vect,""vect[7]/F"");; t2.Branch(""getot"",&gstep.getot,""getot/F"");; t2.Branch(""gekin"",&gstep.gekin,""gekin/F"");; t2.Branch(""nmec"",&gstep.nmec,""nmec/I"");; t2.Branch(""lmec"",gstep.lmec,""lmec[nmec]/I"");; t2.Branch(""destep"",&gstep.destep,""destep/F"");; t2.Branch(""pid"",&gstep.pid,""pid/I"");. //Initialize particle parameters at first point; Float_t px,py,pz,p,charge=0;; Float_t vout[7];; Float_t mass = 0.137;; Bool_t newParticle = kTRUE;; gstep.step = 0.1;; gstep.destep = 0;; gstep.nmec = 0;; gstep.pid = 0;. //transport particles; for (Int_t i=0; i<10000; i++) {; //generate a new particle if necessary (Geant3 emulation); if (newParticle) {; px = gRandom->Gaus(0,.02);; py = gRandom->Gaus(0,.02);; pz = gRandom->Gaus(0,.02);; p = TMath::Sqrt(px*px+py*py+pz*pz);; charge = 1;; if (gRandom->Rndm() < 0.5) charge = -1;; gstep.pid += 1;; gstep.vect[0] = 0;; gstep.vect[1] = 0;; gstep.vect[2] = 0;; gstep.vect[3] = px/p;; gstep.vect[4] = py/p;; gstep.vect[5] = pz/p;; gstep.vect[6] = p*charge;; gstep.getot = TMath::Sqrt(p*p + mass*mass);; gstep.gekin = gstep.getot - mass;; newParticle = kFALSE;; }; // fill the Tree with current step parameters; t2.Fill();. //transport particle in magnetic field (Geant3 emulation); helixStep(gstep.step, gstep.vect, vout);; //make one step; //apply energy loss; gstep.destep = gstep.step*gRandom->Gaus(0.0002,0.00001);; gstep.gekin -= gstep.destep;; gstep.getot = gstep.gekin + mass;; gstep.vect[6]= charge*TMath::Sqrt(gstep.getot*gstep.getot; - mass*mass);; gstep.vect[0] = vout[0];; gstep.vect[1] = vout[1];; gstep.vect[2] = vout[2];; gstep.vect[3] = vout[3];; gstep.vect[4] = vout[4];; gstep.vect[5] = vout[5];; gstep.nmec = (Int_t)(5*gRandom->Rndm());; for (Int_t l=0; l<gstep.nmec; l++) gstep.lmec[l] = l;; if (gstep.gekin < 0.001) newParticle = kTRUE;; if (TMath::Abs(gstep.vect[2]) > 30) newParticle = kTRUE;; }; //save the Tree header. The file will be automatically; // closed when going out of the function scope; t2.Write();; }; 12.15.1.1 A",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:563876,charge,charge,563876,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['charge'],['charge']
Energy Efficiency,"; virtual Double_tMakeChi2(const Double_t* coeff = 0); virtual voidMakeCode(const char* functionName = ""MDF"", Option_t* option = """")MENU ; virtual voidMakeHistograms(Option_t* option = ""A"")MENU ; virtual voidMakeMethod(const Char_t* className = ""MDF"", Option_t* option = """")MENU ; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TMultiDimFit&operator=(const TMultiDimFit&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidPrint(Option_t* option = ""ps"") constMENU ; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidSetBinVarX(Int_t nbbinvarx); voidSetBinVarY(Int_t nbbinvary); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetMaxAngle(Double_t angle = 0); voidSetMaxFunctions(Int_t n); voidSetMaxPowers(const Int_t* powers); voidSetMaxStudy(Int_t n); voidSetMaxTerms(Int_t terms); voidSetMinAngle(Double_t angle = 1); voidSetMinRelativeError(Double_t error); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidSetPowerLimit(Double_t limit = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMultiDimFit.html:19587,power,powers,19587,root/html602/TMultiDimFit.html,https://root.cern,https://root.cern/root/html602/TMultiDimFit.html,2,['power'],['powers']
Energy Efficiency,"; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. ULong_tfAllMembersCountNumber of all members (class and its daughters); Bool_tfCollapsedCondition - true if node is collapsed (we don't see dauthers); Float_tfHeightHeight of outlining box; UInt_tfLevelLevel number; UInt_tfMaxLevelNumber of levels displayed when the node is top node on scene; UInt_tfMaxObjectsNumber of objects displayed when the node is top node on scene; TList*fMembersList of daughter nodes; ULong_tfMembersCountNumber of members in class; TStringfNameName of node; ENodeTypefNodeTypeType of node; TStructNode*fParentPointer to parent node, NULL if not exist; void*fPointerPointer to data (address of variable); ULong_tfSizeMemory allocated by class without pointers and list elements; ULong_tfTotalSizeTotal allocated memory; TStringfTypeNameName of type; Bool_tfVisibleCondition - true if node is visible; Float_tfWidthWidth of outlining box; Float_tfXX coordinate in 3D space; Float_tfYY coordinate in 3D space; static EScalingTypefgScalBy. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TStructNode(TString name, TString typeName, void* pointer, TStructNode* parent, ULong_t size, ENodeType type); Constructs node with name ""name"" of class ""typeName"" and given parent ""parent"" which represents pointer ""pointer"".; Size of node is set to ""size"" and type is set to ""type"". ~TStructNode(); Destructs list of nodes. Int_t Compare(const TObject* obj) const; Overrided method. Compare to objects of TStructNode class. U",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TStructNode.html:7466,allocate,allocated,7466,root/html530/TStructNode.html,https://root.cern,https://root.cern/root/html530/TStructNode.html,6,['allocate'],['allocated']
Energy Efficiency,"; virtual ~Interpolator ();  ; double Deriv (double x) const;  Return the derivative of the interpolated function at point x. ;  ; double Deriv2 (double x) const;  Return the second derivative of the interpolated function at point x. ;  ; double Eval (double x) const;  Return the interpolated value at point x. ;  ; double Integ (double a, double b) const;  Return the Integral of the interpolated function over the range [a,b]. ;  ; Interpolator & operator= (const Interpolator &)=delete;  ; Interpolator & operator= (Interpolator &&)=delete;  ; bool SetData (const std::vector< double > &x, const std::vector< double > &y);  Set the data vector ( x[] and y[] ) To be efficient, the size of the data must be the same of the value used in the constructor (ndata) If this is not the case a new re-initialization is performed with the new data size. ;  ; bool SetData (unsigned int ndata, const double *x, const double *y);  Set the data vector ( x[] and y[] ) To be efficient, the size of the data must be the same of the value used when constructing the class (ndata) If this is not the case a new re-initialization is performed with the new data size. ;  ; std::string Type () const;  Return the type of interpolation method. ;  ; std::string TypeGet () const;  . Private Attributes; GSLInterpolator * fInterp;  . #include <Math/Interpolator.h>; Constructor & Destructor Documentation. ◆ Interpolator() [1/4]. ROOT::Math::Interpolator::Interpolator ; (; unsigned int ; ndata = 0, . Interpolation::Type ; type = Interpolation::kCSPLINE . ). Constructs an interpolator class from number of data points and with Interpolation::Type type. ; The data can be set later on with the SetData method. In case the data size is not known, better using the default of zero or the next constructor later on. The default interpolation type is Cubic spline ; Definition at line 40 of file Interpolator.cxx. ◆ Interpolator() [2/4]. ROOT::Math::Interpolator::Interpolator ; (; const std::vector< double > & ; x, . con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1Interpolator.html:2441,efficient,efficient,2441,doc/master/classROOT_1_1Math_1_1Interpolator.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1Interpolator.html,1,['efficient'],['efficient']
Energy Efficiency,"; void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TMCParticle&operator=(const TMCParticle&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); virtual voidTAttLine::ResetAttLine(Option_t* option = """"); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTAttLine::SaveLineAttributes(ostream& out, const char* name, Int_t coldef = 1, Int_t stydef = 1, Int_t widdef = 1); virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetEnergy(Float_t energy); virtual voidSetFirstChild(Int_t first); virtual voidSetKF(Int_t kF); virtual voidSetKS(Int_t kS); virtual voidSetLastChild(Int_t last); virtual voidSetLifetime(Float_t lifetime); virtual voidTAttLine::SetLineAttributes()MENU ; virtual voidTAttLine::SetLineColor(Color_t lcolor); virtual voidTAttLine::SetLineStyle(Style_t lstyle); virtual voidTAttLine::SetLineWidth(Width_t lwidth); virtual voidSetMass(Float_t mass); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetParent(Int_t parent); virtual voidSetPx(Float_t px); virtual voidSetPy(Float_t py); virtual voidSetPz(Float_t pz); virtual voidSetTime(Float_t time); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidSetVx(Float_t vx); virtual voidSetVy(Float_t vy); virtual voidSetVz(Float_t vz); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMCParticle.html:4983,energy,energy,4983,root/html528/TMCParticle.html,https://root.cern,https://root.cern/root/html528/TMCParticle.html,1,['energy'],['energy']
Energy Efficiency,"; voidReadItems(int nElements, TBuffer& b); voidShrink(UInt_t nCurr, UInt_t left, Bool_t force); voidWriteItems(int nElements, TBuffer& b). Data Members; public:. enum TGenCollectionProxy::[unnamed] { kBIT_ISSTRING; kBIT_ISTSTRING; kBOOL_t; };; enum TVirtualCollectionProxy::EProperty { kIsInitialized; kIsAssociative; kIsEmulated; };. public:. static const Int_tTVirtualCollectionProxy::fgIteratorArenaSizegreater than sizeof(void*) + sizeof(UInt_t). protected:. TClassRefTVirtualCollectionProxy::fClass; TGenCollectionProxy::MethodTGenCollectionProxy::fClearMethod cache for container accessors: clear container; TGenCollectionProxy::MethodTGenCollectionProxy::fCollectMethod to collect objects from container; void*TGenCollectionProxy::fConstructContainer accessors: block construct; map<std::string,TObjArray*>*TGenCollectionProxy::fConversionReadMemberWiseArray of bundle of TStreamerInfoActions to stream out (read) derived from another class.; TGenCollectionProxy::Method0TGenCollectionProxy::fCreateEnvMethod to allocate an Environment holder.; void*TGenCollectionProxy::fDestructContainer accessors: block destruct; ROOT::TCollectionProxyInfo::EnvironBase*TGenCollectionProxy::fEnvAddress of the currently proxied object; void*TGenCollectionProxy::fFeedContainer accessors: block feed; TGenCollectionProxy::MethodTGenCollectionProxy::fFirstContainer accessors: generic iteration: first; void*TGenCollectionProxy::fFunctionCreateIterators; void*TGenCollectionProxy::fFunctionDeleteTwoIterators; TGenCollectionProxy::Value*TGenCollectionProxy::fKeyDescriptor of the key_type; stringTGenCollectionProxy::fNameName of the class being proxied.; TGenCollectionProxy::MethodTGenCollectionProxy::fNextContainer accessors: generic iteration: next; TClass*TGenCollectionProxy::fOnFileClassOn file class; Bool_tTGenCollectionProxy::fPointersFlag to indicate if containee has pointers (key or value); UInt_tTVirtualCollectionProxy::fProperties; vector<ROOT::TCollectionProxyInfo::EnvironBase*,allocator<",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEmulatedCollectionProxy.html:4706,allocate,allocate,4706,root/html528/TEmulatedCollectionProxy.html,https://root.cern,https://root.cern/root/html528/TEmulatedCollectionProxy.html,2,['allocate'],['allocate']
Energy Efficiency,"; void Print (Option_t *option=""ps"") const override;  Print statistics etc. ;  ; void SetBinVarX (Int_t nbbinvarx);  ; void SetBinVarY (Int_t nbbinvary);  ; void SetMaxAngle (Double_t angle=0);  Set the max angle (in degrees) between the initial data vector to be fitted, and the new candidate function to be included in the fit. ;  ; void SetMaxFunctions (Int_t n);  ; void SetMaxPowers (const Int_t *powers);  Set the maximum power to be considered in the fit for each variable. ;  ; void SetMaxStudy (Int_t n);  ; void SetMaxTerms (Int_t terms);  ; void SetMinAngle (Double_t angle=1);  Set the min angle (in degrees) between a new candidate function and the subspace spanned by the previously accepted functions. ;  ; void SetMinRelativeError (Double_t error);  Set the acceptable relative error for when sum of square residuals is considered minimized. ;  ; void SetPowerLimit (Double_t limit=1e-3);  Set the user parameter for the function selection. ;  ; virtual void SetPowers (const Int_t *powers, Int_t terms);  Define a user function. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMultiDimFit.html:23671,power,powers,23671,doc/master/classTMultiDimFit.html,https://root.cern,https://root.cern/doc/master/classTMultiDimFit.html,1,['power'],['powers']
Energy Efficiency,"; xmldoc, . XMLNodePointer_t ; xmlnode . ). set main (root) node for document ; Definition at line 1326 of file TXMLEngine.cxx. ◆ FindNs(). XMLNsPointer_t TXMLEngine::FindNs ; (; XMLNodePointer_t ; xmlnode, . const char * ; nsname . ). protected . define if namespace of that name exists for xmlnode ; Definition at line 1562 of file TXMLEngine.cxx. ◆ FreeAllAttr(). void TXMLEngine::FreeAllAttr ; (; XMLNodePointer_t ; xmlnode). Free all attributes of the node. ; Definition at line 647 of file TXMLEngine.cxx. ◆ FreeAttr(). void TXMLEngine::FreeAttr ; (; XMLNodePointer_t ; xmlnode, . const char * ; name . ). remove attribute from xmlnode ; Definition at line 622 of file TXMLEngine.cxx. ◆ FreeDoc(). void TXMLEngine::FreeDoc ; (; XMLDocPointer_t ; xmldoc). frees allocated document data and deletes document itself ; Definition at line 1288 of file TXMLEngine.cxx. ◆ FreeNode(). void TXMLEngine::FreeNode ; (; XMLNodePointer_t ; xmlnode). release all memory, allocated from this node and destroys node itself ; Definition at line 1037 of file TXMLEngine.cxx. ◆ GetAttr(). const char * TXMLEngine::GetAttr ; (; XMLNodePointer_t ; xmlnode, . const char * ; name . ). returns value of attribute for xmlnode ; Definition at line 555 of file TXMLEngine.cxx. ◆ GetAttrName(). const char * TXMLEngine::GetAttrName ; (; XMLAttrPointer_t ; xmlattr). return name of the attribute ; Definition at line 692 of file TXMLEngine.cxx. ◆ GetAttrValue(). const char * TXMLEngine::GetAttrValue ; (; XMLAttrPointer_t ; xmlattr). return value of attribute ; Definition at line 703 of file TXMLEngine.cxx. ◆ GetChild(). XMLNodePointer_t TXMLEngine::GetChild ; (; XMLNodePointer_t ; xmlnode, . Bool_t ; realnode = kTRUE . ). returns first child of xmlnode ; Definition at line 1146 of file TXMLEngine.cxx. ◆ GetFirstAttr(). XMLAttrPointer_t TXMLEngine::GetFirstAttr ; (; XMLNodePointer_t ; xmlnode). return first attribute in the list, namespace (if exists) will be skipped ; Definition at line 665 of file TXMLEngine.c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTXMLEngine.html:25399,allocate,allocated,25399,doc/master/classTXMLEngine.html,https://root.cern,https://root.cern/doc/master/classTXMLEngine.html,1,['allocate'],['allocated']
Energy Efficiency,"; }. Scalar Et() const. return the transverse energy; \f[ e_t = \sqrt{ \frac{E^2 p_{\perp}^2 }{ |p|^2 } } X sign(E) \f]. { return fCoordinates.Et(); }. Scalar Phi() const. azimuthal Angle. { return fCoordinates.Phi();}. Scalar Theta() const. polar Angle. { return fCoordinates.Theta(); }. Scalar Eta() const. pseudorapidity; \f[ \eta = - \ln { \tan { \frac { \theta} {2} } } \f]. { return fCoordinates.Eta(); }. return operator*( Scalar(-1) ); LorentzVector<CoordinateType> v(*this);; v.Negate();. Scalar Rapidity() const; ---- Relativistic Properties ----. Rapidity relative to the Z axis: .5 log [(E+Pz)/(E-Pz)]. Scalar ColinearRapidity() const. Rapidity in the direction of travel: atanh (|P|/E)=.5 log[(E+P)/(E-P)]. bool isTimelike() const. Determine if momentum-energy can represent a physical massive particle. bool isLightlike(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<Double32_t> >::Scalar tolerance = 100*std::numeric_limits<Scalar>::epsilon()) const. Determine if momentum-energy can represent a massless particle. bool isSpacelike() const. Determine if momentum-energy is spacelike, and represents a tachyon. BetaVector BoostToCM() const. The beta vector for the boost that would bring this vector into; its center of mass frame (zero momentum). return - Vect(); TODO - should attempt to Throw with msg about; boostVector computed for LorentzVector with t=0. Scalar Beta() const; beta and gamma. Return beta scalar value. Scalar Gamma() const. Return Gamma scalar value. Scalar x() const; Method providing limited backward name compatibility with CLHEP ----. { return fCoordinates.Px(); }. Scalar y() const; { return fCoordinates.Py(); }. Scalar z() const; { return fCoordinates.Pz(); }. Scalar t() const; { return fCoordinates.E(); }. Scalar px() const; { return fCoordinates.Px(); }. Scalar py() const; { return fCoordinates.Py(); }. Scalar pz() const; { return fCoordinates.Pz(); }. Scalar e() const; { return fCoordinates.E(); }. Scalar theta() const; { return fCoordinates.The",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__LorentzVector_-p1PtEtaPhiE4D_Double32_t___.html:15972,energy,energy,15972,root/html528/ROOT__Math__LorentzVector_-p1PtEtaPhiE4D_Double32_t___.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__LorentzVector_-p1PtEtaPhiE4D_Double32_t___.html,4,['energy'],['energy']
Energy Efficiency,"; }. Scalar Et() const. return the transverse energy; \f[ e_t = \sqrt{ \frac{E^2 p_{\perp}^2 }{ |p|^2 } } X sign(E) \f]. { return fCoordinates.Et(); }. Scalar Phi() const. azimuthal Angle. { return fCoordinates.Phi();}. Scalar Theta() const. polar Angle. { return fCoordinates.Theta(); }. Scalar Eta() const. pseudorapidity; \f[ \eta = - \ln { \tan { \frac { \theta} {2} } } \f]. { return fCoordinates.Eta(); }. return operator*( Scalar(-1) ); LorentzVector<CoordinateType> v(*this);; v.Negate();. Scalar Rapidity() const; ---- Relativistic Properties ----. Rapidity relative to the Z axis: .5 log [(E+Pz)/(E-Pz)]. Scalar ColinearRapidity() const. Rapidity in the direction of travel: atanh (|P|/E)=.5 log[(E+P)/(E-P)]. bool isTimelike() const. Determine if momentum-energy can represent a physical massive particle. bool isLightlike(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<Double32_t> >::Scalar tolerance = 100*std::numeric_limits<Scalar>::epsilon()) const. Determine if momentum-energy can represent a massless particle. bool isSpacelike() const. Determine if momentum-energy is spacelike, and represents a tachyon. BetaVector BoostToCM() const. The beta vector for the boost that would bring this vector into; its center of mass frame (zero momentum). return - Vect(); TODO - should attempt to Throw with msg about; boostVector computed for LorentzVector with t=0. Scalar Beta() const; beta and gamma. Return beta scalar value. Scalar Gamma() const. Return Gamma scalar value. Scalar x() const; Method providing limited backward name compatibility with CLHEP ----. { return fCoordinates.Px(); }. Scalar y() const; { return fCoordinates.Py(); }. Scalar z() const; { return fCoordinates.Pz(); }. Scalar t() const; { return fCoordinates.E(); }. Scalar px() const; { return fCoordinates.Px(); }. Scalar py() const; { return fCoordinates.Py(); }. Scalar pz() const; { return fCoordinates.Pz(); }. Scalar e() const; { return fCoordinates.E(); }. Scalar theta() const; { return fCoordinates.The",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__LorentzVector_-p1PtEtaPhiM4D_Double32_t___.html:15972,energy,energy,15972,root/html528/ROOT__Math__LorentzVector_-p1PtEtaPhiM4D_Double32_t___.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__LorentzVector_-p1PtEtaPhiM4D_Double32_t___.html,4,['energy'],['energy']
Energy Efficiency,";   Example showing an histogram with reverse axis. ;  ;  sparsehist.C;  Evaluate the performance of THnSparse vs TH1/2/3/nF for different numbers of dimensions and bins per dimension. ;  ;  statsEditing.C;   Edit statistics box. ;  ;  testSmooth.C;   Histogram smoothing. ;  ;  th2polyBoxes.C;   This tutorial illustrates how to create an histogram with polygonal bins (TH2Poly). ;  ;  th2polyEurope.C;   This tutorial illustrates how to create an histogram with polygonal bins (TH2Poly), fill it and draw it. ;  ;  th2polyHoneycomb.C;   This tutorial illustrates how to create an histogram with hexagonal bins (TH2Poly). ;  ;  th2polyUSA.C;   This tutorial illustrates how to create an histogram with polygonal bins (TH2Poly), fill it and draw it using the col option. ;  ;  thstack2palettecolor.C;   Palette coloring for 2D histograms' stack is activated thanks to the option PFC (Palette Fill Color). ;  ;  thstackcolorscheme.C;   This example demonstrates how to use the accessible color schemes with THStack. ;  ;  thstackpalettecolor.C;   Palette coloring for histograms' stack is activated thanks to the options PFC (Palette Fill Color), PLC (Palette Line Color) and AMC (Palette Marker Color). ;  ;  tprofile2polyRealistic.C;   Different charges depending on region ;  ;  tprofile2polyRealisticModuleError.C;   Simulate faulty detector panel w.r.t. ;  ;  transpad.C;   Example of a canvas showing two histograms with different scales. ;  ;  twoscales.C;   Example of macro illustrating how to superimpose two histograms with different scales in the ""same"" pad. ;  ;  twoscales.py;   Example of macro illustrating how to superimpose two histograms with different scales in the ""same"" pad. ;  ;  xyplot.C;   Example showing how to produce a plot with an orthogonal axis system centered at (0,0). ;  ;  ZoomHistogram.C;   Changing the Range on the X-Axis of a Histogram ;  . tutorialshist. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:50 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/dir_cb5b3ace9d7fddaf972edd3edd27e2ab.html:6198,charge,charges,6198,doc/master/dir_cb5b3ace9d7fddaf972edd3edd27e2ab.html,https://root.cern,https://root.cern/doc/master/dir_cb5b3ace9d7fddaf972edd3edd27e2ab.html,1,['charge'],['charges']
Energy Efficiency,";  ; Bool_t IsValid () const;  ; Bool_t IsVisContainers () const;  ; virtual Bool_t IsVisible () const;  ; Bool_t IsVisibleDaughters () const;  ; Bool_t IsVisLeaves () const;  ; Bool_t IsVisOnly () const;  ; virtual Bool_t IsVolumeMulti () const;  ; Bool_t IsXYZVoxels () const;  ; TH2F * LegoPlot (Int_t ntheta=20, Double_t themin=0., Double_t themax=180., Int_t nphi=60, Double_t phimin=0., Double_t phimax=360., Double_t rmin=0., Double_t rmax=9999999, Option_t *option="""");  Generate a lego plot fot the top volume, according to option. ;  ; void MakeCopyNodes (const TGeoVolume *other);  make a new list of nodes and copy all nodes of other volume inside ;  ; virtual TGeoVolume * MakeCopyVolume (TGeoShape *newshape);  make a copy of this volume build a volume with same name, shape and medium ;  ; TGeoVolume * MakeReflectedVolume (const char *newname="""") const;  Make a copy of this volume which is reflected with respect to XY plane. ;  ; Bool_t OptimizeVoxels ();  Perform an extensive sampling to find which type of voxelization is most efficient. ;  ; void Paint (Option_t *option="""") override;  paint volume ;  ; void Print (Option_t *option="""") const override;  Print volume info. ;  ; void PrintNodes () const;  print nodes ;  ; void PrintVoxels () const;  Print the voxels for this volume. ;  ; void RandomPoints (Int_t npoints=1000000, Option_t *option="""");  Draw random points in the bounding box of this volume. ;  ; void RandomRays (Int_t nrays=10000, Double_t startx=0, Double_t starty=0, Double_t startz=0, const char *target_vol=nullptr, Bool_t check_norm=kFALSE);  Random raytracing method. ;  ; void Raytrace (Bool_t flag=kTRUE);  Draw this volume with current settings and perform raytracing in the pad. ;  ; void RegisterYourself (Option_t *option="""");  Register the volume and all materials/media/matrices/shapes to the manager. ;  ; void Release ();  ; void RemoveNode (TGeoNode *node);  Remove an existing daughter. ;  ; TGeoNode * ReplaceNode (TGeoNode *nodeorig, TGeoS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoVolume.html:20484,efficient,efficient,20484,doc/master/classTGeoVolume.html,https://root.cern,https://root.cern/doc/master/classTGeoVolume.html,1,['efficient'],['efficient']
Energy Efficiency,";  ; typedef std::vector< EnvironBase_t * > Proxies_t;  ; typedef void(* Sizing_t) (void *obj, size_t size);  ; typedef std::vector< TStaging * > Staged_t;  Collection of pre-allocated staged array for associative containers. ;  ;  Protected Member Functions inherited from TGenCollectionProxy; void CheckFunctions () const;  Check existence of function pointers. ;  ; TGenCollectionProxy * Initialize (Bool_t silent) const;  Proxy initializer. ;  ; virtual TGenCollectionProxy * InitializeEx (Bool_t silent);  Proxy initializer. ;  ;  Protected Attributes inherited from TGenCollectionProxy; Method fClear;  Method cache for container accessors: clear container. ;  ; Collectfunc_t fCollect;  Method to collect objects from container. ;  ; ArrIterfunc_t fConstruct;  Container accessors: block construct. ;  ; std::map< std::string, TObjArray * > * fConversionReadMemberWise;  Array of bundle of TStreamerInfoActions to stream out (read) derived from another class. ;  ; Method0 fCreateEnv;  Method to allocate an Environment holder. ;  ; Sizing_t fDestruct;  Container accessors: block destruct. ;  ; EnvironBase_t * fEnv;  Address of the currently proxied object. ;  ; Feedfunc_t fFeed;  Container accessors: block feed. ;  ; Method fFirst;  Container accessors: generic iteration: first. ;  ; CopyIterator_t fFunctionCopyIterator;  ; CreateIterators_t fFunctionCreateIterators;  ; DeleteIterator_t fFunctionDeleteIterator;  ; DeleteTwoIterators_t fFunctionDeleteTwoIterators;  ; Next_t fFunctionNextIterator;  ; Value * fKey;  Descriptor of the key_type. ;  ; std::string fName;  Name of the class being proxied. ;  ; Method fNext;  Container accessors: generic iteration: next. ;  ; TClass * fOnFileClass;  On file class. ;  ; Bool_t fPointers;  Flag to indicate if containee has pointers (key or value) ;  ; Proxies_t fProxyKept;  Optimization: Keep proxies once they were created. ;  ; Proxies_t fProxyList;  Stack of recursive proxies. ;  ; TObjArray * fReadMemberWise;  Array of bundle of TS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGenBitsetProxy.html:9783,allocate,allocate,9783,doc/master/classTGenBitsetProxy.html,https://root.cern,https://root.cern/doc/master/classTGenBitsetProxy.html,6,['allocate'],['allocate']
Energy Efficiency,";  ; virtual TClass * GetTargetClass ();  ; Int_t GetType () const;  ; template<typename T > ; T GetTypedValue (Int_t i, Int_t len, bool subarr=false) const;  ; virtual const char * GetTypeName () const;  Return type name of element in the branch. ;  ; Double_t GetValue (Int_t i, Int_t len, bool subarr=false) const;  ; virtual void * GetValuePointer () const;  Returns pointer to first data element of this branch. ;  ; TClass * IsA () const override;  ; bool IsBranchFolder () const;  ; bool IsFolder () const override;  Return true if more than one leaf, false otherwise. ;  ; virtual bool IsObjectOwner () const;  ; bool Notify () override;  This method must be overridden to handle object notification (the base implementation is no-op). ;  ; void Print (Option_t *option="""") const override;  Print TBranch parameters. ;  ; void PrintValue (Int_t i) const;  Prints values of leaves. ;  ; void Reset (Option_t *option="""") override;  Reset a Branch. ;  ; void ResetAddress () override;  Set branch address to zero and free all allocated memory. ;  ; void ResetAfterMerge (TFileMergeInfo *) override;  Reset a Branch after a Merge operation (drop data but keep customizations) ;  ; virtual void ResetDeleteObject ();  Release ownership of any allocated objects. ;  ; virtual void ResetInitInfo (bool recurse);  Reset offset and StreamerInfo information from this branch. ;  ; void SetAddress (void *addobj) override;  Point this branch at an object. ;  ; void SetBasketSize (Int_t buffsize) override;  Reset the basket size for all sub-branches of this branch element. ;  ; virtual void SetBranchFolder ();  ; virtual void SetClassName (const char *name);  ; bool SetMakeClass (bool decomposeObj=true) override;  Set the branch in a mode where the object are decomposed (Also known as MakeClass mode). ;  ; virtual void SetMissing ();  Set offset of the object (to which the data member represented by this branch belongs) inside its containing object (if any) to mark it as missing. ;  ; void SetO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBranchElement.html:6194,allocate,allocated,6194,doc/master/classTBranchElement.html,https://root.cern,https://root.cern/doc/master/classTBranchElement.html,1,['allocate'],['allocated']
Energy Efficiency,";  ; virtual const char * GetTypeName () const;  Return type name of element in the branch. ;  ; Double_t GetValue (Int_t i, Int_t len, bool subarr=false) const;  ; virtual void * GetValuePointer () const;  Returns pointer to first data element of this branch. ;  ; TClass * IsA () const override;  ; bool IsBranchFolder () const;  ; bool IsFolder () const override;  Return true if more than one leaf, false otherwise. ;  ; virtual bool IsObjectOwner () const;  ; bool Notify () override;  This method must be overridden to handle object notification (the base implementation is no-op). ;  ; void Print (Option_t *option="""") const override;  Print TBranch parameters. ;  ; void PrintValue (Int_t i) const;  Prints values of leaves. ;  ; void Reset (Option_t *option="""") override;  Reset a Branch. ;  ; void ResetAddress () override;  Set branch address to zero and free all allocated memory. ;  ; void ResetAfterMerge (TFileMergeInfo *) override;  Reset a Branch after a Merge operation (drop data but keep customizations) ;  ; virtual void ResetDeleteObject ();  Release ownership of any allocated objects. ;  ; virtual void ResetInitInfo (bool recurse);  Reset offset and StreamerInfo information from this branch. ;  ; void SetAddress (void *addobj) override;  Point this branch at an object. ;  ; void SetBasketSize (Int_t buffsize) override;  Reset the basket size for all sub-branches of this branch element. ;  ; virtual void SetBranchFolder ();  ; virtual void SetClassName (const char *name);  ; bool SetMakeClass (bool decomposeObj=true) override;  Set the branch in a mode where the object are decomposed (Also known as MakeClass mode). ;  ; virtual void SetMissing ();  Set offset of the object (to which the data member represented by this branch belongs) inside its containing object (if any) to mark it as missing. ;  ; void SetObject (void *objadd) override;  Set object this branch is pointing to. ;  ; void SetOffset (Int_t offset) override;  Set offset of the object (to which the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBranchElement.html:6409,allocate,allocated,6409,doc/master/classTBranchElement.html,https://root.cern,https://root.cern/doc/master/classTBranchElement.html,1,['allocate'],['allocated']
Energy Efficiency,";  ;  Static Public Member Functions inherited from TAttMarker; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Width_t GetMarkerLineWidth (Style_t style);  Internal helper function that returns the line width of the given marker style (0 = filled marker) ;  ; static Style_t GetMarkerStyleBase (Style_t style);  Internal helper function that returns the corresponding marker style with line width 1 for the given style. ;  ;  Static Public Member Functions inherited from TAttText; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  . Protected Attributes; Float_t fAlpha;  Per cent of transparency. ;  ; std::vector< float > fAlphas;  List of alpha values used. ;  ; Float_t fBlue;  Per cent of blue. ;  ; Bool_t fCompress;  True when fBuffer must be compressed. ;  ; Float_t fGreen;  Per cent of green. ;  ; Float_t fLineScale;  Line width scale factor. ;  ; Int_t fNbObj {0};  Number of objects. ;  ; Int_t fNbPage;  Number of pages. ;  ; Int_t * fObjPos {nullptr};  Objects position. ;  ; Int_t fObjPosSize {0};  Real size of fObjPos. ;  ; Int_t fPageFormat;  Page format (A4, Letter etc ...) ;  ; Bool_t fPageNotEmpty;  True if the current page is not empty. ;  ; Int_t fPageOrientation;  Page orientation (Portrait, Landscape) ;  ; Bool_t fRange;  True when a range has been defined. ;  ; Float_t fRed;  Per cent of red. ;  ; Int_t fStartStream;  ; Int_t fType;  Workstation type used to know if the PDF is open. ;  ; Float_t fXsize;  Page size along X. ;  ; Float_t fYsize;  Page size along Y. ;  ;  Protected Attributes inherited from TVirtualPS; char * fBuffer {nullptr};  ; const char * fImplicitCREsc {nullptr};  ; Int_t fLenBuffer {0};  ; Int_t fNByte {0};  ; Bool_t fPrinted {kFALSE};  ; Int_t fSizBuffer {0};  ; std::ofstream * fStream {nullptr};  ;  Protected Attribute",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPDF.html:24036,green,green,24036,doc/master/classTPDF.html,https://root.cern,https://root.cern/doc/master/classTPDF.html,1,['green'],['green']
Energy Efficiency,";  Constructor with unit label. ;  ;  RooAbsReal (const char *name, const char *title, double minVal, double maxVal, const char *unit="""");  Constructor with plot range and unit label. ;  ;  RooAbsReal (const RooAbsReal &other, const char *name=nullptr);  Copy constructor. ;  ;  ~RooAbsReal () override;  Destructor. ;  ; virtual double analyticalIntegral (Int_t code, const char *rangeName=nullptr) const;  Implements the actual analytical integral(s) advertised by getAnalyticalIntegral. ;  ; TF1 * asTF (const RooArgList &obs, const RooArgList &pars=RooArgList(), const RooArgSet &nset=RooArgSet()) const;  Return a ROOT TF1,2,3 object bound to this RooAbsReal with given definition of observables and parameters. ;  ; virtual std::list< double > * binBoundaries (RooAbsRealLValue &obs, double xlo, double xhi) const;  Retrieve bin boundaries if this distribution is binned in obs. ;  ; RooFit::OwningPtr< RooAbsFunc > bindVars (const RooArgSet &vars, const RooArgSet *nset=nullptr, bool clipInvalid=false) const;  Create an interface adaptor f(vars) that binds us to the specified variables (in arbitrary order). ;  ; virtual std::string buildCallToAnalyticIntegral (Int_t code, const char *rangeName, RooFit::Detail::CodeSquashContext &ctx) const;  This function defines the analytical integral translation for the class. ;  ; virtual RooFit::OwningPtr< RooFitResult > chi2FitTo (RooDataHist &data, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={});  Perform a \( \chi^2 \) fit to given histogram. ;  ; virtual RooFit::OwningPtr< RooFitResult > chi2FitTo (RooDataHist &data, const RooLinkedList &cmdList);  Calls RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList) and returns fit result. ;  ; virtual RooFit::OwningPtr< RooFitResult > chi2FitTo (RooDataSet &xydata, const RooCmdArg &arg1={}, const RooCmdArg &arg2={},",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooBMixDecay.html:18963,adapt,adaptor,18963,doc/master/classRooBMixDecay.html,https://root.cern,https://root.cern/doc/master/classRooBMixDecay.html,40,['adapt'],['adaptor']
Energy Efficiency,";   kFitAlphaOptimal =1; , kFitPower2 =2; , kFitPower4 =4; , kFitPower6 =6; , ;   kFitPower8 =8; , kFitPower10 =10; , kFitPower12 =12; , kFitTaylorOrderFirst =0; , ;   kFitTaylorOrderSecond =1; , kFitNumRegulCycles =100. };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  . Public Member Functions;  TSpectrum2Fit (Int_t numberPeaks);  numberPeaks: number of fitted peaks (must be greater than zero) the constructor allocates arrays for all fitted parameters (peak positions, amplitudes etc) and sets the member variables to their default values. ;  ;  TSpectrum2Fit (void);  Default constructor. ;  ;  ~TSpectrum2Fit () override;  Destructor. ;  ; void FitAwmi (Double_t **source);  This function fits the source spectrum. ;  ; void FitStiefel (Double_t **source);  This function fits the source spectrum. ;  ; void GetAmplitudeErrors (Double_t *amplitudeErrors, Double_t *amplitudeErrorsX1, Double_t *amplitudeErrorsY1);  This function gets the amplitudes of fitted 2D peaks and 1D ridges. ;  ; void GetAmplitudes (Double_t *amplitudes, Double_t *amplitudesX1, Double_t *amplitudesY1);  This function gets the amplitudes of fitted 2D peaks and 1D ridges. ;  ; void GetBackgroundParameters (Double_t &a0, Double_t &a0Err, Double_t &ax, Double_t &axErr, Double_t &ay, Double_t &ayErr);  This function gets the background parameters and their errors. ;  ; Double_t GetChi () const;  ; void GetPositionErrors (Do",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSpectrum2Fit.html:2779,allocate,allocates,2779,doc/master/classTSpectrum2Fit.html,https://root.cern,https://root.cern/doc/master/classTSpectrum2Fit.html,1,['allocate'],['allocates']
Energy Efficiency,";; 1710 ; 1711// // remove the weights of the output layer of the preNet; 1712// preWeights.erase (preWeights.begin () + _numWeights, preWeights.end ());; 1713 ; 1714// // remove the outputLayer of the preNet; 1715// preNet.removeLayer ();; 1716 ; 1717// // set the output size to the number of nodes in the new output layer (== last hidden layer); 1718// preNet.setOutputSize (numNodes);; 1719 ; 1720// // transform pattern using the created preNet; 1721// auto proceedPattern = [&](std::vector<Pattern>& pttrn); 1722// {; 1723// std::vector<Pattern> newPttrn;; 1724// std::for_each (std::begin (pttrn), std::end (pttrn),; 1725// [&preNet,&preWeights,&newPttrn](Pattern& p); 1726// {; 1727// std::vector<double> output = preNet.compute (p.input (), preWeights);; 1728// Pattern pat (output, output, p.weight ());; 1729// newPttrn.push_back (pat);; 1730// // p = pat;; 1731// });; 1732// return newPttrn;; 1733// };; 1734 ; 1735 ; 1736// prePatternTrain = proceedPattern (prePatternTrain);; 1737// prePatternTest = proceedPattern (prePatternTest);; 1738 ; 1739 ; 1740// // the new input size is the output size of the already reduced preNet; 1741// _inputSize = preNet.layers ().back ().numNodes ();; 1742// }; 1743// }; 1744 ; 1745 ; 1746 ; 1747 ; 1748 ; 1749 ; 1750 ; 1751 ; 1752 ; 1753 ; 1754 ; 1755 ; 1756 ; 1757 ; 1758 ; 1759 ; 1760 } // namespace DNN; 1761} // namespace TMVA; 1762 ; 1763#endif; MethodBase.h; Pattern.h; f#define f(i)Definition RSha256.hxx:104; g#define g(i)Definition RSha256.hxx:105; kMagenta@ kMagentaDefinition Rtypes.h:66; kBlue@ kBlueDefinition Rtypes.h:66; wwinID wDefinition TGWin32VirtualGLProxy.cxx:39; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; inputOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void inputDefinition TGWin32VirtualXProxy.cxx:142; resultOption_t Option_t TPoint TPoint const char GetTextMagnitude GetF",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/NeuralNet_8icc_source.html:58615,reduce,reduced,58615,doc/master/NeuralNet_8icc_source.html,https://root.cern,https://root.cern/doc/master/NeuralNet_8icc_source.html,1,['reduce'],['reduced']
Energy Efficiency,";; 3540 ; 3541 if (!(gifArr = (unsigned char *) calloc(filesize+256,1))) {; 3542 Error(""ReadGIF"", ""unable to allocate array for gif"");; 3543 fclose(fd);; 3544 return pic;; 3545 }; 3546 ; 3547 if (fread(gifArr, filesize, 1, fd) != 1) {; 3548 Error(""ReadGIF"", ""GIF file read failed"");; 3549 free(gifArr);; 3550 fclose(fd);; 3551 return pic;; 3552 }; 3553 fclose(fd);; 3554 ; 3555 irep = GIFinfo(gifArr, &width, &height, &ncolor);; 3556 if (irep != 0) {; 3557 free(gifArr);; 3558 return pic;; 3559 }; 3560 ; 3561 if (!(pixArr = (unsigned char *) calloc((width*height),1))) {; 3562 Error(""ReadGIF"", ""unable to allocate array for image"");; 3563 free(gifArr);; 3564 return pic;; 3565 }; 3566 ; 3567 irep = GIFdecode(gifArr, pixArr, &width, &height, &ncolor, red, green, blue);; 3568 if (irep != 0) {; 3569 free(gifArr);; 3570 free(pixArr);; 3571 return pic;; 3572 }; 3573 ; 3574 // S E T P A L E T T E; 3575 ; 3576 offset = 8;; 3577 ; 3578 for (i = 0; i < ncolor; i++) {; 3579 rr = red[i]/255.;; 3580 gg = green[i]/255.;; 3581 bb = blue[i]/255.;; 3582 j = i+offset;; 3583 SetRGB(j,rr,gg,bb);; 3584 }; 3585 ; 3586 // O U T P U T I M A G E; 3587 ; 3588 for (i = 1; i <= height/2; i++) {; 3589 j1 = pixArr + (i-1)*width;; 3590 j2 = pixArr + (height-i)*width;; 3591 for (k = 0; k < width; k++) {; 3592 icol = *j1; *j1++ = *j2; *j2++ = icol;; 3593 }; 3594 }; 3595 if (id) pic = CreatePixmap(id, width, height);; 3596 PutImage(offset,-1,x0,y0,width,height,0,0,width-1,height-1,pixArr,pic);; 3597 ; 3598 free(gifArr);; 3599 free(pixArr);; 3600 ; 3601 if (pic); 3602 return pic;; 3603 else if (gCws->fDrawing); 3604 return (Pixmap_t)gCws->fDrawing;; 3605 return 0;; 3606}; 3607 ; 3608////////////////////////////////////////////////////////////////////////////////; 3609/// Returns an array of pixels created from a part of drawable; 3610/// (defined by x, y, w, h) in format:; 3611/// `b1, g1, r1, 0, b2, g2, r2, 0, ..., bn, gn, rn, 0`.; 3612///; 3613/// Pixels are numbered from left to right and from top to bot",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGX11_8cxx_source.html:117835,green,green,117835,doc/master/TGX11_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html,1,['green'],['green']
Energy Efficiency,";; 967 ; 968 if (f->Eval(x, y - eyL) < f->Eval(x, y + eyH)) {; 969 eyLNew = TMath::Abs(fxy - f->Eval(x, y - eyL));; 970 eyHNew = TMath::Abs(f->Eval(x, y + eyH) - fxy);; 971 } else {; 972 eyHNew = TMath::Abs(fxy - f->Eval(x, y - eyL));; 973 eyLNew = TMath::Abs(f->Eval(x, y + eyH) - fxy);; 974 }; 975 ; 976 // systematic errors and error on x doesn't change; 977 SetPointEY(i, 0, eyLNew, eyHNew);; 978 }; 979 ; 980 if (gPad); 981 gPad->Modified();; 982}; 983 ; 984////////////////////////////////////////////////////////////////////////////////; 985/// This function is only kept for backward compatibility.; 986/// You should rather use the Divide method.; 987/// It calls `Divide(pass,total,""cl=0.683 b(1,1) mode"")` which is equivalent to the; 988/// former BayesDivide method.; 989 ; 990void TGraphMultiErrors::BayesDivide(const TH1 *pass, const TH1 *total, Option_t *); 991{; 992 Divide(pass, total, ""cl=0.683 b(1,1) mode"");; 993}; 994 ; 995////////////////////////////////////////////////////////////////////////////////; 996/// This function was adapted from the TGraphAsymmErrors class.; 997/// See TGraphAsymmErrors::Divide for the documentation; 998///; 999/// Only the first error dimension is affected.; 1000 ; 1001void TGraphMultiErrors::Divide(const TH1 *pass, const TH1 *total, Option_t *opt); 1002{; 1003 // check pointers; 1004 if (!pass || !total) {; 1005 Error(""Divide"", ""one of the passed pointers is zero"");; 1006 return;; 1007 }; 1008 ; 1009 // check dimension of histograms; only 1-dimensional ones are accepted; 1010 if ((pass->GetDimension() > 1) || (total->GetDimension() > 1)) {; 1011 Error(""Divide"", ""passed histograms are not one-dimensional"");; 1012 return;; 1013 }; 1014 ; 1015 // check whether histograms are filled with weights -> use number of effective; 1016 // entries; 1017 Bool_t bEffective = false;; 1018 // compare sum of weights with sum of squares of weights; 1019 // re-compute here to be sure to get the right values; 1020 Double_t psumw = 0;; 1021 Double_t p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:34395,adapt,adapted,34395,doc/master/TGraphMultiErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html,1,['adapt'],['adapted']
Energy Efficiency,";; ; sprintf(FunName,""Fitfcn_%s"",his->GetName());; ; TF1 *ffitold = (TF1*)gROOT->GetListOfFunctions()->FindObject(FunName);; if (ffitold) delete ffitold;; ; TF1 *ffit = new TF1(FunName,langaufun,fitrange[0],fitrange[1],4);; ffit->SetParameters(startvalues);; ffit->SetParNames(""Width"",""MP"",""Area"",""GSigma"");; ; for (i=0; i<4; i++) {; ffit->SetParLimits(i, parlimitslo[i], parlimitshi[i]);; }; ; his->Fit(FunName,""RB0""); // fit within specified range, use ParLimits, do not plot; ; ffit->GetParameters(fitparams); // obtain fit parameters; for (i=0; i<4; i++) {; fiterrors[i] = ffit->GetParError(i); // obtain fit parameter errors; }; ChiSqr[0] = ffit->GetChisquare(); // obtain chi^2; NDF[0] = ffit->GetNDF(); // obtain ndf; ; return (ffit); // return fit function; ; }; ; ; int langaupro(double *params, double &maxx, double &FWHM) {; ; // Searches for the location (x value) at the maximum of the; // Landau-Gaussian convolute and its full width at half-maximum.; //; // The search is probably not very efficient, but it's a first try.; ; double p,x,fy,fxr,fxl;; double step;; double l,lold;; int i = 0;; int MAXCALLS = 10000;; ; ; // Search for maximum; ; p = params[1] - 0.1 * params[0];; step = 0.05 * params[0];; lold = -2.0;; l = -1.0;; ; ; while ( (l != lold) && (i < MAXCALLS) ) {; i++;; ; lold = l;; x = p + step;; l = langaufun(&x,params);; ; if (l < lold); step = -step/10;; ; p += step;; }; ; if (i == MAXCALLS); return (-1);; ; maxx = x;; ; fy = l/2;; ; ; // Search for right x location of fy; ; p = maxx + params[0];; step = params[0];; lold = -2.0;; l = -1e300;; i = 0;; ; ; while ( (l != lold) && (i < MAXCALLS) ) {; i++;; ; lold = l;; x = p + step;; l = TMath::Abs(langaufun(&x,params) - fy);; ; if (l > lold); step = -step/10;; ; p += step;; }; ; if (i == MAXCALLS); return (-2);; ; fxr = x;; ; ; // Search for left x location of fy; ; p = maxx - 0.5 * params[0];; step = -params[0];; lold = -2.0;; l = -1e300;; i = 0;; ; while ( (l != lold) && (i < MAXCALLS) ) {; i++;; ; lold = l;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/langaus_8C.html:4375,efficient,efficient,4375,doc/master/langaus_8C.html,https://root.cern,https://root.cern/doc/master/langaus_8C.html,1,['efficient'],['efficient']
Energy Efficiency,"< ( 13 )). };  ;  Public Types inherited from RooPrintable; enum  ContentsOption { ;   kName =1; , kClassName =2; , kValue =4; , kArgs =8; , ;   kExtras =16; , kAddress =32; , kTitle =64; , kCollectionHeader =128. };  ; enum  StyleOption { ;   kInline =1; , kSingleLine =2; , kStandard =3; , kVerbose =4; , ;   kTreeStructure =5. };  . Public Member Functions;  RooFFTConvPdf ();  ;  RooFFTConvPdf (const char *name, const char *title, RooAbsReal &pdfConvVar, RooRealVar &convVar, RooAbsPdf &pdf1, RooAbsPdf &pdf2, Int_t ipOrder=2);  Constructor for numerical (FFT) convolution of PDFs. ;  ;  RooFFTConvPdf (const char *name, const char *title, RooRealVar &convVar, RooAbsPdf &pdf1, RooAbsPdf &pdf2, Int_t ipOrder=2);  Constructor for numerical (FFT) convolution of PDFs. ;  ;  RooFFTConvPdf (const RooFFTConvPdf &other, const char *name=nullptr);  Copy constructor. ;  ;  ~RooFFTConvPdf () override;  Destructor. ;  ; double bufferFraction () const;  Return value of buffer fraction applied in FFT calculation array beyond either end of the observable domain to reduce cyclical effects. ;  ; BufStrat bufferStrategy () const;  Return the strategy currently used to fill the buffer: 'Extend' means is that the input p.d.f convolution observable range is widened to include the buffer range 'Flat' means that the buffer is filled with the p.d.f. ;  ; const RooArgSet & cacheObservables () const;  ; TObject * clone (const char *newname) const override;  ; Int_t getMaxVal (const RooArgSet &vars) const override;  Advertise capability to determine maximum value of function for given set of observables. ;  ; TClass * IsA () const override;  ; double maxVal (Int_t code) const override;  Return maximum value for set of observables identified by code assigned in getMaxVal. ;  ; void printMetaArgs (std::ostream &os) const override;  Customized printing of arguments of a RooNumConvPdf to more intuitively reflect the contents of the product operator construction. ;  ; void setBufferFraction (double f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooFFTConvPdf.html:7737,reduce,reduce,7737,doc/master/classRooFFTConvPdf.html,https://root.cern,https://root.cern/doc/master/classRooFFTConvPdf.html,1,['reduce'],['reduce']
Energy Efficiency,"< double >; double operator() (const double *x) const;  ; double operator() (const double *x, const double *p) const;  Evaluate function at a point x and for given parameters p. ;  ;  Public Member Functions inherited from ROOT::Math::IBaseFunctionMultiDimTempl< T >; virtual ~IBaseFunctionMultiDimTempl ()=default;  ; virtual bool HasGradient () const;  ; T operator() (const T *x) const;  Evaluate the function at a point x[]. ;  ;  Public Member Functions inherited from ROOT::Math::IBaseParam; virtual ~IBaseParam ();  Virtual Destructor (no operations) ;  ; virtual std::string ParameterName (unsigned int i) const;  Return the name of the i-th parameter (starting from zero) Overwrite if want to avoid the default name (""Par_0, Par_1, ..."") ;  . Private Member Functions;  WrappedParamFunctionGen (const WrappedParamFunctionGen &)=delete;  ; double DoEval (const double *x) const override;  evaluate the function (re-implement for being more efficient) ;  ; double DoEvalPar (const double *x, const double *p) const override;  implement the required IParamFunction interface ;  ; void DoInit ();  ; WrappedParamFunctionGen & operator= (const WrappedParamFunctionGen &)=delete;  ; void SetParValues (unsigned int npar, const double *p) const;  . Private Attributes; unsigned int fDim;  ; FuncPtr fFunc;  ; std::vector< double > fParams;  ; std::vector< unsigned int > fParIndices;  ; std::vector< unsigned int > fVarIndices;  ; std::vector< double > fX;  . Additional Inherited Members;  Public Types inherited from ROOT::Math::IParametricFunctionMultiDimTempl< double >; typedef IBaseFunctionMultiDimTempl< double > BaseFunc;  ;  Public Types inherited from ROOT::Math::IBaseFunctionMultiDimTempl< T >; typedef T BackendType;  ; typedef IBaseFunctionMultiDimTempl< T > BaseFunc;  . #include <Math/WrappedParamFunction.h>. Inheritance diagram for ROOT::Math::WrappedParamFunctionGen< FuncPtr >:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1WrappedParamFunctionGen.html:2977,efficient,efficient,2977,doc/master/classROOT_1_1Math_1_1WrappedParamFunctionGen.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1WrappedParamFunctionGen.html,1,['efficient'],['efficient']
Energy Efficiency,"< ncolors; i++) {; 3363 R[i] = xcol[i].red;; 3364 G[i] = xcol[i].green;; 3365 B[i] = xcol[i].blue;; 3366 }; 3367 ncol = ncolors;; 3368 ; 3369 // update image with indices (pixels) into the new RGB colormap; 3370 for (x = 0; x < (int) gCws->fWidth; x++) {; 3371 for (y = 0; y < (int) gCws->fHeight; y++) {; 3372 ULong_t pixel = XGetPixel(image, x, y);; 3373 Int_t idx = FindColor(pixel, orgcolors, ncolors);; 3374 XPutPixel(image, x, y, idx);; 3375 }; 3376 }; 3377 ; 3378 // cleanup; 3379 delete [] xcol;; 3380 ::operator delete(orgcolors);; 3381}; 3382 ; 3383////////////////////////////////////////////////////////////////////////////////; 3384/// Writes the current window into GIF file. Returns 1 in case of success,; 3385/// 0 otherwise.; 3386 ; 3387Int_t TGX11::WriteGIF(char *name); 3388{; 3389 Byte_t scline[2000], r[256], b[256], g[256];; 3390 Int_t *red, *green, *blue;; 3391 Int_t ncol, maxcol, i;; 3392 ; 3393 if (gXimage) {; 3394 XDestroyImage(gXimage);; 3395 gXimage = nullptr;; 3396 }; 3397 ; 3398 gXimage = XGetImage((Display*)fDisplay, gCws->fDrawing, 0, 0,; 3399 gCws->fWidth, gCws->fHeight,; 3400 AllPlanes, ZPixmap);; 3401 ; 3402 ImgPickPalette((RXImage*)gXimage, ncol, red, green, blue);; 3403 ; 3404 if (ncol > 256) {; 3405 //GIFquantize(...);; 3406 Error(""WriteGIF"", ""Cannot create GIF of image containing more than 256 colors. Try in batch mode."");; 3407 delete [] red;; 3408 delete [] green;; 3409 delete [] blue;; 3410 return 0;; 3411 }; 3412 ; 3413 maxcol = 0;; 3414 for (i = 0; i < ncol; i++) {; 3415 if (maxcol < red[i] ) maxcol = red[i];; 3416 if (maxcol < green[i] ) maxcol = green[i];; 3417 if (maxcol < blue[i] ) maxcol = blue[i];; 3418 r[i] = 0;; 3419 g[i] = 0;; 3420 b[i] = 0;; 3421 }; 3422 if (maxcol != 0) {; 3423 for (i = 0; i < ncol; i++) {; 3424 r[i] = red[i] * 255/maxcol;; 3425 g[i] = green[i] * 255/maxcol;; 3426 b[i] = blue[i] * 255/maxcol;; 3427 }; 3428 }; 3429 ; 3430 gOut = fopen(name, ""w+"");; 3431 ; 3432 if (gOut) {; 3433 GIFencode(gCws->fWidth, gCws->f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGX11_8cxx_source.html:112539,green,green,112539,doc/master/TGX11_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html,2,['green'],['green']
Energy Efficiency,"<< ( 13 )). };  ;  Public Attributes inherited from TArrayD; Double_t * fArray;  ;  Public Attributes inherited from TArray; Int_t fN;  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Static Protected Member Functions inherited from TH3; static TH1D * DoProject1D (const TH3 &h, const char *name, const char *title, const TAxis *projX, bool computeErrors, bool originalRange, bool useUF, bool useOF);  static methdod performing the projection to 1D histogram ;  ; static TH2D * DoProject2D (const TH3 &h, const char *name, const char *title, const TAxis *projX, const TAxis *projY, bool computeErrors, bool originalRange, bool useUF, bool useOF);  static methdod performing the projection to 2D histogram ;  ;  Static Protected Member Functions inherited from TH1; static Int_t AutoP2GetBins (Int_t n);  Auxiliary function to get the next power of 2 integer value larger then n. ;  ; static Double_t AutoP2GetPower2 (Double_t x, Bool_t next=kTRUE);  Auxiliary function to get the power of 2 next (larger) or previous (smaller) a given x. ;  ; static bool CheckAxisLimits (const TAxis *a1, const TAxis *a2);  Check that the axis limits of the histograms are the same. ;  ; static bool CheckBinLabels (const TAxis *a1, const TAxis *a2);  Check that axis have same labels. ;  ; static bool CheckBinLimits (const TAxis *a1, const TAxis *a2);  Check bin limits. ;  ; static int CheckConsistency (const TH1 *h1, const TH1 *h2);  Check histogram compatibility. ;  ; static bool CheckConsistentSubAxes (const TAxis *a1, Int_t firstBin1, Int_t lastBin1, const TAxis *a2, Int_t firstBin2=0, Int_t lastBin2=0);  Check that two sub axis are the same. ;  ; static bool CheckEqualAxes (const TAxis *a1, const TAxis *a2);  Check that the axis are the same. ;  ; static Bool_t RecomputeAxisLimits (TAxis &destAxis, const TAxis &anAxis);  Finds new limits for the axis for the Merge function. ;  ; static Bool_t SameLimitsAndNBins (const TAxis &axis1, const TAxis &axis2);  S",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH3D.html:57603,power,power,57603,doc/master/classTH3D.html,https://root.cern,https://root.cern/doc/master/classTH3D.html,2,['power'],['power']
Energy Efficiency,"<Element> &TMatrixTSym<Element> InvertFast(Double_t* det = 0); Invert the matrix and calculate its determinant. TMatrixTSym<Element> &TMatrixTSym<Element> Transpose(const TMatrixTSym<double>& source); Transpose a matrix. TMatrixTSym<Element> &TMatrixTSym<Element> Rank1Update(const TVectorT<double>& v, double alpha = 1.0); Perform a rank 1 operation on the matrix:; A += alpha * v * v^T. TMatrixTSym<Element> &TMatrixTSym<Element> Similarity(const TMatrixT<Element> &b); Calculate B * (*this) * B^T , final matrix will be (nrowsb x nrowsb); This is a similarity transform when B is orthogonal . It is more; efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . TMatrixTSym<Element> &TMatrixTSym<Element> Similarity(const TMatrixTSym<Element> &b); Calculate B * (*this) * B^T , final matrix will be (nrowsb x nrowsb); This is a similarity transform when B is orthogonal . It is more; efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . Element TMatrixTSym<Element> Similarity(const TVectorT<double>& v) const; Calculate scalar v * (*this) * v^T. TMatrixTSym<Element> &TMatrixTSym<Element> SimilarityT(const TMatrixT<double>& n); Calculate B^T * (*this) * B , final matrix will be (ncolsb x ncolsb); It is more efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . TMatrixTSym<Element> &TMatrixTSym<Element> operator=(const TMatrixTSym<Element> &source). TMatrixTSym<Element> &TMatrixTSym<Element> operator=(const TMatrixTSymLazy<Element> &lazy_constructor). TMatrixTSym<Element> &TMatrixTSym<Element> operator=(Element val); Assign val to every element of the matrix. TMatrixTSym<Element> &TMatrixTSym<Element> operator+=(Element val); Add val to every element of the matrix. TMatrixTSym<Element> &TMatrixTSym<Element> operator-=(Element val); Subtract val from every element of the matrix. TMatrixTSym<Ele",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMatrixTSym_double_.html:18413,efficient,efficient,18413,root/html528/TMatrixTSym_double_.html,https://root.cern,https://root.cern/root/html528/TMatrixTSym_double_.html,4,['efficient'],['efficient']
Energy Efficiency,"<RooAbsReal*>(createPlotProjection(deps, &projectedVars, projectionCompList, o.projectionRangeName));; 1983 cxcoutD(Plotting) << ""RooAbsReal::plotOn("" << GetName() << "") plot projection object is "" << projection->GetName() << std::endl ;; 1984 if (dologD(Plotting)) {; 1985 projection->printStream(ccoutD(Plotting),0,kVerbose) ;; 1986 }; 1987 ; 1988 // Always fix RooAddPdf normalizations; 1989 RooArgSet fullNormSet(deps) ;; 1990 fullNormSet.add(projectedVars) ;; 1991 if (projDataNeededVars && !projDataNeededVars->empty()) {; 1992 fullNormSet.add(*projDataNeededVars) ;; 1993 }; 1994 ; 1995 std::unique_ptr<RooArgSet> projectionComponents(projection->getComponents());; 1996 for(auto * pdf : dynamic_range_cast<RooAbsPdf*>(*projectionComponents)) {; 1997 if (pdf) {; 1998 pdf->selectNormalization(&fullNormSet) ;; 1999 }; 2000 }; 2001 ; 2002 // Apply data projection, if requested; 2003 if (o.projData && projDataNeededVars && !projDataNeededVars->empty()) {; 2004 ; 2005 // If data set contains more rows than needed, make reduced copy first; 2006 RooAbsData* projDataSel = const_cast<RooAbsData*>(o.projData);; 2007 std::unique_ptr<RooAbsData> projDataSelOwned;; 2008 ; 2009 if (projDataNeededVars->size() < o.projData->get()->size()) {; 2010 ; 2011 // Determine if there are any slice variables in the projection set; 2012 std::unique_ptr<RooArgSet> sliceDataSet{sliceSet.selectCommon(*o.projData->get())};; 2013 TString cutString ;; 2014 if (!sliceDataSet->empty()) {; 2015 bool first(true) ;; 2016 for(RooAbsArg * sliceVar : *sliceDataSet) {; 2017 if (!first) {; 2018 cutString.Append(""&&"") ;; 2019 } else {; 2020 first=false ;; 2021 }; 2022 ; 2023 RooAbsRealLValue* real ;; 2024 RooAbsCategoryLValue* cat ;; 2025 if ((real = dynamic_cast<RooAbsRealLValue*>(sliceVar))) {; 2026 cutString.Append(Form(""%s==%f"",real->GetName(),real->getVal())) ;; 2027 } else if ((cat = dynamic_cast<RooAbsCategoryLValue*>(sliceVar))) {; 2028 cutString.Append(Form(""%s==%d"",cat->GetName(),cat->getCurrentIndex()",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8cxx_source.html:88480,reduce,reduced,88480,doc/master/RooAbsReal_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html,1,['reduce'],['reduced']
Energy Efficiency,"<TAttParticle.h>. Inheritance diagram for TAttParticle:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TAttParticle() [1/2]. TAttParticle::TAttParticle ; (; ). Particle definition default constructor. ; Definition at line 32 of file TAttParticle.cxx. ◆ TAttParticle() [2/2]. TAttParticle::TAttParticle ; (; const char * ; name, . const char * ; title, . Double_t ; Mass, . Bool_t ; Stable, . Double_t ; DecayWidth, . Double_t ; Charge, . const char * ; Type, . Int_t ; MCnumber, . Int_t ; granularity = 90, . Double_t ; LowerCutOff = 1.e-5, . Double_t ; HighCutOff = 1.e4 . ). Particle definition normal constructor. ; If the particle is set to be stable, the decay width parameter does have no meaning and can be set to any value. The parameters granularity, LowerCutOff and HighCutOff are used for the construction of the mean free path look up tables. The granularity will be the number of logwise energy points for which the mean free path will be calculated. ; Definition at line 56 of file TAttParticle.cxx. ◆ ~TAttParticle(). TAttParticle::~TAttParticle ; (; ). override . Particle destructor. ; Definition at line 80 of file TAttParticle.cxx. Member Function Documentation. ◆ Class(). static TClass * TAttParticle::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TAttParticle::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TAttParticle::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 69 of file TAttParticle.h. ◆ ConvertISAtoPDG(). Int_t TAttParticle::ConvertISAtoPDG ; (; Int_t ; isaNumber). static . Converts the ISAJET Particle number into the PDG MC number. ; Definition at line 89 of file TAttParticle.cxx. ◆ DeclFileName(). static const char * TAttParticle::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class de",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTAttParticle.html:13978,energy,energy,13978,doc/master/classTAttParticle.html,https://root.cern,https://root.cern/doc/master/classTAttParticle.html,1,['energy'],['energy']
Energy Efficiency,"<nodename1>; |; ---> <key1> - <value1>; ---> <key2> - <value2>; ---> <nodename2>; |; ---> <key3> - <value3>; ---> <key4> - <value4>. The parameter monid is equivalent to the MonaLisa node name, for the; case of process monitoring it can be just an identifier to classify; the type of jobs e.g. ""PROOF_PROCESSING"".; If monid is not specified, TMonaLisaWriter tries to set it in this order; from environement variables:; - PROOF_JOB_ID; - GRID_JOB_ID; - LCG_JOB_ID; - ALIEN_MASTERJOB_ID; - ALIEN_PROC_ID. The parameter montag is equivalent to the MonaLisa farm name, for the; case of process monitoring it can be a process identifier e.g. a PROOF; session ID. The parameter monserver specifies the server to whom to send the; monitoring UDP packets. If not specified, the hostname (the port is; a default one) is specified in the environment variable APMON_CONFIG. To use TMonaLisaWriter, libMonaLisa.so has to be loaded. According to the fact, that the deepness of the MonaLisa naming scheme; is only 3 (<farm><node><value>), a special naming scheme is used for; process monitoring. There is a high-level method to send progress; information of Tree analysis (# of events, datasize).; To distinguish individual nodes running the processing, part of the; information is kept in the <value> parameter of ML.; <value> is named as:; <site-name>:<host-name>:<pid>:<valuetag>; <site-name> is taken from an environment variable in the following order:; - PROOF_SITE; - GRID_SITE; - ALIEN_SITE; - default 'none'; <host-name> is taken from gSystem->Hostname(); <pid> is the process ID of the ROOT process. Example of use for Process Monitoring:; new TMonaLisaWriter(""BATCH_ANALYSIS"",""AnalysisLoop-00001"",""lxplus050.cern.ch"");; Once when you create an analysis task, execute; gMonitoringWriter->SendInfoUser(""myname"");; gMonitoringWriter->SendInfoDescription(""My first Higgs analysis"");; gMonitoringWriter->SendInfoTime();; gMonitoringWriter->SendInfoStatus(""Submitted"");. On each node executing a subtask, you ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMonaLisaWriter.html:11188,monitor,monitoring,11188,root/html530/TMonaLisaWriter.html,https://root.cern,https://root.cern/root/html530/TMonaLisaWriter.html,2,['monitor'],['monitoring']
Energy Efficiency,"<th>..</th>; intfInTrTrue if within <tr>..</tr>; TGHtmlListStart*fInnerListThe inner most <OL> or <UL>; intfInputIdxUnique input index; SHtmlIndex_tfInsThe insertion cursor position; intfInsIndexIndex in pInsBlock of the cursor; intfInsOffTimeHow long it is off (milliseconds); intfInsOnTimeHow long the cursor states one (millisec); intfInsStatusIs it visible?; TTimer*fInsTimerTimer used to flash the insertion cursor; TGHtmlBlock*fLastBlockLast TGHtmlBlock in the list; intfLastGCIndex of recently used GC; TGHtmlInput*fLastInputLast <INPUT> element; TGHtmlElement*fLastSizedLast HTML element that has been sized; const char*fLastUriUsed in HandleMotion; Bool_tTGCompositeFrame::fLayoutBrokenno layout manager is used; TGHtmlLayoutContextfLayoutContext; TGLayoutManager*TGCompositeFrame::fLayoutManagerlayout manager; TList*TGCompositeFrame::fListcontainer of frame elements; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; TGHtmlElement*fLoEndPtrHow far AddStyle has gone to; TGHtmlForm*fLoFormStartFor AddStyle; Bool_tTGCompositeFrame::fMapSubwindowskTRUE - map subwindows; TGInsetsfMarginsdocument margins (separation between the; UInt_tTGFrame::fMaxHeightmaximal frame height; UInt_tTGFrame::fMaxWidthmaximal frame width; intfMaxXMaximum extent of any ""paint"" that appears; intfMaxYMaximum extent of any ""paint"" that appears; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; TGLongPositionTGView::fMousePosposition of mouse; const TGWindow*TGWidget::fMsgWindowwindow which handles widget events; Int_tTGCompositeFrame::fMustCleanupcleanup mode (see EFrameCleanup); intfNAllocSpace allocated for zText; intfNCompleteHow much of zText has actually been; intfNFormThe number of <FORM> elements; intfNInputThe number of <INPUT> elements; intfNTextNumber of characters in zText; intfNTokenNumber of HTML tokens on the list.; TStringTGWindow::fNamename of the window",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGHtml.html:28963,allocate,allocated,28963,root/html602/TGHtml.html,https://root.cern,https://root.cern/root/html602/TGHtml.html,2,['allocate'],['allocated']
Energy Efficiency,"= """") const; Make a clone of an collection using the Streamer facility.; If newname is specified, this will be the name of the new collection. Int_t Compare(const TObject* obj) const; Compare two TCollection objects. Returns 0 when equal, -1 when this is; smaller and +1 when bigger (like strcmp()). void Draw(Option_t* option = """"); Draw all objects in this collection. void Dump() const; Dump all objects in this collection. TObject * FindObject(const char* name) const; Find an object in this collection using its name. Requires a sequential; scan till the object has been found. Returns 0 if object with specified; name is not found. TObject * operator()(const char* name) const; Find an object in this collection by name. TObject * FindObject(const TObject* obj) const; Find an object in this collection using the object's IsEqual(); member function. Requires a sequential scan till the object has; been found. Returns 0 if object is not found.; Typically this function is overridden by a more efficient version; in concrete collection classes (e.g. THashTable). const char * GetName() const; Return name of this collection.; if no name, return the collection class name. Int_t GrowBy(Int_t delta) const; Increase the collection's capacity by delta slots. Bool_t IsArgNull(const char* where, const TObject* obj) const; Returns true if object is a null pointer. void ls(Option_t* option = """") const; List (ls) all objects in this collection.; Wildcarding supported, eg option=""xxx*"" lists only objects; with names xxx*. void Paint(Option_t* option = """"); Paint all objects in this collection. void PrintCollectionHeader(Option_t* option) const; Print the collection header. const char* GetCollectionEntryName(TObject* entry) const; For given collection entry return the string that is used to; identify the object and, potentially, perform wildcard/regexp; filtering on. void PrintCollectionEntry(TObject* entry, Option_t* option, Int_t recurse) const; Print the collection entry. void Print(Optio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TCollection.html:9370,efficient,efficient,9370,root/html528/TCollection.html,https://root.cern,https://root.cern/root/html528/TCollection.html,6,['efficient'],['efficient']
Energy Efficiency,"= ""ordered"" (iTies = 0): input x are ""ordered""; ties = ""mean"" (iTies = 1): function ""mean""; ties = ""min"" (iTies = 2): function ""min""; ties = ""max"" (iTies = 3): function ""max"". Details:; At least two complete (x, y) pairs are required.; If there are duplicated (tied) x values and ties is a function it is; applied to the y values for each distinct x value. Useful functions in; this context include mean, min, and max.; If ties=""ordered"" the x values are assumed to be already ordered. The; first y value will be used for interpolation to the left and the last; one for interpolation to the right. Value:; approx returns a graph with components x and y, containing n coordinates; which interpolate the given data points according to the method (and rule); desired. Double_t Approx1(Double_t v, Double_t f, Double_t* x, Double_t* y, Int_t n, Int_t iKind, Double_t Ylow, Double_t Yhigh); Approximate one data point*-*-*-*-*-; *-* ==========================. Approximate y(v), given (x,y)[i], i = 0,..,n-1; Based on R function approx1: Translated to C++ by Christian Stratowa; (R source file: approx.c by R Development Core Team (C) 1999-2001). Int_t Rcmp(Double_t x, Double_t y); static function; if (ISNAN(x)) return 1;; if (ISNAN(y)) return -1;. void Psort(Double_t* x, Int_t n, Int_t k); static function; based on R function rPsort: adapted to C++ by Christian Stratowa; (R source file: R_sort.c by R Development Core Team (C) 1999-2001). void Rank(Int_t n, Double_t* a, Int_t* index, Int_t* rank, Bool_t down = kTRUE); static function. TGraphSmooth(const TGraphSmooth& ). TGraphSmooth& operator=(const TGraphSmooth& ). » Author: Christian Stratowa 30/09/2001 » Copyright (c) 2001- , Dr. Christian Stratowa, Vienna, Austria. *; » Last changed: root/hist:$Id: TGraphSmooth.h 24702 2008-07-08 12:01:46Z brun $ » Last generated: 2010-09-23 20:14; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGraphSmooth.html:17135,adapt,adapted,17135,root/html528/TGraphSmooth.html,https://root.cern,https://root.cern/root/html528/TGraphSmooth.html,1,['adapt'],['adapted']
Energy Efficiency,"= ""ordered"" (iTies = 0): input x are ""ordered""; ties = ""mean"" (iTies = 1): function ""mean""; ties = ""min"" (iTies = 2): function ""min""; ties = ""max"" (iTies = 3): function ""max"". Details:; At least two complete (x, y) pairs are required.; If there are duplicated (tied) x values and ties is a function it is; applied to the y values for each distinct x value. Useful functions in; this context include mean, min, and max.; If ties=""ordered"" the x values are assumed to be already ordered. The; first y value will be used for interpolation to the left and the last; one for interpolation to the right. Value:; approx returns a graph with components x and y, containing n coordinates; which interpolate the given data points according to the method (and rule); desired. Double_t Approx1(Double_t v, Double_t f, Double_t* x, Double_t* y, Int_t n, Int_t iKind, Double_t Ylow, Double_t Yhigh); Approximate one data point*-*-*-*-*-; *-* ==========================. Approximate y(v), given (x,y)[i], i = 0,..,n-1; Based on R function approx1: Translated to C++ by Christian Stratowa; (R source file: approx.c by R Development Core Team (C) 1999-2001). Int_t Rcmp(Double_t x, Double_t y); static function; if (ISNAN(x)) return 1;; if (ISNAN(y)) return -1;. void Psort(Double_t* x, Int_t n, Int_t k); static function; based on R function rPsort: adapted to C++ by Christian Stratowa; (R source file: R_sort.c by R Development Core Team (C) 1999-2001). void Rank(Int_t n, Double_t* a, Int_t* index, Int_t* rank, Bool_t down = kTRUE); static function. TGraphSmooth(const TGraphSmooth& ). TGraphSmooth& operator=(const TGraphSmooth& ). » Author: Christian Stratowa 30/09/2001 » Copyright (c) 2001- , Dr. Christian Stratowa, Vienna, Austria. *; » Last changed: root/hist:$Id: TGraphSmooth.h 24702 2008-07-08 12:01:46Z brun $ » Last generated: 2011-07-04 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGraphSmooth.html:17204,adapt,adapted,17204,root/html530/TGraphSmooth.html,https://root.cern,https://root.cern/root/html530/TGraphSmooth.html,1,['adapt'],['adapted']
Energy Efficiency,"= ""ordered"" (iTies = 0): input x are ""ordered""; ties = ""mean"" (iTies = 1): function ""mean""; ties = ""min"" (iTies = 2): function ""min""; ties = ""max"" (iTies = 3): function ""max"". Details:; At least two complete (x, y) pairs are required.; If there are duplicated (tied) x values and ties is a function it is; applied to the y values for each distinct x value. Useful functions in; this context include mean, min, and max.; If ties=""ordered"" the x values are assumed to be already ordered. The; first y value will be used for interpolation to the left and the last; one for interpolation to the right. Value:; approx returns a graph with components x and y, containing n coordinates; which interpolate the given data points according to the method (and rule); desired. Double_t Approx1(Double_t v, Double_t f, Double_t* x, Double_t* y, Int_t n, Int_t iKind, Double_t Ylow, Double_t Yhigh); Approximate one data point*-*-*-*-*-; *-* ==========================. Approximate y(v), given (x,y)[i], i = 0,..,n-1; Based on R function approx1: Translated to C++ by Christian Stratowa; (R source file: approx.c by R Development Core Team (C) 1999-2001). Int_t Rcmp(Double_t x, Double_t y); static function; if (ISNAN(x)) return 1;; if (ISNAN(y)) return -1;. void Psort(Double_t* x, Int_t n, Int_t k); static function; based on R function rPsort: adapted to C++ by Christian Stratowa; (R source file: R_sort.c by R Development Core Team (C) 1999-2001). void Rank(Int_t n, Double_t* a, Int_t* index, Int_t* rank, Bool_t down = kTRUE); static function. TGraphSmooth(const TGraphSmooth& ). TGraphSmooth& operator=(const TGraphSmooth& ). » Author: Christian Stratowa 30/09/2001 » Copyright (c) 2001- , Dr. Christian Stratowa, Vienna, Austria. *; » Last changed: root/hist:$Id: TGraphSmooth.h 24702 2008-07-08 12:01:46Z brun $ » Last generated: 2011-11-03 20:18; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGraphSmooth.html:17204,adapt,adapted,17204,root/html532/TGraphSmooth.html,https://root.cern,https://root.cern/root/html532/TGraphSmooth.html,1,['adapt'],['adapted']
Energy Efficiency,"= 0, double relTol = 0, const double* hint = 0) const; boolRunOnePoint(double thisX, bool adaptive = false, double clTarget = -1) const; voidSetAutoScan(); static voidSetCloseProof(Bool_t flag); virtual voidSetConfidenceLevel(Double_t cl); virtual voidSetData(RooAbsData&); voidSetFixedScan(int nBins, double xMin = 1, double xMax = -1); voidSetMaximumToys(int ntoys); virtual voidSetModel(const RooStats::ModelConfig&); voidSetNumErr(double err); virtual voidSetTestSize(Double_t size); boolSetTestStatistic(RooStats::TestStatistic& stat); voidSetVerbose(int level = 1); virtual voidShowMembers(TMemberInspector& insp); virtual Double_tSize() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidUseCLs(bool on = true). protected:. static voidCheckInputModels(const RooStats::HypoTestCalculatorGeneric& hc, const RooRealVar& scanVar); voidCreateResults() const; RooStats::HypoTestResult*Eval(RooStats::HypoTestCalculatorGeneric& hc, bool adaptive, double clsTarget) const; static RooRealVar*GetVariableToScan(const RooStats::HypoTestCalculatorGeneric& hc); RooStats::HypoTestInverterHypoTestInverter(const RooStats::HypoTestInverter& rhs); RooStats::HypoTestInverter&operator=(const RooStats::HypoTestInverter& rhs). Data Members; public:. enum ECalculatorType { kUndefined; kHybrid; kFrequentist; kAsymptotic; };. private:. RooStats::HypoTestInverter::ECalculatorTypefCalcType; RooStats::HypoTestCalculatorGeneric*fCalculator0pointer to the calculator passed in the constructor; RooStats::HypoTestInverter::auto_ptr<HypoTestCalculatorGeneric>fHC; auto_ptr<TGraphErrors>fLimitPlot! plot of limits; intfMaxToysmaximum number of toys to run ; intfNBins; doublefNumErr; RooStats::HypoTestInverterResult*fResultspointer to the result ; RooRealVar*fScannedVariablepointer to the constrained variable; doublefSize; intfTotalToysRun; boolfUseCLs; intfVerbose; doublefXmax; doublefXmin; static doublefgAbsAccuracy; static stringfgAlgo; static doublefgCLAccuracy; static boolfgCloseP",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooStats__HypoTestInverter.html:4105,adapt,adaptive,4105,root/html532/RooStats__HypoTestInverter.html,https://root.cern,https://root.cern/root/html532/RooStats__HypoTestInverter.html,1,['adapt'],['adaptive']
Energy Efficiency,"= 0, double relTol = 0, const double* hint = 0) const; boolRunOnePoint(double thisX, bool adaptive = false, double clTarget = -1) const; voidSetAutoScan(); static voidSetCloseProof(Bool_t flag); virtual voidSetConfidenceLevel(Double_t cl); virtual voidSetData(RooAbsData&); voidSetFixedScan(int nBins, double xMin = 1, double xMax = -1); voidSetMaximumToys(int ntoys); virtual voidSetModel(const RooStats::ModelConfig&); voidSetNumErr(double err); virtual voidSetTestSize(Double_t size); boolSetTestStatistic(RooStats::TestStatistic& stat); voidSetVerbose(int level = 1); virtual voidShowMembers(TMemberInspector& insp); virtual Double_tSize() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidUseCLs(bool on = true). protected:. static voidCheckInputModels(const RooStats::HypoTestCalculatorGeneric& hc, const RooRealVar& scanVar); voidCreateResults() const; RooStats::HypoTestResult*Eval(RooStats::HypoTestCalculatorGeneric& hc, bool adaptive, double clsTarget) const; static RooRealVar*GetVariableToScan(const RooStats::HypoTestCalculatorGeneric& hc); RooStats::HypoTestInverterHypoTestInverter(const RooStats::HypoTestInverter& rhs); RooStats::HypoTestInverter&operator=(const RooStats::HypoTestInverter& rhs). Data Members; public:. enum ECalculatorType { kUndefined; kHybrid; kFrequentist; };. private:. RooStats::HypoTestInverter::ECalculatorTypefCalcType; RooStats::HypoTestCalculatorGeneric*fCalculator0pointer to the calculator passed in the constructor; RooStats::HypoTestInverter::auto_ptr<HypoTestCalculatorGeneric>fHC; auto_ptr<TGraphErrors>fLimitPlot! plot of limits; intfMaxToysmaximum number of toys to run ; intfNBins; doublefNumErr; RooStats::HypoTestInverterResult*fResultspointer to the result ; RooRealVar*fScannedVariablepointer to the constrained variable; doublefSize; intfTotalToysRun; boolfUseCLs; intfVerbose; doublefXmax; doublefXmin; static doublefgAbsAccuracy; static stringfgAlgo; static doublefgCLAccuracy; static boolfgCloseProof; static ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooStats__HypoTestInverter.html:3976,adapt,adaptive,3976,root/html530/RooStats__HypoTestInverter.html,https://root.cern,https://root.cern/root/html530/RooStats__HypoTestInverter.html,1,['adapt'],['adaptive']
Energy Efficiency,"= 1.0); Perform a rank 1 operation on the matrix:; A += alpha * v * v^T. TMatrixTSym<Element> &TMatrixTSym<Element> Similarity(const TMatrixT<Element> &b); Calculate B * (*this) * B^T , final matrix will be (nrowsb x nrowsb); This is a similarity transform when B is orthogonal . It is more; efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . TMatrixTSym<Element> &TMatrixTSym<Element> Similarity(const TMatrixTSym<Element> &b); Calculate B * (*this) * B^T , final matrix will be (nrowsb x nrowsb); This is a similarity transform when B is orthogonal . It is more; efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . Element TMatrixTSym<Element> Similarity(const TVectorT<double>& v) const; Calculate scalar v * (*this) * v^T. TMatrixTSym<Element> &TMatrixTSym<Element> SimilarityT(const TMatrixT<double>& n); Calculate B^T * (*this) * B , final matrix will be (ncolsb x ncolsb); It is more efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . TMatrixTSym<Element> &TMatrixTSym<Element> operator=(const TMatrixTSym<Element> &source). TMatrixTSym<Element> &TMatrixTSym<Element> operator=(const TMatrixTSymLazy<Element> &lazy_constructor). TMatrixTSym<Element> &TMatrixTSym<Element> operator=(Element val); Assign val to every element of the matrix. TMatrixTSym<Element> &TMatrixTSym<Element> operator+=(Element val); Add val to every element of the matrix. TMatrixTSym<Element> &TMatrixTSym<Element> operator-=(Element val); Subtract val from every element of the matrix. TMatrixTSym<Element> &TMatrixTSym<Element> operator*=(double val); Multiply every element of the matrix with val. TMatrixTSym<Element> &TMatrixTSym<Element> operator+=(const TMatrixTSym<Element> &source); Add the source matrix. TMatrixTSym<Element> &TMatrixTSym<Element> operator-=(const TMatrixTSym<Element> &source); Subtract the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMatrixTSym_double_.html:18805,efficient,efficient,18805,root/html528/TMatrixTSym_double_.html,https://root.cern,https://root.cern/root/html528/TMatrixTSym_double_.html,4,['efficient'],['efficient']
Energy Efficiency,"= kTRUE); Double_tXtoPDF(Double_t x); Double_tYtoPDF(Double_t y). protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Float_tfAlphaPer cent of transparency; vector<float>fAlphasList of alpha values used; Float_tfBluePer cent of blue; char*TVirtualPS::fBufferFile buffer; Bool_tfCompressTrue when fBuffer must be compressed; Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; Float_tfGreenPer cent of green; const char*TVirtualPS::fImplicitCREscEscape symbol before enforced new line; Int_tTVirtualPS::fLenBufferBuffer length; Color_tTAttLine::fLineColorline color; Float_tfLineScaleLine width scale factor; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; Color_tTAttMarker::fMarkerColorMarker color index; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; Int_tTVirtualPS::fNByteNumber of bytes written in the file (PDF); TStringTNamed::fNameobject identifier; Int_tfNbObjNumber of objects; Int_tfNbPageNumber of pages; Int_t*fObjPosObjets position; Int_tfObjPosSizeReal size of fObjPos; Int_tfPageFormatPage format (A4, Letter etc ...); Bool_tfPageNotEmptyTrue if the current page is not empty; Int_tfPageOrientationPage orientation (Portrait, Landscape); Bool_tTVirtualPS::fPrintedTrue when a page must be printed; Bool_tfRangeTrue when a range has been defined; Float_tfRedPer cent of red; Int_tTVirtualPS::fSizBufferBuffer size; Int_tfStartStream; ofstream*TVirtualPS::fStreamFile stream identifier; Short_tTAttText::fTextAlignText alignment; Float_tTAttText::fTextAngleText angle; Color_tTAttText::fTextColorText color",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TPDF.html:11868,green,green,11868,root/html534/TPDF.html,https://root.cern,https://root.cern/root/html534/TPDF.html,1,['green'],['green']
Energy Efficiency,"= oldNumOfPoints + buff->segs[3*i+2];; 176 ; 177 segs[currSeg].color = &(colors[c]);; 178 segs[currSeg].P = &(points[p]);; 179 segs[currSeg].Q = &(points[q]);; 180 ; 181 /*; 182 * Update points' segment lists; 183 */; 184 ; 185 if(points[p].numSegs == 0){; 186 if((points[p].segs = (segment **)calloc(1, sizeof(segment *))) == NULL){; 187 puts(""Unable to allocate memory for point segments !"");; 188 return;; 189 }; 190 }else{; 191 if((points[p].segs = (segment **)realloc(points[p].segs,; 192 (points[p].numSegs + 1) * sizeof(segment *))) == NULL){; 193 puts(""Unable to allocate memory for point segments !"");; 194 return;; 195 }; 196 }; 197 ; 198 if(points[q].numSegs == 0){; 199 if((points[q].segs = (segment **)calloc(1, sizeof(segment *))) == NULL){; 200 puts(""Unable to allocate memory for point segments !"");; 201 return;; 202 }; 203 }else{; 204 if((points[q].segs = (segment **)realloc(points[q].segs,; 205 (points[q].numSegs + 1) * sizeof(segment *))) == NULL){; 206 puts(""Unable to allocate memory for point segments !"");; 207 return;; 208 }; 209 }; 210 points[p].segs[points[p].numSegs] = &(segs[currSeg]);; 211 points[q].segs[points[q].numSegs] = &(segs[currSeg]);; 212 points[p].numSegs++;; 213 points[q].numSegs++;; 214 ; 215 }; 216 ; 217 /*; 218 * Read polygons; 219 */; 220 ; 221 n = 0;; 222 ; 223 for (i = 0; i < buff->numPolys; i++, currPoly++) {; 224 c = buff->polys[n++];; 225 polys[currPoly].color = &(colors)[c];; 226 polys[currPoly].numSegs = buff->polys[n++];; 227 ; 228 polys[currPoly].segs = (segment **) calloc(polys[currPoly].numSegs, sizeof(segment *));; 229 if (!polys[currPoly].segs) {; 230 puts(""Unable to allocate memory for polygon segments !"");; 231 return;; 232 }; 233 for (j = 0; j < polys[currPoly].numSegs; j++) {; 234 int seg = oldNumOfSegments + buff->polys[n++];; 235 polys[currPoly].segs[j] = &(segs[seg]);; 236 ; 237 /*; 238 * Update segments' polygon lists; 239 */; 240 ; 241 if(segs[seg].numPolys == 0) {; 242 if((segs[seg].polys = (polygon **) calloc(1,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/X3DBuffer_8c_source.html:6422,allocate,allocate,6422,doc/master/X3DBuffer_8c_source.html,https://root.cern,https://root.cern/doc/master/X3DBuffer_8c_source.html,1,['allocate'],['allocate']
Energy Efficiency,"= typename TTraits::CallableTraits<F>::ret_type>; 1688 RResultPtr<T> Reduce(F f, std::string_view columnName = """"); 1689 {; 1690 static_assert(; 1691 std::is_default_constructible<T>::value,; 1692 ""reduce object cannot be default-constructed. Please provide an initialisation value (redIdentity)"");; 1693 return Reduce(std::move(f), columnName, T());; 1694 }; 1695 ; 1696 ////////////////////////////////////////////////////////////////////////////; 1697 /// \brief Execute a user-defined reduce operation on the values of a column.; 1698 /// \tparam F The type of the reduce callable. Automatically deduced.; 1699 /// \tparam T The type of the column to apply the reduction to. Automatically deduced.; 1700 /// \param[in] f A callable with signature `T(T,T)`; 1701 /// \param[in] columnName The column to be reduced. If omitted, the first default column is used instead.; 1702 /// \param[in] redIdentity The reduced object of each thread is initialized to this value.; 1703 /// \return the reduced quantity wrapped in a RResultPtr.; 1704 ///; 1705 /// ### Example usage:; 1706 /// ~~~{.cpp}; 1707 /// auto sumOfIntColWithOffset = d.Reduce([](int x, int y) { return x + y; }, ""intCol"", 42);; 1708 /// ~~~; 1709 /// See the description of the first Reduce overload for more information.; 1710 template <typename F, typename T = typename TTraits::CallableTraits<F>::ret_type>; 1711 RResultPtr<T> Reduce(F f, std::string_view columnName, const T &redIdentity); 1712 {; 1713 return Aggregate(f, f, columnName, redIdentity);; 1714 }; 1715 ; 1716 ////////////////////////////////////////////////////////////////////////////; 1717 /// \brief Return the number of entries processed (*lazy action*).; 1718 /// \return the number of entries wrapped in a RResultPtr.; 1719 ///; 1720 /// Useful e.g. for counting the number of entries passing a certain filter (see also `Report`).; 1721 /// This action is *lazy*: upon invocation of this method the calculation is; 1722 /// booked but not executed. Also see RRes",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RInterface_8hxx_source.html:95540,reduce,reduced,95540,doc/master/RInterface_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RInterface_8hxx_source.html,1,['reduce'],['reduced']
Energy Efficiency,"=(const TMVA::KDEKernel&); voidSetKernelType(TMVA::KDEKernel::EKernelType ktype = kGauss); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). private:. TMVA::MsgLogger&Log() const. Data Members; public:. static TMVA::KDEKernel::EKernelIterkAdaptiveKDE; static TMVA::KDEKernel::EKernelTypekGauss; static TMVA::KDEKernel::EKernelBorderkKernelRenorm; static TMVA::KDEKernel::EKernelBorderkNoTreatment; static TMVA::KDEKernel::EKernelIterkNonadaptiveKDE; static TMVA::KDEKernel::EKernelTypekNone; static TMVA::KDEKernel::EKernelBorderkSampleMirror. private:. Float_tfFineFactorfine tuning factor for Adaptive KDE: factor to multiply the ""width"" of the Kernel function; TH1F*fFirstIterHisthistogram to be filled in the hidden iteration; Bool_tfHiddenIterationDefines if whats currently running is the; TH1F*fHistcopy of input histogram; TMVA::KDEKernel::EKernelIterfIteriteration number; TMVA::KDEKernel::EKernelBorderfKDEborderThe method to take care about ""border"" effects; TF1*fKernel_integthe integral of the Kernel function; TMVA::MsgLogger*fLoggermessage logger; Float_tfLowerEdgethe lower edge of the PDF; Float_tfSigmaWidth of the Kernel function; TH1F*fSigmaHistcontains the Sigmas Widths for adaptive KDE; Float_tfUpperEdgethe upper edge of the PDF. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; KDEKernel(TMVA::KDEKernel::EKernelIter kiter = kNonadaptiveKDE, const TH1* hist = 0, Float_t lower_edge = 0., Float_t upper_edge = 1., TMVA::KDEKernel::EKernelBorder kborder = kNoTreatment, Float_t FineFactor = 1.); constructor; sanity check. ~KDEKernel(); destructor. void SetKernelType(TMVA::KDEKernel::EKernelType ktype = kGauss); fIter == 1 ---> nonadaptive KDE; fIter == 2 ---> adaptive KDE. Float_t GetBinKernelIntegral(Float_t lowr, Float_t highr, Float_t mean, Int_t binnum); calculates the integral of the Kernel. KDEKernel(TMVA::KDEKernel::EKernelI",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__KDEKernel.html:2103,adapt,adaptive,2103,root/html602/TMVA__KDEKernel.html,https://root.cern,https://root.cern/root/html602/TMVA__KDEKernel.html,2,['adapt'],['adaptive']
Energy Efficiency,"=2; , kStandard =3; , kVerbose =4; , ;   kTreeStructure =5. };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TGraph; virtual Double_t ** Allocate (Int_t newsize);  Allocate internal data structures for newsize points. ;  ; Double_t ** AllocateArrays (Int_t Narrays, Int_t arraySize);  Allocate arrays. ;  ; virtual void CopyAndRelease (Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin);  Copy points from fX and fY to arrays[0] and arrays[1] or to fX and fY if arrays == 0 and ibegin != iend. ;  ; virtual Bool_t CopyPoints (Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin);  Copy points from fX and fY to arrays[0] and arrays[1] or to fX and fY if arrays == 0 and ibegin != iend. ;  ; Bool_t CtorAllocate ();  In constructors set fNpoints than call this method. ;  ; virtual Bool_t DoMerge (const TGraph *g);  protected function to perform the merge operation of a graph ;  ; Double_t ** ExpandAndCopy (Int_t size, Int_t iend);  if size > fMaxSize allocate new arrays of 2*size points and copy iend first points. ;  ; virtual void FillZero (Int_t begin, Int_t end, Bool_t from_ctor=kTRUE);  Set zero values for point arrays in the range [begin, end) Should be redefined in descendant classes. ;  ; TString SaveArray (std::ostream &out, const char *suffix, Int_t frameNumber, Double_t *arr);  Save array as C++ code Returns name of created array. ;  ; void SaveHistogramAndFunctions (std::ostream &out, const char *varname, Int_t &frameNumber, Option_t *option);  Save histogram and list of functions of TGraph as C++ statement Used in all TGraph-derived classes. ;  ; Double_t ** ShrinkAndCopy (Int_t size, Int_t iend);  if size*2 <= fMaxSize allocate new arrays of size points, copy points [0,oend). ;  ; virtual void SwapPoints (Int_t pos1, Int_t pos2);  Swap points. ;  ; virtual void UpdateArrays (const std::vector< Int_t > &sorting_indices, Int_t numSortedPoints, Int_t low);  Upda",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooEllipse.html:31759,allocate,allocate,31759,doc/master/classRooEllipse.html,https://root.cern,https://root.cern/doc/master/classRooEllipse.html,1,['allocate'],['allocate']
Energy Efficiency,"=; 188 /// proxied object), `Commit()` should be called on the value returned by this function.; 189 virtual void* Allocate(UInt_t n, Bool_t forceDelete) = 0;; 190 ; 191 /// Commits pending elements in a staging area (see Allocate() for more information).; 192 virtual void Commit(void*) = 0;; 193 ; 194 /// Insert elements into the proxied container. `data` is a C-style array of the value type of the given `size`.; 195 /// For associative containers, e.g. `std::map`, the data type should be `std::pair<Key_t, Value_t>`.; 196 virtual void Insert(const void *data, void *container, size_t size) = 0;; 197 ; 198 /// Return the address of the value at index `idx`; 199 char *operator[](UInt_t idx) const { return (char *)(const_cast<TVirtualCollectionProxy *>(this))->At(idx); }; 200 ; 201 // Functions related to member-wise actions; 202 virtual TStreamerInfoActions::TActionSequence *GetConversionReadMemberWiseActions(TClass *oldClass, Int_t version) = 0;; 203 virtual TStreamerInfoActions::TActionSequence *GetReadMemberWiseActions(Int_t version) = 0;; 204 virtual TStreamerInfoActions::TActionSequence *GetWriteMemberWiseActions() = 0;; 205 ; 206 /// The size of a small buffer that can be allocated on the stack to store iterator-specific information; 207 static const Int_t fgIteratorArenaSize = 16; // greater than sizeof(void*) + sizeof(UInt_t); 208 ; 209 /// `*begin_arena` and `*end_arena` should contain the location of a memory arena of size `fgIteratorArenaSize`.; 210 /// If iterator-specific information is of that size or less, the iterators will be constructed in place in the given; 211 /// locations. Otherwise, iterators will be allocated via `new` and their address returned by modifying the value; 212 /// of `*begin_arena` and `*end_arena`.; 213 /// As a special case, given that iterators for array-backed containers are just pointers, the required information; 214 /// will be directly stored in `*(begin|end)_arena`.; 215 typedef void (*CreateIterators_t)(void *collection,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TVirtualCollectionProxy_8h_source.html:9749,allocate,allocated,9749,doc/master/TVirtualCollectionProxy_8h_source.html,https://root.cern,https://root.cern/doc/master/TVirtualCollectionProxy_8h_source.html,1,['allocate'],['allocated']
Energy Efficiency,"===============================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================> | [Elapsed time: 0:10m processing file: 1 / 1 processed evts: 59996000 / 61540413 7.50e+06 evt/s 0:00m remaining time (per file being processed)] ; ; ; [Total elapsed time: 0:11m processed files: 1 / 1 processed evts: 61540413 / 61540413] ; Events with exactly two muons: pass=31104343 all=61540413 -- eff=50.54 % cumulative eff=50.54 %; Muons with opposite charge: pass=24067843 all=31104343 -- eff=77.38 % cumulative eff=39.11 %; DateAugust 2018 ; AuthorStefan Wunsch (KIT, CERN) ; Definition in file df102_NanoAODDimuonAnalysis.C. tutorialsdataframedf102_NanoAODDimuonAnalysis.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/df102__NanoAODDimuonAnalysis_8C.html:66681,charge,charge,66681,doc/master/df102__NanoAODDimuonAnalysis_8C.html,https://root.cern,https://root.cern/doc/master/df102__NanoAODDimuonAnalysis_8C.html,1,['charge'],['charge']
Energy Efficiency,"=i1+1;; 1318 l=l+i1;; 1319 }; 1320 if (ifix != -1) {; 1321 // so the worst parameter is found - fix it and exclude,; 1322 // reduce fZ-matrix again; 1323 fPL[ifix] = -1.;; 1324 fixFLG = fixFLG + 1;; 1325 fi = 0;; 1326 //.. REPEAT CALCULATION OF THEORETICAL STEP AFTER fiXING EACH PARAMETER; 1327 goto L19;; 1328 }; 1329 ; 1330 //... CALCULATE STEP CORRECTION FACTOR; 1331 ; 1332 alambd = 1.;; 1333 fAKAPPA = 0.;; 1334 Int_t imax;; 1335 imax = -1;; 1336 ; 1337 ; 1338 for( i = 0; i < n; i++) {; 1339 if (fPL[i] > .0) {; 1340 bm = fAMX[i] - fA[i];; 1341 abi = fA[i] + fPL[i]; // upper parameter limit; 1342 abm = fAMX[i];; 1343 if (fDA[i] <= .0) {; 1344 bm = fA[i] - fAMN[i];; 1345 abi = fA[i] - fPL[i]; // lower parameter limit; 1346 abm = fAMN[i];; 1347 }; 1348 bi = fPL[i];; 1349 // if parallelepiped boundary is crossing limits; 1350 // then reduce it (deforming); 1351 if ( bi > bm) {; 1352 bi = bm;; 1353 abi = abm;; 1354 }; 1355 // if calculated step is out of bounds; 1356 if ( TMath::Abs(fDA[i]) > bi) {; 1357 // decrease step splitter alambdA if needed; 1358 al = TMath::Abs(bi/fDA[i]);; 1359 if (alambd > al) {; 1360 imax=i;; 1361 aiMAX=abi;; 1362 alambd=al;; 1363 }; 1364 }; 1365 // fAKAPPA - parameter will be <fEPS if fit is converged; 1366 akap = TMath::Abs(fDA[i]/fParamError[i]);; 1367 if (akap > fAKAPPA) fAKAPPA=akap;; 1368 }; 1369 }; 1370 //... CALCULATE NEW CORRECTED STEP; 1371 fGT = 0.;; 1372 amb = 1.e18;; 1373 // alambd - multiplier to split theoretical step dA; 1374 if (alambd > .0) amb = 0.25/alambd;; 1375 for( i = 0; i < n; i++) {; 1376 if (fPL[i] > .0) {; 1377 if (nn2 > fNlimMul ) {; 1378 if (TMath::Abs(fDA[i]/fPL[i]) > amb ) {; 1379 fPL[i] = 4.*fPL[i]; // increase parallelepiped; 1380 t1=4.; // flag - that fPL was increased; 1381 }; 1382 }; 1383 // cut step; 1384 fDA[i] = fDA[i]*alambd;; 1385 // expected function value change in next iteration; 1386 fGT = fGT + fDA[i]*fGr[i];; 1387 }; 1388 }; 1389 ; 1390 //.. CHECK IF MINIMUM ATTAINED AND SET EXIT MODE; 1391 // i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFumili_8cxx_source.html:38289,reduce,reduce,38289,doc/master/TFumili_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html,1,['reduce'],['reduce']
Energy Efficiency,"={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={}) const;  ; virtual RooPlot * plotOn (RooPlot *frame, const RooLinkedList &cmdList) const;  Plot dataset on specified frame. ;  ; void Print (Option_t *options=nullptr) const override;  This method must be overridden when a class wants to print itself. ;  ; void printClassName (std::ostream &os) const override;  Print class name of dataset. ;  ; void printMultiline (std::ostream &os, Int_t contents, bool verbose=false, TString indent="""") const override;  Interface for detailed printing of object. ;  ; void printName (std::ostream &os) const override;  Print name of dataset. ;  ; void printTitle (std::ostream &os) const override;  Print title of dataset. ;  ; void RecursiveRemove (TObject *obj) override;  If one of the TObject we have a referenced to is deleted, remove the reference. ;  ; RooFit::OwningPtr< RooAbsData > reduce (const char *cut) const;  Create a subset of the data set by applying the given cut on the data points. ;  ; RooFit::OwningPtr< RooAbsData > reduce (const RooArgSet &varSubset, const char *cut=nullptr) const;  Create a subset of the data set by applying the given cut on the data points and reducing the dimensions to the specified set. ;  ; RooFit::OwningPtr< RooAbsData > reduce (const RooArgSet &varSubset, const RooFormulaVar &cutVar) const;  Create a subset of the data set by applying the given cut on the data points and reducing the dimensions to the specified set. ;  ; RooFit::OwningPtr< RooAbsData > reduce (const RooCmdArg &arg1, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={}) const;  Create a reduced copy of this dataset. ;  ; RooFit::OwningPtr< RooAbsData > reduce (const RooFormulaVar &cutVar) const;  Create a subset of the data set by applying the given cut on the data points",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooTreeData.html:7504,reduce,reduce,7504,doc/master/classRooTreeData.html,https://root.cern,https://root.cern/doc/master/classRooTreeData.html,2,['reduce'],['reduce']
Energy Efficiency,"> hmap, Double_t initWgt, Bool_t doDensityCorrection); Import data from given set of TH1/2/3 into this RooDataHist. The category indexCat labels the sources; in the constructed RooDataHist. The stl map provides the mapping between the indexCat state labels; and the import source. void importDHistSet(const RooArgList& vars, RooCategory& indexCat, map<string,RooDataHist*> dmap, Double_t initWgt); Import data from given set of TH1/2/3 into this RooDataHist. The category indexCat labels the sources; in the constructed RooDataHist. The stl map provides the mapping between the indexCat state labels; and the import source. void adjustBinning(const RooArgList& vars, TH1& href, Int_t* offset = 0); Adjust binning specification on first and optionally second and third; observable to binning in given reference TH1. Used by constructors; that import data from an external TH1. void initialize(const char* binningName = 0, Bool_t fillTree = kTRUE); Initialization procedure: allocate weights array, calculate; multipliers needed for N-space to 1-dim array jump table,; and fill the internal tree with all bin center coordinates. void checkBinBounds() const. RooDataHist(const RooDataHist& other, const char* newname = 0); Copy constructor. RooDataHist(const char* name, const char* title, RooDataHist* h, const RooArgSet& varSubset, const RooFormulaVar* cutVar, const char* cutRange, Int_t nStart, Int_t nStop, Bool_t copyCache); Constructor of a data hist from (part of) an existing data hist. The dimensions; of the data set are defined by the 'vars' RooArgSet, which can be identical; to 'dset' dimensions, or a subset thereof. Reduced dimensions will be projected; in the output data hist. The optional 'cutVar' formula variable can used to; select the subset of bins to be copied. For most uses the RooAbsData::reduce() wrapper function, which uses this constructor,; is the most convenient way to create a subset of an existing data. RooAbsData* cacheClone(const RooAbsArg* newCacheOwner, const Ro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooDataHist.html:28065,allocate,allocate,28065,root/html602/RooDataHist.html,https://root.cern,https://root.cern/root/html602/RooDataHist.html,2,['allocate'],['allocate']
Energy Efficiency,">(). template<> . const RAttrMap::Value_t * ROOT::Experimental::RAttrMap::Value_t::GetValue< const RAttrMap::Value_t *, RColor > ; (; const Value_t * ; rec). ◆ RAttrMap::Value_t::GetValue< const RAttrMap::Value_t *, RPadLength >(). template<> . const RAttrMap::Value_t * ROOT::Experimental::RAttrMap::Value_t::GetValue< const RAttrMap::Value_t *, RPadLength > ; (; const Value_t * ; rec). ◆ RAttrMap::Value_t::GetValue< const RAttrMap::Value_t *, void >(). template<> . const RAttrMap::Value_t * ROOT::Experimental::RAttrMap::Value_t::GetValue< const RAttrMap::Value_t *, void > ; (; const Value_t * ; rec). ◆ REveLog(). REX::RLogChannel & ROOT::Experimental::REveLog ; (; ). Log channel for Eve diagnostics. ; Definition at line 51 of file REveTypes.cxx. ◆ swap(). template<int DIMENSIONS, class PRECISION , template< int D_, class P_ > class... STAT> . void ROOT::Experimental::swap ; (; RHist< DIMENSIONS, PRECISION, STAT... > & ; a, . RHist< DIMENSIONS, PRECISION, STAT... > & ; b . ). noexcept . Swap two histograms. ; Very efficient; swaps the fImpl pointers. ; Definition at line 210 of file RHist.hxx. Variable Documentation. ◆ gEve. REveManager * ROOT::Experimental::gEve = nullptr. Definition at line 286 of file REveManager.hxx. ◆ kInvalidColumnId. constexpr ColumnId_t ROOT::Experimental::kInvalidColumnId = -1. constexpr . Definition at line 104 of file RNTupleUtil.hxx. ◆ kInvalidDescriptorId. constexpr DescriptorId_t ROOT::Experimental::kInvalidDescriptorId = std::uint64_t(-1). constexpr . Definition at line 108 of file RNTupleUtil.hxx. ◆ kInvalidNTupleIndex. constexpr NTupleSize_t ROOT::Experimental::kInvalidNTupleIndex = std::uint64_t(-1). constexpr . Definition at line 49 of file RNTupleUtil.hxx. ◆ kUnknownCompressionSettings. constexpr int ROOT::Experimental::kUnknownCompressionSettings = -1. constexpr . Definition at line 66 of file RNTupleUtil.hxx. ROOTExperimental. ROOT v6-32 - Reference Guide Generated on Fri Nov 1 2024 15:13:39 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/namespaceROOT_1_1Experimental.html:56301,efficient,efficient,56301,doc/v632/namespaceROOT_1_1Experimental.html,https://root.cern,https://root.cern/doc/v632/namespaceROOT_1_1Experimental.html,1,['efficient'],['efficient']
Energy Efficiency,">::Scalar xx, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<Double32_t> >::Scalar yy, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<Double32_t> >::Scalar zz, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<Double32_t> >::Scalar ee). bool operator==(const ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<Double32_t> >& rhs) const; ------------------- Equality -----------------. Exact equality. bool operator!=(const ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<Double32_t> >& rhs) const. Scalar Px() const; ------ Individual element access, in various coordinate systems ------; individual coordinate accessors in various coordinate systems. spatial X component. { return fCoordinates.Px(); }. Scalar X() const. spatial Y component. { return fCoordinates.Px(); }. Scalar Py() const; { return fCoordinates.Py(); }. Scalar Y() const. spatial Z component. { return fCoordinates.Py(); }. Scalar Pz() const; { return fCoordinates.Pz(); }. Scalar Z() const. return 4-th component (time, or energy for a 4-momentum vector). { return fCoordinates.Pz(); }. Scalar E() const; { return fCoordinates.E(); }. Scalar T() const. return magnitude (mass) squared M2 = T**2 - X**2 - Y**2 - Z**2; (we use -,-,-,+ metric). { return fCoordinates.E(); }. Scalar M2() const. return magnitude (mass) using the (-,-,-,+) metric.; If M2 is negative (space-like vector) a GenVector_exception; is suggested and if continuing, - sqrt( -M2) is returned. { return fCoordinates.M2(); }. Scalar M() const. return the spatial (3D) magnitude ( sqrt(X**2 + Y**2 + Z**2) ). { return fCoordinates.M();}. Scalar R() const; { return fCoordinates.R(); }. Scalar P() const. return the square of the spatial (3D) magnitude ( X**2 + Y**2 + Z**2 ). { return fCoordinates.R(); }. Scalar P2() const. return the square of the transverse spatial component ( X**2 + Y**2 ). { return P() * P(); }. Scalar Perp2() const; { return fCoordinates.Perp2();}. Scalar Pt() const. return the transverse spatial component sqrt ( X**2 + Y**2 ). {",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__LorentzVector_-p1PtEtaPhiE4D_Double32_t___.html:13510,energy,energy,13510,root/html526/ROOT__Math__LorentzVector_-p1PtEtaPhiE4D_Double32_t___.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__LorentzVector_-p1PtEtaPhiE4D_Double32_t___.html,5,['energy'],['energy']
Energy Efficiency,">::Scalar xx, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<Double32_t> >::Scalar yy, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<Double32_t> >::Scalar zz, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<Double32_t> >::Scalar ee). bool operator==(const ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<Double32_t> >& rhs) const; ------------------- Equality -----------------. Exact equality. bool operator!=(const ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<Double32_t> >& rhs) const. Scalar Px() const; ------ Individual element access, in various coordinate systems ------; individual coordinate accessors in various coordinate systems. spatial X component. { return fCoordinates.Px(); }. Scalar X() const. spatial Y component. { return fCoordinates.Px(); }. Scalar Py() const; { return fCoordinates.Py(); }. Scalar Y() const. spatial Z component. { return fCoordinates.Py(); }. Scalar Pz() const; { return fCoordinates.Pz(); }. Scalar Z() const. return 4-th component (time, or energy for a 4-momentum vector). { return fCoordinates.Pz(); }. Scalar E() const; { return fCoordinates.E(); }. Scalar T() const. return magnitude (mass) squared M2 = T**2 - X**2 - Y**2 - Z**2; (we use -,-,-,+ metric). { return fCoordinates.E(); }. Scalar M2() const. return magnitude (mass) using the (-,-,-,+) metric.; If M2 is negative (space-like vector) a GenVector_exception; is suggested and if continuing, - sqrt( -M2) is returned. { return fCoordinates.M2(); }. Scalar M() const. return the spatial (3D) magnitude ( sqrt(X**2 + Y**2 + Z**2) ). { return fCoordinates.M();}. Scalar R() const; { return fCoordinates.R(); }. Scalar P() const. return the square of the spatial (3D) magnitude ( X**2 + Y**2 + Z**2 ). { return fCoordinates.R(); }. Scalar P2() const. return the square of the transverse spatial component ( X**2 + Y**2 ). { return P() * P(); }. Scalar Perp2() const; { return fCoordinates.Perp2();}. Scalar Pt() const. return the transverse spatial component sqrt ( X**2 + Y**2 ). {",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__LorentzVector_-p1PtEtaPhiM4D_Double32_t___.html:13510,energy,energy,13510,root/html526/ROOT__Math__LorentzVector_-p1PtEtaPhiM4D_Double32_t___.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__LorentzVector_-p1PtEtaPhiM4D_Double32_t___.html,5,['energy'],['energy']
Energy Efficiency,">Clone(0);; 4909/// for (Int_t i = 0; i < 10; ++i) {; 4910/// t1->GetEntry(i);; 4911/// t2->Fill();; 4912/// }; 4913/// t2->Write(); 4914/// delete f2;; 4915/// f2 = 0;; 4916/// delete f1;; 4917/// f1 = 0;; 4918/// ~~~; 4919/// An example of a branch with an object allocated by us,; 4920/// but owned by the caller:; 4921/// ~~~ {.cpp}; 4922/// TFile* f = new TFile(""myfile.root"", ""recreate"");; 4923/// TTree* t = new TTree(""t"", ""A test tree.""); 4924/// Event* event = 0;; 4925/// TBranchElement* br = t->Branch(""event."", &event);; 4926/// for (Int_t i = 0; i < 10; ++i) {; 4927/// ... Fill event with meaningful data in some way.; 4928/// t->Fill();; 4929/// }; 4930/// t->Write();; 4931/// delete event;; 4932/// event = 0;; 4933/// delete f;; 4934/// f = 0;; 4935/// ~~~; 4936/// Notice that the only difference between this example; 4937/// and the following example is that the event pointer; 4938/// is zero when the branch is created.; 4939///; 4940/// An example of a branch with an object allocated and; 4941/// owned by the caller:; 4942/// ~~~ {.cpp}; 4943/// TFile* f = new TFile(""myfile.root"", ""recreate"");; 4944/// TTree* t = new TTree(""t"", ""A test tree.""); 4945/// Event* event = new Event();; 4946/// TBranchElement* br = t->Branch(""event."", &event);; 4947/// for (Int_t i = 0; i < 10; ++i) {; 4948/// ... Fill event with meaningful data in some way.; 4949/// t->Fill();; 4950/// }; 4951/// t->Write();; 4952/// delete event;; 4953/// event = 0;; 4954/// delete f;; 4955/// f = 0;; 4956/// ~~~; 4957/// If AutoDelete is on (see TBranch::SetAutoDelete),; 4958/// the top level objet will be deleted and recreate; 4959/// each time an entry is read, whether or not the; 4960/// TTree owns the object.; 4961 ; 4962void TBranchElement::SetAddress(void* addr); 4963{; 4964 SetAddressImpl(addr, (addr == nullptr));; 4965}; 4966 ; 4967/// See TBranchElement::SetAddress.; 4968/// If implied is true, we do not over-ride existing address for; 4969/// sub-branches.; 4970void TBranchElement::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBranchElement_8cxx_source.html:182547,allocate,allocated,182547,doc/master/TBranchElement_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html,1,['allocate'],['allocated']
Energy Efficiency,">Ntracks; i++) { // O(10000) tracks; new(a[i]) TTrack(x,y,z,...);. }. a.Delete();; }. Note: the only supported way to add objects to a TClonesArray is; via the new with placement method. The diffrent Add() methods of; TObjArray and its base classes are not allowed. Considering that a new/delete costs about 70 mus on a 300 MHz HP,; O(10^9) new/deletes will save about 19 hours. NOTE 1. C/C++ offer the possibility to allocate and delete memory.; Forgetting to delete allocated memory is a programming error that originate ""leaks"",; i.e. the memory of your process grows and eventually your program crashes.; Even if you *always* delete the allocated memory, the recovered space may not be; efficiently reused. The process knows that there are portions of free memory,; but when you allocate it again, a fresh piece of memory is grabbed.; Your program is free from semantic errors, but the total memory of your process; still grows. Moreover your program's memory is full of ""holes"" which reduce the; efficiency of memory access, this is called ""memory fragmentation"".; Moreover new / delete are expensive operations in terms of CPU time. Without entering into technical details, the TClonesArray allow to ""reuse"" the; same portion of memory for new/delete avoiding memory fragmentation and memory; growth and improving by orders of magnitude the performance. Every time the; memory of the TClonesArray has to be reused, the Clear() method is employed.; To provide its benefits, each TClonesArray must be allocated *once* per process; and disposed of (deleted) *only when not needed any more*.; So a job should see *only one* deletion for each TClonesArray, which should be; ""Cleared()"" in between several times. Keep deleting a TClonesArray is a double; waste. Not only you do not avoid memory fragmentation, but you worsen it because; the TClonesArray itself is a rather heavy structure, and there is quite some; code in the destructor, so you have more memory fragmentation and slower code. NOTE 2",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TClonesArray.html:2064,reduce,reduce,2064,root/html528/TClonesArray.html,https://root.cern,https://root.cern/root/html528/TClonesArray.html,2,['reduce'],['reduce']
Energy Efficiency,">feedback=name1,name2,name3,...;<next_option>; The special name 'stats' triggers feedback about events and packets. The separator from the next option is either a ' ' or a ';'. Called interanally by TProof::Process. ; Definition at line 5232 of file TProof.cxx. ◆ SetInputDataFile(). void TProof::SetInputDataFile ; (; const char * ; datafile). Set the file to be used to optimally distribute the input data objects. ; If the file exists the object in the file are added to those in the fInputData list. If the file path is null, a default file will be created at the moment of sending the processing request with the content of the fInputData list. See also SendInputDataFile. ; Definition at line 9585 of file TProof.cxx. ◆ SetLogLevel(). void TProof::SetLogLevel ; (; Int_t ; level, . UInt_t ; mask = TProofDebug::kAll . ). Set server logging level. ; Definition at line 7079 of file TProof.cxx. ◆ SetManager(). void TProof::SetManager ; (; TProofMgr * ; mgr). Set manager and schedule its destruction after this for clean operations. ; Definition at line 1301 of file TProof.cxx. ◆ SetMaxDrawQueries(). void TProof::SetMaxDrawQueries ; (; Int_t ; max). Set max number of draw queries whose results are saved. ; Definition at line 2115 of file TProof.cxx. ◆ SetMonitor(). void TProof::SetMonitor ; (; TMonitor * ; mon = 0, . Bool_t ; on = kTRUE . ). private . Activate (on == TRUE) or deactivate (on == FALSE) all sockets monitored by 'mon'. ; Definition at line 2408 of file TProof.cxx. ◆ SetParallel(). Int_t TProof::SetParallel ; (; Int_t ; nodes = -1, . Bool_t ; random = kFALSE . ). Tell PROOF how many slaves to use in parallel. ; Returns the number of parallel slaves. Returns -1 in case of error. ; Definition at line 7140 of file TProof.cxx. ◆ SetParallelSilent(). Int_t TProof::SetParallelSilent ; (; Int_t ; nodes, . Bool_t ; random = kFALSE . ). private . Tell PROOF how many slaves to use in parallel. ; If random is TRUE a random selection is done (if nodes is less than the availabl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProof.html:144028,schedul,schedule,144028,doc/master/classTProof.html,https://root.cern,https://root.cern/doc/master/classTProof.html,1,['schedul'],['schedule']
Energy Efficiency,"? ; check for convergence; Definition at line 485 of file NeuralNet.cxx. ◆ learningRate(). double TMVA::DNN::Settings::learningRate ; (; ); const. inline . get the learning rate ; Definition at line 771 of file NeuralNet.h. ◆ maxConvergenceCount(). size_t TMVA::DNN::Settings::maxConvergenceCount ; (; ); const. inline . returns the max convergence count so far ; Definition at line 828 of file NeuralNet.h. ◆ minError(). size_t TMVA::DNN::Settings::minError ; (; ); const. inline . returns the smallest error so far ; Definition at line 829 of file NeuralNet.h. ◆ minimizerType(). MinimizerType TMVA::DNN::Settings::minimizerType ; (; ); const. inline . which minimizer shall be used (e.g. SGD) ; Definition at line 774 of file NeuralNet.h. ◆ momentum(). double TMVA::DNN::Settings::momentum ; (; ); const. inline . get the momentum (e.g. for SGD) ; Definition at line 772 of file NeuralNet.h. ◆ pads(). void TMVA::DNN::Settings::pads ; (; int ; numPads). inline . preparation for monitoring ; Definition at line 818 of file NeuralNet.h. ◆ plot(). void TMVA::DNN::Settings::plot ; (; std::string ; histoName, . std::string ; options, . int ; pad, . EColor ; color . ). inline . for monitoring ; Definition at line 823 of file NeuralNet.h. ◆ regularization(). EnumRegularization TMVA::DNN::Settings::regularization ; (; ); const. inline . some regularization of the DNN is turned on? ; Definition at line 813 of file NeuralNet.h. ◆ repetitions(). int TMVA::DNN::Settings::repetitions ; (; ); const. inline . how many steps have to be gone until the batch is changed ; Definition at line 773 of file NeuralNet.h. ◆ setDropOut(). template<typename Iterator > . void TMVA::DNN::Settings::setDropOut ; (; Iterator ; begin, . Iterator ; end, . size_t ; _dropRepetitions . ). inline . set the drop-out configuration (layer-wise) ; Parameters. beginbegin of an array or vector denoting the drop-out probabilities for each layer ; endend of an array or vector denoting the drop-out probabilities for each laye",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1Settings.html:9907,monitor,monitoring,9907,doc/master/classTMVA_1_1DNN_1_1Settings.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1Settings.html,1,['monitor'],['monitoring']
Energy Efficiency,"??BUG???; 5278 // Allow TObject's to be registered again.; 5279 if(statsave) {; 5280 SetObjectStat(statsave);; 5281 }; 5282 ; 5283 } else {; 5284 Error(""NewArray"", ""This cannot happen!"");; 5285 }; 5286 ; 5287 return p;; 5288}; 5289 ; 5290////////////////////////////////////////////////////////////////////////////////; 5291/// Return a pointer to a newly allocated object of this class.; 5292/// The class must have a default constructor. For meaning of; 5293/// defConstructor, see TClass::IsCallingNew().; 5294 ; 5295void *TClass::NewArray(Long_t nElements, void *arena, ENewType defConstructor) const; 5296{; 5297 auto obj = NewObjectArray(nElements, arena, defConstructor);; 5298 if (obj.GetPtr() && obj.GetAllocator()) {; 5299 // Register the object for special handling in the destructor.; 5300 RegisterAddressInRepository(""TClass::NewArray with placement"", obj.GetPtr(), this);; 5301 }; 5302 return obj.GetPtr();; 5303}; 5304 ; 5305////////////////////////////////////////////////////////////////////////////////; 5306/// Return a pointer to a newly allocated object of this class.; 5307/// The class must have a default constructor. For meaning of; 5308/// defConstructor, see TClass::IsCallingNew().; 5309 ; 5310TClass::ObjectPtr TClass::NewObjectArray(Long_t nElements, void *arena, ENewType defConstructor) const; 5311{; 5312 ObjectPtr p;; 5313 ; 5314 if (fNewArray) {; 5315 // We have the new operator wrapper function,; 5316 // so there is a dictionary and it was generated; 5317 // by rootcint, so there should be a default; 5318 // constructor we can call through the wrapper.; 5319 {; 5320 TClass__GetCallingNewRAII callingNew(defConstructor);; 5321 p = fNewArray(nElements, arena);; 5322 }; 5323 if (!p) {; 5324 Error(""NewArray with placement"", ""cannot create object of class %s version %d at address %p"", GetName(), fClassVersion, arena);; 5325 }; 5326 } else if (HasInterpreterInfo()) {; 5327 // We have the dictionary but do not have the constructor wrapper,; 5328 // so the dict",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:202567,allocate,allocated,202567,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['allocate'],['allocated']
Energy Efficiency,"??BUG???; 5345 // Allow TObject's to be registered again.; 5346 if(statsave) {; 5347 SetObjectStat(statsave);; 5348 }; 5349 ; 5350 } else {; 5351 Error(""NewArray"", ""This cannot happen!"");; 5352 }; 5353 ; 5354 return p;; 5355}; 5356 ; 5357////////////////////////////////////////////////////////////////////////////////; 5358/// Return a pointer to a newly allocated object of this class.; 5359/// The class must have a default constructor. For meaning of; 5360/// defConstructor, see TClass::IsCallingNew().; 5361 ; 5362void *TClass::NewArray(Long_t nElements, void *arena, ENewType defConstructor) const; 5363{; 5364 auto obj = NewObjectArray(nElements, arena, defConstructor);; 5365 if (obj.GetPtr() && obj.GetAllocator()) {; 5366 // Register the object for special handling in the destructor.; 5367 RegisterAddressInRepository(""TClass::NewArray with placement"", obj.GetPtr(), this);; 5368 }; 5369 return obj.GetPtr();; 5370}; 5371 ; 5372////////////////////////////////////////////////////////////////////////////////; 5373/// Return a pointer to a newly allocated object of this class.; 5374/// The class must have a default constructor. For meaning of; 5375/// defConstructor, see TClass::IsCallingNew().; 5376 ; 5377TClass::ObjectPtr TClass::NewObjectArray(Long_t nElements, void *arena, ENewType defConstructor) const; 5378{; 5379 ObjectPtr p;; 5380 ; 5381 if (fNewArray) {; 5382 // We have the new operator wrapper function,; 5383 // so there is a dictionary and it was generated; 5384 // by rootcint, so there should be a default; 5385 // constructor we can call through the wrapper.; 5386 {; 5387 TClass__GetCallingNewRAII callingNew(defConstructor);; 5388 p = fNewArray(nElements, arena);; 5389 }; 5390 if (!p) {; 5391 Error(""NewArray with placement"", ""cannot create object of class %s version %d at address %p"", GetName(), fClassVersion, arena);; 5392 }; 5393 } else if (HasInterpreterInfo()) {; 5394 // We have the dictionary but do not have the constructor wrapper,; 5395 // so the dict",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:205318,allocate,allocated,205318,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['allocate'],['allocated']
Energy Efficiency,"A::DNN::Settings::maxConvergenceCountsize_t maxConvergenceCount() constreturns the max convergence count so farDefinition NeuralNet.h:828; TMVA::DNN::Settings::padsvoid pads(int numPads)preparation for monitoringDefinition NeuralNet.h:818; TMVA::DNN::Settings::m_testRepetitionssize_t m_testRepetitionsDefinition NeuralNet.h:839; TMVA::DNN::Settings::fLearningRatedouble fLearningRateDefinition NeuralNet.h:852; TMVA::DNN::Settings::fMomentumdouble fMomentumDefinition NeuralNet.h:853; TMVA::DNN::Settings::batchSizesize_t batchSize() constmini-batch sizeDefinition NeuralNet.h:767; TMVA::DNN::Settings::computeResultvirtual void computeResult(const Net &, std::vector< double > &)callback for monitoring and loggingDefinition NeuralNet.h:809; TMVA::DNN::Settings::fMonitoringstd::shared_ptr< Monitoring > fMonitoringDefinition NeuralNet.h:865; TMVA::DNN::Settings::dropRepetitionssize_t dropRepetitions() constDefinition NeuralNet.h:761; TMVA::DNN::Settings::createvoid create(std::string histoName, int bins, double min, double max)for monitoringDefinition NeuralNet.h:819; TMVA::DNN::Settings::fRepetitionsint fRepetitionsDefinition NeuralNet.h:854; TMVA::DNN::Settings::minErrorsize_t minError() constreturns the smallest error so farDefinition NeuralNet.h:829; TMVA::DNN::Settings::startTrainingvirtual void startTraining()Definition NeuralNet.h:795; TMVA::DNN::Settings::m_maxConvergenceCountsize_t m_maxConvergenceCountDefinition NeuralNet.h:858; TMVA::DNN::Settings::startTestCyclevirtual void startTestCycle()callback for monitoring and logggingDefinition NeuralNet.h:804; TMVA::DNN::SteepestSteepest Gradient Descent algorithm (SGD)Definition NeuralNet.h:334; TMVA::DNN::Steepest::m_repetitionssize_t m_repetitionsDefinition NeuralNet.h:337; TMVA::DNN::Steepest::m_betadouble m_betainternal parameter (momentum)Definition NeuralNet.h:372; TMVA::DNN::Steepest::m_localGradientsstd::vector< double > m_localGradientslocal gradients for reuse in thread.Definition NeuralNet.h:376; TMVA::DNN::St",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/NeuralNet_8h_source.html:77659,monitor,monitoringDefinition,77659,doc/master/NeuralNet_8h_source.html,https://root.cern,https://root.cern/doc/master/NeuralNet_8h_source.html,1,['monitor'],['monitoringDefinition']
Energy Efficiency,"AN for one-dimensional discrete distribution ;  CEvent_t;  CExceptionContext_t;  CFeldmanCousinsBinomialInterval;  CFeldmanCousinsSorter;  CFileStat_t;  CFontAttributes_t;  CFontMetrics_t;  CFoption_t;  Cfuncptr_and_voidptr_t;  CGcCache_t;  CGCValues_t;  CGraphCreatorHelperHelper class that provides the operation graph nodes ;  CGraphNodeClass used to create the operation graph to be printed in the dot representation ;  Cgroup;  Ch1analysis;  Ch1analysisTreeReader;  Chash< std::experimental::basic_string_view< _CharT, _Traits > >;  CHelperOps;  CHEPEVT_DEFHEPEVT common block ;  CHit;  CHoption_tHistogram option structure ;  CHparam_tHistogram parameters structure ;  CJet;  CJetEvent;  CMemInfo_t;  ►CMemPoolForRooSetsMemory pool for RooArgSet and RooDataSet ;  CArena;  Cmg_callbacks;  Cmg_client_cert;  Cmg_client_options;  Cmg_form_data_handler;  Cmg_header;  Cmg_option;  Cmg_request_info;  Cmg_response_info;  Cmg_server_ports;  Cmg_websocket_subprotocols;  CMultiDistFree functions adapter needed by UNURAN for multidimensional cont distribution ;  CMyPdfV1;  CMyPdfV2;  CMyPdfV3;  CMYSQL_BIND;  CMYSQL_STMT;  CNuMuToNuE_Oscillation;  ►CParamHistFuncA class which maps the current values of a RooRealVar (or a set of RooRealVars) to one of a number of RooRealVars: ;  CCacheElem;  CPassiveKeyGrab;  Cpasswd;  CPattern;  CPgSQL_Stmt_t;  CPictureAttributes_t;  ►CPiecewiseInterpolation;  CCacheElem;  CPoint_t;  CProcInfo_t;  CProofServEnv_t;  Cpthread_cond_t;  CPybins_tPythia6 common block Pybins ;  CPydat1_tPythia6 common block Pydat1 ;  CPydat2_tPythia6 common block Pydat2 ;  CPydat3_tPythia6 common block Pydat3 ;  CPydat4_tPythia6 common block Pydat4 ;  CPydatr_tPythia6 common block Pydatr ;  CPyint1_tPythia6 common block Pyint1 ;  CPyint2_tPythia6 common block Pyint2 ;  CPyint3_tPythia6 common block Pyint3 ;  CPyint4_tPythia6 common block Pyint4 ;  CPyint5_tPythia6 common block Pyint5 ;  CPyint6_tPythia6 common block Pyint6 ;  CPyint7_tPythia6 common block Pyint7 ;  CPyint",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/annotated.html:96487,adapt,adapter,96487,doc/v616/annotated.html,https://root.cern,https://root.cern/doc/v616/annotated.html,1,['adapt'],['adapter']
Energy Efficiency,"AbsDataStore.; Definition at line 141 of file RooVectorDataStore.h. ◆ realfStoreList(). std::vector< RealFullVector * > & RooVectorDataStore::realfStoreList ; (; ). inline . Definition at line 541 of file RooVectorDataStore.h. ◆ realStoreList(). std::vector< RealVector * > & RooVectorDataStore::realStoreList ; (; ). inline . Definition at line 540 of file RooVectorDataStore.h. ◆ recalculateCache(). void RooVectorDataStore::recalculateCache ; (; const RooArgSet * ; projectedArgs, . Int_t ; firstEvent, . Int_t ; lastEvent, . Int_t ; stepSize, . bool ; skipZeroWeights . ). overridevirtual . Reimplemented from RooAbsDataStore.; Definition at line 924 of file RooVectorDataStore.cxx. ◆ recomputeSumWeight(). void RooVectorDataStore::recomputeSumWeight ; (; ). Trigger a recomputation of the cached weight sums. ; Meant for use by RooFit dataset converter functions such as the NumPy converter functions implemented as pythonizations. ; Definition at line 1338 of file RooVectorDataStore.cxx. ◆ reduce(). std::unique_ptr< RooAbsDataStore > RooVectorDataStore::reduce ; (; RooStringView ; name, . RooStringView ; title, . const RooArgSet & ; vars, . const RooFormulaVar * ; cutVar, . const char * ; cutRange, . std::size_t ; nStart, . std::size_t ; nStop . ). overridevirtual . Implements RooAbsDataStore.; Definition at line 249 of file RooVectorDataStore.cxx. ◆ reserve(). void RooVectorDataStore::reserve ; (; Int_t ; nEvt). private . Definition at line 703 of file RooVectorDataStore.cxx. ◆ reset(). void RooVectorDataStore::reset ; (; ). overridevirtual . Implements RooAbsDataStore.; Definition at line 738 of file RooVectorDataStore.cxx. ◆ resetBuffers(). void RooVectorDataStore::resetBuffers ; (; ). overridevirtual . Implements RooAbsDataStore.; Definition at line 1055 of file RooVectorDataStore.cxx. ◆ resetCache(). void RooVectorDataStore::resetCache ; (; ). overridevirtual . Implements RooAbsDataStore.; Definition at line 1015 of file RooVectorDataStore.cxx. ◆ row(). const RooArgSet",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooVectorDataStore.html:34826,reduce,reduce,34826,doc/master/classRooVectorDataStore.html,https://root.cern,https://root.cern/doc/master/classRooVectorDataStore.html,1,['reduce'],['reduce']
Energy Efficiency,"AbsReal::createScanRIRooFit::OwningPtr< RooAbsReal > createScanRI(const RooArgSet &iset, const RooArgSet &nset, Int_t numScanBins, Int_t intOrder)Utility function for createRunningIntegral that construct an object implementing the numeric scanning...Definition RooAbsReal.cxx:3810; RooAbsReal::_DEBUG_getValdouble _DEBUG_getVal(const RooArgSet *normalisationSet) constDebug version of getVal(), which is slow and does error checking.Definition RooAbsReal.cxx:4434; RooAbsReal::createFundamentalRooFit::OwningPtr< RooAbsArg > createFundamental(const char *newname=nullptr) const overrideCreate a RooRealVar fundamental object with our properties.Definition RooAbsReal.cxx:3130; RooAbsReal::plotSanityChecksbool plotSanityChecks(RooPlot *frame) constUtility function for plotOn(), perform general sanity check on frame to ensure safe plotting operatio...Definition RooAbsReal.cxx:2860; RooAbsReal::bindVarsRooFit::OwningPtr< RooAbsFunc > bindVars(const RooArgSet &vars, const RooArgSet *nset=nullptr, bool clipInvalid=false) constCreate an interface adaptor f(vars) that binds us to the specified variables (in arbitrary order).Definition RooAbsReal.cxx:2980; RooAbsReal::selectNormalizationvirtual void selectNormalization(const RooArgSet *depSet=nullptr, bool force=false)Interface function to force use of a given set of observables to interpret function value.Definition RooAbsReal.cxx:3360; RooAbsReal::derivativeRooDerivative * derivative(RooRealVar &obs, Int_t order=1, double eps=0.001)Return function representing first, second or third order derivative of this function.Definition RooAbsReal.cxx:3987; RooAbsReal::chi2FitTovirtual RooFit::OwningPtr< RooFitResult > chi2FitTo(RooDataHist &data, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={})Perform a fit to given histogram.Definition RooAbsReal.cxx:4105; RooAbsReal::asTFTF1 * asTF",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8cxx_source.html:220936,adapt,adaptor,220936,doc/master/RooAbsReal_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html,1,['adapt'],['adaptor']
Energy Efficiency,"AddAction(ReadSTL<ReadSTLMemberWiseSameClass,ReadSTLObjectWiseStreamerV2>, new TConfigSTL(this,i,compinfo,compinfo->fOffset,1,oldClass,element->GetStreamer(),element->GetTypeName(),isSTLbase));; 3305 } else {; 3306 readSequence->AddAction(ReadSTL<ReadSTLMemberWiseSameClass,ReadSTLObjectWiseFastArrayV2>, new TConfigSTL(this,i,compinfo,compinfo->fOffset,1,oldClass,element->GetTypeName(),isSTLbase));; 3307 }; 3308 }; 3309 } else {; 3310 if (newClass && newClass != oldClass) {; 3311 if (element->GetStreamer()) {; 3312 readSequence->AddAction(ReadSTL<ReadSTLMemberWiseChangedClass,ReadSTLObjectWiseStreamer>, new TConfigSTL(this,i,compinfo,compinfo->fOffset,1,oldClass,newClass,element->GetStreamer(),element->GetTypeName(),isSTLbase));; 3313 } else if (oldClass) {; 3314 if (oldClass->GetCollectionProxy() == 0 || oldClass->GetCollectionProxy()->GetValueClass() || oldClass->GetCollectionProxy()->HasPointers() ) {; 3315 readSequence->AddAction(ReadSTL<ReadSTLMemberWiseChangedClass,ReadSTLObjectWiseFastArray>, new TConfigSTL(this,i,compinfo,compinfo->fOffset,1,oldClass,newClass,element->GetTypeName(),isSTLbase));; 3316 } else {; 3317 switch (SelectLooper(*newClass->GetCollectionProxy())) {; 3318 case kVectorLooper:; 3319 readSequence->AddAction(GetConvertCollectionReadAction<VectorLooper>(oldClass->GetCollectionProxy()->GetType(), newClass->GetCollectionProxy()->GetType(), new TConfigSTL(this,i,compinfo,compinfo->fOffset,1,oldClass,newClass,element->GetTypeName(),isSTLbase)));; 3320 break;; 3321 case kAssociativeLooper:; 3322 readSequence->AddAction(GetConvertCollectionReadAction<AssociativeLooper>(oldClass->GetCollectionProxy()->GetType(), newClass->GetCollectionProxy()->GetType(), new TConfigSTL(this,i,compinfo,compinfo->fOffset,1,oldClass,newClass,element->GetTypeName(),isSTLbase)));; 3323 break;; 3324 case kVectorPtrLooper:; 3325 case kGenericLooper:; 3326 default:; 3327 // For now TBufferXML would force use to allocate the data buffer each time and copy into the real thing.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html:149141,allocate,allocate,149141,doc/master/TStreamerInfoActions_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html,1,['allocate'],['allocate']
Energy Efficiency,"AddPixmap ; (; ULong_t ; pixid, . UInt_t ; w, . UInt_t ; h . ). overridevirtual . Registers a pixmap created by TGLManager as a ROOT pixmap. ; Parameters. [in]pixidpixmap identifier ; [in]w,hthe width and height, which define the pixmap size . Reimplemented from TVirtualX.; Definition at line 2549 of file TGCocoa.mm. ◆ AddWindow(). Int_t TGCocoa::AddWindow ; (; ULong_t ; qwid, . UInt_t ; w, . UInt_t ; h . ). overridevirtual . Registers a window created by Qt as a ROOT window. ; Parameters. [in]qwidwindow identifier ; [in]w,hthe width and height, which define the window size . Reimplemented from TVirtualX.; Definition at line 846 of file TGCocoa.mm. ◆ AllocColor(). Bool_t TGCocoa::AllocColor ; (; Colormap_t ; cmap, . ColorStruct_t & ; color . ). overridevirtual . Allocates a read-only colormap entry corresponding to the closest RGB value supported by the hardware. ; If no cell could be allocated it returns kFALSE, otherwise kTRUE.; The pixel value is set to default. Let system think we could allocate color.; Parameters. [in]cmapthe colormap ; [in]colorspecifies and returns the values actually used in the cmap . Reimplemented from TVirtualX.; Definition at line 2917 of file TGCocoa.mm. ◆ Bell(). void TGCocoa::Bell ; (; Int_t ; percent). overridevirtual . Sets the sound bell. Percent is loudness from -100% to 100%. ; Reimplemented from TVirtualX.; Definition at line 4264 of file TGCocoa.mm. ◆ ChangeActivePointerGrab(). void TGCocoa::ChangeActivePointerGrab ; (; Window_t ; , . UInt_t ; , . Cursor_t ;  . ). overridevirtual . Changes the specified dynamic parameters if the pointer is actively grabbed by the client and if the specified time is no earlier than the last-pointer-grab time and no later than the current X server time. ; Reimplemented from TVirtualX.; Definition at line 2699 of file TGCocoa.mm. ◆ ChangeGC(). void TGCocoa::ChangeGC ; (; GContext_t ; gc, . GCValues_t * ; gval . ). overridevirtual . Changes the components specified by the mask in gval for the speci",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGCocoa.html:53634,allocate,allocate,53634,doc/master/classTGCocoa.html,https://root.cern,https://root.cern/doc/master/classTGCocoa.html,1,['allocate'],['allocate']
Energy Efficiency,"AnalysisType(). Bool_t TMVA::MethodBoost::HasAnalysisType ; (; Types::EAnalysisType ; type, . UInt_t ; numberClasses, . UInt_t ;  . ). virtual . Boost can handle classification with 2 classes and regression with one regression-target. ; Implements TMVA::IMethod.; Definition at line 166 of file MethodBoost.cxx. ◆ Init(). void TMVA::MethodBoost::Init ; (; void ; ). privatevirtual . Implements TMVA::MethodBase.; Definition at line 264 of file MethodBoost.cxx. ◆ InitHistos(). void TMVA::MethodBoost::InitHistos ; (; ). private . initialisation routine ; Definition at line 271 of file MethodBoost.cxx. ◆ IsA(). virtual TClass * TMVA::MethodBoost::IsA ; (; ); const. inlinevirtual . ReturnsTClass describing current object ; Reimplemented from TMVA::MethodCompositeBase.; Definition at line 202 of file MethodBoost.h. ◆ MonitorBoost(). void TMVA::MethodBoost::MonitorBoost ; (; Types::EBoostStage ; stage, . UInt_t ; methodIndex = 0 . ). private . fill various monitoring histograms from information of the individual classifiers that have been boosted. ; of course.... this depends very much on the individual classifiers, and so far, only for Decision Trees, this monitoring is actually implemented ; Definition at line 1305 of file MethodBoost.cxx. ◆ PrintResults(). void TMVA::MethodBoost::PrintResults ; (; const TString & ; , . std::vector< Double_t > & ; , . const Double_t ;  . ); const. private . ◆ ProcessOptions(). void TMVA::MethodBoost::ProcessOptions ; (; ). privatevirtual . process user options ; Implements TMVA::MethodCompositeBase.; Definition at line 663 of file MethodBoost.cxx. ◆ ResetBoostWeights(). void TMVA::MethodBoost::ResetBoostWeights ; (; ). private . resetting back the boosted weights of the events to 1 ; Definition at line 569 of file MethodBoost.cxx. ◆ SetBoostedMethodName(). void TMVA::MethodBoost::SetBoostedMethodName ; (; TString ; methodName). inline . Definition at line 86 of file MethodBoost.h. ◆ SingleBoost(). Double_t TMVA::MethodBoost::SingleBoost ; (",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodBoost.html:39103,monitor,monitoring,39103,doc/master/classTMVA_1_1MethodBoost.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodBoost.html,1,['monitor'],['monitoring']
Energy Efficiency,"AnalysisTypemethod-mode : true --> regression, false --> classification; UInt_tTMVA::MethodBase::fBackgroundClassindex of the Background-class; vector<TString>*TMVA::MethodBase::fInputVarsvector of input variables used in MVA; vector<Float_t>*TMVA::MethodBase::fMulticlassReturnValholds the return-values for the multiclass classification; Int_tTMVA::MethodBase::fNbinsnumber of bins in representative histograms; Int_tTMVA::MethodBase::fNbinsHnumber of bins in evaluation histograms; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class. private:. TMatrixD*fBetwbetween-class matrix; TMatrixD*fCovfull covariance matrix; vector<Double_t>*fDiscrimPowdiscriminating power; Double_tfF0offset; vector<Double_t>*fFisherCoeffFisher coefficients; TMVA::MethodFisher::EFisherMethodfFisherMethodFisher or Mahalanobis ; TMatrixD*fMeanMatx; Double_tfSumOfWeightsBsum-of-weights for background training events; Double_tfSumOfWeightsSsum-of-weights for signal training events; TStringfTheMethodFisher or Mahalanobis; TMatrixD*fWithwithin-class matrix. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodFisher(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& dsi, const TString& theOption = ""Fisher"", TDirectory* theTargetDir = 0); standard constructor for the ""Fisher"". MethodFisher(TMVA::DataSetInfo& dsi, const TString& theWeightFile, TDirectory* theTargetDir = NULL); constructor from weight file. void Init( void ); default initialization called by all constructors. void DeclareOptions(). MethodFisher options:; format and syntax of option string: ""type""; where type is ""Fisher"" or ""Mahalanobis"". void ProcessOptions(); process user options. ~MethodFisher( void ); destructor. Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MethodFisher.html:17953,power,power,17953,root/html528/TMVA__MethodFisher.html,https://root.cern,https://root.cern/root/html528/TMVA__MethodFisher.html,1,['power'],['power']
Energy Efficiency,"At(idx); }. TStreamerInfoActions::TActionSequence * GetConversionReadMemberWiseActions(TClass* oldClass, Int_t version); MemberWise actions. TStreamerInfoActions::TActionSequence * GetReadMemberWiseActions(Int_t version). TStreamerInfoActions::TActionSequence * GetWriteMemberWiseActions(). CreateIterators_t GetFunctionCreateIterators(Bool_t read = kTRUE); begin_arena and end_arena should contain the location of a memory arena of size fgIteratorSize.; If the collection iterator are of that size or less, the iterators will be constructed in place in those location (new with placement); Otherwise the iterators will be allocated via a regular new and their address returned by modifying the value of begin_arena and end_arena. CopyIterator_t GetFunctionCopyIterator(Bool_t read = kTRUE); Copy the iterator source, into dest. dest should contain the location of a memory arena of size fgIteratorSize.; If the collection iterator is of that size or less, the iterator will be constructed in place in this location (new with placement); Otherwise the iterator will be allocated via a regular new.; The actual address of the iterator is returned in both case. Next_t GetFunctionNext(Bool_t read = kTRUE); iter and end should be pointers to respectively an iterator to be incremented and the result of collection.end(); If the iterator has not reached the end of the collection, 'Next' increment the iterator 'iter' and return 0 if; the iterator reached the end.; If the end was not reached, 'Next' returns the address of the content pointed to by the iterator before the; incrementation ; if the collection contains pointers, 'Next' will return the value of the pointer. DeleteIterator_t GetFunctionDeleteIterator(Bool_t read = kTRUE). DeleteTwoIterators_t GetFunctionDeleteTwoIterators(Bool_t read = kTRUE); If the size of the iterator is greater than fgIteratorArenaSize, call delete on the addresses,; Otherwise just call the iterator's destructor. » Author: Philippe Canal 20/08/2003 » Copyright ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TVirtualCollectionProxy.html:5972,allocate,allocated,5972,root/html534/TVirtualCollectionProxy.html,https://root.cern,https://root.cern/root/html534/TVirtualCollectionProxy.html,3,['allocate'],['allocated']
Energy Efficiency,"Att...(); methods to change the drawing style attributes of a contained; object directly. TString getDrawOptions(const char* name) const; Return the Draw() options registered for the named object. Return; an empty string if the named object cannot be found. Bool_t setDrawOptions(const char* name, TString options); Register the specified drawing options for the named object.; Return kFALSE if the named object cannot be found. Bool_t getInvisible(const char* name) const; Returns true of object with given name is set to be invisible. void setInvisible(const char* name, Bool_t flag = kTRUE); If flag is true object with 'name' is set to be invisible; i.e. it is not drawn when Draw() is called. TString caller(const char* method) const; Utility function. void SetMaximum(Double_t maximum = -1111); Set maximum value of Y axis. void SetMinimum(Double_t minimum = -1111); Set minimum value of Y axis. Double_t chiSquare(const char* pdfname, const char* histname, int nFitParam = 0) const; Calculate and return reduced chi-squared of curve with given name with respect; to histogram with given name. If nFitParam is non-zero, it is used to reduce the; number of degrees of freedom for a chi^2 for a curve that was fitted to the; data with that number of floating parameters. RooHist* residHist(const char* histname = 0, const char* pdfname = 0, bool normalize = false) const; Return a RooHist containing the residuals of histogram 'histname' with respect; to curve 'curvename'. If normalize is true the residuals are divided by the error; on the histogram, effectively returning a pull histogram. Double_t getFitRangeNEvt(Double_t xlo, Double_t xhi) const; Return the number of events that is associated with the range [xlo,xhi]; This method is only fully functional for ranges not equal to the full; range if the object that inserted the normalization data provided; a link to an external object that can calculate the event count in; in sub ranges. An error will be printed if this function is used",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooPlot.html:21039,reduce,reduced,21039,root/html526/RooPlot.html,https://root.cern,https://root.cern/root/html526/RooPlot.html,4,['reduce'],['reduced']
Energy Efficiency,"Att...(); methods to change the drawing style attributes of a contained; object directly. TString getDrawOptions(const char* name) const; Return the Draw() options registered for the named object. Return; an empty string if the named object cannot be found. Bool_t setDrawOptions(const char* name, TString options); Register the specified drawing options for the named object.; Return kFALSE if the named object cannot be found. Bool_t getInvisible(const char* name) const; Returns true of object with given name is set to be invisible. void setInvisible(const char* name, Bool_t flag = kTRUE); If flag is true object with 'name' is set to be invisible; i.e. it is not drawn when Draw() is called. TString caller(const char* method) const; Utility function. void SetMaximum(Double_t maximum = -1111); Set maximum value of Y axis. void SetMinimum(Double_t minimum = -1111); Set minimum value of Y axis. Double_t chiSquare(const char* pdfname, const char* histname, int nFitParam = 0) const; Calculate and return reduced chi-squared of curve with given name with respect; to histogram with given name. If nFitParam is non-zero, it is used to reduce the; number of degrees of freedom for a chi^2 for a curve that was fitted to the; data with that number of floating parameters. RooHist* residHist(const char* histname = 0, const char* pdfname = 0, bool normalize = false, bool useAverage = kFALSE) const; Return a RooHist containing the residuals of histogram 'histname' with respect; to curve 'curvename'. If normalize is true the residuals are divided by the error; on the histogram, effectively returning a pull histogram. Double_t getFitRangeNEvt(Double_t xlo, Double_t xhi) const; Return the number of events that is associated with the range [xlo,xhi]; This method is only fully functional for ranges not equal to the full; range if the object that inserted the normalization data provided; a link to an external object that can calculate the event count in; in sub ranges. An error will be printe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooPlot.html:21506,reduce,reduced,21506,root/html534/RooPlot.html,https://root.cern,https://root.cern/root/html534/RooPlot.html,3,['reduce'],['reduced']
Energy Efficiency,"B"" },; 51 { ""ZB"", ""ZiB"" },; 52 { ""YB"", ""YiB"" } };; 53 value_type unit = si ? 1000 : 1024;; 54 int exp = 0;; 55 if (bytes == unit) {; 56 // On some 32bit platforms, the result of; 57 // (int) (std::log(bytes) / std::log(unit); 58 // in the case of bytes==unit ends up surprisingly to be zero; 59 // rather than one, so 'hard code' the result; 60 exp = 1;; 61 } else if (bytes > 0) {; 62 exp = std::min( (int) (std::log(bytes) / std::log(unit)),; 63 (int) (sizeof(suffix) / sizeof(suffix[0]) - 1));; 64 }; 65 *coeff = bytes / std::pow(unit, exp);; 66 *units = suffix[exp][!si];; 67}; 68 ; 69enum class EFromHumanReadableSize {; 70 kSuccess,; 71 kParseFail,; 72 kOverflow; 73};; 74 ; 75///////////////////////////////////////////////////////////////////////////////; 76/// Convert strings like the following into byte counts; 77/// 5MB, 5 MB, 5M, 3.7GB, 123b, 456kB, 3.7GiB, 5MiB; 78/// with some amount of forgiveness baked into the parsing.; 79/// For this routine we use the official SI unit where the [i] is reserved; 80/// for the 'legacy' power of two units. 1KB = 1000 bytes, 1KiB = 1024 bytes.; 81/// \param str the string to be parsed; 82/// \param value will be updated with the result if and only if the parse is successful and does not overflow for the type of value.; 83/// \return return a EFromHumanReadableSize enum value indicating the success or failure of the parse.; 84///; 85template <typename T>; 86EFromHumanReadableSize FromHumanReadableSize(std::string_view str, T &value); 87{; 88 try {; 89 size_t cur, size = str.size();; 90 // Parse leading numeric factor; 91 const double coeff = stod(std::string(str.data(), str.size()), &cur);; 92 ; 93 // Skip any intermediate white space; 94 while (cur<size && isspace(str[cur])) ++cur;; 95 ; 96 // Read off first character which should be an SI prefix; 97 int exp = 0, unit = 1000;; 98 ; 99 auto result = [coeff,&exp,&unit,&value]() {; 100 double v = exp ? coeff * std::pow(unit, exp / 3) : coeff;; 101 if (v < (double) std::numeric_lim",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/StringConv_8hxx_source.html:3091,power,power,3091,doc/master/StringConv_8hxx_source.html,https://root.cern,https://root.cern/doc/master/StringConv_8hxx_source.html,2,['power'],['power']
Energy Efficiency,"BasicPointer(eaddr,ele,UChar_t); continue;; 4995 case TStreamerInfo::kOffsetP + TStreamerInfo::kUShort: DeleteBasicPointer(eaddr,ele,UShort_t); continue;; 4996 case TStreamerInfo::kOffsetP + TStreamerInfo::kUInt: DeleteBasicPointer(eaddr,ele,UInt_t); continue;; 4997 case TStreamerInfo::kOffsetP + TStreamerInfo::kULong: DeleteBasicPointer(eaddr,ele,ULong_t); continue;; 4998 case TStreamerInfo::kOffsetP + TStreamerInfo::kULong64:DeleteBasicPointer(eaddr,ele,ULong64_t); continue;; 4999 case TStreamerInfo::kCharStar: DeleteBasicPointer(eaddr,ele,Char_t); continue;; 5000 }; 5001 ; 5002 ; 5003 ; 5004 TClass* cle = ele->GetClassPointer();; 5005 if (!cle) continue;; 5006 ; 5007 ; 5008 if (etype == kObjectp || etype == kAnyp) {; 5009 // Destroy an array of pre-allocated objects.; 5010 Int_t len = ele->GetArrayLength();; 5011 if (!len) {; 5012 len = 1;; 5013 }; 5014 void** r = (void**) eaddr;; 5015 for (Int_t j = len - 1; j >= 0; --j) {; 5016 if (r[j]) {; 5017 cle->Destructor(r[j]);; 5018 r[j] = 0;; 5019 }; 5020 }; 5021 }; 5022 ; 5023 if ((etype == kObjectP || etype == kAnyP || etype == kSTLp) && !ele->TestBit(TStreamerElement::kDoNotDelete)) {; 5024 // Destroy an array of pointers to not-pre-allocated objects.; 5025 Int_t len = ele->GetArrayLength();; 5026 if (!len) {; 5027 len = 1;; 5028 }; 5029 void** r = (void**) eaddr;; 5030 for (Int_t j = len - 1; j >= 0; --j) {; 5031 if (r[j]) {; 5032 cle->Destructor(r[j]);; 5033 r[j] = 0;; 5034 }; 5035 }; 5036 }; 5037 ; 5038 if (etype == kBase) {; 5039 if (cle->Property() & kIsAbstract) {; 5040 TVirtualStreamerInfo *einfo = cle->GetStreamerInfoAbstractEmulated();; 5041 if (einfo) einfo->Destructor(eaddr, kTRUE);; 5042 } else {; 5043 cle->Destructor(eaddr, kTRUE);; 5044 }; 5045 }; 5046 ; 5047 if (etype == kObject || etype == kAny ||; 5048 etype == kTObject || etype == kTString || etype == kTNamed) {; 5049 // A data member is destroyed, but not deleted.; 5050 cle->Destructor(eaddr, kTRUE);; 5051 }; 5052 ; 5053 if (etype == kSTL) {; 5054",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:200661,allocate,allocated,200661,doc/master/TStreamerInfo_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html,1,['allocate'],['allocated']
Energy Efficiency,"BeltToFile(bool flag = true); virtual voidSetConfidenceLevel(Double_t cl); virtual voidSetData(RooAbsData&); virtual voidSetModel(const RooStats::ModelConfig&); voidSetNBins(Int_t bins); virtual voidSetNuisanceParameters(const RooArgSet&); virtual voidSetParameters(const RooArgSet&); virtual voidSetPdf(RooAbsPdf&); virtual voidSetTestSize(Double_t size); virtual voidShowMembers(TMemberInspector& insp); virtual Double_tSize() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidUseAdaptiveSampling(bool flag = true). private:. voidCreateParameterPoints() const; voidCreateTestStatSampler() const. Data Members; private:. Bool_tfAdaptiveSamplingcontrols use of adaptive sampling algorithm; Double_tfAdditionalNToysFactorgive user ability to ask for more toys; RooStats::ConfidenceBelt*fConfBelt; Bool_tfCreateBeltcontrols use if ConfidenceBelt should be saved to a TFile; RooAbsData&fDatadata set ; Bool_tfDoProfileConstructioninstead of full construction over nuisance parametrs, do profile; Bool_tfFluctuateDatatell ToyMCSampler to fluctuate number of entries in dataset; RooStats::ModelConfig&fModel; Int_tfNbinsnumber of samples per variable; RooAbsData*fPointsToTestpoints to perform the construction; Bool_tfSaveBeltToFilecontrols use if ConfidenceBelt should be saved to a TFile; Double_tfSizesize of the test (eg. specified rate of Type I error); RooStats::ToyMCSampler*fTestStatSamplerthe test statistic sampler. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; FeldmanCousins(RooAbsData& data, RooStats::ModelConfig& model); standard constructor. ~FeldmanCousins(); destructor; if(fOwnsWorkspace && fWS) delete fWS;. void SetModel(const RooStats::ModelConfig& ); set the model. TestStatSampler* GetTestStatSampler() const. void CreateTestStatSampler() const; specify the Test Statistic and create a ToyMC test statistic sampler. void CreateParameterPoints() const; specify the parameter points to perform the constructi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooStats__FeldmanCousins.html:3060,adapt,adaptive,3060,root/html528/RooStats__FeldmanCousins.html,https://root.cern,https://root.cern/root/html528/RooStats__FeldmanCousins.html,1,['adapt'],['adaptive']
Energy Efficiency,"BinContent (Long64_t bin, Double_t v=1.) override;  Add ""v"" to the content of bin with index ""bin"". ;  ; void AddBinError2 (Long64_t bin, Double_t e2) override;  Add ""e"" to error of bin with index ""bin"", enable errors if needed. ;  ; ROOT::Internal::THnBaseBinIter * CreateIter (Bool_t respectAxisRange) const override;  Create an iterator over all filled bins of a THnSparse. ;  ; Long64_t GetBin (const char *name[]) const override;  ; Long64_t GetBin (const char *name[], Bool_t allocate=kTRUE) override;  Get the bin index for the n dimensional tuple addressed by ""name"", allocate one if it doesn't exist yet and ""allocate"" is true. ;  ; Long64_t GetBin (const Double_t *x) const override;  ; Long64_t GetBin (const Double_t *x, Bool_t allocate=kTRUE) override;  Get the bin index for the n dimensional tuple x, allocate one if it doesn't exist yet and ""allocate"" is true. ;  ; Long64_t GetBin (const Int_t *idx) const override;  ; Long64_t GetBin (const Int_t *idx, Bool_t allocate=kTRUE) override;  Get the bin index for the n dimensional coordinates coord, allocate one if it doesn't exist yet and ""allocate"" is true. ;  ; Double_t GetBinContent (const Int_t *idx) const;  Forwards to THnBase::GetBinContent() overload. ;  ; Double_t GetBinContent (Long64_t bin, Int_t *idx=nullptr) const override;  Return the content of the filled bin number ""idx"". ;  ; Double_t GetBinError2 (Long64_t linidx) const override;  Get square of the error of bin addressed by linidx as \(\sum weight^{2}\) If errors are not enabled (via Sumw2() or CalculateErrors()) return contents. ;  ; Int_t GetChunkSize () const;  ; Long64_t GetNbins () const override;  ; Int_t GetNChunks () const;  ; Double_t GetSparseFractionBins () const;  Return the amount of filled bins over all bins. ;  ; Double_t GetSparseFractionMem () const;  Return the amount of used memory over memory that would be used by a non-sparse n-dimensional histogram. ;  ; TClass * IsA () const override;  ; THnSparse * Projection (Int_t ndim, cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHnSparse.html:6019,allocate,allocate,6019,doc/master/classTHnSparse.html,https://root.cern,https://root.cern/doc/master/classTHnSparse.html,3,['allocate'],['allocate']
Energy Efficiency,"BinContent (Long64_t bin, Double_t v=1.) override;  Add ""v"" to the content of bin with index ""bin"". ;  ; void AddBinError2 (Long64_t bin, Double_t e2) override;  Add ""e"" to error of bin with index ""bin"", enable errors if needed. ;  ; ROOT::Internal::THnBaseBinIter * CreateIter (Bool_t respectAxisRange) const override;  Create an iterator over all filled bins of a THnSparse. ;  ; Long64_t GetBin (const char *name[]) const override;  ; Long64_t GetBin (const char *name[], Bool_t allocate=kTRUE) override;  Get the bin index for the n dimensional tuple addressed by ""name"", allocate one if it doesn't exist yet and ""allocate"" is true. ;  ; Long64_t GetBin (const Double_t *x) const override;  ; Long64_t GetBin (const Double_t *x, Bool_t allocate=kTRUE) override;  Get the bin index for the n dimensional tuple x, allocate one if it doesn't exist yet and ""allocate"" is true. ;  ; Long64_t GetBin (const Int_t *idx) const override;  ; Long64_t GetBin (const Int_t *idx, Bool_t allocate=kTRUE) override;  Get the bin index for the n dimensional coordinates coord, allocate one if it doesn't exist yet and ""allocate"" is true. ;  ; Double_t GetBinContent (const Int_t *idx) const;  Forwards to THnBase::GetBinContent() overload. ;  ; Double_t GetBinContent (Long64_t bin, Int_t *idx=nullptr) const override;  Return the content of the filled bin number ""idx"". ;  ; Double_t GetBinError2 (Long64_t linidx) const override;  Get square of the error of bin addressed by linidx as \(\sum weight^{2}\) If errors are not enabled (via Sumw2() or CalculateErrors()) return contents. ;  ; Int_t GetChunkSize () const;  ; Long64_t GetNbins () const override;  ; Int_t GetNChunks () const;  ; Double_t GetSparseFractionBins () const;  Return the amount of filled bins over all bins. ;  ; Double_t GetSparseFractionMem () const;  Return the amount of used memory over memory that would be used by a non-sparse n-dimensional histogram. ;  ; THnSparse * Projection (Int_t ndim, const Int_t *dim, Option_t *option="""") ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHnSparseT.html:3283,allocate,allocate,3283,doc/master/classTHnSparseT.html,https://root.cern,https://root.cern/doc/master/classTHnSparseT.html,3,['allocate'],['allocate']
Energy Efficiency,BinVarX;  Number of bin in independent variables. ;  ; Int_t fBinVarY;  Number of bin in dependent variables. ;  ; Double_t fChi2;  Chi square of fit. ;  ; TVectorD fCoefficients;  Vector of the final coefficients. ;  ; TVectorD fCoefficientsRMS;  Vector of RMS of coefficients. ;  ; Double_t fCorrelationCoeff;  Multi Correlation coefficient. ;  ; TMatrixD fCorrelationMatrix;  Correlation matrix. ;  ; Double_t fError;  Error from parametrization. ;  ; TVirtualFitter * fFitter;  ; Int_t * fFunctionCodes;  [fMaxFunctions] acceptance code ;  ; TMatrixD fFunctions;  Functions evaluated over sample. ;  ; Byte_t fHistogramMask;  Bit pattern of histograms used. ;  ; TList * fHistograms;  List of histograms. ;  ; Bool_t fIsUserFunction;  Flag for user defined function. ;  ; Bool_t fIsVerbose;  ; Double_t fMaxAngle;  Max angle for accepting new function. ;  ; Int_t fMaxFuncNV;  fMaxFunctions*fNVariables ;  ; Int_t fMaxFunctions;  max number of functions ;  ; Int_t * fMaxPowers;  [fNVariables] maximum powers ;  ; Int_t * fMaxPowersFinal;  [fNVariables] maximum powers from fit; ;  ; Double_t fMaxQuantity;  Max value of dependent quantity. ;  ; Double_t fMaxResidual;  Max residual value. ;  ; Int_t fMaxResidualRow;  Row giving max residual. ;  ; Int_t fMaxStudy;  max functions to study ;  ; Int_t fMaxTerms;  Max terms expected in final expr. ;  ; TVectorD fMaxVariables;  max value of independent variables ;  ; Double_t fMeanQuantity;  Mean of dependent quantity. ;  ; TVectorD fMeanVariables;  mean value of independent variables ;  ; Double_t fMinAngle;  Min angle for accepting new function. ;  ; Double_t fMinQuantity;  Min value of dependent quantity. ;  ; Double_t fMinRelativeError;  Min relative error accepted. ;  ; Double_t fMinResidual;  Min residual value. ;  ; Int_t fMinResidualRow;  Row giving min residual. ;  ; TVectorD fMinVariables;  min value of independent variables ;  ; Int_t fNCoefficients;  Dimension of model coefficients. ;  ; Int_t fNVariables;  Number of indepe,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMultiDimFit.html:35759,power,powers,35759,doc/master/classTMultiDimFit.html,https://root.cern,https://root.cern/doc/master/classTMultiDimFit.html,2,['power'],['powers']
Energy Efficiency,"BindingRooCFunction1Binding is a templated implementation of class RooAbsReal that binds generic C(++) functions to a RooAbsReal argument thus allowing generic C++ functions to be used as RooFit functions ;  CRooFunctor1DPdfBinding;  CRooFunctorBindingRooCFunction1Binding is a templated implementation of class RooAbsReal that binds generic C(++) functions to a RooAbsReal argument thus allowing generic C++ functions to be used as RooFit functions ;  CRooFunctorPdfBinding;  CRooGamma;  CRooGaussianPlain Gaussian p.d.f ;  CRooGaussKronrodIntegrator1DRooGaussKronrodIntegrator1D implements the Gauss-Kronrod integration algorithm ;  CRooGaussModelClass RooGaussModel implements a RooResolutionModel that models a Gaussian distribution ;  CRooGenContextClass RooGenContext implement a universal generator context for all RooAbsPdf classes that do not have or need a specialized generator context ;  CRooGenericPdfRooGenericPdf is a concrete implementation of a probability density function, which takes a RooArgList of servers and a C++ expression string defining how its value should be calculated from the given list of servers ;  CRooGenFitStudyRooGenFitStudy is an abstract base class for RooStudyManager modules ;  CRooGenFunctionLightweight interface adaptor that exports a RooAbsReal as a ROOT::Math::IGenFunction ;  CRooGenProdProjRooGenProdProj is an auxiliary class for RooProdPdf that calculates a general normalized projection of a product of non-factorizing PDFs, e.g ;  CRooGExpModelClass RooGExpModel is a RooResolutionModel implementation that models a resolution function that is the convolution of a Gaussian with a one-sided exponential ;  CRooGlobalFunc;  CRooGridRooGrid is a utility class for RooMCIntegrator which implements an adaptive multi-dimensional Monte Carlo numerical integration, following the VEGAS algorithm ;  CRooHashTableRooHashTable implements a hash table for TObjects ;  CRooHistA RooHist is a graphical representation of binned data based on the TGraphAsymm",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/annotated.html:91812,adapt,adaptor,91812,doc/v608/annotated.html,https://root.cern,https://root.cern/doc/v608/annotated.html,1,['adapt'],['adaptor']
Energy Efficiency,"Bins. TFitResultPtr Fit(TF1* f1, Option_t* option = """", Option_t* goption = """"); Fit a THnSparse with function f. since the data is sparse by default a likelihood fit is performed; merging all the regions with empty bins for betetr performance efficiency. Since the THnSparse is not drawn no graphics options are passed; Here is the list of possible options. = ""I"" Use integral of function in bin instead of value at bin center; = ""X"" Use chi2 method (default is log-likelihood method); = ""U"" Use a User specified fitting algorithm (via SetFCN); = ""Q"" Quiet mode (minimum printing); = ""V"" Verbose mode (default is between Q and V); = ""E"" Perform better Errors estimation using Minos technique; = ""B"" Use this option when you want to fix one or more parameters; and the fitting function is like ""gaus"", ""expo"", ""poln"", ""landau"".; = ""M"" More. Improve fit results; = ""R"" Use the Range specified in the function range. Long64_t GetBin(const Double_t* x, Bool_t allocate = kTRUE); Get the bin index for the n dimensional tuple x,; allocate one if it doesn't exist yet and ""allocate"" is true. Long64_t GetBin(const char* name[], Bool_t allocate /* = kTRUE */); Get the bin index for the n dimensional tuple addressed by ""name"",; allocate one if it doesn't exist yet and ""allocate"" is true. Long64_t GetBin(const Int_t* idx, Bool_t allocate = kTRUE); Get the bin index for the n dimensional coordinates coord,; allocate one if it doesn't exist yet and ""allocate"" is true. Double_t GetBinContent(const Int_t* idx) const; Get content of bin with coordinates ""coord"". Double_t GetBinContent(Long64_t bin, Int_t* idx = 0) const; Return the content of the filled bin number ""idx"".; If coord is non-null, it will contain the bin's coordinates for each axis; that correspond to the bin. Double_t GetBinError(const Int_t* idx) const; Get error of bin with coordinates ""coord"" as. If errors are not enabled (via Sumw2() or CalculateErrors()); return sqrt(contents). Double_t GetBinError(Long64_t linidx) const; Get e",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/THnSparse.html:16467,allocate,allocate,16467,root/html528/THnSparse.html,https://root.cern,https://root.cern/root/html528/THnSparse.html,9,['allocate'],['allocate']
Energy Efficiency,"BitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TGLLightSet::ELightkLightBottom; static TGLLightSet::ELightkLightFront; static TGLLightSet::ELightkLightLeft; static TGLLightSet::ELightkLightMask; static TGLLightSet::ELightkLightRight; static TGLLightSet::ELightkLightSpecular; static TGLLightSet::ELightkLightTop; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Float_tfFrontPower! power of the front lamp; UInt_tfLightState! light states (on/off) mask; Float_tfSidePower! power of the side lamps; Float_tfSpecularPower! power of specular lamp; Bool_tfUseSpecular!. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLLightSet(); Constructor. void ToggleLight(TGLLightSet::ELight light); Toggle light on/off. void SetLight(TGLLightSet::ELight light, Bool_t on); Set a light on/off. void StdSetupLights(const TGLBoundingBox& bbox, const TGLCamera& camera, Bool_t debug = kFALSE); Setup lights for current given bounding box and camera.; This is called by standard GL viewer.; Expects matrix-mode to be model-view. TGLLightSet(const TGLLightSet& ). TGLLightSet& operator=(const TGLLightSet& ). virtual ~TGLLightSet(); {}. UInt_t GetLightState(); { return fLightState; }. Bool_t GetUseSpecular() const; { return fUseSpecular; }. void SetUseSpecular(Bool_t s); { fUseSpecular = s; }. Float_t GetFrontPower() const; { return fFrontPower; }. Float_t GetSidePower() const; { return fSidePower; }. Float_t GetSpecularPower() cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGLLightSet.html:6370,power,power,6370,root/html602/TGLLightSet.html,https://root.cern,https://root.cern/root/html602/TGLLightSet.html,6,['power'],['power']
Energy Efficiency,"Bool_t *b, Long64_t n)=0; TBuffer::ReadFastArrayWithFactorvirtual void ReadFastArrayWithFactor(Float_t *ptr, Int_t n, Double_t factor, Double_t minvalue)=0; TBuffer::WriteVersionvirtual UInt_t WriteVersion(const TClass *cl, Bool_t useBcnt=kFALSE)=0; TBuffer::ReadFastArrayFloat16virtual void ReadFastArrayFloat16(Float_t *f, Int_t n, TStreamerElement *ele=nullptr)=0; TBuffer::LengthInt_t Length() constDefinition TBuffer.h:100; TBuffer::StreamObjectvirtual void StreamObject(void *obj, const std::type_info &typeinfo, const TClass *onFileClass=nullptr)=0; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClass::Streamervoid Streamer(void *obj, TBuffer &b, const TClass *onfile_class=nullptr) constDefinition TClass.h:607; TClass::CanSplitBool_t CanSplit() constReturn true if the data member of this TClass can be saved separately.Definition TClass.cxx:2386; TClass::NewArrayvoid * NewArray(Long_t nElements, ENewType defConstructor=kClassNew) constReturn a pointer to a newly allocated array of objects of this class.Definition TClass.cxx:5260; TClass::GetStateEState GetState() constDefinition TClass.h:488; TClass::Newvoid * New(ENewType defConstructor=kClassNew, Bool_t quiet=kFALSE) constReturn a pointer to a newly allocated object of this class.Definition TClass.cxx:5045; TClass::HasCustomStreamerMemberBool_t HasCustomStreamerMember() constThe class has a Streamer method and it is implemented by the user or an older (not StreamerInfo based...Definition TClass.h:508; TClass::SizeInt_t Size() constReturn size of object of this class.Definition TClass.cxx:5771; TClass::DeleteArrayvoid DeleteArray(void *ary, Bool_t dtorOnly=kFALSE)Explicitly call operator delete[] for an array.Definition TClass.cxx:5596; TClass::GetStreamerInfoTVirtualStreamerInfo * GetStreamerInfo(Int_t version=0, Bool_t isTransient=kFALSE) constreturns a pointer to the TVirtualStreamerInfo object for version If the object does not exist,...Definitio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html:214988,allocate,allocated,214988,doc/master/TStreamerInfoActions_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html,1,['allocate'],['allocated']
Energy Efficiency,"Box& box, const TGLCamera& camera, Double_t& base, TGLVector3[3] axis) const; const UChar_t*TGLManip::ColorFor(UInt_t widget) const. private:. voidLimitScale(Double_t& factor) const. Data Members; protected:. Bool_tTGLManip::fActive! manipulator is active?; TPointTGLManip::fFirstMouse! first (start) mouse position (in WINDOW coords); TPointTGLManip::fLastMouse! last (latest) mouse position (in WINDOW coords); UInt_tTGLManip::fSelectedWidget! active width (axis) component; TGLPhysicalShape*TGLManip::fShape! manipulated shape. private:. TGLVector3fStartScale! initial scaling factors. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLScaleManip(); Construct scale manipulator not bound to any physical shape. TGLScaleManip(TGLPhysicalShape* shape); Construct scale manipulator bound to TGLPhysicalShape 'shape'. ~TGLScaleManip(); Destory the scale manipulator. void Draw(const TGLCamera& camera) const; Draw scale manipulator - tubes with box heads, in local axes of; attached shape, in red(X), green(Y) and blue(Z), with white center sphere.; If selected widget (mouse over) this is drawn in active colour (yellow). Bool_t HandleButton(const Event_t& event, const TGLCamera& camera); Handle mouse button event over manipulator - returns kTRUE if; redraw required kFALSE otherwise. Bool_t HandleMotion(const Event_t& event, const TGLCamera& camera); Handle mouse motion over manipulator - if active (selected; widget) scale physical along selected widget (axis) of the; manipulator, so it tracks mouse action. Returns kTRUE if redraw; required kFALSE otherwise. void LimitScale(Double_t& factor) const; Clamp scale to sizable values: 1000 - 1/1000; Guards against div by zero problems. TGLScaleManip(). » Author: Richard Maunder 16/09/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id$ » Last generated: 2015-06-02 15:53; This page has been automatically generated. For comments or suggestions regarding the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGLScaleManip.html:2600,green,green,2600,root/html604/TGLScaleManip.html,https://root.cern,https://root.cern/root/html604/TGLScaleManip.html,1,['green'],['green']
Energy Efficiency,"Box& box, const TGLCamera& camera, Double_t& base, TGLVector3[3] axis) const; const UChar_t*TGLManip::ColorFor(UInt_t widget) const. private:. voidLimitScale(Double_t& factor) const. Data Members; protected:. Bool_tTGLManip::fActive! manipulator is active?; TPointTGLManip::fFirstMouse! first (start) mouse position (in WINDOW coords); TPointTGLManip::fLastMouse! last (latest) mouse position (in WINDOW coords); UInt_tTGLManip::fSelectedWidget! active width (axis) component; TGLPhysicalShape*TGLManip::fShape! manipulated shape. private:. TGLVector3fStartScale! initial scaling factors. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLScaleManip(); Construct scale manipulator not bound to any physical shape. TGLScaleManip(TGLPhysicalShape* shape); Construct scale manipulator bound to TGLPhysicalShape 'shape'. ~TGLScaleManip(); Destory the scale manipulator. void Draw(const TGLCamera& camera) const; Draw scale manipulator - tubes with box heads, in local axes of; attached shape, in red(X), green(Y) and blue(Z), with white center sphere.; If selected widget (mouse over) this is drawn in active colour (yellow). Bool_t HandleButton(const Event_t& event, const TGLCamera& camera); Handle mouse button event over manipulator - returns kTRUE if; redraw required kFALSE otherwise. Bool_t HandleMotion(const Event_t& event, const TGLCamera& camera); Handle mouse motion over manipulator - if active (selected; widget) scale physical along selected widget (axis) of the; manipulator, so it tracks mouse action. Returns kTRUE if redraw; required kFALSE otherwise. void LimitScale(Double_t& factor) const; Clamp scale to sizable values: 1000 - 1/1000; Guards against div by zero problems. TGLScaleManip(). » Author: Richard Maunder 16/09/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id$ » Last generated: 2015-06-30 14:53; This page has been automatically generated. For comments or suggestions regarding the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGLScaleManip.html:2600,green,green,2600,root/html602/TGLScaleManip.html,https://root.cern,https://root.cern/root/html602/TGLScaleManip.html,1,['green'],['green']
Energy Efficiency,"Box(""sensor"", 19,9,0.2);; // The volume for the sensor; TGeoVolume *sensor = new TGeoVolume(""sensor"",ssensor, medSi);; sensor->SetLineColor(kRed);; ; // Chip assembly of support+sensor; TGeoVolumeAssembly *chip = new TGeoVolumeAssembly(""chip"");; chip->AddNode(support, 1);; chip->AddNode(sensor,1, new TGeoTranslation(0,0,-2.1));; ; // A ladder that normally sags; TGeoBBox *sladder = new TGeoBBox(""sladder"", 20,300,5);; // The volume for the ladder; TGeoVolume *ladder = new TGeoVolume(""ladder"",sladder, medAl);; ladder->SetLineColor(kBlue);; ; // Add nodes; top->AddNode(ladder,1);; for (Int_t i=0; i<10; i++); top->AddNode(chip, i+1, new TGeoTranslation(0, -225.+50.*i, 10));; ; gGeoManager->CloseGeometry();; TGeoParallelWorld *pw = nullptr;; if (usepw) pw = gGeoManager->CreateParallelWorld(""priority_sensors"");; // Align chips; align();; if (usepw) {; if (useovlp) pw->AddOverlap(ladder);; pw->CloseGeometry();; gGeoManager->SetUseParallelWorldNav(kTRUE);; }; TString cname;; cname = usepw ? ""cpw"" : ""cnopw"";; TCanvas *c = (TCanvas*)gROOT->GetListOfCanvases()->FindObject(cname);; if (c) c->cd();; else c = new TCanvas(cname, """",800,600);; top->Draw();; // top->RandomRays(0,0,0,0,sensor->GetName());; // Track random ""particles"" coming from the block side and draw only the tracklets; // actually crossing one of the sensors. Note that some of the tracks coming; // from the outer side may see the full sensor, while the others only part of it.; TStopwatch timer;; timer.Start();; top->RandomRays(100000,0,0,-30,sensor->GetName());; timer.Stop();; timer.Print();; TView3D *view = (TView3D*)gPad->GetView();; if (view) {; view->SetParallel();; view->Side();; }; if (usepw) pw->PrintDetectedOverlaps();; }; ; //______________________________________________________________________________; void align(); {; // Aligning 2 sensors so they will overlap with the support. One sensor is positioned; // normally while the other using the shared matrix; TGeoPhysicalNode *node;; TGeoParallelWorld *pw =",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/parallel__world_8C.html:3102,sensor,sensor,3102,doc/master/parallel__world_8C.html,https://root.cern,https://root.cern/doc/master/parallel__world_8C.html,2,['sensor'],"['sensor', 'sensors']"
Energy Efficiency,"Branch * b_ptds_dDefinition h1analysis.h:252; h1analysis::b_ntracksTBranch * b_ntracksDefinition h1analysis.h:303; h1analysis::rstartFloat_t rstart[200]Definition h1analysis.h:161; h1analysis::b_njetsTBranch * b_njetsDefinition h1analysis.h:328; h1analysis::Beginvoid Begin(TTree *tree) override; h1analysis::ipisInt_t ipisDefinition h1analysis.h:107; h1analysis::ptd0_dFloat_t ptd0_dDefinition h1analysis.h:109; h1analysis::njetsInt_t njetsDefinition h1analysis.h:174; h1analysis::nlhkFloat_t nlhk[200]Definition h1analysis.h:165; h1analysis::elistTEntryList * elistDefinition h1analysis.h:32; h1analysis::SlaveBeginvoid SlaveBegin(TTree *tree) override; h1analysis::etads_dFloat_t etads_dDefinition h1analysis.h:99; h1analysis::h2TH2F * h2Definition h1analysis.h:28; h1analysis::b_ptd0_dTBranch * b_ptd0_dDefinition h1analysis.h:263; h1analysis::ptds_dFloat_t ptds_dDefinition h1analysis.h:98; h1analysis::Terminatevoid Terminate() override; h1analysis::ipiInt_t ipiDefinition h1analysis.h:106; lineTLine * lineDefinition entrylistblock_figure1.C:235; fdm5Double_t fdm5(Double_t *xx, Double_t *par)Definition h1analysisProxy.h:14; sigmaconst Double_t sigmaDefinition h1analysisProxy.h:11; dxbinconst Double_t dxbinDefinition h1analysisProxy.h:10; fdm2Double_t fdm2(Double_t *xx, Double_t *par)Definition h1analysisProxy.h:25; h1analysis.h; c1return c1Definition legend1.C:41; xDouble_t x[n]Definition legend1.C:17; c2return c2Definition legend2.C:14; TMath::ExpDouble_t Exp(Double_t x)Returns the base-e exponential function of x, which is e raised to the power x.Definition TMath.h:709; TMath::PowerLongDouble_t Power(LongDouble_t x, LongDouble_t y)Returns x raised to the power y.Definition TMath.h:721; TMath::AbsShort_t Abs(Short_t d)Returns the absolute value of parameter Short_t d.Definition TMathBase.h:123; AuthorRene Brun ; Definition in file h1analysis.C. tutorialstreeh1analysis.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/h1analysis_8C.html:21968,power,power,21968,doc/master/h1analysis_8C.html,https://root.cern,https://root.cern/doc/master/h1analysis_8C.html,2,['power'],['power']
Energy Efficiency,"Branch::ResetAfterMerge(info);; 4775}; 4776 ; 4777////////////////////////////////////////////////////////////////////////////////; 4778/// Set branch address to zero and free all allocated memory.; 4779 ; 4780void TBranchElement::ResetAddress(); 4781{; 4782 for (Int_t i = 0; i < fNleaves; ++i) {; 4783 TLeaf* leaf = (TLeaf*) fLeaves.UncheckedAt(i);; 4784 //if (leaf) leaf->SetAddress(0);; 4785 leaf->SetAddress(nullptr);; 4786 }; 4787 ; 4788 // Note: We *must* do the sub-branches first, otherwise; 4789 // we may delete the object containing the sub-branches; 4790 // before giving them a chance to cleanup.; 4791 Int_t nbranches = fBranches.GetEntriesFast();; 4792 for (Int_t i = 0; i < nbranches; ++i) {; 4793 TBranch* br = (TBranch*) fBranches[i];; 4794 if (br) br->ResetAddress();; 4795 }; 4796 ; 4797 //; 4798 // SetAddress may have allocated an object.; 4799 //; 4800 ; 4801 ReleaseObject();; 4802 ; 4803 ResetBit(kAddressSet);; 4804 fAddress = nullptr;; 4805 fObject = nullptr;; 4806}; 4807 ; 4808////////////////////////////////////////////////////////////////////////////////; 4809/// Release ownership of any allocated objects.; 4810///; 4811/// Note: This interface was added so that clone trees could; 4812/// be told they do not own the allocated objects.; 4813 ; 4814void TBranchElement::ResetDeleteObject(); 4815{; 4816 ResetBit(kDeleteObject);; 4817 Int_t nb = fBranches.GetEntriesFast();; 4818 for (Int_t i = 0; i < nb; ++i) {; 4819 TBranch* br = (TBranch*) fBranches[i];; 4820 if (br->InheritsFrom(TBranchElement::Class())) {; 4821 ((TBranchElement*) br)->ResetDeleteObject();; 4822 }; 4823 }; 4824}; 4825 ; 4826////////////////////////////////////////////////////////////////////////////////; 4827/// \brief Reset offset and StreamerInfo information from this branch.; 4828/// \param[in] recurse When true call ResetInitInfo on all subbranches.; 4829///; 4830 ; 4831void TBranchElement::ResetInitInfo(bool recurse); 4832{; 4833 fInfo = nullptr;; 4834 fInit = false;; 4835 fInitOf",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBranchElement_8cxx_source.html:177998,allocate,allocated,177998,doc/master/TBranchElement_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html,1,['allocate'],['allocated']
Energy Efficiency,"Buffer.h""; 14#include ""TTree.h""; 15#include ""TBranch.h""; 16#include ""TLeaf.h""; 17#include ""TBrowser.h""; 18#include ""TreeUtils.h""; 19#include ""strlcpy.h""; 20 ; 21#include <string>; 22 ; 23ClassImp(TNtuple);; 24 ; 25/** \class TNtuple; 26\ingroup tree; 27 ; 28A simple TTree restricted to a list of float variables only.; 29 ; 30Each variable goes to a separate branch.; 31 ; 32A Ntuple is created via; 33~~~ {.cpp}; 34 TNtuple(name,title,varlist,bufsize); 35~~~; 36It is filled via:; 37~~~ {.cpp}; 38 TNtuple::Fill(*x) or; 39 TNtuple::Fill(v1,v2,v3.....); 40~~~; 41*/; 42 ; 43////////////////////////////////////////////////////////////////////////////////; 44/// Default constructor for Ntuple.; 45 ; 46TNtuple::TNtuple(): TTree(); 47{; 48 fNvar = 0;; 49 fArgs = nullptr;; 50}; 51 ; 52////////////////////////////////////////////////////////////////////////////////; 53/// Create an Ntuple.; 54///; 55/// The parameter varlist describes the list of the ntuple variables; 56/// separated by a colon:; 57///; 58/// Example: `x:y:z:energy`; 59///; 60/// For each variable in the list a separate branch is created.; 61///; 62/// NOTE:; 63/// - Use TTree to create branches with variables of different data types.; 64/// - Use TTree when the number of branches is large (> 100).; 65 ; 66TNtuple::TNtuple(const char *name, const char *title, const char *varlist, Int_t bufsize); 67 :TTree(name,title); 68{; 69 Int_t i;; 70 fNvar = 0;; 71 fArgs = nullptr;; 72 ; 73// Count number of variables (separated by :); 74 Int_t nch = strlen(varlist);; 75 if (nch == 0) return;; 76 char *vars = new char[nch+1];; 77 strlcpy(vars,varlist,nch+1);; 78 Int_t *pvars = new Int_t[nch+1];; 79 fNvar = 1;; 80 pvars[0] = 0;; 81 for (i=1;i<nch;i++) {; 82 if (vars[i] == ':') {; 83 pvars[fNvar] = i+1;; 84 vars[i] = 0;; 85 fNvar++;; 86 }; 87 }; 88 fArgs = new Float_t[fNvar];; 89 ; 90// Create one branch for each variable; 91 for (i=0;i<fNvar;i++) {; 92 Int_t pv = pvars[i];; 93 TTree::Branch(&vars[pv],&fArgs[i],&vars[pv],buf",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TNtuple_8cxx_source.html:1682,energy,energy,1682,doc/master/TNtuple_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TNtuple_8cxx_source.html,1,['energy'],['energy']
Energy Efficiency,"Buffer3D*fBuffbuffer of projectable object. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEvePolygonSetProjected(const char* n = ""TEvePolygonSetProjected"", const char* t = """"); Constructor. ~TEvePolygonSetProjected(); Destructor. void ComputeBBox(); Override of virtual method from TAttBBox. void SetProjection(TEveProjectionManager* mng, TEveProjectable* model); This is virtual method from base-class TEveProjected. void SetDepthLocal(Float_t d); Set depth (z-coordinate) of the projected points. void UpdateProjection(); This is virtual method from base-class TEveProjected. Bool_t IsFirstIdxHead(Int_t s0, Int_t s1); Compare the two segments and check if the first index of first segment is starting. Int_t* ProjectAndReducePoints(); Project and reduce buffer points. Float_t AddPolygon(list<Int_t>& pp, list<TEvePolygonSetProjected::Polygon_t>& p); Check if polygon has dimensions above TEveProjection::fgEps and add it; to a list if it is not a duplicate. Float_t MakePolygonsFromBP(Int_t* idxMap); Build polygons from list of buffer polygons. Float_t MakePolygonsFromBS(Int_t* idxMap); Build polygons from the set of buffer segments.; First creates a segment pool according to reduced and projected points; and then build polygons from the pool. void ProjectBuffer3D(); Project current buffer. Float_t PolygonSurfaceXY(const TEvePolygonSetProjected::Polygon_t& poly) const; Calculate XY surface of a polygon. void DumpPolys() const; Dump information about built polygons. void DumpBuffer3D(); Dump information about currenty projected buffer. TEvePolygonSetProjected(const TEvePolygonSetProjected& ). TEvePolygonSetProjected& operator=(const TEvePolygonSetProjected& ). TEveElement* GetProjectedAsElement(); { return this; }. » Last changed: root/eve:$Id$ » Last generated: 2015-06-02 15:44; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TEvePolygonSetProjected.html:25334,reduce,reduced,25334,root/html604/TEvePolygonSetProjected.html,https://root.cern,https://root.cern/root/html604/TEvePolygonSetProjected.html,1,['reduce'],['reduced']
Energy Efficiency,"Buffer3D*fBuffbuffer of projectable object. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEvePolygonSetProjected(const char* n = ""TEvePolygonSetProjected"", const char* t = """"); Constructor. ~TEvePolygonSetProjected(); Destructor. void ComputeBBox(); Override of virtual method from TAttBBox. void SetProjection(TEveProjectionManager* mng, TEveProjectable* model); This is virtual method from base-class TEveProjected. void SetDepthLocal(Float_t d); Set depth (z-coordinate) of the projected points. void UpdateProjection(); This is virtual method from base-class TEveProjected. Bool_t IsFirstIdxHead(Int_t s0, Int_t s1); Compare the two segments and check if the first index of first segment is starting. Int_t* ProjectAndReducePoints(); Project and reduce buffer points. Float_t AddPolygon(list<Int_t>& pp, list<TEvePolygonSetProjected::Polygon_t>& p); Check if polygon has dimensions above TEveProjection::fgEps and add it; to a list if it is not a duplicate. Float_t MakePolygonsFromBP(Int_t* idxMap); Build polygons from list of buffer polygons. Float_t MakePolygonsFromBS(Int_t* idxMap); Build polygons from the set of buffer segments.; First creates a segment pool according to reduced and projected points; and then build polygons from the pool. void ProjectBuffer3D(); Project current buffer. Float_t PolygonSurfaceXY(const TEvePolygonSetProjected::Polygon_t& poly) const; Calculate XY surface of a polygon. void DumpPolys() const; Dump information about built polygons. void DumpBuffer3D(); Dump information about currenty projected buffer. TEvePolygonSetProjected(const TEvePolygonSetProjected& ). TEvePolygonSetProjected& operator=(const TEvePolygonSetProjected& ). TEveElement* GetProjectedAsElement(); { return this; }. » Last changed: root/eve:$Id$ » Last generated: 2015-06-30 14:46; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEvePolygonSetProjected.html:25334,reduce,reduced,25334,root/html602/TEvePolygonSetProjected.html,https://root.cern,https://root.cern/root/html602/TEvePolygonSetProjected.html,1,['reduce'],['reduced']
Energy Efficiency,"BufferFraction() member function. This class is a caching p.d.f inheriting from RooAbsCachedPdf. If this p.d.f; is evaluated for a particular value of x, the FFT calculate the values for the; p.d.f at all points in observables space for the given choice of parameters,; which are stored in the cache. Subsequent evaluations of RooFFTConvPdf with; identical parameters will retrieve results from the cache. If one or more; of the parameters change, the cache will be updated. The sampling density of the cache is controlled by the binning of the; the convolution observable, which can be changed from RooRealVar::setBins(N); For good results N should be large (>1000). Additional interpolation of; cache values may improve the result if courser binning are chosen. These can be; set in the constructor or through the setInterpolationOrder() member function.; For N>1000 interpolation will not substantially improve the performance. Additionial information on caching activities can be displayed by monitoring; the message stream with topic ""Caching"" at the INFO level, i.e.; do RooMsgService::instance().addStream(RooMsgService::INFO,Topic(""Caching"")); to see these message on stdout. Multi-dimensional convolutions are not supported yet, but will be in the future; as FFTW can calculate them. Installing a copy of FFTW on Linux and compiling ROOT to use it. 1) Go to www.fftw.org and download the latest stable version (a .tar.gz file). If you have root access to your machine and want to make a system installation of FFTW. 2) Untar fftw-XXX.tar.gz in /tmp, cd into the untarred directory; and type './configure' followed by 'make install'.; This will install fftw in /usr/local/bin,lib etc... 3) Start from a source installation of ROOT. If you now have a binary distribution,; first download a source tar ball from root.cern.ch for your ROOT version and untar it.; Run 'configure', following the instruction from 'configure --help' but be sure run 'configure'; with additional flags '--enable-fftw",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooFFTConvPdf.html:2885,monitor,monitoring,2885,root/html526/RooFFTConvPdf.html,https://root.cern,https://root.cern/root/html526/RooFFTConvPdf.html,7,['monitor'],['monitoring']
Energy Efficiency,"CIFace;  CSpecialsIFace;  ►CRooFFTConvPdf;  CFFTCacheElem;  CRooFirstMomentRooFirstMoment represents the first, second, or third order derivative of any RooAbsReal as calculated (numerically) by the MathCore Richardson derivator class ;  CRooFIter;  CRooFitResult;  CRooFoamGeneratorClass RooFoamGenerator is a generic toy monte carlo generator that implement the TFOAM sampling technique on any positively valued function ;  CRooFormulaRooFormula an implementation of ROOT::v5::TFormula that interfaces it to RooAbsArg value objects ;  CRooFormulaVar;  CRooFracRemainderRooFracRemainder calculates the remainder fraction of a sum of RooAbsReal fraction, i.e (1 - sum_i a_i) ;  CRooFunctorLightweight interface adaptor that exports a RooAbsPdf as a functor ;  CRooFunctor1DBindingRooCFunction1Binding is a templated implementation of class RooAbsReal that binds generic C(++) functions to a RooAbsReal argument thus allowing generic C++ functions to be used as RooFit functions ;  CRooFunctor1DPdfBinding;  CRooFunctorBindingRooCFunction1Binding is a templated implementation of class RooAbsReal that binds generic C(++) functions to a RooAbsReal argument thus allowing generic C++ functions to be used as RooFit functions ;  CRooFunctorPdfBinding;  CRooGammaImplementation of the Gamma PDF for RooFit/RooStats ;  CRooGaussianPlain Gaussian p.d.f ;  CRooGaussKronrodIntegrator1DRooGaussKronrodIntegrator1D implements the Gauss-Kronrod integration algorithm ;  CRooGaussModelClass RooGaussModel implements a RooResolutionModel that models a Gaussian distribution ;  CRooGenContextClass RooGenContext implement a universal generator context for all RooAbsPdf classes that do not have or need a specialized generator context ;  CRooGenericPdfRooGenericPdf is a concrete implementation of a probability density function, which takes a RooArgList of servers and a C++ expression string defining how its value should be calculated from the given list of servers ;  CRooGenFitStudyRooGenFitStudy is an abstr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v610/annotated.html:99254,adapt,adaptor,99254,doc/v610/annotated.html,https://root.cern,https://root.cern/doc/v610/annotated.html,3,['adapt'],['adaptor']
Energy Efficiency,"CL upper limit using the Feldman-Cousins method; TFile ROOT file; TFileCacheRead TFile cache when reading; TFileCacheWrite TFile cache when writing; TFileCollection Collection of TFileInfo objects; TFileDrawMap Draw a 2-d map of the objects in a file; TFileHandler Handles events on file descriptors; TFileInfo Describes generic file info including meta data information; TFileInfoMeta Describes TFileInfo meta data; TFileIter TFile class iterator; TFileMerger File copying and merging services; TFileSet TDataSet class to read the native file system directory structure in; TFileStager ABC defining interface to a stager; TFitEditor Fit Panel interface; TFitParametersDialog Fit function parameters dialog; TFitResult Class holding the result of the fit ; TFitResultPtr indirection to TFitResult; TFitter The ROOT standard fitter based on TMinuit; TFitterFumili Fitter based on new Fumili method (Fumili2); TFitterMinuit The ROOT fitter based on new Minuit (Minuit2); TFoam General purpose self-adapting Monte Carlo event generator; TFoamCell Single cell of FOAM; TFoamIntegrand n-dimensional real positive integrand of FOAM; TFoamMaxwt Controlling of the MC weight (maximum weight); TFoamSampler ; TFoamVect n-dimensional vector with dynamical allocation; TFolder Describe a folder: a list of objects and folders; TFormula The formula base class f(x,y,z,par); TFormulaPrimitive The primitive formula ; TFractionFitter Fits MC fractions to data histogram; TFrame Pad graphics frame; TFrameEditor editor of TFrame objects; TFree Description of free segments on a file; TFriendElement A friend element of another TTree; TFumili The FUMILI Minimization package; TFumiliMinimizer Implementation of Minimizer interface using TFumili ; TFunction Dictionary for global function; TFunctionParametersDialog Function parameters dialog; TG16ColorSelector 16 color cells; TGApplication GUI application singleton; TGButton Button widget abstract base class; TGButtonGroup Organizes TGButtons in a group; TGCanvas ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ClassIndex.html:71517,adapt,adapting,71517,root/html528/ClassIndex.html,https://root.cern,https://root.cern/root/html528/ClassIndex.html,1,['adapt'],['adapting']
Energy Efficiency,"CL upper limit using the Feldman-Cousins method; TFile ROOT file; TFileCacheRead TFile cache when reading; TFileCacheWrite TFile cache when writing; TFileCollection Collection of TFileInfo objects; TFileDrawMap Draw a 2-d map of the objects in a file; TFileHandler Handles events on file descriptors; TFileInfo Describes generic file info including meta data information; TFileInfoMeta Describes TFileInfo meta data; TFileIter TFile class iterator; TFileMerger File copying and merging services; TFileSet TDataSet class to read the native file system directory structure in; TFileStager ABC defining interface to a stager; TFitEditor Fit Panel interface; TFitParametersDialog Fit function parameters dialog; TFitResult Class holding the result of the fit ; TFitResultPtr indirection to TFitResult; TFitter The ROOT standard fitter based on TMinuit; TFitterFumili Fitter based on new Fumili method (Fumili2); TFitterMinuit The ROOT fitter based on new Minuit (Minuit2); TFoam General purpose self-adapting Monte Carlo event generator; TFoamCell Single cell of FOAM; TFoamIntegrand n-dimensional real positive integrand of FOAM; TFoamMaxwt Controlling of the MC weight (maximum weight); TFoamVect n-dimensional vector with dynamical allocation; TFolder Describe a folder: a list of objects and folders; TFormula The formula base class f(x,y,z,par); TFormulaPrimitive The primitive formula ; TFractionFitter Fits MC fractions to data histogram; TFrame Pad graphics frame; TFrameEditor editor of TFrame objects; TFree Description of free segments on a file; TFriendElement A friend element of another TTree; TFumili The FUMILI Minimization package; TFumiliMinimizer Implementation of Minimizer interface using TFumili ; TFunction Dictionary for global function; TFunctionParametersDialog Function parameters dialog; TG16ColorSelector 16 color cells; TG4RootNavMgr Class crreating a G4Navigator based on ROOT geometry; TGApplication GUI application singleton; TGButton Button widget abstract base class; TG",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ClassIndex.html:68501,adapt,adapting,68501,root/html526/ClassIndex.html,https://root.cern,https://root.cern/root/html526/ClassIndex.html,1,['adapt'],['adapting']
Energy Efficiency,"CVariableNormalizeTransformLinear interpolation class ;  CVariablePCATransformLinear interpolation class ;  CVariableRearrangeTransformRearrangement of input variables ;  CVariableTransformBaseLinear interpolation class ;  CVarTransformHandler;  CVolumeVolume for BinarySearchTree ;  ►NTStreamerInfoActions;  ►CTActionSequence;  CSequencePtr;  CTConfigurationBase class of the Configurations ;  CTConfiguredAction;  CTIDNode;  CTLoopConfigurationBase class of the Configurations for the member wise looping routines ;  CTNestedIDs;  ►Nvecgeom;  ►Nwriter;  Cwriter;  C_x3d_data_;  C_x3d_sizeof_;  CAnyCollectionProxy;  CAnyCollectionStreamer;  CBalancerInfo;  Cbasic_string_view;  ►CBidirMMapPipeBidirMMapPipe creates a bidirectional channel between the current process and a child it forks ;  CPollEntryFor poll() interface ;  CBinaryOpPolicy;  CBinomialNeymanInterval;  CBinomialProbHelper;  CColorStruct_t;  CCompareAsc;  CcompareBAasc;  CcompareBAdesc;  CCompareDesc;  CContDistFree functions adapter needed by UNURAN for onedimensional continuous distributions ;  CContextSmall helper to keep current directory context ;  CCpuInfo_t;  CDebuggingSamplerDebuggingSampler is a simple implementation of the DistributionCreator interface used for debugging ;  CDebuggingTestStatDebuggingTestStat is a simple implementation of the DistributionCreator interface used for debugging ;  CDiscrDistFree functions adapter needed by UNURAN for one-dimensional discrete distribution ;  CEvent_t;  CExceptionContext_t;  CFeldmanCousinsBinomialInterval;  CFeldmanCousinsSorter;  CFileStat_t;  CFontAttributes_t;  CFontMetrics_t;  CFoption_t;  Cfuncptr_and_voidptr_t;  CGcCache_t;  CGCValues_t;  Cgroup;  Ch1analysis;  Ch1analysisTreeReader;  Chash< std::experimental::basic_string_view< _CharT, _Traits > >;  CHelperOps;  CHEPEVT_DEFHEPEVT common block ;  CHit;  CHoption_tHistogram option structure ;  CHparam_tHistogram parameters structure ;  CJet;  CJetEvent;  CMemInfo_t;  Cmg_callbacks;  Cmg_client_options",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/annotated.html:88227,adapt,adapter,88227,doc/v612/annotated.html,https://root.cern,https://root.cern/doc/v612/annotated.html,1,['adapt'],['adapter']
Energy Efficiency,"Calculates the Normalized Cross Product of two vectors. ;  ; Double_t TMath::NormQuantile (Double_t p);  Computes quantiles for standard normal distribution N(0, 1) at probability p. ;  ; Bool_t TMath::Permute (Int_t n, Int_t *a);  Simple recursive algorithm to find the permutations of n natural numbers, not necessarily all distinct adapted from CERNLIB routine PERMU. ;  ; constexpr Double_t TMath::Pi ();  \( \pi\) ;  ; constexpr Double_t TMath::PiOver2 ();  \( \frac{\pi}{2} \) ;  ; constexpr Double_t TMath::PiOver4 ();  \( \frac{\pi}{4} \) ;  ; Double_t TMath::Poisson (Double_t x, Double_t par);  Computes the Poisson distribution function for (x,par). ;  ; Double_t TMath::PoissonI (Double_t x, Double_t par);  Computes the Discrete Poisson distribution function for (x,par). ;  ; Double_t TMath::Power (Double_t x, Double_t y);  Returns x raised to the power y. ;  ; Double_t TMath::Power (Double_t x, Int_t y);  Returns x raised to the power y. ;  ; LongDouble_t TMath::Power (Long64_t x, Long64_t y);  Returns x raised to the power y. ;  ; LongDouble_t TMath::Power (LongDouble_t x, Long64_t y);  Returns x raised to the power y. ;  ; LongDouble_t TMath::Power (LongDouble_t x, LongDouble_t y);  Returns x raised to the power y. ;  ; Double_t TMath::Prob (Double_t chi2, Int_t ndf);  Computation of the probability for a certain Chi-squared (chi2) and number of degrees of freedom (ndf). ;  ; constexpr Double_t TMath::Qe ();  Elementary charge in \( C \) . ;  ; constexpr Double_t TMath::QeUncertainty ();  Elementary charge uncertainty. ;  ; void TMath::Quantiles (Int_t n, Int_t nprob, Double_t *x, Double_t *quantiles, Double_t *prob, Bool_t isSorted=kTRUE, Int_t *index=nullptr, Int_t type=7);  Computes sample quantiles, corresponding to the given probabilities. ;  ; Double_t TMath::QuietNaN ();  Returns a quiet NaN as defined by IEEE 754. ;  ; constexpr Double_t TMath::R ();  Universal gas constant ( \( Na K \)) in \( J K^{-1} mol^{-1} \) ;  ; constexpr Double_t TMath::RadToDeg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMath_8h.html:15452,power,power,15452,doc/master/TMath_8h.html,https://root.cern,https://root.cern/doc/master/TMath_8h.html,1,['power'],['power']
Energy Efficiency,"Calculation of Vavilov distribution Nucl.Instr. and Meth. B47(1990), 215-224; Accuracy: quote from the reference above:; ""The results of our code have been compared with the values of the Vavilov; density function computed numerically in an accurate way: our approximation; shows a difference of less than 3% around the peak of the density function, slowly; increasing going towards the extreme tails to the right and to the left""; For a more accurate implementation see the documentation of the Vavilov class and the cumulative ROOT::Math::vavilov_accurate_cdf ; Definition at line 2815 of file TMath.cxx. ◆ VavilovSet(). void TMath::VavilovSet ; (; Double_t ; rkappa, . Double_t ; beta2, . Bool_t ; mode, . Double_t * ; WCM, . Double_t * ; AC, . Double_t * ; HC, . Int_t & ; itype, . Int_t & ; npt . ). Internal function, called by Vavilov and VavilovI. ; Definition at line 2854 of file TMath.cxx. ◆ Voigt(). Double_t TMath::Voigt ; (; Double_t ; xx, . Double_t ; sigma, . Double_t ; lg, . Int_t ; r = 4 . ). Computation of Voigt function (normalised). ; Voigt is a convolution of the two functions: ; \[; gauss(xx) = \frac{1}{(\sqrt{2\pi} sigma)} e^{\frac{xx^{2}}{(2 sigma{^2})}}; \]. and ; \[; lorentz(xx) = \frac{ \frac{1}{\pi} \frac{lg}{2} }{ (xx^{2} + \frac{lg^{2}}{4}) }; \]. .; The Voigt function is known to be the real part of Faddeeva function also called complex error function [2].; The algorithm was developed by J. Humlicek [1]. This code is based on fortran code presented by R. J. Wells [2]. Translated and adapted by Miha D. Puc; To calculate the Faddeeva function with relative error less than 10^(-r). r can be set by the user subject to the constraints 2 <= r <= 5. [1] J. Humlicek, JQSRT, 21, 437 (1982).; [2] R.J. Wells ""Rapid Approximation to the Voigt/Faddeeva Function and its Derivatives"" JQSRT 62 (1999), pp 29-48. . Definition at line 898 of file TMath.cxx. TMath. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:29 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceTMath.html:90637,adapt,adapted,90637,doc/master/namespaceTMath.html,https://root.cern,https://root.cern/doc/master/namespaceTMath.html,1,['adapt'],['adapted']
Energy Efficiency,"Call::GetMethod ; (; ). Returns the TMethod describing the method to be executed. ; This takes all overriding and overloading into account (call TClass::GetMethod()). Since finding the method is expensive the result is cached. ; Definition at line 386 of file TMethodCall.cxx. ◆ GetMethodName(). const char * TMethodCall::GetMethodName ; (; ); const. inline . Definition at line 90 of file TMethodCall.h. ◆ GetParams(). const char * TMethodCall::GetParams ; (; ); const. inline . Definition at line 91 of file TMethodCall.h. ◆ GetProto(). const char * TMethodCall::GetProto ; (; ); const. inline . Definition at line 92 of file TMethodCall.h. ◆ Init() [1/4]. void TMethodCall::Init ; (; const char * ; function, . const char * ; params . ). Initialize the function invocation environment. ; Necessary input information: the function name and the parameter string of the form ""\""aap\"", 3, 4.35"".; To execute the method call TMethodCall::Execute(...). This two step method is much more efficient than calling for every invocation TInterpreter::Execute(...). ; Definition at line 281 of file TMethodCall.cxx. ◆ Init() [2/4]. void TMethodCall::Init ; (; const TFunction * ; func). Initialize the method invocation environment based on the TFunction object. ; Definition at line 226 of file TMethodCall.cxx. ◆ Init() [3/4]. void TMethodCall::Init ; (; TClass * ; cl, . CallFunc_t * ; func, . Longptr_t ; offset = 0 . ). Initialize the method invocation environment based on the CallFunc object and the TClass describing the function context. ; Definition at line 185 of file TMethodCall.cxx. ◆ Init() [4/4]. void TMethodCall::Init ; (; TClass * ; cl, . const char * ; method, . const char * ; params, . Bool_t ; objectIsConst = kFALSE . ). Initialize the method invocation environment. ; Necessary input information: the class, method name and the parameter string of the form ""\""aap\"", 3, 4.35"".; To execute the method call TMethodCall::Execute(object,...). This two step method is much more efficient th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMethodCall.html:23979,efficient,efficient,23979,doc/master/classTMethodCall.html,https://root.cern,https://root.cern/doc/master/classTMethodCall.html,1,['efficient'],['efficient']
Energy Efficiency,"CallFunc_t* func, Long_t offset = 0); Initialize the method invocation environment based on; the CallFunc object and the TClass describing the function context. void Init(TFunction* func); Initialize the method invocation environment based on; the TFunction object. void Init(TClass* cl, const char* method, const char* params, Bool_t objectIsConst = kFALSE); Initialize the method invocation environment. Necessary input; information: the class, method name and the parameter string; of the form ""\""aap\"", 3, 4.35"".; To execute the method call TMethodCall::Execute(object,...).; This two step method is much more efficient than calling for; every invocation TInterpreter::Execute(...). void Init(const char* function, const char* params); Initialize the function invocation environment. Necessary input; information: the function name and the parameter string of; the form ""\""aap\"", 3, 4.35"".; To execute the method call TMethodCall::Execute(...).; This two step method is much more efficient than calling for; every invocation TInterpreter::Execute(...). void InitImplementation(const char* methodname, const char* params, const char* proto, Bool_t objectIsConst, TClass* cl, const ClassInfo_t* cinfo, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch); This function implements Init and InitWithPrototype. void InitWithPrototype(TClass* cl, const char* method, const char* proto, Bool_t objectIsConst = kFALSE, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch); Initialize the method invocation environment. Necessary input; information: the class, method name and the prototype string of; the form: ""char*,int,float"".; To execute the method call TMethodCall::Execute(object,...).; This two step method is much more efficient than calling for; every invocation TInterpreter::Execute(...). void InitWithPrototype(const char* function, const char* proto, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch); Initialize the function invocation environment. Necessary input; information",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMethodCall.html:11009,efficient,efficient,11009,root/html602/TMethodCall.html,https://root.cern,https://root.cern/root/html602/TMethodCall.html,2,['efficient'],['efficient']
Energy Efficiency,"Cannot register CGI variable [%s]"",; 10985 __func__,; 10986 fmt);; 10987 return;; 10988 }; 10989 ; 10990 /* Calculate how much space is left in the buffer */; 10991 space = (env->buflen - env->bufused);; 10992 ; 10993 do {; 10994 /* Space for ""\0\0"" is always needed. */; 10995 if (space <= 2) {; 10996 /* Allocate new buffer */; 10997 n = env->buflen + CGI_ENVIRONMENT_SIZE;; 10998 added = (char *)mg_realloc_ctx(env->buf, n, env->conn->phys_ctx);; 10999 if (!added) {; 11000 /* Out of memory */; 11001 mg_cry_internal(; 11002 env->conn,; 11003 ""%s: Cannot allocate memory for CGI variable [%s]"",; 11004 __func__,; 11005 fmt);; 11006 return;; 11007 }; 11008 /* Retarget pointers */; 11009 env->buf = added;; 11010 env->buflen = n;; 11011 for (i = 0, n = 0; i < env->varused; i++) {; 11012 env->var[i] = added + n;; 11013 n += strlen(added + n) + 1;; 11014 }; 11015 space = (env->buflen - env->bufused);; 11016 }; 11017 ; 11018 /* Make a pointer to the free space int the buffer */; 11019 added = env->buf + env->bufused;; 11020 ; 11021 /* Copy VARIABLE=VALUE\0 string into the free space */; 11022 va_start(ap, fmt);; 11023 mg_vsnprintf(env->conn, &truncated, added, space - 1, fmt, ap);; 11024 va_end(ap);; 11025 ; 11026 /* Do not add truncated strings to the environment */; 11027 if (truncated) {; 11028 /* Reallocate the buffer */; 11029 space = 0;; 11030 }; 11031 } while (truncated);; 11032 ; 11033 /* Calculate number of bytes added to the environment */; 11034 n = strlen(added) + 1;; 11035 env->bufused += n;; 11036 ; 11037 /* Append a pointer to the added string into the envp array */; 11038 env->var[env->varused] = added;; 11039 env->varused++;; 11040}; 11041 ; 11042/* Return 0 on success, non-zero if an error occurs. */; 11043 ; 11044static int; 11045prepare_cgi_environment(struct mg_connection *conn,; 11046 const char *prog,; 11047 struct cgi_environment *env,; 11048 unsigned char cgi_config_idx); 11049{; 11050 const char *s;; 11051 struct vec var_vec;; 11052 char *p, src_addr[",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:316869,allocate,allocate,316869,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['allocate'],['allocate']
Energy Efficiency,"Cannot register CGI variable [%s]"",; 10986 __func__,; 10987 fmt);; 10988 return;; 10989 }; 10990 ; 10991 /* Calculate how much space is left in the buffer */; 10992 space = (env->buflen - env->bufused);; 10993 ; 10994 do {; 10995 /* Space for ""\0\0"" is always needed. */; 10996 if (space <= 2) {; 10997 /* Allocate new buffer */; 10998 n = env->buflen + CGI_ENVIRONMENT_SIZE;; 10999 added = (char *)mg_realloc_ctx(env->buf, n, env->conn->phys_ctx);; 11000 if (!added) {; 11001 /* Out of memory */; 11002 mg_cry_internal(; 11003 env->conn,; 11004 ""%s: Cannot allocate memory for CGI variable [%s]"",; 11005 __func__,; 11006 fmt);; 11007 return;; 11008 }; 11009 /* Retarget pointers */; 11010 env->buf = added;; 11011 env->buflen = n;; 11012 for (i = 0, n = 0; i < env->varused; i++) {; 11013 env->var[i] = added + n;; 11014 n += strlen(added + n) + 1;; 11015 }; 11016 space = (env->buflen - env->bufused);; 11017 }; 11018 ; 11019 /* Make a pointer to the free space int the buffer */; 11020 added = env->buf + env->bufused;; 11021 ; 11022 /* Copy VARIABLE=VALUE\0 string into the free space */; 11023 va_start(ap, fmt);; 11024 mg_vsnprintf(env->conn, &truncated, added, space - 1, fmt, ap);; 11025 va_end(ap);; 11026 ; 11027 /* Do not add truncated strings to the environment */; 11028 if (truncated) {; 11029 /* Reallocate the buffer */; 11030 space = 0;; 11031 }; 11032 } while (truncated);; 11033 ; 11034 /* Calculate number of bytes added to the environment */; 11035 n = strlen(added) + 1;; 11036 env->bufused += n;; 11037 ; 11038 /* Append a pointer to the added string into the envp array */; 11039 env->var[env->varused] = added;; 11040 env->varused++;; 11041}; 11042 ; 11043/* Return 0 on success, non-zero if an error occurs. */; 11044 ; 11045static int; 11046prepare_cgi_environment(struct mg_connection *conn,; 11047 const char *prog,; 11048 struct cgi_environment *env,; 11049 unsigned char cgi_config_idx); 11050{; 11051 const char *s;; 11052 struct vec var_vec;; 11053 char *p, src_addr[",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:316902,allocate,allocate,316902,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['allocate'],['allocate']
Energy Efficiency,"Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Fit::BinData. class ROOT::Fit::BinData: public ROOT::Fit::FitData. Class describing the binned data sets :; vectors of x coordinates, y values and optionally error on y values and error on coordinates; The dimension of the coordinate is free; There are 4 different options:; - only coordinates and values (for binned likelihood fits) : kNoError; - coordinate, values and error on values (for normal least square fits) : kValueError; - coordinate, values, error on values and coordinates (for effective least square fits) : kCoordError; - corrdinate, values, error on coordinates and asymmettric error on valyes : kAsymError. In addition there is the option to construct Bindata copying the data in (using the DataVector class); or using pointer to external data (DataWrapper) class.; In general is found to be more efficient to copy the data.; In case of really large data sets for limiting memory consumption then the other option can be used; Specialized constructor exists for data up to 3 dimensions. When the data are copying in the number of points can be set later (or re-set) using Initialize and; the data are inserted one by one using the Add method.; It is mandatory to set the size before using the Add method. @ingroup FitData. Function Members (Methods); public:. virtual~BinData(); voidAdd(double x, double y); voidAdd(const double* x, double val); voidAdd(double x, double y, double ey); voidAdd(const double* x, double val, double eval); voidAdd(double x, double y, double ex, double ey); voidAdd(const double* x, double val, const double* ex, double eval); voidAdd(double x, double y, double ex, double eyl, double eyh); voidAdd(const double* x, double val, const double* ex, double elval, double ehval); voidAddBinUpEdge(const double* xup); ROOT::Fit::BinDataBinData(const ROOT::Fit::BinData&)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ROOT__Fit__BinData.html:1054,efficient,efficient,1054,root/html530/ROOT__Fit__BinData.html,https://root.cern,https://root.cern/root/html530/ROOT__Fit__BinData.html,5,['efficient'],['efficient']
Energy Efficiency,"Class describing current object ; Definition at line 85 of file TStorage.h. ◆ ObjectAlloc() [1/2]. void * TStorage::ObjectAlloc ; (; size_t ; sz). static . Used to allocate a TObject on the heap (via TObject::operator new()). ; Directly after this routine one can call (in the TObject ctor) TStorage::FilledByObjectAlloc() to find out if the just created object is on the heap. This technique is necessary as there is one stack per thread and we can not rely on comparison with the current stack memory position. ; Definition at line 291 of file TStorage.cxx. ◆ ObjectAlloc() [2/2]. void * TStorage::ObjectAlloc ; (; size_t ; size, . void * ; vp . ). static . Used to allocate a TObject on the heap (via TObject::operator new(size_t,void*)) in position vp. ; vp is already allocated (maybe on heap, maybe on stack) so just return. ; Definition at line 314 of file TStorage.cxx. ◆ ObjectAllocArray(). void * TStorage::ObjectAllocArray ; (; size_t ; sz). static . Used to allocate array of TObject on the heap (via TObject::operator new[]()). ; Unlike the 'singular' ObjectAlloc, we do not mark those object has being allocated on the heap as they can not be individually deleted. ; Definition at line 303 of file TStorage.cxx. ◆ ObjectDealloc() [1/2]. void TStorage::ObjectDealloc ; (; void * ; vp). static . Used to deallocate a TObject on the heap (via TObject::operator delete()). ; Definition at line 322 of file TStorage.cxx. ◆ ObjectDealloc() [2/2]. void TStorage::ObjectDealloc ; (; void * ; vp, . void * ; ptr . ). static . Used to deallocate a TObject on the heap (via TObject::operator delete(void*,void*)). ; Definition at line 331 of file TStorage.cxx. ◆ PrintStatistics(). void TStorage::PrintStatistics ; (; ). static . Print memory usage statistics. ; Definition at line 368 of file TStorage.cxx. ◆ ReAlloc(). void * TStorage::ReAlloc ; (; void * ; ovp, . size_t ; size, . size_t ; oldsize . ). static . Reallocate (i.e. ; resize) block of memory. Checks if current size is equal to olds",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTStorage.html:7925,allocate,allocate,7925,doc/master/classTStorage.html,https://root.cern,https://root.cern/doc/master/classTStorage.html,1,['allocate'],['allocate']
Energy Efficiency,"Class describing current object ; Reimplemented from TObject.; Definition at line 116 of file TGeoBranchArray.h. ◆ IsOutside(). Bool_t TGeoBranchArray::IsOutside ; (; ); const. inline . Definition at line 111 of file TGeoBranchArray.h. ◆ IsSortable(). Bool_t TGeoBranchArray::IsSortable ; (; ); const. inlineoverridevirtual . Reimplemented from TObject.; Definition at line 110 of file TGeoBranchArray.h. ◆ MakeCopy(). TGeoBranchArray * TGeoBranchArray::MakeCopy ; (; const TGeoBranchArray & ; other). static . Make a copy of a branch array at the location (if indicated) ; Definition at line 81 of file TGeoBranchArray.cxx. ◆ MakeCopyAt(). TGeoBranchArray * TGeoBranchArray::MakeCopyAt ; (; const TGeoBranchArray & ; other, . void * ; addr . ). static . Make a copy of a branch array at the location (if indicated) ; Definition at line 101 of file TGeoBranchArray.cxx. ◆ MakeInstance(). TGeoBranchArray * TGeoBranchArray::MakeInstance ; (; size_t ; maxlevel). static . Make an instance of the class which allocates the node array. ; To be released using ReleaseInstance. If addr is non-zero, the user promised that addr contains at least that many bytes: size_t needed = SizeOf(maxlevel); ; Definition at line 51 of file TGeoBranchArray.cxx. ◆ MakeInstanceAt(). TGeoBranchArray * TGeoBranchArray::MakeInstanceAt ; (; size_t ; maxlevel, . void * ; addr . ). static . Make an instance of the class which allocates the node array. ; To be released using ReleaseInstance. If addr is non-zero, the user promised that addr contains at least that many bytes: size_t needed = SizeOf(maxlevel); ; Definition at line 69 of file TGeoBranchArray.cxx. ◆ operator!=(). Bool_t TGeoBranchArray::operator!= ; (; const TGeoBranchArray & ; other); const. Not equal operator. ; Definition at line 219 of file TGeoBranchArray.cxx. ◆ operator<(). Bool_t TGeoBranchArray::operator< ; (; const TGeoBranchArray & ; other); const. Is equal operator. ; Definition at line 241 of file TGeoBranchArray.cxx. ◆ operator<=(). Bool_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoBranchArray.html:19687,allocate,allocates,19687,doc/master/classTGeoBranchArray.html,https://root.cern,https://root.cern/doc/master/classTGeoBranchArray.html,1,['allocate'],['allocates']
Energy Efficiency,"ClassInfo_t* cinfo, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch); This function implements Init and InitWithPrototype. void InitWithPrototype(TClass* cl, const char* method, const char* proto, Bool_t objectIsConst = kFALSE, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch); Initialize the method invocation environment. Necessary input; information: the class, method name and the prototype string of; the form: ""char*,int,float"".; To execute the method call TMethodCall::Execute(object,...).; This two step method is much more efficient than calling for; every invocation TInterpreter::Execute(...). void InitWithPrototype(const char* function, const char* proto, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch); Initialize the function invocation environment. Necessary input; information: the function name and the prototype string of; the form: ""char*,int,float"".; To execute the method call TMethodCall::Execute(...).; This two step method is much more efficient than calling for; every invocation TInterpreter::Execute(...). Bool_t IsValid() const; Return true if the method call has been properly initialized and is; usable. TFunction * GetMethod(); Returns the TMethod describing the method to be executed. This takes; all overriding and overloading into account (call TClass::GetMethod()).; Since finding the method is expensive the result is cached. void Execute(void* object); Execute the method (with preset arguments) for the specified object. void Execute(void* object, const char* params); Execute the method for the specified object and argument values. void Execute(void* object, Long_t& retLong); Execute the method (with preset arguments) for the specified object. void Execute(void* object, const char* params, Long_t& retLong); Execute the method for the specified object and argument values. void Execute(void* object, Double_t& retDouble); Execute the method (with preset arguments) for the specified object. void Execute(void* object, const char* par",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMethodCall.html:12193,efficient,efficient,12193,root/html602/TMethodCall.html,https://root.cern,https://root.cern/root/html602/TMethodCall.html,2,['efficient'],['efficient']
Energy Efficiency,"ClassRef is used to implement a permanent reference to a TClass object.Definition TClassRef.h:28; TClassRef::GetClassTClass * GetClass() constDefinition TClassRef.h:66; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClass::NewArrayvoid * NewArray(Long_t nElements, ENewType defConstructor=kClassNew) constReturn a pointer to a newly allocated array of objects of this class.Definition TClass.cxx:5260; TClass::Newvoid * New(ENewType defConstructor=kClassNew, Bool_t quiet=kFALSE) constReturn a pointer to a newly allocated object of this class.Definition TClass.cxx:5045; TClass::Destructorvoid Destructor(void *obj, Bool_t dtorOnly=kFALSE)Explicitly call destructor for object.Definition TClass.cxx:5467; TClass::DeleteArrayvoid DeleteArray(void *ary, Bool_t dtorOnly=kFALSE)Explicitly call operator delete[] for an array.Definition TClass.cxx:5596; TClass::NewObjectArrayObjectPtr NewObjectArray(Long_t nElements, ENewType defConstructor=kClassNew) constReturn a pointer to a newly allocated array of objects of this class.Definition TClass.cxx:5276; TClass::NewObjectObjectPtr NewObject(ENewType defConstructor=kClassNew, Bool_t quiet=kFALSE) constDefinition TClass.cxx:5059; TStreamerInfoActions::TActionSequenceDefinition TStreamerInfoActions.h:177; TVirtualCollectionProxy::TPushPopRAII helper class that ensures that PushProxy() / PopProxy() are called when entering / leaving a C++...Definition TVirtualCollectionProxy.h:75; TVirtualCollectionProxy::TPushPop::operator=TPushPop & operator=(const TPushPop &)=delete; TVirtualCollectionProxy::TPushPop::TPushPopTPushPop(const TPushPop &)=delete; TVirtualCollectionProxy::TPushPop::TPushPopTPushPop(TVirtualCollectionProxy *proxy, void *objectstart)Definition TVirtualCollectionProxy.h:78; TVirtualCollectionProxy::TPushPop::fProxyTVirtualCollectionProxy * fProxyDefinition TVirtualCollectionProxy.h:77; TVirtualCollectionProxy::TPushPop::~TPushPop~TPushPop()Definition TVirtual",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TVirtualCollectionProxy_8h_source.html:15142,allocate,allocated,15142,doc/master/TVirtualCollectionProxy_8h_source.html,https://root.cern,https://root.cern/doc/master/TVirtualCollectionProxy_8h_source.html,1,['allocate'],['allocated']
Energy Efficiency,"Cleanups) to avoid the unnecessary call to; 945 // this RecursiveRemove while we delete our content.; 946 ROOT::CallRecursiveRemoveIfNeeded(*this);; 947 ResetBit(kMustCleanup); // Don't redo it.; 948 ; 949 // We don't own the leaves in fLeaves, the branches do.; 950 fLeaves.Clear();; 951 // I'm ready to destroy any objects allocated by; 952 // SetAddress() by my branches. If I have clones,; 953 // tell them to zero their pointers to this shared; 954 // memory.; 955 if (fClones && fClones->GetEntries()) {; 956 // I have clones.; 957 // I am about to delete the objects created by; 958 // SetAddress() which we are sharing, so tell; 959 // the clones to release their pointers to them.; 960 for (TObjLink* lnk = fClones->FirstLink(); lnk; lnk = lnk->Next()) {; 961 TTree* clone = (TTree*) lnk->GetObject();; 962 // clone->ResetBranchAddresses();; 963 ; 964 // Reset only the branch we have set the address of.; 965 CopyAddresses(clone,true);; 966 }; 967 }; 968 // Get rid of our branches, note that this will also release; 969 // any memory allocated by TBranchElement::SetAddress().; 970 fBranches.Delete();; 971 ; 972 // The TBranch destructor is using fDirectory to detect whether it; 973 // owns the TFile that contains its data (See TBranch::~TBranch); 974 fDirectory = nullptr;; 975 ; 976 // FIXME: We must consider what to do with the reset of these if we are a clone.; 977 delete fPlayer;; 978 fPlayer = nullptr;; 979 if (fExternalFriends) {; 980 using namespace ROOT::Detail;; 981 for(auto fetree : TRangeStaticCast<TFriendElement>(*fExternalFriends)); 982 fetree->Reset();; 983 fExternalFriends->Clear(""nodelete"");; 984 SafeDelete(fExternalFriends);; 985 }; 986 if (fFriends) {; 987 fFriends->Delete();; 988 delete fFriends;; 989 fFriends = nullptr;; 990 }; 991 if (fAliases) {; 992 fAliases->Delete();; 993 delete fAliases;; 994 fAliases = nullptr;; 995 }; 996 if (fUserInfo) {; 997 fUserInfo->Delete();; 998 delete fUserInfo;; 999 fUserInfo = nullptr;; 1000 }; 1001 if (fClones) {; 10",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:35116,allocate,allocated,35116,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['allocate'],['allocated']
Energy Efficiency,"ClonesArray allows you to ""reuse"" the same portion of memory for new/delete avoiding memory fragmentation and memory growth and improving the performance by orders of magnitude. Every time the memory of the TClonesArray has to be reused, the Clear() method is used. To provide its benefits, each TClonesArray must be allocated once per process and disposed of (deleted) only when not needed any more.; So a job should see only one deletion for each TClonesArray, which should be Clear()ed during the job several times. Deleting a TClonesArray is a double waste. Not only you do not avoid memory fragmentation, but you worsen it because the TClonesArray itself is a rather heavy structure, and there is quite some code in the destructor, so you have more memory fragmentation and slower code. NOTE 2; When investigating misuse of TClonesArray, please make sure of the following:. Use Clear() or Clear(""C"") instead of Delete(). This will improve program execution time.; TClonesArray object classes containing pointers allocate memory. To avoid causing memory leaks, special Clear(""C"") must be used for clearing TClonesArray. When option ""C"" is specified, ROOT automatically executes the Clear() method (by default it is empty contained in TObject). This method must be overridden in the relevant TClonesArray object class, implementing the reset procedure for pointer objects.; If the objects are added using the placement new then the Clear must deallocate the memory.; If the objects are added using TClonesArray::ConstructedAt then the heap-based memory can stay allocated and reused as the constructor is not called for already constructed/added object.; To reduce memory fragmentation, please make sure that the TClonesArrays are not destroyed and created on every event. They must only be constructed/destructed at the beginning/end of the run. . Definition at line 29 of file TClonesArray.h. Public Types; enum  EStatusBits { kBypassStreamer = (1ULL << ( 12 )); , kForgetBits = (1ULL << ( 15 ))",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClonesArray.html:4146,allocate,allocate,4146,doc/master/classTClonesArray.html,https://root.cern,https://root.cern/doc/master/classTClonesArray.html,1,['allocate'],['allocate']
Energy Efficiency,"Color ; (; Colormap ; cmap, . RXColor * ; color . ). protected . Allocate color in colormap. ; If we are on an <= 8 plane machine we will use XAllocColor. If we are on a >= 15 (15, 16 or 24) plane true color machine we will calculate the pixel value using: for 15 and 16 bit true colors have 6 bits precision per color however only the 5 most significant bits are used in the color index. Except for 16 bits where green uses all 6 bits. I.e.: 15 bits = rrrrrgggggbbbbb; 16 bits = rrrrrggggggbbbbb; for 24 bits each r, g and b are represented by 8 bits.; Since all colors are set with a max of 65535 (16 bits) per r, g, b we just right shift them by 10, 11 and 10 bits for 16 planes, and (10, 10, 10 for 15 planes) and by 8 bits for 24 planes. Returns kFALSE in case color allocation failed. ; Definition at line 366 of file TGX11.cxx. ◆ AllocColor() [2/2]. Bool_t TGX11::AllocColor ; (; Colormap_t ; cmap, . ColorStruct_t & ; color . ). overridevirtual . Find and allocate a color cell according to the color values specified in the ColorStruct_t. ; If no cell could be allocated it returns kFALSE, otherwise kTRUE. ; Reimplemented from TVirtualX.; Definition at line 1351 of file GX11Gui.cxx. ◆ Bell(). void TGX11::Bell ; (; Int_t ; percent). overridevirtual . Sound bell. Percent is loudness from -100% .. 100%. ; Reimplemented from TVirtualX.; Definition at line 1675 of file GX11Gui.cxx. ◆ ChangeActivePointerGrab(). void TGX11::ChangeActivePointerGrab ; (; Window_t ; , . UInt_t ; mask, . Cursor_t ; cur . ). overridevirtual . Changes the specified dynamic parameters if the pointer is actively grabbed by the client. ; Reimplemented from TVirtualX.; Definition at line 2718 of file GX11Gui.cxx. ◆ ChangeGC(). void TGX11::ChangeGC ; (; GContext_t ; gc, . GCValues_t * ; gval . ). overridevirtual . Change entries in an existing graphics context, gc, by values from gval. ; Reimplemented from TVirtualX.; Definition at line 993 of file GX11Gui.cxx. ◆ ChangeProperties(). void TGX11::ChangeProperti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGX11.html:55134,allocate,allocate,55134,doc/master/classTGX11.html,https://root.cern,https://root.cern/doc/master/classTGX11.html,1,['allocate'],['allocate']
Energy Efficiency,"Commit()));; 992 }; 993 lines.emplace_back(TString::Format(""With %s"",; 994 gSystem->GetBuildCompilerVersionStr()));; 995 lines.emplace_back(""Binary directory: ""+ gROOT->GetBinDir());; 996 lines.emplace_back(""```"");; 997 TString setup = """";; 998 for (auto& line : lines) {; 999 setup.Append(line);; 1000 setup.Append('\n');; 1001 }; 1002 setup.Chop(); // trim final `\n`; 1003 return setup;; 1004}; 1005 ; 1006////////////////////////////////////////////////////////////////////////////////; 1007/// It opens a Forum topic in a web browser with prefilled ROOT version; 1008///; 1009/// \param[in] type the issue type (only bug supported right now); 1010 ; 1011void TApplication::OpenForumTopic(const TString &type); 1012{; 1013 // https://meta.discourse.org/t/how-to-create-a-post-clicking-a-link/96197; 1014 ; 1015 if (type == ""bug"") {; 1016 //OpenInBrowser(""\""https://root-forum.cern.ch/new-topic?title=topic%20title&body=topic%20body&category=category/subcategory&tags=email,planned\"""");; 1017 TString report_template =; 1018R""(___; 1019_Please read [tips for efficient and successful posting](https://root-forum.cern.ch/t/tips-for-efficient-and-successful-posting/28292) and [posting code](https://root-forum.cern.ch/t/posting-code-read-this-first/28293)_; 1020 ; 1021### Describe the bug; 1022<!--; 1023A clear and concise description of what the wrong behavior is.; 1024-->; 1025### Expected behavior; 1026<!--; 1027A clear and concise description of what you expected to happen.; 1028-->; 1029 ; 1030### To Reproduce; 1031<!--; 1032Steps to reproduce the behavior:; 10331. Your code that triggers the issue: at least a part; ideally something we can run ourselves.; 10342. Don't forget to attach the required input files!; 10353. How to run your code and / or build it, e.g. `root myMacro.C`, ...; 1036-->; 1037 ; 1038### Setup; 1039)""+GetSetup()+; 1040R""(; 1041<!--; 1042Please specify also how you obtained ROOT, such as `dnf install` / binary download / you built it yourself.; 1043-->; 1044",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TApplication_8cxx_source.html:38862,efficient,efficient,38862,doc/master/TApplication_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html,1,['efficient'],['efficient']
Energy Efficiency,"Computes the numerical derivative of a function f at a point x using an adaptive central difference algorithm with a step size h. ; Definition at line 81 of file GSLDerivator.cxx. ◆ EvalCentral() [2/2]. double ROOT::Math::GSLDerivator::EvalCentral ; (; double ; x, . double ; h . ). Computes the numerical derivative at a point x using an adaptive central difference algorithm with a step size h. ; Definition at line 47 of file GSLDerivator.cxx. ◆ EvalForward() [1/2]. double ROOT::Math::GSLDerivator::EvalForward ; (; const IGenFunction & ; f, . double ; x, . double ; h . ). static . Computes the numerical derivative of a function f at a point x using an adaptive forward difference algorithm with a step size h. ; The function is evaluated only at points greater than x and at x itself ; Definition at line 90 of file GSLDerivator.cxx. ◆ EvalForward() [2/2]. double ROOT::Math::GSLDerivator::EvalForward ; (; double ; x, . double ; h . ). Computes the numerical derivative at a point x using an adaptive forward difference algorithm with a step size h. ; The function is evaluated only at points greater than x and at x itself. ; Definition at line 58 of file GSLDerivator.cxx. ◆ Result(). double ROOT::Math::GSLDerivator::Result ; (; ); const. return the result of the last derivative calculation ; Definition at line 109 of file GSLDerivator.cxx. ◆ SetFunction() [1/2]. void ROOT::Math::GSLDerivator::SetFunction ; (; const IGenFunction & ; f). Set the function for calculating the derivatives. ; The function must implement the ROOT::Math::IGenFunction signature ; Definition at line 123 of file GSLDerivator.cxx. ◆ SetFunction() [2/2]. void ROOT::Math::GSLDerivator::SetFunction ; (; GSLFuncPointer ; f, . void * ; p = nullptr . ). Set the function f for evaluating the derivative using a GSL function pointer type. ; Parameters. f: free function pointer of the GSL required type ; p: pointer to the object carrying the function state (for example the function object itself) . Definition at",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1GSLDerivator.html:5157,adapt,adaptive,5157,doc/master/classROOT_1_1Math_1_1GSLDerivator.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1GSLDerivator.html,1,['adapt'],['adaptive']
Energy Efficiency,"Constructor with RooAbsRealLValue variable and RooAbsReal slope and offset. RooLinearVar(const RooLinearVar& other, const char* name = 0); Copy constructor. ~RooLinearVar(); Destructor. Double_t evaluate() const; Calculate current value of this object. void setVal(Double_t value); Assign given value to linear transformation: sets input variable to (value-offset)/slope; If slope is zerom an error message is printed and no assignment is made. Bool_t isJacobianOK(const RooArgSet& depList) const; Returns true if Jacobian term associated with current; expression tree is indeed constant. Double_t jacobian() const; Return value of Jacobian associated with the transformation. Bool_t readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Read object contents from stream. void writeToStream(ostream& os, Bool_t compact) const; Write object contents to stream. RooAbsBinning& getBinning(const char* name = 0, Bool_t verbose = kTRUE, Bool_t createOnTheFly = kFALSE); Retrieve binning of this linear transformation. A RooLinearVar does not have its own; binnings but uses linearly transformed binnings of teh input variable. If a given; binning exists on the input variable, it will also exists on this linear transformation; and a binning adaptor object is created on the fly. const RooAbsBinning& getBinning(const char* name = 0, Bool_t verbose = kTRUE, Bool_t createOnTheFly = kFALSE) const; Const version of getBinning(). Bool_t hasBinning(const char* name) const; Returns true if binning with given name exists.If a given binning; exists on the input variable, it will also exists on this linear; transformation. RooLinearVar(); Constructors, assignment etc. {}. TObject* clone(const char* newname) const; { return new RooLinearVar(*this,newname); }. » Last changed: Thu Nov 3 20:08:31 2011 » Last generated: 2011-11-03 20:08; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooLinearVar.html:39984,adapt,adaptor,39984,root/html532/RooLinearVar.html,https://root.cern,https://root.cern/root/html532/RooLinearVar.html,1,['adapt'],['adaptor']
Energy Efficiency,"Context ; (; const RooArgSet & ; vars, . const RooDataSet * ; prototype = nullptr, . const RooArgSet * ; auxProto = nullptr, . bool ; verbose = false . ); const. overrideprotectedvirtual . Create appropriate generator context for this convolution. ; If both input p.d.f.s support internal generation, if it is safe to use them and if no observables other than the convolution observable are requested for generation, use the specialized convolution generator context which implements a smearing strategy in the convolution observable. If not return the regular accept/reject generator context ; Reimplemented from RooAbsPdf.; Definition at line 864 of file RooFFTConvPdf.cxx. ◆ getMaxVal(). Int_t RooFFTConvPdf::getMaxVal ; (; const RooArgSet & ; vars); const. inlineoverridevirtual . Advertise capability to determine maximum value of function for given set of observables. ; If no direct generator method is provided, this information will assist the accept/reject generator to operate more efficiently as it can skip the initial trial sampling phase to empirically find the function maximum ; Reimplemented from RooAbsReal.; Definition at line 61 of file RooFFTConvPdf.h. ◆ histNameSuffix(). TString RooFFTConvPdf::histNameSuffix ; (; ); const. overrideprotectedvirtual . Suffix for cache histogram (added in addition to suffix for cache name) ; Reimplemented from RooAbsCachedPdf.; Definition at line 448 of file RooFFTConvPdf.cxx. ◆ inputBaseName(). const char * RooFFTConvPdf::inputBaseName ; (; ); const. overrideprotectedvirtual . Return base name component for cache components in this case 'PDF1_CONV_PDF2'. ; Implements RooAbsCachedPdf.; Definition at line 327 of file RooFFTConvPdf.cxx. ◆ IsA(). TClass * RooFFTConvPdf::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from RooAbsCachedPdf.; Definition at line 124 of file RooFFTConvPdf.h. ◆ maxVal(). double RooFFTConvPdf::maxVal ; (; Int_t ; code); const. inlineoverridevirtual . Return",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooFFTConvPdf.html:91937,efficient,efficiently,91937,doc/master/classRooFFTConvPdf.html,https://root.cern,https://root.cern/doc/master/classRooFFTConvPdf.html,1,['efficient'],['efficiently']
Energy Efficiency,"CreateIterators_t GetFunctionCreateIterators(Bool_t read = kTRUE); Set of functions to iterate easily throught the collection. CopyIterator_t GetFunctionCopyIterator(Bool_t read = kTRUE); typedef void (*CreateIterators_t)(void *collection, void **begin_arena, void **end_arena);; begin_arena and end_arena should contain the location of a memory arena of size fgIteratorSize.; If the collection iterator are of that size or less, the iterators will be constructed in place in those location (new with placement); Otherwise the iterators will be allocated via a regular new and their address returned by modifying the value of begin_arena and end_arena. Next_t GetFunctionNext(Bool_t read = kTRUE); typedef void* (*CopyIterator_t)(void *dest, const void *source);; Copy the iterator source, into dest. dest should contain the location of a memory arena of size fgIteratorSize.; If the collection iterator is of that size or less, the iterator will be constructed in place in this location (new with placement); Otherwise the iterator will be allocated via a regular new and its address returned by modifying the value of dest. DeleteIterator_t GetFunctionDeleteIterator(Bool_t read = kTRUE); typedef void* (*Next_t)(void *iter, const void *end);; iter and end should be pointers to respectively an iterator to be incremented and the result of collection.end(); If the iterator has not reached the end of the collection, 'Next' increment the iterator 'iter' and return 0 if; the iterator reached the end.; If the end was not reached, 'Next' returns the address of the content pointed to by the iterator before the; incrementation ; if the collection contains pointers, 'Next' will return the value of the pointer. DeleteTwoIterators_t GetFunctionDeleteTwoIterators(Bool_t read = kTRUE); typedef void (*DeleteIterator_t)(void *iter);; typedef void (*DeleteTwoIterators_t)(void *begin, void *end);; If the size of the iterator is greater than fgIteratorArenaSize, call delete on the addresses,; Otherwise",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGenCollectionProxy.html:9494,allocate,allocated,9494,root/html528/TGenCollectionProxy.html,https://root.cern,https://root.cern/root/html528/TGenCollectionProxy.html,3,['allocate'],['allocated']
Energy Efficiency,"CreateVar(). string RooFactoryWSTool::processCreateVar ; (; std::string & ; func, . std::vector< std::string > & ; args . ). protected . Glue function between high-level syntax and low-level factory call to createVariable: Process a parsed call to create a variable named func ; If initial token is non-numeric, a RooCategory will be created, and the args are interpreted as either state names or name=id assignments. Otherwise a RooRealvar is created and the arg list is interpreted as follows:; If list has two args, these are interpreted as xmin,xmax; If list has three args, these are interpreted as xinit,xmin,xmax; If list has one arg, this is interpreted as xinit and the variable is set as constant . Definition at line 1267 of file RooFactoryWSTool.cxx. ◆ processExpression(). std::string RooFactoryWSTool::processExpression ; (; const char * ; token). Process a single high-level expression or list of expressions. ; The returned string a the reduced expression where all inline object creations have been executed and substituted with the name of the created object. e.g. RooGaussian::g(x,m,s) --> g; e.g. {x(-10,10),s} --> {x,s} . Definition at line 882 of file RooFactoryWSTool.cxx. ◆ processListExpression(). string RooFactoryWSTool::processListExpression ; (; const char * ; arg). protected . Process a list of high-level expression. ; The returned string a the reduced expression list where all inline object creations have been executed and substituted with the name of the created object. E.g. {x(-10,10),s} --> {x,s} . Definition at line 1118 of file RooFactoryWSTool.cxx. ◆ processMetaArg(). std::string RooFactoryWSTool::processMetaArg ; (; std::string & ; func, . std::vector< std::string > & ; args . ). protected . Concatenate list of args into comma separated string. ; Definition at line 1385 of file RooFactoryWSTool.cxx. ◆ processSingleExpression(). std::string RooFactoryWSTool::processSingleExpression ; (; const char * ; arg). protected . Process a single high-level exp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooFactoryWSTool.html:39956,reduce,reduced,39956,doc/master/classRooFactoryWSTool.html,https://root.cern,https://root.cern/doc/master/classRooFactoryWSTool.html,1,['reduce'],['reduced']
Energy Efficiency,"Current coordinate; Double_t_xmax! Upper integration bound; Double_t_xmin! Lower integration bound. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void registerIntegrator(RooNumIntFactory& fact); Register this class with RooNumIntConfig as a possible choice of numeric; integrator for one-dimensional integrals over finite and infinite domains. RooAdaptiveGaussKronrodIntegrator1D(); coverity[UNINIT_CTOR]; Default constructor. RooAdaptiveGaussKronrodIntegrator1D(const RooAbsFunc& function, const RooNumIntConfig& config); Constructor taking a function binding and a configuration object. RooAdaptiveGaussKronrodIntegrator1D(const RooAbsFunc& function, Double_t xmin, Double_t xmax, const RooNumIntConfig& config); Constructor taking a function binding, an integration range and a configuration object. RooAbsIntegrator* clone(const RooAbsFunc& function, const RooNumIntConfig& config) const; Virtual constructor. Bool_t initialize(); Initialize integrator allocate buffers and setup GSL workspace. ~RooAdaptiveGaussKronrodIntegrator1D(); Destructor. Bool_t setLimits(Double_t* xmin, Double_t* xmax); Change our integration limits. Return kTRUE if the new limits are; ok, or otherwise kFALSE. Always returns kFALSE and does nothing; if this object was constructed to always use our integrand's limits. Bool_t checkLimits() const; Check that our integration range is finite and otherwise return kFALSE.; Update the limits from the integrand if requested. Double_t integral(const Double_t* yvec = 0); Calculate and return integral at at given parameter values. RooAdaptiveGaussKronrodIntegrator1D(); Constructors, assignment etc. Bool_t setUseIntegrandLimits(Bool_t flag); If flag is true, intergration limits are taken from definition in input function binding. Bool_t canIntegrate1D() const; We can integrate 1-dimensional functions. Bool_t canIntegrate2D() const; We can not integrate 2-dimensional functions. Bool_t canIntegrateND() const; We can not int",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooAdaptiveGaussKronrodIntegrator1D.html:9036,allocate,allocate,9036,root/html530/RooAdaptiveGaussKronrodIntegrator1D.html,https://root.cern,https://root.cern/root/html530/RooAdaptiveGaussKronrodIntegrator1D.html,5,['allocate'],['allocate']
Energy Efficiency,"Cws->fDrawing on the window gCws->fWindow; if the double buffer is on. void Warp(Int_t ix, Int_t iy, Window_t id = 0); Set pointer position.; ix : New X coordinate of pointer; iy : New Y coordinate of pointer; Coordinates are relative to the origin of the window id; or to the origin of the current window if id == 0. void WritePixmap(Int_t wid, UInt_t w, UInt_t h, char* pxname); Write the pixmap wid in the bitmap file pxname.; wid : Pixmap address; w,h : Width and height of the pixmap.; lenname : pixmap name length; pxname : pixmap name. void ImgPickPalette(RXImage* image, Int_t& ncol, Int_t*& R, Int_t*& G, Int_t*& B); Returns in R G B the ncol colors of the palette used by the image.; The image pixels are changed to index values in these R G B arrays.; This produces a colormap with only the used colors (so even on displays; with more than 8 planes we will be able to create GIF's when the image; contains no more than 256 different colors). If it does contain more; colors we will have to use GIFquantize to reduce the number of colors.; The R G B arrays must be deleted by the caller. Int_t WriteGIF(char* name); Writes the current window into GIF file. Returns 1 in case of success,; 0 otherwise. void PutImage(Int_t offset, Int_t itran, Int_t x0, Int_t y0, Int_t nx, Int_t ny, Int_t xmin, Int_t ymin, Int_t xmax, Int_t ymax, UChar_t* image, Drawable_t id); Draw image. Pixmap_t ReadGIF(Int_t x0, Int_t y0, const char* file, Window_t id = 0); If id is NULL - loads the specified gif file at position [x0,y0] in the; current window. Otherwise creates pixmap from gif file. unsigned char * GetColorBits(Drawable_t wid, Int_t x = 0, Int_t y = 0, UInt_t w = 0, UInt_t h = 0); Returns an array of pixels created from a part of drawable (defined by x, y, w, h); in format:; b1, g1, r1, 0, b2, g2, r2, 0 ... bn, gn, rn, 0 .. Pixels are numbered from left to right and from top to bottom.; By default all pixels from the whole drawable are returned. Note that return array is 32-bit aligned. Pi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGX11.html:38764,reduce,reduce,38764,root/html602/TGX11.html,https://root.cern,https://root.cern/root/html602/TGX11.html,2,['reduce'],['reduce']
Energy Efficiency,"D &, TEveVectorD &out);  Get closest point on line defined with vector p0 and u. ;  ; void ClosestPointFromVertexToLineSegment (const TEveVectorD &v, const TEveVectorD &s, const TEveVectorD &r, Double_t rMagInv, TEveVectorD &c);  Get closest point from given vertex v to line segment defined with s and r. ;  ; Bool_t HelixIntersectPlane (const TEveVectorD &p, const TEveVectorD &point, const TEveVectorD &normal, TEveVectorD &itsect);  Intersect helix with a plane. ;  ; Bool_t LineIntersectPlane (const TEveVectorD &p, const TEveVectorD &point, const TEveVectorD &normal, TEveVectorD &itsect);  Intersect line with a plane. ;  ; void LineToBounds (TEveVectorD &p);  Propagate neutral particle with momentum p to bounds. ;  ; Bool_t LineToVertex (TEveVectorD &v);  Propagate neutral particle to vertex v. ;  ; void LoopToBounds (TEveVectorD &p);  Propagate charged particle with momentum p to bounds. ;  ; Bool_t LoopToLineSegment (const TEveVectorD &s, const TEveVectorD &r, TEveVectorD &p);  Propagate charged particle with momentum p to line segment with point s and vector r to the second point. ;  ; Bool_t LoopToVertex (TEveVectorD &v, TEveVectorD &p);  Propagate charged particle with momentum p to vertex v. ;  ; Bool_t PointOverVertex (const TEveVector4D &v0, const TEveVector4D &v, Double_t *p=nullptr);  ; void RebuildTracks ();  Rebuild all tracks using this render-style. ;  ; void Step (const TEveVector4D &v, const TEveVectorD &p, TEveVector4D &vOut, TEveVectorD &pOut);  Wrapper to step helix. ;  ; void StepRungeKutta (Double_t step, Double_t *vect, Double_t *vout);  Wrapper to step with method RungeKutta. ;  ; void Update (const TEveVector4D &v, const TEveVectorD &p, Bool_t full_update=kFALSE, Bool_t enforce_max_step=kFALSE);  Update helix / B-field projection state. ;  ;  Protected Member Functions inherited from TEveElement; virtual void AnnihilateRecursively ();  Protected member function called from TEveElement::Annihilate(). ;  ; virtual void PreDeleteElement ();  Exte",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEveTrackPropagator.html:38693,charge,charged,38693,doc/master/classTEveTrackPropagator.html,https://root.cern,https://root.cern/doc/master/classTEveTrackPropagator.html,1,['charge'],['charged']
Energy Efficiency,"D globalPalettesList(0);; 41 return globalPalettesList;; 42 }; 43}; 44 ; 45static Int_t gHighestColorIndex = 0; ///< Highest color index defined; 46static Float_t gColorThreshold = -1.; ///< Color threshold used by GetColor; 47static Int_t gDefinedColors = 0; ///< Number of defined colors.; 48static Int_t gLastDefinedColors = 649; ///< Previous number of defined colors; 49 ; 50#define fgGrayscaleMode TColor__GrayScaleMode(); 51#define fgPalette TColor__Palette(); 52#define fgPalettesList TColor__PalettesList(); 53 ; 54using std::floor;; 55 ; 56/** \class TColor; 57\ingroup Base; 58\ingroup GraphicsAtt; 59 ; 60The color creation and management class.; 61 ; 62 - [Introduction](\ref C00); 63 - [Basic colors](\ref C01); 64 - [The color wheel](\ref C02); 65 - [Bright and dark colors](\ref C03); 66 - [Accessible Color Schemes](\ref C031); 67 - [Gray scale view of of canvas with colors](\ref C04); 68 - [Color palettes](\ref C05); 69 - [High quality predefined palettes](\ref C06); 70 - [Colour Vision Deficiency (CVD) friendly palettes](\ref C06a); 71 - [Non Colour Vision Deficiency (CVD) friendly palettes](\ref C06b); 72 - [Palette inversion](\ref C061); 73 - [Color transparency](\ref C07); 74 ; 75\anchor C00; 76## Introduction; 77 ; 78Colors are defined by their red, green and blue components, simply called the; 79RGB components. The colors are also known by the hue, light and saturation; 80components also known as the HLS components. When a new color is created the; 81components of both color systems are computed.; 82 ; 83At initialization time, a table of colors is generated. An existing color can; 84be retrieved by its index:; 85 ; 86~~~ {.cpp}; 87 TColor *color = gROOT->GetColor(10);; 88~~~; 89 ; 90Then it can be manipulated. For example its RGB components can be modified:; 91 ; 92~~~ {.cpp}; 93 color->SetRGB(0.1, 0.2, 0.3);; 94~~~; 95 ; 96A new color can be created the following way:; 97 ; 98~~~ {.cpp}; 99 Int_t ci = 1756; // color index; 100 auto color = new TColor(ci",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TColor_8cxx_source.html:2589,green,green,2589,doc/master/TColor_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html,1,['green'],['green']
Energy Efficiency,"D() terms that contained it; EDIT::name( orig, origNode=$REMOVE(prodname,...), ... ] -- As above, but restrict removal of origNode to PROD term(s) prodname,... Interface to RooClassFactory. CEXPR::name('expr',var,...] -- Create an custom compiled p.d.f that evaluates the given expression; cexpr::name('expr',var,...] -- Create an custom compiled function that evaluates the given expression. $MetaType(...) - Meta argument that does not result in construction of an object but is used logically organize; input arguments in certain operator p.d.f. constructions. The defined meta arguments are context dependent. The only meta argument that is defined globally is $Alias(typeName,aliasName) to; define aliases for type names. For the definition of meta arguments in operator p.d.f.s; see the definitions below. std::string processExpression(const char* expr); Process a single high-level expression or list of; expressions. The returned string a the reduced expression where; all inline object creations have been executed and substituted; with the name of the created object. e.g. 'RooGaussian::g(x,m,s)' --> 'g'; '{x(-10,10),s} --> '{x,s}'. std::string processCompositeExpression(const char* arg); Process a single composite expression. e.g. 'A=RooGaussian::g[x,m,s]' --> 'A=g'; e.g. 'f[0,1]*RooGaussian::g[x,m,s]' --> 'f*g'; e.g. 'RooGaussian::g(x,y,s)|x' --> g|x'; e.g. '$MetaArg(RooGaussian::g[x,m,s],blah)' --> '$MetaArg(g,blah)'. std::string processSingleExpression(const char* arg); Process a single high-level expression. The returned string a the reduced; expression where all inline object creations have been executed and substituted; with the name of the created object. e.g. 'RooGaussian::g(x,m,s)' --> 'g'; e.g. 'x[-10,10]' --> 'x'. string processListExpression(const char* arg); Process a list of high-level expression. The returned string a the reduced; expression list where all inline object creations have been executed and substituted; with the name of the created object. E.g. '",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooFactoryWSTool.html:17007,reduce,reduced,17007,root/html530/RooFactoryWSTool.html,https://root.cern,https://root.cern/root/html530/RooFactoryWSTool.html,5,['reduce'],['reduced']
Energy Efficiency,"D, etc. histograms c2 is an optional argument that gives a relative weight between the two histograms, and dc2 is the error on this weight. This is useful, for example, when forming an asymmetry between two histograms from 2 different data sets that need to be normalized to each other in some way. The function calculates the errors assuming Poisson statistics on h1 and h2 (that is, dh = sqrt(h)).; example: assuming 'h1' and 'h2' are already filled; h3 = h1->GetAsymmetry(h2); TH1::GetAsymmetryTH1 * GetAsymmetry(TH1 *h2, Double_t c2=1, Double_t dc2=0)Return a histogram containing the asymmetry of this histogram with h2, where the asymmetry is defined...Definition TH1.cxx:4339; then 'h3' is created and filled with the asymmetry between 'h1' and 'h2'; h1 and h2 are left intact.; Note that it is the user's responsibility to manage the created histogram. The name of the returned histogram will be Asymmetry_nameOfh1-nameOfh2; code proposed by Jason Seely (seely.nosp@m.@mit.nosp@m..edu) and adapted by R.Brun; clone the histograms so top and bottom will have the correct dimensions: Sumw2 just makes sure the errors will be computed properly when we form sums and ratios below. ; Definition at line 4339 of file TH1.cxx. ◆ GetAxisColor(). Color_t TH1::GetAxisColor ; (; Option_t * ; axis = ""X""); const. virtual . Return the number of divisions for ""axis"". ; Definition at line 40 of file Haxis.cxx. ◆ GetAxisLabelStatus(). UInt_t TH1::GetAxisLabelStatus ; (; ); const. protected . Internal function used in TH1::Fill to see which axis is full alphanumeric, i.e. ; can be extended and is alphanumeric ; Definition at line 6675 of file TH1.cxx. ◆ GetBarOffset(). virtual Float_t TH1::GetBarOffset ; (; ); const. inlinevirtual . Definition at line 256 of file TH1.h. ◆ GetBarWidth(). virtual Float_t TH1::GetBarWidth ; (; ); const. inlinevirtual . Definition at line 257 of file TH1.h. ◆ GetBin(). Int_t TH1::GetBin ; (; Int_t ; binx, . Int_t ; biny = 0, . Int_t ; binz = 0 . ); const. virtual . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH1.html:145745,adapt,adapted,145745,doc/master/classTH1.html,https://root.cern,https://root.cern/doc/master/classTH1.html,1,['adapt'],['adapted']
Energy Efficiency,"DG(); Create PDG database. Initialization of the DB has to be done via explicit; call to ReadDataBasePDG (also done by GetParticle methods). ~TDatabasePDG(); Cleanup the PDG database. TDatabasePDG* Instance(); static function. void BuildPdgMap() const; Build fPdgMap mapping pdg-code to particle. Initial size is set so as to be able to hold at least 600; particles: 521 in default table, ALICE adds 54 more.; To be revisited after LHC discovers SUSY. TParticlePDG* AddParticle(const char* Name, const char* Title, Double_t Mass, Bool_t Stable, Double_t DecayWidth, Double_t Charge, const char* ParticleClass, Int_t PdgCode, Int_t Anti = -1, Int_t TrackingCode = 0). Particle definition normal constructor. If the particle is set to be; stable, the decay width parameter does have no meaning and can be set to; any value. The parameters granularity, LowerCutOff and HighCutOff are; used for the construction of the mean free path look up tables. The; granularity will be the number of logwise energy points for which the; mean free path will be calculated. TParticlePDG* AddAntiParticle(const char* Name, Int_t PdgCode); assuming particle has already been defined. TParticlePDG * GetParticle(const char* name) const. Get a pointer to the particle object according to the name given. TParticlePDG * GetParticle(Int_t pdgCode) const. Get a pointer to the particle object according to the MC code number. void Print(Option_t* opt = """") const; Print contents of PDG database. Int_t ConvertGeant3ToPdg(Int_t Geant3Number) const; Converts Geant3 particle codes to PDG convention. (Geant4 uses; PDG convention already); Source: BaBar User Guide, Neil I. Geddes,. /*; see Conversion table; */. with some fixes by PB, marked with (PB) below. Checked against; PDG listings from 2000. Paul Balm, Nov 19, 2001. Int_t ConvertPdgToGeant3(Int_t pdgNumber) const; Converts pdg code to geant3 id. Int_t ConvertIsajetToPdg(Int_t isaNumber) const. Converts the ISAJET Particle number into the PDG MC number. void ReadPDG",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TDatabasePDG.html:8269,energy,energy,8269,root/html534/TDatabasePDG.html,https://root.cern,https://root.cern/root/html534/TDatabasePDG.html,3,['energy'],['energy']
Energy Efficiency,"DG(); Create PDG database. Initialization of the DB has to be done via explicit; call to ReadDataBasePDG (also done by GetParticle methods). ~TDatabasePDG(); Cleanup the PDG database. TDatabasePDG* Instance(); static function. void BuildPdgMap() const; Build fPdgMap mapping pdg-code to particle. Initial size is set so as to be able to hold at least 600; particles: 521 in default table, ALICE adds 54 more.; To be revisited after LHC discovers SUSY. TParticlePDG* AddParticle(const char* Name, const char* Title, Double_t Mass, Bool_t Stable, Double_t DecayWidth, Double_t Charge, const char* ParticleClass, Int_t PdgCode, Int_t Anti = -1, Int_t TrackingCode = 0). Particle definition normal constructor. If the particle is set to be; stable, the decay width parameter does have no meaning and can be set to; any value. The parameters granularity, LowerCutOff and HighCutOff are; used for the construction of the mean free path look up tables. The; granularity will be the number of logwise energy points for which the; mean free path will be calculated. TParticlePDG* AddAntiParticle(const char* Name, Int_t PdgCode); assuming particle has already been defined. TParticlePDG * GetParticle(const char* name) const. Get a pointer to the particle object according to the name given. TParticlePDG * GetParticle(Int_t pdgCode) const. Get a pointer to the particle object according to the MC code number. void Print(Option_t* opt = """") const; Print contents of PDG database. Int_t ConvertGeant3ToPdg(Int_t Geant3Number); Converts Geant3 particle codes to PDG convention. (Geant4 uses; PDG convention already); Source: BaBar User Guide, Neil I. Geddes,. /*; see Conversion table; */. with some fixes by PB, marked with (PB) below. Checked against; PDG listings from 2000. Paul Balm, Nov 19, 2001. Int_t ConvertPdgToGeant3(Int_t pdgNumber); Converts pdg code to geant3 id. Int_t ConvertIsajetToPdg(Int_t isaNumber). Converts the ISAJET Particle number into the PDG MC number. void ReadPDGTable(const char* ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TDatabasePDG.html:8163,energy,energy,8163,root/html528/TDatabasePDG.html,https://root.cern,https://root.cern/root/html528/TDatabasePDG.html,3,['energy'],['energy']
Energy Efficiency,"DNN::TCpuMatrix< AFloat >The TCpuMatrix class. ; Matrix class for multi-threaded CPU architectures. Uses the TCpuBuffer class to store the matrices in column-major format for compatibility with BLAS. Provides Map and MapFrom member functions to simplify the application of activation functions and derivatives to matrices.; Copying and assignment of TCpuMatrix objects only performs shallow copies, i.e. copying is fast and the resulting objects share the element data.; Template Parameters. AFloatThe floating point type used to represent the matrix elements. . Definition at line 86 of file CpuMatrix.h. Public Member Functions;  TCpuMatrix ();  ;  TCpuMatrix (const TCpuBuffer< AFloat > &buffer, size_t m, size_t n);  Construct a m-times-n matrix from the given buffer. ;  ;  TCpuMatrix (const TCpuMatrix &)=default;  ;  TCpuMatrix (const TMatrixT< AFloat > &);  Construct a TCpuMatrix object by (deeply) copying from a TMatrixT<Double_t> matrix. ;  ;  TCpuMatrix (size_t nRows, size_t nCols);  Construct matrix and allocate space for its elements. ;  ;  TCpuMatrix (TCpuMatrix &&)=default;  ;  ~TCpuMatrix ()=default;  ; TCpuBuffer< AFloat > & GetBuffer ();  Returns pointer to a vector holding only ones with a guaranteed length of the number of columns of every instantiated CpuMatrix object. ;  ; const TCpuBuffer< AFloat > & GetBuffer () const;  ; TCpuBuffer< AFloat > & GetDeviceBuffer ();  ; const TCpuBuffer< AFloat > & GetDeviceBuffer () const;  ; size_t GetNcols () const;  ; size_t GetNoElements () const;  ; size_t GetNrows () const;  ; AFloat * GetRawDataPointer ();  Return raw pointer to the elements stored contiguously in column-major order. ;  ; const AFloat * GetRawDataPointer () const;  ; size_t GetSize () const;  ; template<typename Function_t > ; void Map (Function_t &f);  Map the given function over the matrix elements. ;  ; template<typename Function_t > ; void MapFrom (Function_t &f, const TCpuMatrix &A);  Same as maps but takes the input values from the matrix A an",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TCpuMatrix.html:1471,allocate,allocate,1471,doc/master/classTMVA_1_1DNN_1_1TCpuMatrix.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TCpuMatrix.html,1,['allocate'],['allocate']
Energy Efficiency,"Data::createHistogram() function is pythonized with the command argument pythonization.; 129The keywords must correspond to the CmdArgs of the function.; 130 ; 131\see RooAbsData::createHistogram(const char *name, const RooAbsRealLValue& xvar, const RooCmdArg& arg1, const RooCmdArg& arg2, const RooCmdArg& arg3, const RooCmdArg& arg4, const RooCmdArg& arg5, const RooCmdArg& arg6, const RooCmdArg& arg7, const RooCmdArg& arg8) const; 132 ; 133\anchor _rooabsdata_ploton; 134### RooAbsData.plotOn; 135The RooAbsData::plotOn() function is pythonized with the command argument pythonization.; 136The keywords must correspond to the CmdArgs of the function.; 137 ; 138\see RooAbsData::plotOn(RooPlot* frame, const RooCmdArg& arg1, const RooCmdArg& arg2, const RooCmdArg& arg3, const RooCmdArg& arg4, const RooCmdArg& arg5, const RooCmdArg& arg6, const RooCmdArg& arg7, const RooCmdArg& arg8) const; 139 ; 140\anchor _rooabsdata_reduce; 141### RooAbsData.reduce; 142The RooAbsData::reduce() function is pythonized with the command argument pythonization.; 143The keywords must correspond to the CmdArgs of the function.; 144 ; 145\see RooAbsData::reduce(const RooCmdArg& arg1,const RooCmdArg& arg2, const RooCmdArg& arg3,const RooCmdArg& arg4, const RooCmdArg& arg5,const RooCmdArg& arg6, const RooCmdArg& arg7,const RooCmdArg& arg8); 146 ; 147\anchor _rooabsdata_staton; 148### RooAbsData.statOn; 149The RooAbsData::statOn() function is pythonized with the command argument pythonization.; 150The keywords must correspond to the CmdArgs of the function.; 151 ; 152\see RooAbsData::statOn(RooPlot* frame, const RooCmdArg& arg1, const RooCmdArg& arg2, const RooCmdArg& arg3, const RooCmdArg& arg4, const RooCmdArg& arg5, const RooCmdArg& arg6, const RooCmdArg& arg7, const RooCmdArg& arg8); 153 ; 154\anchor _rooabspdf; 155## RooAbsPdf; 156\see RooAbsPdf; 157 ; 158Some member functions of RooAbsPdf that take a RooCmdArg as argument also support keyword arguments.; 159So far, this applies to RooAbsPdf::f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/__roofit_8pyzdoc_source.html:6744,reduce,reduce,6744,doc/master/__roofit_8pyzdoc_source.html,https://root.cern,https://root.cern/doc/master/__roofit_8pyzdoc_source.html,2,['reduce'],['reduce']
Energy Efficiency,"DataFrame` object like so:; 693 ; 694~~~{.py}; 695import pyspark; 696import ROOT; 697 ; 698# Create a SparkContext object with the right configuration for your Spark cluster; 699conf = SparkConf().setAppName(appName).setMaster(master); 700sc = SparkContext(conf=conf); 701 ; 702# Point RDataFrame calls to the Spark specific RDataFrame; 703RDataFrame = ROOT.RDF.Experimental.Distributed.Spark.RDataFrame; 704 ; 705# The Spark RDataFrame constructor accepts an optional ""sparkcontext"" parameter; 706# and it will distribute the application to the connected cluster; 707df = RDataFrame(""mytree"", ""myfile.root"", sparkcontext = sc); 708~~~; 709 ; 710If an instance of [SparkContext](https://spark.apache.org/docs/latest/api/python/reference/api/pyspark.SparkContext.html); 711is not provided, the default behaviour is to create one in the background for you.; 712 ; 713### Connecting to a Dask cluster; 714 ; 715Similarly, you can connect to a Dask cluster by creating your own connection object which internally operates with one; 716of the cluster schedulers supported by Dask (more information in the; 717[Dask distributed docs](http://distributed.dask.org/en/stable/)):; 718 ; 719~~~{.py}; 720import ROOT; 721from dask.distributed import Client; 722 ; 723# Point RDataFrame calls to the Dask specific RDataFrame; 724RDataFrame = ROOT.RDF.Experimental.Distributed.Dask.RDataFrame; 725 ; 726# In a Python script the Dask client needs to be initalized in a context; 727# Jupyter notebooks / Python session don't need this; 728if __name__ == ""__main__"":; 729 # With an already setup cluster that exposes a Dask scheduler endpoint; 730 client = Client(""dask_scheduler.domain.com:8786""); 731 ; 732 # The Dask RDataFrame constructor accepts the Dask Client object as an optional argument; 733 df = RDataFrame(""mytree"",""myfile.root"", daskclient=client); 734 # Proceed as usual; 735 df.Define(""x"",""someoperation"").Histo1D((""name"", ""title"", 10, 0, 10), ""x""); 736~~~; 737 ; 738If an instance of [distributed.Clie",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RDataFrame_8cxx_source.html:41559,schedul,schedulers,41559,doc/v632/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/RDataFrame_8cxx_source.html,1,['schedul'],['schedulers']
Energy Efficiency,"DataFrame` object like so:; 733 ; 734~~~{.py}; 735import pyspark; 736import ROOT; 737 ; 738# Create a SparkContext object with the right configuration for your Spark cluster; 739conf = SparkConf().setAppName(appName).setMaster(master); 740sc = SparkContext(conf=conf); 741 ; 742# Point RDataFrame calls to the Spark specific RDataFrame; 743RDataFrame = ROOT.RDF.Experimental.Distributed.Spark.RDataFrame; 744 ; 745# The Spark RDataFrame constructor accepts an optional ""sparkcontext"" parameter; 746# and it will distribute the application to the connected cluster; 747df = RDataFrame(""mytree"", ""myfile.root"", sparkcontext = sc); 748~~~; 749 ; 750If an instance of [SparkContext](https://spark.apache.org/docs/latest/api/python/reference/api/pyspark.SparkContext.html); 751is not provided, the default behaviour is to create one in the background for you.; 752 ; 753### Connecting to a Dask cluster; 754 ; 755Similarly, you can connect to a Dask cluster by creating your own connection object which internally operates with one; 756of the cluster schedulers supported by Dask (more information in the; 757[Dask distributed docs](http://distributed.dask.org/en/stable/)):; 758 ; 759~~~{.py}; 760import ROOT; 761from dask.distributed import Client; 762 ; 763# Point RDataFrame calls to the Dask specific RDataFrame; 764RDataFrame = ROOT.RDF.Experimental.Distributed.Dask.RDataFrame; 765 ; 766# In a Python script the Dask client needs to be initalized in a context; 767# Jupyter notebooks / Python session don't need this; 768if __name__ == ""__main__"":; 769 # With an already setup cluster that exposes a Dask scheduler endpoint; 770 client = Client(""dask_scheduler.domain.com:8786""); 771 ; 772 # The Dask RDataFrame constructor accepts the Dask Client object as an optional argument; 773 df = RDataFrame(""mytree"",""myfile.root"", daskclient=client); 774 # Proceed as usual; 775 df.Define(""x"",""someoperation"").Histo1D((""name"", ""title"", 10, 0, 10), ""x""); 776~~~; 777 ; 778If an instance of [distributed.Clie",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDataFrame_8cxx_source.html:43199,schedul,schedulers,43199,doc/master/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RDataFrame_8cxx_source.html,1,['schedul'],['schedulers']
Energy Efficiency,"DataStore.cxx. ◆ printName(). void RooAbsDataStore::printName ; (; std::ostream & ; os); const. inlineoverridevirtual . Print name of dataset. ; Reimplemented from RooPrintable.; Definition at line 112 of file RooAbsDataStore.h. ◆ printTitle(). void RooAbsDataStore::printTitle ; (; std::ostream & ; os); const. inlineoverridevirtual . Print title of dataset. ; Reimplemented from RooPrintable.; Definition at line 114 of file RooAbsDataStore.h. ◆ printValue(). void RooAbsDataStore::printValue ; (; std::ostream & ; os); const. inlineoverridevirtual . Print value of the dataset, i.e. the sum of weights contained in the dataset. ; Reimplemented from RooPrintable.; Definition at line 118 of file RooAbsDataStore.h. ◆ recalculateCache(). virtual void RooAbsDataStore::recalculateCache ; (; const RooArgSet * ; , . Int_t ; , . Int_t ; , . Int_t ; , . bool ;  . ). inlinevirtual . Reimplemented in RooVectorDataStore, and RooCompositeDataStore.; Definition at line 132 of file RooAbsDataStore.h. ◆ reduce(). virtual std::unique_ptr< RooAbsDataStore > RooAbsDataStore::reduce ; (; RooStringView ; name, . RooStringView ; title, . const RooArgSet & ; vars, . const RooFormulaVar * ; cutVar, . const char * ; cutRange, . std::size_t ; nStart, . std::size_t ; nStop . ). pure virtual . Implemented in RooCompositeDataStore, RooTreeDataStore, and RooVectorDataStore. ◆ reset(). virtual void RooAbsDataStore::reset ; (; ). pure virtual . Implemented in RooCompositeDataStore, RooTreeDataStore, and RooVectorDataStore. ◆ resetBuffers(). virtual void RooAbsDataStore::resetBuffers ; (; ). pure virtual . Implemented in RooCompositeDataStore, RooTreeDataStore, and RooVectorDataStore. ◆ resetCache(). virtual void RooAbsDataStore::resetCache ; (; ). pure virtual . Implemented in RooCompositeDataStore, RooTreeDataStore, and RooVectorDataStore. ◆ setArgStatus(). virtual void RooAbsDataStore::setArgStatus ; (; const RooArgSet & ; set, . bool ; active . ). pure virtual . Implemented in RooCompositeDataStore, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsDataStore.html:26560,reduce,reduce,26560,doc/master/classRooAbsDataStore.html,https://root.cern,https://root.cern/doc/master/classRooAbsDataStore.html,1,['reduce'],['reduce']
Energy Efficiency,"Definition TBrowser.h:37; TBufferFileThe concrete implementation of TBuffer for writing/reading to/from a ROOT file or socket.Definition TBufferFile.h:47; TBufferBuffer base class used for serializing objects.Definition TBuffer.h:43; TBuffer::Expandvoid Expand(Int_t newsize, Bool_t copy=kTRUE)Expand (or shrink) the I/O buffer to newsize bytes.Definition TBuffer.cxx:223; TBuffer::BufferSizeInt_t BufferSize() constDefinition TBuffer.h:98; TBuffer::kWrite@ kWriteDefinition TBuffer.h:73; TBuffer::kRead@ kReadDefinition TBuffer.h:73; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClass::CanSplitBool_t CanSplit() constReturn true if the data member of this TClass can be saved separately.Definition TClass.cxx:2386; TClass::GetCollectionTypeROOT::ESTLType GetCollectionType() constReturn the 'type' of the STL the TClass is representing.Definition TClass.cxx:2953; TClass::Newvoid * New(ENewType defConstructor=kClassNew, Bool_t quiet=kFALSE) constReturn a pointer to a newly allocated object of this class.Definition TClass.cxx:5045; TClass::HasDataMemberInfoBool_t HasDataMemberInfo() constDefinition TClass.h:407; TClass::HasCustomStreamerMemberBool_t HasCustomStreamerMember() constThe class has a Streamer method and it is implemented by the user or an older (not StreamerInfo based...Definition TClass.h:508; TClass::Destructorvoid Destructor(void *obj, Bool_t dtorOnly=kFALSE)Explicitly call destructor for object.Definition TClass.cxx:5467; TClass::BuildRealDatavoid BuildRealData(void *pointer=nullptr, Bool_t isTransient=kFALSE)Build a full list of persistent data members.Definition TClass.cxx:2098; TClass::GetTypeInfoconst std::type_info * GetTypeInfo() constDefinition TClass.h:496; TClass::GetListOfDataMembersTList * GetListOfDataMembers(Bool_t load=kTRUE)Return list containing the TDataMembers of a class.Definition TClass.cxx:3837; TClass::GetListOfRealDataTList * GetListOfRealData() constDefinition TClass.h:45",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:401114,allocate,allocated,401114,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['allocate'],['allocated']
Energy Efficiency,"Definition TTree.h:130; TTree::fIMTEnabledbool fIMTEnabled! true if implicit multi-threading is enabled for this treeDefinition TTree.h:142; TTree::GetBranchStatusvirtual bool GetBranchStatus(const char *branchname) constReturn status of branch with name branchname.Definition TTree.cxx:5380; TTree::fFriendLockStatusUInt_t fFriendLockStatus! Record which method is locking the friend recursionDefinition TTree.h:137; TTree::GetLeafImplvirtual TLeaf * GetLeafImpl(const char *branchname, const char *leafname)Return pointer to the 1st Leaf named name in any Branch of this Tree or any branch in the list of fri...Definition TTree.cxx:6098; TTree::fTotBytesLong64_t fTotBytesTotal number of bytes in all branches before compression.Definition TTree.h:86; TTree::FlushBasketsvirtual Int_t FlushBaskets(bool create_cluster=true) constWrite to disk all the basket that have not yet been individually written and create an event cluster ...Definition TTree.cxx:5129; TTree::fMaxClusterRangeInt_t fMaxClusterRange! Memory allocated for the cluster range.Definition TTree.h:96; TTree::Showvirtual void Show(Long64_t entry=-1, Int_t lenmax=20)Print values of all active leaves for entry.Definition TTree.cxx:9385; TTree::fEventListTEventList * fEventList! Pointer to event selection list (if one)Definition TTree.h:125; TTree::GetAutoSavevirtual Long64_t GetAutoSave() constDefinition TTree.h:448; TTree::StopCacheLearningPhasevirtual Int_t StopCacheLearningPhase()Stop the cache learning phase.Definition TTree.cxx:9474; TTree::GetEntryvirtual Int_t GetEntry(Long64_t entry, Int_t getall=0)Read all branches of entry and return total number of bytes read.Definition TTree.cxx:5638; TTree::fSortedBranchesstd::vector< std::pair< Long64_t, TBranch * > > fSortedBranches! Branches to be processed in parallel when IMT is on, sorted by average task timeDefinition TTree.h:144; TTree::SetCircularvirtual void SetCircular(Long64_t maxEntries)Enable/Disable circularity for this tree.Definition TTree.cxx:8892; TTr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:436618,allocate,allocated,436618,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['allocate'],['allocated']
Energy Efficiency,"Definition at line 1629 of file TGHtml.cxx. ◆ GetColorByValue(). int TGHtml::GetColorByValue ; (; ColorStruct_t * ; pRef). protected . Find a color integer for the color whose color components are given by pRef. ; Definition at line 1767 of file TGHtml.cxx. ◆ GetCurrentStyle(). SHtmlStyle_t TGHtml::GetCurrentStyle ; (; ). protected . Get the current rendering style. ; In other words, get the style that is currently on the top of the style stack. ; Definition at line 41 of file TGHtmlSizer.cxx. ◆ GetDarkShadowColor(). int TGHtml::GetDarkShadowColor ; (; int ; iBgColor). protected . Given that the background color is iBgColor, figure out an appropriate color for the dark part of a 3D shadow. ; Definition at line 1692 of file TGHtml.cxx. ◆ GetFont(). TGFont * TGHtml::GetFont ; (; int ; iFont). virtual . The rendering and layout routines should call this routine in order to get a font structure. ; The iFont parameter specifies which of the N_FONT fonts should be obtained. The font is allocated if necessary. ; Definition at line 1465 of file TGHtml.cxx. ◆ GetFontName(). virtual char * TGHtml::GetFontName ; (; ). inlinevirtual . Definition at line 954 of file TGHtml.h. ◆ GetGC(). GContext_t TGHtml::GetGC ; (; int ; color, . int ; font . ). protected . Return a GC from the cache. ; As many as N_CACHE_GCs are kept valid at any one time. They are replaced using an LRU algorithm.; A value of FONT_Any (-1) for the font means ""don't care"". ; Definition at line 1047 of file TGHtml.cxx. ◆ GetHref(). const char * TGHtml::GetHref ; (; int ; x, . int ; y, . const char ** ; target = nullptr . ). This routine searches for a hyperlink beneath the coordinates x,y and returns a pointer to the HREF for that hyperlink. ; The text is held in one of the markup argv[] fields of the markup. ; Definition at line 1831 of file TGHtml.cxx. ◆ GetImage(). TGHtmlImage * TGHtml::GetImage ; (; TGHtmlImageMarkup * ; p). Given an <IMG> markup, find or create an appropriate TGHtmlImage object and return a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGHtml.html:66360,allocate,allocated,66360,doc/master/classTGHtml.html,https://root.cern,https://root.cern/doc/master/classTGHtml.html,1,['allocate'],['allocated']
Energy Efficiency,"Definition legend1.C:17; eyDouble_t ey[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; exDouble_t ex[n]Definition legend1.C:17; c2return c2Definition legend2.C:14; TMath::NintInt_t Nint(T x)Round to nearest integer. Rounds half integers to the nearest even integer.Definition TMath.h:693; TMath::MaxShort_t Max(Short_t a, Short_t b)Returns the largest of a and b.Definition TMathBase.h:250; TMath::ProbDouble_t Prob(Double_t chi2, Int_t ndf)Computation of the probability for a certain Chi-squared (chi2) and number of degrees of freedom (ndf...Definition TMath.cxx:637; TMath::IsInsideBool_t IsInside(T xp, T yp, Int_t np, T *x, T *y)Function which returns kTRUE if point xp,yp lies inside the polygon defined by the np points in array...Definition TMath.h:1233; TMath::ATanDouble_t ATan(Double_t)Returns the principal value of the arc tangent of x, expressed in radians.Definition TMath.h:640; TMath::PiOver2constexpr Double_t PiOver2()Definition TMath.h:51; TMath::SqrtDouble_t Sqrt(Double_t x)Returns the square root of x.Definition TMath.h:662; TMath::PowerLongDouble_t Power(LongDouble_t x, LongDouble_t y)Returns x raised to the power y.Definition TMath.h:721; TMath::MinShort_t Min(Short_t a, Short_t b)Returns the smallest of a and b.Definition TMathBase.h:198; TMath::CosDouble_t Cos(Double_t)Returns the cosine of an angle of x radians.Definition TMath.h:594; TMath::Piconstexpr Double_t Pi()Definition TMath.h:37; TMath::SinDouble_t Sin(Double_t)Returns the sine of an angle of x radians.Definition TMath.h:588; TMath::Log10Double_t Log10(Double_t x)Returns the common (base-10) logarithm of x.Definition TMath.h:762; TMath::AbsShort_t Abs(Short_t d)Returns the absolute value of parameter Short_t d.Definition TMathBase.h:123; arrowDefinition RArrowDS.hxx:17; lTLine lDefinition textangle.C:4; DrawMarkerm DrawMarker(0.1, 0.1). histhistpaintersrcTGraphPainter.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:35 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphPainter_8cxx_source.html:222854,power,power,222854,doc/master/TGraphPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html,1,['power'],['power']
Energy Efficiency,"Definition legend1.C:17; f1TF1 * f1Definition legend1.C:11; ROOT::Fit::FitObjectTFitResultPtr FitObject(TH1 *h1, TF1 *f1, Foption_t &option, const ROOT::Math::MinimizerOptions &moption, const char *goption, ROOT::Fit::DataRange &range)fitting function for a TH1 (called from TH1::Fit)Definition HFitImpl.cxx:972; ROOT::Fit::Chisquaredouble Chisquare(const TH1 &h1, TF1 &f1, bool useRange, EChisquareType type)compute the chi2 value for an histogram given a function (see TH1::Chisquare for the documentation)Definition HFitImpl.cxx:1027; ROOT::Fit::FitOptionsMakevoid FitOptionsMake(EFitObjectType type, const char *option, Foption_t &fitOption)Decode list of options into fitOption.Definition HFitImpl.cxx:685; ROOT::Fit::EFitObjectType::kGraph@ kGraph; TMath::IsInsideBool_t IsInside(T xp, T yp, Int_t np, T *x, T *y)Function which returns kTRUE if point xp,yp lies inside the polygon defined by the np points in array...Definition TMath.h:1233; TMath::ExpDouble_t Exp(Double_t x)Returns the base-e exponential function of x, which is e raised to the power x.Definition TMath.h:709; TMath::ATan2Double_t ATan2(Double_t y, Double_t x)Returns the principal value of the arc tangent of y/x, expressed in radians.Definition TMath.h:646; TMath::LogDouble_t Log(Double_t x)Returns the natural logarithm of x.Definition TMath.h:756; TMath::SqrtDouble_t Sqrt(Double_t x)Returns the square root of x.Definition TMath.h:662; TMath::MinShort_t Min(Short_t a, Short_t b)Returns the smallest of a and b.Definition TMathBase.h:198; TMath::Sortvoid Sort(Index n, const Element *a, Index *index, Bool_t down=kTRUE)Sort the n elements of the array a of generic templated type Element.Definition TMathBase.h:431; TMath::BinarySearchLong64_t BinarySearch(Long64_t n, const T *array, T value)Binary search in an array of n values to locate value.Definition TMathBase.h:347; TMath::AbsShort_t Abs(Short_t d)Returns the absolute value of parameter Short_t d.Definition TMathBase.h:123; Foption_tDefinition Foption.h:24; D",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraph_8cxx_source.html:139212,power,power,139212,doc/master/TGraph_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html,1,['power'],['power']
Energy Efficiency,"Derivator &);  ; Derivator & operator= (const Derivator &);  . — Static methods —; This methods don't require to use a Derivator object, and are designed to be used in fast calculation.; Error and status code cannot be retrieved in this case . GSLDerivator * fDerivator;  ; int Status () const;  return the error status of the last derivative calculation ;  ; double Result () const;  return the result of the last derivative calculation ;  ; double Error () const;  return the estimate of the absolute error of the last derivative calculation ;  ; static double Eval (const IGenFunction &f, double x, double h=1E-8);  Computes the numerical derivative of a function f at a point x. ;  ; static double EvalCentral (const IGenFunction &f, double x, double h=1E-8);  Computes the numerical derivative of a function f at a point x using an adaptive central difference algorithm with a step size h. ;  ; static double EvalForward (const IGenFunction &f, double x, double h=1E-8);  Computes the numerical derivative of a function f at a point x using an adaptive forward difference algorithm with a step size h. ;  ; static double EvalBackward (const IGenFunction &f, double x, double h=1E-8);  Computes the numerical derivative of a function f at a point x using an adaptive backward difference algorithm with a step size h. ;  ; static double Eval (const IMultiGenFunction &f, const double *x, unsigned int icoord=0, double h=1E-8);  Evaluate the partial derivative of a multi-dim function with respect coordinate x_icoord at the point x[]. ;  ; static double Eval (IParamFunction &f, double x, const double *p, unsigned int ipar=0, double h=1E-8);  Evaluate the derivative with respect a parameter for one-dim parameteric function at the point ( x,p[]) with respect the parameter p_ipar. ;  ; static double Eval (IParamMultiFunction &f, const double *x, const double *p, unsigned int ipar=0, double h=1E-8);  Evaluate the derivative with respect a parameter for a multi-dim parameteric function at the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1Derivator.html:3146,adapt,adaptive,3146,doc/master/classROOT_1_1Math_1_1Derivator.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1Derivator.html,1,['adapt'],['adaptive']
Energy Efficiency,"DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . #include <TPie.h>. Inheritance diagram for TPie:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TPie() [1/6]. TPie::TPie ; (; ). Default constructor. ; Definition at line 64 of file TPie.cxx. ◆ TPie() [2/6]. TPie::TPie ; (; const char * ; name, . const char * ; title, . Int_t ; npoints . ). This constructor creates a pie chart when only the number of the slices is known. ; The number of slices is fixed. ; Definition at line 73 of file TPie.cxx. ◆ TPie() [3/6]. TPie::TPie ; (; const char * ; name, . const char * ; title, . Int_t ; npoints, . Double_t * ; vals, . Int_t * ; colors = nullptr, . const char * ; lbls[] = nullptr . ). Normal constructor. ; The 1st and 2nd parameters are the name of the object and its title.; The number of points passed at this point is used to allocate the memory.; Slices values are given as Double_t.; The 4th elements is an array containing, in double precision format, the value of each slice. It is also possible to specify the filled color of each slice. If the color array is not specified the slices are colored using a color sequence in the standard palette. ; Definition at line 92 of file TPie.cxx. ◆ TPie() [4/6]. TPie::TPie ; (; const char * ; name, . const char * ; title, . Int_t ; npoints, . Float_t * ; vals, . Int_t * ; cols = nullptr, . const char * ; lbls[] = nullptr . ). Normal constructor (Float_t). ; Definition at line 106 of file TPie.cxx. ◆ TPie() [5/6]. TPie::TPie ; (; const TH1 * ; h). Constructor from a TH1. ; Definition at line 121 of file TPie.cxx. ◆ TPie() [6/6]. TPie::TPie ; (; const TPie & ; cpy). Copy constructor. ; Definition at line 145 of file TPie.cxx. ◆ ~TPie(). TPie::~TPie ; (; ). override . Destructor. ; Definition at line 156 of file TPie.cxx. Member Function Documentation. ◆ ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPie.html:24132,allocate,allocate,24132,doc/master/classTPie.html,https://root.cern,https://root.cern/doc/master/classTPie.html,1,['allocate'],['allocate']
Energy Efficiency,"DoEval(const double *) for the; function evaluation in addition to NDim() and Clone(). @ingroup GenFunc. This class is also known as (typedefs to this class)ROOT::Math::IGradientFunctionMultiDim::BaseGrad. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IGradientMultiDim(); doubleDerivative(const double* x, unsigned int icoord = 0) const; virtual voidFdF(const double* x, double& f, double* df) const; virtual voidGradient(const double* x, double* grad) const; ROOT::Math::IGradientMultiDim&operator=(const ROOT::Math::IGradientMultiDim&). private:. virtual doubleDoDerivative(const double* x, unsigned int icoord) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~IGradientMultiDim(); virual destructor. {}. void Gradient(const double* x, double* grad) const. Evaluate all the vector of function derivatives (gradient) at a point x.; Derived classes must re-implement if it is more efficient than evaluting one at a time. double Derivative(const double* x, unsigned int icoord = 0) const. Return the partial derivative with respect to the passed coordinate. return DoDerivative(const double* x, unsigned int icoord) const. void FdF(const double* x, double& f, double* df) const. Optimized method to evaluate at the same time the function value and derivative at a point x.; Often both value and derivatives are needed and it is often more efficient to compute them at the same time.; Derived class should implement this method if performances play an important role and if it is faster to; evaluate value and derivative at the same time. » Last changed: root/mathcore:$Id: IFunction.h 24482 2008-06-23 15:33:08Z moneta $ » Last generated: 2009-12-07 13:43; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__IGradientMultiDim.html:1881,efficient,efficient,1881,root/html526/ROOT__Math__IGradientMultiDim.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__IGradientMultiDim.html,2,['efficient'],['efficient']
Energy Efficiency,"Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); return boosted MVA response. Double_t GetBoostROCIntegral(Bool_t , TMVA::Types::ETreeType , Bool_t CalcOverlapIntergral = kFALSE); Calculate the ROC integral of a single classifier or even the; whole boosted classifier. The tree type (training or testing; sample) is specified by 'eTT'. If tree type kTraining is set, the original training sample is; used to compute the ROC integral (original weights). - singleMethod - if kTRUE, return ROC integral of single (last; trained) classifier; if kFALSE, return ROC; integral of full classifier. - eTT - tree type (Types::kTraining / Types::kTesting). - CalcOverlapIntergral - if kTRUE, the overlap integral of the; signal/background MVA distributions; is calculated and stored in; 'fOverlap_integral'. void CalcMVAValues(); Calculate MVA values of current method fMethods.back() on; training sample. void MonitorBoost(TMVA::Types::EBoostStage stage, UInt_t methodIdx = 0); fill various monitoring histograms from information of the individual classifiers that; have been boosted.; of course.... this depends very much on the individual classifiers, and so far, only for; Decision Trees, this monitoring is actually implemented. MethodBoost(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = """", TDirectory* theTargetDir = __null); constructors. void SetBoostedMethodName(TString methodName); { fBoostedMethodName = methodName; }. Int_t GetBoostNum(); { return fBoostNum; }. void ClearAll(); clean up. void PrintResults(const TString& , vector<Double_t>& , const Double_t ) const; print fit results. MethodBase* CurrentMethod(); {return fCurrentMethod;}. UInt_t CurrentMethodIdx(); training a single classifier. {return fCurrentMethodIdx;}. Double_t CalcMethodWeight(); calculate weight of single method. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss, Or Cohen, Jan Therhaag, Eckhard von Toerne » Copyright (c) 2005-2",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__MethodBoost.html:23943,monitor,monitoring,23943,root/html602/TMVA__MethodBoost.html,https://root.cern,https://root.cern/root/html602/TMVA__MethodBoost.html,2,['monitor'],['monitoring']
Energy Efficiency,"Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); return boosted MVA response. Double_t GetBoostROCIntegral(Bool_t , TMVA::Types::ETreeType , Bool_t CalcOverlapIntergral = kFALSE); Calculate the ROC integral of a single classifier or even the; whole boosted classifier. The tree type (training or testing; sample) is specified by 'eTT'. If tree type kTraining is set, the original training sample is; used to compute the ROC integral (original weights). - singleMethod - if kTRUE, return ROC integral of single (last; trained) classifier; if kFALSE, return ROC; integral of full classifier. - eTT - tree type (Types::kTraining / Types::kTesting). - CalcOverlapIntergral - if kTRUE, the overlap integral of the; signal/background MVA distributions; is calculated and stored in; 'fOverlap_integral'. void CalcMVAValues(); Calculate MVA values of current method fMethods.back() on; training sample. void MonitorBoost(TMVA::Types::EBoostStage stage, UInt_t methodIdx = 0); fill various monitoring histograms from information of the individual classifiers that; have been boosted.; of course.... this depends very much on the individual classifiers, and so far, only for; Decision Trees, this monitoring is actually implemented. void SetBoostedMethodName(TString methodName); { fBoostedMethodName = methodName; }. Int_t GetBoostNum(); { return fBoostNum; }. void ClearAll(); clean up. void PrintResults(const TString& , vector<Double_t>& , const Double_t ) const; print fit results. MethodBase* CurrentMethod(); {return fCurrentMethod;}. UInt_t CurrentMethodIdx(); training a single classifier. {return fCurrentMethodIdx;}. Double_t CalcMethodWeight(); calculate weight of single method. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss, Or Cohen, Jan Therhaag, Eckhard von Toerne » Copyright (c) 2005-2011: *; » Last changed: root/tmva $Id$ » Last generated: 2015-03-14 16:43; This page has been automatically generated. For comments or suggestions regarding the documentatio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__MethodBoost.html:22227,monitor,monitoring,22227,root/html534/TMVA__MethodBoost.html,https://root.cern,https://root.cern/root/html534/TMVA__MethodBoost.html,1,['monitor'],['monitoring']
Energy Efficiency,"Double_t exl, Double_t exh, Double_t eyl, Double_t eyh); 1332{; 1333 if (i < 0) return;; 1334 if (i >= fNpoints) {; 1335 // re-allocate the object; 1336 TGraphAsymmErrors::SetPoint(i,0,0);; 1337 }; 1338 fEXlow[i] = exl;; 1339 fEYlow[i] = eyl;; 1340 fEXhigh[i] = exh;; 1341 fEYhigh[i] = eyh;; 1342}; 1343 ; 1344 ; 1345////////////////////////////////////////////////////////////////////////////////; 1346/// Set EXlow for point `i`.; 1347 ; 1348void TGraphAsymmErrors::SetPointEXlow(Int_t i, Double_t exl); 1349{; 1350 if (i < 0) return;; 1351 if (i >= fNpoints) {; 1352 // re-allocate the object; 1353 TGraphAsymmErrors::SetPoint(i,0,0);; 1354 }; 1355 fEXlow[i] = exl;; 1356}; 1357 ; 1358 ; 1359////////////////////////////////////////////////////////////////////////////////; 1360/// Set EXhigh for point `i`.; 1361 ; 1362void TGraphAsymmErrors::SetPointEXhigh(Int_t i, Double_t exh); 1363{; 1364 if (i < 0) return;; 1365 if (i >= fNpoints) {; 1366 // re-allocate the object; 1367 TGraphAsymmErrors::SetPoint(i,0,0);; 1368 }; 1369 fEXhigh[i] = exh;; 1370}; 1371 ; 1372 ; 1373////////////////////////////////////////////////////////////////////////////////; 1374/// Set EYlow for point `i`.; 1375 ; 1376void TGraphAsymmErrors::SetPointEYlow(Int_t i, Double_t eyl); 1377{; 1378 if (i < 0) return;; 1379 if (i >= fNpoints) {; 1380 // re-allocate the object; 1381 TGraphAsymmErrors::SetPoint(i,0,0);; 1382 }; 1383 fEYlow[i] = eyl;; 1384}; 1385 ; 1386 ; 1387////////////////////////////////////////////////////////////////////////////////; 1388/// Set EYhigh for point `i`.; 1389 ; 1390void TGraphAsymmErrors::SetPointEYhigh(Int_t i, Double_t eyh); 1391{; 1392 if (i < 0) return;; 1393 if (i >= fNpoints) {; 1394 // re-allocate the object; 1395 TGraphAsymmErrors::SetPoint(i,0,0);; 1396 }; 1397 fEYhigh[i] = eyh;; 1398}; 1399 ; 1400 ; 1401////////////////////////////////////////////////////////////////////////////////; 1402/// Stream an object of class TGraphAsymmErrors.; 1403 ; 1404void TGraphAsymmEr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html:47066,allocate,allocate,47066,doc/master/TGraphAsymmErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html,1,['allocate'],['allocate']
Energy Efficiency,"Double_t red[9] = { 57./255., 72./255., 94./255., 117./255., 136./255., 154./255., 174./255., 192./255., 215./255.};; 3338 Double_t green[9] = { 0./255., 33./255., 68./255., 109./255., 140./255., 171./255., 192./255., 196./255., 209./255.};; 3339 Double_t blue[9] = { 116./255., 137./255., 173./255., 201./255., 200./255., 201./255., 203./255., 190./255., 187./255.};; 3340 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3341 }; 3342 break;; 3343 ; 3344 // Light Temperature; 3345 case 87:; 3346 {; 3347 Double_t red[9] = { 31./255., 71./255., 123./255., 160./255., 210./255., 222./255., 214./255., 199./255., 183./255.};; 3348 Double_t green[9] = { 40./255., 117./255., 171./255., 211./255., 231./255., 220./255., 190./255., 132./255., 65./255.};; 3349 Double_t blue[9] = { 234./255., 214./255., 228./255., 222./255., 210./255., 160./255., 105./255., 60./255., 34./255.};; 3350 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3351 }; 3352 break;; 3353 ; 3354 // Light Terrain; 3355 case 88:; 3356 {; 3357 Double_t red[9] = { 123./255., 108./255., 109./255., 126./255., 154./255., 172./255., 188./255., 196./255., 218./255.};; 3358 Double_t green[9] = { 184./255., 138./255., 130./255., 133./255., 154./255., 175./255., 188./255., 196./255., 218./255.};; 3359 Double_t blue[9] = { 208./255., 130./255., 109./255., 99./255., 110./255., 122./255., 150./255., 171./255., 218./255.};; 3360 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3361 }; 3362 break;; 3363 ; 3364 // Mint; 3365 case 89:; 3366 {; 3367 Double_t red[9] = { 105./255., 106./255., 122./255., 143./255., 159./255., 172./255., 176./255., 181./255., 207./255.};; 3368 Double_t green[9] = { 252./255., 197./255., 194./255., 187./255., 174./255., 162./255., 153./255., 136./255., 125./255.};; 3369 Double_t blue[9] = { 146./255., 133./255., 144./255., 155./255., 163./255., 167./255., 166./255., 162./255., 174./255.};; 3370 Idx = TColor::Cr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TColor_8cxx_source.html:130773,green,green,130773,doc/master/TColor_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html,1,['green'],['green']
Energy Efficiency,"Double_t TMath::PiOver2 ();  \( \frac{\pi}{2} \) ;  ; constexpr Double_t TMath::PiOver4 ();  \( \frac{\pi}{4} \) ;  ; Double_t TMath::Poisson (Double_t x, Double_t par);  Computes the Poisson distribution function for (x,par). ;  ; Double_t TMath::PoissonI (Double_t x, Double_t par);  Computes the Discrete Poisson distribution function for (x,par). ;  ; Double_t TMath::Power (Double_t x, Double_t y);  Returns x raised to the power y. ;  ; Double_t TMath::Power (Double_t x, Int_t y);  Returns x raised to the power y. ;  ; LongDouble_t TMath::Power (Long64_t x, Long64_t y);  Returns x raised to the power y. ;  ; LongDouble_t TMath::Power (LongDouble_t x, Long64_t y);  Returns x raised to the power y. ;  ; LongDouble_t TMath::Power (LongDouble_t x, LongDouble_t y);  Returns x raised to the power y. ;  ; Double_t TMath::Prob (Double_t chi2, Int_t ndf);  Computation of the probability for a certain Chi-squared (chi2) and number of degrees of freedom (ndf). ;  ; constexpr Double_t TMath::Qe ();  Elementary charge in \( C \) . ;  ; constexpr Double_t TMath::QeUncertainty ();  Elementary charge uncertainty. ;  ; void TMath::Quantiles (Int_t n, Int_t nprob, Double_t *x, Double_t *quantiles, Double_t *prob, Bool_t isSorted=kTRUE, Int_t *index=nullptr, Int_t type=7);  Computes sample quantiles, corresponding to the given probabilities. ;  ; Double_t TMath::QuietNaN ();  Returns a quiet NaN as defined by IEEE 754. ;  ; constexpr Double_t TMath::R ();  Universal gas constant ( \( Na K \)) in \( J K^{-1} mol^{-1} \) ;  ; constexpr Double_t TMath::RadToDeg ();  Conversion from radian to degree: \( \frac{180}{\pi} \). ;  ; constexpr Double_t TMath::Rgair ();  Dry Air Gas Constant (R / MWair) in \( J kg^{-1} K^{-1} \) ;  ; template<typename Iterator > ; Double_t TMath::RMS (Iterator first, Iterator last);  Returns the Standard Deviation of an array defined by the iterators. ;  ; template<typename Iterator , typename WeightIterator > ; Double_t TMath::RMS (Iterator first, Iterator la",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMath_8h.html:15864,charge,charge,15864,doc/master/TMath_8h.html,https://root.cern,https://root.cern/doc/master/TMath_8h.html,1,['charge'],['charge']
Energy Efficiency,"Dst->Org.; 349 * Make sure the old vertex points to a valid half-edge.; 350 */; 351 MakeVertex( newVertex, eDst, eOrg->Org );; 352 eOrg->Org->anEdge = eOrg;; 353 }; 354 if( ! joiningLoops ) {; 355 GLUface *newFace= allocFace();; 356 if (newFace == NULL) return 0;; 357 ; 358 /* We split one loop into two -- the new loop is eDst->Lface.; 359 * Make sure the old face points to a valid half-edge.; 360 */; 361 MakeFace( newFace, eDst, eOrg->Lface );; 362 eOrg->Lface->anEdge = eOrg;; 363 }; 364 ; 365 return 1;; 366}; 367 ; 368 ; 369/* __gl_meshDelete( eDel ) removes the edge eDel. There are several cases:; 370 * if (eDel->Lface != eDel->Rface), we join two loops into one; the loop; 371 * eDel->Lface is deleted. Otherwise, we are splitting one loop into two;; 372 * the newly created loop will contain eDel->Dst. If the deletion of eDel; 373 * would create isolated vertices, those are deleted as well.; 374 *; 375 * This function could be implemented as two calls to __gl_meshSplice; 376 * plus a few calls to memFree, but this would allocate and delete; 377 * unnecessary vertices and faces.; 378 */; 379int __gl_meshDelete( GLUhalfEdge *eDel ); 380{; 381 GLUhalfEdge *eDelSym = eDel->Sym;; 382 int joiningLoops = FALSE;; 383 ; 384 /* First step: disconnect the origin vertex eDel->Org. We make all; 385 * changes to get a consistent mesh in this ""intermediate"" state.; 386 */; 387 if( eDel->Lface != eDel->Rface ) {; 388 /* We are joining two loops into one -- remove the left face */; 389 joiningLoops = TRUE;; 390 KillFace( eDel->Lface, eDel->Rface );; 391 }; 392 ; 393 if( eDel->Onext == eDel ) {; 394 KillVertex( eDel->Org, NULL );; 395 } else {; 396 /* Make sure that eDel->Org and eDel->Rface point to valid half-edges */; 397 eDel->Rface->anEdge = eDel->Oprev;; 398 eDel->Org->anEdge = eDel->Onext;; 399 ; 400 Splice( eDel, eDel->Oprev );; 401 if( ! joiningLoops ) {; 402 GLUface *newFace= allocFace();; 403 if (newFace == NULL) return 0;; 404 ; 405 /* We are splitting one loop into two ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/mesh_8c_source.html:12497,allocate,allocate,12497,doc/master/mesh_8c_source.html,https://root.cern,https://root.cern/doc/master/mesh_8c_source.html,1,['allocate'],['allocate']
Energy Efficiency,"Dump::GetStream ; (; ); const. inlineoverridevirtual . Reimplemented from TVirtualPS.; Definition at line 53 of file TImageDump.h. ◆ GetType(). Int_t TImageDump::GetType ; (; ); const. inlineoverridevirtual . Reimplemented from TVirtualPS.; Definition at line 55 of file TImageDump.h. ◆ IsA(). TClass * TImageDump::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 58 of file TImageDump.h. ◆ NewPage(). void TImageDump::NewPage ; (; ). overridevirtual . new page ; Implements TVirtualPS.; Definition at line 838 of file TImageDump.cxx. ◆ Open(). void TImageDump::Open ; (; const char * ; filename, . Int_t ; type = -111 . ). overridevirtual . Open a image file. ; Implements TVirtualPS.; Definition at line 82 of file TImageDump.cxx. ◆ SetColor(). void TImageDump::SetColor ; (; Float_t ; r, . Float_t ; g, . Float_t ; b . ). overridevirtual . Set color with its R G B components. . r: % of red in [0,1]; g: % of green in [0,1]; b: % of blue in [0,1] . Implements TVirtualPS.; Definition at line 981 of file TImageDump.cxx. ◆ SetType(). void TImageDump::SetType ; (; Int_t ; type = -111). inlineoverridevirtual . Reimplemented from TVirtualPS.; Definition at line 54 of file TImageDump.h. ◆ Streamer(). void TImageDump::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void TImageDump::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 58 of file TImageDump.h. ◆ Text() [1/2]. void TImageDump::Text ; (; Double_t ; x, . Double_t ; y, . const char * ; chars . ). overridevirtual . Draw text. . x: x position of the text; y: y position of the text . Implements TVirtualPS.; Definition at line 854 of file TImageDump.cxx. ◆ Text() [2/2]. void TImageDump::Text ; (; Double_t ; x, . Double_t ; y, . const wchar_t * ; chars . ). overridevirtual . Draw text. . x: x position of the text; y: y ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTImageDump.html:28411,green,green,28411,doc/master/classTImageDump.html,https://root.cern,https://root.cern/doc/master/classTImageDump.html,1,['green'],['green']
Energy Efficiency,"E)=0; TBuffer::ReadFastArrayFloat16virtual void ReadFastArrayFloat16(Float_t *f, Int_t n, TStreamerElement *ele=nullptr)=0; TBuffer::LengthInt_t Length() constDefinition TBuffer.h:100; TBuffer::StreamObjectvirtual void StreamObject(void *obj, const std::type_info &typeinfo, const TClass *onFileClass=nullptr)=0; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClass::Streamervoid Streamer(void *obj, TBuffer &b, const TClass *onfile_class=nullptr) constDefinition TClass.h:607; TClass::CanSplitBool_t CanSplit() constReturn true if the data member of this TClass can be saved separately.Definition TClass.cxx:2386; TClass::NewArrayvoid * NewArray(Long_t nElements, ENewType defConstructor=kClassNew) constReturn a pointer to a newly allocated array of objects of this class.Definition TClass.cxx:5260; TClass::GetStateEState GetState() constDefinition TClass.h:488; TClass::Newvoid * New(ENewType defConstructor=kClassNew, Bool_t quiet=kFALSE) constReturn a pointer to a newly allocated object of this class.Definition TClass.cxx:5045; TClass::HasCustomStreamerMemberBool_t HasCustomStreamerMember() constThe class has a Streamer method and it is implemented by the user or an older (not StreamerInfo based...Definition TClass.h:508; TClass::SizeInt_t Size() constReturn size of object of this class.Definition TClass.cxx:5771; TClass::DeleteArrayvoid DeleteArray(void *ary, Bool_t dtorOnly=kFALSE)Explicitly call operator delete[] for an array.Definition TClass.cxx:5596; TClass::GetStreamerInfoTVirtualStreamerInfo * GetStreamerInfo(Int_t version=0, Bool_t isTransient=kFALSE) constreturns a pointer to the TVirtualStreamerInfo object for version If the object does not exist,...Definition TClass.cxx:4666; TClass::GetCollectionProxyTVirtualCollectionProxy * GetCollectionProxy() constReturn the proxy describing the collection (if any).Definition TClass.cxx:2964; TClass::GetConversionStreamerInfoTVirtualStreamerInfo * GetConversi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html:215232,allocate,allocated,215232,doc/master/TStreamerInfoActions_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html,1,['allocate'],['allocated']
Energy Efficiency,"E***to arrays[***] or to f*** Copy points. ;  ; Bool_t CtorAllocate ();  Should be called from ctors after fNpoints has been set. ;  ; Bool_t DoMerge (const TGraph *g) override;  Protected function to perform the merge operation of a graph with asymmetric errors. ;  ; void FillZero (Int_t begin, Int_t end, Bool_t from_ctor=kTRUE) override;  Set zero values for point arrays in the range [begin, end] ;  ; void SwapPoints (Int_t pos1, Int_t pos2) override;  Swap points. ;  ; void UpdateArrays (const std::vector< Int_t > &sorting_indices, Int_t numSortedPoints, Int_t low) override;  Update the fX, fY, fEXlow, fEXhigh, fEXlowd, fEXhighd, fEYlow, fEYhigh, fEYlowd, ; and fEYhighd arrays with the sorted values. ;  ;  Protected Member Functions inherited from TGraph; Double_t ** AllocateArrays (Int_t Narrays, Int_t arraySize);  Allocate arrays. ;  ; Bool_t CtorAllocate ();  In constructors set fNpoints than call this method. ;  ; Double_t ** ExpandAndCopy (Int_t size, Int_t iend);  if size > fMaxSize allocate new arrays of 2*size points and copy iend first points. ;  ; TString SaveArray (std::ostream &out, const char *suffix, Int_t frameNumber, Double_t *arr);  Save array as C++ code Returns name of created array. ;  ; void SaveHistogramAndFunctions (std::ostream &out, const char *varname, Int_t &frameNumber, Option_t *option);  Save histogram and list of functions of TGraph as C++ statement Used in all TGraph-derived classes. ;  ; Double_t ** ShrinkAndCopy (Int_t size, Int_t iend);  if size*2 <= fMaxSize allocate new arrays of size points, copy points [0,oend). ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; Double_t * fEXhigh;  [fNpoints] array of X high errors ;  ; Double_t * fEXhighd;  [fNpoints] array of X high displacements ;  ; Double_t * fEXlow;  [fNpoints] array of X low errors ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGraphBentErrors.html:30666,allocate,allocate,30666,doc/master/classTGraphBentErrors.html,https://root.cern,https://root.cern/doc/master/classTGraphBentErrors.html,1,['allocate'],['allocate']
Energy Efficiency,"Element::HandleElementPaste(TEveElement* el); virtual Bool_tTObject::HandleTimer(TTimer* timer); Bool_tTEveElement::HasChild(TEveElement* el); Bool_tTEveElement::HasChildren() const; virtual ULong_tTNamed::Hash() const; virtual Bool_tTEveElement::HasMainColor() const; virtual Bool_tTEveElement::HasMainTrans() const; Bool_tTEveElement::HasParents() const; virtual Bool_tTEveProjectable::HasProjecteds() const; virtual voidTEveElement::HighlightElement(Bool_t state); voidTEveElement::IncDenyDestroy(); virtual voidTEveElement::IncImpliedHighlighted(); virtual voidTEveElement::IncImpliedSelected(); voidTEveElement::IncParentIgnoreCnt(); virtual voidTEveRefBackPtr::IncRefCount(TEveElement* re); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTEveElement::InitMainTrans(Bool_t can_edit = kTRUE); voidInitTrack(TEveVector& v, Int_t charge); virtual voidTObject::Inspect() constMENU ; Bool_tIntersectPlane(const TEveVector& p, const TEveVector& point, const TEveVector& normal, TEveVector& itsect); voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; static Bool_tIsOutsideBounds(const TEveVector& point, Float_t maxRsqr, Float_t maxZ); Bool_tTEveElement::IsPickable() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; TEveElement*TEveElement::LastChild() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTEveElement::NameTitleChanged(); virtual Bool_tTObject::Notify(); Int_tTEveElement::NumChildren() const; Int_tTEveElement::NumParents() const; virtual voidOnZeroRefCount(); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEveTrackPropagator.html:10824,charge,charge,10824,root/html528/TEveTrackPropagator.html,https://root.cern,https://root.cern/root/html528/TEveTrackPropagator.html,1,['charge'],['charge']
Energy Efficiency,"Element::Printvoid Print(Option_t *option="""") const overridePrint TBranch parameters.Definition TBranchElement.cxx:3836; TBranchElement::GetIDInt_t GetID() constDefinition TBranchElement.h:195; TBranchElement::GetBranchOffsetInt_t * GetBranchOffset() constDefinition TBranchElement.h:184; TBranchElement::GetClassNameconst char * GetClassName() const overrideReturn the name of the user class whose content is stored in this branch, if any.Definition TBranchElement.h:186; TBranchElement::GetInfoTStreamerInfo * GetInfo() constGet streamer info for the branch class.Definition TBranchElement.cxx:1024; TBranchElement::ReadLeavesCollectionvoid ReadLeavesCollection(TBuffer &b)Read leaves into i/o buffers for this branch.Definition TBranchElement.cxx:4267; TBranchElement::SetupAddressesvoid SetupAddresses() overrideIf the branch address is not set, we set all addresses starting with the top level parent branch.Definition TBranchElement.cxx:5892; TBranchElement::ResetAddressvoid ResetAddress() overrideSet branch address to zero and free all allocated memory.Definition TBranchElement.cxx:4780; TBranchElement::SetTypevirtual void SetType(Int_t btype)Definition TBranchElement.h:234; TBranchElement::FillLeavesMembervoid FillLeavesMember(TBuffer &b)Write leaves into i/o buffers for this branch.Definition TBranchElement.cxx:1734; TBranchElement::SetBranchCountvoid SetBranchCount(TBranchElement *bre)Set the branch counter for this branch.Definition TBranchElement.cxx:5529; TBranchElement::SwitchContainerstatic void SwitchContainer(TObjArray *)Modify the container type of the branches.Definition TBranchElement.cxx:85; TBranchElement::SetReadActionSequencevoid SetReadActionSequence()Set the sequence of actions needed to read the data out of the buffer.Definition TBranchElement.cxx:5663; TBranchElement::IsMissingCollectionbool IsMissingCollection() constDetect a collection written using a zero pointer in old versions of root.Definition TBranchElement.cxx:3776; TBranchElement::FillImplInt_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBranchElement_8h_source.html:21499,allocate,allocated,21499,doc/master/TBranchElement_8h_source.html,https://root.cern,https://root.cern/doc/master/TBranchElement_8h_source.html,1,['allocate'],['allocated']
Energy Efficiency,"Error(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. THnSparseArrayChunk*THnSparse::AddChunk(); voidTHnSparse::AddInternal(const THnSparse* h, Double_t c, Bool_t rebinned); Bool_tTHnSparse::CheckConsistency(const THnSparse* h, const char* tag) const; THnSparse*THnSparse::CloneEmpty(const char* name, const char* title, const TObjArray* axes, Int_t chunksize, Bool_t keepTargetAxis) const; TH1*THnSparse::CreateHist(const char* name, const char* title, const TObjArray* axes, Bool_t keepTargetAxis) const; virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; Long64_tTHnSparse::Fill(Long64_t bin, Double_t w); voidTHnSparse::FillExMap(); Long64_tTHnSparse::GetBinIndexForCurrentBin(Bool_t allocate); THnSparseArrayChunk*THnSparse::GetChunk(Int_t idx) const; Int_tTHnSparse::GetChunkSize() const; THnSparseCompactBinCoord*THnSparse::GetCompactCoord() const; Bool_tTHnSparse::IsInRange(Int_t* coord) const; voidTObject::MakeZombie(); Bool_tTHnSparse::PrintBin(Long64_t idx, Int_t* coord, Option_t* options) const; TObject*THnSparse::ProjectionAny(Int_t ndim, const Int_t* dim, Bool_t wantSparse, Option_t* option = """") const. Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function doc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/THnSparseT_TArrayC_.html:10268,allocate,allocate,10268,root/html528/THnSparseT_TArrayC_.html,https://root.cern,https://root.cern/root/html528/THnSparseT_TArrayC_.html,18,['allocate'],['allocate']
Energy Efficiency,"EveElement::ECompoundSelectionColorBitsTEveElement::kCSCBTakeAnyParentAsMaster; static TEveElement::EDestructTEveElement::kNone; static TEveElement::EDestructTEveElement::kStandard. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEveTrackPropagator(const char* n = ""TEveTrackPropagator"", const char* t = """", TEveMagField* field = 0, Bool_t own_field = kTRUE); Default constructor. ~TEveTrackPropagator(); Destructor. void OnZeroRefCount(); Virtual from TEveRefBackPtr - track reference count has reached zero. void CheckReferenceCount(const TEveException& eh = ""TEveElement::CheckReferenceCount ""); Check reference count - virtual from TEveElement.; Must also take into account references from TEveRefBackPtr. void ElementChanged(Bool_t update_scenes = kTRUE, Bool_t redraw = kFALSE); Element-change notification.; Stamp all tracks as requiring display-list regeneration.; Virtual from TEveElement. void InitTrack(const TEveVectorD& v, Int_t charge); Initialize internal data-members for given particle parameters. void InitTrack(const TEveVectorF& v, Int_t charge); TEveVectorF wrapper. void ResetTrack(); Reset cache holding particle trajectory. Int_t GetCurrentPoint() const; Get index of current point on track. Double_t GetTrackLength(Int_t start_point = 0, Int_t end_point = -1) const; Calculate track length from start_point to end_point.; If end_point is less than 0, distance to the end is returned. Bool_t GoToVertex(TEveVectorD& v, TEveVectorD& p); Propagate particle with momentum p to vertex v. Bool_t GoToLineSegment(const TEveVectorD& s, const TEveVectorD& r, TEveVectorD& p); Propagate particle with momentum p to line with start point s and vector r to the second point. Bool_t GoToVertex(TEveVectorF& v, TEveVectorF& p); TEveVectorF wrapper. Bool_t GoToLineSegment(const TEveVectorF& s, const TEveVectorF& r, TEveVectorF& p); TEveVectorF wrapper. void GoToBounds(TEveVectorD& p); Propagate particle to bounds.; Return TRUE if hit bounds. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEveTrackPropagator.html:28013,charge,charge,28013,root/html602/TEveTrackPropagator.html,https://root.cern,https://root.cern/root/html602/TEveTrackPropagator.html,2,['charge'],['charge']
Energy Efficiency,"EveVectorD & ; point, . Double_t ; maxRsqr, . Double_t ; maxZ . ). inlinestatic . Definition at line 352 of file TEveTrackPropagator.h. ◆ LineIntersectPlane(). Bool_t TEveTrackPropagator::LineIntersectPlane ; (; const TEveVectorD & ; p, . const TEveVectorD & ; point, . const TEveVectorD & ; normal, . TEveVectorD & ; itsect . ). protected . Intersect line with a plane. ; Current position and argument p define the line. ; Definition at line 907 of file TEveTrackPropagator.cxx. ◆ LineToBounds(). void TEveTrackPropagator::LineToBounds ; (; TEveVectorD & ; p). protected . Propagate neutral particle with momentum p to bounds. ; Definition at line 824 of file TEveTrackPropagator.cxx. ◆ LineToVertex(). Bool_t TEveTrackPropagator::LineToVertex ; (; TEveVectorD & ; v). protected . Propagate neutral particle to vertex v. ; Definition at line 808 of file TEveTrackPropagator.cxx. ◆ LoopToBounds(). void TEveTrackPropagator::LoopToBounds ; (; TEveVectorD & ; p). protected . Propagate charged particle with momentum p to bounds. ; It is expected that Update() with full-update was called before. ; Definition at line 547 of file TEveTrackPropagator.cxx. ◆ LoopToLineSegment(). Bool_t TEveTrackPropagator::LoopToLineSegment ; (; const TEveVectorD & ; s, . const TEveVectorD & ; r, . TEveVectorD & ; p . ). protected . Propagate charged particle with momentum p to line segment with point s and vector r to the second point. ; It is expected that Update() with full-update was called before. Returns kFALSE if hits bounds. ; Definition at line 687 of file TEveTrackPropagator.cxx. ◆ LoopToVertex(). Bool_t TEveTrackPropagator::LoopToVertex ; (; TEveVectorD & ; v, . TEveVectorD & ; p . ). protected . Propagate charged particle with momentum p to vertex v. ; It is expected that Update() with full-update was called before. ; Definition at line 610 of file TEveTrackPropagator.cxx. ◆ OnZeroRefCount(). void TEveTrackPropagator::OnZeroRefCount ; (; ). overridevirtual . Virtual from TEveRefBackPtr - trac",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEveTrackPropagator.html:55021,charge,charged,55021,doc/master/classTEveTrackPropagator.html,https://root.cern,https://root.cern/doc/master/classTEveTrackPropagator.html,1,['charge'],['charged']
Energy Efficiency,"ExpModelClass RooGExpModel is a RooResolutionModel implementation that models a resolution function that is the convolution of a Gaussian with a one-sided exponential ;  CRooGlobalFunc;  CRooGridRooGrid is a utility class for RooMCIntegrator which implements an adaptive multi-dimensional Monte Carlo numerical integration, following the VEGAS algorithm ;  CRooHashTableRooHashTable implements a hash table for TObjects ;  CRooHistA RooHist is a graphical representation of binned data based on the TGraphAsymmErrors class ;  CRooHistConstraint;  ►CRooHistErrorRooHistError is a singleton class used to calculate the error bars for each bin of a RooHist object ;  CBinomialSumAsym;  CBinomialSumEff;  CPoissonSum;  CRooHistFuncRooHistFunc implements a real-valued function sampled from a multidimensional histogram ;  CRooHistPdfRooHistPdf implements a probablity density function sampled from a multidimensional histogram ;  CRooImproperIntegrator1DSpecial numeric integrator that can handle integrals over open domains ;  CRooIntRooInt is a minimal implementation of a TObject holding a Int_t value ;  ►CRooIntegralMorphClass RooIntegralMorph is an implementation of the histogram interpolation technique described by Alex Read in 'NIM A 425 (1999) 357-369 'Linear interpolation of histograms' for continuous functions rather than histograms ;  CMorphCacheElem;  CRooIntegrator1DRooIntegrator1D implements an adaptive one-dimensional numerical integration algorithm ;  CRooIntegrator2DRooIntegrator2D implements a numeric two-dimensiona integrator in terms of a recursive application of RooIntegrator1D ;  CRooIntegratorBindingFunction binding representing the output of a RooAbsIntegrator ;  CRooInvTransformLightweight function binding that returns the inverse of an input function binding Apply the change of variables transformation x -> 1/x to the input function and its range ;  CRooJeffreysPriorRooJeffreysPrior ;  CRooKeysPdfClass RooKeysPdf implements a one-dimensional kernel estimation p.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v610/annotated.html:102269,adapt,adaptive,102269,doc/v610/annotated.html,https://root.cern,https://root.cern/doc/v610/annotated.html,4,['adapt'],['adaptive']
Energy Efficiency,"F(double x, double& f, double& df) const; voidFdF(const double* x, double& f, double* df) const; voidGradient(const double* x, double* g) const; ROOT::Math::IGradientOneDim&operator=(const ROOT::Math::IGradientOneDim&). private:. virtual doubleDoDerivative(double x) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Gradient(const double* x, double* g) const. Evaluate all the vector of function derivatives (gradient) at a point x.; Derived classes must re-implement if it is more efficient than evaluting one at a time. double Derivative(const double * x, unsigned int icoord = 0). Return the partial derivative with respect to the passed coordinate. return DoDerivative(x, icoord). void FdF(const double * x, double & f, double * df). Optimized method to evaluate at the same time the function value and derivative at a point x.; Often both value and derivatives are needed and it is often more efficient to compute them at the same time.; Derived class should implement this method if performances play an important role and if it is faster to; evaluate value and derivative at the same time. virtual ~IGradientOneDim(); virtual destructor. {}. double Derivative(double x ). Return the derivative of the function at a point x; Use the private method DoDerivative. void FdF(double x, double & f, double & df). Optimized method to evaluate at the same time the function value and derivative at a point x.; Often both value and derivatives are needed and it is often more efficient to compute them at the same time.; Derived class should implement this method if performances play an important role and if it is faster to; evaluate value and derivative at the same time. » Last changed: root/mathcore:$Id: IFunction.h 24482 2008-06-23 15:33:08Z moneta $ » Last generated: 2009-12-07 13:43; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__IGradientOneDim.html:2851,efficient,efficient,2851,root/html526/ROOT__Math__IGradientOneDim.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__IGradientOneDim.html,1,['efficient'],['efficient']
Energy Efficiency,"F::EInterpolateMethodkSpline3; static TMVA::PDF::EInterpolateMethodkSpline5; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. TStringfBorderMethodString; Bool_tfCheckHistcheck of source histogram; Float_tfFineFactorfine tuning factor for Adaptive KDE; TGraph*fGraph! needed to create PDF from histogram; TH1*fHistcopy of input histogram; Int_tfHistAvgEvtPerBinavg event per source hist bin; Int_tfHistDefinedNBinssource hist bin num set by user; TH1*fHistOriginalthe input histogram; TF1*fIGetValintegration interface; TMVA::PDF::EInterpolateMethodfInterpolMethodinterpolation method; TStringfInterpolateString; TMVA::KDEKernel::EKernelBorderfKDEborderThe method to take care about ""border"" effects (string); TMVA::KDEKernel::EKernelIterfKDEiterNumber of iterations (adaptive or not); TStringfKDEiterString; TMVA::KDEKernel::EKernelTypefKDEtypeKernel type to use for KDE; TStringfKDEtypeStringstrings used to read definitions; TMVA::MsgLogger*fLogger! message logger; Int_tfMaxNsmoothMax number of smoothing iterations; Int_tfMinNsmoothMin number of smoothing iterations; TH1*fNSmoothHistnumber of smooth for each bin; Bool_tfNormalizenormalize histogram (false for cumulative distribution used in GaussTranform); Int_tfNsmoothMin number of smoothing iterations; TH1*fPDFHistthe high-binned histogram corresponding to the PDF; TStringfPDFNamefor output; UInt_tfReadingVersionthe TMVA version of the weight file; TSpline*fSpline! the used spline type; TStringfSuffix! the suffix for options; Bool_tfUseHistogramspline0 uses histogram as reference; static const Double_tfgEpsilonminimum PDF return; static const Bool_tfgManualIntegrationmanual integration (sum over bins) or DGAUSS; static const Int_tfgNbin_PdfHistnumber of bins in high-binned reference histogram. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; PDF(const TString& name, Bool_t norm = kTRUE); default constructor needed for ROOT I/O. P",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__PDF.html:9588,adapt,adaptive,9588,root/html602/TMVA__PDF.html,https://root.cern,https://root.cern/root/html602/TMVA__PDF.html,2,['adapt'],['adaptive']
Energy Efficiency,"Fitter.cxx. ◆ SetParameters(). void TMVA::SimulatedAnnealingFitter::SetParameters ; (; Int_t ; fMaxCalls, . Double_t ; fInitialTemperature, . Double_t ; fMinTemperature, . Double_t ; fEps, . TString ; fKernelTemperatureS, . Double_t ; fTemperatureScale, . Double_t ; fTemperatureAdaptiveStep, . Bool_t ; fUseDefaultScale, . Bool_t ; fUseDefaultTemperature . ). set SA configuration parameters ; Definition at line 112 of file SimulatedAnnealingFitter.cxx. ◆ Streamer(). virtual void TMVA::SimulatedAnnealingFitter::Streamer ; (; TBuffer & ; R__b). virtual . Stream an object of class TObject. ; Reimplemented from TMVA::FitterBase. ◆ StreamerNVirtual(). void TMVA::SimulatedAnnealingFitter::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 87 of file SimulatedAnnealingFitter.h. Member Data Documentation. ◆ fAdaptiveSpeed. Double_t TMVA::SimulatedAnnealingFitter::fAdaptiveSpeed. private . how fast temperature change in adaptive (in adaptive two variables describe the change of temperature, but fAdaptiveSpeed should be 1.0 and its not recommended to change it) ; Definition at line 80 of file SimulatedAnnealingFitter.h. ◆ fEps. Double_t TMVA::SimulatedAnnealingFitter::fEps. private . relative required FCN accuracy at minimum ; Definition at line 77 of file SimulatedAnnealingFitter.h. ◆ fInitialTemperature. Double_t TMVA::SimulatedAnnealingFitter::fInitialTemperature. private . initial temperature (depends on FCN) ; Definition at line 75 of file SimulatedAnnealingFitter.h. ◆ fKernelTemperatureS. TString TMVA::SimulatedAnnealingFitter::fKernelTemperatureS. private . string just to set fKernelTemperature ; Definition at line 78 of file SimulatedAnnealingFitter.h. ◆ fMaxCalls. Int_t TMVA::SimulatedAnnealingFitter::fMaxCalls. private . max number of FCN calls ; Definition at line 74 of file SimulatedAnnealingFitter.h. ◆ fMinTemperature. Double_t TMVA::SimulatedAnnealingFitter::fMinTemperature. private . minimum temperature before SA quit ; De",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1SimulatedAnnealingFitter.html:20065,adapt,adaptive,20065,doc/master/classTMVA_1_1SimulatedAnnealingFitter.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1SimulatedAnnealingFitter.html,2,['adapt'],['adaptive']
Energy Efficiency,"FoamCell.cxx. Member Function Documentation. ◆ CalcVolume(). void TMVA::PDEFoamCell::CalcVolume ; (; void ; ). Calculates volume of the cell using size params which are calculated. ; Definition at line 191 of file PDEFoamCell.cxx. ◆ Class(). static TClass * TMVA::PDEFoamCell::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TMVA::PDEFoamCell::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TMVA::PDEFoamCell::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 109 of file PDEFoamCell.h. ◆ DeclFileName(). static const char * TMVA::PDEFoamCell::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 109 of file PDEFoamCell.h. ◆ Fill(). void TMVA::PDEFoamCell::Fill ; (; Int_t ; status, . PDEFoamCell * ; parent, . PDEFoamCell * ; daugh1, . PDEFoamCell * ; daugh2 . ). Fills in certain data into newly allocated cell. ; Definition at line 120 of file PDEFoamCell.cxx. ◆ GetBest(). Int_t TMVA::PDEFoamCell::GetBest ; (; ); const. inline . Definition at line 78 of file PDEFoamCell.h. ◆ GetDau0(). PDEFoamCell * TMVA::PDEFoamCell::GetDau0 ; (; ); const. inline . Definition at line 94 of file PDEFoamCell.h. ◆ GetDau1(). PDEFoamCell * TMVA::PDEFoamCell::GetDau1 ; (; ); const. inline . Definition at line 95 of file PDEFoamCell.h. ◆ GetDepth(). UInt_t TMVA::PDEFoamCell::GetDepth ; (; ). Get depth of cell in binary tree, where the root cell has depth 1. ; Definition at line 207 of file PDEFoamCell.cxx. ◆ GetDriv(). Double_t TMVA::PDEFoamCell::GetDriv ; (; ); const. inline . Definition at line 87 of file PDEFoamCell.h. ◆ GetElement(). TObject * TMVA::PDEFoamCell::GetElement ; (; ); const. inline . Definition at line 107 of file PDEFoamCell.h. ◆ GetHcub(). void TMVA::PDEFoamCell::GetHcub ; (; PDEFoamVect & ; cellPosi, . PDEFoamVect & ; cellSize . ); const. Provides size and position of t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1PDEFoamCell.html:13836,allocate,allocated,13836,doc/master/classTMVA_1_1PDEFoamCell.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1PDEFoamCell.html,1,['allocate'],['allocated']
Energy Efficiency,"Functions |; Private Attributes |; List of all members ; ROOT::Math::OneDimParamFunctionAdapter< ParamFuncType > Class Template ReferenceMath » MathCore » Function Classes and Interfaces » Generic Function Evaluation Interfaces. ; template<class ParamFuncType = ROOT::Math::IParamMultiFunction &>; class ROOT::Math::OneDimParamFunctionAdapter< ParamFuncType >OneDimParamFunctionAdapter class to wrap a multi-dim parametric function in one dimensional one. ; Given a f(x[],p1,...pn) transforms in a f( p_i) given the param index i and the vectors x[] and p[] of the coordinates and parameters It has to be used carefully, since for efficiency reason it does not copy the parameter object but re-uses the given pointer for the p[] vector. The ParamFuncType reference by default is not const because the operator()(x,p) is not a const method ; Definition at line 213 of file OneDimFunctionAdapter.h. Public Member Functions;  OneDimParamFunctionAdapter (ParamFuncType f, const double *x, const double *p, unsigned int ipar=0);  Constructor from the function object , x value and coordinate we want to adapt. ;  ;  ~OneDimParamFunctionAdapter () override;  Destructor (no operations) ;  ; OneDimParamFunctionAdapter * Clone () const override;  clone ;  ;  Public Member Functions inherited from ROOT::Math::IBaseFunctionOneDim; virtual ~IBaseFunctionOneDim ()=default;  ; virtual bool HasGradient () const;  ; double operator() (const double *x) const;  Evaluate the function at a point x[]. ;  ; double operator() (double x) const;  Evaluate the function at a point x. ;  . Private Member Functions; double DoEval (double x) const override;  evaluate function at the values x[] given in the constructor and as function of the coordinate fCoord. ;  . Private Attributes; ParamFuncType fFunc;  ; unsigned int fIpar;  ; const double * fParams;  ; const double * fX;  . Additional Inherited Members;  Public Types inherited from ROOT::Math::IBaseFunctionOneDim; typedef IBaseFunctionOneDim BaseFunc;  . #inc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1OneDimParamFunctionAdapter.html:1334,adapt,adapt,1334,doc/master/classROOT_1_1Math_1_1OneDimParamFunctionAdapter.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1OneDimParamFunctionAdapter.html,1,['adapt'],['adapt']
Energy Efficiency,"Functions; double DoEval (double x) const override;  evaluate function at the values x[] given in the constructor and as function of the coordinate fCoord. ;  . Private Attributes; ParamFuncType fFunc;  ; unsigned int fIpar;  ; const double * fParams;  ; const double * fX;  . Additional Inherited Members;  Public Types inherited from ROOT::Math::IBaseFunctionOneDim; typedef IBaseFunctionOneDim BaseFunc;  . #include <Math/OneDimFunctionAdapter.h>. Inheritance diagram for ROOT::Math::OneDimParamFunctionAdapter< ParamFuncType >:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ OneDimParamFunctionAdapter(). template<class ParamFuncType = ROOT::Math::IParamMultiFunction &> . ROOT::Math::OneDimParamFunctionAdapter< ParamFuncType >::OneDimParamFunctionAdapter ; (; ParamFuncType ; f, . const double * ; x, . const double * ; p, . unsigned int ; ipar = 0 . ). inline . Constructor from the function object , x value and coordinate we want to adapt. ; Definition at line 221 of file OneDimFunctionAdapter.h. ◆ ~OneDimParamFunctionAdapter(). template<class ParamFuncType = ROOT::Math::IParamMultiFunction &> . ROOT::Math::OneDimParamFunctionAdapter< ParamFuncType >::~OneDimParamFunctionAdapter ; (; ). inlineoverride . Destructor (no operations) ; Definition at line 234 of file OneDimFunctionAdapter.h. Member Function Documentation. ◆ Clone(). template<class ParamFuncType = ROOT::Math::IParamMultiFunction &> . OneDimParamFunctionAdapter * ROOT::Math::OneDimParamFunctionAdapter< ParamFuncType >::Clone ; (; ); const. inlineoverridevirtual . clone ; Implements ROOT::Math::IBaseFunctionOneDim.; Definition at line 239 of file OneDimFunctionAdapter.h. ◆ DoEval(). template<class ParamFuncType = ROOT::Math::IParamMultiFunction &> . double ROOT::Math::OneDimParamFunctionAdapter< ParamFuncType >::DoEval ; (; double ; x); const. inlineoverrideprivatevirtual . evaluate function at the values x[] given in the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1OneDimParamFunctionAdapter.html:2856,adapt,adapt,2856,doc/master/classROOT_1_1Math_1_1OneDimParamFunctionAdapter.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1OneDimParamFunctionAdapter.html,1,['adapt'],['adapt']
Energy Efficiency,"GC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoMaterialEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for material editor. ~TGeoMaterialEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected material. void DoName(); Perform name change. void DoA(); Slot for atomic mass. void DoZ(); Slot for charge. void DoState(Int_t state); Slot for material state. void DoTemperature(); Slot for material temperature. void DoPressure(); Slot for material pressure. void DoDensity(); Slot for density.; fMatDensity->SetNumber(fDensityi);. void DoRadAbs(); Slot for radiation/absorbtion length. void DoApply(); Slot for applying modifications. void DoUndo(); Slot for cancelling current modifications. void DoModified(); Slot for signaling modifications. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoMaterialEditor.h 32718 2010-03-23 15:58:34Z rdm $ » Last generated: 2010-11-08 19:55; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoMaterialEditor.html:21489,charge,charge,21489,root/html528/TGeoMaterialEditor.html,https://root.cern,https://root.cern/root/html528/TGeoMaterialEditor.html,1,['charge'],['charge']
Energy Efficiency,"GC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoMaterialEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for material editor. ~TGeoMaterialEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected material. void DoName(); Perform name change. void DoA(); Slot for atomic mass. void DoZ(); Slot for charge. void DoState(Int_t state); Slot for material state. void DoTemperature(); Slot for material temperature. void DoPressure(); Slot for material pressure. void DoDensity(); Slot for density.; fMatDensity->SetNumber(fDensityi);. void DoRadAbs(); Slot for radiation/absorbtion length. void DoApply(); Slot for applying modifications. void DoUndo(); Slot for cancelling current modifications. void DoModified(); Slot for signaling modifications. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoMaterialEditor.h 32718 2010-03-23 15:58:34Z rdm $ » Last generated: 2011-07-04 15:31; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoMaterialEditor.html:21589,charge,charge,21589,root/html530/TGeoMaterialEditor.html,https://root.cern,https://root.cern/root/html530/TGeoMaterialEditor.html,1,['charge'],['charge']
Energy Efficiency,"GC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoMaterialEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for material editor. ~TGeoMaterialEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected material. void DoName(); Perform name change. void DoA(); Slot for atomic mass. void DoZ(); Slot for charge. void DoState(Int_t state); Slot for material state. void DoTemperature(); Slot for material temperature. void DoPressure(); Slot for material pressure. void DoDensity(); Slot for density.; fMatDensity->SetNumber(fDensityi);. void DoRadAbs(); Slot for radiation/absorbtion length. void DoApply(); Slot for applying modifications. void DoUndo(); Slot for cancelling current modifications. void DoModified(); Slot for signaling modifications. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoMaterialEditor.h 32718 2010-03-23 15:58:34Z rdm $ » Last generated: 2011-11-03 20:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoMaterialEditor.html:21589,charge,charge,21589,root/html532/TGeoMaterialEditor.html,https://root.cern,https://root.cern/root/html532/TGeoMaterialEditor.html,1,['charge'],['charge']
Energy Efficiency,"GFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoMaterialEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for material editor. ~TGeoMaterialEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected material. void DoName(); Perform name change. void DoA(); Slot for atomic mass. void DoZ(); Slot for charge. void DoState(Int_t state); Slot for material state. void DoTemperature(); Slot for material temperature. void DoPressure(); Slot for material pressure. void DoDensity(); Slot for density.; fMatDensity->SetNumber(fDensityi);. void DoRadAbs(); Slot for radiation/absorbtion length. void DoApply(); Slot for applying modifications. void DoUndo(); Slot for cancelling current modifications. void DoModified(); Slot for signaling modifications. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-03-14 16:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoMaterialEditor.html:21608,charge,charge,21608,root/html534/TGeoMaterialEditor.html,https://root.cern,https://root.cern/root/html534/TGeoMaterialEditor.html,1,['charge'],['charge']
Energy Efficiency,"Generate points along a X^3 with noise; TRandom rg;; rg.SetSeed(520);; for (Int_t i = 0; i < n; i++) {; x[i] = rg.Uniform(0, 1);; y[i] = TMath::Power(x[i], 3) + rg.Gaus() * 0.06;; }; ; TGraph *gr1 = new TGraph(n,x,y);; gr1->SetMarkerColor(kBlue);; gr1->SetMarkerStyle(8);; gr1->SetMarkerSize(1);; mg->Add(gr1);; ; // create second graph; TF1 *f_known=new TF1(""f_known"",""pow(x,3)"",0,1);; TGraph *gr2 = new TGraph(f_known);; gr2->SetMarkerColor(kRed);; gr2->SetMarkerStyle(8);; gr2->SetMarkerSize(1);; mg->Add(gr2);; ; //passing x and y values to R for fitting; ROOT::R::TRInterface &r=ROOT::R::TRInterface::Instance();; r[""x""]<<TVectorD(n, x);; r[""y""]<<TVectorD(n, y);; //creating a R data frame; r<<""ds<-data.frame(x=x,y=y)"";; //fitting x and y to X^power using Nonlinear Least Squares; r<<""m <- nls(y ~ I(x^power),data = ds, start = list(power = 1),trace = T)"";; //getting the fitted value (power); Double_t power;; r[""summary(m)$coefficients[1]""]>>power;; ; TF1 *f_fitted=new TF1(""f_fitted"",""pow(x,[0])"",0,1);; f_fitted->SetParameter(0,power);; //plotting the fitted function; TGraph *gr3 = new TGraph(f_fitted);; gr3->SetMarkerColor(kGreen);; gr3->SetMarkerStyle(8);; gr3->SetMarkerSize(1);; ; mg->Add(gr3);; mg->Draw(""ap"");; ; //displaying basic results; TPaveText *pt = new TPaveText(0.1,0.6,0.5,0.9,""brNDC"");; pt->SetFillColor(18);; pt->SetTextAlign(12);; pt->AddText(""Fitting x^power "");; pt->AddText("" \""Blue\"" Points with gaussian noise to be fitted"");; pt->AddText("" \""Red\"" Known function x^3"");; TString fmsg;; fmsg.Form("" \""Green\"" Fitted function with power=%.4lf"",power);; pt->AddText(fmsg);; pt->Draw();; c1->Update();; kRed@ kRedDefinition Rtypes.h:66; kGreen@ kGreenDefinition Rtypes.h:66; kBlue@ kBlueDefinition Rtypes.h:66; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; TVec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1R_1_1TRInterface.html:2328,power,power,2328,doc/master/classROOT_1_1R_1_1TRInterface.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1R_1_1TRInterface.html,7,['power'],['power']
Energy Efficiency,"GeoTranslation(-0.2,0,0));; chamber->AddNode(wire_co, 2, new TGeoTranslation(0.2,0,0));. The 2 nodes that we have created inside chamber will both point to a wire_co; object, but will be completely distinct : WIRE_CO_1 and WIRE_CO_2. We will; want now to place symetrically 1000 chambers on a pad, following a pattern; of 20 rows and 50 columns. One way to do this will be to replicate our chamber; by positioning it 1000 times in different positions of the pad. Unfortunatelly,; this is far from being the optimal way of doing what we want.; Imagine that we would like to find out which of the 1000 chambers is containing; a (x,y,z) point defined in the pad reference. You will never have to do that,; since the modeller will take care of it for you, but let's guess what it has; to do. The most simple algorithm will just loop over all daughters, convert; the point from mother to local reference and check if the current chamber; contains the point or not. This might be efficient for pads with few chambers,; but definitely not for 1000. Fortunately the modeler is smarter than that and; create for each volume some optimization structures called voxels (see Voxelization); to minimize the penalty having too many daughters, but if you have 100 pads like; this in your geometry you will anyway loose a lot in your tracking performance. The way out when volumes can be arranged according to simple patterns is the; usage of divisions. We will describe them in detail later on. Let's think now; at a different situation : instead of 1000 chambers of the same type, we may; have several types of chambers. Let's say all chambers are cylindrical and have; a wire inside, but their dimensions are different. However, we would like all; to be represented by a single volume family, since they have the same properties. Volume families (TGeoVolumeMulti). A volume family is represented by the class TGeoVolumeMulti. It represents; a class of volumes having the same shape type and each member will be; i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoVolume.html:9605,efficient,efficient,9605,root/html534/TGeoVolume.html,https://root.cern,https://root.cern/root/html534/TGeoVolume.html,9,['efficient'],['efficient']
Energy Efficiency,"GeoTranslation(0.2,0,0));; TGeoTranslationClass describing translations.Definition TGeoMatrix.h:116; The 2 nodes that we have created inside chamber will both point to a wire_co object, but will be completely distinct : WIRE_CO_1 and WIRE_CO_2. We will want now to place symmetrically 1000 chambers on a pad, following a pattern of 20 rows and 50 columns. One way to do this will be to replicate our chamber by positioning it 1000 times in different positions of the pad. Unfortunately, this is far from being the optimal way of doing what we want. Imagine that we would like to find out which of the 1000 chambers is containing a (x,y,z) point defined in the pad reference. You will never have to do that, since the modeller will take care of it for you, but let's guess what it has to do. The most simple algorithm will just loop over all daughters, convert the point from mother to local reference and check if the current chamber contains the point or not. This might be efficient for pads with few chambers, but definitely not for 1000. Fortunately the modeler is smarter than that and create for each volume some optimization structures called voxels (see Voxelization) to minimize the penalty having too many daughters, but if you have 100 pads like this in your geometry you will anyway loose a lot in your tracking performance.; The way out when volumes can be arranged according to simple patterns is the usage of divisions. We will describe them in detail later on. Let's think now at a different situation : instead of 1000 chambers of the same type, we may have several types of chambers. Let's say all chambers are cylindrical and have a wire inside, but their dimensions are different. However, we would like all to be represented by a single volume family, since they have the same properties. ; Definition at line 43 of file TGeoVolume.h. Public Types; enum  EGeoVolumeTypes { ;   kVolumeReplicated = (1ULL << ( 14 )); , kVolumeSelected = (1ULL << ( 15 )); , kVolumeDiv = (1ULL << ( 1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoVolume.html:10547,efficient,efficient,10547,doc/master/classTGeoVolume.html,https://root.cern,https://root.cern/doc/master/classTGeoVolume.html,1,['efficient'],['efficient']
Energy Efficiency,GetSenderClassName () const;  ;  Protected Member Functions inherited from TGWidget;  TGWidget (const TGWidget &tgw);  ; Int_t ClearFlags (Int_t flags);  ; TGWidget & operator= (const TGWidget &tgw);  ; Int_t SetFlags (Int_t flags);  . Protected Attributes; Float_t fAngle;  ; Float_t fAngleMax;  needle min and max angle ;  ; Float_t fAngleMin;  ; const TGPicture * fBase;  picture used as background ;  ; std::vector< Float_t > fBuffer;  circular buffer for mean calculation ;  ; Int_t fBufferCount;  circular buffer count ;  ; Int_t fBufferSize;  circular buffer size ;  ; Int_t fCounter;  small odo meter (4 digits) ;  ; FontStruct_t fCounterFS;  font structures for text rendering ;  ; TString fDisplay1;  first line in the small display ;  ; TString fDisplay2;  second line in the small display ;  ; TImage * fImage;  image used as background ;  ; TImage * fImage2;  intermediate image used as background ;  ; TString fLabel1;  main label (first line) ;  ; TString fLabel2;  main label (second line) ;  ; Bool_t fMeanMark;  kTRUE if mean mark is active ;  ; Float_t fMeanVal;  mean value mark ;  ; Bool_t fPeakMark;  kTRUE if peak mark is active ;  ; Float_t fPeakVal;  maximum peak mark ;  ; TString fPicName;  name of picture used as background ;  ; Float_t fScaleMax;  needle min and max scale ;  ; Float_t fScaleMin;  ; FontStruct_t fTextFS;  ; Float_t fThreshold [3];  glowing thresholds ;  ; Bool_t fThresholdActive;  kTRUE if glowing thresholds are active ;  ; EGlowColor fThresholdColor [3];  glowing threshold colors ;  ; Float_t fValue;  needle angle and corresponding value ;  ;  Protected Attributes inherited from TGFrame; Pixel_t fBackground;  frame background color ;  ; Int_t fBorderWidth;  frame border width ;  ; Int_t fDNDState;  EDNDFlags. ;  ; UInt_t fEventMask;  currently active event mask ;  ; TGFrameElement * fFE;  pointer to frame element ;  ; UInt_t fHeight;  frame height ;  ; UInt_t fMaxHeight;  maximal frame height ;  ; UInt_t fMaxWidth;  maximal frame width ;  ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGSpeedo.html:27271,meter,meter,27271,doc/master/classTGSpeedo.html,https://root.cern,https://root.cern/doc/master/classTGSpeedo.html,1,['meter'],['meter']
Energy Efficiency,"Github ssh key . ; Git Tips and Tricks . ; Git How Tos . ; A suggested work flow for distributed projects: NoSY . ; Browse Sources . ; Meetings . ; ROOT 7 . ; Run the tests . ; Setup externals from AFS/CVMFS . ; Jenkins . ; Doxygen . ; Benchmarks . ; Contribute . ; Collaborate with Us . You are hereHome » Development Formatting Comments for Doxygen. The ROOT team has adopted Doxygen for generating the reference manual. Here you will find a number of conventions and tips for converting the existing source code to generate proper documentation.; How to generate the doxygen documentation; Developers may generate the documentation by hand to see the results of the current changes before committing them to the repository. The automatic daily Jenkins procedures will generate the complete set of documentation.; $ cd <root_sources>/documentation/doxygen ; $ make . The results are placed by default at ${HOME}/rootdoc/html. The file documentation/doxygen/Doxyfile can be edited to reduce the number of input files and thus reduce the time for generating the HTML pages. The property to be modified is INPUT = ../../<module>; General Guidelines; Classes and methods can be documented both in the .cxx and .h files. For the long descriptions of a class functionality and its methods we usually prefer the .cxx file.; Class documentation; The documentation for the class is in general located at the beginning of the .cxx file. The \class Doxygen command is mandatory otherwise Doxygen will not associate the comments to the proper class. The first sentence is a brief description of the class and will appear in all class listings. For an example see the TF2 class documentation:; /** \class TF2; A 2-Dim function with parameters;  ; TF2 graphics function is via the TH1 drawing functions.; Example of a function;  ; TF2 *f2 = new TF2(""f2"",""sin(x)*sin(y)/(x*y)"",0,5,0,5);; f2->Draw();;  ; \image html tf2_function2.png; See TF1 class for the list of functions formats; */; Method documentation; Met",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/formatting-comments-doxygen.html:2546,reduce,reduce,2546,d/formatting-comments-doxygen.html,https://root.cern,https://root.cern/d/formatting-comments-doxygen.html,2,['reduce'],['reduce']
Energy Efficiency,"GradientCalculator;  CBasicFunctionGradient;  ►CBasicFunctionMinimumResult of the minimization; both internal and external (MnUserParameterState) representation available For the parameters at the Minimum ;  CMnAboveMaxEdm;  CMnReachedCallLimit;  ►CBasicMinimumErrorInternal Class containing the error information on the estimated minimum : Error matrix + dcovar + additional flags for quality and validity checks ;  CMnHesseFailed;  CMnInvertFailed;  CMnMadePosDef;  CMnNotPosDef;  CBasicMinimumParameters;  CBasicMinimumSeed;  CBasicMinimumState;  CCombinedMinimizerCombined minimizer: combination of Migrad and Simplex ;  CCombinedMinimumBuilder;  CContoursError;  CDavidonErrorUpdatorUpdate of the covariance matrix for the Variable Metric minimizer (MIGRAD) ;  CFCNAdapterTemplate wrapped class for adapting to FCNBase signature ;  CFCNBaseInterface (abstract class) defining the function to be minimized, which has to be implemented by the user ;  CFCNGradAdapterTemplate wrapped class for adapting to FCNBase signature a IGradFunction ;  CFCNGradientBaseExtension of the FCNBase for providing the analytical Gradient of the function ;  CFlatRandomGen;  CFumiliBuilderBuilds the FunctionMinimum using the Fumili method ;  CFumiliChi2FCNExtension of the FCNBase for the Fumili method ;  CFumiliErrorUpdatorIn the case of the Fumili algorithm the Error matrix (or the Hessian matrix containing the (approximate) second derivatives) is calculated using a linearization of the model function negleting second derivatives ;  CFumiliFCNAdapterTemplate wrapped class for adapting to FumiliFCNBase signature ;  CFumiliFCNBaseExtension of the FCNBase for the Fumili method ;  CFumiliGradientCalculator;  CFumiliMaximumLikelihoodFCNExtension of the FCNBase for the Fumili method ;  CFumiliMinimizerInstantiates the seed generator and Minimum builder for the Fumili minimization method ;  CFumiliStandardChi2FCNClass implementing the standard chi square function, which is the sum of the squares of the fig",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/annotated.html:55329,adapt,adapting,55329,doc/v608/annotated.html,https://root.cern,https://root.cern/doc/v608/annotated.html,3,['adapt'],['adapting']
Energy Efficiency,"GradientCalculator;  CBasicFunctionGradient;  ►CBasicFunctionMinimumResult of the minimization; both internal and external (MnUserParameterState) representation available For the parameters at the Minimum ;  CMnAboveMaxEdm;  CMnReachedCallLimit;  ►CBasicMinimumErrorInternal Class containing the error information on the estimated minimum : Error matrix + dcovar + additional flags for quality and validity checks ;  CMnHesseFailed;  CMnInvertFailed;  CMnMadePosDef;  CMnNotPosDef;  CBasicMinimumParameters;  CBasicMinimumSeed;  CBasicMinimumState;  CCombinedMinimizerCombined minimizer: combination of Migrad and Simplex ;  CCombinedMinimumBuilder;  CContoursError;  CDavidonErrorUpdatorUpdate of the covariance matrix for the Variable Metric minimizer (MIGRAD) ;  CFCNAdapterTemplate wrapped class for adapting to FCNBase signature ;  CFCNBaseInterface (abstract class) defining the function to be minimized, which has to be implemented by the user ;  CFCNGradAdapterTemplate wrapped class for adapting to FCNBase signature a IGradFunction ;  CFCNGradientBaseExtension of the FCNBase for providing the analytical Gradient of the function ;  CFumiliBuilderBuilds the FunctionMinimum using the Fumili method ;  CFumiliChi2FCNExtension of the FCNBase for the Fumili method ;  CFumiliErrorUpdatorIn the case of the Fumili algorithm the Error matrix (or the Hessian matrix containing the (approximate) second derivatives) is calculated using a linearization of the model function negleting second derivatives ;  CFumiliFCNAdapterTemplate wrapped class for adapting to FumiliFCNBase signature ;  CFumiliFCNBaseExtension of the FCNBase for the Fumili method ;  CFumiliGradientCalculator;  CFumiliMaximumLikelihoodFCNExtension of the FCNBase for the Fumili method ;  CFumiliMinimizerInstantiates the seed generator and Minimum builder for the Fumili minimization method ;  CFumiliStandardChi2FCNClass implementing the standard chi square function, which is the sum of the squares of the figures-of-merit cal",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/annotated.html:61837,adapt,adapting,61837,doc/v612/annotated.html,https://root.cern,https://root.cern/doc/v612/annotated.html,1,['adapt'],['adapting']
Energy Efficiency,"Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Types |; Public Member Functions |; Static Public Member Functions |; Protected Member Functions |; Private Member Functions |; Private Attributes |; List of all members ; ROOT::Math::IntegratorOneDim Class ReferenceMath » MathCore | Math » MathMore » Numerical Algorithms » Numerical Integration. ; User Class for performing numerical integration of a function in one dimension. ; It uses the plug-in manager to load advanced numerical integration algorithms from GSL, which reimplements the algorithms used in the QUADPACK, a numerical integration package written in Fortran.; Various types of adaptive and non-adaptive integration are supported. These include integration over infinite and semi-infinite ranges and singular integrals.; The integration type is selected using the Integration::type enumeration in the class constructor. The default type is adaptive integration with singularity (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule. In the case of ADAPTIVE type, the integration rule can also be specified via the Integration::GKRule. The default rule is 31 points.; In the case of integration over infinite and semi-infinite ranges, the type used is always ADAPTIVESINGULAR applying a transformation from the original interval into (0,1).; The ADAPTIVESINGULAR type is the most sophisticated type. When performances are important, it is then recommended to use the NONADAPTIVE type in case of smooth functions or ADAPTIVE with a lower Gauss-Kronrod rule.; For detailed description on GSL integration algorithms see the GSL Manual. ; Definition at line 98 of file Integrator.h. Public Types; typedef IntegrationOneDim::Type Type;  . Public Member Functions;  IntegratorOneDim (const IGenFunction &f, IntegrationOneDim::Type type=IntegrationOneDim::kDEFAULT, double absTol=-1, double relTol=-1, unsigned int size=0, int rule=0);  Constructor of one di",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1IntegratorOneDim.html:1023,adapt,adaptive,1023,doc/master/classROOT_1_1Math_1_1IntegratorOneDim.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1IntegratorOneDim.html,1,['adapt'],['adaptive']
Energy Efficiency,HistogramMask. protected . Bit pattern of histograms used. ; Definition at line 97 of file TMultiDimFit.h. ◆ fHistograms. TList* TMultiDimFit::fHistograms. protected . List of histograms. ; Definition at line 96 of file TMultiDimFit.h. ◆ fIsUserFunction. Bool_t TMultiDimFit::fIsUserFunction. protected . Flag for user defined function. ; Definition at line 105 of file TMultiDimFit.h. ◆ fIsVerbose. Bool_t TMultiDimFit::fIsVerbose. protected . Definition at line 106 of file TMultiDimFit.h. ◆ fMaxAngle. Double_t TMultiDimFit::fMaxAngle. protected . Max angle for accepting new function. ; Definition at line 51 of file TMultiDimFit.h. ◆ fMaxFuncNV. Int_t TMultiDimFit::fMaxFuncNV. protected . fMaxFunctions*fNVariables ; Definition at line 62 of file TMultiDimFit.h. ◆ fMaxFunctions. Int_t TMultiDimFit::fMaxFunctions. protected . max number of functions ; Definition at line 59 of file TMultiDimFit.h. ◆ fMaxPowers. Int_t* TMultiDimFit::fMaxPowers. protected . [fNVariables] maximum powers ; Definition at line 54 of file TMultiDimFit.h. ◆ fMaxPowersFinal. Int_t* TMultiDimFit::fMaxPowersFinal. protected . [fNVariables] maximum powers from fit; ; Definition at line 68 of file TMultiDimFit.h. ◆ fMaxQuantity. Double_t TMultiDimFit::fMaxQuantity. protected . Max value of dependent quantity. ; Definition at line 31 of file TMultiDimFit.h. ◆ fMaxResidual. Double_t TMultiDimFit::fMaxResidual. protected . Max residual value. ; Definition at line 73 of file TMultiDimFit.h. ◆ fMaxResidualRow. Int_t TMultiDimFit::fMaxResidualRow. protected . Row giving max residual. ; Definition at line 75 of file TMultiDimFit.h. ◆ fMaxStudy. Int_t TMultiDimFit::fMaxStudy. protected . max functions to study ; Definition at line 61 of file TMultiDimFit.h. ◆ fMaxTerms. Int_t TMultiDimFit::fMaxTerms. protected . Max terms expected in final expr. ; Definition at line 52 of file TMultiDimFit.h. ◆ fMaxVariables. TVectorD TMultiDimFit::fMaxVariables. protected . max value of independent variables ; Definition at l,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMultiDimFit.html:63443,power,powers,63443,doc/master/classTMultiDimFit.html,https://root.cern,https://root.cern/doc/master/classTMultiDimFit.html,1,['power'],['powers']
Energy Efficiency,"I(Double_t x, Double_t par); compute the Poisson distribution function for (x,par); This is a non-smooth function.; This function is equivalent to ROOT::Math::poisson_pdf. /*. */. Double_t Prob(Double_t chi2, Int_t ndf); Computation of the probability for a certain Chi-squared (chi2); and number of degrees of freedom (ndf). Calculations are based on the incomplete gamma function P(a,x),; where a=ndf/2 and x=chi2/2. P(a,x) represents the probability that the observed Chi-squared; for a correct model should be less than the value chi2. The returned probability corresponds to 1-P(a,x),; which denotes the probability that an observed Chi-squared exceeds; the value chi2 by chance, even for a correct model. --- NvE 14-nov-1998 UU-SAP Utrecht. Double_t KolmogorovProb(Double_t z); Calculates the Kolmogorov distribution function,. /*; ; */. which gives the probability that Kolmogorov's test statistic will exceed; the value z assuming the null hypothesis. This gives a very powerful; test for comparing two one-dimensional distributions.; see, for example, Eadie et al, ""statistocal Methods in Experimental; Physics', pp 269-270). This function returns the confidence level for the null hypothesis, where:; z = dn*sqrt(n), and; dn is the maximum deviation between a hypothetical distribution; function and an experimental distribution with; n events. NOTE: To compare two experimental distributions with m and n events,; use z = sqrt(m*n/(m+n))*dn. Accuracy: The function is far too accurate for any imaginable application.; Probabilities less than 10^-15 are returned as zero.; However, remember that the formula is only valid for ""large"" n.; Theta function inversion formula is used for z <= 1. This function was translated by Rene Brun from PROBKL in CERNLIB. Double_t KolmogorovTest(Int_t na, const Double_t* a, Int_t nb, const Double_t* b, Option_t* option); Statistical test whether two one-dimensional sets of points are compatible; with coming from the same parent distribution, using the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMath.html:16412,power,powerful,16412,root/html528/TMath.html,https://root.cern,https://root.cern/root/html528/TMath.html,6,['power'],['powerful']
Energy Efficiency,"IB routine PERMU. ;  ; constexpr Double_t Pi ();  \( \pi\) ;  ; constexpr Double_t PiOver2 ();  \( \frac{\pi}{2} \) ;  ; constexpr Double_t PiOver4 ();  \( \frac{\pi}{4} \) ;  ; Double_t Poisson (Double_t x, Double_t par);  Computes the Poisson distribution function for (x,par). ;  ; Double_t PoissonI (Double_t x, Double_t par);  Computes the Discrete Poisson distribution function for (x,par). ;  ; Double_t Power (Double_t x, Double_t y);  Returns x raised to the power y. ;  ; Double_t Power (Double_t x, Int_t y);  Returns x raised to the power y. ;  ; LongDouble_t Power (Long64_t x, Long64_t y);  Returns x raised to the power y. ;  ; LongDouble_t Power (LongDouble_t x, Long64_t y);  Returns x raised to the power y. ;  ; LongDouble_t Power (LongDouble_t x, LongDouble_t y);  Returns x raised to the power y. ;  ; Double_t Prob (Double_t chi2, Int_t ndf);  Computation of the probability for a certain Chi-squared (chi2) and number of degrees of freedom (ndf). ;  ; constexpr Double_t Qe ();  Elementary charge in \( C \) . ;  ; constexpr Double_t QeUncertainty ();  Elementary charge uncertainty. ;  ; void Quantiles (Int_t n, Int_t nprob, Double_t *x, Double_t *quantiles, Double_t *prob, Bool_t isSorted=kTRUE, Int_t *index=nullptr, Int_t type=7);  Computes sample quantiles, corresponding to the given probabilities. ;  ; Double_t QuietNaN ();  Returns a quiet NaN as defined by IEEE 754. ;  ; constexpr Double_t R ();  Universal gas constant ( \( Na K \)) in \( J K^{-1} mol^{-1} \) ;  ; constexpr Double_t RadToDeg ();  Conversion from radian to degree: \( \frac{180}{\pi} \). ;  ; Double_t Range (Double_t lb, Double_t ub, Double_t x);  Returns x if lb < x < up, lb if x < lb and ub if x > ub. ;  ; Int_t Range (Int_t lb, Int_t ub, Int_t x);  Returns x if lb < x < up, lb if x < lb and ub if x > ub. ;  ; Long_t Range (Long_t lb, Long_t ub, Long_t x);  Returns x if lb < x < up, lb if x < lb and ub if x > ub. ;  ; Short_t Range (Short_t lb, Short_t ub, Short_t x);  Returns x if lb < ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceTMath.html:17614,charge,charge,17614,doc/master/namespaceTMath.html,https://root.cern,https://root.cern/doc/master/namespaceTMath.html,1,['charge'],['charge']
Energy Efficiency,"INGS IN THE; 23 * SOFTWARE.; 24 *; 25 * Except as contained in this notice, the name of Silicon Graphics, Inc.; 26 * shall not be used in advertising or otherwise to promote the sale, use or; 27 * other dealings in this Software without prior written authorization from; 28 * Silicon Graphics, Inc.; 29 */; 30/*; 31** Author: Eric Veach, July 1994.; 32**; 33*/; 34 ; 35#include ""gluos.h""; 36#include <stddef.h>; 37#include <assert.h>; 38#include ""mesh.h""; 39#include ""memalloc.h""; 40 ; 41#ifndef TRUE; 42#define TRUE 1; 43#endif; 44#ifndef FALSE; 45#define FALSE 0; 46#endif; 47 ; 48static GLUvertex *allocVertex(); 49{; 50 return (GLUvertex *)memAlloc( sizeof( GLUvertex ));; 51}; 52 ; 53static GLUface *allocFace(); 54{; 55 return (GLUface *)memAlloc( sizeof( GLUface ));; 56}; 57 ; 58/************************ Utility Routines ************************/; 59 ; 60/* MakeEdge creates a new pair of half-edges which form their own loop.; 61 * No vertex or face structures are allocated, but these must be assigned; 62 * before the current edge operation is completed.; 63 */; 64static GLUhalfEdge *MakeEdge( GLUhalfEdge *eNext ); 65{; 66 GLUhalfEdge *e;; 67 GLUhalfEdge *eSym;; 68 GLUhalfEdge *ePrev;; 69 EdgePair *pair = (EdgePair *)memAlloc( sizeof( EdgePair ));; 70 if (pair == NULL) return NULL;; 71 ; 72 e = &pair->e;; 73 eSym = &pair->eSym;; 74 ; 75 /* Make sure eNext points to the first edge of the edge pair */; 76 if( eNext->Sym < eNext ) { eNext = eNext->Sym; }; 77 ; 78 /* Insert in circular doubly-linked list before eNext.; 79 * Note that the prev pointer is stored in Sym->next.; 80 */; 81 ePrev = eNext->Sym->next;; 82 eSym->next = ePrev;; 83 ePrev->Sym->next = e;; 84 e->next = eNext;; 85 eNext->Sym->next = eSym;; 86 ; 87 e->Sym = eSym;; 88 e->Onext = e;; 89 e->Lnext = eSym;; 90 e->Org = NULL;; 91 e->Lface = NULL;; 92 e->winding = 0;; 93 e->activeRegion = NULL;; 94 ; 95 eSym->Sym = e;; 96 eSym->Onext = eSym;; 97 eSym->Lnext = e;; 98 eSym->Org = NULL;; 99 eSym->Lface = NULL;; 100 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/mesh_8c_source.html:2484,allocate,allocated,2484,doc/master/mesh_8c_source.html,https://root.cern,https://root.cern/doc/master/mesh_8c_source.html,1,['allocate'],['allocated']
Energy Efficiency,"IT > . void ROOT::Math::LorentzVector< CoordSystem >::GetCoordinates ; (; IT ; begin, . IT ; end . ); const. inline . get internal data into 4 Scalars at *begin to *end ; Definition at line 218 of file LorentzVector.h. ◆ GetCoordinates() [3/4]. template<class CoordSystem > . void ROOT::Math::LorentzVector< CoordSystem >::GetCoordinates ; (; Scalar & ; a, . Scalar & ; b, . Scalar & ; c, . Scalar & ; d . ); const. inline . get internal data into 4 Scalar numbers ; Definition at line 205 of file LorentzVector.h. ◆ GetCoordinates() [4/4]. template<class CoordSystem > . void ROOT::Math::LorentzVector< CoordSystem >::GetCoordinates ; (; Scalar ; dest[]); const. inline . get internal data into an array of 4 Scalar numbers ; Definition at line 211 of file LorentzVector.h. ◆ isLightlike(). template<class CoordSystem > . bool ROOT::Math::LorentzVector< CoordSystem >::isLightlike ; (; Scalar ; tolerance = 100*std::numeric_limits<Scalar>::epsilon()); const. inline . Determine if momentum-energy can represent a massless particle. ; Definition at line 535 of file LorentzVector.h. ◆ isSpacelike(). template<class CoordSystem > . bool ROOT::Math::LorentzVector< CoordSystem >::isSpacelike ; (; ); const. inline . Determine if momentum-energy is spacelike, and represents a tachyon. ; Definition at line 545 of file LorentzVector.h. ◆ isTimelike(). template<class CoordSystem > . bool ROOT::Math::LorentzVector< CoordSystem >::isTimelike ; (; ); const. inline . Determine if momentum-energy can represent a physical massive particle. ; Definition at line 528 of file LorentzVector.h. ◆ M(). template<class CoordSystem > . Scalar ROOT::Math::LorentzVector< CoordSystem >::M ; (; ); const. inline . return magnitude (mass) using the (-,-,-,+) metric. ; If M2 is negative (space-like vector) a GenVector_exception is suggested and if continuing, - sqrt( -M2) is returned ; Definition at line 306 of file LorentzVector.h. ◆ M2(). template<class CoordSystem > . Scalar ROOT::Math::LorentzVector< CoordSyst",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1LorentzVector.html:17682,energy,energy,17682,doc/master/classROOT_1_1Math_1_1LorentzVector.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1LorentzVector.html,1,['energy'],['energy']
Energy Efficiency,"Initial Length of fEntryOffset table in the basket buffers; TDirectory*TTree::fDirectory! Pointer to directory holding this tree; TDrawFeedback*fDrawFeedbackfeedback handler; Long64_tTTree::fEntriesNumber of entries; TEntryList*TTree::fEntryList! Pointer to event selection list (if one); Long64_tTTree::fEstimateNumber of entries to estimate histogram limits; TEventList*TTree::fEventList! Pointer to event selection list (if one); TFile*TChain::fFile! Pointer to current file (We own the file).; Int_tTTree::fFileNumber! current file number (if file extensions); TObjArray*TChain::fFiles-> List of file names containing the trees (TChainElement, owned); Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; Long64_tTTree::fFlushedBytesNumber of autoflushed bytes; UInt_tTTree::fFriendLockStatus! Record which method is locking the friend recursion; TList*TTree::fFriendspointer to list of friend elements; TArrayITTree::fIndexIndex of sorted values; TArrayDTTree::fIndexValuesSorted index values; TObjArrayTTree::fLeavesDirect pointers to individual branch leaves; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; Int_tTTree::fMakeClass! not zero when processing code generated by MakeClass; Color_tTAttMarker::fMarkerColorMarker color index; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; Int_tTTree::fMaxClusterRange! Memory allocated for the cluster range.; Long64_tTTree::fMaxEntriesMaximum number of entries in case of circular buffers; Long64_tTTree::fMaxEntryLoopMaximum number of entries to process; Long64_tTTree::fMaxVirtualSizeMaximum total size of buffers kept in memory; Int_tTTree::fNClusterRangeNumber of Cluster range in addition to the one defined by 'AutoFlush'; TStringTNamed::fNameobject identifier; Int_tTTree::fNfill! Local for EntryLoop; TObject*TTree::fNotify! Object to be notified when loading a Tree; Int_tTChain::fNtreesNumber ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TProofChain.html:24634,allocate,allocated,24634,root/html530/TProofChain.html,https://root.cern,https://root.cern/root/html530/TProofChain.html,2,['allocate'],['allocated']
Energy Efficiency,"Int_t col, float* v, Int_t n = -1) const; Store in array v, n matrix elements of row rown starting at column coln. void TMatrixTSparse<Element> AMultBt(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMultBt(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMultBt(const TMatrixT<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixT<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> GetMatrix2Array(float* data, Option_t* = """") const; Copy ma",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMatrixTSparse_float_.html:18212,allocate,allocated,18212,root/html528/TMatrixTSparse_float_.html,https://root.cern,https://root.cern/root/html528/TMatrixTSparse_float_.html,6,['allocate'],['allocated']
Energy Efficiency,"Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMultBt(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMultBt(const TMatrixT<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixT<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> GetMatrix2Array(double* data, Option_t* = """") const; Copy matrix data to array . It is assumed that array is of size >= fNelems. TMatrixTBase<Element> &TMatrixTSparse<Element> SetMatrixArray(Int_t nr_nonzeros, Int_t* irow, Int_t* icol, double* data); Copy nr elements from row/",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMatrixTSparse_double_.html:18647,allocate,allocated,18647,root/html528/TMatrixTSparse_double_.html,https://root.cern,https://root.cern/root/html528/TMatrixTSparse_double_.html,6,['allocate'],['allocated']
Energy Efficiency,"Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMultBt(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMultBt(const TMatrixT<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixT<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> GetMatrix2Array(float* data, Option_t* = """") const; Copy matrix data to array . It is assumed that array is of size >= fNelems. TMatrixTBase<Element> &TMatrixTSparse<Element> SetMatrixArray(Int_t nr_nonzeros, Int_t* irow, Int_t* icol, float* data); Copy nr elements from row/co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMatrixTSparse_float_.html:18430,allocate,allocated,18430,root/html528/TMatrixTSparse_float_.html,https://root.cern,https://root.cern/root/html528/TMatrixTSparse_float_.html,6,['allocate'],['allocated']
Energy Efficiency,"Int_t left, Bool_t force); voidWriteItems(int nElements, TBuffer& b). private:. TEmulatedCollectionProxy&operator=(const TEmulatedCollectionProxy&). Data Members; public:. enum TGenCollectionProxy::[unnamed] { kBIT_ISSTRING; kBIT_ISTSTRING; kBOOL_t; };; enum TVirtualCollectionProxy::EProperty { kIsInitialized; kIsAssociative; kIsEmulated; kNeedDelete; };. public:. static const Int_tTVirtualCollectionProxy::fgIteratorArenaSizegreater than sizeof(void*) + sizeof(UInt_t). protected:. TClassRefTVirtualCollectionProxy::fClass; TGenCollectionProxy::MethodTGenCollectionProxy::fClearMethod cache for container accessors: clear container; void*TGenCollectionProxy::fCollectMethod to collect objects from container; void*TGenCollectionProxy::fConstructContainer accessors: block construct; map<std::string,TObjArray*>*TGenCollectionProxy::fConversionReadMemberWiseArray of bundle of TStreamerInfoActions to stream out (read) derived from another class.; TGenCollectionProxy::Method0TGenCollectionProxy::fCreateEnvMethod to allocate an Environment holder.; void*TGenCollectionProxy::fDestructContainer accessors: block destruct; ROOT::TCollectionProxyInfo::EnvironBase*TGenCollectionProxy::fEnvAddress of the currently proxied object; void*TGenCollectionProxy::fFeedContainer accessors: block feed; TGenCollectionProxy::MethodTGenCollectionProxy::fFirstContainer accessors: generic iteration: first; void*TGenCollectionProxy::fFunctionCopyIterator; void*TGenCollectionProxy::fFunctionCreateIterators; void*TGenCollectionProxy::fFunctionDeleteIterator; void*TGenCollectionProxy::fFunctionDeleteTwoIterators; void*TGenCollectionProxy::fFunctionNextIterator; TGenCollectionProxy::Value*TGenCollectionProxy::fKeyDescriptor of the key_type; stringTGenCollectionProxy::fNameName of the class being proxied.; TGenCollectionProxy::MethodTGenCollectionProxy::fNextContainer accessors: generic iteration: next; TClass*TGenCollectionProxy::fOnFileClassOn file class; Bool_tTGenCollectionProxy::fPointersFlag to indi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TEmulatedCollectionProxy.html:4867,allocate,allocate,4867,root/html534/TEmulatedCollectionProxy.html,https://root.cern,https://root.cern/root/html534/TEmulatedCollectionProxy.html,1,['allocate'],['allocate']
Energy Efficiency,"Int_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. TMonaLisaValue(const TMonaLisaValue&); TMonaLisaValue&operator=(const TMonaLisaValue&). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Double_tfValuedouble monitor value. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMonaLisaValue(const TMonaLisaValue& ). TMonaLisaValue& operator=(const TMonaLisaValue& ). TMonaLisaValue(const char* name, Double_t value); { }. virtual ~TMonaLisaValue(); { }. Double_t GetValue() const; { return fValue; }. Double_t * GetValuePtr(); { return &fValue; }. » Author: Andreas Peters 5/10/2005 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/monalisa:$Id: TMonaLisaWriter.h 23209 2008-04-14 13:25:09Z rdm $ » Last generated: 2011-07-04 15:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMonaLisaValue.html:6230,monitor,monitor,6230,root/html530/TMonaLisaValue.html,https://root.cern,https://root.cern/root/html530/TMonaLisaValue.html,1,['monitor'],['monitor']
Energy Efficiency,"Int_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. TMonaLisaValue(const TMonaLisaValue&); TMonaLisaValue&operator=(const TMonaLisaValue&). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Double_tfValuedouble monitor value. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMonaLisaValue(const TMonaLisaValue& ). TMonaLisaValue& operator=(const TMonaLisaValue& ). TMonaLisaValue(const char* name, Double_t value); { }. virtual ~TMonaLisaValue(); { }. Double_t GetValue() const; { return fValue; }. Double_t * GetValuePtr(); { return &fValue; }. » Author: Andreas Peters 5/10/2005 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/monalisa:$Id: TMonaLisaWriter.h 23209 2008-04-14 13:25:09Z rdm $ » Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMonaLisaValue.html:6230,monitor,monitor,6230,root/html532/TMonaLisaValue.html,https://root.cern,https://root.cern/root/html532/TMonaLisaValue.html,1,['monitor'],['monitor']
Energy Efficiency,"Int_tTObject::TestBits(UInt_t f) const; const char*URL() const; virtual voidTObject::UseCurrentStyle(); const char*Version() const; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. TXMLDocument(const TXMLDocument&); TXMLDocument&operator=(const TXMLDocument&). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. TXMLNode*fRootNodethe root node ; _xmlDoc*fXMLDoclibxml xml doc. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TXMLDocument(_xmlDoc* doc); TXMLDocument constructor. ~TXMLDocument(); TXMLDocument destructor.; Free the global variables that may; have been allocated by the parser. TXMLNode * GetRootNode() const; Returns the root element node. const char * Version() const; Returns the XML version string or 0 in case there is no document set. const char * Encoding() const; Returns external initial encoding, if any or 0 in case there is no; document set. const char * URL() const; Returns the URI for the document or 0 in case there is no document set. TXMLDocument(const TXMLDocument& ). TXMLDocument& operator=(const TXMLDocument& ). » Author: Jose Lo 12/4/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/xmlparser:$Id$ » Last generated: 2015-03-15 16:41; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TXMLDocument.html:5674,allocate,allocated,5674,root/html534/TXMLDocument.html,https://root.cern,https://root.cern/root/html534/TXMLDocument.html,1,['allocate'],['allocated']
Energy Efficiency,"Int_t Fill (Double_t) override;  Invalid Fill method. ;  ; Int_t Fill (Double_t, const char *, Double_t);  ; Int_t Fill (Double_t, Double_t) override;  Increment bin with abscissa X with a weight w. ;  ; Double_t Interpolate (Double_t x) const override;  Not yet implemented. ;  ; Double_t Interpolate (Double_t x, Double_t y) const override;  Not yet implemented. ;  ;  Protected Member Functions inherited from TH1;  TH1 ();  Histogram default constructor. ;  ;  TH1 (const char *name, const char *title, Int_t nbinsx, const Double_t *xbins);  Constructor for variable bin size histograms using an input array of type double. ;  ;  TH1 (const char *name, const char *title, Int_t nbinsx, const Float_t *xbins);  Constructor for variable bin size histograms using an input array of type float. ;  ;  TH1 (const char *name, const char *title, Int_t nbinsx, Double_t xlow, Double_t xup);  Constructor for fix bin size histograms. ;  ; virtual Int_t AutoP2FindLimits (Double_t min, Double_t max);  Buffer-based estimate of the histogram range using the power of 2 algorithm. ;  ; Int_t AxisChoice (Option_t *axis) const;  Choose an axis according to ""axis"". ;  ; virtual void DoFillN (Int_t ntimes, const Double_t *x, const Double_t *w, Int_t stride=1);  Internal method to fill histogram content from a vector called directly by TH1::BufferEmpty. ;  ; virtual Double_t DoIntegral (Int_t ix1, Int_t ix2, Int_t iy1, Int_t iy2, Int_t iz1, Int_t iz2, Double_t &err, Option_t *opt, Bool_t doerr=kFALSE) const;  Internal function compute integral and optionally the error between the limits specified by the bin number values working for all histograms (1D, 2D and 3D) ;  ; virtual Bool_t FindNewAxisLimits (const TAxis *axis, const Double_t point, Double_t &newMin, Double_t &newMax);  finds new limits for the axis so that point is within the range and the limits are compatible with the previous ones (see TH1::Merge). ;  ; UInt_t GetAxisLabelStatus () const;  Internal function used in TH1::Fill to see ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGLTH3Composition.html:55731,power,power,55731,doc/master/classTGLTH3Composition.html,https://root.cern,https://root.cern/doc/master/classTGLTH3Composition.html,8,['power'],['power']
Energy Efficiency,"K ^ 0x70f3336d); 200#define T55 /* 0xffeff47d */ (T_MASK ^ 0x00100b82); 201#define T56 /* 0x85845dd1 */ (T_MASK ^ 0x7a7ba22e); 202#define T57 (0x6fa87e4f); 203#define T58 /* 0xfe2ce6e0 */ (T_MASK ^ 0x01d3191f); 204#define T59 /* 0xa3014314 */ (T_MASK ^ 0x5cfebceb); 205#define T60 (0x4e0811a1); 206#define T61 /* 0xf7537e82 */ (T_MASK ^ 0x08ac817d); 207#define T62 /* 0xbd3af235 */ (T_MASK ^ 0x42c50dca); 208#define T63 (0x2ad7d2bb); 209#define T64 /* 0xeb86d391 */ (T_MASK ^ 0x14792c6e); 210 ; 211static void; 212md5_process(md5_state_t *pms, const md5_byte_t *data /*[64]*/); 213{; 214 md5_word_t a = pms->abcd[0], b = pms->abcd[1], c = pms->abcd[2],; 215 d = pms->abcd[3];; 216 md5_word_t t;; 217#if BYTE_ORDER > 0; 218 /* Define storage only for big-endian CPUs. */; 219 md5_word_t X[16];; 220#else; 221 /* Define storage for little-endian or both types of CPUs. */; 222 md5_word_t xbuf[16];; 223 const md5_word_t *X;; 224#endif; 225 ; 226 {; 227#if BYTE_ORDER == 0; 228 /*; 229 * Determine dynamically whether this is a big-endian or; 230 * little-endian machine, since we can use a more efficient; 231 * algorithm on the latter.; 232 */; 233 static const int w = 1;; 234 ; 235 if (*((const md5_byte_t *)&w)) /* dynamic little-endian */; 236#endif; 237#if BYTE_ORDER <= 0 /* little-endian */; 238 {; 239 /*; 240 * On little-endian machines, we can process properly aligned; 241 * data without copying it.; 242 */; 243 if (!(((uintptr_t) data) & 3)) {; 244 /* data are properly aligned, a direct assignment is possible */; 245 /* cast through a (void *) should avoid a compiler warning,; 246 see; 247 https://github.com/bel2125/civetweb/issues/94#issuecomment-98112861; 248 */; 249 X = (const md5_word_t *)(const void *)data;; 250 } else {; 251 /* not aligned */; 252 memcpy(xbuf, data, 64);; 253 X = xbuf;; 254 }; 255 }; 256#endif; 257#if BYTE_ORDER == 0; 258 else /* dynamic big-endian */; 259#endif; 260#if BYTE_ORDER >= 0 /* big-endian */; 261 {; 262 /*; 263 * On big-endian machines, we must",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/md5_8inl_source.html:9502,efficient,efficient,9502,doc/master/md5_8inl_source.html,https://root.cern,https://root.cern/doc/master/md5_8inl_source.html,1,['efficient'],['efficient']
Energy Efficiency,"L << ( 13 )). };  ;  Public Attributes inherited from TArrayC; Char_t * fArray;  ;  Public Attributes inherited from TArray; Int_t fN;  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Static Protected Member Functions inherited from TH3; static TH1D * DoProject1D (const TH3 &h, const char *name, const char *title, const TAxis *projX, bool computeErrors, bool originalRange, bool useUF, bool useOF);  static methdod performing the projection to 1D histogram ;  ; static TH2D * DoProject2D (const TH3 &h, const char *name, const char *title, const TAxis *projX, const TAxis *projY, bool computeErrors, bool originalRange, bool useUF, bool useOF);  static methdod performing the projection to 2D histogram ;  ;  Static Protected Member Functions inherited from TH1; static Int_t AutoP2GetBins (Int_t n);  Auxiliary function to get the next power of 2 integer value larger then n. ;  ; static Double_t AutoP2GetPower2 (Double_t x, Bool_t next=kTRUE);  Auxiliary function to get the power of 2 next (larger) or previous (smaller) a given x. ;  ; static bool CheckAxisLimits (const TAxis *a1, const TAxis *a2);  Check that the axis limits of the histograms are the same. ;  ; static bool CheckBinLabels (const TAxis *a1, const TAxis *a2);  Check that axis have same labels. ;  ; static bool CheckBinLimits (const TAxis *a1, const TAxis *a2);  Check bin limits. ;  ; static int CheckConsistency (const TH1 *h1, const TH1 *h2);  Check histogram compatibility. ;  ; static bool CheckConsistentSubAxes (const TAxis *a1, Int_t firstBin1, Int_t lastBin1, const TAxis *a2, Int_t firstBin2=0, Int_t lastBin2=0);  Check that two sub axis are the same. ;  ; static bool CheckEqualAxes (const TAxis *a1, const TAxis *a2);  Check that the axis are the same. ;  ; static Bool_t RecomputeAxisLimits (TAxis &destAxis, const TAxis &anAxis);  Finds new limits for the axis for the Merge function. ;  ; static Bool_t SameLimitsAndNBins (const TAxis &axis1, const TAxis &axis2);  S",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH3C.html:57333,power,power,57333,doc/master/classTH3C.html,https://root.cern,https://root.cern/doc/master/classTH3C.html,1,['power'],['power']
Energy Efficiency,"L calculation on num CPUs; Optimize(Bool_t flag) -- Activate constant term optimization (on by default). Options to control flow of fit procedure. InitialHesse(Bool_t flag) -- Flag controls if HESSE before MIGRAD as well, off by default; Hesse(Bool_t flag) -- Flag controls if HESSE is run after MIGRAD, on by default; Minos(Bool_t flag) -- Flag controls if MINOS is run after HESSE, on by default; Minos(const RooArgSet& set) -- Only run MINOS on given subset of arguments; Save(Bool_t flag) -- Flac controls if RooFitResult object is produced and returned, off by default; Strategy(Int_t flag) -- Set Minuit strategy (0 through 2, default is 1); FitOptions(const char* optStr) -- Steer fit with classic options string (for backward compatibility). Use of this option; excludes use of any of the new style steering options. Options to control informational output. Verbose(Bool_t flag) -- Flag controls if verbose output is printed (NLL, parameter changes during fit; Timer(Bool_t flag) -- Time CPU and wall clock consumption of fit steps, off by default; PrintLevel(Int_t level) -- Set Minuit print level (-1 through 3, default is 1). At -1 all RooFit informational; messages are suppressed as well; Warnings(Bool_t flag) -- Enable or disable MINUIT warnings (enabled by default); PrintEvalErrors(Int_t numErr) -- Control number of p.d.f evaluation errors printed per likelihood evaluation. A negative; value suppress output completely, a zero value will only print the error count per p.d.f component,; a positive value is will print details of each error up to numErr messages per p.d.f component. RooFitResult* chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); Internal back-end function to steer chi2 fits. RooAbsReal* createChi2(RooDataHist& data, RooCmdArg arg1, RooCmdArg arg2, 				 RooCmdArg arg3, RooCmdArg arg4, RooCmdArg arg5, 				 RooCmdArg arg6, RooCmdArg arg7, RooCmdArg arg8); Create a chi-2 from a histogram and this function. The following named arguments are supported. O",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsReal.html:71607,consumption,consumption,71607,root/html526/RooAbsReal.html,https://root.cern,https://root.cern/root/html526/RooAbsReal.html,1,['consumption'],['consumption']
Energy Efficiency,"L calculation on num CPUs; Optimize(Bool_t flag) -- Activate constant term optimization (on by default). Options to control flow of fit procedure. InitialHesse(Bool_t flag) -- Flag controls if HESSE before MIGRAD as well, off by default; Hesse(Bool_t flag) -- Flag controls if HESSE is run after MIGRAD, on by default; Minos(Bool_t flag) -- Flag controls if MINOS is run after HESSE, on by default; Minos(const RooArgSet& set) -- Only run MINOS on given subset of arguments; Save(Bool_t flag) -- Flac controls if RooFitResult object is produced and returned, off by default; Strategy(Int_t flag) -- Set Minuit strategy (0 through 2, default is 1); FitOptions(const char* optStr) -- Steer fit with classic options string (for backward compatibility). Use of this option; excludes use of any of the new style steering options. Options to control informational output. Verbose(Bool_t flag) -- Flag controls if verbose output is printed (NLL, parameter changes during fit; Timer(Bool_t flag) -- Time CPU and wall clock consumption of fit steps, off by default; PrintLevel(Int_t level) -- Set Minuit print level (-1 through 3, default is 1). At -1 all RooFit informational; messages are suppressed as well; Warnings(Bool_t flag) -- Enable or disable MINUIT warnings (enabled by default); PrintEvalErrors(Int_t numErr) -- Control number of p.d.f evaluation errors printed per likelihood evaluation. A negative; value suppress output completely, a zero value will only print the error count per p.d.f component,; a positive value is will print details of each error up to numErr messages per p.d.f component. RooFitResult* chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); Internal back-end function to steer chi2 fits. RooAbsReal* createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsReal.html:72573,consumption,consumption,72573,root/html528/RooAbsReal.html,https://root.cern,https://root.cern/root/html528/RooAbsReal.html,6,['consumption'],['consumption']
Energy Efficiency,"LDerivator Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; List of all members ; ROOT::Math::GSLDerivator Class ReferenceMath » MathCore | Math » MathMore » Numerical Algorithms » Numerical Differentiation. ; Class for computing numerical derivative of a function based on the GSL numerical algorithm This class is implemented using the numerical derivatives algorithms provided by GSL (see GSL Online Manual ). ; Definition at line 62 of file GSLDerivator.h. Public Member Functions;  GSLDerivator ();  Default Constructor of a GSLDerivator class based on GSL numerical differentiation algorithms. ;  ; virtual ~GSLDerivator ();  destructor (no operations) ;  ; double EvalBackward (double x, double h);  Computes the numerical derivative at a point x using an adaptive backward difference algorithm with a step size h. ;  ; double EvalCentral (double x, double h);  Computes the numerical derivative at a point x using an adaptive central difference algorithm with a step size h. ;  ; double EvalForward (double x, double h);  Computes the numerical derivative at a point x using an adaptive forward difference algorithm with a step size h. ;  ; void SetFunction (const IGenFunction &f);  Set the function for calculating the derivatives. ;  ; void SetFunction (GSLFuncPointer f, void *p=nullptr);  Set the function f for evaluating the derivative using a GSL function pointer type. ;  . — Static methods —; int fStatus;  ; double fResult;  ; double fError;  ; GSLFunctionWrapper fFunction;  ; int Status () const;  return the error status of the last integral calculation ;  ; double Result () const;  return the result of the last derivative calculation ;  ; double Error () const;  return the estimate of the absolute error of the last derivative calculation ;  ; static double EvalCentral (const IGenFunction &f, double x, double h);  Computes the numerical derivative of a function f at a point",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1GSLDerivator.html:1046,adapt,adaptive,1046,doc/master/classROOT_1_1Math_1_1GSLDerivator.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1GSLDerivator.html,1,['adapt'],['adaptive']
Energy Efficiency,"LFPhotonMaker.h ATLFTrackMaker.h ATLFTrigger.h ATLFTriggerMaker.h; LinkDef.h MAKE MyProject.so MyProjectProjectDict.h; MyProjectProjectDict.cxx MyProjectProjectDict.o; Now you can load the shared library in any consecutive root session to use the atlfast classes.; root[]gSystem->Load(""MyProject/MyProject""); root[]ATLFMuon muon; This is an example of a generated header file:; //////////////////////////////////////////////////////////; // This class has been generated by TFile::MakeProject; // (Thu Apr 5 10:18:37 2001 by ROOT version 3.00/06); // from the TStreamerInfo in file atlfast.root; //////////////////////////////////////////////////////////; #ifndef ATLFMuon_h; #define ATLFMuon_h; #include ""TObject.h""; #include ""TAtt3D.h""; class ATLFMuon : public TObject , public TAtt3D {; public:; Int_t m_KFcode; //Muon KF-code; Int_t m_MCParticle; //Muon position in MCParticles list; Int_t m_KFmother; //Muon mother KF-code; Int_t m_UseFlag; //Muon energy usage flag; Int_t m_Isolated; //Muon isolation (1 for isolated); Float_t m_Eta; //Eta coordinate; Float_t m_Phi; //Phi coordinate; Float_t m_PT; //Transverse energy; Int_t m_Trigger; //Result of trigger; ATLFMuon() {;}; virtual ~ATLFMuon() {;}; ClassDef(ATLFMuon,1) //; };; ClassImp(ATLFMuon); #endif; 11.6 Compression and Performance; ROOT uses a compression algorithm based on the well-known gzip algorithm. It supports nine levels of compression. The default for ROOT is one. The compression level can be set with the method TFile::SetCompressionLevel. The experience with this algorithm shows that a compression level of 1.3 for raw data files and around two on most DST files is the optimum. The choice of one for the default is a compromise between the time it takes to read and write the object vs. the disk space savings.; To specify no compression, set the level to zero.; We recommend using compression when the time spent in I/O is small compared to the total processing time. If the I/O operation is increased by a factor of 5 i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:512189,energy,energy,512189,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['energy'],['energy']
Energy Efficiency,"LIBPATH, or PATH.; Setting from rootrc; ROOT’s builtin library directory. Interpreter. cling’s LLVM is upgraded to version 9.0; New interface to enable/disable optional cling features. Currently, it can be used to enable/disable support for redefinitions. See this issue for more information. Multithreading. Fix an uninitialized variable in global read-write lock which could have caused deadlocks or crashes in some rare cases.; Default global read-write lock transitioned to new implementation based on TBB thread local storage when TBB is available on supported platforms (all except Windows). This gives an O(10%) performance improvement for some typical RDataFrame scenarios with 256 threads due to reduced lock contention. I/O Libraries. Exclusive use of the global lock is reduced or migrated to finer grained read and write locks in a few hotspots that occur during file opening/closing or task initialization in RDataFrame. This can lead to O(100x) improvements for some typical RDataFrame scenarios with 256 threads due to massively reduced lock contention. TTree Libraries. TTree now supports the inclusion of leaves of types long and unsigned long (and therefore also std::size_t on most systems) also for branches in “leaflist mode”. The corresponding leaflist letters are ‘G’ and ‘g’.; when looping over a TTree with a friend with a larger number of entries, TTreeReader now ends the event loop when the entries in the main TTree are exhausted, consistently with other interfaces. See #6518 for more details.; TTreeProcessorMT::SetMaxTasksPerFilePerWorker is now deprecated in favor of the more flexible and newly introduced TTreeProcessorMT::SetTasksPerWorkerHint. See the relevant entries in our reference guide for more information.; The name of the sub-branches of a split collection no longer have 2 consecutive dots if the top level branche name has a trailing dot. The name of the collection’s index leaf also no longer include the dot. For example for “t.” the names where “t._”",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v624/release-notes.html:5768,reduce,reduced,5768,doc/v624/release-notes.html,https://root.cern,https://root.cern/doc/v624/release-notes.html,1,['reduce'],['reduced']
Energy Efficiency,"LL << ( 13 )). };  ;  Public Attributes inherited from TArrayI; Int_t * fArray;  ;  Public Attributes inherited from TArray; Int_t fN;  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Static Protected Member Functions inherited from TH3; static TH1D * DoProject1D (const TH3 &h, const char *name, const char *title, const TAxis *projX, bool computeErrors, bool originalRange, bool useUF, bool useOF);  static methdod performing the projection to 1D histogram ;  ; static TH2D * DoProject2D (const TH3 &h, const char *name, const char *title, const TAxis *projX, const TAxis *projY, bool computeErrors, bool originalRange, bool useUF, bool useOF);  static methdod performing the projection to 2D histogram ;  ;  Static Protected Member Functions inherited from TH1; static Int_t AutoP2GetBins (Int_t n);  Auxiliary function to get the next power of 2 integer value larger then n. ;  ; static Double_t AutoP2GetPower2 (Double_t x, Bool_t next=kTRUE);  Auxiliary function to get the power of 2 next (larger) or previous (smaller) a given x. ;  ; static bool CheckAxisLimits (const TAxis *a1, const TAxis *a2);  Check that the axis limits of the histograms are the same. ;  ; static bool CheckBinLabels (const TAxis *a1, const TAxis *a2);  Check that axis have same labels. ;  ; static bool CheckBinLimits (const TAxis *a1, const TAxis *a2);  Check bin limits. ;  ; static int CheckConsistency (const TH1 *h1, const TH1 *h2);  Check histogram compatibility. ;  ; static bool CheckConsistentSubAxes (const TAxis *a1, Int_t firstBin1, Int_t lastBin1, const TAxis *a2, Int_t firstBin2=0, Int_t lastBin2=0);  Check that two sub axis are the same. ;  ; static bool CheckEqualAxes (const TAxis *a1, const TAxis *a2);  Check that the axis are the same. ;  ; static Bool_t RecomputeAxisLimits (TAxis &destAxis, const TAxis &anAxis);  Finds new limits for the axis for the Merge function. ;  ; static Bool_t SameLimitsAndNBins (const TAxis &axis1, const TAxis &axis2);  S",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH3I.html:57427,power,power,57427,doc/master/classTH3I.html,https://root.cern,https://root.cern/doc/master/classTH3I.html,1,['power'],['power']
Energy Efficiency,"LL;; 475 ; 476 eNew = tempHalfEdge->Sym;; 477 ; 478 /* Disconnect eOrg from eOrg->Dst and connect it to eNew->Org */; 479 Splice( eOrg->Sym, eOrg->Sym->Oprev );; 480 Splice( eOrg->Sym, eNew );; 481 ; 482 /* Set the vertex and face information */; 483 eOrg->Dst = eNew->Org;; 484 eNew->Dst->anEdge = eNew->Sym; /* may have pointed to eOrg->Sym */; 485 eNew->Rface = eOrg->Rface;; 486 eNew->winding = eOrg->winding; /* copy old winding information */; 487 eNew->Sym->winding = eOrg->Sym->winding;; 488 ; 489 return eNew;; 490}; 491 ; 492 ; 493/* __gl_meshConnect( eOrg, eDst ) creates a new edge from eOrg->Dst; 494 * to eDst->Org, and returns the corresponding half-edge eNew.; 495 * If eOrg->Lface == eDst->Lface, this splits one loop into two,; 496 * and the newly created loop is eNew->Lface. Otherwise, two disjoint; 497 * loops are merged into one, and the loop eDst->Lface is destroyed.; 498 *; 499 * If (eOrg == eDst), the new face will have only two edges.; 500 * If (eOrg->Lnext == eDst), the old face is reduced to a single edge.; 501 * If (eOrg->Lnext->Lnext == eDst), the old face is reduced to two edges.; 502 */; 503GLUhalfEdge *__gl_meshConnect( GLUhalfEdge *eOrg, GLUhalfEdge *eDst ); 504{; 505 GLUhalfEdge *eNewSym;; 506 int joiningLoops = FALSE;; 507 GLUhalfEdge *eNew = MakeEdge( eOrg );; 508 if (eNew == NULL) return NULL;; 509 ; 510 eNewSym = eNew->Sym;; 511 ; 512 if( eDst->Lface != eOrg->Lface ) {; 513 /* We are connecting two disjoint loops -- destroy eDst->Lface */; 514 joiningLoops = TRUE;; 515 KillFace( eDst->Lface, eOrg->Lface );; 516 }; 517 ; 518 /* Connect the new edge appropriately */; 519 Splice( eNew, eOrg->Lnext );; 520 Splice( eNewSym, eDst );; 521 ; 522 /* Set the vertex and face information */; 523 eNew->Org = eOrg->Dst;; 524 eNewSym->Org = eDst->Org;; 525 eNew->Lface = eNewSym->Lface = eOrg->Lface;; 526 ; 527 /* Make sure the old face points to a valid half-edge */; 528 eOrg->Lface->anEdge = eNewSym;; 529 ; 530 if( ! joiningLoops ) {; 531 GLUface *newFa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/mesh_8c_source.html:16653,reduce,reduced,16653,doc/master/mesh_8c_source.html,https://root.cern,https://root.cern/doc/master/mesh_8c_source.html,1,['reduce'],['reduced']
Energy Efficiency,"LineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void valueDefinition TGWin32VirtualXProxy.cxx:142; typeOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t typeDefinition TGWin32VirtualXProxy.cxx:249; ROOT::Math::KahanSumThe Kahan summation is a compensated summation algorithm, which significantly reduces numerical error...Definition Util.h:122; ROOT::Math::KahanSum::SumT Sum() constDefinition Util.h:240; ROOT::Math::KahanSum::operator==bool operator==(KahanSum< U, M > const &other) constDefinition Util.h:305; ROOT::Math::KahanSum::operator-KahanSum< T, N > operator-()Definition Util.h:299; ROOT::Math::KahanSum::Accumulatestatic KahanSum< T, N > Accumulate(Iterator begin, Iterator end, T initialValue=T{})Iterate over a range and return an instance of a KahanSum.Definition Util.h:211; ROOT::Math::KahanSum::ResultT Result() constDefinition Util.h:245; ROOT::Math::KahanSum::Addvoid Add(Iterator begin, Iterator end)Accumulate from a range denoted by iterators.Definition Util.h:180; ROOT::Math::KahanSum::Addvoid Add(const Container_t &inputs)Fill from a container that supports index access.Definition Util.h:195; ROOT::Math::KahanSum::KahanSumKahanSum(KahanSum< T, M > const &other)Constructor to create a KahanSum from another KahanSum with a di",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Util_8h_source.html:14824,reduce,reduces,14824,doc/master/Util_8h_source.html,https://root.cern,https://root.cern/doc/master/Util_8h_source.html,1,['reduce'],['reduces']
Energy Efficiency,"List; static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Double_tfEnergyCutLower energy cut off, the default is 10 keV; Double_tfEnergyLimitHigh energy cut off, the default is 10 TeV; Double_tfGranularityGranularity of the fLogEScale; Int_tfMCnumberOfPDGPDG MC number followed by; Double_tfPDGChargeCharge of the particle in units of e; Double_tfPDGDecayWidthLife time of the particle in sec.; Double_tfPDGMassMass of the particle in GeV/c2; Bool_tfPDGStableLogical indicator, if TRUE the particle can not decay; TStringfParticleTypeText indicator for the particle family. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TAttParticle(). Particle definition default constructor. TAttParticle(const char* name, const char* title, Double_t Mass, Bool_t Stable, Double_t DecayWidth, Double_t Charge, const char* Type, Int_t MCnumber, Int_t granularity = 90, Double_t LowerCutOff = 1.0000000000000001E-5, Double_t HighCutOff = 1.0E+4). Particle definition normal constructor. If the particle is set to be; stable, the decay width parameter does have no meaning and can be set to; any value. The parameters granularity, LowerCutOff and HighCutOff are; used for the construction of the me",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TAttParticle.html:6880,energy,energy,6880,root/html602/TAttParticle.html,https://root.cern,https://root.cern/root/html602/TAttParticle.html,4,['energy'],['energy']
Energy Efficiency,"ListOfEnumsWithLockIterIterator for TListOfEnumsWithLock ;  CTListOfFunctionsA collection of TFunction objects designed for fast access given a DeclId_t and for keep track of TFunction that were described unloaded function ;  CTListOfFunctionsIterIterator for TListOfFunctions ;  CTListOfFunctionTemplatesA collection of TFunction objects designed for fast access given a DeclId_t and for keep track of TFunction that were described unloaded function ;  CTListOfTypesA collection of TDataType designed to hold the typedef information and numerical type information ;  CTLockFileA scoped lock based on files ;  CTLockGuard;  CTLockPathPath locking class allowing shared and exclusive locks ;  CTLockPathGuard;  ►CTLorentzRotationDescribes Lorentz transformations including Lorentz boosts and rotations (see TRotation) ;  CTLorentzRotationRow;  CTLorentzVectorTLorentzVector is a general four-vector class, which can be used either for the description of position and time (x,y,z,t) or momentum and energy (px,py,pz,E) ;  CTMacOSXSystem;  CTMacroClass supporting a collection of lines with C++ code ;  CTMakeProject;  CTMapTMap implements an associative array of (key,value) pairs using a THashTable for efficient retrieval (therefore TMap does not conserve the order of the entries) ;  CTMapFileThis class implements a shared memory region mapped to a file ;  CTMapIterIterator of map ;  CTMapRecKeep track of an object in the mapped file ;  CTMarkerManages Markers ;  CTMarker3DBoxA special 3-D marker designed for event display ;  CTMaterialManages a detector material ;  CTMathTextTo draw TeX Mathematical Formula ;  CTMatrixDEigenTMatrixDEigen ;  CTMatrixDSymEigenTMatrixDSymEigen ;  CTMatrixTTMatrixT ;  CTMatrixTBaseLinear Algebra Package ;  CTMatrixTColumn;  CTMatrixTColumn_const;  CTMatrixTDiag;  CTMatrixTDiag_const;  CTMatrixTFlat;  CTMatrixTFlat_const;  CTMatrixTLazyTemplates of Lazy Matrix classes ;  CTMatrixTRow;  CTMatrixTRow_const;  CTMatrixTSparseTMatrixTSparse ;  CTMatrixTSparseDia",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/annotated.html:168443,energy,energy,168443,doc/v608/annotated.html,https://root.cern,https://root.cern/doc/v608/annotated.html,5,['energy'],['energy']
Energy Efficiency,"LorentzVector.h. ◆ Dot(). template<class CoordSystem > . template<class OtherLorentzVector > . Scalar ROOT::Math::LorentzVector< CoordSystem >::Dot ; (; const OtherLorentzVector< CoordSystem > & ; q); const. inline . scalar (Dot) product of two LorentzVector vectors (metric is -,-,-,+) Enable the product using any other LorentzVector implementing the x(), y() , y() and t() member functions ; Parameters. qany LorentzVector implementing the x(), y() , z() and t() member functions . Returnsthe result of v.q of type according to the base scalar type of v ; Definition at line 387 of file LorentzVector.h. ◆ E(). template<class CoordSystem > . Scalar ROOT::Math::LorentzVector< CoordSystem >::E ; (; ); const. inline . return 4-th component (time, or energy for a 4-momentum vector) ; Definition at line 294 of file LorentzVector.h. ◆ e(). template<class CoordSystem > . Scalar ROOT::Math::LorentzVector< CoordSystem >::e ; (; ); const. inline . Definition at line 649 of file LorentzVector.h. ◆ energy(). template<class CoordSystem > . Scalar ROOT::Math::LorentzVector< CoordSystem >::energy ; (; ); const. inline . Definition at line 664 of file LorentzVector.h. ◆ Et(). template<class CoordSystem > . Scalar ROOT::Math::LorentzVector< CoordSystem >::Et ; (; ); const. inline . return the transverse energy . \[ e_t = \sqrt{ \frac{E^2 p_{\perp}^2 }{ |p|^2 } } X sign(E) \]. Definition at line 349 of file LorentzVector.h. ◆ Et2(). template<class CoordSystem > . Scalar ROOT::Math::LorentzVector< CoordSystem >::Et2 ; (; ); const. inline . return the transverse energy squared . \[ e_t = \frac{E^2 p_{\perp}^2 }{ |p|^2 } \]. Definition at line 343 of file LorentzVector.h. ◆ Eta(). template<class CoordSystem > . Scalar ROOT::Math::LorentzVector< CoordSystem >::Eta ; (; ); const. inline . pseudorapidity . \[ \eta = - \ln { \tan { \frac { \theta} {2} } } \]. Definition at line 365 of file LorentzVector.h. ◆ eta(). template<class CoordSystem > . Scalar ROOT::Math::LorentzVector< CoordSystem >::e",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1LorentzVector.html:15075,energy,energy,15075,doc/master/classROOT_1_1Math_1_1LorentzVector.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1LorentzVector.html,1,['energy'],['energy']
Energy Efficiency,"L} c_l \prod_{i=1}^{N} p_{li}\left(x_i\right); = \sum_{l=1}^{L} c_l F_l(\mathbf{x}); \]. such that. \[; S \equiv \sum_{j=1}^{M} \left(D_j - D_p\left(\mathbf{x}_j\right)\right)^2; \]. is minimal. Here \(p_{li}(x_i)\) are monomials, or Chebyshev or Legendre polynomials, labelled \(l = 1, \ldots, L\), in each variable \( x_i\), \( i=1, \ldots, N\).; So what TMultiDimFit does, is to determine the number of terms \( L\), and then \( L\) terms (or functions) \( F_l\), and the \( L\) coefficients \( c_l\), so that \( S\) is minimal (TMultiDimFit::FindParameterization).; Of course it's more than a little unlikely that \( S\) will ever become exact zero as a result of the procedure outlined below. Therefore, the user is asked to provide a minimum relative error \( \epsilon\) (TMultiDimFit::SetMinRelativeError), and \( S\) will be considered minimized when. \[; R = \frac{S}{\sum_{j=1}^M D_j^2} < \epsilon; \]. Optionally, the user may impose a functional expression by specifying the powers of each variable in \( L\) specified functions \( F_1, \ldots,F_L\) (TMultiDimFit::SetPowers). In that case, only the coefficients \( c_l\) is calculated by the class. Limiting the Number of Terms; As always when dealing with fits, there's a real chance of over fitting. As is well-known, it's always possible to fit an \( N-1\) polynomial in \( x\) to \( N\) points \( (x,y)\) with \(\chi^2 = 0\), but the polynomial is not likely to fit new data at all 1. Therefore, the user is asked to provide an upper limit, \( L_{max}\) to the number of terms in \( D_p\) (TMultiDimFit::SetMaxTerms).; However, since there's an infinite number of \( F_l\) to choose from, the user is asked to give the maximum power. \( P_{max,i}\), of each variable \( x_i\) to be considered in the minimization of \( S\) (TMultiDimFit::SetMaxPowers).; One way of obtaining values for the maximum power in variable \( i\), is to perform a regular fit to the dependent quantity \( D\), using a polynomial only in \( x_i\). The maximu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMultiDimFit.html:3802,power,powers,3802,doc/master/classTMultiDimFit.html,https://root.cern,https://root.cern/doc/master/classTMultiDimFit.html,1,['power'],['powers']
Energy Efficiency,"M2 must be less than P2 for the tachionic particles - otherwise use positive values. Scalar Theta() const. polar angle. void SetPt(ROOT::Math::PtEtaPhiM4D<double>::Scalar pt); --------- Set Coordinates of this system ---------------. set Pt value. void SetEta(ROOT::Math::PtEtaPhiM4D<double>::Scalar eta). set eta value. void SetPhi(ROOT::Math::PtEtaPhiM4D<double>::Scalar phi). set phi value. void SetM(ROOT::Math::PtEtaPhiM4D<double>::Scalar mass). set M value. void SetPxPyPzE(ROOT::Math::PtEtaPhiM4D<double>::Scalar px, ROOT::Math::PtEtaPhiM4D<double>::Scalar py, ROOT::Math::PtEtaPhiM4D<double>::Scalar pz, ROOT::Math::PtEtaPhiM4D<double>::Scalar e). set values using cartesian coordinate system. void Negate(); ------ Manipulations -------------. negate the 4-vector -- Note that the energy cannot be negate (would need an additional data member); therefore negate will work only on the spatial components; One would need to use negate only with vectors having the energy as data members. void Scale(ROOT::Math::PtEtaPhiM4D<double>::Scalar a). Scale coordinate values by a scalar quantity a. Scalar x() const; ============= Compatibility secition ==================; The following make this coordinate system look enough like a CLHEP; vector that an assignment member template can work with either. { return X(); }. Scalar y() const; { return Y(); }. Scalar z() const; { return Z(); }. Scalar t() const; { return E(); }. void SetPx(ROOT::Math::PtEtaPhiM4D<double>::Scalar px); ====== Set member functions for coordinates in other systems =======. void SetPy(ROOT::Math::PtEtaPhiM4D<double>::Scalar py). void SetPz(ROOT::Math::PtEtaPhiM4D<double>::Scalar pz). void SetE(ROOT::Math::PtEtaPhiM4D<double>::Scalar energy). » Last changed: root/mathcore:$Id: PtEtaPhiM4D.h 30568 2009-10-06 07:17:59Z moneta $ » Last generated: 2009-12-07 13:44; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__PtEtaPhiM4D_double_.html:8938,energy,energy,8938,root/html526/ROOT__Math__PtEtaPhiM4D_double_.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__PtEtaPhiM4D_double_.html,1,['energy'],['energy']
Energy Efficiency,"M2 must be less than P2 for the tachionic particles - otherwise use positive values. Scalar Theta() const. polar angle. void SetPt(ROOT::Math::PtEtaPhiM4D<double>::Scalar pt); --------- Set Coordinates of this system ---------------. set Pt value. void SetEta(ROOT::Math::PtEtaPhiM4D<double>::Scalar eta). set eta value. void SetPhi(ROOT::Math::PtEtaPhiM4D<double>::Scalar phi). set phi value. void SetM(ROOT::Math::PtEtaPhiM4D<double>::Scalar mass). set M value. void SetPxPyPzE(ROOT::Math::PtEtaPhiM4D<double>::Scalar px, ROOT::Math::PtEtaPhiM4D<double>::Scalar py, ROOT::Math::PtEtaPhiM4D<double>::Scalar pz, ROOT::Math::PtEtaPhiM4D<double>::Scalar e). set values using cartesian coordinate system. void Negate(); ------ Manipulations -------------. negate the 4-vector -- Note that the energy cannot be negate (would need an additional data member); therefore negate will work only on the spatial components; One would need to use negate only with vectors having the energy as data members. void Scale(ROOT::Math::PtEtaPhiM4D<double>::Scalar a). Scale coordinate values by a scalar quantity a. Scalar x() const; ============= Compatibility secition ==================; The following make this coordinate system look enough like a CLHEP; vector that an assignment member template can work with either. { return X(); }. Scalar y() const; { return Y(); }. Scalar z() const; { return Z(); }. Scalar t() const; { return E(); }. void SetPx(ROOT::Math::PtEtaPhiM4D<double>::Scalar px); ====== Set member functions for coordinates in other systems =======. void SetPy(ROOT::Math::PtEtaPhiM4D<double>::Scalar py). void SetPz(ROOT::Math::PtEtaPhiM4D<double>::Scalar pz). void SetE(ROOT::Math::PtEtaPhiM4D<double>::Scalar energy). » Last changed: root/mathcore:$Id: PtEtaPhiM4D.h 31938 2009-12-18 14:49:38Z moneta $ » Last generated: 2010-09-23 19:56; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__PtEtaPhiM4D_double_.html:8938,energy,energy,8938,root/html528/ROOT__Math__PtEtaPhiM4D_double_.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__PtEtaPhiM4D_double_.html,1,['energy'],['energy']
Energy Efficiency,"M2 must be less than P2 for the tachionic particles - otherwise use positive values. Scalar Theta() const. polar angle. void SetPt(ROOT::Math::PtEtaPhiM4D<double>::Scalar pt); --------- Set Coordinates of this system ---------------. set Pt value. void SetEta(ROOT::Math::PtEtaPhiM4D<double>::Scalar eta). set eta value. void SetPhi(ROOT::Math::PtEtaPhiM4D<double>::Scalar phi). set phi value. void SetM(ROOT::Math::PtEtaPhiM4D<double>::Scalar mass). set M value. void SetPxPyPzE(ROOT::Math::PtEtaPhiM4D<double>::Scalar px, ROOT::Math::PtEtaPhiM4D<double>::Scalar py, ROOT::Math::PtEtaPhiM4D<double>::Scalar pz, ROOT::Math::PtEtaPhiM4D<double>::Scalar e). set values using cartesian coordinate system. void Negate(); ------ Manipulations -------------. negate the 4-vector -- Note that the energy cannot be negate (would need an additional data member); therefore negate will work only on the spatial components; One would need to use negate only with vectors having the energy as data members. void Scale(ROOT::Math::PtEtaPhiM4D<double>::Scalar a). Scale coordinate values by a scalar quantity a. Scalar x() const; ============= Compatibility secition ==================; The following make this coordinate system look enough like a CLHEP; vector that an assignment member template can work with either. { return X(); }. Scalar y() const; { return Y(); }. Scalar z() const; { return Z(); }. Scalar t() const; { return E(); }. void SetPx(ROOT::Math::PtEtaPhiM4D<double>::Scalar px); ====== Set member functions for coordinates in other systems =======. void SetPy(ROOT::Math::PtEtaPhiM4D<double>::Scalar py). void SetPz(ROOT::Math::PtEtaPhiM4D<double>::Scalar pz). void SetE(ROOT::Math::PtEtaPhiM4D<double>::Scalar energy). » Last changed: root/mathcore:$Id: PtEtaPhiM4D.h 31938 2009-12-18 14:49:38Z moneta $ » Last generated: 2011-07-04 15:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ROOT__Math__PtEtaPhiM4D_double_.html:8940,energy,energy,8940,root/html530/ROOT__Math__PtEtaPhiM4D_double_.html,https://root.cern,https://root.cern/root/html530/ROOT__Math__PtEtaPhiM4D_double_.html,1,['energy'],['energy']
Energy Efficiency,"M2 must be less than P2 for the tachionic particles - otherwise use positive values. Scalar Theta() const. polar angle. void SetPt(ROOT::Math::PtEtaPhiM4D<double>::Scalar pt); --------- Set Coordinates of this system ---------------. set Pt value. void SetEta(ROOT::Math::PtEtaPhiM4D<double>::Scalar eta). set eta value. void SetPhi(ROOT::Math::PtEtaPhiM4D<double>::Scalar phi). set phi value. void SetM(ROOT::Math::PtEtaPhiM4D<double>::Scalar mass). set M value. void SetPxPyPzE(ROOT::Math::PtEtaPhiM4D<double>::Scalar px, ROOT::Math::PtEtaPhiM4D<double>::Scalar py, ROOT::Math::PtEtaPhiM4D<double>::Scalar pz, ROOT::Math::PtEtaPhiM4D<double>::Scalar e). set values using cartesian coordinate system. void Negate(); ------ Manipulations -------------. negate the 4-vector -- Note that the energy cannot be negate (would need an additional data member); therefore negate will work only on the spatial components; One would need to use negate only with vectors having the energy as data members. void Scale(ROOT::Math::PtEtaPhiM4D<double>::Scalar a). Scale coordinate values by a scalar quantity a. Scalar x() const; ============= Compatibility secition ==================; The following make this coordinate system look enough like a CLHEP; vector that an assignment member template can work with either. { return X(); }. Scalar y() const; { return Y(); }. Scalar z() const; { return Z(); }. Scalar t() const; { return E(); }. void SetPx(ROOT::Math::PtEtaPhiM4D<double>::Scalar px); ====== Set member functions for coordinates in other systems =======. void SetPy(ROOT::Math::PtEtaPhiM4D<double>::Scalar py). void SetPz(ROOT::Math::PtEtaPhiM4D<double>::Scalar pz). void SetE(ROOT::Math::PtEtaPhiM4D<double>::Scalar energy). » Last changed: root/mathcore:$Id: PtEtaPhiM4D.h 31938 2009-12-18 14:49:38Z moneta $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ROOT__Math__PtEtaPhiM4D_double_.html:8940,energy,energy,8940,root/html532/ROOT__Math__PtEtaPhiM4D_double_.html,https://root.cern,https://root.cern/root/html532/ROOT__Math__PtEtaPhiM4D_double_.html,1,['energy'],['energy']
Energy Efficiency,"M4D<Double32_t>(const ROOT::Math::PtEtaPhiM4D<Double32_t>& v); ROOT::Math::PtEtaPhiM4D<Double32_t>PtEtaPhiM4D<Double32_t>(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar pt, ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar eta, ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar phi, ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar mass); ROOT::Math::PtEtaPhiM4D<Double32_t>::ScalarPx() const; ROOT::Math::PtEtaPhiM4D<Double32_t>::ScalarPy() const; ROOT::Math::PtEtaPhiM4D<Double32_t>::ScalarPz() const; ROOT::Math::PtEtaPhiM4D<Double32_t>::ScalarR() const; ROOT::Math::PtEtaPhiM4D<Double32_t>::ScalarRho() const; voidScale(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar a); voidSetCoordinates(const ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar* src); voidSetCoordinates(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar pt, ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar eta, ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar phi, ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar mass); voidSetE(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar energy); voidSetEta(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar eta); voidSetM(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar mass); voidSetPhi(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar phi); voidSetPt(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar pt); voidSetPx(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar px); voidSetPxPyPzE(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar px, ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar py, ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar pz, ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar e); voidSetPy(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar py); voidSetPz(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar pz); ROOT::Math::PtEtaPhiM4D<Double32_t>::ScalarT() const; ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalart() const; ROOT::Math::PtEtaPhiM4D<Double32_t>::ScalarTheta() const; ROOT::Math::PtEtaPhiM4D<Double32_t>::ScalarX() const; ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalarx() const; ROOT::Math::PtEtaPhiM4D<Double32_t>::ScalarY() const; ROOT::Math::PtEtaPhiM4D<Double32_t>::Scala",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__PtEtaPhiM4D_Double32_t_.html:3519,energy,energy,3519,root/html526/ROOT__Math__PtEtaPhiM4D_Double32_t_.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__PtEtaPhiM4D_Double32_t_.html,5,['energy'],['energy']
Energy Efficiency,"MVA::BinaryTree::Log() const. private:. Double_tSamplePurity(TMVA::DecisionTree::EventList eventSample). Data Members; public:. enum EPruneMethod { kExpectedErrorPruning; kCostComplexityPruning; kNoPruning; };. protected:. UInt_tTMVA::BinaryTree::fDepthmaximal depth in tree reached; UInt_tTMVA::BinaryTree::fNNodestotal number of nodes in the tree (counted); TMVA::Node*TMVA::BinaryTree::fRootthe root node of the tree; static TMVA::MsgLogger*TMVA::BinaryTree::fgLoggermessage logger, static to save resources . private:. TMVA::Types::EAnalysisTypefAnalysisTypekClassification(=0=false) or kRegression(=1=true); TMVA::DataSetInfo*fDataSetInfo; UInt_tfMaxDepthmax depth; Double_tfMinLinCorrForFisherthe minimum linear correlation between two variables demanded for use in fisher criterium in node splitting; Double_tfMinNodeSizemin fraction of training events in node; Double_tfMinSepGainmin number of separation gain to perform node splitting; Double_tfMinSizemin number of events in node; TRandom3*fMyTrandomrandom number generator for randomised trees; Int_tfNCutsnumber of grid point in variable cut scans; Int_tfNNodesBeforePruningremember this one (in case of pruning, it allows to monitor the before/after; Double_tfNodePurityLimitpurity limit to decide whether a node is signal; UInt_tfNvarsnumber of variables used to separate S and B; TMVA::DecisionTree::EPruneMethodfPruneMethodmethod used for prunig ; Double_tfPruneStrengtha parameter to set the ""amount"" of pruning..needs to be adjusted ; Bool_tfRandomisedTreechoose at each node splitting a random set of variables ; TMVA::RegressionVariance*fRegTypethe separation crition used in Regression; TMVA::SeparationBase*fSepTypethe separation crition; UInt_tfSigClassclass which is treated as signal when building the tree; Int_tfTreeIDjust an ID number given to the tree.. makes debugging easier as tree knows who he is.; Bool_tfUseExclusiveVarsindividual variables already used in fisher criterium are not anymore analysed individually for ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__DecisionTree.html:7109,monitor,monitor,7109,root/html534/TMVA__DecisionTree.html,https://root.cern,https://root.cern/root/html534/TMVA__DecisionTree.html,1,['monitor'],['monitor']
Energy Efficiency,"Map window on screen and put on top of all windows. ;  ; void MapSubwindows (Window_t id) override;  Map sub windows. ;  ; void MapWindow (Window_t id) override;  Map window on screen. ;  ; void MoveResizeWindow (Window_t id, Int_t x, Int_t y, UInt_t w, UInt_t h) override;  Move and resize a window. ;  ; void MoveWindow (Int_t wid, Int_t x, Int_t y) override;  Move the window wid. ;  ; void MoveWindow (Window_t id, Int_t x, Int_t y) override;  Move a window. ;  ; void NextEvent (Event_t &event) override;  Copies first pending event from event queue to Event_t structure and removes event from queue. ;  ; Int_t OpenDisplay (const char *dpyName) override;  Open connection to display server (if such a thing exist on the current platform). ;  ; Int_t OpenDisplay (void *display);  Open the display. Return -1 if the opening fails, 0 when ok. ;  ; Int_t OpenPixmap (UInt_t w, UInt_t h) override;  Open a new pixmap. ;  ; Bool_t ParseColor (Colormap_t cmap, const char *cname, ColorStruct_t &color) override;  Parse string cname containing color name, like ""green"" or ""#00FF00"". ;  ; Bool_t PointInRegion (Int_t x, Int_t y, Region_t reg) override;  Returns true if the point x,y is in the region. ;  ; Region_t PolygonRegion (Point_t *points, Int_t np, Bool_t winding) override;  Create region for the polygon defined by the points array. ;  ; void PutImage (Drawable_t id, GContext_t gc, Drawable_t img, Int_t dx, Int_t dy, Int_t x, Int_t y, UInt_t w, UInt_t h) override;  Put (x,y,w,h) part of image img in window win at position dx,dy. ;  ; void PutPixel (Drawable_t id, Int_t x, Int_t y, ULong_t pixel) override;  Set pixel at specified location in XImage img. ;  ; void QueryColor (Colormap_t cmap, ColorStruct_t &color) override;  Fill in the primary color components for a specific pixel value. ;  ; void QueryPointer (Int_t &ix, Int_t &iy) override;  Query pointer position. ;  ; void QueryPointer (Window_t id, Window_t &rootw, Window_t &childw, Int_t &root_x, Int_t &root_y, Int_t &win_x",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGX11.html:16735,green,green,16735,doc/master/classTGX11.html,https://root.cern,https://root.cern/doc/master/classTGX11.html,2,['green'],['green']
Energy Efficiency,"Mask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Float_t*TAttBBox::fBBox! Dynamic Float_t[6] X(min,max), Y(min,max), Z(min,max); TRefArrayfIdsUser-provided point identifications; Int_tTPolyMarker3D::fLastPointThe index of the last filled point; Color_tTAttMarker::fMarkerColorMarker color index; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; Int_tTPolyMarker3D::fNNumber of allocated points; TStringTPolyMarker3D::fNameName of polymarker; TStringTPolyMarker3D::fOptionOptions; Bool_tfOwnIdsFlag specifying id-objects are owned by the point-set; Float_t*TPolyMarker3D::fP[3*fN] Array of X,Y,Z coordinates. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPointSet3D(const TPointSet3D& t); Copy constructor. ~TPointSet3D(); Destructor. void CopyIds(const TPointSet3D& t); Copy id objects from point-set 't'. TPointSet3D& operator=(const TPointSet3D& t); Assignement operator. void ComputeBBox(); Compute the bounding box of this points set. void SetPointId(TObject* id); Set id of last point.; Use this method if you also use TPolyMarker3D::SetNextPoint(). void SetPointId(Int_t n, TObject* id); Set id of point n. void ClearIds(); Clears the id-array. If ids are owned the TObjects are deleted. void PointSelected(Int_t n); This virtual method is called from TPoin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TPointSet3D.html:9355,allocate,allocated,9355,root/html602/TPointSet3D.html,https://root.cern,https://root.cern/root/html602/TPointSet3D.html,2,['allocate'],['allocated']
Energy Efficiency,"MatrixT< Element >::TMatrixT ; (; const TMatrixT< Element2 > & ; another). inline . Definition at line 70 of file TMatrixT.h. ◆ TMatrixT() [10/15]. template<class Element > . TMatrixT< Element >::TMatrixT ; (; EMatrixCreatorsOp1 ; op, . const TMatrixT< Element > & ; prototype . ). Constructor of matrix applying a specific operation to the prototype. ; Example: TMatrixT<Element> a(10,12); ...; TMatrixT<Element> b(TMatrixT::kTransposed, a); Supported operations are: kZero, kUnit, kTransposed, kInverted and kAtA. ; Definition at line 119 of file TMatrixT.cxx. ◆ TMatrixT() [11/15]. template<class Element > . TMatrixT< Element >::TMatrixT ; (; const TMatrixT< Element > & ; a, . EMatrixCreatorsOp2 ; op, . const TMatrixT< Element > & ; b . ). Constructor of matrix applying a specific operation to two prototypes. ; Example: TMatrixT<Element> a(10,12), b(12,5); ...; TMatrixT<Element> c(a, TMatrixT::kMult, b); Supported operations are: kMult (a*b), kTransposeMult (a'*b), kInvMult (a^(-1)*b); Whenever kInvMult is invoked and b is not squared, additional memory is allocated for a^(-1) ; Definition at line 165 of file TMatrixT.cxx. ◆ TMatrixT() [12/15]. template<class Element > . TMatrixT< Element >::TMatrixT ; (; const TMatrixT< Element > & ; a, . EMatrixCreatorsOp2 ; op, . const TMatrixTSym< Element > & ; b . ). Constructor of matrix applying a specific operation to two prototypes. ; Example: TMatrixT<Element> a(10,12), b(12,5); ...; TMatrixT<Element> c(a, TMatrixT::kMult, b); Supported operations are: kMult (a*b), kTransposeMult (a'*b), kInvMult (a^(-1)*b) ; Definition at line 227 of file TMatrixT.cxx. ◆ TMatrixT() [13/15]. template<class Element > . TMatrixT< Element >::TMatrixT ; (; const TMatrixTSym< Element > & ; a, . EMatrixCreatorsOp2 ; op, . const TMatrixT< Element > & ; b . ). Constructor of matrix applying a specific operation to two prototypes. ; Example: TMatrixT<Element> a(10,12), b(12,5); ...; TMatrixT<Element> c(a, TMatrixT::kMult, b); Supported operations are: ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMatrixT.html:30740,allocate,allocated,30740,doc/master/classTMatrixT.html,https://root.cern,https://root.cern/doc/master/classTMatrixT.html,1,['allocate'],['allocated']
Energy Efficiency,"Member Functions |; List of all members ; TQObject Class ReferenceCore ROOT classes » Base ROOT classes. ; This is the ROOT implementation of the Qt object communication mechanism (see also http://www.troll.no/qt/metaobjects.html) ; Signals and slots are used for communication between objects. When an object has changed in some way that might be interesting for the outside world, it emits a signal to tell whoever is listening. All slots that are connected to this signal will be activated (called). It is even possible to connect a signal directly to another signal (this will emit the second signal immediately whenever the first is emitted.) There is no limitation on the number of slots that can be connected to a signal. The slots will be activated in the order they were connected to the signal. This mechanism allows objects to be easily reused, because the object that emits a signal does not need to know to which objects the signals are connected. Together, signals and slots make up a powerfull component programming mechanism. Signals; Destroyed(); TQObject::Destroyedvirtual void Destroyed()Definition TQObject.h:197; Signal emitted when object is destroyed. This signal could be connected to some garbage-collector object.; ChangedBy(const char *method_name); TQObject::ChangedByvirtual void ChangedBy(const char *method)Definition TQObject.h:199; This signal is emitted when some important data members of the object were changed. method_name parameter can be used as an identifier of the modifier method.; Message(const char *msg); TQObject::Messagevirtual void Message(const char *msg)Definition TQObject.h:201; General purpose message signal ; Definition at line 48 of file TQObject.h. Public Member Functions;  TQObject ();  TQObject Constructor. ;  ; virtual ~TQObject ();  TQObject Destructor. ;  ; Bool_t AreSignalsBlocked () const;  ; Bool_t BlockSignals (Bool_t b);  ; virtual void ChangedBy (const char *method);  ; void CollectClassSignalLists (TList &list, TClass *cls); ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQObject.html:1328,power,powerfull,1328,doc/master/classTQObject.html,https://root.cern,https://root.cern/doc/master/classTQObject.html,1,['power'],['powerfull']
Energy Efficiency,"Members;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  . #include <TSpectrumFit.h>. Inheritance diagram for TSpectrumFit:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Enumeration Documentation. ◆ anonymous enum. anonymous enum. EnumeratorkFitOptimChiCounts ; kFitOptimChiFuncValues ; kFitOptimMaxLikelihood ; kFitAlphaHalving ; kFitAlphaOptimal ; kFitPower2 ; kFitPower4 ; kFitPower6 ; kFitPower8 ; kFitPower10 ; kFitPower12 ; kFitTaylorOrderFirst ; kFitTaylorOrderSecond ; kFitNumRegulCycles . Definition at line 70 of file TSpectrumFit.h. Constructor & Destructor Documentation. ◆ TSpectrumFit() [1/2]. TSpectrumFit::TSpectrumFit ; (; void ; ). Default constructor. ; Definition at line 37 of file TSpectrumFit.cxx. ◆ TSpectrumFit() [2/2]. TSpectrumFit::TSpectrumFit ; (; Int_t ; numberPeaks). numberPeaks: number of fitted peaks (must be greater than zero) ; the constructor allocates arrays for all fitted parameters (peak positions, amplitudes etc) and sets the member variables to their default values. One can change these variables by member functions (setters) of TSpectrumFit class.; Shape function of the fitted peaks is. where a represents vector of fitted parameters (positions p(j), amplitudes A(j), sigma, relative amplitudes T, S and slope B). ; Definition at line 103 of file TSpectrumFit.cxx. ◆ ~TSpectrumFit(). TSpectrumFit::~TSpectrumFit ; (; ). override . Destructor. ; Definition at line 162 of file TSpectrumFit.cxx. Member Function Documentation. ◆ Area(). Double_t TSpectrumFit::Area ; (; Double_t ; a, . Double_t ; sigma, . Double_t ; t, . Double_t ; b . ). protected . This function calculates area of a peak Function parameters: . a-amplitude of the peak; sigma-sigma of peak; t-relative amplitude; b-slope . Definition at line 571 of file TSpectrumFit.cxx. ◆ Class(). static TClass * TSpectrumFit::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name()",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSpectrumFit.html:23027,allocate,allocates,23027,doc/master/classTSpectrumFit.html,https://root.cern,https://root.cern/doc/master/classTSpectrumFit.html,1,['allocate'],['allocates']
Energy Efficiency,MethodPDERS::fKernelEstimator. private . ◆ fKernelString. TString TMVA::MethodPDERS::fKernelString. private . Definition at line 149 of file MethodPDERS.h. ◆ fkNNMax. Int_t TMVA::MethodPDERS::fkNNMax. private . max number of events in kNN tree ; Definition at line 200 of file MethodPDERS.h. ◆ fkNNMin. Int_t TMVA::MethodPDERS::fkNNMin. private . min number of events in kNN tree ; Definition at line 199 of file MethodPDERS.h. ◆ fMax_distance. Double_t TMVA::MethodPDERS::fMax_distance. private . maximum distance ; Definition at line 202 of file MethodPDERS.h. ◆ fMaxVIterations. Float_t TMVA::MethodPDERS::fMaxVIterations. private . maximum number of iterations to adapt volume size ; Definition at line 194 of file MethodPDERS.h. ◆ fNEventsMax. Float_t TMVA::MethodPDERS::fNEventsMax. private . maximum number of events in adaptive volume ; Definition at line 193 of file MethodPDERS.h. ◆ fNEventsMin. Float_t TMVA::MethodPDERS::fNEventsMin. private . minimum number of events in adaptive volume ; Definition at line 192 of file MethodPDERS.h. ◆ fNormTree. Bool_t TMVA::MethodPDERS::fNormTree. private . binary-search tree is normalised ; Definition at line 204 of file MethodPDERS.h. ◆ fNRegOut. Double_t TMVA::MethodPDERS::fNRegOut. private . Definition at line 189 of file MethodPDERS.h. ◆ fPrinted. Bool_t TMVA::MethodPDERS::fPrinted. private . print ; Definition at line 203 of file MethodPDERS.h. ◆ fScaleB. Float_t TMVA::MethodPDERS::fScaleB. private . weight for background events ; Definition at line 184 of file MethodPDERS.h. ◆ fScaleS. Float_t TMVA::MethodPDERS::fScaleS. private . weight for signal events ; Definition at line 183 of file MethodPDERS.h. ◆ fShift. std::vector<Float_t>* TMVA::MethodPDERS::fShift. private . volume center ; Definition at line 180 of file MethodPDERS.h. ◆ fVolumeRange. TString TMVA::MethodPDERS::fVolumeRange. private . Definition at line 148 of file MethodPDERS.h. ◆ fVRangeMode. enum TMVA::MethodPDERS::EVolumeRangeMode TMVA::MethodPDERS::fVRangeMod,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodPDERS.html:46884,adapt,adaptive,46884,doc/master/classTMVA_1_1MethodPDERS.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodPDERS.html,1,['adapt'],['adaptive']
Energy Efficiency,"MultiDimOptions are used ; Definition at line 64 of file IntegratorMultiDim.h. ◆ IntegratorMultiDim() [2/3]. ROOT::Math::IntegratorMultiDim::IntegratorMultiDim ; (; const IMultiGenFunction & ; f, . IntegrationMultiDim::Type ; type = IntegrationMultiDim::kDEFAULT, . double ; absTol = -1, . double ; relTol = -1, . unsigned int ; ncall = 0 . ). inlineexplicit . Generic Constructor of multi dimensional Integrator passing a function. ; By default uses the adaptive integration method; Parameters. fintegration function (multi-dim interface) ; typeintegration type (adaptive, MC methods, etc..) ; absToldesired absolute Error ; relToldesired relative Error ; ncallnumber of function calls (apply only to MC integration methods) . Definition at line 79 of file IntegratorMultiDim.h. ◆ ~IntegratorMultiDim(). virtual ROOT::Math::IntegratorMultiDim::~IntegratorMultiDim ; (; ). inlinevirtual . Template Constructor of multi dimensional Integrator passing a generic function. ; By default uses the adaptive integration method; Parameters. fintegration function (generic function implementing operator()(const double *) ; dimfunction dimension ; typeintegration type (adaptive, MC methods, etc..) ; absToldesired absolute Error ; relToldesired relative Error ; ncallnumber of function calls (apply only to MC integration methods) destructor . Definition at line 105 of file IntegratorMultiDim.h. ◆ IntegratorMultiDim() [3/3]. ROOT::Math::IntegratorMultiDim::IntegratorMultiDim ; (; const IntegratorMultiDim & ; ). inlineprivate . Definition at line 113 of file IntegratorMultiDim.h. Member Function Documentation. ◆ CreateIntegrator(). VirtualIntegratorMultiDim * ROOT::Math::IntegratorMultiDim::CreateIntegrator ; (; IntegrationMultiDim::Type ; type, . double ; absTol, . double ; relTol, . unsigned int ; ncall . ). protected . Definition at line 178 of file Integrator.cxx. ◆ Error(). double ROOT::Math::IntegratorMultiDim::Error ; (; ); const. inline . return integration error ; Definition at line 159 o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1IntegratorMultiDim.html:5524,adapt,adaptive,5524,doc/master/classROOT_1_1Math_1_1IntegratorMultiDim.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1IntegratorMultiDim.html,1,['adapt'],['adaptive']
Energy Efficiency,"N the posterior is in the Wikipedia parameterization Gamma(mu, alpha=N+1, beta=1) thus for this implementation it is:; RooGamma(_x=mu,_gamma=N+1,_beta=1,_mu=0); Also note, that in this case it is equivalent to RooPoison(N,mu) and treating the function as a PDF in mu. ; Definition at line 20 of file RooGamma.h. Public Member Functions;  RooGamma ();  ;  RooGamma (const char *name, const char *title, RooAbsReal &_x, RooAbsReal &_gamma, RooAbsReal &_beta, RooAbsReal &_mu);  ;  RooGamma (const RooGamma &other, const char *name=nullptr);  ; double analyticalIntegral (Int_t code, const char *rangeName=nullptr) const override;  Implements the actual analytical integral(s) advertised by getAnalyticalIntegral. ;  ; std::string buildCallToAnalyticIntegral (Int_t code, const char *rangeName, RooFit::Detail::CodeSquashContext &ctx) const override;  This function defines the analytical integral translation for the class. ;  ; TObject * clone (const char *newname) const override;  ; void generateEvent (Int_t code) override;  algorithm adapted from code example in: Marsaglia, G. ;  ; Int_t getAnalyticalIntegral (RooArgSet &allVars, RooArgSet &analVars, const char *rangeName=nullptr) const override;  Interface function getAnalyticalIntergral advertises the analytical integrals that are supported. ;  ; Int_t getGenerator (const RooArgSet &directVars, RooArgSet &generateVars, bool staticInitOK=true) const override;  Load generatedVars with the subset of directVars that we can generate events for, and return a code that specifies the generator algorithm we will use. ;  ; TClass * IsA () const override;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void translate (RooFit::Detail::CodeSquashContext &ctx) const override;  This function defines a translation for each RooAbsReal based object that can be used to express the class as simple C++ code. ;  ;  Public Member Functions inherited from ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooGamma.html:1987,adapt,adapted,1987,doc/master/classRooGamma.html,https://root.cern,https://root.cern/doc/master/classRooGamma.html,1,['adapt'],['adapted']
Energy Efficiency,"N);  Set the array size to N, which the current array must have enough capacity for. ;  ; size_t size () const;  . Private Types; using SuperClass = RVecN< T, Internal::VecOps::RVecInlineStorageSize< T >::value >;  . Friends; void Internal::VecOps::ResetView (RVec< T > &v, T *addr, std::size_t sz);  ; bool ROOT::Detail::VecOps::IsAdopting (const RVec< T > &v);  ; bool ROOT::Detail::VecOps::IsSmall (const RVec< T > &v);  . Additional Inherited Members;  Protected Member Functions inherited from ROOT::Detail::VecOps::RVecImpl< T >;  RVecImpl (unsigned N);  ;  Protected Member Functions inherited from ROOT::Internal::VecOps::SmallVectorTemplateBase< T, bool >;  SmallVectorTemplateBase (size_t Size);  ; void grow (size_t MinSize=0);  Grow the allocated memory (without initializing new elements), doubling the size of the allocated memory. ;  ;  Protected Member Functions inherited from ROOT::Internal::VecOps::SmallVectorTemplateCommon< T >;  SmallVectorTemplateCommon (size_t Size);  ; void grow_pod (size_t MinSize, size_t TSize);  ; bool isSmall () const;  Return true if this is a smallvector which has not had dynamic memory allocated for it. ;  ; void resetToSmall ();  Put this vector in a state of being small. ;  ;  Protected Member Functions inherited from ROOT::Internal::VecOps::SmallVectorBase;  SmallVectorBase ()=delete;  ;  SmallVectorBase (void *FirstEl, size_t TotalCapacity);  ; void grow_pod (void *FirstEl, size_t MinSize, size_t TSize);  This is an implementation of the grow() method which only works on POD-like data types and is out of line to reduce code duplication. ;  ; bool Owns () const;  If false, the RVec is in ""memory adoption"" mode, i.e. it is acting as a view on a memory buffer it does not own. ;  ;  Static Protected Member Functions inherited from ROOT::Internal::VecOps::SmallVectorTemplateBase< T, bool >; static void destroy_range (T *S, T *E);  ; template<typename It1 , typename It2 > ; static void uninitialized_copy (It1 I, It1 E, It2 Dest);  Co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1VecOps_1_1RVec.html:18369,allocate,allocated,18369,doc/v632/classROOT_1_1VecOps_1_1RVec.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1VecOps_1_1RVec.html,2,['allocate'],['allocated']
Energy Efficiency,"N-dimensional non-parametric kernel estimation p.d.f; RooNLLVar Function representing (extended) -log(L) of p.d.f and dataset; RooNameReg String name registry; RooNameSet A sterile version of RooArgSet, containing only the names of the contained RooAbsArgs; RooNonCPEigenDecay PDF to model CP-violating decays to final states which are not CP eigenstates; RooNonCentralChiSquare non-central chisquare pdf; RooNormSetCache Management tool for tracking sets of similar integration/normalization sets; RooNovosibirsk Novosibirsk PDF; RooNumCdf Numeric calculator for CDF for a given PDF; RooNumConvPdf Operator PDF implementing numeric convolution of 2 input PDFs; RooNumConvolution Operator PDF implementing numeric convolution of 2 input functions; RooNumGenConfig Numeric (MC) Event generator configuration ; RooNumGenFactory Numeric Generator factory; RooNumIntConfig Numeric Integrator configuration ; RooNumIntFactory Numeric Integrator factory; RooNumRunningInt Numeric calculator for running integral of a given function; RooNumber wrapper class for portable numerics; RooObjCacheManager Cache manager for generic caches that contain RooAbsArg objects; RooParamBinning Binning specification with ranges parameterized by external RooAbsReal functions; RooParametricStepFunction Parametric Step Function Pdf; RooPlot Plot frame and container for graphics objects; RooPlotable Abstract interface for plotable objects in a RooPlot; RooPoisson A Poisson PDF; RooPolyVar Polynomial function; RooPolynomial Polynomial PDF; RooPrintable Interface for printable objects; RooProdGenContext Context for efficient generation of a a dataset from a RooProdPdf; RooProdPdf PDF representing a product of PDFs; RooProduct Product of RooAbsReal and/or RooAbsCategory terms; RooProfileLL Real-valued function representing profile likelihood of external (likelihood) function; RooProjectedPdf Operator p.d.f calculating projection of another p.d.f; RooProofDriverSelector ; RooPullVar Calculation of pull of measurem",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ClassIndex.html:40552,efficient,efficient,40552,root/html528/ClassIndex.html,https://root.cern,https://root.cern/root/html528/ClassIndex.html,3,['efficient'],['efficient']
Energy Efficiency,"N::Settings::count_mb_dEsize_t count_mb_dEDefinition NeuralNet.h:845; TMVA::DNN::Settings::m_useMultithreadingbool m_useMultithreadingDefinition NeuralNet.h:863; TMVA::DNN::Settings::count_mb_Esize_t count_mb_EDefinition NeuralNet.h:844; TMVA::DNN::Settings::existsbool exists(std::string histoName)for monitoringDefinition NeuralNet.h:825; TMVA::DNN::Settings::maxConvergenceCountsize_t maxConvergenceCount() constreturns the max convergence count so farDefinition NeuralNet.h:828; TMVA::DNN::Settings::padsvoid pads(int numPads)preparation for monitoringDefinition NeuralNet.h:818; TMVA::DNN::Settings::m_testRepetitionssize_t m_testRepetitionsDefinition NeuralNet.h:839; TMVA::DNN::Settings::fLearningRatedouble fLearningRateDefinition NeuralNet.h:852; TMVA::DNN::Settings::fMomentumdouble fMomentumDefinition NeuralNet.h:853; TMVA::DNN::Settings::batchSizesize_t batchSize() constmini-batch sizeDefinition NeuralNet.h:767; TMVA::DNN::Settings::computeResultvirtual void computeResult(const Net &, std::vector< double > &)callback for monitoring and loggingDefinition NeuralNet.h:809; TMVA::DNN::Settings::fMonitoringstd::shared_ptr< Monitoring > fMonitoringDefinition NeuralNet.h:865; TMVA::DNN::Settings::dropRepetitionssize_t dropRepetitions() constDefinition NeuralNet.h:761; TMVA::DNN::Settings::createvoid create(std::string histoName, int bins, double min, double max)for monitoringDefinition NeuralNet.h:819; TMVA::DNN::Settings::fRepetitionsint fRepetitionsDefinition NeuralNet.h:854; TMVA::DNN::Settings::minErrorsize_t minError() constreturns the smallest error so farDefinition NeuralNet.h:829; TMVA::DNN::Settings::startTrainingvirtual void startTraining()Definition NeuralNet.h:795; TMVA::DNN::Settings::m_maxConvergenceCountsize_t m_maxConvergenceCountDefinition NeuralNet.h:858; TMVA::DNN::Settings::startTestCyclevirtual void startTestCycle()callback for monitoring and logggingDefinition NeuralNet.h:804; TMVA::DNN::SteepestSteepest Gradient Descent algorithm (SGD)Definition Neur",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/NeuralNet_8h_source.html:77315,monitor,monitoring,77315,doc/master/NeuralNet_8h_source.html,https://root.cern,https://root.cern/doc/master/NeuralNet_8h_source.html,1,['monitor'],['monitoring']
Energy Efficiency,"NDC);; 607}; 608 ; 609////////////////////////////////////////////////////////////////////////////////; 610/// Set point following LastPoint to x, y.; 611/// Returns index of the point (new last point).; 612 ; 613Int_t TPolyLine::SetNextPoint(Double_t x, Double_t y); 614{; 615 fLastPoint++;; 616 SetPoint(fLastPoint, x, y);; 617 return fLastPoint;; 618}; 619 ; 620////////////////////////////////////////////////////////////////////////////////; 621/// Set point number n to (x, y); 622/// If n is greater than the current size, the arrays are automatically; 623/// extended.; 624 ; 625void TPolyLine::SetPoint(Int_t n, Double_t x, Double_t y); 626{; 627 if (n < 0) return;; 628 if (!fX || !fY || n >= fN) {; 629 // re-allocate the object; 630 Int_t newN = TMath::Max(2*fN,n+1);; 631 Double_t *savex = new Double_t [newN];; 632 Double_t *savey = new Double_t [newN];; 633 if (fX && fN){; 634 memcpy(savex,fX,fN*sizeof(Double_t));; 635 memset(&savex[fN],0,(newN-fN)*sizeof(Double_t));; 636 delete [] fX;; 637 }; 638 if (fY && fN){; 639 memcpy(savey,fY,fN*sizeof(Double_t));; 640 memset(&savey[fN],0,(newN-fN)*sizeof(Double_t));; 641 delete [] fY;; 642 }; 643 fX = savex;; 644 fY = savey;; 645 fN = newN;; 646 }; 647 fX[n] = x;; 648 fY[n] = y;; 649 fLastPoint = TMath::Max(fLastPoint, n);; 650}; 651 ; 652////////////////////////////////////////////////////////////////////////////////; 653/// Resize this polyline to size n.; 654/// If n <= 0 the current arrays of points are deleted.; 655/// If n is greater than the current size, the new points are set to (0, 0); 656 ; 657void TPolyLine::SetPolyLine(Int_t n); 658{; 659 if (n <= 0) {; 660 fN = 0;; 661 fLastPoint = -1;; 662 delete [] fX;; 663 delete [] fY;; 664 fX = fY = nullptr;; 665 return;; 666 }; 667 if (n < fN) {; 668 fN = n;; 669 fLastPoint = n - 1;; 670 } else {; 671 SetPoint(n-1,0,0);; 672 }; 673}; 674 ; 675////////////////////////////////////////////////////////////////////////////////; 676/// Set new values for this polyline (singl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TPolyLine_8cxx_source.html:20485,allocate,allocate,20485,doc/master/TPolyLine_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TPolyLine_8cxx_source.html,1,['allocate'],['allocate']
Energy Efficiency,"NGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; 79In the case of ADAPTIVE type, the integration rule can also be specified via the; 80Integration::GKRule. The default rule is 31 points.; 81 ; 82In the case of integration over infinite and semi-infinite ranges, the type used is always; 83ADAPTIVESINGULAR applying a transformation from the original interval into (0,1).; 84 ; 85The ADAPTIVESINGULAR type is the most sophisticated type. When performances are; 86important, it is then recommended to use the NONADAPTIVE type in case of smooth functions or; 87 ADAPTIVE with a lower Gauss-Kronrod rule.; 88 ; 89For detailed description on GSL integration algorithms see the; 90<A HREF=""http://www.gnu.org/software/gsl/manual/gsl-ref_16.html#SEC248"">GSL Manual</A>.; 91 ; 92 ; 93@ingroup Integration; 94 ; 95*/; 96 ; 97 ; 98class IntegratorOneDim {; 99 ; 100public:; 101 ; 102 typedef IntegrationOneDim::Type Type; // for the enumerations defining the types; 103 ; 104 // constructors; 105 ; 106 ; 107 /**; 108 Constructor of one dimensional Integrator, default type is adaptive; 109 ; 110 @param type integration type (adaptive, non-adaptive, etc..); 111 @param absTol desired absolute Error; 112 @param relTol desired relative Error; 113 @param size maximum number of sub-intervals; 114 @param rule Gauss-Kronrod integration rule (only for GSL kADAPTIVE type); 115 ; 116 Possible type values are : kGAUSS (simple Gauss method), kADAPTIVE (from GSL), kADAPTIVESINGULAR (from GSL), kNONADAPTIVE (from GSL); 117 Possible rule values are kGAUS15 (rule = 1), kGAUS21( rule = 2), kGAUS31(rule =3), kGAUS41 (rule=4), kGAUS51 (rule =5), kGAUS61(rule =6); 118 lower rules are indicated for singular functions while higher for smooth functions to get better accuracies; 119 ; 120 NOTE: When the default values are passed, the values used are taken from the default defined in ROOT::Math::IntegratorOneDimOptions; 121 */; 122 explicit; 123 IntegratorOneDim(Integrati",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Integrator_8h_source.html:3817,adapt,adaptive,3817,doc/master/Integrator_8h_source.html,https://root.cern,https://root.cern/doc/master/Integrator_8h_source.html,3,['adapt'],['adaptive']
Energy Efficiency,"Name(TString)set the weight file name (depreciated)Definition MethodBase.cxx:2068; TMVA::MethodBase::DataInfoDataSetInfo & DataInfo() constDefinition MethodBase.h:410; TMVA::MethodBase::MakeClassvirtual void MakeClass(const TString &classFileName=TString("""")) constcreate reader class for method (classification only at present)Definition MethodBase.cxx:3003; TMVA::MethodBase::GetWeightFileNameTString GetWeightFileName() constretrieve weight file nameDefinition MethodBase.cxx:2076; TMVA::MethodBase::SetTestTimevoid SetTestTime(Double_t testTime)Definition MethodBase.h:165; TMVA::MethodBase::fMethodTypeTypes::EMVA fMethodTypeDefinition MethodBase.h:616; TMVA::MethodBase::TestClassificationvirtual void TestClassification()initializationDefinition MethodBase.cxx:1127; TMVA::MethodBase::AddOutputvoid AddOutput(Types::ETreeType type, Types::EAnalysisType analysisType)Definition MethodBase.cxx:1315; TMVA::MethodBase::WriteMonitoringHistosToFilevirtual void WriteMonitoringHistosToFile() constwrite special monitoring histograms to file dummy implementation here --------------—Definition MethodBase.cxx:2133; TMVA::MethodBase::GetNVariablesUInt_t GetNVariables() constDefinition MethodBase.h:345; TMVA::MethodBase::fAnalysisTypeTypes::EAnalysisType fAnalysisTypeDefinition MethodBase.h:595; TMVA::MethodBase::AddRegressionOutputvirtual void AddRegressionOutput(Types::ETreeType type)prepare tree branch with the method's discriminating variableDefinition MethodBase.cxx:744; TMVA::MethodBase::InitBasevoid InitBase()default initialization called by all constructorsDefinition MethodBase.cxx:441; TMVA::MethodBase::fEventCollectionsstd::vector< const std::vector< TMVA::Event * > * > fEventCollectionsDefinition MethodBase.h:708; TMVA::MethodBase::TrainingEndedbool TrainingEnded()Definition MethodBase.h:469; TMVA::MethodBase::GetRegressionDeviationvirtual void GetRegressionDeviation(UInt_t tgtNum, Types::ETreeType type, Double_t &stddev, Double_t &stddev90Percent) constDefinition MethodBase",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodBase_8h_source.html:54629,monitor,monitoring,54629,doc/master/MethodBase_8h_source.html,https://root.cern,https://root.cern/doc/master/MethodBase_8h_source.html,1,['monitor'],['monitoring']
Energy Efficiency,"Nelems. TMatrixTBase<Element> &TMatrixTSparse<Element> SetMatrixArray(Int_t nr_nonzeros, Int_t* irow, Int_t* icol, double* data); Copy nr elements from row/col index and data array to matrix . It is assumed; that arrays are of size >= nr; Note that the input arrays are not passed as const since they will be modified !. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndex(Int_t nelem_new); Increase/decrease the number of non-zero elements to nelems_new. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndex(const TMatrixTBase<double>& another); Use non-zero data of matrix source to set the sparse structure. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndexAB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b); Set the row/column indices to the ""sum"" of matrices a and b; It is checked that enough space has been allocated. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndexAB(const TMatrixT<Element> &a,const TMatrixTSparse<Element> &b); Set the row/column indices to the ""sum"" of matrices a and b; It is checked that enough space has been allocated. TMatrixTBase<Element> &TMatrixTSparse<Element> ResizeTo(Int_t nrows, Int_t ncols, Int_t nr_nonzeros = -1); Set size of the matrix to nrows x ncols with nr_nonzeros non-zero entries; if nr_nonzeros > 0 .; New dynamic elements are created, the overlapping part of the old ones are; copied to the new structures, then the old elements are deleted. TMatrixTBase<Element> &TMatrixTSparse<Element> ResizeTo(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Int_t nr_nonzeros = -1); Set size of the matrix to [row_lwb:row_upb] x [col_lwb:col_upb] with nr_nonzeros; non-zero entries if nr_nonzeros > 0 .; New dynamic elemenst are created, the overlapping part of the old ones are; copied to the new structures, then the old elements are deleted. TMatrixTSparse<Element> &TMatrixTSparse<Element> Use(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Int_t nr_nonzeros,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMatrixTSparse_double_.html:20789,allocate,allocated,20789,root/html530/TMatrixTSparse_double_.html,https://root.cern,https://root.cern/root/html530/TMatrixTSparse_double_.html,5,['allocate'],['allocated']
Energy Efficiency,"New(). ; Definition at line 5106 of file TClass.cxx. ◆ NewObjectArray() [1/2]. TClass::ObjectPtr TClass::NewObjectArray ; (; Long_t ; nElements, . ENewType ; defConstructor = kClassNew . ); const. Return a pointer to a newly allocated array of objects of this class. ; The class must have a default constructor. For meaning of defConstructor, see TClass::IsCallingNew(). ; Definition at line 5209 of file TClass.cxx. ◆ NewObjectArray() [2/2]. TClass::ObjectPtr TClass::NewObjectArray ; (; Long_t ; nElements, . void * ; arena, . ENewType ; defConstructor = kClassNew . ); const. Return a pointer to a newly allocated object of this class. ; The class must have a default constructor. For meaning of defConstructor, see TClass::IsCallingNew(). ; Definition at line 5310 of file TClass.cxx. ◆ operator=(). TClass & TClass::operator= ; (; const TClass & ; ). privatedelete . ◆ PostLoadCheck(). void TClass::PostLoadCheck ; (; ). virtual . Do the initialization that can only be done after the CINT dictionary has been fully populated and can not be delayed efficiently. ; Definition at line 5959 of file TClass.cxx. ◆ Property(). Long_t TClass::Property ; (; ); const. overridevirtual . Returns the properties of the TClass as a bit field stored as a Long_t value. ; The bit values used for the return value are defined in the enum EProperty (in TDictionary.h); Also sets TObject::fBits and fStreamerType to cache information about the class. The bits stored in TObject::fBits are kIsTObject : the class inherits from TObject; kStartWithTObject: TObject is the left-most class in the inheritance tree; kIsForeign : the class doe not have a Streamer method; a#define a(i)Definition RSha256.hxx:99; TClass::Streamervoid Streamer(void *obj, TBuffer &b, const TClass *onfile_class=nullptr) constDefinition TClass.h:607; TClass::kStartWithTObject@ kStartWithTObjectDefinition TClass.h:103; TClass::kIsTObject@ kIsTObjectDefinition TClass.h:100; TClass::kIsForeign@ kIsForeignDefinition TClass.h:101; The value",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTClass.html:108740,efficient,efficiently,108740,doc/v632/classTClass.html,https://root.cern,https://root.cern/doc/v632/classTClass.html,1,['efficient'],['efficiently']
Energy Efficiency,"New(). ; Definition at line 5173 of file TClass.cxx. ◆ NewObjectArray() [1/2]. TClass::ObjectPtr TClass::NewObjectArray ; (; Long_t ; nElements, . ENewType ; defConstructor = kClassNew . ); const. Return a pointer to a newly allocated array of objects of this class. ; The class must have a default constructor. For meaning of defConstructor, see TClass::IsCallingNew(). ; Definition at line 5276 of file TClass.cxx. ◆ NewObjectArray() [2/2]. TClass::ObjectPtr TClass::NewObjectArray ; (; Long_t ; nElements, . void * ; arena, . ENewType ; defConstructor = kClassNew . ); const. Return a pointer to a newly allocated object of this class. ; The class must have a default constructor. For meaning of defConstructor, see TClass::IsCallingNew(). ; Definition at line 5377 of file TClass.cxx. ◆ operator=(). TClass & TClass::operator= ; (; const TClass & ; ). privatedelete . ◆ PostLoadCheck(). void TClass::PostLoadCheck ; (; ). virtual . Do the initialization that can only be done after the CINT dictionary has been fully populated and can not be delayed efficiently. ; Definition at line 6026 of file TClass.cxx. ◆ Property(). Long_t TClass::Property ; (; ); const. overridevirtual . Returns the properties of the TClass as a bit field stored as a Long_t value. ; The bit values used for the return value are defined in the enum EProperty (in TDictionary.h); Also sets TObject::fBits and fStreamerType to cache information about the class. The bits stored in TObject::fBits are kIsTObject : the class inherits from TObject; kStartWithTObject: TObject is the left-most class in the inheritance tree; kIsForeign : the class doe not have a Streamer method; a#define a(i)Definition RSha256.hxx:99; TClass::Streamervoid Streamer(void *obj, TBuffer &b, const TClass *onfile_class=nullptr) constDefinition TClass.h:607; TClass::kStartWithTObject@ kStartWithTObjectDefinition TClass.h:103; TClass::kIsTObject@ kIsTObjectDefinition TClass.h:100; TClass::kIsForeign@ kIsForeignDefinition TClass.h:101; The value",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClass.html:108741,efficient,efficiently,108741,doc/master/classTClass.html,https://root.cern,https://root.cern/doc/master/classTClass.html,1,['efficient'],['efficiently']
Energy Efficiency,"Not only you do not avoid memory fragmentation, but you worsen it because the TClonesArray itself is a rather heavy structure, and there is quite some code in the destructor, so you have more memory fragmentation and slower code. NOTE 2; When investigating misuse of TClonesArray, please make sure of the following:. Use Clear() or Clear(""C"") instead of Delete(). This will improve program execution time.; TClonesArray object classes containing pointers allocate memory. To avoid causing memory leaks, special Clear(""C"") must be used for clearing TClonesArray. When option ""C"" is specified, ROOT automatically executes the Clear() method (by default it is empty contained in TObject). This method must be overridden in the relevant TClonesArray object class, implementing the reset procedure for pointer objects.; If the objects are added using the placement new then the Clear must deallocate the memory.; If the objects are added using TClonesArray::ConstructedAt then the heap-based memory can stay allocated and reused as the constructor is not called for already constructed/added object.; To reduce memory fragmentation, please make sure that the TClonesArrays are not destroyed and created on every event. They must only be constructed/destructed at the beginning/end of the run. . Definition at line 29 of file TClonesArray.h. Public Types; enum  EStatusBits { kBypassStreamer = (1ULL << ( 12 )); , kForgetBits = (1ULL << ( 15 )); };  Saved copies of pointers to objects. More...;  ;  Public Types inherited from TObjArray; typedef TObjArrayIter Iterator_t;  ;  Public Types inherited from TCollection; enum  { kInitCapacity = 16; , kInitHashTableCapacity = 17; };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClonesArray.html:4694,allocate,allocated,4694,doc/master/classTClonesArray.html,https://root.cern,https://root.cern/doc/master/classTClonesArray.html,1,['allocate'],['allocated']
Energy Efficiency,"NotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. Int_tfBestBest Edge for division; TReffDaught0Pointer to daughter 1; TReffDaught1Pointer to daughter 2; Short_tfDimDimension of the vector space; Double_tfDriveDriver integral, only for cell build-up; Double_tfIntegralIntegral over cell (estimate from exploration); TReffParentPointer to parent cell; Double_tfPrimaryPrimary integral, only for MC generation; Int_tfSerialSerial number; Int_tfStatusStatus (active, inactive); Double_tfVolumeCartesian Volume of cell; Double_tfXdivFactor for division. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFoamCell(); Default constructor for streamer. TFoamCell(Int_t ); User constructor allocating single empty Cell. TFoamCell(TFoamCell& ); Copy constructor (not tested!). ~TFoamCell(); Destructor. TFoamCell& operator=(const TFoamCell& ); Substitution operator = (never used). void Fill(Int_t , TFoamCell* , TFoamCell* , TFoamCell* ); Fills in certain data into newly allocated cell. void GetHcub(TFoamVect& , TFoamVect& ) const; Provides size and position of the cell; These parameter are calculated by analyzing information in all parents; cells up to the root cell. It takes time but saves memory. void GetHSize(TFoamVect& ) const; Provides size of the cell; Size parameters are calculated by analyzing information in all parents; cells up to the root cell. It takes time but saves memory. void CalcVolume(void); Calculates volume of the cell using size params which are calculated. void Print(Option_t* option) const; Printout of the cell geometry parameters for the debug purpose. Double_t GetXdiv() const; Geometry. { return fXdiv;}. Int_t GetBest() const; { return fBest;}. void SetBest(Int_t Best); { fBest =Best;}. void SetXdiv(Double_t Xdiv); { fXdiv =Xdiv;}. Double_t GetVolume() const; { return fVolume;}. Double_t GetIntg() const; { return fIntegral;}. Double_t GetDriv() const; { return fDrive;}. Double_t GetPrim() ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFoamCell.html:6860,allocate,allocated,6860,root/html528/TFoamCell.html,https://root.cern,https://root.cern/root/html528/TFoamCell.html,4,['allocate'],['allocated']
Energy Efficiency,"Npy = 500;; 1699 } else {; 1700 fNpy = npy;; 1701 }; 1702 if (fHistogram) {; 1703 delete fHistogram;; 1704 fHistogram = nullptr;; 1705 fDelaunay = nullptr;; 1706 }; 1707}; 1708 ; 1709 ; 1710////////////////////////////////////////////////////////////////////////////////; 1711/// Sets point number n.; 1712/// If n is greater than the current size, the arrays are automatically; 1713/// extended.; 1714 ; 1715void TGraph2D::SetPoint(Int_t n, Double_t x, Double_t y, Double_t z); 1716{; 1717 if (n < 0) return;; 1718 ; 1719 if (!fX || !fY || !fZ || n >= fSize) {; 1720 // re-allocate the object; 1721 Int_t newN = TMath::Max(2 * fSize, n + 1);; 1722 Double_t *savex = new Double_t [newN];; 1723 Double_t *savey = new Double_t [newN];; 1724 Double_t *savez = new Double_t [newN];; 1725 if (fX && fSize) {; 1726 memcpy(savex, fX, fSize * sizeof(Double_t));; 1727 memset(&savex[fSize], 0, (newN - fSize)*sizeof(Double_t));; 1728 delete [] fX;; 1729 }; 1730 if (fY && fSize) {; 1731 memcpy(savey, fY, fSize * sizeof(Double_t));; 1732 memset(&savey[fSize], 0, (newN - fSize)*sizeof(Double_t));; 1733 delete [] fY;; 1734 }; 1735 if (fZ && fSize) {; 1736 memcpy(savez, fZ, fSize * sizeof(Double_t));; 1737 memset(&savez[fSize], 0, (newN - fSize)*sizeof(Double_t));; 1738 delete [] fZ;; 1739 }; 1740 fX = savex;; 1741 fY = savey;; 1742 fZ = savez;; 1743 fSize = newN;; 1744 }; 1745 fX[n] = x;; 1746 fY[n] = y;; 1747 fZ[n] = z;; 1748 fNpoints = TMath::Max(fNpoints, n + 1);; 1749}; 1750 ; 1751 ; 1752////////////////////////////////////////////////////////////////////////////////; 1753/// Sets the 2D graph title.; 1754///; 1755/// This method allows to change the global title and the axis' titles of a 2D; 1756/// graph. If `g` is the 2D graph one can do:; 1757///; 1758/// ~~~ {.cpp}; 1759/// g->SetTitle(""Graph title; X axis title; Y axis title; Z axis title"");; 1760/// ~~~; 1761 ; 1762void TGraph2D::SetTitle(const char* title); 1763{; 1764 fTitle = title;; 1765 if (fHistogram) fHistogram->SetTitle(tit",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraph2D_8cxx_source.html:54891,allocate,allocate,54891,doc/master/TGraph2D_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraph2D_8cxx_source.html,1,['allocate'],['allocate']
Energy Efficiency,"Number, double weight, double wgtErr)Set bin content of bin that was last loaded with get(std::size_t).Definition RooDataHist.cxx:1754; RooDataHist::binVolumedouble binVolume(std::size_t i) constReturn bin volume of i-th bin.Definition RooDataHist.h:118; RooDataHist::getconst RooArgSet * get() const overrideGet bin centre of current bin.Definition RooDataHist.h:82; RooDataSetContainer class to hold unbinned data.Definition RooDataSet.h:33; RooDerivativeRepresents the first, second, or third order derivative of any RooAbsReal as calculated (numerically)...Definition RooDerivative.h:30; RooFirstMomentDefinition RooFirstMoment.h:26; RooFitResultRooFitResult is a container class to hold the input and output of a PDF fit to a dataset.Definition RooFitResult.h:40; RooFitResult::covarianceMatrixconst TMatrixDSym & covarianceMatrix() constReturn covariance matrix.Definition RooFitResult.cxx:1112; RooFitResult::reducedCovarianceMatrixTMatrixDSym reducedCovarianceMatrix(const RooArgList &params) constReturn a reduced covariance matrix (Note that Vred is a simple sub-matrix of V, row/columns are order...Definition RooFitResult.cxx:1124; RooFitResult::floatParsFinalconst RooArgList & floatParsFinal() constReturn list of floating parameters after fit.Definition RooFitResult.h:111; RooFitResult::createHessePdfRooAbsPdf * createHessePdf(const RooArgSet &params) constReturn a p.d.f that represents the fit result as a multi-variate probability densisty function on the...Definition RooFitResult.cxx:1260; RooFit::Detail::CodeSquashContextA class to maintain the context for squashing of RooFit models into code.Definition CodeSquashContext.h:42; RooFit::EvalContextDefinition EvalContext.h:84; RooFit::EvalContext::atstd::span< const double > at(RooAbsArg const *arg, RooAbsArg const *caller=nullptr)Definition EvalContext.cxx:35; RooFit::EvalContext::outputstd::span< double > output()Definition EvalContext.h:112; RooFormulaVarA RooFormulaVar is a generic implementation of a real-valued obj",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8cxx_source.html:242536,reduce,reducedCovarianceMatrixTMatrixDSym,242536,doc/master/RooAbsReal_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html,3,['reduce'],"['reduced', 'reducedCovarianceMatrix', 'reducedCovarianceMatrixTMatrixDSym']"
Energy Efficiency,"Nz positions must be entered via TXTRU::DefineSection. TXTRU(const TXTRU& xtru); TXTRU copy constructor. ~TXTRU(); TXTRU destructor deallocates arrays. TXTRU& operator=(const TXTRU& rhs); Deep assignment operator. void Copy(TObject& xtru) const; TXTRU Copy method. void DefineSection(Int_t secNum, Float_t z, Float_t scale = 1., Float_t x0 = 0., Float_t y0 = 0.); Set z section iz information; expand size of array if necessary. void DefineVertex(Int_t pointNum, Float_t x, Float_t y). Int_t DistancetoPrimitive(Int_t px, Int_t py); Compute the distance from point px,py to a TXTRU; by calculating the closest approach to each corner. Float_t GetOutlinePointX(Int_t pointNum) const. Float_t GetOutlinePointY(Int_t pointNum) const. Float_t GetSectionX0(Int_t secNum) const. Float_t GetSectionY0(Int_t secNum) const. Float_t GetSectionScale(Int_t secNum) const. Float_t GetSectionZ(Int_t secNum) const. void Print(Option_t* option = """") const; Dump the info of this TXTRU shape; Option: ""xy"" to get x-y information; ""z"" to get z information; ""alloc"" to show full allocated arrays (not just used values). void SetPoints(Double_t* points) const; Create TXTRU points in buffer; order as expected by other methods (counterclockwise xy, increasing z). void Sizeof3D() const; Return total X3D needed by TNode::ls (when called with option ""x""). void SplitConcavePolygon(Bool_t split = kTRUE); (Dis)Enable the splitting of concave polygon outlines into; multiple convex polygons. This would make for better rendering; in solid mode, but introduces extra, potentially confusing, lines; in wireframe mode.; *** Not yet implemented ***. void TruncateNxy(Int_t npts). void TruncateNz(Int_t npts). void CheckOrdering(); Determine ordering over which to process points, segments, surfaces; so that they render correctly. Generally this has to do; with getting outward normals in the hidden/solid surface case. void DumpPoints(int npoints, float* pointbuff) const; Dump the vertex points for visual inspection. void Du",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TXTRU.html:12415,allocate,allocated,12415,root/html528/TXTRU.html,https://root.cern,https://root.cern/root/html528/TXTRU.html,6,['allocate'],['allocated']
Energy Efficiency,"O(100000) events; for (int i = 0; i < ev->Ntracks; i++) { // O(10000) tracks; a[i] = new TTrack(x,y,z,...);. }. a.Delete();; }. One better uses a TClonesArray which reduces the number of; new/delete calls to only O(10000):. TClonesArray a(""TTrack"", 10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000) events; for (int i = 0; i < ev->Ntracks; i++) { // O(10000) tracks; new(a[i]) TTrack(x,y,z,...);. }. a.Delete();; }. Note: the only supported way to add objects to a TClonesArray is; via the new with placement method. The diffrent Add() methods of; TObjArray and its base classes are not allowed. Considering that a new/delete costs about 70 mus on a 300 MHz HP,; O(10^9) new/deletes will save about 19 hours. NOTE 1. C/C++ offer the possibility to allocate and delete memory.; Forgetting to delete allocated memory is a programming error that originate ""leaks"",; i.e. the memory of your process grows and eventually your program crashes.; Even if you *always* delete the allocated memory, the recovered space may not be; efficiently reused. The process knows that there are portions of free memory,; but when you allocate it again, a fresh piece of memory is grabbed.; Your program is free from semantic errors, but the total memory of your process; still grows. Moreover your program's memory is full of ""holes"" which reduce the; efficiency of memory access, this is called ""memory fragmentation"".; Moreover new / delete are expensive operations in terms of CPU time. Without entering into technical details, the TClonesArray allow to ""reuse"" the; same portion of memory for new/delete avoiding memory fragmentation and memory; growth and improving by orders of magnitude the performance. Every time the; memory of the TClonesArray has to be reused, the Clear() method is employed.; To provide its benefits, each TClonesArray must be allocated *once* per process; and disposed of (deleted) *only when not needed any more*.; So a job should see *only one* deletion for each TClonesArray, w",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TClonesArray.html:1716,allocate,allocated,1716,root/html528/TClonesArray.html,https://root.cern,https://root.cern/root/html528/TClonesArray.html,4,"['allocate', 'efficient']","['allocated', 'efficiently']"
Energy Efficiency,"OOT files; JSROOT can read files from local file system using HTML5 FileReader functionality. Main limitation here - user should interactively select files for reading. There is button “…” on the main JSROOT page, which starts file selection dialog. If valid ROOT file is selected, JSROOT will be able to normally read content of such file.; 1.9 JSROOT with THttpServer; THttpServer provides http access to objects from running ROOT application. JSROOT is used to implement the user interface in the web browsers.; The layout of the main page coming from THttpServer is very similar to normal JSROOT page. One could browse existing items and display them. A snapshot of running server can be seen on the demo page.; One could also specify similar URL parameters to configure the displayed items and drawing options.; It is also possible to display one single item from the THttpServer server like:; https://root.cern/js/latest/httpserver.C/Files/job1.root/hpxpy/draw.htm?opt=colz; 1.10 Data monitoring with JSROOT; 1.10.1 Monitoring with http server; The best possibility to organize the monitoring of data from a running application is to use THttpServer. In such case the client can always access the latest changes and request only the items currently displayed in the browser. To enable monitoring, one should activate the appropriate checkbox or provide monitoring parameter in the URL string like:; https://root.cern/js/latest/httpserver.C/Files/job1.root/hprof/draw.htm?monitoring=1000; The parameter value is the update interval in milliseconds.; 1.10.2 JSON file-based monitoring; Solid file-based monitoring (without integration of THttpServer into application) can be implemented in JSON format. There is the TBufferJSON class, which is capable to convert any (beside TTree) ROOT object into JSON. Any ROOT application can use such class to create JSON files for selected objects and write such files in a directory, which can be accessed via web server. Then one can use JSROOT to read su",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:19297,monitor,monitoring,19297,root/htmldoc/guides/JSROOT/JSROOT.html,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html,1,['monitor'],['monitoring']
Energy Efficiency,"OOT with THttpServer; THttpServer provides http access to objects from running ROOT application. JSROOT is used to implement the user interface in the web browsers.; The layout of the main page coming from THttpServer is very similar to normal JSROOT page. One could browse existing items and display them. A snapshot of running server can be seen on the demo page.; One could also specify similar URL parameters to configure the displayed items and drawing options.; It is also possible to display one single item from the THttpServer server like:; https://root.cern/js/latest/httpserver.C/Files/job1.root/hpxpy/draw.htm?opt=colz; 1.10 Data monitoring with JSROOT; 1.10.1 Monitoring with http server; The best possibility to organize the monitoring of data from a running application is to use THttpServer. In such case the client can always access the latest changes and request only the items currently displayed in the browser. To enable monitoring, one should activate the appropriate checkbox or provide monitoring parameter in the URL string like:; https://root.cern/js/latest/httpserver.C/Files/job1.root/hprof/draw.htm?monitoring=1000; The parameter value is the update interval in milliseconds.; 1.10.2 JSON file-based monitoring; Solid file-based monitoring (without integration of THttpServer into application) can be implemented in JSON format. There is the TBufferJSON class, which is capable to convert any (beside TTree) ROOT object into JSON. Any ROOT application can use such class to create JSON files for selected objects and write such files in a directory, which can be accessed via web server. Then one can use JSROOT to read such files and display objects in a web browser.; There is a demonstration page showing such functionality: https://root.cern/js/latest/demo/update_draw.htm. This demo page reads in cycle 20 json files and displays them.; If one has a web server which already provides such JSON file, one could specify the URL to this file like:; https://root.cern/js",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:19597,monitor,monitoring,19597,root/htmldoc/guides/JSROOT/JSROOT.html,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html,2,['monitor'],['monitoring']
Energy Efficiency,"OOT::Fit::BinData::GetBinUpEdgeCoordinates ; (; unsigned int ; ipoint, . double * ; x . ); const. inline . Thread save version of function retrieving the bin up-edge in case of multidimensions. ; Definition at line 532 of file BinData.h. ◆ GetCoordErrorComponent(). double ROOT::Fit::BinData::GetCoordErrorComponent ; (; unsigned int ; ipoint, . unsigned int ; icoord . ); const. inline . returns a single coordinate error component of a point. ; This function is threadsafe in contrast to Coords(...) and can easily get vectorized by the compiler in loops running over the ipoint-index. ; Definition at line 395 of file BinData.h. ◆ GetErrorType(). ErrorType ROOT::Fit::BinData::GetErrorType ; (; ); const. inline . retrieve the errortype ; Definition at line 562 of file BinData.h. ◆ GetPoint() [1/2]. const double * ROOT::Fit::BinData::GetPoint ; (; unsigned int ; ipoint, . double & ; value . ); const. inline . retrieve at the same time a pointer to the coordinate data and the fit value More efficient than calling Coords(i) and Value(i) ; Definition at line 381 of file BinData.h. ◆ GetPoint() [2/2]. const double * ROOT::Fit::BinData::GetPoint ; (; unsigned int ; ipoint, . double & ; value, . double & ; invError . ); const. inline . retrieve in a single call a pointer to the coordinate data, value and inverse error for the given fit point. ; To be used only when type is kValueError or kNoError. In the last case the value 1 is returned for the error. ; Definition at line 439 of file BinData.h. ◆ GetPointError() [1/2]. const double * ROOT::Fit::BinData::GetPointError ; (; unsigned int ; ipoint, . double & ; errlow, . double & ; errhigh . ); const. inline . Get errors on the point (coordinate errors and asymmetric value errors) for the given fit point. ; It must be called only when the coordinate errors and asymmetric errors are stored otherwise it will produce an assert. ; Definition at line 480 of file BinData.h. ◆ GetPointError() [2/2]. const double * ROOT::Fit::BinData::GetP",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Fit_1_1BinData.html:23434,efficient,efficient,23434,doc/master/classROOT_1_1Fit_1_1BinData.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Fit_1_1BinData.html,1,['efficient'],['efficient']
Energy Efficiency,"OT . ; All Releases . ; Documentation . ; Reference Manual . ; User's Guides . ; HowTo . ; Courses . ; Building ROOT . ; Tutorials . ; Javascript Root . ; ROOT and Spark . ; Publications . ; FAQ . ; News . ; Blog . ; Workshops . ; Support . ; Forum . ; Bug submission guidelines . ; Submit a Bug . ; RootTalk Digest . ; Discourse Mailing List Mode . ; About . ; Licence . ; Contact Us . ; Project Founders . ; Team . ; Previous Developers . ; Development . ; Program of Work . ; Code Owners . ; Release Checklist . ; Coding Conventions . ; Shifter's Instructions . ; Git Primer . ; Creating a Pull Request . ; Github ssh key . ; Git Tips and Tricks . ; Git How Tos . ; A suggested work flow for distributed projects: NoSY . ; Browse Sources . ; Meetings . ; ROOT 7 . ; Run the tests . ; Setup externals from AFS/CVMFS . ; Jenkins . ; Doxygen . ; Benchmarks . ; Contribute . ; Collaborate with Us . You are hereHome » ROOT 6 Analysis Workshop 4. Histogramming. What is a histogram?; Our TTree contains for instance the energy of all electrons. What we usually care about is its distribution - for instance by counting how often electrons have an energy within a certain range. Such a range is called ""bin"". Let's look at an example: draw the histogram of the momentum (""fPt"") of all electrons with an energy (""fE"") > 80 and fTriggered being true.; Binning; You can tell TTree::Draw() what the binning should be:; tree->Draw(""electrons.fE >> htemp(15, 0., 30.)"",...). will use 15 bins, where the lower bin border of the first bin is at 0. and the upper bin border of the highest is at 30.; Style; ROOT displays a few properties for the histogram in the box in the upper right. You can move things around in the graphical display (""canvas"") of the histogram. You can modify graphical properties of the canvas by showing the editor: in the menu, select ""View"", then ""Editor"". Click on the histogram to select it, then change its visual appearance to magenta line, 5 pixels width, with pink fill. Eeew. Thi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/4-histogramming.html:1954,energy,energy,1954,d/4-histogramming.html,https://root.cern,https://root.cern/d/4-histogramming.html,1,['energy'],['energy']
Energy Efficiency,"Object *args);  Add pretty printing pythonization. ;  ; PyObject * AddTClassDynamicCastPyz (PyObject *self, PyObject *args);  Add pythonization for TClass::DynamicCast. ;  ; PyObject * AddTObjectEqNePyz (PyObject *self, PyObject *args);  Add pythonization for equality and inequality operators in TObject. ;  ; PyObject * BranchPyz (PyObject *self, PyObject *args);  Add pythonization for TTree::Branch. ;  ; PyObject * ClearProxiedObjects (PyObject *self, PyObject *args);  ; PyObject * CPPInstanceExpand (PyObject *self, PyObject *args);  Deserialize pickled objects. ;  ; PyObject * GetBranchAttr (PyObject *self, PyObject *args);  ; void Init ();  ; PyObject * RegisterConverterAlias (PyObject *, PyObject *args);  ; PyObject * RegisterExecutorAlias (PyObject *, PyObject *args);  . Variables; PyObject * gRootModule = nullptr;  . Function Documentation. ◆ AddCPPInstancePickling(). PyObject * PyROOT::AddCPPInstancePickling ; (; PyObject * ; self, . PyObject * ; args . ). Set reduce attribute for CPPInstance objects. ; Parameters. [in]selfAlways null, since this is a module function. ; [in]argsPointer to a Python tuple object containing the arguments received from Python. The C++ function op_reduce defined above is wrapped in a Python method so that it can be injected in CPPInstance ; Definition at line 123 of file CPPInstancePyz.cxx. ◆ AddPrettyPrintingPyz(). PyObject * PyROOT::AddPrettyPrintingPyz ; (; PyObject * ; self, . PyObject * ; args . ). Add pretty printing pythonization. ; Parameters. [in]selfAlways null, since this is a module function. ; [in]argsPointer to a Python tuple object containing the arguments received from Python. This function adds the following pythonizations to print the object more user-friendly than cppyy by using the output of cling::printValue as the return value of the special method str. ; Definition at line 119 of file GenericPyz.cxx. ◆ AddTClassDynamicCastPyz(). PyObject * PyROOT::AddTClassDynamicCastPyz ; (; PyObject * ; self, . PyObject * ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespacePyROOT.html:1663,reduce,reduce,1663,doc/master/namespacePyROOT.html,https://root.cern,https://root.cern/doc/master/namespacePyROOT.html,1,['reduce'],['reduce']
Energy Efficiency,"Object::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TMaterial*TShape::fMaterialPointer to material; TStringTNamed::fNameobject identifier; Int_tTShape::fNumberShape number; Int_tfNxynumber of x-y points in the cross section; Int_tfNxyAllocnumber of x-y points allocated; Int_tfNznumber of z planes; Int_tfNzAllocnumber of z planes allocated; TXTRU::EXYCheckedfPolygonShapeCCW vs. CW, convex vs. concave; Float_t*fScale[fNzAlloc] array of scale factors (for each z); Bool_tfSplitConcave; TStringTNamed::fTitleobject title; Int_tTShape::fVisibilityVisibility flag; Float_t*fX0[fNzAlloc] array of x offsets (for each z); Float_t*fXvtx[fNxyAlloc] array of x positions; Float_t*fY0[fNzAlloc] array of y offsets (for each z); Float_t*fYvtx[fNxyAlloc] array of y positions; Float_t*fZ[fNzAlloc] array of z planes; TXTRU::EZCheckedfZOrderingincreasing or decreasing; static TXTRU::EXYCheckedkConcaveCCW; static TXTRU::EXYCheckedkConcaveCW; static TXTRU::EZCheckedkConcaveDecZ; static TXTRU::EZCheckedkConcaveIncZ; static TXTRU::EXYCheckedkConvexCCW; static TXTRU::EXYCheckedkConvexCW; static TXTRU::EZCheckedkConvexDecZ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TXTRU.html:10936,allocate,allocated,10936,root/html602/TXTRU.html,https://root.cern,https://root.cern/root/html602/TXTRU.html,4,['allocate'],['allocated']
Energy Efficiency,"Object::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual TMap*GetSubDataSets(const char* uri, const char* excludeservers); virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidMonitorUsedSpace(TVirtualMonitoringWriter* monitoring); virtual Bool_tTObject::Notify(); virtual Int_tNotifyUpdate(const char* group = 0, const char* user = 0, const char* dspath = 0, Long_t mtime = 0, const char* checksum = 0); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); static TList*ParseDataSetSrvMaps(const TString& srvmaps); virtual voidParseInitOpts(const char* opts); Bool_tParseUri(const char* uri, TString* dsGroup = 0, TString* dsUser = 0, TString* dsName = 0, TString* dsTree = 0, Bool_t onlyCurrent = kFALSE, Bool_t wildcards = kFALSE); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TDataSetManager.html:3876,monitor,monitoring,3876,root/html528/TDataSetManager.html,https://root.cern,https://root.cern/root/html528/TDataSetManager.html,1,['monitor'],['monitoring']
Energy Efficiency,"Object::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual TMap*GetSubDataSets(const char* uri, const char* excludeservers); virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidMonitorUsedSpace(TVirtualMonitoringWriter* monitoring); virtual Bool_tTObject::Notify(); virtual Int_tNotifyUpdate(const char* group = 0, const char* user = 0, const char* dspath = 0, Long_t mtime = 0, const char* checksum = 0); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); static TList*ParseDataSetSrvMaps(const TString& srvmaps); virtual voidParseInitOpts(const char* opts); Bool_tParseUri(const char* uri, TString* dsGroup = 0, TString* dsUser = 0, TString* dsName = 0, TString* dsTree = 0, Bool_t onlyCurrent = kFALSE, Bool_t wildcards = kFALS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TDataSetManager.html:3876,monitor,monitoring,3876,root/html530/TDataSetManager.html,https://root.cern,https://root.cern/root/html530/TDataSetManager.html,3,['monitor'],['monitoring']
Energy Efficiency,"Object::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual TMap*GetSubDataSets(const char* uri, const char* excludeservers); virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidMonitorUsedSpace(TVirtualMonitoringWriter* monitoring); virtual Bool_tTObject::Notify(); virtual Int_tNotifyUpdate(const char* group = 0, const char* user = 0, const char* dspath = 0, Long_t mtime = 0, const char* checksum = 0); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); static TList*ParseDataSetSrvMaps(const TString& srvmaps); virtual voidParseInitOpts(const char* opts); Bool_tParseUri(const char* uri, TString* dsGroup = 0, TString* dsUser = 0, TString* dsName = 0, TString* dsTree = 0, Bool_t onlyCurrent = kFALSE, Bool_t wildcards = kFALSE); virtual voidTObject::Pop",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TDataSetManager.html:4001,monitor,monitoring,4001,root/html602/TDataSetManager.html,https://root.cern,https://root.cern/root/html602/TDataSetManager.html,2,['monitor'],['monitoring']
Energy Efficiency,"Object::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. Bool_tRooAbsData::allClientsCached(RooAbsArg*, const RooArgSet&); virtual voidRooAbsData::attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); virtual voidRooAbsData::cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0, Bool_t skipZeroWeights = kFALSE); virtual RooAbsData*RooAbsData::cacheClone(const RooAbsArg* newCacheOwner, const RooArgSet* newCacheVars, const char* newName = 0); Double_tRooAbsData::corrcov(RooRealVar& x, RooRealVar& y, const char* cutSpec, const char* cutRange, Bool_t corr) const; TMatrixDSym*RooAbsData::corrcovMatrix(const RooArgList& vars, const char* cutSpec, const char* cutRange, Bool_t corr) const; RooRealVar*RooAbsData::dataRealVar(const char* methodname, RooRealVar& extVar) const; virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); virtual voidRooAbsData::optimizeReadingWithCaching(RooAbsArg& arg, const RooArgSet& cacheList, const RooArgSet& keepObsList); virtual RooPlot*RooAbsData::plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsData::PlotOpt o) const; virtual RooPlot*RooAbsData::plotEffOn(RooPlot* frame, const RooAbsCategoryLValue& effCat, RooAbsData::PlotOpt o) const; virtual RooPlot*RooAbsData::plotOn(RooPlot* frame, RooAbsData::PlotOpt o) const; virtual RooAbsData*RooAbsData::reduceEng(const RooArgSet& varSubset, const RooFormulaVar* cutVar, const char* cutRange = 0, Int_t nStart = 0, Int_t nStop = 2000000000, Bool_t copyCache = kTRUE); virtual voidRooAbsData::resetCache(); virtual voidRooAbsData::setArgStatus(const RooArgSet& set, Bool_t active). Data Members; public:. enum RooAbsData::ErrorType { Poisson; SumW2; None; Auto; Expected; };; enum RooAbsData::StorageType { Tree; Vector; };; enum TObject::EStatusBits { kCanDel",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooTreeData.html:14174,reduce,reduceEng,14174,root/html534/RooTreeData.html,https://root.cern,https://root.cern/root/html534/RooTreeData.html,1,['reduce'],['reduceEng']
Energy Efficiency,"Object::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. Bool_tRooAbsData::allClientsCached(RooAbsArg*, const RooArgSet&); virtual voidRooAbsData::attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); virtual voidRooAbsData::cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0, Bool_t skipZeroWeights = kFALSE); virtual RooAbsData*RooAbsData::cacheClone(const RooAbsArg* newCacheOwner, const RooArgSet* newCacheVars, const char* newName = 0); Double_tRooAbsData::corrcov(RooRealVar& x, RooRealVar& y, const char* cutSpec, const char* cutRange, Bool_t corr) const; TMatrixDSym*RooAbsData::corrcovMatrix(const RooArgList& vars, const char* cutSpec, const char* cutRange, Bool_t corr) const; RooRealVar*RooAbsData::dataRealVar(const char* methodname, RooRealVar& extVar) const; virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); virtual voidRooAbsData::optimizeReadingWithCaching(RooAbsArg& arg, const RooArgSet& cacheList, const RooArgSet& keepObsList); virtual RooPlot*RooAbsData::plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsData::PlotOpt o) const; virtual RooPlot*RooAbsData::plotEffOn(RooPlot* frame, const RooAbsCategoryLValue& effCat, RooAbsData::PlotOpt o) const; virtual RooPlot*RooAbsData::plotOn(RooPlot* frame, RooAbsData::PlotOpt o) const; virtual RooAbsData*RooAbsData::reduceEng(const RooArgSet& varSubset, const RooFormulaVar* cutVar, const char* cutRange = 0, Int_t nStart = 0, Int_t nStop = 2000000000, Bool_t copyCache = kTRUE); virtual voidRooAbsData::resetCache(); virtual voidRooAbsData::setArgStatus(const RooArgSet& set, Bool_t active). Data Members; public:. static RooAbsData::ErrorTypeRooAbsData::Auto; static RooAbsData::ErrorTypeRooAbsData::Expected; static RooAbsData::ErrorTypeRooAbsData::None; static RooAbs",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooTreeData.html:14323,reduce,reduceEng,14323,root/html602/RooTreeData.html,https://root.cern,https://root.cern/root/html602/RooTreeData.html,2,['reduce'],['reduceEng']
Energy Efficiency,"Object::kOverwrite; static TMonitor::EInterestkRead; static TObject::(anonymous)TObject::kSingleKey; static TMonitor::EInterestkWrite; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. private:. TList*fActivelist of sockets to monitor; TList*fDeActivelist of (temporary) disabled sockets; Bool_tfInterruptflags an interrupt to Select; Bool_tfMainLooptrue if monitoring sockets within the main event loop; TSocket*fReadysocket which is ready to be read or written. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMonitor(Bool_t mainloop = kTRUE); Create a monitor object. If mainloop is true the monitoring will be; done in the main event loop. TMonitor(const TMonitor& m); Copy constructor. ~TMonitor(); Cleanup the monitor object. Does not delete sockets being monitored. void Add(TSocket* sock, Int_t interest = kRead); Add socket to the monitor's active list. If interest=kRead then we; want to monitor the socket for read readiness, if interest=kWrite; then we monitor the socket for write readiness, if interest=kRead|kWrite; then we monitor both read and write readiness. void SetInterest(TSocket* sock, Int_t interest = kRead); Set interest mask for socket sock to interest. If the socket is not; in the active list move it or add it there.; If interest=kRead then we want to monitor the socket for read readiness,; if interest=kWrite then we monitor the socket for write readiness,; if interest=kRead|kWrite then we monitor both read and write readiness. void Remove(TSocket* sock); Remove a socket from the monitor. void RemoveAll(); Remove all sockets from the monitor. void Activate(TSocket* sock",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMonitor.html:10719,monitor,monitoring,10719,root/html602/TMonitor.html,https://root.cern,https://root.cern/root/html602/TMonitor.html,2,['monitor'],['monitoring']
Energy Efficiency,"Org->Dst and connect it to eNew->Org */; 479 Splice( eOrg->Sym, eOrg->Sym->Oprev );; 480 Splice( eOrg->Sym, eNew );; 481 ; 482 /* Set the vertex and face information */; 483 eOrg->Dst = eNew->Org;; 484 eNew->Dst->anEdge = eNew->Sym; /* may have pointed to eOrg->Sym */; 485 eNew->Rface = eOrg->Rface;; 486 eNew->winding = eOrg->winding; /* copy old winding information */; 487 eNew->Sym->winding = eOrg->Sym->winding;; 488 ; 489 return eNew;; 490}; 491 ; 492 ; 493/* __gl_meshConnect( eOrg, eDst ) creates a new edge from eOrg->Dst; 494 * to eDst->Org, and returns the corresponding half-edge eNew.; 495 * If eOrg->Lface == eDst->Lface, this splits one loop into two,; 496 * and the newly created loop is eNew->Lface. Otherwise, two disjoint; 497 * loops are merged into one, and the loop eDst->Lface is destroyed.; 498 *; 499 * If (eOrg == eDst), the new face will have only two edges.; 500 * If (eOrg->Lnext == eDst), the old face is reduced to a single edge.; 501 * If (eOrg->Lnext->Lnext == eDst), the old face is reduced to two edges.; 502 */; 503GLUhalfEdge *__gl_meshConnect( GLUhalfEdge *eOrg, GLUhalfEdge *eDst ); 504{; 505 GLUhalfEdge *eNewSym;; 506 int joiningLoops = FALSE;; 507 GLUhalfEdge *eNew = MakeEdge( eOrg );; 508 if (eNew == NULL) return NULL;; 509 ; 510 eNewSym = eNew->Sym;; 511 ; 512 if( eDst->Lface != eOrg->Lface ) {; 513 /* We are connecting two disjoint loops -- destroy eDst->Lface */; 514 joiningLoops = TRUE;; 515 KillFace( eDst->Lface, eOrg->Lface );; 516 }; 517 ; 518 /* Connect the new edge appropriately */; 519 Splice( eNew, eOrg->Lnext );; 520 Splice( eNewSym, eDst );; 521 ; 522 /* Set the vertex and face information */; 523 eNew->Org = eOrg->Dst;; 524 eNewSym->Org = eDst->Org;; 525 eNew->Lface = eNewSym->Lface = eOrg->Lface;; 526 ; 527 /* Make sure the old face points to a valid half-edge */; 528 eOrg->Lface->anEdge = eNewSym;; 529 ; 530 if( ! joiningLoops ) {; 531 GLUface *newFace= allocFace();; 532 if (newFace == NULL) return NULL;; 533 ; 534 /* We spl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/mesh_8c_source.html:16735,reduce,reduced,16735,doc/master/mesh_8c_source.html,https://root.cern,https://root.cern/doc/master/mesh_8c_source.html,1,['reduce'],['reduced']
Energy Efficiency,"OtherLorentzVector > . Scalar ROOT::Math::LorentzVector< CoordSystem >::Dot ; (; const OtherLorentzVector< CoordSystem > & ; q); const. inline . scalar (Dot) product of two LorentzVector vectors (metric is -,-,-,+) Enable the product using any other LorentzVector implementing the x(), y() , y() and t() member functions ; Parameters. qany LorentzVector implementing the x(), y() , z() and t() member functions . Returnsthe result of v.q of type according to the base scalar type of v ; Definition at line 387 of file LorentzVector.h. ◆ E(). template<class CoordSystem > . Scalar ROOT::Math::LorentzVector< CoordSystem >::E ; (; ); const. inline . return 4-th component (time, or energy for a 4-momentum vector) ; Definition at line 294 of file LorentzVector.h. ◆ e(). template<class CoordSystem > . Scalar ROOT::Math::LorentzVector< CoordSystem >::e ; (; ); const. inline . Definition at line 649 of file LorentzVector.h. ◆ energy(). template<class CoordSystem > . Scalar ROOT::Math::LorentzVector< CoordSystem >::energy ; (; ); const. inline . Definition at line 664 of file LorentzVector.h. ◆ Et(). template<class CoordSystem > . Scalar ROOT::Math::LorentzVector< CoordSystem >::Et ; (; ); const. inline . return the transverse energy . \[ e_t = \sqrt{ \frac{E^2 p_{\perp}^2 }{ |p|^2 } } X sign(E) \]. Definition at line 349 of file LorentzVector.h. ◆ Et2(). template<class CoordSystem > . Scalar ROOT::Math::LorentzVector< CoordSystem >::Et2 ; (; ); const. inline . return the transverse energy squared . \[ e_t = \frac{E^2 p_{\perp}^2 }{ |p|^2 } \]. Definition at line 343 of file LorentzVector.h. ◆ Eta(). template<class CoordSystem > . Scalar ROOT::Math::LorentzVector< CoordSystem >::Eta ; (; ); const. inline . pseudorapidity . \[ \eta = - \ln { \tan { \frac { \theta} {2} } } \]. Definition at line 365 of file LorentzVector.h. ◆ eta(). template<class CoordSystem > . Scalar ROOT::Math::LorentzVector< CoordSystem >::eta ; (; ); const. inline . Definition at line 654 of file LorentzVector.h",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1LorentzVector.html:15165,energy,energy,15165,doc/master/classROOT_1_1Math_1_1LorentzVector.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1LorentzVector.html,1,['energy'],['energy']
Energy Efficiency,"PDG code). void ReadDecayTable(); Read in particle data from an ASCII file. The file name must; previously have been set using the member function; SetDecayTableFile. void WriteDecayTable(); write particle data to an ASCII file. The file name must; previously have been set using the member function; SetDecayTableFile. Users can use this function to make an initial decay list file,; which then can be edited by hand, and re-loaded into the decayer; using ReadDecayTable. The file syntax is. particle_list : partcle_data; | particle_list particle_data; ;; particle_data : particle_info; | particle_info '\n' decay_list; ;; particle_info : See below; ;; decay_list : decay_entry; | decay_list decay_entry; ;; decay_entry : See below. The particle_info consists of 13 fields:. PDG code int; Name string; Anti-particle name string if there's no anti-particle,; then this field must be the; empty string; Electic charge int in units of |e|/3; Color charge int in units of quark color charges; Have anti-particle int 1 of there's an anti-particle; to this particle, or 0; otherwise; Mass float in units of GeV; Resonance width float; Max broadning float; Lifetime float; MWID int ??? (some sort of flag); Decay int 1 if it decays. 0 otherwise. The format to write these entries in are. "" %9 %-16s %-16s%3d%3d%3d%12.5f%12.5f%12.5f%13.gf%3d%d\n"". The decay_entry consists of 8 fields:. On/Off int 1 for on, -1 for off; Matrix element type int; Branching ratio float; Product 1 int PDG code of decay product 1; Product 2 int PDG code of decay product 2; Product 3 int PDG code of decay product 3; Product 4 int PDG code of decay product 4; Product 5 int PDG code of decay product 5. The format for these lines are. "" %5d%5d%12.5f%10d%10d%10d%10d%10d\n"". Int_t CountProducts(Int_t channel, Int_t particle); Count number of decay products. void ForceHadronicD(); Force golden D decay modes. void ForceParticleDecay(Int_t particle, Int_t product, Int_t mult). Force decay of particle into products with multipli",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TPythia6Decayer.html:8161,charge,charge,8161,root/html528/TPythia6Decayer.html,https://root.cern,https://root.cern/root/html528/TPythia6Decayer.html,9,['charge'],"['charge', 'charges']"
Energy Efficiency,"PROOF cluster. If logtomacro is TRUE the text result of the action is saved in the fMacroLog TMacro, accessible via TMacro::GetMacroLog(); Returns -1 in case of error, >=0 in case of succes. ; Definition at line 6589 of file TProof.cxx. ◆ Exec() [3/3]. Int_t TProof::Exec ; (; const char * ; cmd, . ESlaves ; list, . Bool_t ; plusMaster . ). private . Send command to be executed on the PROOF master and/or slaves. ; Command can be any legal command line command. Commands like "".x file.C"" or "".L file.C"" will cause the file file.C to be send to the PROOF cluster. Returns -1 in case of error, >=0 in case of succes. ; Definition at line 6533 of file TProof.cxx. ◆ ExistsDataSet(). Bool_t TProof::ExistsDataSet ; (; const char * ; dataset). virtual . Returns kTRUE if 'dataset' exists, kFALSE otherwise. ; Reimplemented in TProofLite.; Definition at line 10868 of file TProof.cxx. ◆ Feedback(). void TProof::Feedback ; (; TList * ; objs). Get list of feedback objects. ; Connect a slot to this signal to monitor the feedback object. ; Definition at line 9268 of file TProof.cxx. ◆ FinalizationDone(). void TProof::FinalizationDone ; (; ). inlineprivate . Definition at line 694 of file TProof.h. ◆ Finalize() [1/2]. Long64_t TProof::Finalize ; (; const char * ; ref, . Bool_t ; force = kFALSE . ). Finalize query with reference ref. ; If force, force retrieval if the query is found in the local list but has already been finalized (default kFALSE). If ref = 0, finalize current query. Return 0 on success, -1 on error ; Definition at line 5908 of file TProof.cxx. ◆ Finalize() [2/2]. Long64_t TProof::Finalize ; (; Int_t ; qry = -1, . Bool_t ; force = kFALSE . ). Finalize the qry-th query in fQueries. ; If force, force retrieval if the query is found in the local list but has already been finalized (default kFALSE). If query < 0, finalize current query. Return 0 on success, -1 on error ; Definition at line 5883 of file TProof.cxx. ◆ FindDataSets(). TList * TProof::FindDataSets ; (; const char",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProof.html:89807,monitor,monitor,89807,doc/master/classTProof.html,https://root.cern,https://root.cern/doc/master/classTProof.html,1,['monitor'],['monitor']
Energy Efficiency,"ParallelWorld *pw = nullptr;; if (usepw) pw = gGeoManager->CreateParallelWorld(""priority_sensors"");; // Align chips; align();; if (usepw) {; if (useovlp) pw->AddOverlap(ladder);; pw->CloseGeometry();; gGeoManager->SetUseParallelWorldNav(kTRUE);; }; TString cname;; cname = usepw ? ""cpw"" : ""cnopw"";; TCanvas *c = (TCanvas*)gROOT->GetListOfCanvases()->FindObject(cname);; if (c) c->cd();; else c = new TCanvas(cname, """",800,600);; top->Draw();; // top->RandomRays(0,0,0,0,sensor->GetName());; // Track random ""particles"" coming from the block side and draw only the tracklets; // actually crossing one of the sensors. Note that some of the tracks coming; // from the outer side may see the full sensor, while the others only part of it.; TStopwatch timer;; timer.Start();; top->RandomRays(100000,0,0,-30,sensor->GetName());; timer.Stop();; timer.Print();; TView3D *view = (TView3D*)gPad->GetView();; if (view) {; view->SetParallel();; view->Side();; }; if (usepw) pw->PrintDetectedOverlaps();; }; ; //______________________________________________________________________________; void align(); {; // Aligning 2 sensors so they will overlap with the support. One sensor is positioned; // normally while the other using the shared matrix; TGeoPhysicalNode *node;; TGeoParallelWorld *pw = gGeoManager->GetParallelWorld();; Double_t sag;; for (Int_t i=0; i<10; i++) {; node = gGeoManager->MakePhysicalNode(TString::Format(""/TOP_1/chip_%d"",i+1));; sag = 8.-0.494*(i-4.5)*(i-4.5);; TGeoTranslation *tr = new TGeoTranslation(0., -225.+50.*i, 10-sag);; node->Align(tr);; if (pw) pw->AddNode(TString::Format(""/TOP_1/chip_%d"",i+1));; }; }; c#define c(i)Definition RSha256.hxx:101; Bool_tbool Bool_tDefinition RtypesCore.h:63; Int_tint Int_tDefinition RtypesCore.h:45; Double_tdouble Double_tDefinition RtypesCore.h:59; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; kRed@ kRedDefinition Rtypes.h:66; kGreen@ kGreenDefinition Rtypes.h:66; kBlue@ kBlueDefinition Rtypes.h:66; cnameOption_t Option_t TPoint",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/parallel__world_8C.html:3742,sensor,sensors,3742,doc/master/parallel__world_8C.html,https://root.cern,https://root.cern/doc/master/parallel__world_8C.html,1,['sensor'],['sensors']
Energy Efficiency,"PerfEvent*fPerfEvent!TPerfEvent used to fill tree; TH2D*fProcTimeHist!histogram of real time spent processing packets; Int_tfSlaves!number of active slaves; Long64_tfTotBytesRead!total bytes read on all slaves; Double_tfTotCpuTime!total cpu time of all slaves; Long64_tfTotEvents!total number of events processed; TTree*fTrace!TTree with trace events; TTimeStampfTzero!start time of this run; static Long_tfgResMemMax! Max resident memory used by this process; static Long_tfgVirtMemMax! Max virtual memory used by this process. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPerfStats(TList* input, TList* output); Normal constructor. void SimpleEvent(TVirtualPerfStats::EEventType type); Simple event. void PacketEvent(const char* slave, const char* slavename, const char* filename, Long64_t eventsprocessed, Double_t latency, Double_t proctime, Double_t cputime, Long64_t bytesRead); Packet event.; See WriteQueryLog for the descripition of the structure sent for monitoring; when fMonitorPerPacket is kTRUE. void FileEvent(const char* slave, const char* slavename, const char* nodename, const char* filename, Bool_t isStart); File event. void FileOpenEvent(TFile* file, const char* filename, Double_t start); Open file event. void FileReadEvent(TFile* file, Int_t len, Double_t start); Read file event. void FileUnzipEvent(TFile* file, Long64_t pos, Double_t start, Int_t complen, Int_t objlen); Record TTree file unzip event.; start is the TimeStamp before unzip; pos is where in the file the compressed buffer came from; complen is the length of the compressed buffer; objlen is the length of the de-compressed buffer. void RateEvent(Double_t proctime, Double_t deltatime, Long64_t eventsprocessed, Long64_t bytesRead); Rate event. void SetBytesRead(Long64_t num); Set number of bytes read. Long64_t GetBytesRead() const; Get number of bytes read. void WriteQueryLog(); Connect to SQL server and register query log used for quotas.; The <proofquerylo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TPerfStats.html:8485,monitor,monitoring,8485,root/html530/TPerfStats.html,https://root.cern,https://root.cern/root/html530/TPerfStats.html,1,['monitor'],['monitoring']
Energy Efficiency,"Perp2() const; ROOT::Math::PxPyPzM4D<double>::ScalarPhi() const; ROOT::Math::PxPyPzM4D<double>::ScalarPt() const; ROOT::Math::PxPyPzM4D<double>::ScalarPt2() const; ROOT::Math::PxPyPzM4D<double>::ScalarPx() const; ROOT::Math::PxPyPzM4D<double>PxPyPzM4D<double>(); ROOT::Math::PxPyPzM4D<double>PxPyPzM4D<double>(const ROOT::Math::PxPyPzM4D<double>& v); ROOT::Math::PxPyPzM4D<double>PxPyPzM4D<double>(ROOT::Math::PxPyPzM4D<double>::Scalar px, ROOT::Math::PxPyPzM4D<double>::Scalar py, ROOT::Math::PxPyPzM4D<double>::Scalar pz, ROOT::Math::PxPyPzM4D<double>::Scalar m); ROOT::Math::PxPyPzM4D<double>::ScalarPy() const; ROOT::Math::PxPyPzM4D<double>::ScalarPz() const; ROOT::Math::PxPyPzM4D<double>::ScalarR() const; ROOT::Math::PxPyPzM4D<double>::ScalarRho() const; voidScale(const ROOT::Math::PxPyPzM4D<double>::Scalar& a); voidSetCoordinates(const ROOT::Math::PxPyPzM4D<double>::Scalar* src); voidSetCoordinates(ROOT::Math::PxPyPzM4D<double>::Scalar px, ROOT::Math::PxPyPzM4D<double>::Scalar py, ROOT::Math::PxPyPzM4D<double>::Scalar pz, ROOT::Math::PxPyPzM4D<double>::Scalar m); voidSetE(double energy); voidSetEta(double eta); voidSetM(ROOT::Math::PxPyPzM4D<double>::Scalar m); voidSetPhi(double phi); voidSetPt(double pt); voidSetPx(ROOT::Math::PxPyPzM4D<double>::Scalar px); voidSetPxPyPzE(ROOT::Math::PxPyPzM4D<double>::Scalar px, ROOT::Math::PxPyPzM4D<double>::Scalar py, ROOT::Math::PxPyPzM4D<double>::Scalar pz, ROOT::Math::PxPyPzM4D<double>::Scalar e); voidSetPy(ROOT::Math::PxPyPzM4D<double>::Scalar py); voidSetPz(ROOT::Math::PxPyPzM4D<double>::Scalar pz); ROOT::Math::PxPyPzM4D<double>::ScalarT() const; ROOT::Math::PxPyPzM4D<double>::Scalart() const; ROOT::Math::PxPyPzM4D<double>::ScalarTheta() const; ROOT::Math::PxPyPzM4D<double>::ScalarX() const; ROOT::Math::PxPyPzM4D<double>::Scalarx() const; ROOT::Math::PxPyPzM4D<double>::ScalarY() const; ROOT::Math::PxPyPzM4D<double>::Scalary() const; ROOT::Math::PxPyPzM4D<double>::ScalarZ() const; ROOT::Math::PxPyPzM4D<double>::Scalarz() const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__PxPyPzM4D_double_.html:3260,energy,energy,3260,root/html526/ROOT__Math__PxPyPzM4D_double_.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__PxPyPzM4D_double_.html,5,['energy'],['energy']
Energy Efficiency,"Point.h:47; TPoint::GetXSCoord_t GetX() constDefinition TPoint.h:46; TROOT::IndentLevelstatic void IndentLevel()Functions used by ls() to indent an object hierarchy.Definition TROOT.cxx:2895; TStringBasic string class.Definition TString.h:139; TString::ToLowervoid ToLower()Change string to lower-case.Definition TString.cxx:1182; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; TVirtualPadTVirtualPad is an abstract base class for the Pad and Canvas classes.Definition TVirtualPad.h:51; TVirtualPad::YtoAbsPixelvirtual Int_t YtoAbsPixel(Double_t y) const =0; TVirtualPad::GetX2virtual Double_t GetX2() const =0; TVirtualPad::XtoAbsPixelvirtual Int_t XtoAbsPixel(Double_t x) const =0; TVirtualPad::GetY1virtual Double_t GetY1() const =0; TVirtualPad::GetY2virtual Double_t GetY2() const =0; TVirtualPad::GetBorderSizevirtual Short_t GetBorderSize() const =0; TVirtualPad::GetX1virtual Double_t GetX1() const =0; TVirtualX::kHollow@ kHollowDefinition TVirtualX.h:50; bool; double; int; unsigned int; boxvoid box(Int_t pat, Double_t x1, Double_t y1, Double_t x2, Double_t y2)Definition fillpatterns.C:1; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; TMath::MaxShort_t Max(Short_t a, Short_t b)Returns the largest of a and b.Definition TMathBase.h:250; TMath::PowerLongDouble_t Power(LongDouble_t x, LongDouble_t y)Returns x raised to the power y.Definition TMath.h:721; TMath::MinShort_t Min(Short_t a, Short_t b)Returns the smallest of a and b.Definition TMathBase.h:198; TMath::Log10Double_t Log10(Double_t x)Returns the common (base-10) logarithm of x.Definition TMath.h:762; TMath::AbsShort_t Abs(Short_t d)Returns the absolute value of parameter Short_t d.Definition TMathBase.h:123; Rectangle_tRectangle structure (maps to the X11 XRectangle structure)Definition GuiTypes.h:361. graf2dgrafsrcTBox.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:18 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBox_8cxx_source.html:40631,power,power,40631,doc/master/TBox_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TBox_8cxx_source.html,1,['power'],['power']
Energy Efficiency,"Points) {; 46 points = (point *) calloc(gSize3D.numPoints, sizeof (point));; 47 if (!points) {; 48 puts (""Unable to allocate memory for points !"");; 49 ret = 0;; 50 }; 51 }; 52 else return (0); /* if there are no points, return back */; 53 ; 54 ; 55 ; 56 /*; 57 * Allocate memory for colors; 58 */; 59 ; 60 colors = (Color *) calloc(28+4, sizeof (Color));; 61 if(!colors) {; 62 puts (""Unable to allocate memory for colors !"");; 63 ret = 0;; 64 }; 65 else {; 66 colors[ 0].red = 92; colors[ 0].green = 92; colors[0].blue = 92;; 67 colors[ 1].red = 122; colors[ 1].green = 122; colors[1].blue = 122;; 68 colors[ 2].red = 184; colors[ 2].green = 184; colors[2].blue = 184;; 69 colors[ 3].red = 215; colors[ 3].green = 215; colors[3].blue = 215;; 70 colors[ 4].red = 138; colors[ 4].green = 15; colors[4].blue = 15;; 71 colors[ 5].red = 184; colors[ 5].green = 20; colors[5].blue = 20;; 72 colors[ 6].red = 235; colors[ 6].green = 71; colors[6].blue = 71;; 73 colors[ 7].red = 240; colors[ 7].green = 117; colors[7].blue = 117;; 74 colors[ 8].red = 15; colors[ 8].green = 138; colors[8].blue = 15;; 75 colors[ 9].red = 20; colors[ 9].green = 184; colors[9].blue = 20;; 76 colors[10].red = 71; colors[10].green = 235; colors[10].blue = 71;; 77 colors[11].red = 117; colors[11].green = 240; colors[11].blue = 117;; 78 colors[12].red = 15; colors[12].green = 15; colors[12].blue = 138;; 79 colors[13].red = 20; colors[13].green = 20; colors[13].blue = 184;; 80 colors[14].red = 71; colors[14].green = 71; colors[14].blue = 235;; 81 colors[15].red = 117; colors[15].green = 117; colors[15].blue = 240;; 82 colors[16].red = 138; colors[16].green = 138; colors[16].blue = 15;; 83 colors[17].red = 184; colors[17].green = 184; colors[17].blue = 20;; 84 colors[18].red = 235; colors[18].green = 235; colors[18].blue = 71;; 85 colors[19].red = 240; colors[19].green = 240; colors[19].blue = 117;; 86 colors[20].red = 138; colors[20].green = 15; colors[20].blue = 138;; 87 colors[21].red = 184; colors[21].green = 2",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/X3DBuffer_8c_source.html:2189,green,green,2189,doc/master/X3DBuffer_8c_source.html,https://root.cern,https://root.cern/doc/master/X3DBuffer_8c_source.html,1,['green'],['green']
Energy Efficiency,"Primitive(Int_t px, Int_t py); Compute distance from point px,py to a 3-D points ; *-* =====================================================; -; *-* Compute the closest distance of approach from point px,py to each segment; *-* of the polyline.; *-* Returns when the distance found is below DistanceMaximum.; *-* The distance is computed in pixels units.; -; -. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Execute action corresponding to one event; *-* =========================================. void ls(Option_t* option = """") const; -*-*-*List this 3-D polyline with its attributes; *-* ==========================================. void Print(Option_t* option = """") const; -*Dump this 3-D polyline with its attributes; *-* ==========================================. Int_t SetLastPosition(Int_t idx); to be documented. Int_t SetPoint(Int_t point, Float_t x, Float_t y, Float_t z); Initialize one point of the 3-D polyline; *-* ========================================; *-* if n is more then the current TPointsArray3D size (n > fN) - re-allocate this; *-* The new size of the object will be fN += min(10,fN/4); -; *-* return the total number of points introduced; -. Int_t SetPoints(Int_t n, Float_t* p = 0, Option_t* option = """"); Set new values for this 3-D polyline; *-* ====================================; *-* return the total number of points introduced; -. void Streamer(TBuffer& ); Stream a class object*-*-*-*-*-*-*-; *-* =========================================. Int_t GetLastPosition() const; {return fLastPoint;}. Int_t GetN() const; {return fN;}. Float_t * GetP() const; {return fP;}. Float_t GetX(Int_t idx) const; {return fP[3*idx+0];}. Float_t GetY(Int_t idx) const; {return fP[3*idx+1];}. Float_t GetZ(Int_t idx) const; {return fP[3*idx+2];}. const Float_t * GetXYZ(Int_t idx); {return &fP[3*idx+0];}. Float_t * GetXYZ(Float_t* xyz, Int_t idx, Int_t num = 1) const; {return (Float_t *)memcpy(xyz,&fP[3*idx],3*num*sizeof(Float_t));}. Option_t * GetOption() const; {return fO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TPointsArray3D.html:9554,allocate,allocate,9554,root/html534/TPointsArray3D.html,https://root.cern,https://root.cern/root/html534/TPointsArray3D.html,3,['allocate'],['allocate']
Energy Efficiency,"Primitive(Int_t px, Int_t py); Compute distance from point px,py to a 3-D points ; *-* =====================================================; -; *-* Compute the closest distance of approach from point px,py to each segment; *-* of the polyline.; *-* Returns when the distance found is below DistanceMaximum.; *-* The distance is computed in pixels units.; -; -. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Execute action corresponding to one event; *-* =========================================. void ls(Option_t* option = """") const; -*-*-*List this 3-D polyline with its attributes; *-* ==========================================. void Print(Option_t* option = """") const; -*Dump this 3-D polyline with its attributes; *-* ==========================================. Int_t SetLastPosition(Int_t idx); to be documented. Int_t SetPoint(Int_t point, Float_t x, Float_t y, Float_t z); Initialize one point of the 3-D polyline; *-* ========================================; *-* if n is more then the current TPointsArray3D size (n > fN) - re-allocate this; *-* The new size of the object will be fN += min(10,fN/4); -; *-* return the total number of points introduced; -. Int_t SetPoints(Int_t n, Float_t* p = 0, Option_t* option = """"); Set new values for this 3-D polyline; *-* ====================================; *-* return the total number of points introduced; -. void Streamer(TBuffer& b); Stream a class object*-*-*-*-*-*-*-; *-* =========================================. Int_t GetLastPosition() const; {return fLastPoint;}. Int_t GetN() const; {return fN;}. Float_t * GetP() const; {return fP;}. Float_t GetX(Int_t idx) const; {return fP[3*idx+0];}. Float_t GetY(Int_t idx) const; {return fP[3*idx+1];}. Float_t GetZ(Int_t idx) const; {return fP[3*idx+2];}. const Float_t * GetXYZ(Int_t idx); {return &fP[3*idx+0];}. Float_t * GetXYZ(Float_t* xyz, Int_t idx, Int_t num = 1) const; {return (Float_t *)memcpy(xyz,&fP[3*idx],3*num*sizeof(Float_t));}. Option_t * GetOption() const; {return f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TPointsArray3D.html:9466,allocate,allocate,9466,root/html528/TPointsArray3D.html,https://root.cern,https://root.cern/root/html528/TPointsArray3D.html,3,['allocate'],['allocate']
Energy Efficiency,"Print(Option_t* option = """") const; Print TBranch parameters. void Reset(Option_t* option = """"); Reset a branch. Existing buffers are deleted.; Entries, max and min are reset. void SetAddress(void* addobj); Set address of this branch. void SetAutoDelete(Bool_t autodel = kTRUE); Set the AutoDelete bit. This function can be used to instruct Root in TBranchObject::ReadBasket; to not delete the object referenced by a branchobject before reading a; new entry. By default, the object is deleted.; If autodel is kTRUE, this existing object will be deleted, a new object; created by the default constructor, then object->Streamer called.; If autodel is kFALSE, the existing object is not deleted. Root assumes; that the user is taking care of deleting any internal object or array; This can be done in Streamer itself.; If this branch has sub-branches, the function sets autodel for these; branches as well.; We STRONGLY suggest to activate this option by default when you create; the top level branch. This will make the read phase more efficient; because it minimizes the numbers of new/delete operations.; Once this option has been set and the Tree is written to a file, it is; not necessary to specify the option again when reading, unless you; want to set the opposite mode. void SetBasketSize(Int_t buffsize); Reset basket size for all subbranches of this branch. void Streamer(TBuffer& b); Stream an object of class TBranchObject. void UpdateAddress(); Update branch addresses if a new object was created. const char* GetClassName() const; { return fClassName.Data(); }. const char* GetObjClassName(); { return fClassName.Data(); }. » Author: Rene Brun 11/02/96 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id: TBranchObject.h 23230 2008-04-15 15:33:32Z pcanal $ » Last generated: 2009-12-07 15:44; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TBranchObject.html:14652,efficient,efficient,14652,root/html526/TBranchObject.html,https://root.cern,https://root.cern/root/html526/TBranchObject.html,1,['efficient'],['efficient']
Energy Efficiency,"ProofDrawEntryList;  CTProofDrawEventList;  CTProofDrawGraph;  CTProofDrawHist;  ►CTProofDrawListOfGraphs;  CPoint3D_t;  ►CTProofDrawListOfPolyMarkers3D;  CPoint4D_t;  CTProofDrawPolyMarker3D;  CTProofDrawProfile;  CTProofDrawProfile2D;  CTProofInputHandler;  CTProofInterruptHandler;  CTProofLimitsFinderClass to find axis limits and synchronize them between workers ;  CTProofLiteThis class starts a PROOF session on the local machine: no daemons, client and master merged, communications via UNIX-like sockets ;  CTProofLockPath;  CTProofLockPathGuard;  CTProofLogImplementation of the PROOF session log handler ;  CTProofLogElem;  CTProofMergePrg;  CTProofMgrThe PROOF manager interacts with the PROOF server coordinator to create or destroy a PROOF session, attach to or detach from existing one, and to monitor any client activity on the cluster ;  CTProofMgrLiteBasic TProofMgr functionality implementation in the case of Lite session ;  ►CTProofMonSenderProvides the interface for PROOF monitoring to different writers ;  CTDSetPlet;  CTProofMonSenderMLTProofMonSender implementation for the ML writer ;  CTProofMonSenderSQLTProofMonSender implementation for the SQL writers ;  CTProofNodeInfoThe purpose of this class is to provide a complete node description for masters, submasters and workers ;  CTProofNodesPROOF worker node information ;  CTProofOutputFileClass to steer the merging of files produced on the workers ;  CTProofOutputListDerivation of TList with an overload of ls() and Print() allowing to filter out some of the variables ;  CTProofPerfAnalysisSet of tools to analyse the performance tree ;  ►CTProofPlayerInternal class steering processing in PROOF ;  CTCleanup;  CTProofPlayerLiteVersion of TProofPlayerRemote merges the functionality needed by clients and masters ;  CTProofPlayerLocal;  CTProofPlayerRemote;  CTProofPlayerSlave;  CTProofPlayerSuperMaster;  CTProofProgressDialog;  CTProofProgressInfo;  CTProofProgressLog;  CTProofProgressMemoryPlot;  CTProofProgress",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/annotated.html:178693,monitor,monitoring,178693,doc/v608/annotated.html,https://root.cern,https://root.cern/doc/v608/annotated.html,4,['monitor'],['monitoring']
Energy Efficiency,"Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  . #include <TSpectrum2Fit.h>. Inheritance diagram for TSpectrum2Fit:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Enumeration Documentation. ◆ anonymous enum. anonymous enum. EnumeratorkFitOptimChiCounts ; kFitOptimChiFuncValues ; kFitOptimMaxLikelihood ; kFitAlphaHalving ; kFitAlphaOptimal ; kFitPower2 ; kFitPower4 ; kFitPower6 ; kFitPower8 ; kFitPower10 ; kFitPower12 ; kFitTaylorOrderFirst ; kFitTaylorOrderSecond ; kFitNumRegulCycles . Definition at line 117 of file TSpectrum2Fit.h. Constructor & Destructor Documentation. ◆ TSpectrum2Fit() [1/2]. TSpectrum2Fit::TSpectrum2Fit ; (; void ; ). Default constructor. ; Definition at line 37 of file TSpectrum2Fit.cxx. ◆ TSpectrum2Fit() [2/2]. TSpectrum2Fit::TSpectrum2Fit ; (; Int_t ; numberPeaks). numberPeaks: number of fitted peaks (must be greater than zero) the constructor allocates arrays for all fitted parameters (peak positions, amplitudes etc) and sets the member variables to their default values. ; One can change these variables by member functions (setters) of TSpectrumFit class.; Shape function of the fitted peaks contains the two-dimensional symmetrical Gaussian two one-dimensional symmetrical Gaussian ridges as well as non-symmetrical terms and background. Definition at line 152 of file TSpectrum2Fit.cxx. ◆ ~TSpectrum2Fit(). TSpectrum2Fit::~TSpectrum2Fit ; (; ). override . Destructor. ; Definition at line 261 of file TSpectrum2Fit.cxx. Member Function Documentation. ◆ Class(). static TClass * TSpectrum2Fit::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TSpectrum2Fit::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TSpectrum2Fit::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 190 of file TSpectrum2Fit.h. ◆ DeclFileName(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSpectrum2Fit.html:34551,allocate,allocates,34551,doc/master/classTSpectrum2Fit.html,https://root.cern,https://root.cern/doc/master/classTSpectrum2Fit.html,1,['allocate'],['allocates']
Energy Efficiency,"Proxy.cxx:1169; TGenCollectionProxy::GetCollectionTypeInt_t GetCollectionType() const overrideReturn the type of collection see TClassEdit::ESTLType.Definition TGenCollectionProxy.cxx:993; TGenCollectionProxy::Clearvoid Clear(const char *opt="""") overrideClear the emulated collection.Definition TGenCollectionProxy.cxx:1136; TGenCollectionProxy::fProxyListProxies_t fProxyListStack of recursive proxies.Definition TGenCollectionProxy.h:317; TGenCollectionProxy::GetFunctionDeleteIteratorDeleteIterator_t GetFunctionDeleteIterator(Bool_t read=kTRUE) overrideSee typedef void (*DeleteIterator_t)(void *iter); If the sizeof iterator is greater than fgIteratorAr...Definition TGenCollectionProxy.cxx:1696; TGenCollectionProxy::SizeUInt_t Size() const overrideReturn the current size of the container.Definition TGenCollectionProxy.cxx:1153; TGenCollectionProxy::fDestructSizing_t fDestructContainer accessors: block destruct.Definition TGenCollectionProxy.h:307; TGenCollectionProxy::fCreateEnvMethod0 fCreateEnvMethod to allocate an Environment holder.Definition TGenCollectionProxy.h:310; TGenCollectionProxy::fValValue * fValDescriptor of the Value_type.Definition TGenCollectionProxy.h:312; TGenCollectionProxy::GetFunctionNextNext_t GetFunctionNext(Bool_t read=kTRUE) overrideSee typedef void* (*Next_t)(void *iter, void *end); iter and end should be pointer to respectively an...Definition TGenCollectionProxy.cxx:1670; TGenCollectionProxy::operator()virtual void operator()(TBuffer &refBuffer, void *pObject)TClassStreamer IO overload.Definition TGenCollectionProxy.cxx:1448; TGenCollectionProxy::fOnFileClassTClass * fOnFileClassOn file class.Definition TGenCollectionProxy.h:322; TGenCollectionProxy::fResizeSizing_t fResizeContainer accessors: resize container.Definition TGenCollectionProxy.h:303; TGenCollectionProxy::fConstructArrIterfunc_t fConstructContainer accessors: block construct.Definition TGenCollectionProxy.h:306; TGenCollectionProxy::Atvoid * At(UInt_t idx) overrideReturn the ad",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:81840,allocate,allocate,81840,doc/master/TGenCollectionProxy_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html,1,['allocate'],['allocate']
Energy Efficiency,"PtEtaPhiE4D<double> >::Scalar xx, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<double> >::Scalar yy, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<double> >::Scalar zz, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<double> >::Scalar ee). bool operator==(const ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<double> >& rhs) const; ------------------- Equality -----------------. Exact equality. bool operator!=(const ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<double> >& rhs) const. Scalar Px() const; ------ Individual element access, in various coordinate systems ------; individual coordinate accessors in various coordinate systems. spatial X component. { return fCoordinates.Px(); }. Scalar X() const. spatial Y component. { return fCoordinates.Px(); }. Scalar Py() const; { return fCoordinates.Py(); }. Scalar Y() const. spatial Z component. { return fCoordinates.Py(); }. Scalar Pz() const; { return fCoordinates.Pz(); }. Scalar Z() const. return 4-th component (time, or energy for a 4-momentum vector). { return fCoordinates.Pz(); }. Scalar E() const; { return fCoordinates.E(); }. Scalar T() const. return magnitude (mass) squared M2 = T**2 - X**2 - Y**2 - Z**2; (we use -,-,-,+ metric). { return fCoordinates.E(); }. Scalar M2() const. return magnitude (mass) using the (-,-,-,+) metric.; If M2 is negative (space-like vector) a GenVector_exception; is suggested and if continuing, - sqrt( -M2) is returned. { return fCoordinates.M2(); }. Scalar M() const. return the spatial (3D) magnitude ( sqrt(X**2 + Y**2 + Z**2) ). { return fCoordinates.M();}. Scalar R() const; { return fCoordinates.R(); }. Scalar P() const. return the square of the spatial (3D) magnitude ( X**2 + Y**2 + Z**2 ). { return fCoordinates.R(); }. Scalar P2() const. return the square of the transverse spatial component ( X**2 + Y**2 ). { return P() * P(); }. Scalar Perp2() const; { return fCoordinates.Perp2();}. Scalar Pt() const. return the transverse spatial component sqrt ( X**2 + Y**2 ). {",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__LorentzVector_-p1PtEtaPhiE4D_double___.html:15353,energy,energy,15353,root/html526/ROOT__Math__LorentzVector_-p1PtEtaPhiE4D_double___.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__LorentzVector_-p1PtEtaPhiE4D_double___.html,9,['energy'],['energy']
Energy Efficiency,"PtEtaPhiM4D<double> >::Scalar xx, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >::Scalar yy, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >::Scalar zz, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >::Scalar ee). bool operator==(const ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >& rhs) const; ------------------- Equality -----------------. Exact equality. bool operator!=(const ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >& rhs) const. Scalar Px() const; ------ Individual element access, in various coordinate systems ------; individual coordinate accessors in various coordinate systems. spatial X component. { return fCoordinates.Px(); }. Scalar X() const. spatial Y component. { return fCoordinates.Px(); }. Scalar Py() const; { return fCoordinates.Py(); }. Scalar Y() const. spatial Z component. { return fCoordinates.Py(); }. Scalar Pz() const; { return fCoordinates.Pz(); }. Scalar Z() const. return 4-th component (time, or energy for a 4-momentum vector). { return fCoordinates.Pz(); }. Scalar E() const; { return fCoordinates.E(); }. Scalar T() const. return magnitude (mass) squared M2 = T**2 - X**2 - Y**2 - Z**2; (we use -,-,-,+ metric). { return fCoordinates.E(); }. Scalar M2() const. return magnitude (mass) using the (-,-,-,+) metric.; If M2 is negative (space-like vector) a GenVector_exception; is suggested and if continuing, - sqrt( -M2) is returned. { return fCoordinates.M2(); }. Scalar M() const. return the spatial (3D) magnitude ( sqrt(X**2 + Y**2 + Z**2) ). { return fCoordinates.M();}. Scalar R() const; { return fCoordinates.R(); }. Scalar P() const. return the square of the spatial (3D) magnitude ( X**2 + Y**2 + Z**2 ). { return fCoordinates.R(); }. Scalar P2() const. return the square of the transverse spatial component ( X**2 + Y**2 ). { return P() * P(); }. Scalar Perp2() const; { return fCoordinates.Perp2();}. Scalar Pt() const. return the transverse spatial component sqrt ( X**2 + Y**2 ). {",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__LorentzVector_-p1PtEtaPhiM4D_double___.html:14615,energy,energy,14615,root/html526/ROOT__Math__LorentzVector_-p1PtEtaPhiM4D_double___.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__LorentzVector_-p1PtEtaPhiM4D_double___.html,9,['energy'],['energy']
Energy Efficiency,"R USED). void Initialize(TRandom* , TFoamIntegrand* ); Basic initialization of FOAM invoked by the user. Mandatory!. This method starts the process of the cell build-up.; User must invoke Initialize with two arguments or Initialize without arguments.; This is done BEFORE generating first MC event and AFTER allocating FOAM object; and reseting (optionally) its internal parameters/switches.; The overall operational scheme of the FOAM is the following:. . This method invokes several other methods:. InitCells initializes memory storage for cells and begins exploration process; from the root cell. The empty cells are allocated/filled using CellFill.; The procedure Grow which loops over cells, picks up the cell with the biggest; ``driver integral'', see Comp. Phys. Commun. 152 152 (2003) 55 for explanations,; with the help of PeekMax procedure. The chosen cell is split using Divide.; Subsequently, the procedure Explore called by the Divide; (and by InitCells for the root cell) does the most important; job in the FOAM object build-up: it performs a small MC run for each; newly allocated daughter cell.; Explore calculates how profitable the future split of the cell will be; and defines the optimal cell division geometry with the help of Carver or Varedu; procedures, for maximum weight or variance optimization respectively.; All essential results of the exploration are written into; the explored cell object. At the very end of the foam build-up,; Finally, MakeActiveList is invoked to create a list of pointers to; all active cells, for the purpose of the quick access during the MC generation.; The procedure Explore employs MakeAlpha to generate random coordinates; inside a given cell with the uniform distribution.; The above sequence of the procedure calls is depicted in the following figure:. . void Initialize(); Basic initialization of FOAM invoked by the user.; IMPORTANT: Random number generator and the distribution object has to be; provided using SetPseRan and SetRho pri",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFoam.html:15340,allocate,allocated,15340,root/html528/TFoam.html,https://root.cern,https://root.cern/root/html528/TFoam.html,6,['allocate'],['allocated']
Energy Efficiency,"RField.cxx. ◆ Create() [2/2]. ROOT::Experimental::RResult< std::unique_ptr< ROOT::Experimental::RFieldBase > > ROOT::Experimental::RFieldBase::Create ; (; const std::string & ; fieldName, . const std::string & ; typeName . ). static . Factory method to resurrect a field from the stored on-disk type information. ; Definition at line 582 of file RField.cxx. ◆ CreateBulk(). ROOT::Experimental::RFieldBase::RBulk ROOT::Experimental::RFieldBase::CreateBulk ; (; ). The returned bulk is initially empty; RBulk::ReadBulk will construct the array of values. ; Definition at line 1076 of file RField.cxx. ◆ CreateObject() [1/3]. template<> . std::unique_ptr< void, typename RFieldBase::RCreateObjectDeleter< void >::deleter > ROOT::Experimental::RFieldBase::CreateObject ; (; ); const. ◆ CreateObject() [2/3]. template<typename T > . std::unique_ptr< T, typename RFieldBase::RCreateObjectDeleter< T >::deleter > ROOT::Experimental::RFieldBase::CreateObject. Generates an object of the field type and allocates new initialized memory according to the type. ; Implemented at the end of this header because the implementation is using RField<T>::TypeName() The returned object can be released with delete, i.e. it is valid to call auto ptr = field->CreateObject(); delete ptr.release();; Note that CreateObject<void> is supported. The returned unique_ptr has a custom deleter that reports an error if it is called. The intended use of the returned unique_ptr<void> is to call release(). In this way, the transfer of pointer ownership is explicit. ; Definition at line 451 of file RField.hxx. ◆ CreateObject() [3/3]. template<> . std::unique_ptr< void, typename ROOT::Experimental::RFieldBase::RCreateObjectDeleter< void >::deleter > ROOT::Experimental::RFieldBase::CreateObject ; (; ); const. Definition at line 542 of file RField.cxx. ◆ CreateObjectRawPtr(). void * ROOT::Experimental::RFieldBase::CreateObjectRawPtr ; (; ); const. protected . Factory method for the field's type. The caller owns the returne",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RFieldBase.html:29531,allocate,allocates,29531,doc/master/classROOT_1_1Experimental_1_1RFieldBase.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RFieldBase.html,1,['allocate'],['allocates']
Energy Efficiency,"RNode MaybeAddRange(RNode df, bool mustAddRange); 1107{; 1108 return mustAddRange ? df.Range(1) : df;; 1109}; 1110// use as :; 1111ROOT::RDataFrame df(10);; 1112auto maybeRangedDF = MaybeAddRange(df, true);; 1113~~~; 1114 ; 1115The conversion to ROOT::RDF::RNode is cheap, but it will introduce an extra virtual call during the RDataFrame event; 1116loop (in most cases, the resulting performance impact should be negligible). Python users can perform the conversion with the helper function `ROOT.RDF.AsRNode`.; 1117 ; 1118\anchor RDFCollections; 1119### Storing RDataFrame objects in collections; 1120 ; 1121ROOT::RDF::RNode also makes it simple to store RDataFrame nodes in collections, e.g. a `std::vector<RNode>` or a `std::map<std::string, RNode>`:; 1122 ; 1123~~~{.cpp}; 1124std::vector<ROOT::RDF::RNode> dfs;; 1125dfs.emplace_back(ROOT::RDataFrame(10));; 1126dfs.emplace_back(dfs[0].Define(""x"", ""42.f""));; 1127~~~; 1128 ; 1129\anchor callbacks; 1130### Executing callbacks every N events; 1131It's possible to schedule execution of arbitrary functions (callbacks) during the event loop.; 1132Callbacks can be used e.g. to inspect partial results of the analysis while the event loop is running,; 1133drawing a partially-filled histogram every time a certain number of new entries is processed, or; 1134displaying a progress bar while the event loop runs.; 1135 ; 1136For example one can draw an up-to-date version of a result histogram every 100 entries like this:; 1137~~~{.cpp}; 1138auto h = df.Histo1D(""x"");; 1139TCanvas c(""c"",""x hist"");; 1140h.OnPartialResult(100, [&c](TH1D &h_) { c.cd(); h_.Draw(); c.Update(); });; 1141// event loop runs here, this final `Draw` is executed after the event loop is finished; 1142h->Draw();; 1143~~~; 1144 ; 1145Callbacks are registered to a ROOT::RDF::RResultPtr and must be callables that takes a reference to the result type as argument; 1146and return nothing. RDataFrame will invoke registered callbacks passing partial action results as arguments t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RDataFrame_8cxx_source.html:65953,schedul,schedule,65953,doc/v632/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/RDataFrame_8cxx_source.html,1,['schedul'],['schedule']
Energy Efficiency,"RNode MaybeAddRange(RNode df, bool mustAddRange); 1147{; 1148 return mustAddRange ? df.Range(1) : df;; 1149}; 1150// use as :; 1151ROOT::RDataFrame df(10);; 1152auto maybeRangedDF = MaybeAddRange(df, true);; 1153~~~; 1154 ; 1155The conversion to ROOT::RDF::RNode is cheap, but it will introduce an extra virtual call during the RDataFrame event; 1156loop (in most cases, the resulting performance impact should be negligible). Python users can perform the conversion with the helper function `ROOT.RDF.AsRNode`.; 1157 ; 1158\anchor RDFCollections; 1159### Storing RDataFrame objects in collections; 1160 ; 1161ROOT::RDF::RNode also makes it simple to store RDataFrame nodes in collections, e.g. a `std::vector<RNode>` or a `std::map<std::string, RNode>`:; 1162 ; 1163~~~{.cpp}; 1164std::vector<ROOT::RDF::RNode> dfs;; 1165dfs.emplace_back(ROOT::RDataFrame(10));; 1166dfs.emplace_back(dfs[0].Define(""x"", ""42.f""));; 1167~~~; 1168 ; 1169\anchor callbacks; 1170### Executing callbacks every N events; 1171It's possible to schedule execution of arbitrary functions (callbacks) during the event loop.; 1172Callbacks can be used e.g. to inspect partial results of the analysis while the event loop is running,; 1173drawing a partially-filled histogram every time a certain number of new entries is processed, or; 1174displaying a progress bar while the event loop runs.; 1175 ; 1176For example one can draw an up-to-date version of a result histogram every 100 entries like this:; 1177~~~{.cpp}; 1178auto h = df.Histo1D(""x"");; 1179TCanvas c(""c"",""x hist"");; 1180h.OnPartialResult(100, [&c](TH1D &h_) { c.cd(); h_.Draw(); c.Update(); });; 1181// event loop runs here, this final `Draw` is executed after the event loop is finished; 1182h->Draw();; 1183~~~; 1184 ; 1185Callbacks are registered to a ROOT::RDF::RResultPtr and must be callables that takes a reference to the result type as argument; 1186and return nothing. RDataFrame will invoke registered callbacks passing partial action results as arguments t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDataFrame_8cxx_source.html:67633,schedul,schedule,67633,doc/master/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RDataFrame_8cxx_source.html,1,['schedul'],['schedule']
Energy Efficiency,"ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. h1analysisProxy.h. Go to the documentation of this file. 1#include ""TH2.h""; 2#include ""TF1.h""; 3#include ""TStyle.h""; 4#include ""TCanvas.h""; 5#include ""TLine.h""; 6#include ""TEntryList.h""; 7#include ""TPaveStats.h""; 8#include ""TMath.h""; 9 ; 10const Double_t dxbin = (0.17-0.13)/40; // Bin-width; 11const Double_t sigma = 0.0012;; 12 ; 13//_____________________________________________________________________; 14Double_t fdm5(Double_t *xx, Double_t *par); 15{; 16 Double_t x = xx[0];; 17 if (x <= 0.13957) return 0;; 18 Double_t xp3 = (x-par[3])*(x-par[3]);; 19 Double_t res = dxbin*(par[0]*TMath::Power(x-0.13957, par[1]); 20 + par[2] / 2.5066/par[4]*TMath::Exp(-xp3/2/par[4]/par[4]));; 21 return res;; 22}; 23 ; 24//_____________________________________________________________________; 25Double_t fdm2(Double_t *xx, Double_t *par); 26{; 27 Double_t x = xx[0];; 28 if (x <= 0.13957) return 0;; 29 Double_t xp3 = (x-0.1454)*(x-0.1454);; 30 Double_t res = dxbin*(par[0]*TMath::Power(x-0.13957, 0.25); 31 + par[1] / 2.5066/sigma*TMath::Exp(-xp3/2/sigma/sigma));; 32 return res;; 33}; 34 ; Double_tdouble Double_tDefinition RtypesCore.h:59; TCanvas.h; TEntryList.h; TF1.h; TH2.h; TLine.h; TMath.h; TPaveStats.h; TStyle.h; fdm5Double_t fdm5(Double_t *xx, Double_t *par)Definition h1analysisProxy.h:14; sigmaconst Double_t sigmaDefinition h1analysisProxy.h:11; dxbinconst Double_t dxbinDefinition h1analysisProxy.h:10; fdm2Double_t fdm2(Double_t *xx, Double_t *par)Definition h1analysisProxy.h:25; xDouble_t x[n]Definition legend1.C:17; TMath::ExpDouble_t Exp(Double_t x)Returns the base-e exponential function of x, which is e raised to the power x.Definition TMath.h:709; TMath::PowerLongDouble_t Power(LongDouble_t x, LongDouble_t y)Returns x raised to the power y.Definition TMath.h:721. tutorialstreeh1analysisProxy.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:11 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/h1analysisProxy_8h_source.html:1770,power,power,1770,doc/master/h1analysisProxy_8h_source.html,https://root.cern,https://root.cern/doc/master/h1analysisProxy_8h_source.html,2,['power'],['power']
Energy Efficiency,"ROOT->GetListOfSpecials()->FindObject(""contours"");; Int_t ncontours = contours->GetSize();; TList *list = (TList*)contours->At(i);; Where i is a contour number, and list contains a list of TGraph objects. For one given contour, more than one disjoint polyline may be generated. The number of TGraphs per contour is given by: list->GetSize();; To access the first graph in the list one should do: TGraph *gr1 = (TGraph*)list->First();; The following example (ContourList.C) shows how to use this functionality.; ; Double_t SawTooth(Double_t x, Double_t WaveLen);; ; TCanvas *ContourList(){; ; const Double_t PI = TMath::Pi();; ; TCanvas* c = new TCanvas(""c"",""Contour List"",0,0,600,600);; c->SetRightMargin(0.15);; c->SetTopMargin(0.15);; ; Int_t i, j;; ; Int_t nZsamples = 80;; Int_t nPhiSamples = 80;; ; Double_t HofZwavelength = 4.0; // 4 meters; Double_t dZ = HofZwavelength/(Double_t)(nZsamples - 1);; Double_t dPhi = 2*PI/(Double_t)(nPhiSamples - 1);; ; TArrayD z(nZsamples);; TArrayD HofZ(nZsamples);; TArrayD phi(nPhiSamples);; TArrayD FofPhi(nPhiSamples);; ; // Discretized Z and Phi Values; for ( i = 0; i < nZsamples; i++) {; z[i] = (i)*dZ - HofZwavelength/2.0;; HofZ[i] = SawTooth(z[i], HofZwavelength);; }; ; for(Int_t i=0; i < nPhiSamples; i++){; phi[i] = (i)*dPhi;; FofPhi[i] = sin(phi[i]);; }; ; // Create Histogram; TH2D *HistStreamFn = new TH2D(""HstreamFn"",; ""#splitline{Histogram with negative and positive contents. Six contours are defined.}{It is plotted with options CONT LIST to retrieve the contours points in TGraphs}"",; nZsamples, z[0], z[nZsamples-1], nPhiSamples, phi[0], phi[nPhiSamples-1]);; ; // Load Histogram Data; for (Int_t i = 0; i < nZsamples; i++) {; for(Int_t j = 0; j < nPhiSamples; j++){; HistStreamFn->SetBinContent(i,j, HofZ[i]*FofPhi[j]);; }; }; ; gStyle->SetOptStat(0);; gStyle->SetTitleW(0.99);; gStyle->SetTitleH(0.08);; ; Double_t contours[6];; contours[0] = -0.7;; contours[1] = -0.5;; contours[2] = -0.1;; contours[3] = 0.1;; contours[4] = 0.4;; conto",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHistPainter.html:81214,meter,meters,81214,doc/master/classTHistPainter.html,https://root.cern,https://root.cern/doc/master/classTHistPainter.html,1,['meter'],['meters']
Energy Efficiency,"ROOT::Math::IntegratorMultiDim::IntegratorMultiDim ; (; const IMultiGenFunction & ; f, . IntegrationMultiDim::Type ; type = IntegrationMultiDim::kDEFAULT, . double ; absTol = -1, . double ; relTol = -1, . unsigned int ; ncall = 0 . ). inlineexplicit . Generic Constructor of multi dimensional Integrator passing a function. ; By default uses the adaptive integration method; Parameters. fintegration function (multi-dim interface) ; typeintegration type (adaptive, MC methods, etc..) ; absToldesired absolute Error ; relToldesired relative Error ; ncallnumber of function calls (apply only to MC integration methods) . Definition at line 79 of file IntegratorMultiDim.h. ◆ ~IntegratorMultiDim(). virtual ROOT::Math::IntegratorMultiDim::~IntegratorMultiDim ; (; ). inlinevirtual . Template Constructor of multi dimensional Integrator passing a generic function. ; By default uses the adaptive integration method; Parameters. fintegration function (generic function implementing operator()(const double *) ; dimfunction dimension ; typeintegration type (adaptive, MC methods, etc..) ; absToldesired absolute Error ; relToldesired relative Error ; ncallnumber of function calls (apply only to MC integration methods) destructor . Definition at line 105 of file IntegratorMultiDim.h. ◆ IntegratorMultiDim() [3/3]. ROOT::Math::IntegratorMultiDim::IntegratorMultiDim ; (; const IntegratorMultiDim & ; ). inlineprivate . Definition at line 113 of file IntegratorMultiDim.h. Member Function Documentation. ◆ CreateIntegrator(). VirtualIntegratorMultiDim * ROOT::Math::IntegratorMultiDim::CreateIntegrator ; (; IntegrationMultiDim::Type ; type, . double ; absTol, . double ; relTol, . unsigned int ; ncall . ). protected . Definition at line 178 of file Integrator.cxx. ◆ Error(). double ROOT::Math::IntegratorMultiDim::Error ; (; ); const. inline . return integration error ; Definition at line 159 of file IntegratorMultiDim.h. ◆ GetIntegrator(). VirtualIntegratorMultiDim * ROOT::Math::IntegratorMultiDim::G",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1IntegratorMultiDim.html:5693,adapt,adaptive,5693,doc/master/classROOT_1_1Math_1_1IntegratorMultiDim.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1IntegratorMultiDim.html,1,['adapt'],['adaptive']
Energy Efficiency,"ROOT::Math::PxPyPzE4D<double> >::Scalar xx, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >::Scalar yy, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >::Scalar zz, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >::Scalar ee). bool operator==(const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >& rhs) const; ------------------- Equality -----------------. Exact equality. bool operator!=(const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >& rhs) const. Scalar Px() const; ------ Individual element access, in various coordinate systems ------; individual coordinate accessors in various coordinate systems. spatial X component. { return fCoordinates.Px(); }. Scalar X() const. spatial Y component. { return fCoordinates.Px(); }. Scalar Py() const; { return fCoordinates.Py(); }. Scalar Y() const. spatial Z component. { return fCoordinates.Py(); }. Scalar Pz() const; { return fCoordinates.Pz(); }. Scalar Z() const. return 4-th component (time, or energy for a 4-momentum vector). { return fCoordinates.Pz(); }. Scalar E() const; { return fCoordinates.E(); }. Scalar T() const. return magnitude (mass) squared M2 = T**2 - X**2 - Y**2 - Z**2; (we use -,-,-,+ metric). { return fCoordinates.E(); }. Scalar M2() const. return magnitude (mass) using the (-,-,-,+) metric.; If M2 is negative (space-like vector) a GenVector_exception; is suggested and if continuing, - sqrt( -M2) is returned. { return fCoordinates.M2(); }. Scalar M() const. return the spatial (3D) magnitude ( sqrt(X**2 + Y**2 + Z**2) ). { return fCoordinates.M();}. Scalar R() const; { return fCoordinates.R(); }. Scalar P() const. return the square of the spatial (3D) magnitude ( X**2 + Y**2 + Z**2 ). { return fCoordinates.R(); }. Scalar P2() const. return the square of the transverse spatial component ( X**2 + Y**2 ). { return P() * P(); }. Scalar Perp2() const; { return fCoordinates.Perp2();}. Scalar Pt() const. return the transverse spatial component sqrt ( X**2 + Y**2 ). {",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__LorentzVector_-p1PxPyPzE4D_double___.html:16195,energy,energy,16195,root/html526/ROOT__Math__LorentzVector_-p1PxPyPzE4D_double___.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__LorentzVector_-p1PxPyPzE4D_double___.html,9,['energy'],['energy']
Energy Efficiency,"ROOT::Math::PxPyPzM4D<double> >::Scalar xx, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >::Scalar yy, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >::Scalar zz, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >::Scalar ee). bool operator==(const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >& rhs) const; ------------------- Equality -----------------. Exact equality. bool operator!=(const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >& rhs) const. Scalar Px() const; ------ Individual element access, in various coordinate systems ------; individual coordinate accessors in various coordinate systems. spatial X component. { return fCoordinates.Px(); }. Scalar X() const. spatial Y component. { return fCoordinates.Px(); }. Scalar Py() const; { return fCoordinates.Py(); }. Scalar Y() const. spatial Z component. { return fCoordinates.Py(); }. Scalar Pz() const; { return fCoordinates.Pz(); }. Scalar Z() const. return 4-th component (time, or energy for a 4-momentum vector). { return fCoordinates.Pz(); }. Scalar E() const; { return fCoordinates.E(); }. Scalar T() const. return magnitude (mass) squared M2 = T**2 - X**2 - Y**2 - Z**2; (we use -,-,-,+ metric). { return fCoordinates.E(); }. Scalar M2() const. return magnitude (mass) using the (-,-,-,+) metric.; If M2 is negative (space-like vector) a GenVector_exception; is suggested and if continuing, - sqrt( -M2) is returned. { return fCoordinates.M2(); }. Scalar M() const. return the spatial (3D) magnitude ( sqrt(X**2 + Y**2 + Z**2) ). { return fCoordinates.M();}. Scalar R() const; { return fCoordinates.R(); }. Scalar P() const. return the square of the spatial (3D) magnitude ( X**2 + Y**2 + Z**2 ). { return fCoordinates.R(); }. Scalar P2() const. return the square of the transverse spatial component ( X**2 + Y**2 ). { return P() * P(); }. Scalar Perp2() const; { return fCoordinates.Perp2();}. Scalar Pt() const. return the transverse spatial component sqrt ( X**2 + Y**2 ). {",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__LorentzVector_-p1PxPyPzM4D_double___.html:14589,energy,energy,14589,root/html526/ROOT__Math__LorentzVector_-p1PxPyPzM4D_double___.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__LorentzVector_-p1PxPyPzM4D_double___.html,9,['energy'],['energy']
Energy Efficiency,"ROOT::RVecD are also available as template instantiations of RVec of fundamental types. The full list of available aliases:; RVecB (bool); RVecC (char); RVecD (double); RVecF (float); RVecI (int); RVecL (long); RVecLL (long long); RVecU (unsigned); RVecUL (unsigned long); RVecULL (unsigned long long). RVec does not attempt to be exception safe. Exceptions thrown by element constructors during insertions, swaps or other operations will be propagated potentially leaving the RVec object in an invalid state. RVec methods (e.g. at or size) follow the STL naming convention instead of the ROOT naming convention in order to make RVec a drop-in replacement for std::vector. Table of Contents. Example; Arithmetic operations, logical operations and mathematical functions; Owning and adopting memory; Sorting and manipulation of indices; Usage in combination with RDataFrame; Reference for the RVec class; Reference for RVec helper functions. Example; Suppose to have an event featuring a collection of muons with a certain pseudorapidity, momentum and charge, e.g.: std::vector<short> mu_charge {1, 1, -1, -1, -1, 1, 1, -1};; std::vector<float> mu_pt {56, 45, 32, 24, 12, 8, 7, 6.2};; std::vector<float> mu_eta {3.1, -.2, -1.1, 1, 4.1, 1.6, 2.4, -.5};; Suppose you want to extract the transverse momenta of the muons satisfying certain criteria, for example consider only negatively charged muons with a pseudorapidity smaller or equal to 2 and with a transverse momentum greater than 10 GeV. Such a selection would require, among the other things, the management of an explicit loop, for example: std::vector<float> goodMuons_pt;; const auto size = mu_charge.size();; for (size_t i=0; i < size; ++i) {; if (mu_pt[i] > 10 && abs(mu_eta[i]) <= 2. && mu_charge[i] == -1) {; goodMuons_pt.emplace_back(mu_pt[i]);; }; }; ROOT::Internal::VecOps::SmallVectorTemplateCommon::sizesize_t size() constDefinition RVec.hxx:174; ROOT::VecOps::absRVec< PromoteType< T > > abs(const RVec< T > &v)Definition RVec.hxx:18",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1VecOps_1_1RVec.html:1993,charge,charge,1993,doc/v632/classROOT_1_1VecOps_1_1RVec.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1VecOps_1_1RVec.html,2,['charge'],['charge']
Energy Efficiency,"ROOTConfig.cmake should not set CMAKE_MODULE_PATH nor install FindX modules; [ROOT-7809] - TWebFile infinite loop for 301 redirects without Location; [ROOT-7817] - Avoid a crash under some circumstances when trying to open an invalid path.; [ROOT-7787] - CMake: allow disabling ncurses. Release 6.04/14; Build system. Added build option builtin_openssl to build OpenSSL internally. This is specially needed for the lastest Mac OSX (El Capitan); Fix configuration of threading in LLVM.; Fix issue with inconsistent visibility ROOT-7896. GL. Mattias Ellert fixed a memory leak [PR114]. Interpreter. Update automatic variables if gDirectory changes ROOT-7830; Fix issue with initialization of statics in interpreter ROOT-7901. PyROOT. Fix handling of vector<enums> ROOT-7916. Release 6.04/16; Published on 2016-03-17.; Core. Properly handle the case of an executable with a space in its full pathname when search for linked in library. This fixes [ROOT-8019].; Reduce memory consumption (autoparsing) of plugins TXNetSystem/TNetXNGSystem and TGQt. Meta Library. Added a new mode for TClass::SetCanSplit (2) which indicates that this class and any derived class should not be split.; This included a rework the mechanism checking the base classes. Instead of using InheritsFrom, which lead in some cases, including the case where the class derived from an STL collection, to spurrious autoparsing (to look at the base class of the collection!), we use a custom walk through the tree of base classes that checks their value of fCanSplit.; This also has the side-effect of allowing the extension of the concept ‘base class that prevent its derived class from being split’ to any user class. This fixes [ROOT-7972].; Reduce autoparse occasions by autoloading libraries also based on their type_info-derived name, instead of only their normalized name.; Improve TClassEdit’s handling of STL’s default allocator, in particular for std::map ROOT-8048. Dictionaries. Add the -noIncludePaths and –noIncludePaths ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v604/release-notes.html:37179,consumption,consumption,37179,doc/v604/release-notes.html,https://root.cern,https://root.cern/doc/v604/release-notes.html,1,['consumption'],['consumption']
Energy Efficiency,"ROOT_Math_QuasiRandom; 32#define ROOT_Math_QuasiRandom; 33 ; 34#include <string>; 35 ; 36/**; 37 @defgroup QuasiRandom QuasiRandom number generators and distributions; 38 Classes for generating QuasiRandom numbers and based on GSL ; 39 @ingroup Random; 40 @ingroup MathMore; 41*/; 42 ; 43 ; 44 ; 45namespace ROOT {; 46namespace Math {; 47 ; 48 ; 49//_____________________________________________________________________________________; 50/**; 51 User class for MathMore random numbers template on the Engine type.; 52 The API of this class followed that of the class ROOT::Math::Random; 53 It must be implemented using as Engine one of the derived classes of; 54 ROOT::Math::GSLQuasiRandomEngine, like ROOT::Math::GSLQrngSobol; 55 ; 56 @ingroup QuasiRandom; 57 ; 58*/; 59template < class Engine>; 60class QuasiRandom {; 61 ; 62public:; 63 ; 64 ; 65 /**; 66 Create a QuasiRandom generator. Use default engine constructor.; 67 Engine will be initialized via Initialize() function in order to; 68 allocate resources; 69 */; 70 QuasiRandom(unsigned int dimension = 1) {; 71 fEngine.Initialize(dimension);; 72 }; 73 ; 74 ; 75 /**; 76 Create a QuasiRandom generator based on a provided generic engine.; 77 Engine will be initialized via Initialize() function in order to; 78 allocate resources; 79 */; 80 explicit QuasiRandom(const Engine & e, unsigned int dimension = 1) : fEngine(e) {; 81 fEngine.Initialize(dimension);; 82 }; 83 ; 84 /**; 85 Destructor: call Terminate() function of engine to free any; 86 allocated resource; 87 */; 88 ~QuasiRandom() {; 89 fEngine.Terminate();; 90 }; 91 ; 92 /**; 93 Generate next quasi random numbers points; 94 */; 95 bool Next(double * x) {; 96 return fEngine(x);; 97 }; 98 ; 99 /**; 100 Generate next quasi random numbers point (1 - dimension); 101 */; 102 double Next() {; 103 return fEngine();; 104 }; 105 ; 106 /**; 107 Generate quasi random numbers between ]0,1[; 108 0 and 1 are excluded; 109 Function to be compatible with ROOT TRandom compatibility; 110 */;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/QuasiRandom_8h_source.html:2481,allocate,allocate,2481,doc/master/QuasiRandom_8h_source.html,https://root.cern,https://root.cern/doc/master/QuasiRandom_8h_source.html,1,['allocate'],['allocate']
Energy Efficiency,"RUE); Initialize particle direction (tangent on the helix in initial point). void InitDirection(Double_t* dir, Bool_t is_normalized = kTRUE); Initialize particle direction (tangent on the helix in initial point). Double_t GetTotalCurvature() const; Compute helix total curvature. void SetXYcurvature(Double_t curvature); Set XY curvature: c = 1/Rxy. void SetCharge(Int_t charge); Positive charge means left-handed helix. void SetField(Double_t bx, Double_t by, Double_t bz, Bool_t is_normalized = kTRUE); Initialize particle direction (tangent on the helix in initial point). void SetHelixStep(Double_t hstep); Set Z step of the helix on a complete turn. Positive or null. void ResetStep(); Reset current point/direction to initial values. void Step(Double_t step); Make a step from current point along the helix and compute new point, direction and angle; To reach a plane/ shape boundary, one has to:; 1. Compute the safety to the plane/boundary; 2. Define / update a helix according local field and particle state (position, direction, charge); 3. Compute the magnetic safety (maximum distance for which the field can be considered constant); 4. Call TGeoHelix::Step() having as argument the minimum between 1. and 3.; 5. Repeat from 1. until the step to be made is small enough.; 6. Add to the total step the distance along a straigth line from the last point; to the plane/shape boundary. Double_t StepToPlane(Double_t* point, Double_t* norm); Propagate initial point up to a given Z position in MARS. void UpdateHelix(); Update the local helix matrix. TGeoHelix(); constructors. const Double_t * GetCurrentPoint() const; {return fPoint;}. const Double_t * GetCurrentDirection() const; {return fDir;}. Double_t GetXYcurvature() const; {return fC;}. Double_t GetStep() const; {return fStep;}. Bool_t IsRightHanded() const; {return (fQ>0)?kFALSE:kTRUE;}. » Author: Andrei Gheata 28/04/04 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id: TGeoHelix.h 21425 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoHelix.html:9135,charge,charge,9135,root/html528/TGeoHelix.html,https://root.cern,https://root.cern/root/html528/TGeoHelix.html,3,['charge'],['charge']
Energy Efficiency,"RUE); Initialize particle direction (tangent on the helix in initial point). void InitDirection(Double_t* dir, Bool_t is_normalized = kTRUE); Initialize particle direction (tangent on the helix in initial point). Double_t GetTotalCurvature() const; Compute helix total curvature. void SetXYcurvature(Double_t curvature); Set XY curvature: c = 1/Rxy. void SetCharge(Int_t charge); Positive charge means left-handed helix. void SetField(Double_t bx, Double_t by, Double_t bz, Bool_t is_normalized = kTRUE); Initialize particle direction (tangent on the helix in initial point). void SetHelixStep(Double_t hstep); Set Z step of the helix on a complete turn. Positive or null. void ResetStep(); Reset current point/direction to initial values. void Step(Double_t step); Make a step from current point along the helix and compute new point, direction and angle; To reach a plane/ shape boundary, one has to:; 1. Compute the safety to the plane/boundary; 2. Define / update a helix according local field and particle state (position, direction, charge); 3. Compute the magnetic safety (maximum distance for which the field can be considered constant); 4. Call TGeoHelix::Step() having as argument the minimum between 1. and 3.; 5. Repeat from 1. until the step to be made is small enough.; 6. Add to the total step the distance along a straigth line from the last point; to the plane/shape boundary. Double_t StepToPlane(Double_t* point, Double_t* norm); Propagate initial point up to a given Z position in MARS. void UpdateHelix(); Update the local helix matrix. TGeoHelix(const TGeoHelix& ). TGeoHelix & operator=(const TGeoHelix& ). const Double_t * GetCurrentPoint() const; {return fPoint;}. const Double_t * GetCurrentDirection() const; {return fDir;}. Double_t GetXYcurvature() const; {return fC;}. Double_t GetStep() const; {return fStep;}. Bool_t IsRightHanded() const; {return (fQ>0)?kFALSE:kTRUE;}. » Author: Andrei Gheata 28/04/04 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » La",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoHelix.html:9233,charge,charge,9233,root/html534/TGeoHelix.html,https://root.cern,https://root.cern/root/html534/TGeoHelix.html,3,['charge'],['charge']
Energy Efficiency,Rank : Variable : Delta Separation; : -----------------------------------; : 1 : var4 : 1.353e-01; : 2 : var3 : 6.016e-02; : 3 : var2 : 1.277e-02; : 4 : var1 : 5.885e-03; : -----------------------------------; : Elapsed time for training with 10000 events: 0.252 sec ; <HEADER> Category_Likelihood_1 : [Category_Likelihood_1_dsi] : Evaluation of Category_Likelihood_1 on training sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.0108 sec ; <HEADER> Category_Likelihood_2 : [Category_Likelihood_2_dsi] : Evaluation of Category_Likelihood_2 on training sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00971 sec ; : Creating xml weight file: dataset/weights/TMVAClassificationCategory_LikelihoodCat.weights.xml; <HEADER> Factory : Training finished; : ; : Ranking input variables (method specific)...; <HEADER> Fisher : Ranking result (top variable is best ranked); : -------------------------------; : Rank : Variable : Discr. power; : -------------------------------; : 1 : var4 : 1.446e-01; : 2 : var3 : 7.153e-02; : 3 : var2 : 2.447e-02; : 4 : var1 : 1.243e-02; : -------------------------------; <HEADER> Likelihood : Ranking result (top variable is best ranked); : -----------------------------------; : Rank : Variable : Delta Separation; : -----------------------------------; : 1 : var4 : 1.148e-01; : 2 : var3 : 5.071e-02; : 3 : var2 : 2.758e-02; : 4 : var1 : 1.990e-02; : -----------------------------------; : No variable ranking supplied by classifier: FisherCat; : No variable ranking supplied by classifier: LikelihoodCat; <HEADER> Factory : === Destroy and recreate all methods via weight files for testing ===; : ; : Reading weight file: dataset/weights/TMVAClassificationCategory_Fisher.weights.xml; : Reading weight file: dataset/weights/TMVAClassificationCategory_Likelihood.weights.xml; : Reading weight file: dataset/weights/TMVAClassificationCategory_FisherCat.weights.xml; : Recreating sub-classifiers from XML-file ; <HEADER> DataS,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAClassificationCategory_8C.html:20813,power,power,20813,doc/master/TMVAClassificationCategory_8C.html,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategory_8C.html,1,['power'],['power']
Energy Efficiency,"ReadAll(Option_t* option = """"); Read objects from a ROOT db file directory into memory.; If an object is already in memory, the memory copy is deleted; and the object is again read from the file.; If opt==""dirs"", only subdirectories will be read; If opt==""dirs*"" complete directory tree will be read. Int_t ReadKeys(Bool_t forceRead = kTRUE); Read the KEYS linked list; *-* =========================; Every directory has a linked list (fKeys). This linked list has been; written on the file via WriteKeys as a single data record. It is interesting to call this function in the following situation.; Assume another process1 is connecting this directory in Update mode; -Process1 is adding/updating objects in this directory; -You want to see the latest status from process1.; Example Process1:; obj1.Write();; obj2.Write();; gDirectory->SaveSelf();. Example Process2; gDirectory->ReadKeys();; obj1->Draw();. This is an efficient way (without opening/closing files) to view; the latest updates of a file being modified by another process; as it is typically the case in a data acquisition system. Int_t ReadTObject(TObject* obj, const char* keyname); Read object with keyname from the current directory; Read contents of object with specified name from the current directory.; First the key with keyname is searched in the current directory,; next the key buffer is deserialized into the object.; The object must have been created before via the default constructor.; See TObject::Write(). void ResetAfterMerge(TFileMergeInfo* ); Reset the TDirectory after its content has been merged into another; Directory. This returns the TDirectoryFile object back to its state; before any data has been written to the file.; The object in the in-memory list are assumed to also have been reset. void rmdir(const char* name); Removes subdirectory from the directory; When diredctory is deleted, all keys in all subdirectories will be; read first and deleted from file (if exists); Equivalent call is Delete(""name;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TDirectoryFile.html:21671,efficient,efficient,21671,root/html532/TDirectoryFile.html,https://root.cern,https://root.cern/root/html532/TDirectoryFile.html,4,['efficient'],['efficient']
Energy Efficiency,"ReadAll(Option_t* option = """"); Read objects from a ROOT db file directory into memory.; If an object is already in memory, the memory copy is deleted; and the object is again read from the file.; If opt==""dirs"", only subdirectories will be read; If opt==""dirs*"" complete directory tree will be read. Int_t ReadKeys(Bool_t forceRead = kTRUE); Read the KEYS linked list; *-* =========================; Every directory has a linked list (fKeys). This linked list has been; written on the file via WriteKeys as a single data record. It is interesting to call this function in the following situation.; Assume another process1 is connecting this directory in Update mode; -Process1 is adding/updating objects in this directory; -You want to see the latest status from process1.; Example Process1:; obj1.Write();; obj2.Write();; gDirectory->SaveSelf();. Example Process2; gDirectory->ReadKeys();; obj1->Draw();. This is an efficient way (without opening/closing files) to view; the latest updates of a file being modified by another process; as it is typically the case in a data acquisition system. Int_t ReadTObject(TObject* obj, const char* keyname); Read object with keyname from the current directory; Read contents of object with specified name from the current directory.; First the key with keyname is searched in the current directory,; next the key buffer is deserialized into the object.; The object must have been created before via the default constructor.; See TObject::Write(). void rmdir(const char* name); Removes subdirectory from the directory; When diredctory is deleted, all keys in all subdirectories will be; read first and deleted from file (if exists); Equivalent call is Delete(""name;*"");. void Save(); *-*-*-*-*Save recursively all directory keys and headers; *-* ===============================================. Int_t SaveObjectAs(const TObject* obj, const char* filename = """", Option_t* option = """") const; Save object in filename,; if filename is 0 or """", a file with ""object",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TDirectoryFile.html:21370,efficient,efficient,21370,root/html528/TDirectoryFile.html,https://root.cern,https://root.cern/root/html528/TDirectoryFile.html,2,['efficient'],['efficient']
Energy Efficiency,"ReadArray (TBuffer &b, const TClass *clReq);  Read TArray object from buffer. ;  ; static void WriteArray (TBuffer &b, const TArray *a);  Write TArray object to buffer. ;  . Protected Member Functions; Double_t RetrieveBinContent (Int_t bin) const override;  Raw retrieval of bin content on internal data structure see convention for numbering bins in TH1::GetBin. ;  ;  Protected Member Functions inherited from TH1;  TH1 ();  Histogram default constructor. ;  ;  TH1 (const char *name, const char *title, Int_t nbinsx, const Double_t *xbins);  Constructor for variable bin size histograms using an input array of type double. ;  ;  TH1 (const char *name, const char *title, Int_t nbinsx, const Float_t *xbins);  Constructor for variable bin size histograms using an input array of type float. ;  ;  TH1 (const char *name, const char *title, Int_t nbinsx, Double_t xlow, Double_t xup);  Constructor for fix bin size histograms. ;  ; virtual Int_t AutoP2FindLimits (Double_t min, Double_t max);  Buffer-based estimate of the histogram range using the power of 2 algorithm. ;  ; Int_t AxisChoice (Option_t *axis) const;  Choose an axis according to ""axis"". ;  ; virtual Int_t BufferFill (Double_t x, Double_t w);  accumulate arguments in buffer. ;  ; virtual void DoFillN (Int_t ntimes, const Double_t *x, const Double_t *w, Int_t stride=1);  Internal method to fill histogram content from a vector called directly by TH1::BufferEmpty. ;  ; virtual Double_t DoIntegral (Int_t ix1, Int_t ix2, Int_t iy1, Int_t iy2, Int_t iz1, Int_t iz2, Double_t &err, Option_t *opt, Bool_t doerr=kFALSE) const;  Internal function compute integral and optionally the error between the limits specified by the bin number values working for all histograms (1D, 2D and 3D) ;  ; virtual Bool_t FindNewAxisLimits (const TAxis *axis, const Double_t point, Double_t &newMin, Double_t &newMax);  finds new limits for the axis so that point is within the range and the limits are compatible with the previous ones (see TH1::Merg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH1K.html:43173,power,power,43173,doc/master/classTH1K.html,https://root.cern,https://root.cern/doc/master/classTH1K.html,1,['power'],['power']
Energy Efficiency,"Reader.h:161; TMVA::Reader::DataInfoconst DataSetInfo & DataInfo() constDefinition Reader.h:117; TMVA::Tools::xmlengineTXMLEngine & xmlengine()Definition Tools.h:262; TMVA::Tools::ReadAttrvoid ReadAttr(void *node, const char *, T &value)read attribute from xmlDefinition Tools.h:329; TMVA::Types::Instancestatic Types & Instance()The single instance of ""Types"" if existing already, or create it (Singleton)Definition Types.cxx:70; TMVA::Types::EMVAEMVADefinition Types.h:76; TMVA::Types::kCategory@ kCategoryDefinition Types.h:97; TMVA::Types::kCuts@ kCutsDefinition Types.h:78; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::ReplaceAllTString & ReplaceAll(const TString &s1, const TString &s2)Definition TString.h:704; TString::LastSsiz_t Last(char c) constFind last occurrence of a character c.Definition TString.cxx:931; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; TString::IndexSsiz_t Index(const char *pat, Ssiz_t i=0, ECaseCompare cmp=kExact) constDefinition TString.h:651; TXMLEngine::FreeDocvoid FreeDoc(XMLDocPointer_t xmldoc)frees allocated document data and deletes document itselfDefinition TXMLEngine.cxx:1288; TXMLEngine::DocGetRootElementXMLNodePointer_t DocGetRootElement(XMLDocPointer_t xmldoc)returns root node of documentDefinition TXMLEngine.cxx:1339; TXMLEngine::ParseFileXMLDocPointer_t ParseFile(const char *filename, Int_t maxbuf=100000)Parses content of file and tries to produce xml structures.Definition TXMLEngine.cxx:1356; bool; double; int; unsigned int; nconst Int_t nDefinition legend1.C:16; TMVA::gConfigConfig & gConfig(); TMVA::gToolsTools & gTools(); TMVA::EndlMsgLogger & Endl(MsgLogger &ml)Definition MsgLogger.h:148; TMath::IsNaNBool_t IsNaN(Double_t x)Definition TMath.h:892; Config.h; Types.h. tmvatmvasrcReader.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:01 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Reader_8cxx_source.html:41623,allocate,allocated,41623,doc/master/Reader_8cxx_source.html,https://root.cern,https://root.cern/doc/master/Reader_8cxx_source.html,1,['allocate'],['allocated']
Energy Efficiency,"Real;  RooAbsReal ();  coverity[UNINIT_CTOR] Default constructor ;  ;  RooAbsReal (const char *name, const char *title, const char *unit="""");  Constructor with unit label. ;  ;  RooAbsReal (const char *name, const char *title, double minVal, double maxVal, const char *unit="""");  Constructor with plot range and unit label. ;  ;  RooAbsReal (const RooAbsReal &other, const char *name=nullptr);  Copy constructor. ;  ;  ~RooAbsReal () override;  Destructor. ;  ; virtual double analyticalIntegralWN (Int_t code, const RooArgSet *normSet, const char *rangeName=nullptr) const;  Implements the actual analytical integral(s) advertised by getAnalyticalIntegral. ;  ; TF1 * asTF (const RooArgList &obs, const RooArgList &pars=RooArgList(), const RooArgSet &nset=RooArgSet()) const;  Return a ROOT TF1,2,3 object bound to this RooAbsReal with given definition of observables and parameters. ;  ; RooFit::OwningPtr< RooAbsFunc > bindVars (const RooArgSet &vars, const RooArgSet *nset=nullptr, bool clipInvalid=false) const;  Create an interface adaptor f(vars) that binds us to the specified variables (in arbitrary order). ;  ; virtual RooFit::OwningPtr< RooFitResult > chi2FitTo (RooDataHist &data, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={});  Perform a \( \chi^2 \) fit to given histogram. ;  ; virtual RooFit::OwningPtr< RooFitResult > chi2FitTo (RooDataHist &data, const RooLinkedList &cmdList);  Calls RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList) and returns fit result. ;  ; virtual RooFit::OwningPtr< RooFitResult > chi2FitTo (RooDataSet &xydata, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={});  Perform a 2-D \( \chi^2 \) fit using a series of x ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooHistFunc.html:5581,adapt,adaptor,5581,doc/master/classRooHistFunc.html,https://root.cern,https://root.cern/doc/master/classRooHistFunc.html,1,['adapt'],['adaptor']
Energy Efficiency,"Real;  RooAbsReal ();  coverity[UNINIT_CTOR] Default constructor ;  ;  RooAbsReal (const char *name, const char *title, const char *unit="""");  Constructor with unit label. ;  ;  RooAbsReal (const char *name, const char *title, double minVal, double maxVal, const char *unit="""");  Constructor with plot range and unit label. ;  ;  RooAbsReal (const RooAbsReal &other, const char *name=nullptr);  Copy constructor. ;  ;  ~RooAbsReal () override;  Destructor. ;  ; virtual double analyticalIntegralWN (Int_t code, const RooArgSet *normSet, const char *rangeName=nullptr) const;  Implements the actual analytical integral(s) advertised by getAnalyticalIntegral. ;  ; TF1 * asTF (const RooArgList &obs, const RooArgList &pars=RooArgList(), const RooArgSet &nset=RooArgSet()) const;  Return a ROOT TF1,2,3 object bound to this RooAbsReal with given definition of observables and parameters. ;  ; RooFit::OwningPtr< RooAbsFunc > bindVars (const RooArgSet &vars, const RooArgSet *nset=nullptr, bool clipInvalid=false) const;  Create an interface adaptor f(vars) that binds us to the specified variables (in arbitrary order). ;  ; virtual std::string buildCallToAnalyticIntegral (Int_t code, const char *rangeName, RooFit::Detail::CodeSquashContext &ctx) const;  This function defines the analytical integral translation for the class. ;  ; virtual RooFit::OwningPtr< RooFitResult > chi2FitTo (RooDataHist &data, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={});  Perform a \( \chi^2 \) fit to given histogram. ;  ; virtual RooFit::OwningPtr< RooFitResult > chi2FitTo (RooDataHist &data, const RooLinkedList &cmdList);  Calls RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList) and returns fit result. ;  ; virtual RooFit::OwningPtr< RooFitResult > chi2FitTo (RooDataSet &xydata, const RooCmdArg &arg1={}, const RooCmdArg &arg2={},",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooProduct.html:4075,adapt,adaptor,4075,doc/master/classRooProduct.html,https://root.cern,https://root.cern/doc/master/classRooProduct.html,2,['adapt'],['adaptor']
Energy Efficiency,"Red Blue; 3425 case 95:; 3426 {; 3427 Double_t red[9] = { 94./255., 112./255., 141./255., 165./255., 167./255., 140./255., 91./255., 49./255., 27./255.};; 3428 Double_t green[9] = { 27./255., 46./255., 88./255., 135./255., 166./255., 161./255., 135./255., 97./255., 58./255.};; 3429 Double_t blue[9] = { 42./255., 52./255., 81./255., 106./255., 139./255., 158./255., 155./255., 137./255., 116./255.};; 3430 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3431 }; 3432 break;; 3433 ; 3434 // Rose; 3435 case 96:; 3436 {; 3437 Double_t red[9] = { 30./255., 49./255., 79./255., 117./255., 135./255., 151./255., 146./255., 138./255., 147./255.};; 3438 Double_t green[9] = { 63./255., 60./255., 72./255., 90./255., 94./255., 94./255., 68./255., 46./255., 16./255.};; 3439 Double_t blue[9] = { 18./255., 28./255., 41./255., 56./255., 62./255., 63./255., 50./255., 36./255., 21./255.};; 3440 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3441 }; 3442 break;; 3443 ; 3444 // Rust; 3445 case 97:; 3446 {; 3447 Double_t red[9] = { 0./255., 30./255., 63./255., 101./255., 143./255., 152./255., 169./255., 187./255., 230./255.};; 3448 Double_t green[9] = { 0./255., 14./255., 28./255., 42./255., 58./255., 61./255., 67./255., 74./255., 91./255.};; 3449 Double_t blue[9] = { 39./255., 26./255., 21./255., 18./255., 15./255., 14./255., 14./255., 13./255., 13./255.};; 3450 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3451 }; 3452 break;; 3453 ; 3454 // Sandy Terrain; 3455 case 98:; 3456 {; 3457 Double_t red[9] = { 149./255., 140./255., 164./255., 179./255., 182./255., 181./255., 131./255., 87./255., 61./255.};; 3458 Double_t green[9] = { 62./255., 70./255., 107./255., 136./255., 144./255., 138./255., 117./255., 87./255., 74./255.};; 3459 Double_t blue[9] = { 40./255., 38./255., 45./255., 49./255., 49./255., 49./255., 38./255., 32./255., 34./255.};; 3460 Idx = TColor::CreateGradientColorTable(9, stops",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TColor_8cxx_source.html:135489,green,green,135489,doc/master/TColor_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html,1,['green'],['green']
Energy Efficiency,"RefTEveElement::fSourceExternal object that is represented by this element.; Float_tfThetaCTransition theta; TStringTNamed::fTitleobject title; Int_tTEveElement::fTopItemCnt! Counter for top-level list-tree items that prevent automatic destruction.; void*TEveElement::fUserData! Externally assigned and controlled user data.; TEveElement*TEveElement::fVizModel! Element used as model from VizDB.; TStringTEveElement::fVizTagTag used to query VizDB for model element. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEveJetCone(const Text_t* n = ""TEveJetCone"", const Text_t* t = """"); Constructor. void ComputeBBox(); Compute bounding-box of the data. TClass* ProjectedClass(const TEveProjection* p) const; Virtual from TEveProjectable, returns TEveJetConeProjected class. Int_t AddCone(Float_t eta, Float_t phi, Float_t cone_r, Float_t length = 0); Add jet cone.; parameters are :; * (eta,phi) : of the center/leading particle; * cone_r : cone radius in eta-phi space; * length : length of the cone; * if cylinder is set and length is adapted to cylinder.; - if length is given, it will be used as scalar factor; * if cylinder is not set, length is used as length of the cone; Return 0 on sucess. Int_t AddEllipticCone(Float_t eta, Float_t phi, Float_t reta, Float_t rphi, Float_t length = 0); Add jet cone.; parameters are :; * (eta,phi) : of the center/leading particle; * (reta, rphi) : radius of cone in eta-phi space; * length : length of the cone; * if cylinder is set and length is adapted to cylinder.; - if length is given, it will be used as scalar factor; * if cylinder is not set, length is used as length of the cone; Returns 0 on sucess. TEveVector CalcEtaPhiVec(Float_t eta, Float_t phi) const; Fill TEveVector with eta and phi, magnitude 1. TEveVector CalcBaseVec(Float_t eta, Float_t phi) const; Returns point on the base of the cone with given eta and phi. TEveVector CalcBaseVec(Float_t alpha) const; Returns point on the base of the cone w",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEveJetCone.html:22553,adapt,adapted,22553,root/html528/TEveJetCone.html,https://root.cern,https://root.cern/root/html528/TEveJetCone.html,4,['adapt'],['adapted']
Energy Efficiency,"Repeat(). void TGCocoa::SetKeyAutoRepeat ; (; Bool_t ; on = kTRUE). overridevirtual . Turns key auto repeat on (kTRUE) or off (kFALSE). ; Reimplemented from TVirtualX.; Definition at line 2708 of file TGCocoa.mm. ◆ SetMWMHints(). void TGCocoa::SetMWMHints ; (; Window_t ; id, . UInt_t ; value, . UInt_t ; funcs, . UInt_t ; input . ). overridevirtual . Sets decoration style. ; Reimplemented from TVirtualX.; Definition at line 1585 of file TGCocoa.mm. ◆ SetPrimarySelectionOwner(). void TGCocoa::SetPrimarySelectionOwner ; (; Window_t ; id). overridevirtual . Makes the window ""id"" the current owner of the primary selection. ; That is the window in which, for example some text is selected. ; Reimplemented from TVirtualX.; Definition at line 3586 of file TGCocoa.mm. ◆ SetRGB(). void TGCocoa::SetRGB ; (; Int_t ; cindex, . Float_t ; r, . Float_t ; g, . Float_t ; b . ). overridevirtual . Sets color intensities the specified color index ""cindex"". ; Parameters. [in]cindexcolor index ; [in]r,g,bthe red, green, blue intensities between 0.0 and 1.0 . Reimplemented from TVirtualX.; Definition at line 2970 of file TGCocoa.mm. ◆ SetSelectionOwner(). Bool_t TGCocoa::SetSelectionOwner ; (; Window_t ; , . Atom_t & ;  . ). overridevirtual . Changes the owner and last-change time for the specified selection. ; Reimplemented from TVirtualX.; Definition at line 3612 of file TGCocoa.mm. ◆ SetTextMagnitude(). void TGCocoa::SetTextMagnitude ; (; Float_t ; mgn). overridevirtual . Sets the current text magnification factor to ""mgn"". ; Reimplemented from TVirtualX.; Definition at line 4119 of file TGCocoa.mm. ◆ SetTypeList(). void TGCocoa::SetTypeList ; (; Window_t ; win, . Atom_t ; prop, . Atom_t * ; typelist . ). overridevirtual . Add the list of drag and drop types to the Window win. ; Reimplemented from TVirtualX.; Definition at line 3984 of file TGCocoa.mm. ◆ SetWindowBackground(). void TGCocoa::SetWindowBackground ; (; Window_t ; id, . ULong_t ; color . ). overridevirtual . Sets the backgroun",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGCocoa.html:118792,green,green,118792,doc/master/classTGCocoa.html,https://root.cern,https://root.cern/doc/master/classTGCocoa.html,1,['green'],['green']
Energy Efficiency,"Repetitions=7, double _factorWeightDecay=1e-5, TMVA::DNN::EnumRegularization _regularization=TMVA::DNN::EnumRegularization::NONE, MinimizerType _eMinimizerType=MinimizerType::fSteepest, double _learningRate=1e-5, double _momentum=0.3, int _repetitions=3, bool _multithreading=true)c'torDefinition NeuralNet.cxx:232; TMVA::DNN::Settings::addPointvoid addPoint(std::string histoName, double x)for monitoringDefinition NeuralNet.h:821; TMVA::DNN::Settings::~Settingsvirtual ~Settings()d'torDefinition NeuralNet.cxx:261; TMVA::DNN::Settings::m_convergenceCountsize_t m_convergenceCountDefinition NeuralNet.h:857; TMVA::DNN::Settings::m_minErrordouble m_minErrorDefinition NeuralNet.h:859; TMVA::DNN::Settings::convergenceStepssize_t convergenceSteps() consthow many steps until training is deemed to have convergedDefinition NeuralNet.h:766; TMVA::DNN::Settings::fMonitoringstd::shared_ptr< Monitoring > fMonitoringDefinition NeuralNet.h:865; TMVA::DNN::Settings::createvoid create(std::string histoName, int bins, double min, double max)for monitoringDefinition NeuralNet.h:819; TMVA::DNN::Settings::m_maxConvergenceCountsize_t m_maxConvergenceCountDefinition NeuralNet.h:858; TStringBasic string class.Definition TString.h:139; double; sigmaconst Double_t sigmaDefinition h1analysisProxy.h:11; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; TMVA::DNN::InvGaussstd::shared_ptr< std::function< double(double)> > InvGaussDefinition NeuralNet.cxx:14; TMVA::DNN::uniformDoubledouble uniformDouble(double minValue, double maxValue)Definition NeuralNet.cxx:43; TMVA::DNN::SymmReLUstd::shared_ptr< std::function< double(double)> > SymmReLUDefinition NeuralNet.cxx:30; TMVA::DNN::TanhShiftstd::shared_ptr< std::function< double(double)> > TanhShiftDefinition NeuralNet.cxx:31; TMVA::DNN::Tanhstd::shared_ptr< std::function< double(double)> > TanhDefinition NeuralNet.cxx:29; TMVA::DNN::InvSigmoidstd::shared_ptr< std::function< double(double)> > InvSigmoidDefinition NeuralNet.cxx:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/NeuralNet_8cxx_source.html:28185,monitor,monitoringDefinition,28185,doc/master/NeuralNet_8cxx_source.html,https://root.cern,https://root.cern/doc/master/NeuralNet_8cxx_source.html,1,['monitor'],['monitoringDefinition']
Energy Efficiency,"RestrictNegMass(); restrict the value of negative mass to avoid unphysical negative E2 values; M2 must be less than P2 for the tachionic particles - otherwise use positive values. Scalar Theta() const. polar angle. void SetPt(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar pt); --------- Set Coordinates of this system ---------------. set Pt value. void SetEta(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar eta). set eta value. void SetPhi(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar phi). set phi value. void SetM(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar mass). set M value. void SetPxPyPzE(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar px, ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar py, ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar pz, ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar e). set values using cartesian coordinate system. void Negate(); ------ Manipulations -------------. negate the 4-vector -- Note that the energy cannot be negate (would need an additional data member); therefore negate will work only on the spatial components; One would need to use negate only with vectors having the energy as data members. void Scale(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar a). Scale coordinate values by a scalar quantity a. Scalar x() const; ============= Compatibility secition ==================; The following make this coordinate system look enough like a CLHEP; vector that an assignment member template can work with either. { return X(); }. Scalar y() const; { return Y(); }. Scalar z() const; { return Z(); }. Scalar t() const; { return E(); }. void SetPx(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar px); ====== Set member functions for coordinates in other systems =======. void SetPy(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar py). void SetPz(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar pz). void SetE(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar energy). » Last changed: root/mathcore:$Id$ » Last generated: 2015-09-08 17:00; This page has been automatically generated. For comments o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__PtEtaPhiM4D_Double32_t_.html:8407,energy,energy,8407,root/html534/ROOT__Math__PtEtaPhiM4D_Double32_t_.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__PtEtaPhiM4D_Double32_t_.html,2,['energy'],['energy']
Energy Efficiency,"RestrictNegMass(); restrict the value of negative mass to avoid unphysical negative E2 values; M2 must be less than P2 for the tachionic particles - otherwise use positive values. Scalar Theta() const. polar angle. void SetPt(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar pt); --------- Set Coordinates of this system ---------------. set Pt value. void SetEta(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar eta). set eta value. void SetPhi(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar phi). set phi value. void SetM(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar mass). set M value. void SetPxPyPzE(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar px, ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar py, ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar pz, ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar e). set values using cartesian coordinate system. void Negate(); ------ Manipulations -------------. negate the 4-vector -- Note that the energy cannot be negate (would need an additional data member); therefore negate will work only on the spatial components; One would need to use negate only with vectors having the energy as data members. void Scale(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar a). Scale coordinate values by a scalar quantity a. Scalar x() const; ============= Compatibility secition ==================; The following make this coordinate system look enough like a CLHEP; vector that an assignment member template can work with either. { return X(); }. Scalar y() const; { return Y(); }. Scalar z() const; { return Z(); }. Scalar t() const; { return E(); }. void SetPx(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar px); ====== Set member functions for coordinates in other systems =======. void SetPy(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar py). void SetPz(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar pz). void SetE(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar energy). » Last changed: root/mathcore:$Id: PtEtaPhiM4D.h 30568 2009-10-06 07:17:59Z moneta $ » Last generated: 2009-12-07 13:44; This pag",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__PtEtaPhiM4D_Double32_t_.html:8405,energy,energy,8405,root/html526/ROOT__Math__PtEtaPhiM4D_Double32_t_.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__PtEtaPhiM4D_Double32_t_.html,2,['energy'],['energy']
Energy Efficiency,"RestrictNegMass(); restrict the value of negative mass to avoid unphysical negative E2 values; M2 must be less than P2 for the tachionic particles - otherwise use positive values. Scalar Theta() const. polar angle. void SetPt(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar pt); --------- Set Coordinates of this system ---------------. set Pt value. void SetEta(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar eta). set eta value. void SetPhi(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar phi). set phi value. void SetM(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar mass). set M value. void SetPxPyPzE(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar px, ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar py, ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar pz, ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar e). set values using cartesian coordinate system. void Negate(); ------ Manipulations -------------. negate the 4-vector -- Note that the energy cannot be negate (would need an additional data member); therefore negate will work only on the spatial components; One would need to use negate only with vectors having the energy as data members. void Scale(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar a). Scale coordinate values by a scalar quantity a. Scalar x() const; ============= Compatibility secition ==================; The following make this coordinate system look enough like a CLHEP; vector that an assignment member template can work with either. { return X(); }. Scalar y() const; { return Y(); }. Scalar z() const; { return Z(); }. Scalar t() const; { return E(); }. void SetPx(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar px); ====== Set member functions for coordinates in other systems =======. void SetPy(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar py). void SetPz(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar pz). void SetE(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar energy). » Last changed: root/mathcore:$Id: PtEtaPhiM4D.h 31938 2009-12-18 14:49:38Z moneta $ » Last generated: 2010-09-23 19:56; This pag",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__PtEtaPhiM4D_Double32_t_.html:8405,energy,energy,8405,root/html528/ROOT__Math__PtEtaPhiM4D_Double32_t_.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__PtEtaPhiM4D_Double32_t_.html,2,['energy'],['energy']
Energy Efficiency,"RestrictNegMass(); restrict the value of negative mass to avoid unphysical negative E2 values; M2 must be less than P2 for the tachionic particles - otherwise use positive values. Scalar Theta() const. polar angle. void SetPt(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar pt); --------- Set Coordinates of this system ---------------. set Pt value. void SetEta(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar eta). set eta value. void SetPhi(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar phi). set phi value. void SetM(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar mass). set M value. void SetPxPyPzE(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar px, ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar py, ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar pz, ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar e). set values using cartesian coordinate system. void Negate(); ------ Manipulations -------------. negate the 4-vector -- Note that the energy cannot be negate (would need an additional data member); therefore negate will work only on the spatial components; One would need to use negate only with vectors having the energy as data members. void Scale(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar a). Scale coordinate values by a scalar quantity a. Scalar x() const; ============= Compatibility secition ==================; The following make this coordinate system look enough like a CLHEP; vector that an assignment member template can work with either. { return X(); }. Scalar y() const; { return Y(); }. Scalar z() const; { return Z(); }. Scalar t() const; { return E(); }. void SetPx(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar px); ====== Set member functions for coordinates in other systems =======. void SetPy(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar py). void SetPz(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar pz). void SetE(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar energy). » Last changed: root/mathcore:$Id: PtEtaPhiM4D.h 31938 2009-12-18 14:49:38Z moneta $ » Last generated: 2011-07-04 15:19; This pag",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ROOT__Math__PtEtaPhiM4D_Double32_t_.html:8407,energy,energy,8407,root/html530/ROOT__Math__PtEtaPhiM4D_Double32_t_.html,https://root.cern,https://root.cern/root/html530/ROOT__Math__PtEtaPhiM4D_Double32_t_.html,2,['energy'],['energy']
Energy Efficiency,"RestrictNegMass(); restrict the value of negative mass to avoid unphysical negative E2 values; M2 must be less than P2 for the tachionic particles - otherwise use positive values. Scalar Theta() const. polar angle. void SetPt(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar pt); --------- Set Coordinates of this system ---------------. set Pt value. void SetEta(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar eta). set eta value. void SetPhi(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar phi). set phi value. void SetM(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar mass). set M value. void SetPxPyPzE(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar px, ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar py, ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar pz, ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar e). set values using cartesian coordinate system. void Negate(); ------ Manipulations -------------. negate the 4-vector -- Note that the energy cannot be negate (would need an additional data member); therefore negate will work only on the spatial components; One would need to use negate only with vectors having the energy as data members. void Scale(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar a). Scale coordinate values by a scalar quantity a. Scalar x() const; ============= Compatibility secition ==================; The following make this coordinate system look enough like a CLHEP; vector that an assignment member template can work with either. { return X(); }. Scalar y() const; { return Y(); }. Scalar z() const; { return Z(); }. Scalar t() const; { return E(); }. void SetPx(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar px); ====== Set member functions for coordinates in other systems =======. void SetPy(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar py). void SetPz(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar pz). void SetE(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar energy). » Last changed: root/mathcore:$Id: PtEtaPhiM4D.h 31938 2009-12-18 14:49:38Z moneta $ » Last generated: 2011-11-03 20:05; This pag",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ROOT__Math__PtEtaPhiM4D_Double32_t_.html:8407,energy,energy,8407,root/html532/ROOT__Math__PtEtaPhiM4D_Double32_t_.html,https://root.cern,https://root.cern/root/html532/ROOT__Math__PtEtaPhiM4D_Double32_t_.html,2,['energy'],['energy']
Energy Efficiency,Results for Fisher coefficients:; : -----------------------; : Variable: Coefficient:; : -----------------------; : var1: +0.107; : var2: +0.148; : var3: +0.251; : var4: +0.372; : (offset): -0.751; : -----------------------; : Elapsed time for training with 4871 events: 0.0015 sec ; <HEADER> Category_Fisher_2 : [Category_Fisher_2_dsi] : Evaluation of Category_Fisher_2 on training sample (4871 events); : Elapsed time for evaluation of 4871 events: 0.00213 sec ; : Training finished; : Begin ranking of input variables...; <HEADER> Category_Fisher_1 : Ranking result (top variable is best ranked); : -------------------------------; : Rank : Variable : Discr. power; : -------------------------------; : 1 : var4 : 2.205e-01; : 2 : var3 : 1.054e-01; : 3 : var2 : 4.114e-02; : 4 : var1 : 1.987e-02; : -------------------------------; <HEADER> Category_Fisher_2 : Ranking result (top variable is best ranked); : -------------------------------; : Rank : Variable : Discr. power; : -------------------------------; : 1 : var4 : 2.153e-01; : 2 : var3 : 1.105e-01; : 3 : var2 : 4.289e-02; : 4 : var1 : 1.986e-02; : -------------------------------; : Elapsed time for training with 10000 events: 0.0412 sec ; <HEADER> Category_Fisher_1 : [Category_Fisher_1_dsi] : Evaluation of Category_Fisher_1 on training sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00549 sec ; <HEADER> Category_Fisher_2 : [Category_Fisher_2_dsi] : Evaluation of Category_Fisher_2 on training sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00519 sec ; : Creating xml weight file: dataset/weights/TMVAClassificationCategory_FisherCat.weights.xml; <HEADER> Factory : Training finished; : ; <HEADER> Factory : Train method: LikelihoodCat for Classification; : ; : Train all sub-classifiers for Classification ...; : Rebuilding Dataset Category_Likelihood_1_dsi; : Building event vectors for type 2 Signal; : Dataset[Category_Likelihood_1_dsi] : create input formulas for tree TreeS; :,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAClassificationCategory_8C.html:12157,power,power,12157,doc/master/TMVAClassificationCategory_8C.html,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategory_8C.html,1,['power'],['power']
Energy Efficiency,"RooAbsData* ); If return value is true variables can be deleted. ~RooAbsData(); Destructor; cout << ""deleting dataset "" << this << endl ;. Bool_t changeObservableName(const char* from, const char* to). void fill(). Int_t numEntries() const. void reset(). const RooArgSet* get(Int_t index) const. void cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0); Internal method -- Cache given set of functions with data. void resetCache(); Internal method -- Remove cached function values. void attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); Internal method -- Attach dataset copied with cache contents to copied instances of functions. void setArgStatus(const RooArgSet& set, Bool_t active). void setDirtyProp(Bool_t flag); Control propagation of dirty flags from observables in dataset. RooAbsData* reduce(const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); Create a reduced copy of this dataset. The caller takes ownership of the returned dataset. The following optional named arguments are accepted. SelectVars(const RooArgSet& vars) -- Only retain the listed observables in the output dataset; Cut(const char* expression) -- Only retain event surviving the given cut expression; Cut(const RooFormulaVar& expr) -- Only retain event surviving the given cut formula; CutRange(const char* name) -- Only retain events inside range with given name. Multiple CutRange; arguments may be given to select multiple ranges; EventRange(int lo, int hi) -- Only retain events with given sequential event numbers; Name(const char* name) -- Give specified name to output dataset; Title(const char* name) -- Give specified title to output dataset. RooAbsData* reduce(const char* cut); Create a subset of the data set by applying the given cu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooAbsData.html:15209,reduce,reduce,15209,root/html530/RooAbsData.html,https://root.cern,https://root.cern/root/html530/RooAbsData.html,2,['reduce'],"['reduce', 'reduced']"
Energy Efficiency,"RooAbsData::_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; map<std::string,RooAbsData*>RooAbsData::_ownedComponentsOwned external components; static char*_poolBegin! Start of memory pool; static char*_poolCur! Next free slot in memory pool; static char*_poolEnd! End of memory pool ; RooArgSetRooAbsData::_varsDimensions of this data set; RooArgSet_varsNoWgtVars without weight variable ; RooRealVar*_wgtVarPointer to weight variable (if set) ; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void cleanup(); Clear memoery pool on exit to avoid reported memory leaks. void* operator new(size_t bytes); Overloaded new operator guarantees that all RooDataSets allocated with new; have a unique address, a property that is exploited in several places; in roofit to quickly index contents on normalization set pointers.; The memory pool only allocates space for the class itself. The elements; stored in the set are stored outside the pool. void operator delete(void* ptr); Memory is owned by pool, we need to do nothing to release it. RooDataSet(); Default constructor for persistence. RooDataSet(const char* name, const char* title, const RooArgSet& vars, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); Construct an unbinned dataset from a RooArgSet defining the dimensions of the data space. Optionally, data; can be imported at the time of construction. This constructor takes the following optional arguments. Import(TTree*) -- Import contents of given TTree. Only braches of the TTree that have names; corresponding to those of the RooAbsArgs that define the RooDataSet are; imported.; ImportFromFile(const ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooDataSet.html:17838,allocate,allocates,17838,root/html530/RooDataSet.html,https://root.cern,https://root.cern/root/html530/RooDataSet.html,2,['allocate'],['allocates']
Energy Efficiency,"RooAbsReal object; RooRealConstant RooRealVar constants factory; RooRealIntegral Real-valued function representing an integral over a RooAbsReal object; RooRealMPFE Multi-process front-end for parallel calculation of a real valued function ; RooRealProxy Proxy for a RooAbsReal object; RooRealSumPdf PDF constructed from a sum of (non-pdf) functions; RooRealVar Real-valued variable ; RooRealVarSharedProperties Shared properties of a RooRealVar clone set; RooRecursiveFraction Recursive fraction formula f1*(1-f2)*(1-f3) etc...; RooRefCountList RooLinkedList with reference counting; RooResolutionModel Abstract Resolution Model; RooScaledFunc Function binding applying scaling to another function binding; RooSegmentedIntegrator1D 1-dimensional piece-wise numerical integration engine; RooSegmentedIntegrator2D 2-dimensional piece-wise numerical integration engine; RooSentinel ; RooSetPair Utility class holding a pair of RooArgSet pointers; RooSetProxy Proxy class for a RooArgSet; RooSharedProperties Abstract interface for shared property implementations; RooSharedPropertiesList Manager for shared properties among clones of certain RooAbsArg-derived types; RooSimGenContext Context for efficiently generating a dataset from a RooSimultaneous PDF; RooSimPdfBuilder RooSimultaneous PDF Builder (obsolete); RooSimSplitGenContext Context for efficiently generating a dataset from a RooSimultaneous PDF; RooSimWSTool Workspace oriented tool for customized cloning of p.d.f. into a simultaneous p.d.f; RooSimWSTool::BuildConfig Build configuration object for RooSimWSTool; RooSimWSTool::MultiBuildConfig Build configuration object for RooSimWSTool with multiple prototype p.d.f.; RooSimWSTool::ObjBuildConfig Validated RooSimWSTool build configuration; RooSimWSTool::ObjSplitRule Validated RooSimWSTool split rule; RooSimWSTool::SplitRule Split rule specification for prototype p.d.f; RooSimultaneous Simultaneous operator p.d.f, functions like C++ 'switch()' on input p.d.fs operating on index cat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ClassIndex.html:43134,efficient,efficiently,43134,root/html532/ClassIndex.html,https://root.cern,https://root.cern/root/html532/ClassIndex.html,2,['efficient'],['efficiently']
Energy Efficiency,"RooArgList(sig1, sig2), sig1frac);; ; // Sum the composite signal and background; RooRealVar bkgfrac(""bkgfrac"", ""fraction of background"", 0.5, 0., 1.);; RooAddPdf model(""model"", ""g1+g2+a"", RooArgList(bkg, sig), bkgfrac);; ; // C r e a t e b i n n e d d a t a s e t; // -----------------------------------------; ; std::unique_ptr<RooDataSet> d{model.generate(x, 10000)};; std::unique_ptr<RooDataHist> dh{d->binnedClone()};; ; // Construct a chi^2 of the data and the model.; // When a pdf is used in a chi^2 fit, the probability density scaled; // by the number of events in the dataset to obtain the fit function; // If model is an extended pdf, the expected number events is used; // instead of the observed number of events.; model.chi2FitTo(*dh, {PrintLevel(-1)});; ; // NB: It is also possible to fit a RooAbsReal function to a RooDataHist; // using chi2FitTo().; ; // Note that entries with zero bins are _not_ allowed; // for a proper chi^2 calculation and will give error; // messages; std::unique_ptr<RooAbsData> dsmall{d->reduce(EventRange(1, 100))};; std::unique_ptr<RooDataHist> dhsmall{static_cast<RooDataSet&>(*dsmall).binnedClone()};; std::unique_ptr<RooAbsReal> chi2_lowstat{model.createChi2(*dhsmall)};; cout << chi2_lowstat->getVal() << endl;; }; d#define d(i)Definition RSha256.hxx:102; RooAddPdf.h; RooChebychev.h; RooDataSet.h; RooGaussian.h; RooPlot.h; RooRealVar.h; TAxis.h; TCanvas.h; RooAddPdfEfficient implementation of a sum of PDFs of the form.Definition RooAddPdf.h:33; RooArgListRooArgList is a container object that can hold multiple RooAbsArg objects.Definition RooArgList.h:22; RooArgSetRooArgSet is a container object that can hold multiple RooAbsArg objects.Definition RooArgSet.h:24; RooChebychevChebychev polynomial p.d.f.Definition RooChebychev.h:25; RooDataSetContainer class to hold unbinned data.Definition RooDataSet.h:33; RooDataSet::binnedCloneRooFit::OwningPtr< RooDataHist > binnedClone(const char *newName=nullptr, const char *newTitle=nullptr) constRet",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf602__chi2fit_8C.html:2426,reduce,reduce,2426,doc/master/rf602__chi2fit_8C.html,https://root.cern,https://root.cern/doc/master/rf602__chi2fit_8C.html,1,['reduce'],['reduce']
Energy Efficiency,"RooArgSet(Asig1, Abkg1)));; ; sigData->plotOn(frame, MarkerColor(kBlue));; frame->Draw();; ; pt.Clear();; for (auto text : {; ""With gamma parameters, the"",; ""signal & background templates"",; ""can adapt to the data."",; ""Note how the blue signal"",; ""template changes its shape."",; ""This leads to higher errors"",; ""of the scale parameters A.""}) {; pt.AddText(text);; }; pt.DrawClone();; ; can->cd(3);; frame = x.frame(Title(""Barlow Beeston light for (Sig+Bkg)""));; sumData.plotOn(frame);; model2.plotOn(frame, LineColor(kBlue), VisualizeError(*result2));; // Plot data again to show it on top of model0 error bands:; sumData.plotOn(frame);; model2.plotOn(frame, LineColor(kBlue));; model2.plotOn(frame, Components(p_ph_sig2), LineColor(kAzure));; model2.plotOn(frame, Components(p_ph_bkg2), LineColor(kRed));; model2.paramOn(frame, Parameters(RooArgSet(Asig2, Abkg2)));; ; sigData->plotOn(frame, MarkerColor(kBlue));; frame->Draw();; ; pt.Clear();; for (auto text : {; ""When signal and background"",; ""template share one gamma para-"",; ""meter per bin, they adapt less."",; ""The errors of the A parameters"",; ""also shrink slightly.""}) {; pt.AddText(text);; }; pt.DrawClone();; ; ; std::cout << ""Asig [normal ] = "" << Asig0.getVal() << "" +/- "" << Asig0.getError() << std::endl;; std::cout << ""Asig [BB ] = "" << Asig1.getVal() << "" +/- "" << Asig1.getError() << std::endl;; std::cout << ""Asig [BBlight] = "" << Asig2.getVal() << "" +/- "" << Asig2.getError() << std::endl;; ; }; g#define g(i)Definition RSha256.hxx:105; RooDataHist.h; RooDataSet.h; RooGaussian.h; RooHistConstraint.h; RooHistFunc.h; RooParamHistFunc.h; RooPlot.h; RooProdPdf.h; RooRealSumPdf.h; RooRealVar.h; RooUniform.h; kRed@ kRedDefinition Rtypes.h:66; kBlue@ kBlueDefinition Rtypes.h:66; kAzure@ kAzureDefinition Rtypes.h:67; TCanvas.h; textOption_t Option_t TPoint TPoint const char textDefinition TGWin32VirtualXProxy.cxx:68; TPaveText.h; RooArgListRooArgList is a container object that can hold multiple RooAbsArg objects.Definition RooA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf709__BarlowBeeston_8C.html:7319,meter,meter,7319,doc/master/rf709__BarlowBeeston_8C.html,https://root.cern,https://root.cern/doc/master/rf709__BarlowBeeston_8C.html,2,"['adapt', 'meter']","['adapt', 'meter']"
Energy Efficiency,"RooCmdArg& arg1, const RooCmdArg& arg2, const RooCmdArg& arg3, const RooCmdArg& arg4, const RooCmdArg& arg5, const RooCmdArg& arg6, const RooCmdArg& arg7, const RooCmdArg& arg8) const; 132 ; 133\anchor _rooabsdata_ploton; 134### RooAbsData.plotOn; 135The RooAbsData::plotOn() function is pythonized with the command argument pythonization.; 136The keywords must correspond to the CmdArgs of the function.; 137 ; 138\see RooAbsData::plotOn(RooPlot* frame, const RooCmdArg& arg1, const RooCmdArg& arg2, const RooCmdArg& arg3, const RooCmdArg& arg4, const RooCmdArg& arg5, const RooCmdArg& arg6, const RooCmdArg& arg7, const RooCmdArg& arg8) const; 139 ; 140\anchor _rooabsdata_reduce; 141### RooAbsData.reduce; 142The RooAbsData::reduce() function is pythonized with the command argument pythonization.; 143The keywords must correspond to the CmdArgs of the function.; 144 ; 145\see RooAbsData::reduce(const RooCmdArg& arg1,const RooCmdArg& arg2, const RooCmdArg& arg3,const RooCmdArg& arg4, const RooCmdArg& arg5,const RooCmdArg& arg6, const RooCmdArg& arg7,const RooCmdArg& arg8); 146 ; 147\anchor _rooabsdata_staton; 148### RooAbsData.statOn; 149The RooAbsData::statOn() function is pythonized with the command argument pythonization.; 150The keywords must correspond to the CmdArgs of the function.; 151 ; 152\see RooAbsData::statOn(RooPlot* frame, const RooCmdArg& arg1, const RooCmdArg& arg2, const RooCmdArg& arg3, const RooCmdArg& arg4, const RooCmdArg& arg5, const RooCmdArg& arg6, const RooCmdArg& arg7, const RooCmdArg& arg8); 153 ; 154\anchor _rooabspdf; 155## RooAbsPdf; 156\see RooAbsPdf; 157 ; 158Some member functions of RooAbsPdf that take a RooCmdArg as argument also support keyword arguments.; 159So far, this applies to RooAbsPdf::fitTo, RooAbsPdf::plotOn, RooAbsPdf::generate, RooAbsPdf::paramOn, RooAbsPdf::createCdf,; 160RooAbsPdf::generateBinned, RooAbsPdf::prepareMultiGen and RooAbsPdf::createNLL.; 161For example, the following code is equivalent in PyROOT:; 162\code{.py}; 1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/__roofit_8pyzdoc_source.html:6936,reduce,reduce,6936,doc/master/__roofit_8pyzdoc_source.html,https://root.cern,https://root.cern/doc/master/__roofit_8pyzdoc_source.html,1,['reduce'],['reduce']
Energy Efficiency,"RotateYEulerAngles ; (; Double_t ; phi, . Double_t ; theta, . Double_t ; psi . ). Rotate using the y-convention. ; Definition at line 526 of file TRotation.cxx. ◆ RotateZ(). TRotation & TRotation::RotateZ ; (; Double_t ; a). Rotate around z. ; Definition at line 378 of file TRotation.cxx. ◆ SetToIdentity(). TRotation & TRotation::SetToIdentity ; (; ). inline . Definition at line 251 of file TRotation.h. ◆ SetXAxis() [1/2]. TRotation & TRotation::SetXAxis ; (; const TVector3 & ; axis). Set X axis. ; Definition at line 713 of file TRotation.cxx. ◆ SetXAxis() [2/2]. TRotation & TRotation::SetXAxis ; (; const TVector3 & ; axis, . const TVector3 & ; xyPlane . ). Set X axis. ; Definition at line 698 of file TRotation.cxx. ◆ SetXEulerAngles(). TRotation & TRotation::SetXEulerAngles ; (; Double_t ; phi, . Double_t ; theta, . Double_t ; psi . ). Rotate using the x-convention (Landau and Lifshitz, Goldstein, &c) by doing the explicit rotations. ; This is slightly less efficient than directly applying the rotation, but makes the code much clearer. My presumption is that this code is not going to be a speed bottle neck. ; Definition at line 488 of file TRotation.cxx. ◆ SetXPhi(). void TRotation::SetXPhi ; (; Double_t ; phi). Set XPhi. ; Definition at line 537 of file TRotation.cxx. ◆ SetXPsi(). void TRotation::SetXPsi ; (; Double_t ; psi). Set XPsi. ; Definition at line 551 of file TRotation.cxx. ◆ SetXTheta(). void TRotation::SetXTheta ; (; Double_t ; theta). Set XTheta. ; Definition at line 544 of file TRotation.cxx. ◆ SetYAxis() [1/2]. TRotation & TRotation::SetYAxis ; (; const TVector3 & ; axis). Set Y axis. ; Definition at line 736 of file TRotation.cxx. ◆ SetYAxis() [2/2]. TRotation & TRotation::SetYAxis ; (; const TVector3 & ; axis, . const TVector3 & ; yzPlane . ). Set Y axis. ; Definition at line 721 of file TRotation.cxx. ◆ SetYEulerAngles(). TRotation & TRotation::SetYEulerAngles ; (; Double_t ; phi, . Double_t ; theta, . Double_t ; psi . ). Rotate using the y-conven",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTRotation.html:26465,efficient,efficient,26465,doc/master/classTRotation.html,https://root.cern,https://root.cern/doc/master/classTRotation.html,1,['efficient'],['efficient']
Energy Efficiency,"SaveBeltToFile(bool flag = true); virtual voidSetConfidenceLevel(Double_t cl); virtual voidSetData(RooAbsData& data); voidSetLeftSideTailFraction(Double_t leftSideFraction = 0.); virtual voidSetModel(const RooStats::ModelConfig& model); virtual voidSetNuisanceParameters(const RooArgSet&); voidSetParameterPointsToTest(RooAbsData& pointsToTest); virtual voidSetParameters(const RooArgSet&); virtual voidSetPdf(RooAbsPdf&); virtual voidSetTestSize(Double_t size); voidSetTestStatSampler(RooStats::TestStatSampler& sampler); virtual voidShowMembers(TMemberInspector& insp) const; virtual Double_tSize() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidUseAdaptiveSampling(bool flag = true). Data Members; private:. boolfAdaptiveSamplingcontrols use of adaptive sampling algorithm; Double_tfAdditionalNToysFactorgive user ability to ask for more toys; RooStats::ConfidenceBelt*fConfBelt; boolfCreateBeltcontrols use if ConfidenceBelt should be saved to a TFile; RooAbsData&fDatadata set; Double_tfLeftSideFraction; RooStats::ModelConfig&fModel; RooAbsData*fPointsToTest; boolfSaveBeltToFilecontrols use if ConfidenceBelt should be saved to a TFile; Double_tfSizesize of the test (eg. specified rate of Type I error); RooStats::TestStatSampler*fTestStatSampler. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; NeymanConstruction(RooAbsData& data, RooStats::ModelConfig& model); default constructor; fWS = new RooWorkspace();; fOwnsWorkspace = true;; fDataName = """";; fPdfName = """";. ~NeymanConstruction(); default constructor; if(fOwnsWorkspace && fWS) delete fWS;; if(fConfBelt) delete fConfBelt;. PointSetInterval* GetInterval() const; Main interface to get a RooStats::ConfInterval.; It constructs a RooStats::SetInterval. NeymanConstruction(RooAbsData& data, RooStats::ModelConfig& model); NeymanConstruction();. void SetTestStatSampler(RooStats::TestStatSampler& sampler); in addition to interface we a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooStats__NeymanConstruction.html:4035,adapt,adaptive,4035,root/html602/RooStats__NeymanConstruction.html,https://root.cern,https://root.cern/root/html602/RooStats__NeymanConstruction.html,2,['adapt'],['adaptive']
Energy Efficiency,"ScaleFactor). inline . Definition at line 124 of file Roo2DKeysPdf.h. ◆ Streamer(). void Roo2DKeysPdf::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void Roo2DKeysPdf::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 121 of file Roo2DKeysPdf.h. ◆ writeHistToFile(). void Roo2DKeysPdf::writeHistToFile ; (; char * ; outputFile, . const char * ; histName . ); const. Plots the PDF as a histogram and saves it to a file, so that it can be loaded in as a Roo2DHist PDF in the future to save on calculation time. ; Parameters. [in]outputFileName of the file where to store the PDF ; [in]histNamePDF histogram name . Definition at line 525 of file Roo2DKeysPdf.cxx. ◆ writeNTupleToFile(). void Roo2DKeysPdf::writeNTupleToFile ; (; char * ; outputFile, . const char * ; name . ); const. Saves the data and calculated bandwidths to a file, as a record of what produced the PDF and to give a reduced data set in order to facilitate re-calculation in the future. ; Parameters. [in]outputFileName of the file where to store the data ; [in]nameName of the tree which will contain the data . Definition at line 559 of file Roo2DKeysPdf.cxx. ◆ writeToFile(). void Roo2DKeysPdf::writeToFile ; (; char * ; outputFile, . const char * ; name . ); const. Definition at line 508 of file Roo2DKeysPdf.cxx. Member Data Documentation. ◆ _2pi. double Roo2DKeysPdf::_2pi. private . Definition at line 107 of file Roo2DKeysPdf.h. ◆ _BandWidthType. Int_t Roo2DKeysPdf::_BandWidthType. private . Definition at line 115 of file Roo2DKeysPdf.h. ◆ _debug. Int_t Roo2DKeysPdf::_debug. private . Definition at line 117 of file Roo2DKeysPdf.h. ◆ _hix. double Roo2DKeysPdf::_hix. private . Definition at line 108 of file Roo2DKeysPdf.h. ◆ _hiy. double Roo2DKeysPdf::_hiy. private . Definition at line 109 of file Roo2DKeysPdf.h. ◆ _hx. double* Roo2DKeysPdf::_hx. private . Definition at line 96 of fil",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRoo2DKeysPdf.html:82393,reduce,reduced,82393,doc/master/classRoo2DKeysPdf.html,https://root.cern,https://root.cern/doc/master/classRoo2DKeysPdf.html,1,['reduce'],['reduced']
Energy Efficiency,"Sea; 2985 case 51:; 2986 {; 2987 Double_t red[9] = { 0./255., 9./255., 13./255., 17./255., 24./255., 32./255., 27./255., 25./255., 29./255.};; 2988 Double_t green[9] = { 0./255., 0./255., 0./255., 2./255., 37./255., 74./255., 113./255., 160./255., 221./255.};; 2989 Double_t blue[9] = { 28./255., 42./255., 59./255., 78./255., 98./255., 129./255., 154./255., 184./255., 221./255.};; 2990 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 2991 }; 2992 break;; 2993 ; 2994 // Grey Scale; 2995 case 52:; 2996 {; 2997 Double_t red[9] = { 0./255., 32./255., 64./255., 96./255., 128./255., 160./255., 192./255., 224./255., 255./255.};; 2998 Double_t green[9] = { 0./255., 32./255., 64./255., 96./255., 128./255., 160./255., 192./255., 224./255., 255./255.};; 2999 Double_t blue[9] = { 0./255., 32./255., 64./255., 96./255., 128./255., 160./255., 192./255., 224./255., 255./255.};; 3000 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3001 }; 3002 break;; 3003 ; 3004 // Dark Body Radiator; 3005 case 53:; 3006 {; 3007 Double_t red[9] = { 0./255., 45./255., 99./255., 156./255., 212./255., 230./255., 237./255., 234./255., 242./255.};; 3008 Double_t green[9] = { 0./255., 0./255., 0./255., 45./255., 101./255., 168./255., 238./255., 238./255., 243./255.};; 3009 Double_t blue[9] = { 0./255., 1./255., 1./255., 3./255., 9./255., 8./255., 11./255., 95./255., 230./255.};; 3010 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3011 }; 3012 break;; 3013 ; 3014 // Two-color hue (dark blue through neutral gray to bright yellow); 3015 case 54:; 3016 {; 3017 Double_t red[9] = { 0./255., 22./255., 44./255., 68./255., 93./255., 124./255., 160./255., 192./255., 237./255.};; 3018 Double_t green[9] = { 0./255., 16./255., 41./255., 67./255., 93./255., 125./255., 162./255., 194./255., 241./255.};; 3019 Double_t blue[9] = { 97./255., 100./255., 99./255., 99./255., 93./255., 68./255., 44./255., 26./255., 74./255.};; 30",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TColor_8cxx_source.html:112529,green,green,112529,doc/master/TColor_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html,1,['green'],['green']
Energy Efficiency,"Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooNumConvPdf. class RooNumConvPdf: public RooAbsPdf. Numeric 1-dimensional convolution operator PDF. This class can convolve any PDF; with any other PDF using a straightforward numeric calculation of the; convolution integral; ; This class should be used as last resort as numeric convolution calculated; this way is computationally intensive and prone to stability fitting problems. ; The preferred way to compute numeric convolutions is RooFFTConvPdf,; which calculates convolutions using Fourier Transforms (requires external free; FFTW3 package); ; RooNumConvPdf implements reasonable defaults that should convolve most; functions reasonably well, but results strongly depend on the shape of your; input PDFS so always check your result.; ; The default integration engine for the numeric convolution is the; adaptive Gauss-Kronrod method, which empirically seems the most robust; for this task. You can override the convolution integration settings via; the RooNumIntConfig object reference returned by the convIntConfig() member; function; ; By default the numeric convolution is integrated from -infinity to; +infinity through a x -> 1/x coordinate transformation of the; tails. For convolution with a very small bandwidth it may be; advantageous (for both CPU consumption and stability) if the; integration domain is limited to a finite range. The function; setConvolutionWindow(mean,width,scale) allows to set a sliding; window around the x value to be calculated taking a RooAbsReal; expression for an offset and a width to be taken around the x; value. These input expression can be RooFormulaVars or other; function objects although the 3d 'scale' argument 'scale'; multiplies the width RooAbsReal expression given in the 2nd; argument, allowing for an appropriate window definition for most; cases without ne",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooNumConvPdf.html:1069,adapt,adaptive,1069,root/html526/RooNumConvPdf.html,https://root.cern,https://root.cern/root/html526/RooNumConvPdf.html,7,['adapt'],['adaptive']
Energy Efficiency,"See WriteQueryLog for the descripition of the structure sent for monitoring; when fMonitorPerPacket is kTRUE. void FileEvent(const char* slave, const char* slavename, const char* nodename, const char* filename, Bool_t isStart); File event. void FileOpenEvent(TFile* file, const char* filename, Double_t start); Open file event. void FileReadEvent(TFile* file, Int_t len, Double_t start); Read file event. void FileUnzipEvent(TFile* file, Long64_t pos, Double_t start, Int_t complen, Int_t objlen); Record TTree file unzip event.; start is the TimeStamp before unzip; pos is where in the file the compressed buffer came from; complen is the length of the compressed buffer; objlen is the length of the de-compressed buffer. void RateEvent(Double_t proctime, Double_t deltatime, Long64_t eventsprocessed, Long64_t bytesRead); Rate event. void SetBytesRead(Long64_t num); Set number of bytes read. Long64_t GetBytesRead() const; Get number of bytes read. void WriteQueryLog(); Send to the connected monitoring servers information related to this query.; The information is of three types: 'summary', 'dataset' and 'files'.; Actual 'table' formatting is done by the relevant sender, implementation of; TProofMonSender, where the details are given. void Setup(TList* input); Setup the PROOF input list with requested statistics and tracing options. void Start(TList* input, TList* output); Initialize PROOF statistics run. void Stop(); Terminate the PROOF statistics run. void SetMemValues(); Record memory usage. void GetMemValues(Long_t& vmax, Long_t& rmax); Get memory usage. void SetNumEvents(Long64_t num); { fNumEvents = num; }. Long64_t GetNumEvents() const; { return fNumEvents; }. » Author: Kristjan Gulbrandsen 11/05/04 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/proofplayer:$Id: TPerfStats.h 40699 2011-08-25 10:36:29Z rdm $ » Last generated: 2011-12-02 14:28; This page has been automatically generated. For comments or suggestions regarding the document",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TPerfStats.html:9479,monitor,monitoring,9479,root/html532/TPerfStats.html,https://root.cern,https://root.cern/root/html532/TPerfStats.html,1,['monitor'],['monitoring']
Energy Efficiency,"Segura; Diego worked as technical student on CINT dictionary optimizations.; Eddy Offermann; Eddy joined the ROOT team during a sabbatical to work on making the ROOT matrix package the fastest and most versatile in the industry.; Ilka Antcheva; Ilka has been working from 2002 to 2008 in the ROOT team. She was responsible for the GUI system and designed many high level user interfaces and widgets, like found in many modern graphics applications: ROOT graphics editor (GED) and various object editors, Fit Panel, Style manager, a tool for automatic C++ code generation of any widget and the capability for widgets to save themselves. In addition Ilka took care of the ROOT Users Guide and contributed the chapter ‘Writing a Graphical User Interface’.; Gerardo Ganis; Gerri was a team member for more than ten years; among many other contributions he was in charge of PROOF for many years.; Jan Iwaszkiewicz; Jan was working in the context of a Ph.D. on scheduling and load-balancing of distributed processing in the Parallel ROOT Facility (PROOF).; Leandro Franco; Leo worked a Marie-Curie fellow in the ROOT team from 2005-2008. He worked on a number of widely different topics, from parallel sockets, I/O read-ahead, CINT dictionary, etc.; Maarten Ballintijn; Maarten's initial dab into ROOT was porting it to Linux in 1995. Later he worked on the PROOF system, bringing into production for the RHIC experiments in Brookhaven.; Marek Biskup; Marek worked as technical student on various aspects of PROOF, notably integrating the TChain::Draw() command into PROOF.; Masaharu Goto; Masa is the father of CINT. Without the indefatigable support by Masa we would never have succeeded with the tight integration of CINT in ROOT. Masa is now managing a large division in Agilent and cannot spend as much time on CINT as he would like.; Matevž Tadel; Matevž Tadel is the main developer of 3D graphics and event-visualization packages. He holds a Ph.D. in experimental high-energy physics, obtained in 20",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/previous-developers.html:3997,schedul,scheduling,3997,d/previous-developers.html,https://root.cern,https://root.cern/d/previous-developers.html,1,['schedul'],['scheduling']
Energy Efficiency,"SetInfo & ; dsi, . Types::EVariableTransform ; tf, . const TString & ; trfName . ). standard constructor ; Definition at line 64 of file VariableTransformBase.cxx. ◆ ~VariableTransformBase(). TMVA::VariableTransformBase::~VariableTransformBase ; (; void ; ). virtual . Definition at line 99 of file VariableTransformBase.cxx. Member Function Documentation. ◆ AttachXMLTo(). void TMVA::VariableTransformBase::AttachXMLTo ; (; void * ; parent). pure virtual . create XML description the transformation (write out info of selected variables) ; Implemented in TMVA::VariableDecorrTransform, TMVA::VariableGaussTransform, TMVA::VariableIdentityTransform, TMVA::VariableNormalizeTransform, TMVA::VariablePCATransform, and TMVA::VariableRearrangeTransform.; Definition at line 620 of file VariableTransformBase.cxx. ◆ CalcNorm(). void TMVA::VariableTransformBase::CalcNorm ; (; const std::vector< const Event * > & ; events). protected . TODO --> adapt to variable,target,spectator selection method to calculate minimum, maximum, mean, and RMS for all variables used in the MVA. ; Definition at line 470 of file VariableTransformBase.cxx. ◆ Class(). static TClass * TMVA::VariableTransformBase::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TMVA::VariableTransformBase::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TMVA::VariableTransformBase::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 176 of file VariableTransformBase.h. ◆ CountVariableTypes(). void TMVA::VariableTransformBase::CountVariableTypes ; (; UInt_t & ; nvars, . UInt_t & ; ntgts, . UInt_t & ; nspcts . ); const. virtual . count variables, targets and spectators ; Definition at line 429 of file VariableTransformBase.cxx. ◆ DeclFileName(). static const char * TMVA::VariableTransformBase::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1VariableTransformBase.html:16997,adapt,adapt,16997,doc/master/classTMVA_1_1VariableTransformBase.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1VariableTransformBase.html,1,['adapt'],['adapt']
Energy Efficiency,"SetkDim(Int_t kDim)Definition TFoam.h:115; TFoam::TFoamTFoam()Default constructor for streamer, user should not use it.Definition TFoam.cxx:145; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; TH2D2-D histogram with a double per channel (see TH1 documentation)Definition TH2.h:357; TH2::FillInt_t Fill(Double_t) overrideInvalid Fill method.Definition TH2.cxx:393; TRandom3Random number generator class based on M.Definition TRandom3.h:27; TRandomThis is the base class for the ROOT Random number generators.Definition TRandom.h:27; TRandom::SetSeedvirtual void SetSeed(ULong_t seed=0)Set the random generator seed.Definition TRandom.cxx:615; double; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; TMath::Piconstexpr Double_t Pi()Definition TMath.h:37; . Canonical nine steering parameters of FOAM. Name default Description . kDim 0 Dimension of the integration space. Must be redefined! . nCells 1000 No of allocated number of cells, . nSampl 200 No. of MC events in the cell MC exploration . nBin 8 No. of bins in edge-histogram in cell exploration . OptRej 1 OptRej = 0, weighted; OptRej=1, wt=1 MC events . OptDrive 2 Maximum weight reduction, =1 for variance reduction . EvPerBin 25 Maximum number of the effective wt=1 events/bin, . EvPerBin=0 deactivates this option . Chat 1 =0,1,2 is the `‘chat level’' in the standard output . MaxWtRej 1.1 Maximum weight used to get w=1 MC events . The above can be redefined before calling Initialize() method, for instance FoamObject->SetkDim(15) sets dimension of the distribution to 15. Only kDim HAS TO BE redefined, the other parameters may be left at their defaults. nCell may be increased up to about million cells for wildly peaked distributions. Increasing nSampl sometimes helps, but it may cost CPU time. MaxWtRej may need to be increased for wild a distribution, while using OptRej=0.; Past versions of FOAM: August 2003, v.1.00; September 2003 v.1.01 Adop",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFoam.html:6374,allocate,allocated,6374,doc/master/classTFoam.html,https://root.cern,https://root.cern/doc/master/classTFoam.html,1,['allocate'],['allocated']
Energy Efficiency,"Settings::m_fileNameNetConfigstd::string m_fileNameNetConfigDefinition NeuralNet.h:1011; TMVA::DNN::ClassificationSettings::~ClassificationSettingsvirtual ~ClassificationSettings()d'torDefinition NeuralNet.h:924; TMVA::DNN::ClassificationSettings::m_targetsstd::vector< double > m_targetsDefinition NeuralNet.h:997; TMVA::DNN::ClassificationSettings::testSamplevoid testSample(double error, double output, double target, double weight)action to be done after the computation of a test sample (e.g.Definition NeuralNet.cxx:304; TMVA::DNN::ClassificationSettings::m_scaleToNumEventssize_t m_scaleToNumEventsDefinition NeuralNet.h:1006; TMVA::DNN::ClassificationSettings::startTestCyclevirtual void startTestCycle()action to be done when the test cycle is started (e.g.Definition NeuralNet.cxx:316; TMVA::DNN::ClassificationSettings::m_sumOfBkgWeightsdouble m_sumOfBkgWeightsDefinition NeuralNet.h:1005; TMVA::DNN::ClassificationSettings::setWeightSumsvoid setWeightSums(double sumOfSigWeights, double sumOfBkgWeights)set the weight sums to be scaled to (preparations for monitoring output)Definition NeuralNet.cxx:512; TMVA::DNN::ClassificationSettings::m_amsstd::vector< double > m_amsDefinition NeuralNet.h:1000; TMVA::DNN::ClassificationSettings::m_cutValuedouble m_cutValueDefinition NeuralNet.h:1008; TMVA::DNN::ClassificationSettings::m_outputstd::vector< double > m_outputDefinition NeuralNet.h:996; TMVA::DNN::LayerDataLayerData holds the data of one layer.Definition NeuralNet.h:437; TMVA::DNN::LayerData::m_itInputBeginconst_iterator_type m_itInputBeginiterator to the first of the nodes in the input node vectorDefinition NeuralNet.h:639; TMVA::DNN::LayerData::deltasBeginconst_iterator_type deltasBegin() constreturns const iterator to the begin of the deltas (back-propagation)Definition NeuralNet.h:594; TMVA::DNN::LayerData::valuesBeginiterator_type valuesBegin()returns iterator to the begin of the (node) valuesDefinition NeuralNet.h:585; TMVA::DNN::LayerData::valuesEndconst_iterator_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/NeuralNet_8h_source.html:53439,monitor,monitoring,53439,doc/master/NeuralNet_8h_source.html,https://root.cern,https://root.cern/doc/master/NeuralNet_8h_source.html,1,['monitor'],['monitoring']
Energy Efficiency,"Source > source, const RNTupleReadOptions &options);  The model is generated from the ntuple metadata on storage. ;  ;  RNTupleReader (std::unique_ptr< RNTupleModel > model, std::unique_ptr< Internal::RPageSource > source, const RNTupleReadOptions &options);  ; void ConnectModel (RNTupleModel &model);  ; RNTupleReader * GetDisplayReader ();  ; void InitPageSource (bool enableMetrics);  ; DescriptorId_t RetrieveFieldId (std::string_view fieldName) const;  . Private Attributes; std::unique_ptr< RNTupleDescriptor > fCachedDescriptor;  The ntuple descriptor in the page source is protected by a read-write lock. ;  ; std::unique_ptr< RNTupleReader > fDisplayReader;  We use a dedicated on-demand reader for Show() and Scan(). ;  ; Detail::RNTupleMetrics fMetrics;  ; std::unique_ptr< RNTupleModel > fModel;  Needs to be destructed before fSource. ;  ; std::unique_ptr< Internal::RPageSource > fSource;  ; std::unique_ptr< Internal::RPageStorage::RTaskScheduler > fUnzipTasks;  Set as the page source's scheduler for parallel page decompression if IMT is on Needs to be destructed after the pages source is destructed (an thus be declared before) ;  . #include <ROOT/RNTupleReader.hxx>; Constructor & Destructor Documentation. ◆ RNTupleReader() [1/2]. ROOT::Experimental::RNTupleReader::RNTupleReader ; (; std::unique_ptr< RNTupleModel > ; model, . std::unique_ptr< Internal::RPageSource > ; source, . const RNTupleReadOptions & ; options . ). private . Definition at line 61 of file RNTupleReader.cxx. ◆ RNTupleReader() [2/2]. ROOT::Experimental::RNTupleReader::RNTupleReader ; (; std::unique_ptr< Internal::RPageSource > ; source, . const RNTupleReadOptions & ; options . ). explicitprivate . The model is generated from the ntuple metadata on storage. ; Definition at line 76 of file RNTupleReader.cxx. ◆ ~RNTupleReader(). ROOT::Experimental::RNTupleReader::~RNTupleReader ; (; ). default . Member Function Documentation. ◆ begin(). RIterator ROOT::Experimental::RNTupleReader::begin ; (; ). inli",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RNTupleReader.html:5870,schedul,scheduler,5870,doc/master/classROOT_1_1Experimental_1_1RNTupleReader.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RNTupleReader.html,1,['schedul'],['scheduler']
Energy Efficiency,"SparseT<ArrayF>): bin content held by a Float_t,; THnSparseL (typedef for THnSparseT<ArrayL64>): bin content held by a Long64_t,; THnSparseI (typedef for THnSparseT<ArrayI>): bin content held by an Int_t,; THnSparseS (typedef for THnSparseT<ArrayS>): bin content held by a Short_t,; THnSparseC (typedef for THnSparseT<ArrayC>): bin content held by a Char_t,. They take name and title, the number of dimensions, and for each dimension the number of bins, the minimal, and the maximal value on the dimension's axis. A TH2 h(""h"",""h"",10, 0., 10., 20, -5., 5.) would correspond to Int_t bins[2] = {10, 20};; Double_t xmin[2] = {0., -5.};; Double_t xmax[2] = {10., 5.};; THnSparseD hs(""hs"", ""hs"", 2, bins, xmin, xmax);; ; Filling; A THnSparse is filled just like a regular histogram, using THnSparse::Fill(x, weight), where x is a n-dimensional Double_t value. To take errors into account, Sumw2() must be called before filling the histogram.; Bins are allocated as needed; the status of the allocation can be observed by GetSparseFractionBins(), GetSparseFractionMem(). Fast Bin Content Access; When iterating over a THnSparse one should only look at filled bins to save processing time. The number of filled bins is returned by THnSparse::GetNbins(); the bin content for each (linear) bin number can be retrieved by THnSparse::GetBinContent(linidx, (Int_t*)coord). After the call, coord will contain the bin coordinate of each axis for the bin with linear index linidx. A possible call would be; std::cout << hs.GetBinContent(0, coord); std::cout <<"" is the content of bin [x = "" << coord[0] ""; << "" | y = "" << coord[1] << ""]"" << std::endl;. @subsection autotoc_md369 Efficiency; TH1 and TH2 are generally faster than THnSparse for one and two dimensional; distributions. THnSparse becomes competitive for a sparsely filled TH3; with large numbers of bins per dimension. The tutorial sparsehist.C; shows the turning point. On a AMD64 with 8GB memory, THnSparse ""wins"" starting with a TH3 with 30 bins per",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHnSparse.html:1923,allocate,allocated,1923,doc/master/classTHnSparse.html,https://root.cern,https://root.cern/doc/master/classTHnSparse.html,1,['allocate'],['allocated']
Energy Efficiency,"Spectrum; 3545 case 107:; 3546 {; 3547 Double_t red[9] = { 18./255., 72./255., 5./255., 23./255., 29./255., 201./255., 200./255., 98./255., 29./255.};; 3548 Double_t green[9] = { 0./255., 0./255., 43./255., 167./255., 211./255., 117./255., 0./255., 0./255., 0./255.};; 3549 Double_t blue[9] = { 51./255., 203./255., 177./255., 26./255., 10./255., 9./255., 8./255., 3./255., 0./255.};; 3550 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3551 }; 3552 break;; 3553 ; 3554 // Water Melon; 3555 case 108:; 3556 {; 3557 Double_t red[9] = { 19./255., 42./255., 64./255., 88./255., 118./255., 147./255., 175./255., 187./255., 205./255.};; 3558 Double_t green[9] = { 19./255., 55./255., 89./255., 125./255., 154./255., 169./255., 161./255., 129./255., 70./255.};; 3559 Double_t blue[9] = { 19./255., 32./255., 47./255., 70./255., 100./255., 128./255., 145./255., 130./255., 75./255.};; 3560 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3561 }; 3562 break;; 3563 ; 3564 // Cool; 3565 case 109:; 3566 {; 3567 Double_t red[9] = { 33./255., 31./255., 42./255., 68./255., 86./255., 111./255., 141./255., 172./255., 227./255.};; 3568 Double_t green[9] = { 255./255., 175./255., 145./255., 106./255., 88./255., 55./255., 15./255., 0./255., 0./255.};; 3569 Double_t blue[9] = { 255./255., 205./255., 202./255., 203./255., 208./255., 205./255., 203./255., 206./255., 231./255.};; 3570 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3571 }; 3572 break;; 3573 ; 3574 // Copper; 3575 case 110:; 3576 {; 3577 Double_t red[9] = { 0./255., 25./255., 50./255., 79./255., 110./255., 145./255., 181./255., 201./255., 254./255.};; 3578 Double_t green[9] = { 0./255., 16./255., 30./255., 46./255., 63./255., 82./255., 101./255., 124./255., 179./255.};; 3579 Double_t blue[9] = { 0./255., 12./255., 21./255., 29./255., 39./255., 49./255., 61./255., 74./255., 103./255.};; 3580 Idx = TColor::CreateGradientColorTable(9, stops,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TColor_8cxx_source.html:141764,green,green,141764,doc/master/TColor_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html,1,['green'],['green']
Energy Efficiency,"SplitLevel >= TTree::kSplitCollectionOfPointers ); 5923 {; 5924 TBranchElement *parent = (TBranchElement *)GetMother()->GetSubBranch( this );; 5925 ; 5926 // Make sure the StreamerInfo is loaded and initialized.; 5927 GetInfoImp();; 5928 ; 5929 if( !parent->GetAddress() ); 5930 parent->SetAddress( nullptr );; 5931 return;; 5932 }; 5933 ; 5934 //--------------------------------------------------------------------------; 5935 // Any other case; 5936 /////////////////////////////////////////////////////////////////////////////; 5937 ; 5938 TBranchElement* mother = (TBranchElement*) GetMother();; 5939 if (!mother) {; 5940 return;; 5941 }; 5942 TClass* cl = TClass::GetClass(mother->GetClassName());; 5943 ; 5944 // Make sure the StreamerInfo is loaded and initialized.; 5945 GetInfoImp();; 5946 ; 5947 if (!cl) {; 5948 return;; 5949 }; 5950 ; 5951 if (!mother->GetAddress()) {; 5952 // -- Our top-level branch has no address.; 5953 bool motherStatus = mother->TestBit(kDoNotProcess);; 5954 mother->ResetBit(kDoNotProcess);; 5955 // Note: This will allocate an object.; 5956 mother->SetAddress(nullptr);; 5957 mother->SetBit(kDoNotProcess, motherStatus);; 5958 }; 5959}; 5960 ; 5961////////////////////////////////////////////////////////////////////////////////; 5962/// Stream an object of class TBranchElement.; 5963 ; 5964void TBranchElement::Streamer(TBuffer& R__b); 5965{; 5966 if (R__b.IsReading()) {; 5967 R__b.ReadClassBuffer(TBranchElement::Class(), this);; 5968 fParentClass.SetName(fParentName);; 5969 fBranchClass.SetName(fClassName);; 5970 fTargetClass.SetName(fClassName);; 5971 fClonesClass.SetName(fClonesName);; 5972 // The fAddress and fObject data members are not persistent,; 5973 // therefore we do not own anything.; 5974 // Also clear the bit possibly set by the schema evolution.; 5975 ResetBit(kDeleteObject|kCache|kOwnOnfileObj|kAddressSet|kDecomposedObj);; 5976 // Fixup a case where the TLeafElement was missing; 5977 if ((fType == 0) && (fLeaves.GetEntriesFast() == 0",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBranchElement_8cxx_source.html:223079,allocate,allocate,223079,doc/master/TBranchElement_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html,1,['allocate'],['allocate']
Energy Efficiency,"Statsslave status, keyed by correspondig TSlave; TTimeTVirtualPacketizer::fStartTimetime offset; Bool_tTVirtualPacketizer::fStopTermination of Process() requested?; Float_tTVirtualPacketizer::fTimeUpdttime between updates; Long64_tTVirtualPacketizer::fTotalEntriestotal number of entries to be distributed;; TVirtualPacketizer::EUseEstOptTVirtualPacketizer::fUseEstOptControl usage of estimated values for the progress info; Bool_tTVirtualPacketizer::fValidConstructed properly?. private:. TList*fActivenodes with unfinished files; Float_tfBaseLocalPreferenceindicates how much more likely the nodes will be; Bool_tfCachePacketSynccontrol synchronization of cache and packet sizes; TList*fFileNodesnodes with files; TSortedList*fFilesToProcessGlobal list of files (TFileStat) to be processed; Bool_tfForceLocalif 1 - eliminate the remote processing; Float_tfFractionOfRemoteFilesfraction of TDSetElements that are on non-workers; Double_tfMaxEntriesRatiomax file entries to avg allowed ratio for cache-to-packet sync; Int_tfMaxPerfIdxmaximum of our slaves' performance index; Long_tfMaxSlaveCntmaximum number of workers per filenode (Long_t to avoid; Long64_tfNEventsOnRemLocnumber of events in currently; Int_tfPacketAsAFractionused to calculate the packet size; TList*fPartitionslist of partitions on nodes; Int_tfStrategy0 means the classic and 1 (default) - the adaptive strategy; Int_tfTryReassignControls attempts to reassign packets (0 == no reassignment); TList*fUnAllocatednodes with unallocated files. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPacketizerAdaptive(TDSet* dset, TList* slaves, Long64_t first, Long64_t num, TList* input, TProofProgressStatus* st); Constructor. ~TPacketizerAdaptive(); Destructor. void InitStats(); (re)initialise the statistics; called at the begining or after a worker dies. void RemoveUnAllocNode(TPacketizerAdaptive::TFileNode* ); Remove unallocated node. void RemoveActive(TPacketizerAdaptive::TFileStat* ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TPacketizerAdaptive.html:11485,adapt,adaptive,11485,root/html530/TPacketizerAdaptive.html,https://root.cern,https://root.cern/root/html530/TPacketizerAdaptive.html,3,['adapt'],['adaptive']
Energy Efficiency,"Stop();; ++rep[h];; } while ((!h && w.RealTime() < 0.1); || (h && rep[0] > 0 && rep[1] < rep[0]));; ; fTime[h][0] = (1.* fNum * rep[h]) / w.RealTime() / 1E6;; fTime[h][1] = (1.* fNum * rep[h]) / w.CpuTime() / 1E6;; ; if (h == 1 && (fTime[h][0] > 1E20 || fTime[h][1] > 1E20)) {; do {; // some more cycles:; w.Start(kFALSE);; Fill((EHist) h);; Check((EHist) h);; w.Stop();; ++rep[h];; } while (w.RealTime() < 0.1);; ; fTime[h][0] = (1.* fNum * rep[h]) / w.RealTime() / 1E6;; fTime[h][1] = (1.* fNum * rep[h]) / w.CpuTime() / 1E6;; }; ; if (fTime[h][0] > 1E20) fTime[h][0] = 1E20;; if (fTime[h][1] > 1E20) fTime[h][1] = 1E20;; }; catch (std::exception&) {; fTime[h][0] = fTime[h][1] = -1.;; check[h] = -1.; // can never be < 1 without exception; rep[h] = -1;; }; }; if (check[0] != check[1]); if (check[0] != -1.); printf(""ERROR: mismatch of histogram (%g) and sparse histogram (%g) for dim=%d, bins=%d!\n"",; check[0], check[1], fDim, fBins);; // else; // printf(""ERROR: cannot allocate histogram for dim=%d, bins=%d - out of memory!\n"",; // fDim, fBins);; return (check[0] == check[1]);; }; ; void TTimeHists::NextValues(); {; for (Int_t d = 0; d < fDim; ++d); fValue[d] = gRandom->Gaus() / 4.;; }; ; void TTimeHists::SetupValues(); {; // define fValue; if (!fValue) fValue = new Double_t[fDim];; gRandom->SetSeed(42);; }; ; void TTimeHists::Fill(EHist hist); {; for (Long_t n = 0; n < fNum; ++n) {; NextValues();; if (fgDebug > 1) {; printf(""%ld: fill %s"", n, hist == kHist? (fDim < 4 ? ""hist"" : ""arr"") : ""sparse"");; for (Int_t d = 0; d < fDim; ++d); printf(""[%g]"", fValue[d]);; printf(""\n"");; }; if (hist == kHist) {; switch (fDim) {; case 1: fHist->Fill(fValue[0]); break;; case 2: ((TH2F*)fHist)->Fill(fValue[0], fValue[1]); break;; case 3: ((TH3F*)fHist)->Fill(fValue[0], fValue[1], fValue[2]); break;; default: fHn->Fill(fValue); break;; }; } else {; fSparse->Fill(fValue);; }; }; }; ; void TTimeHists::SetupHist(EHist hist); {; if (hist == kHist) {; switch (fDim) {; case 1: fHist = new TH1F(""h1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/sparsehist_8C.html:4031,allocate,allocate,4031,doc/master/sparsehist_8C.html,https://root.cern,https://root.cern/doc/master/sparsehist_8C.html,1,['allocate'],['allocate']
Energy Efficiency,"Store Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Static Public Member Functions |; Protected Member Functions |; Protected Attributes |; List of all members ; RooCompositeDataStore Class ReferenceRooFit » RooFit Core. ; Combines several disjunct datasets into one. ; This is useful for simultaneous PDFs that do not depend on the same observable such as a PDF depending on x combined with another one depending on y. The composite storage will store two different datasets, {x} and {y}, but they can be passed as a single dataset to RooFit operations. A category tag will define which dataset has to be passed to which likelihood.; When iterated from start to finish, datasets will be traversed in the order of the category index. ; Definition at line 33 of file RooCompositeDataStore.h. Public Member Functions;  RooCompositeDataStore ();  ;  RooCompositeDataStore (const RooCompositeDataStore &other, const char *newname=nullptr);  Convert map by label to map by index for more efficient internal use. ;  ;  RooCompositeDataStore (const RooCompositeDataStore &other, const RooArgSet &vars, const char *newname=nullptr);  Update index category pointer, if it is contained in input argument vars. ;  ;  RooCompositeDataStore (RooStringView name, RooStringView title, const RooArgSet &vars, RooCategory &indexCat, std::map< std::string, RooAbsDataStore * > const &inputData);  Convert map by label to map by index for more efficient internal use. ;  ;  ~RooCompositeDataStore () override;  Destructor. ;  ; RooAbsArg * addColumn (RooAbsArg &var, bool adjustRange=true) override;  WVE ownership issue here!! Caller (a RooAbsData) should take ownership of all arguments, but only does for the first one here... ;  ; void append (RooAbsDataStore &other) override;  ; void attachBuffers (const RooArgSet &extObs) override;  ; void cacheArgs (const RooAbsArg *owner, RooArgSet &varSet, const RooArgSet",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCompositeDataStore.html:1109,efficient,efficient,1109,doc/master/classRooCompositeDataStore.html,https://root.cern,https://root.cern/doc/master/classRooCompositeDataStore.html,1,['efficient'],['efficient']
Energy Efficiency,"Stream, const char* branchDescriptor = """", char delimiter = ' '); Create or simply read branches from an input stream. See reference information for TTree::ReadFile. void RecursiveRemove(TObject* obj); Make sure that obj (which is being deleted or will soon be) is no; longer referenced by this TTree. void Refresh(); Refresh contents of this tree and its branches from the current status on disk. One can call this function in case the tree file is being; updated by another process. void RemoveFriend(TTree* ); Remove a friend from the list of friends. void Reset(Option_t* option = """"); Reset baskets, buffers and entries count in all branches and leaves. void ResetAfterMerge(TFileMergeInfo* ); Resets the state of this TTree after a merge (keep the customization but; forget the data). void ResetBranchAddress(TBranch* ); Tell all of our branches to set their addresses to zero. Note: If any of our branches own any objects, they are deleted. void ResetBranchAddresses(); Tell all of our branches to drop their current objects and allocate new ones. Long64_t Scan(const char* varexp = """", const char* selection = """", Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Loop over tree entries and print entries passing selection. If varexp is 0 (or """") then print only first 8 columns.; If varexp = ""*"" print all columns.; Otherwise a columns selection can be made using ""var1:var2:var3"".; See TTreePlayer::Scan for more information. Bool_t SetAlias(const char* aliasName, const char* aliasFormula); Set a tree variable alias. Set an alias for an expression/formula based on the tree 'variables'. The content of 'aliasName' can be used in TTreeFormula (i.e. TTree::Draw,; TTree::Scan, TTreeViewer) and will be evaluated as the content of; 'aliasFormula'.; If the content of 'aliasFormula' only contains symbol names, periods and; array index specification (for example event.fTracks[3]), then; the content of 'aliasName' can be used as the start of symbol. If the alia",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTree.html:119807,allocate,allocate,119807,root/html532/TTree.html,https://root.cern,https://root.cern/root/html532/TTree.html,4,['allocate'],['allocate']
Energy Efficiency,"Streamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Double_tfEtotTotal energy in GeV; Int_tfFirstMotherIndex of the first mother particle; Int_tfGenerationGeneration flag: last gen. (0) or not (1) or ghost (2); Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; Int_tfPartParticle id produced; Double_tfPxMomentum in x direction in GeV/c; Double_tfPyMomentum in y direction in GeV/c; Double_tfPzMomentum in z direction in GeV/c; Int_tfSecondMotherIndex of the second mother particle(if any); Double_tfTimeTime of particle production in user units; Double_tfTimeEndTime of particle destruction (always in the pp-cms!); TStringfTypeIndicator of primary type; Double_tfVxProduction vertex x position in user units; Double_tfVyProduction vertex y position in user units; Double_tfVzProduction vertex z position in user units. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPrimary(). Primary vertex particle default constructor. TPrimary(Int_t part, Int_t first, Int_t second, Int_t gener, Double_t px, Double",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TPrimary.html:6543,energy,energy,6543,root/html528/TPrimary.html,https://root.cern,https://root.cern/root/html528/TPrimary.html,3,['energy'],['energy']
Energy Efficiency,"Streamer(TBuffer& refBuffer, void* pObject, int siz). protected:. voidCheckFunctions() const; virtual voidDeleteItem(Bool_t force, void* ptr) const; TGenCollectionProxy*Initialize() const; virtual TGenCollectionProxy*InitializeEx(). private:. TGenCollectionProxy(). Data Members; public:. enum { kBIT_ISSTRING; kBIT_ISTSTRING; kBOOL_t; };; enum TVirtualCollectionProxy::EProperty { kIsInitialized; kIsAssociative; kIsEmulated; };. public:. static const Int_tTVirtualCollectionProxy::fgIteratorArenaSizegreater than sizeof(void*) + sizeof(UInt_t). protected:. TClassRefTVirtualCollectionProxy::fClass; TGenCollectionProxy::MethodfClearMethod cache for container accessors: clear container; TGenCollectionProxy::MethodfCollectMethod to collect objects from container; void*fConstructContainer accessors: block construct; map<std::string,TObjArray*>*fConversionReadMemberWiseArray of bundle of TStreamerInfoActions to stream out (read) derived from another class.; TGenCollectionProxy::Method0fCreateEnvMethod to allocate an Environment holder.; void*fDestructContainer accessors: block destruct; ROOT::TCollectionProxyInfo::EnvironBase*fEnvAddress of the currently proxied object; void*fFeedContainer accessors: block feed; TGenCollectionProxy::MethodfFirstContainer accessors: generic iteration: first; void*fFunctionCreateIterators; void*fFunctionDeleteTwoIterators; TGenCollectionProxy::Value*fKeyDescriptor of the key_type; stringfNameName of the class being proxied.; TGenCollectionProxy::MethodfNextContainer accessors: generic iteration: next; TClass*fOnFileClassOn file class; Bool_tfPointersFlag to indicate if containee has pointers (key or value); UInt_tTVirtualCollectionProxy::fProperties; vector<ROOT::TCollectionProxyInfo::EnvironBase*,allocator<ROOT::TCollectionProxyInfo::EnvironBase*> >fProxyKeptOptimization: Keep proxies once they were created; vector<ROOT::TCollectionProxyInfo::EnvironBase*,allocator<ROOT::TCollectionProxyInfo::EnvironBase*> >fProxyListStack of recursive proxies;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGenCollectionProxy.html:4185,allocate,allocate,4185,root/html528/TGenCollectionProxy.html,https://root.cern,https://root.cern/root/html528/TGenCollectionProxy.html,2,['allocate'],['allocate']
Energy Efficiency,"StreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Double_tfEtotTotal energy in GeV; Int_tfFirstMotherIndex of the first mother particle; Int_tfGenerationGeneration flag: last gen. (0) or not (1) or ghost (2); Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; Int_tfPartParticle id produced; Double_tfPxMomentum in x direction in GeV/c; Double_tfPyMomentum in y direction in GeV/c; Double_tfPzMomentum in z direction in GeV/c; Int_tfSecondMotherIndex of the second mother particle(if any); Double_tfTimeTime of particle production in user units; Double_tfTimeEndTime of particle destruction (always in the pp-cms!); TStringfTypeIndicator of primary type; Double_tfVxProduction vertex x position in user units; Double_tfVyProduction vertex y position in user units; Double_tfVzProduction vertex z position in user units. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPrimary(). Primary vertex particle default constructor. TPrimary(Int_t part, Int_t first, Int_t second, Int_t gener, Double_t px, Double",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TPrimary.html:6704,energy,energy,6704,root/html534/TPrimary.html,https://root.cern,https://root.cern/root/html534/TPrimary.html,1,['energy'],['energy']
Energy Efficiency,"Style GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t typeDefinition TGWin32VirtualXProxy.cxx:249; y1Option_t Option_t TPoint TPoint const char y1Definition TGWin32VirtualXProxy.cxx:70; free#define freeDefinition civetweb.c:1539; malloc#define mallocDefinition civetweb.c:1536; ROOT::Detail::VecOps::RVecImplThis class consists of common code factored out of the SmallVector class to reduce code duplication b...Definition RVec.hxx:561; ROOT::Detail::VecOps::RVecImpl::assignvoid assign(size_type NumElts, const T &Elt)Definition RVec.hxx:680; ROOT::Detail::VecOps::RVecImpl::iteratortypename SuperClass::iterator iteratorDefinition RVec.hxx:565; ROOT::Detail::VecOps::RVecImpl::size_typetypename SuperClass::size_type size_typeDefinition RVec.hxx:568; ROOT::Detail::VecOps::RVecImpl::appendvoid append(in_iter in_start, in_iter in_end)Add the specified range to the end of the SmallVector.Definition RVec.hxx:654; ROOT::Detail::VecOps::RVecImpl::insertiterator insert(iterator I, T &&Elt)Definition RVec.hxx:741; ROOT::Detail::VecOps::RVecImpl::resizevoid resize(size_type N)Definition RVec.hxx:596; ROOT::Detail::VecOps::RVecImpl::assignvoid assign(std::initializer_list< T > IL)Definition RVec.hxx:698; ROOT::Detail::VecOps::RVecImpl::const_iteratortypename SuperClass::const_iterator const_iteratorDefinition RVec.hxx:566; ROOT::Detail:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RVec_8hxx_source.html:131272,reduce,reduce,131272,doc/master/RVec_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html,2,['reduce'],['reduce']
Energy Efficiency,"Swap points. ;  ; void UpdateArrays (const std::vector< Int_t > &sorting_indices, Int_t numSortedPoints, Int_t low) override;  Update the fX, fY, fExL, fExH, fEyL and fEyH arrays with the sorted values. ;  ;  Protected Member Functions inherited from TGraph; Double_t ** AllocateArrays (Int_t Narrays, Int_t arraySize);  Allocate arrays. ;  ; Bool_t CtorAllocate ();  In constructors set fNpoints than call this method. ;  ; Double_t ** ExpandAndCopy (Int_t size, Int_t iend);  if size > fMaxSize allocate new arrays of 2*size points and copy iend first points. ;  ; TString SaveArray (std::ostream &out, const char *suffix, Int_t frameNumber, Double_t *arr);  Save array as C++ code Returns name of created array. ;  ; void SaveHistogramAndFunctions (std::ostream &out, const char *varname, Int_t &frameNumber, Option_t *option);  Save histogram and list of functions of TGraph as C++ statement Used in all TGraph-derived classes. ;  ; Double_t ** ShrinkAndCopy (Int_t size, Int_t iend);  if size*2 <= fMaxSize allocate new arrays of size points, copy points [0,oend). ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; std::vector< TAttFill > fAttFill;  The AttFill attributes of the different errors. ;  ; std::vector< TAttLine > fAttLine;  The AttLine attributes of the different errors. ;  ; Double_t * fExH;  [fNpoints] array of X high errors ;  ; Double_t * fExL;  [fNpoints] array of X low errors ;  ; std::vector< TArrayD > fEyH;  Two dimensional array of Y high errors. ;  ; Double_t * fEyHSum = nullptr;  ! Array of summed Y high errors for fitting ;  ; std::vector< TArrayD > fEyL;  Two dimensional array of Y low errors. ;  ; Double_t * fEyLSum = nullptr;  ! Array of summed Y low errors for fitting ;  ; Int_t fNYErrors;  The amount of different y-errors. ;  ; Int_t fSumErrorsMode;  How y errors ar",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGraphMultiErrors.html:41839,allocate,allocate,41839,doc/master/classTGraphMultiErrors.html,https://root.cern,https://root.cern/doc/master/classTGraphMultiErrors.html,1,['allocate'],['allocate']
Energy Efficiency,"Sym<Element> &TMatrixTSym<Element> InvertFast(Double_t* det = 0); Invert the matrix and calculate its determinant. TMatrixTSym<Element> &TMatrixTSym<Element> Transpose(const TMatrixTSym<float>& source); Transpose a matrix. TMatrixTSym<Element> &TMatrixTSym<Element> Rank1Update(const TVectorT<float>& v, float alpha = 1.0); Perform a rank 1 operation on the matrix:; A += alpha * v * v^T. TMatrixTSym<Element> &TMatrixTSym<Element> Similarity(const TMatrixT<Element> &b); Calculate B * (*this) * B^T , final matrix will be (nrowsb x nrowsb); This is a similarity transform when B is orthogonal . It is more; efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . TMatrixTSym<Element> &TMatrixTSym<Element> Similarity(const TMatrixTSym<Element> &b); Calculate B * (*this) * B^T , final matrix will be (nrowsb x nrowsb); This is a similarity transform when B is orthogonal . It is more; efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . Element TMatrixTSym<Element> Similarity(const TVectorT<float>& v) const; Calculate scalar v * (*this) * v^T. TMatrixTSym<Element> &TMatrixTSym<Element> SimilarityT(const TMatrixT<float>& n); Calculate B^T * (*this) * B , final matrix will be (ncolsb x ncolsb); It is more efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . TMatrixTSym<Element> &TMatrixTSym<Element> operator=(const TMatrixTSym<Element> &source). TMatrixTSym<Element> &TMatrixTSym<Element> operator=(const TMatrixTSymLazy<Element> &lazy_constructor). TMatrixTSym<Element> &TMatrixTSym<Element> operator=(Element val); Assign val to every element of the matrix. TMatrixTSym<Element> &TMatrixTSym<Element> operator+=(Element val); Add val to every element of the matrix. TMatrixTSym<Element> &TMatrixTSym<Element> operator-=(Element val); Subtract val from every element of the matrix. TMatrixTSym<Eleme",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMatrixTSym_float_.html:18254,efficient,efficient,18254,root/html528/TMatrixTSym_float_.html,https://root.cern,https://root.cern/root/html528/TMatrixTSym_float_.html,4,['efficient'],['efficient']
Energy Efficiency,"T internal printing level. ; Definition at line 472 of file RooMinimizer.cxx. ◆ setProfile(). void RooMinimizer::setProfile ; (; bool ; flag = true). inline . Definition at line 170 of file RooMinimizer.h. ◆ setRecoverFromNaNStrength(). void RooMinimizer::setRecoverFromNaNStrength ; (; double ; strength). Try to recover from invalid function values. ; When invalid function values are encountered, a penalty term is returned to the minimiser to make it back off. This sets the strength of this penalty. NoteA strength of zero is equivalent to a constant penalty (= the gradient vanishes, ROOT < 6.24). Positive values lead to a gradient pointing away from the undefined regions. Use ~10 to force the minimiser away from invalid function values. ; Definition at line 802 of file RooMinimizer.cxx. ◆ setStrategy(). void RooMinimizer::setStrategy ; (; int ; istrat). Change MINUIT strategy to istrat. ; Accepted codes are 0,1,2 and represent MINUIT strategies for dealing most efficiently with fast FCNs (0), expensive FCNs (2) and 'intermediate' FCNs (1) ; Definition at line 189 of file RooMinimizer.cxx. ◆ setVerbose(). void RooMinimizer::setVerbose ; (; bool ; flag = true). inline . Definition at line 153 of file RooMinimizer.h. ◆ simplex(). int RooMinimizer::simplex ; (; ). Execute SIMPLEX. ; Changes in parameter values and calculated errors are automatically propagated back the RooRealVars representing the floating parameters in the MINUIT operation. ; Definition at line 453 of file RooMinimizer.cxx. ◆ Streamer(). void RooMinimizer::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void RooMinimizer::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 247 of file RooMinimizer.h. ◆ update(). bool RooMinimizer::update ; (; bool ; isValid). private . Definition at line 1100 of file RooMinimizer.cxx. ◆ updateErrors(). void RooMinimizer::updateErrors ; (; ).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooMinimizer.html:29292,efficient,efficiently,29292,doc/master/classRooMinimizer.html,https://root.cern,https://root.cern/doc/master/classRooMinimizer.html,1,['efficient'],['efficiently']
Energy Efficiency,"T's. More...;  ; class  SmallVectorTemplateBase< T, true >;  SmallVectorTemplateBase<TriviallyCopyable = true> - This is where we put method implementations that are designed to work with trivially copyable T's. More...;  ; class  SmallVectorTemplateCommon;  This is the part of SmallVectorTemplateBase which does not depend on whether the type T is a POD. More...;  . Typedefs; template<typename T > ; using RVec = ROOT::VecOps::RVec< T >;  . Functions; constexpr bool All (const bool *vals, std::size_t size);  ; template<typename... T> ; std::size_t GetVectorsSize (const std::string &id, const RVec< T > &... vs);  ; template<typename Tuple_t , std::size_t... Is> ; auto MapFromTuple (Tuple_t &&t, std::index_sequence< Is... >) -> decltype(MapImpl(std::get< std::tuple_size< Tuple_t >::value - 1 >(t), std::get< Is >(t)...));  ; template<typename F , typename... RVecs> ; auto MapImpl (F &&f, RVecs &&... vs) -> RVec< decltype(f(vs[0]...))>;  ; uint64_t NextPowerOf2 (uint64_t A);  Return the next power of two (in 64-bits) that is strictly greater than A. ;  ; template<typename T > ; void ResetView (RVec< T > &v, T *addr, std::size_t sz);  An unsafe function to reset the buffer for which this RVec is acting as a view. ;  ; template<typename ForwardIt > ; void UninitializedValueConstruct (ForwardIt first, ForwardIt last);  ; template<typename T , bool TriviallyCopyable> ;  void (off) SmallVectorTemplateBase< T;  . Typedef Documentation. ◆ RVec. template<typename T > . using ROOT::Internal::VecOps::RVec = typedef ROOT::VecOps::RVec<T>. Definition at line 69 of file RVec.hxx. Function Documentation. ◆ All(). constexpr bool ROOT::Internal::VecOps::All ; (; const bool * ; vals, . std::size_t ; size . ). constexpr . Definition at line 79 of file RVec.hxx. ◆ GetVectorsSize(). template<typename... T> . std::size_t ROOT::Internal::VecOps::GetVectorsSize ; (; const std::string & ; id, . const RVec< T > &... ; vs . ). Definition at line 88 of file RVec.hxx. ◆ MapFromTuple(). template<type",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1Internal_1_1VecOps.html:2029,power,power,2029,doc/master/namespaceROOT_1_1Internal_1_1VecOps.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1Internal_1_1VecOps.html,1,['power'],['power']
Energy Efficiency,"T->GetBinDir());; 996 lines.emplace_back(""```"");; 997 TString setup = """";; 998 for (auto& line : lines) {; 999 setup.Append(line);; 1000 setup.Append('\n');; 1001 }; 1002 setup.Chop(); // trim final `\n`; 1003 return setup;; 1004}; 1005 ; 1006////////////////////////////////////////////////////////////////////////////////; 1007/// It opens a Forum topic in a web browser with prefilled ROOT version; 1008///; 1009/// \param[in] type the issue type (only bug supported right now); 1010 ; 1011void TApplication::OpenForumTopic(const TString &type); 1012{; 1013 // https://meta.discourse.org/t/how-to-create-a-post-clicking-a-link/96197; 1014 ; 1015 if (type == ""bug"") {; 1016 //OpenInBrowser(""\""https://root-forum.cern.ch/new-topic?title=topic%20title&body=topic%20body&category=category/subcategory&tags=email,planned\"""");; 1017 TString report_template =; 1018R""(___; 1019_Please read [tips for efficient and successful posting](https://root-forum.cern.ch/t/tips-for-efficient-and-successful-posting/28292) and [posting code](https://root-forum.cern.ch/t/posting-code-read-this-first/28293)_; 1020 ; 1021### Describe the bug; 1022<!--; 1023A clear and concise description of what the wrong behavior is.; 1024-->; 1025### Expected behavior; 1026<!--; 1027A clear and concise description of what you expected to happen.; 1028-->; 1029 ; 1030### To Reproduce; 1031<!--; 1032Steps to reproduce the behavior:; 10331. Your code that triggers the issue: at least a part; ideally something we can run ourselves.; 10342. Don't forget to attach the required input files!; 10353. How to run your code and / or build it, e.g. `root myMacro.C`, ...; 1036-->; 1037 ; 1038### Setup; 1039)""+GetSetup()+; 1040R""(; 1041<!--; 1042Please specify also how you obtained ROOT, such as `dnf install` / binary download / you built it yourself.; 1043-->; 1044 ; 1045### Additional context; 1046<!--; 1047Add any other context about the problem here.; 1048-->)"";; 1049 report_template = FormatHttpUrl(report_template);; 1050 ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TApplication_8cxx_source.html:38934,efficient,efficient-and-successful-posting,38934,doc/master/TApplication_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html,1,['efficient'],['efficient-and-successful-posting']
Energy Efficiency,"T: TFoam Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Static Public Member Functions |; Protected Attributes |; Private Member Functions |; List of all members ; TFoam Class Reference. ; TFoam is the main class of the multi-dimensional general purpose Monte Carlo event generator (integrator) FOAM. . FOAM Version 1.02M; AuthorsS. Jadach and P.Sawicki Institute of Nuclear Physics, Cracow, Poland Stanislaw. Jadac.nosp@m.h@if.nosp@m.j.edu.nosp@m..pl, Pawel.nosp@m..Saw.nosp@m.icki@.nosp@m.ifj..nosp@m.edu.p.nosp@m.l. What is FOAM for?. Suppose you want to generate randomly points (vectors) according to an arbitrary probability distribution in n dimensions, for which you supply your own method. FOAM can do it for you! Even if your distributions has quite strong peaks and is discontinuous!; FOAM generates random points with weight one or with variable weight.; FOAM is capable to integrate using efficient ""adaptive"" MC method. (The distribution does not need to be normalized to one.). How does it work?; FOAM is the simplified version of the multi-dimensional general purpose Monte Carlo event generator (integrator) FOAM. It creates hyper-rectangular ""foam of cells"", which is more dense around its peaks. See the following 2-dim. example of the map of 1000 cells for doubly peaked distribution:. FOAM is now fully integrated with the ROOT package. The important bonus of the ROOT use is persistency of the FOAM objects!; For more sophisticated problems full version of FOAM may be more appropriate: See full version of FOAM. Simple example of the use of FOAM:; ; #include ""Riostream.h""; #include ""TFoam.h""; #include ""TCanvas.h""; #include ""TH2.h""; #include ""TMath.h""; #include ""TFoamIntegrand.h""; #include ""TRandom3.h""; ; //_____________________________________________________________________________; Double_t sqr(Double_t x){; return x*x;; }; //__________________________________________",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFoam.html:1008,efficient,efficient,1008,doc/master/classTFoam.html,https://root.cern,https://root.cern/doc/master/classTFoam.html,2,"['adapt', 'efficient']","['adaptive', 'efficient']"
Energy Efficiency,T::Internal::VecOps::SmallVectorTemplateCommon::backconst_reference back() constDefinition RVec.hxx:308; ROOT::Internal::VecOps::SmallVectorTemplateCommon::const_pointerconst T * const_pointerDefinition RVec.hxx:252; ROOT::Internal::VecOps::SmallVectorTemplateCommon::resetToSmallvoid resetToSmall()Put this vector in a state of being small.Definition RVec.hxx:229; ROOT::Internal::VecOps::SmallVectorTemplateCommon::pointerT * pointerDefinition RVec.hxx:251; ROOT::Internal::VecOps::SmallVectorTemplateCommon::frontreference front()Definition RVec.hxx:284; ROOT::Internal::VecOps::SmallVectorTemplateCommon::beginiterator begin() noexceptDefinition RVec.hxx:259; ROOT::Internal::VecOps::SmallVectorTemplateCommon::reverse_iteratorstd::reverse_iterator< iterator > reverse_iteratorDefinition RVec.hxx:247; ROOT::Internal::VecOps::SmallVectorTemplateCommon::const_referenceconst T & const_referenceDefinition RVec.hxx:250; ROOT::Internal::VecOps::SmallVectorTemplateCommon::isSmallbool isSmall() constReturn true if this is a smallvector which has not had dynamic memory allocated for it.Definition RVec.hxx:226; ROOT::Internal::VecOps::SmallVectorTemplateCommon::value_typeT value_typeDefinition RVec.hxx:242; ROOT::Internal::VecOps::SmallVectorTemplateCommon::crendconst_reverse_iterator crend() const noexceptDefinition RVec.hxx:272; ROOT::Internal::VecOps::SmallVectorTemplateCommon::endconst_iterator end() const noexceptDefinition RVec.hxx:263; ROOT::Internal::VecOps::SmallVectorTemplateCommon::SmallVectorTemplateCommonSmallVectorTemplateCommon(size_t Size)Definition RVec.hxx:220; ROOT::Internal::VecOps::SmallVectorTemplateCommon::emptybool empty() constDefinition RVec.hxx:177; ROOT::Internal::VecOps::SmallVectorTemplateCommon::referenceT & referenceDefinition RVec.hxx:249; ROOT::Internal::VecOps::SmallVectorTemplateCommon::crbeginconst_reverse_iterator crbegin() const noexceptDefinition RVec.hxx:269; ROOT::Internal::VecOps::SmallVectorTemplateCommon::iteratorT * iteratorDefinition RV,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RVec_8hxx_source.html:141667,allocate,allocated,141667,doc/master/RVec_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html,2,['allocate'],['allocated']
Energy Efficiency,"TArray* cont):; 428 fCoordinateAllocationSize(-1), fSingleCoordinateSize(coordsize), fCoordinatesSize(0),; 429 fCoordinates(nullptr), fContent(cont),; 430 fSumw2(nullptr); 431{; 432 fCoordinateAllocationSize = fSingleCoordinateSize * cont->GetSize();; 433 fCoordinates = new Char_t[fCoordinateAllocationSize];; 434 if (errors) Sumw2();; 435}; 436 ; 437////////////////////////////////////////////////////////////////////////////////; 438/// Destructor; 439 ; 440THnSparseArrayChunk::~THnSparseArrayChunk(); 441{; 442 delete fContent;; 443 delete [] fCoordinates;; 444 delete fSumw2;; 445}; 446 ; 447////////////////////////////////////////////////////////////////////////////////; 448/// Create a new bin in this chunk; 449 ; 450void THnSparseArrayChunk::AddBin(Int_t idx, const Char_t* coordbuf); 451{; 452 // When streaming out only the filled chunk is saved.; 453 // When reading back only the memory needed for that filled part gets; 454 // allocated. We need to check whether the allowed chunk size is; 455 // bigger than the allocated size. If fCoordinateAllocationSize is; 456 // set to -1 this chunk has been allocated by the streamer and the; 457 // buffer allocation size is defined by [fCoordinatesSize]. In that; 458 // case we need to compare fCoordinatesSize to; 459 // fSingleCoordinateSize * fContent->GetSize(); 460 // to determine whether we need to expand the buffer.; 461 if (fCoordinateAllocationSize == -1 && fContent) {; 462 Int_t chunksize = fSingleCoordinateSize * fContent->GetSize();; 463 if (fCoordinatesSize < chunksize) {; 464 // need to re-allocate:; 465 Char_t *newcoord = new Char_t[chunksize];; 466 memcpy(newcoord, fCoordinates, fCoordinatesSize);; 467 delete [] fCoordinates;; 468 fCoordinates = newcoord;; 469 }; 470 fCoordinateAllocationSize = chunksize;; 471 }; 472 ; 473 memcpy(fCoordinates + idx * fSingleCoordinateSize, coordbuf, fSingleCoordinateSize);; 474 fCoordinatesSize += fSingleCoordinateSize;; 475}; 476 ; 477/////////////////////////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THnSparse_8cxx_source.html:15996,allocate,allocated,15996,doc/master/THnSparse_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html,1,['allocate'],['allocated']
Energy Efficiency,TBuffer & ; R__b). overridevirtual . Stream an object of class TRefTable. ; Reimplemented from TObject.; Definition at line 391 of file TRefTable.cxx. ◆ StreamerNVirtual(). void TRefTable::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 93 of file TRefTable.h. Member Data Documentation. ◆ fAllocSize. Int_t* TRefTable::fAllocSize. protected . number of known ProcessIDs ; Definition at line 39 of file TRefTable.h. ◆ fDefaultSize. Int_t TRefTable::fDefaultSize. protected . current parent ID in fParents (latest call to SetParent) ; Definition at line 43 of file TRefTable.h. ◆ fgRefTable. TRefTable * TRefTable::fgRefTable = nullptr. staticprotected . cache of pid to index in fProcessGUIDs ; Definition at line 51 of file TRefTable.h. ◆ fMapPIDtoInternal. std::vector<Int_t> TRefTable::fMapPIDtoInternal. protected . Definition at line 50 of file TRefTable.h. ◆ fN. Int_t* TRefTable::fN. protected . [fNumPIDs] allocated size of array fParentIDs for each ProcessID ; Definition at line 40 of file TRefTable.h. ◆ fNumPIDs. Int_t TRefTable::fNumPIDs. protected . Definition at line 38 of file TRefTable.h. ◆ fOwner. TObject* TRefTable::fOwner. protected . Definition at line 48 of file TRefTable.h. ◆ fParentID. Int_t TRefTable::fParentID. protected . [fNumPIDs][fAllocSize] array of Parent IDs ; Definition at line 42 of file TRefTable.h. ◆ fParentIDs. Int_t** TRefTable::fParentIDs. protected . [fNumPIDs] current maximum number of IDs in array fParentIDs for each ProcessID ; Definition at line 41 of file TRefTable.h. ◆ fParents. TObjArray* TRefTable::fParents. protected . Definition at line 47 of file TRefTable.h. ◆ fProcessGUIDs. std::vector<std::string> TRefTable::fProcessGUIDs. protected . Definition at line 49 of file TRefTable.h. ◆ fSize. Int_t TRefTable::fSize. protected . TProcessID the current uid is referring to. ; Definition at line 46 of file TRefTable.h. ◆ fUID. UInt_t TRefTable::fUID. protected . default size for a new PID array ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTRefTable.html:21788,allocate,allocated,21788,doc/master/classTRefTable.html,https://root.cern,https://root.cern/doc/master/classTRefTable.html,1,['allocate'],['allocated']
Energy Efficiency,"TClass *cl) const;; 166 void Browse(TBrowser *b) override;; 167 Int_t Capacity() const { return fSize; }; 168 void Clear(Option_t *option="""") override = 0;; 169 TObject *Clone(const char *newname="""") const override;; 170 Int_t Compare(const TObject *obj) const override;; 171 Bool_t Contains(const char *name) const { return FindObject(name) != nullptr; }; 172 Bool_t Contains(const TObject *obj) const { return FindObject(obj) != nullptr; }; 173 void Delete(Option_t *option="""") override = 0;; 174 void Draw(Option_t *option="""") override;; 175 void Dump() const override;; 176 TObject *FindObject(const char *name) const override;; 177 TObject *operator()(const char *name) const;; 178 TObject *FindObject(const TObject *obj) const override;; 179 virtual Int_t GetEntries() const { return GetSize(); }; 180 const char *GetName() const override;; 181 virtual TObject **GetObjectRef(const TObject *obj) const = 0;; 182 /// Return the *capacity* of the collection, i.e. the current total amount of space that has been allocated so far.; 183 /// Same as `Capacity`. Use `GetEntries` to get the number of elements currently in the collection.; 184 virtual Int_t GetSize() const { return fSize; }; 185 virtual Int_t GrowBy(Int_t delta) const;; 186 ULong_t Hash() const override { return fName.Hash(); }; 187 Bool_t IsArgNull(const char *where, const TObject *obj) const;; 188 virtual Bool_t IsEmpty() const { return GetSize() <= 0; }; 189 Bool_t IsFolder() const override { return kTRUE; }; 190 Bool_t IsOwner() const { return TestBit(kIsOwner); }; 191 Bool_t IsSortable() const override { return kTRUE; }; 192 void ls(Option_t *option="""") const override;; 193 Bool_t Notify() override;; 194 virtual TIterator *MakeIterator(Bool_t dir = kIterForward) const = 0;; 195 virtual TIterator *MakeReverseIterator() const { return MakeIterator(kIterBackward); }; 196 void Paint(Option_t *option="""") override;; 197 void Print(Option_t *option="""") const override;; 198 virtual void Print(Option_t *option, Int_t rec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCollection_8h_source.html:6672,allocate,allocated,6672,doc/master/TCollection_8h_source.html,https://root.cern,https://root.cern/doc/master/TCollection_8h_source.html,1,['allocate'],['allocated']
Energy Efficiency,"TCutG::TCutG ; (; const TCutG & ; cutg). TCutG copy constructor. ; Definition at line 108 of file TCutG.cxx. ◆ TCutG() [3/5]. TCutG::TCutG ; (; const char * ; name, . Int_t ; n = 0 . ). TCutG normal constructor. ; Definition at line 120 of file TCutG.cxx. ◆ TCutG() [4/5]. TCutG::TCutG ; (; const char * ; name, . Int_t ; n, . const Float_t * ; x, . const Float_t * ; y . ). TCutG normal constructor. ; Definition at line 161 of file TCutG.cxx. ◆ TCutG() [5/5]. TCutG::TCutG ; (; const char * ; name, . Int_t ; n, . const Double_t * ; x, . const Double_t * ; y . ). TCutG normal constructor. ; Definition at line 202 of file TCutG.cxx. ◆ ~TCutG(). TCutG::~TCutG ; (; ). override . TCutG destructor. ; Definition at line 243 of file TCutG.cxx. Member Function Documentation. ◆ Area(). Double_t TCutG::Area ; (; ); const. virtual . Compute the area inside this TCutG The algorithm uses Stoke's theorem over the border of the closed polygon. ; Just as a reminder: Stoke's theorem reduces a surface integral to a line integral over the border of the surface integral. ; Definition at line 272 of file TCutG.cxx. ◆ Center(). void TCutG::Center ; (; Double_t & ; cx, . Double_t & ; cy . ); const. virtual . Compute the center x,y of this TCutG The algorithm uses Stoke's theorem over the border of the closed polygon. ; Just as a reminder: Stoke's theorem reduces a surface integral to a line integral over the border of the surface integral. ; Definition at line 289 of file TCutG.cxx. ◆ Class(). static TClass * TCutG::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TCutG::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TCutG::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 50 of file TCutG.h. ◆ DeclFileName(). static const char * TCutG::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at lin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTCutG.html:36736,reduce,reduces,36736,doc/master/classTCutG.html,https://root.cern,https://root.cern/doc/master/classTCutG.html,1,['reduce'],['reduces']
Energy Efficiency,"TEvePointSet::fIntIdsOptional array of integer ideices.; Int_tTEvePointSet::fIntIdsPerPointNumber of integer indices assigned to each point.; TEveElement::sLTI_tTEveElement::fItems! Set of list-tree-items.; Int_tTPolyMarker3D::fLastPointThe index of the last filled point; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Color_t*TEveElement::fMainColorPtrPointer to main-color variable.; TEveTrans*TEveElement::fMainTransPointer to main transformation matrix.; Char_tTEveElement::fMainTransparencyMain-transparency variable.; Color_tTAttMarker::fMarkerColorMarker color index; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; Int_tTPolyMarker3D::fNNumber of allocated points; TStringTPolyMarker3D::fNameName of polymarker; Int_tTEveElement::fNumChildren!; TStringTPolyMarker3D::fOptionOptions; Bool_tTPointSet3D::fOwnIdsFlag specifying id-objects are owned by the point-set; Float_t*TPolyMarker3D::fP[3*fN] Array of X,Y,Z coordinates; Int_tTEveElement::fParentIgnoreCnt! Counter for parents that are ignored in ref-counting.; TEveElement::List_tTEveElement::fParentsList of parents.; Bool_tTEveElement::fPickable; TEveProjectable::ProjList_tTEveProjectable::fProjectedListreferences to projected instances.; Bool_tTEveElement::fRnrChildrenRender children of this element.; Bool_tfRnrLine; Bool_tfRnrPoints; Bool_tTEveElement::fRnrSelfRender this element.; Bool_tTEveElement::fSelected!; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Bool_tfSmooth; TRefTEveElement::fSourceExternal object that is represented by this element.; TEvePointSelectorConsumer::ETreeVarType_eTEvePointSelectorConsumer::fSourceCSCoordinate-System of the source tree variables; TStringTEvePointSet::fTitleTitle/tooltip of the TEvePointSet.; Int_tTEveElement",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEveLine.html:27019,allocate,allocated,27019,root/html602/TEveLine.html,https://root.cern,https://root.cern/root/html602/TEveLine.html,2,['allocate'],['allocated']
Energy Efficiency,"TF1 * f1Definition legend1.C:11; c2return c2Definition legend2.C:14; TMath::NintInt_t Nint(T x)Round to nearest integer. Rounds half integers to the nearest even integer.Definition TMath.h:693; TMath::MaxShort_t Max(Short_t a, Short_t b)Returns the largest of a and b.Definition TMathBase.h:250; TMath::ProbDouble_t Prob(Double_t chi2, Int_t ndf)Computation of the probability for a certain Chi-squared (chi2) and number of degrees of freedom (ndf...Definition TMath.cxx:637; TMath::ATanDouble_t ATan(Double_t)Returns the principal value of the arc tangent of x, expressed in radians.Definition TMath.h:640; TMath::PiOver2constexpr Double_t PiOver2()Definition TMath.h:51; TMath::LogDouble_t Log(Double_t x)Returns the natural logarithm of x.Definition TMath.h:756; TMath::DegToRadconstexpr Double_t DegToRad()Conversion from degree to radian: .Definition TMath.h:79; TMath::SqrtDouble_t Sqrt(Double_t x)Returns the square root of x.Definition TMath.h:662; TMath::PowerLongDouble_t Power(LongDouble_t x, LongDouble_t y)Returns x raised to the power y.Definition TMath.h:721; TMath::MinShort_t Min(Short_t a, Short_t b)Returns the smallest of a and b.Definition TMathBase.h:198; TMath::CosDouble_t Cos(Double_t)Returns the cosine of an angle of x radians.Definition TMath.h:594; TMath::Piconstexpr Double_t Pi()Definition TMath.h:37; TMath::AreEqualRelBool_t AreEqualRel(Double_t af, Double_t bf, Double_t relPrec)Comparing floating points.Definition TMath.h:426; TMath::SinDouble_t Sin(Double_t)Returns the sine of an angle of x radians.Definition TMath.h:588; TMath::TanDouble_t Tan(Double_t)Returns the tangent of an angle of x radians.Definition TMath.h:600; TMath::BinarySearchLong64_t BinarySearch(Long64_t n, const T *array, T value)Binary search in an array of n values to locate value.Definition TMathBase.h:347; TMath::RadToDegconstexpr Double_t RadToDeg()Conversion from radian to degree: .Definition TMath.h:72; TMath::Log10Double_t Log10(Double_t x)Returns the common (base-10) logarithm o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THistPainter_8cxx_source.html:495390,power,power,495390,doc/master/THistPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html,1,['power'],['power']
Energy Efficiency,"TFile(file.Data());; TH1F *back = (TH1F*) f->Get(""back1"");; back->SetTitle(""Estimation of background with decreasing window"");; back->GetXaxis()->SetRange(1,nbins);; back->Draw(""L"");; ; TSpectrum *s = new TSpectrum();; ; for (i = 0; i < nbins; i++) source[i]=back->GetBinContent(i + 1);; ; // Estimate the background; s->Background(source,nbins,6,TSpectrum::kBackDecreasingWindow,; TSpectrum::kBackOrder2,kFALSE,; TSpectrum::kBackSmoothing3,kFALSE);; ; // Draw the estimated background; for (i = 0; i < nbins; i++) d->SetBinContent(i + 1,source[i]);; d->SetLineColor(kRed);; d->Draw(""SAME L"");; }; TSpectrum::kBackDecreasingWindow@ kBackDecreasingWindowDefinition TSpectrum.h:42; . Example 3 script Background_width.C:; The question is how to choose the width of the clipping window, i.e., numberIterations parameter. The influence of this parameter on the estimated background is illustrated in Example 3.; Example of the influence of clipping window width on the estimated background for numberIterations=4 (red line), 6 (orange line) 8 (green line) using decreasing clipping window algorithm.; in general one should set this parameter so that the value 2*numberIterations+1 was greater than the widths of preserved objects (peaks).; ; void Background_width() {; Int_t i;; const Int_t nbins = 1024;; Double_t xmin = 0;; Double_t xmax = nbins;; Double_t source[nbins];; gROOT->ForceStyle();; ; TString dir = gROOT->GetTutorialDir();; TString file = dir+""/spectrum/TSpectrum.root"";; TFile *f = new TFile(file.Data());; TH1F *back = (TH1F*) f->Get(""back1"");; TH1F *d1 = new TH1F(""d1"","""",nbins,xmin,xmax);; TH1F *d2 = new TH1F(""d2"","""",nbins,xmin,xmax);; TH1F *d3 = new TH1F(""d3"","""",nbins,xmin,xmax);; ; back->GetXaxis()->SetRange(1,nbins);; back->SetTitle(""Influence of clipping window width on the estimated background"");; back->Draw(""L"");; ; TSpectrum *s = new TSpectrum();; ; for (i = 0; i < nbins; i++) source[i]=back->GetBinContent(i + 1);; s->Background(source,nbins,4,TSpectrum::kBackDecreasingWi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSpectrum.html:26259,green,green,26259,doc/master/classTSpectrum.html,https://root.cern,https://root.cern/doc/master/classTSpectrum.html,1,['green'],['green']
Energy Efficiency,"TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGSpeedo(const TGWindow* p = 0, int id = -1); TGSpeedo widget constructor. TGSpeedo(const TGWindow* p, Float_t smin, Float_t smax, const char* lbl1 = """", const char* lbl2 = """", const char* dsp1 = """", const char* dsp2 = """", int id = -1); TGSpeedo widget constructor. void Build(); Build TGSpeedo widget. ~TGSpeedo(); TGSpeedo widget Destructor. TGDimension GetDefaultSize() const; Return default dimension of the widget. void Glow(TGSpeedo::EGlowColor col = kGreen); Make speedo glowing. Bool_t HandleButton(Event_t* event); Handle mouse button event. void SetOdoValue(Int_t val); Set actual value of odo meter. void SetDisplayText(const char* text1, const char* text2 = """"); Set small display text (two lines). void SetLabelText(const char* text1, const char* text2 = """"); Set main label text (two lines). void SetMinMaxScale(Float_t min, Float_t max); Set min and max scale values. void SetScaleValue(Float_t val); Set actual scale (needle position) value. void SetScaleValue(Float_t val, Int_t damping); Set actual scale (needle position) value. void StepScale(Float_t step); Increment/decrement scale (needle position) of ""step"" value. void Translate(Float_t val, Float_t angle, Int_t* x, Int_t* y); Translate distance from center and angle to xy coordinates. void DrawNeedle(); Draw needle in speedo widget. void DrawText(); Draw text in speedo widget. void DoRedraw(); Redraw speedo widget. TGSpeedo(const TGWindow* p = 0, int id = -1). const TGPicture * GetPicture() const; { return fBase; }. TImage * GetImage() const; { return fImage; }. Float_t GetPeakVal() const; { retu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGSpeedo.html:21693,meter,meter,21693,root/html602/TGSpeedo.html,https://root.cern,https://root.cern/root/html602/TGSpeedo.html,2,['meter'],['meter']
Energy Efficiency,"TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. private:. TGTextButton*fAddNewIsoBtnButton to add new iso.; TGNumberEntry*fAlpha; TGTextButton*fApplyAlpha; TGTextButton*fApplyPlanes; TGTextButton*fCancelGridBtn""Cancel"" button.; TGL5DDataSet*fDataSetData adapter for TTree.; TGL5DDataSetEditor::TGL5DEditorPrivate*fHidden; TGCheckButton*fHighlightCheckHighlight selected surface.; TGListBox*fIsoListList box to select surface.; TGCheckButton*fLogScale; TGNumberEntry*fNCellsXEntryNumber of cells along X.; TGNumberEntry*fNCellsYEntryNumber of cells along Y.; TGNumberEntry*fNCellsZEntryNumber of cells along Z.; TGNumberEntry*fNewIsoEntrySet the iso-level for new surface.; TGNumberEntry*fNumberOfPlanes; TGTextButton*fOkGridBtn""Apply"" button.; TGL5DPainter*fPainterPainter.; Int_tfSelectedSurface; TGCheckButton*fShowBoxCut; TGCheckButton*fShowCloudShow/hide points for surface.; TGDoubleHSlider*fSlideRange; TGHSlider*fSurfAlphaSliderSlider to control transparency.; TGColorSelect*fSurfColorSelectOpen color dialog.; TGTextButton*fSurfRemoveBtnRemove selected surface.; TGNumberEntryField*fV4MaxEntryRead only widget.; TGNumberEntryField*fV4MinEntryRead only widget.; TGCheckButton*fVisibleCheckShow/hide surface.; TGDoubleHSlider*fXRangeSliderSlid",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGL5DDataSetEditor.html:21676,adapt,adapter,21676,root/html602/TGL5DDataSetEditor.html,https://root.cern,https://root.cern/root/html602/TGL5DDataSetEditor.html,2,['adapt'],['adapter']
Energy Efficiency,"TGaxis ; (; const TGaxis & ; ax). protected . Copy constructor. ; Definition at line 796 of file TGaxis.cxx. ◆ TGaxis() [2/4]. TGaxis::TGaxis ; (; ). TGaxis default constructor. ; Definition at line 694 of file TGaxis.cxx. ◆ TGaxis() [3/4]. TGaxis::TGaxis ; (; Double_t ; xmin, . Double_t ; ymin, . Double_t ; xmax, . Double_t ; ymax, . Double_t ; wmin, . Double_t ; wmax, . Int_t ; ndiv = 510, . Option_t * ; chopt = """", . Double_t ; gridlength = 0 . ). TGaxis normal constructor. ; Definition at line 722 of file TGaxis.cxx. ◆ TGaxis() [4/4]. TGaxis::TGaxis ; (; Double_t ; xmin, . Double_t ; ymin, . Double_t ; xmax, . Double_t ; ymax, . const char * ; funcname, . Int_t ; ndiv = 510, . Option_t * ; chopt = """", . Double_t ; gridlength = 0 . ). Constructor with a TF1 to map axis values. ; NoteThe function func (with name funcname) is not defined in the user's coordinate space, but in the new TGaxis space. If x is the original axis, w the new axis, and w = f(x) (for example, f is a calibration function converting ADC channels x to energy w), then func must be supplied as f^{-1}(w). ; Definition at line 759 of file TGaxis.cxx. ◆ ~TGaxis(). TGaxis::~TGaxis ; (; ). override . TGaxis default destructor. ; Definition at line 861 of file TGaxis.cxx. Member Function Documentation. ◆ AdjustBinSize(). void TGaxis::AdjustBinSize ; (; Double_t ; A1, . Double_t ; A2, . Int_t ; nold, . Double_t & ; binLow, . Double_t & ; binHigh, . Int_t & ; nbins, . Double_t & ; binWidth . ). virtual . Internal method for axis labels optimisation. ; This method adjusts the bining of the axis in order to have integer values for the labels.; Parameters. [in]A1,A2Old WMIN,WMAX ; [out]binLow,binHighNew WMIN,WMAX ; [in]noldOld NDIV (primary divisions) ; [out]nbinsNew NDIV ; [out]binWidthBin width . Definition at line 2498 of file TGaxis.cxx. ◆ CenterLabels(). void TGaxis::CenterLabels ; (; Bool_t ; center = kTRUE). virtual . If center = kTRUE axis labels are centered in the center of the bin. ; The default i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGaxis.html:60302,energy,energy,60302,doc/master/classTGaxis.html,https://root.cern,https://root.cern/doc/master/classTGaxis.html,1,['energy'],['energy']
Energy Efficiency,"TGenCollectionProxy::kBIT_ISSTRING; static TGenCollectionProxy::(anonymous)TGenCollectionProxy::kBIT_ISTSTRING; static TGenCollectionProxy::(anonymous)TGenCollectionProxy::kBOOL_t; static TVirtualCollectionProxy::EPropertyTVirtualCollectionProxy::kIsAssociative; static TVirtualCollectionProxy::EPropertyTVirtualCollectionProxy::kIsEmulated; static TVirtualCollectionProxy::EPropertyTVirtualCollectionProxy::kNeedDelete. protected:. TClassRefTVirtualCollectionProxy::fClass; TGenCollectionProxy::MethodTGenCollectionProxy::fClearMethod cache for container accessors: clear container; TGenCollectionProxy::Collectfunc_tTGenCollectionProxy::fCollectMethod to collect objects from container; TGenCollectionProxy::ArrIterfunc_tTGenCollectionProxy::fConstructContainer accessors: block construct; map<string,TObjArray*>*TGenCollectionProxy::fConversionReadMemberWiseArray of bundle of TStreamerInfoActions to stream out (read) derived from another class.; TGenCollectionProxy::Method0TGenCollectionProxy::fCreateEnvMethod to allocate an Environment holder.; TGenCollectionProxy::Sizing_tTGenCollectionProxy::fDestructContainer accessors: block destruct; TGenCollectionProxy::EnvironBase_t*TGenCollectionProxy::fEnvAddress of the currently proxied object; TGenCollectionProxy::Feedfunc_tTGenCollectionProxy::fFeedContainer accessors: block feed; TGenCollectionProxy::MethodTGenCollectionProxy::fFirstContainer accessors: generic iteration: first; TVirtualCollectionProxy::CopyIterator_tTGenCollectionProxy::fFunctionCopyIterator; TVirtualCollectionProxy::CreateIterators_tTGenCollectionProxy::fFunctionCreateIterators; TVirtualCollectionProxy::DeleteIterator_tTGenCollectionProxy::fFunctionDeleteIterator; TVirtualCollectionProxy::DeleteTwoIterators_tTGenCollectionProxy::fFunctionDeleteTwoIterators; TVirtualCollectionProxy::Next_tTGenCollectionProxy::fFunctionNextIterator; TGenCollectionProxy::Value*TGenCollectionProxy::fKeyDescriptor of the key_type; stringTGenCollectionProxy::fNameName of the class ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEmulatedCollectionProxy.html:5349,allocate,allocate,5349,root/html602/TEmulatedCollectionProxy.html,https://root.cern,https://root.cern/root/html602/TEmulatedCollectionProxy.html,4,['allocate'],['allocate']
Energy Efficiency,"TGeoTranslation(0.2,0,0));; TGeoTranslationClass describing translations.Definition TGeoMatrix.h:116; The 2 nodes that we have created inside chamber will both point to a wire_co object, but will be completely distinct: WIRE_CO_1 and WIRE_CO_2. We will want now to place symmetrically 1000 chambers on a pad, following a pattern of 20 rows and 50 columns. One way to do this will be to replicate our chamber by positioning it 1000 times in different positions of the pad. Unfortunately, this is far from being the optimal way of doing what we want. Imagine that we would like to find out which of the 1000 chambers is containing a (x,y,z) point defined in the pad reference. You will never have to do that, since the modeller will take care of it for you, but let's guess what it has to do. The most simple algorithm will just loop over all daughters, convert the point from mother to local reference and check if the current chamber contains the point or not. This might be efficient for pads with few chambers, but definitely not for 1000. Fortunately the modeller is smarter than that and creates for each volume some optimization structures called voxels to minimize the penalty having too many daughters, but if you have 100 pads like this in your geometry you will anyway lose a lot in your tracking performance. The way out when volumes can be arranged according to simple patterns is the usage of divisions. We will describe them in detail later on. Let's think now at a different situation: instead of 1000 chambers of the same type, we may have several types of chambers. Let's say all chambers are cylindrical and have a wire inside, but their dimensions are different. However, we would like all to be represented by a single volume family, since they have the same properties.; Volume Families; A volume family is represented by the class TGeoVolumeMulti. It represents a class of volumes having the same shape type and each member will be identified by the same name and volume ID. Any o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:42041,efficient,efficient,42041,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['efficient'],['efficient']
Energy Efficiency,"TMVA::DNN::ClassificationSettings::startTestCycle ; (; ). virtual . action to be done when the test cycle is started (e.g. ; update some monitoring output) ; Reimplemented from TMVA::DNN::Settings.; Definition at line 316 of file NeuralNet.cxx. ◆ startTrainCycle(). void TMVA::DNN::ClassificationSettings::startTrainCycle ; (; ). virtual . action to be done when the training cycle is started (e.g. ; update some monitoring output) ; Reimplemented from TMVA::DNN::Settings.; Definition at line 281 of file NeuralNet.cxx. ◆ testIteration(). void TMVA::DNN::ClassificationSettings::testIteration ; (; ). inlinevirtual . callback for monitoring and loggging ; Reimplemented from TMVA::DNN::Settings.; Definition at line 930 of file NeuralNet.h. ◆ testSample(). void TMVA::DNN::ClassificationSettings::testSample ; (; double ; error, . double ; output, . double ; target, . double ; weight . ). virtual . action to be done after the computation of a test sample (e.g. ; update some monitoring output) ; Reimplemented from TMVA::DNN::Settings.; Definition at line 304 of file NeuralNet.cxx. Member Data Documentation. ◆ m_ams. std::vector<double> TMVA::DNN::ClassificationSettings::m_ams. Definition at line 1000 of file NeuralNet.h. ◆ m_cutValue. double TMVA::DNN::ClassificationSettings::m_cutValue. Definition at line 1008 of file NeuralNet.h. ◆ m_fileNameNetConfig. std::string TMVA::DNN::ClassificationSettings::m_fileNameNetConfig. Definition at line 1011 of file NeuralNet.h. ◆ m_fileNameResult. std::string TMVA::DNN::ClassificationSettings::m_fileNameResult. Definition at line 1010 of file NeuralNet.h. ◆ m_input. std::vector<double> TMVA::DNN::ClassificationSettings::m_input. Definition at line 995 of file NeuralNet.h. ◆ m_output. std::vector<double> TMVA::DNN::ClassificationSettings::m_output. Definition at line 996 of file NeuralNet.h. ◆ m_pResultPatternContainer. std::vector<Pattern>* TMVA::DNN::ClassificationSettings::m_pResultPatternContainer. Definition at line 1009 of file NeuralNe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1ClassificationSettings.html:9416,monitor,monitoring,9416,doc/master/classTMVA_1_1DNN_1_1ClassificationSettings.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1ClassificationSettings.html,1,['monitor'],['monitoring']
Energy Efficiency,"TMVA::DNN::Settings::startTrainCyclevirtual void startTrainCycle()Definition NeuralNet.h:782; TMVA::DNN::Settings::convergenceStepssize_t convergenceSteps() consthow many steps until training is deemed to have convergedDefinition NeuralNet.h:766; TMVA::DNN::Settings::m_factorWeightDecaydouble m_factorWeightDecayDefinition NeuralNet.h:840; TMVA::DNN::Settings::factorWeightDecaydouble factorWeightDecay() constget the weight-decay factorDefinition NeuralNet.h:769; TMVA::DNN::Settings::count_mb_dEsize_t count_mb_dEDefinition NeuralNet.h:845; TMVA::DNN::Settings::m_useMultithreadingbool m_useMultithreadingDefinition NeuralNet.h:863; TMVA::DNN::Settings::count_mb_Esize_t count_mb_EDefinition NeuralNet.h:844; TMVA::DNN::Settings::existsbool exists(std::string histoName)for monitoringDefinition NeuralNet.h:825; TMVA::DNN::Settings::maxConvergenceCountsize_t maxConvergenceCount() constreturns the max convergence count so farDefinition NeuralNet.h:828; TMVA::DNN::Settings::padsvoid pads(int numPads)preparation for monitoringDefinition NeuralNet.h:818; TMVA::DNN::Settings::m_testRepetitionssize_t m_testRepetitionsDefinition NeuralNet.h:839; TMVA::DNN::Settings::fLearningRatedouble fLearningRateDefinition NeuralNet.h:852; TMVA::DNN::Settings::fMomentumdouble fMomentumDefinition NeuralNet.h:853; TMVA::DNN::Settings::batchSizesize_t batchSize() constmini-batch sizeDefinition NeuralNet.h:767; TMVA::DNN::Settings::computeResultvirtual void computeResult(const Net &, std::vector< double > &)callback for monitoring and loggingDefinition NeuralNet.h:809; TMVA::DNN::Settings::fMonitoringstd::shared_ptr< Monitoring > fMonitoringDefinition NeuralNet.h:865; TMVA::DNN::Settings::dropRepetitionssize_t dropRepetitions() constDefinition NeuralNet.h:761; TMVA::DNN::Settings::createvoid create(std::string histoName, int bins, double min, double max)for monitoringDefinition NeuralNet.h:819; TMVA::DNN::Settings::fRepetitionsint fRepetitionsDefinition NeuralNet.h:854; TMVA::DNN::Settings::minErrors",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/NeuralNet_8h_source.html:76823,monitor,monitoringDefinition,76823,doc/master/NeuralNet_8h_source.html,https://root.cern,https://root.cern/doc/master/NeuralNet_8h_source.html,1,['monitor'],['monitoringDefinition']
Energy Efficiency,"TMVA::MethodBase::fBackgroundClassindex of the Background-class; vector<TString>*TMVA::MethodBase::fInputVarsvector of input variables used in MVA; vector<Float_t>*TMVA::MethodBase::fMulticlassReturnValholds the return-values for the multiclass classification; Int_tTMVA::MethodBase::fNbinsnumber of bins in input variable histograms; Int_tTMVA::MethodBase::fNbinsHnumber of bins in evaluation histograms; Int_tTMVA::MethodBase::fNbinsMVAoutputnumber of bins in MVA output histograms; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class. private:. TMatrixD*fBetwbetween-class matrix; TMatrixD*fCovfull covariance matrix; vector<Double_t>*fDiscrimPowdiscriminating power; Double_tfF0offset; vector<Double_t>*fFisherCoeffFisher coefficients; TMVA::MethodFisher::EFisherMethodfFisherMethodFisher or Mahalanobis ; TMatrixD*fMeanMatx; Double_tfSumOfWeightsBsum-of-weights for background training events; Double_tfSumOfWeightsSsum-of-weights for signal training events; TStringfTheMethodFisher or Mahalanobis; TMatrixD*fWithwithin-class matrix. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodFisher(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& dsi, const TString& theOption = ""Fisher"", TDirectory* theTargetDir = 0); standard constructor for the ""Fisher"". MethodFisher(TMVA::DataSetInfo& dsi, const TString& theWeightFile, TDirectory* theTargetDir = NULL); constructor from weight file. void Init( void ); default initialization called by all constructors. void DeclareOptions(). MethodFisher options:; format and syntax of option string: ""type""; where type is ""Fisher"" or ""Mahalanobis"". void ProcessOptions(); process user options. ~MethodFisher( void ); destructor. Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__MethodFisher.html:18573,power,power,18573,root/html530/TMVA__MethodFisher.html,https://root.cern,https://root.cern/root/html530/TMVA__MethodFisher.html,3,['power'],['power']
Energy Efficiency,"TMVA::MethodBase::fBackgroundClassindex of the Background-class; vector<TString>*TMVA::MethodBase::fInputVarsvector of input variables used in MVA; vector<Float_t>*TMVA::MethodBase::fMulticlassReturnValholds the return-values for the multiclass classification; Int_tTMVA::MethodBase::fNbinsnumber of bins in input variable histograms; Int_tTMVA::MethodBase::fNbinsHnumber of bins in evaluation histograms; Int_tTMVA::MethodBase::fNbinsMVAoutputnumber of bins in MVA output histograms; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class. private:. TMatrixD*fBetwbetween-class matrix; TMatrixD*fCovfull covariance matrix; vector<Double_t>*fDiscrimPowdiscriminating power; Double_tfF0offset; vector<Double_t>*fFisherCoeffFisher coefficients; TMVA::MethodFisher::EFisherMethodfFisherMethodFisher or Mahalanobis; TMatrixD*fMeanMatx; Double_tfSumOfWeightsBsum-of-weights for background training events; Double_tfSumOfWeightsSsum-of-weights for signal training events; TStringfTheMethodFisher or Mahalanobis; TMatrixD*fWithwithin-class matrix. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodFisher(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& dsi, const TString& theOption = ""Fisher"", TDirectory* theTargetDir = 0); standard constructor for the ""Fisher"". MethodFisher(TMVA::DataSetInfo& dsi, const TString& theWeightFile, TDirectory* theTargetDir = __null); constructor from weight file. void Init( void ); default initialization called by all constructors. void DeclareOptions(). MethodFisher options:; format and syntax of option string: ""type""; where type is ""Fisher"" or ""Mahalanobis"". void ProcessOptions(); process user options. ~MethodFisher( void ); destructor. Bool_t HasAnalysisType(TMVA::Types::EAnalysisType typ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__MethodFisher.html:19871,power,power,19871,root/html602/TMVA__MethodFisher.html,https://root.cern,https://root.cern/root/html602/TMVA__MethodFisher.html,2,['power'],['power']
Energy Efficiency,"TMVA::VariableTransformBase::Targets ; (; ). inlineprotected . Definition at line 134 of file VariableTransformBase.h. ◆ Targets() [2/2]. const std::vector< TMVA::VariableInfo > & TMVA::VariableTransformBase::Targets ; (; ); const. inline . Definition at line 111 of file VariableTransformBase.h. ◆ ToggleInputSortOrder(). void TMVA::VariableTransformBase::ToggleInputSortOrder ; (; Bool_t ; sortOrder). inline . Definition at line 83 of file VariableTransformBase.h. ◆ Transform(). virtual const Event * TMVA::VariableTransformBase::Transform ; (; const Event * const ; , . Int_t ; cls . ); const. pure virtual . Implemented in TMVA::VariableDecorrTransform, TMVA::VariableGaussTransform, TMVA::VariableIdentityTransform, TMVA::VariableNormalizeTransform, TMVA::VariablePCATransform, and TMVA::VariableRearrangeTransform. ◆ UpdateNorm(). void TMVA::VariableTransformBase::UpdateNorm ; (; Int_t ; ivar, . Double_t ; x . ). private . TODO --> adapt to variable,target,spectator selection update min and max of a given variable (target) and a given transformation method. ; Definition at line 605 of file VariableTransformBase.cxx. ◆ UseSignalTransform(). Bool_t TMVA::VariableTransformBase::UseSignalTransform ; (; ); const. inline . Definition at line 89 of file VariableTransformBase.h. ◆ Variables() [1/2]. std::vector< TMVA::VariableInfo > & TMVA::VariableTransformBase::Variables ; (; ). inlineprotected . Definition at line 133 of file VariableTransformBase.h. ◆ Variables() [2/2]. const std::vector< TMVA::VariableInfo > & TMVA::VariableTransformBase::Variables ; (; ); const. inline . Definition at line 110 of file VariableTransformBase.h. ◆ WriteTransformationToStream(). virtual void TMVA::VariableTransformBase::WriteTransformationToStream ; (; std::ostream & ; o); const. pure virtual . Implemented in TMVA::VariableDecorrTransform, TMVA::VariableGaussTransform, TMVA::VariableIdentityTransform, TMVA::VariableNormalizeTransform, TMVA::VariablePCATransform, and TMVA::VariableRearrangeTran",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1VariableTransformBase.html:27650,adapt,adapt,27650,doc/master/classTMVA_1_1VariableTransformBase.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1VariableTransformBase.html,1,['adapt'],['adapt']
Energy Efficiency,"TMVA::Volume* volume). Double_t CRScalc(const TMVA::Event& ). void RRScalc(const TMVA::Event& , vector<Float_t>* count). Double_t CKernelEstimate(const TMVA::Event& , vector<const TMVA::BinarySearchTreeNode*>& , TMVA::Volume& ); normalization factors so we can work with radius 1 hyperspheres. void RKernelEstimate(const TMVA::Event& , vector<const TMVA::BinarySearchTreeNode*>& , TMVA::Volume& , vector<Float_t>* pdfSum); normalization factors so we can work with radius 1 hyperspheres. Double_t ApplyKernelFunction(Double_t normalized_distance); from the normalized euclidean distance calculate the distance; for a certain kernel. Double_t KernelNormalization(Double_t pdf); Calculating the normalization factor only once (might need a reset at some point.; Can the method be restarted with different params?). Double_t GetNormalizedDistance(const TMVA::Event& base_event, const TMVA::BinarySearchTreeNode& sample_event, Double_t* dim_normalization); We use Euclidian metric here. Might not be best or most efficient. Double_t NormSinc(Double_t x); NormSinc. Double_t LanczosFilter(Int_t level, Double_t x); Lanczos Filter. Float_t GetError(Float_t countS, Float_t countB, Float_t sumW2S, Float_t sumW2B) const; statistical error estimate for RS estimator. void AddWeightsXMLTo(void* parent) const; write weights to xml file. void ReadWeightsFromXML(void* wghtnode). void ReadWeightsFromStream(istream& istr); read weight info from file. void WriteWeightsToStream(TFile& rf) const; write training sample (TTree) to file. void ReadWeightsFromStream(TFile& istr); read training sample from file. TMVA::MethodPDERS* ThisPDERS( void ); static pointer to this object. void UpdateThis( void ); update static this pointer. void MakeClassSpecific(ostream& , const TString& ) const; write specific classifier response. void GetHelpMessage() const; get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". MethodPDERS(const TString& jobName, con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__MethodPDERS.html:25807,efficient,efficient,25807,root/html602/TMVA__MethodPDERS.html,https://root.cern,https://root.cern/root/html602/TMVA__MethodPDERS.html,2,['efficient'],['efficient']
Energy Efficiency,"TMatrixT< Element > & operator/=(const TMatrixTDiag_const< Element > &diag)Divide a matrix row by the diagonal of another matrix matrix(i,j) /= diag(j)Definition TMatrixT.cxx:2109; TObject::operator=TObject & operator=(const TObject &rhs)TObject assignment operator.Definition TObject.h:296; TObject::Streamervirtual void Streamer(TBuffer &)Stream an object of class TObject.Definition TObject.cxx:894; TStringBasic string class.Definition TString.h:139; TString::ToUppervoid ToUpper()Change string to upper case.Definition TString.cxx:1195; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; TVectorTTVectorT.Definition TVectorT.h:27; TVectorT::ResizeToTVectorT< Element > & ResizeTo(Int_t lwb, Int_t upb)Resize the vector to [lwb:upb] .Definition TVectorT.cxx:294; bool; double; int; unsigned int; TMath::MaxShort_t Max(Short_t a, Short_t b)Returns the largest of a and b.Definition TMathBase.h:250; TMath::PowerLongDouble_t Power(LongDouble_t x, LongDouble_t y)Returns x raised to the power y.Definition TMath.h:721; TMath::MinShort_t Min(Short_t a, Short_t b)Returns the smallest of a and b.Definition TMathBase.h:198; TMatrixTAutoloadOps::operator!=TMatrixT< Element > operator!=(const TMatrixT< Element > &source1, const TMatrixT< Element > &source2)logical operation source1 != source2Definition TMatrixT.cxx:2842; TMatrixTAutoloadOps::AMultBtvoid AMultBt(const Element *const ap, Int_t na, Int_t ncolsa, const Element *const bp, Int_t nb, Int_t ncolsb, Element *cp)Elementary routine to calculate matrix multiplication A*B^T.Definition TMatrixT.cxx:3128; TMatrixTAutoloadOps::AMultBvoid AMultB(const Element *const ap, Int_t na, Int_t ncolsa, const Element *const bp, Int_t nb, Int_t ncolsb, Element *cp)Elementary routine to calculate matrix multiplication A*B.Definition TMatrixT.cxx:3081; TMatrixTAutoloadOps::operator+TMatrixT< Element > operator+(const TMatrixT< Element > &source1, const TMatrixT< Element > &source2)operation this ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMatrixT_8cxx_source.html:138333,power,power,138333,doc/master/TMatrixT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TMatrixT_8cxx_source.html,1,['power'],['power']
Energy Efficiency,"TMatrixT<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> GetMatrix2Array(float* data, Option_t* = """") const; Copy matrix data to array . It is assumed that array is of size >= fNelems. TMatrixTBase<Element> &TMatrixTSparse<Element> SetMatrixArray(Int_t nr_nonzeros, Int_t* irow, Int_t* icol, float* data); Copy nr elements from row/col index and data array to matrix . It is assumed; that arrays are of size >= nr. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndex(Int_t nelem_new); Increase/decrease the number of non-zero elements to nelems_new. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndex(const TMatrixTBase<float>& another); Use non-zero data of matrix source to set the sparse structure. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndexAB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b); Set the row/column indices to the ""sum"" of matrices a and b; It is checked that enough space has been allocated. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndexAB(const TMatrixT<Element> &a,const TMatrixTSparse<Element> &b); Set the row/column indices to the ""sum"" of matrices a and b; It is checked that enough space has been allocated. TMatrixTBase<Element> &TMatrixTSparse<Element> ResizeTo(Int_t nrows, Int_t ncols, Int_t nr_nonzeros = -1); Set size of the matrix to nrows x ncols with nr_nonzeros non-zero entries; if nr_nonzeros > 0 .; New dynamic elements are created, the overlapping part of the old ones are; copied to the new structures, then the old elements are deleted. TMatrixTBase<Element> &TMatrixTSparse<Element> ResizeTo(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Int_t nr_nonzeros = -1); Set size of the matrix to [row_lwb:row_upb] x [col_lwb:col_upb] with nr_nonzeros; non-zero entries if nr_nonzeros > 0 .; New dynamic elemenst are cre",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMatrixTSparse_float_.html:20061,allocate,allocated,20061,root/html528/TMatrixTSparse_float_.html,https://root.cern,https://root.cern/root/html528/TMatrixTSparse_float_.html,1,['allocate'],['allocated']
Energy Efficiency,"TMatrixTSparse ();  ;  TMatrixTSparse (const TMatrixT< Element > &a, EMatrixCreatorsOp2 op, const TMatrixTSparse< Element > &b);  Create a matrix applying a specific operation to two prototypes. ;  ;  TMatrixTSparse (const TMatrixT< Element > &another);  ;  TMatrixTSparse (const TMatrixTSparse< Element > &a, EMatrixCreatorsOp2 op, const TMatrixT< Element > &b);  Create a matrix applying a specific operation to two prototypes. ;  ;  TMatrixTSparse (const TMatrixTSparse< Element > &a, EMatrixCreatorsOp2 op, const TMatrixTSparse< Element > &b);  Create a matrix applying a specific operation to two prototypes. ;  ;  TMatrixTSparse (const TMatrixTSparse< Element > &another);  ;  TMatrixTSparse (EMatrixCreatorsOp1 op, const TMatrixTSparse< Element > &prototype);  Create a matrix applying a specific operation to the prototype. ;  ;  TMatrixTSparse (Int_t nrows, Int_t ncols);  Space is allocated for row/column indices and data, but the sparse structure information has still to be set ! ;  ;  TMatrixTSparse (Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Int_t *rowptr, Int_t *col, Element *data);  Space is allocated for row/column indices and data. ;  ;  TMatrixTSparse (Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Int_t nr_nonzeros, Int_t *row, Int_t *col, Element *data);  Space is allocated for row/column indices and data. ;  ;  TMatrixTSparse (Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Int_t nr_nonzeros=0);  Space is allocated for row/column indices and data, but the sparse structure information has still to be set ! ;  ;  ~TMatrixTSparse () override;  ; TClass * Class ();  ; void Clear (Option_t *="""") override;  ; Element ColNorm () const override;  Column matrix norm, MAX{ SUM{ |M(i,j)|, over i}, over j}. ;  ; void ExtractRow (Int_t row, Int_t col, Element *v, Int_t n=-1) const override;  Store in array v, n matrix elements of row rown starting at column coln. ;  ; const Int_t * GetColIndexArray () const override;  ; Int_t * Ge",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMatrixTSparse.html:6254,allocate,allocated,6254,doc/master/classTMatrixTSparse.html,https://root.cern,https://root.cern/doc/master/classTMatrixTSparse.html,2,['allocate'],['allocated']
Energy Efficiency,"TNamed::Copy(TObject& named) const; virtual Bool_tCurrentBoundaryNormal(Double_t& x, Double_t& y, Double_t& z) const; virtual Int_tCurrentEvent() const; virtual Int_tCurrentMaterial(Float_t& a, Float_t& z, Float_t& dens, Float_t& radl, Float_t& absl) const; virtual Int_tCurrentMedium() const; virtual Int_tCurrentVolID(Int_t& copyNo) const; virtual const char*CurrentVolName() const; virtual Int_tCurrentVolOffID(Int_t off, Int_t& copyNo) const; virtual const char*CurrentVolOffName(Int_t off) const; virtual const char*CurrentVolPath(); virtual Bool_tDefineIon(const char* name, Int_t Z, Int_t A, Int_t Q, Double_t excEnergy, Double_t mass = 0.); virtual voidDefineOpSurface(const char* name, EMCOpSurfaceModel model, EMCOpSurfaceType surfaceType, EMCOpSurfaceFinish surfaceFinish, Double_t sigmaAlpha); virtual Bool_tDefineParticle(Int_t pdg, const char* name, TMCParticleType mcType, Double_t mass, Double_t charge, Double_t lifetime); virtual Bool_tDefineParticle(Int_t pdg, const char* name, TMCParticleType mcType, Double_t mass, Double_t charge, Double_t lifetime, const TString& pType, Double_t width, Int_t iSpin, Int_t iParity, Int_t iConjugation, Int_t iIsospin, Int_t iIsospinZ, Int_t gParity, Int_t lepton, Int_t baryon, Bool_t stable, Bool_t shortlived = kFALSE, const TString& subType = """", Int_t antiEncoding = 0, Double_t magMoment = 0., Double_t excitation = 0.); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual Double_tEdep() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Double_tEtot() const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TVirtualMC.html:2372,charge,charge,2372,root/html602/TVirtualMC.html,https://root.cern,https://root.cern/root/html602/TVirtualMC.html,4,['charge'],['charge']
Energy Efficiency,"TNamed::Copy(TObject& named) const; virtual Bool_tCurrentBoundaryNormal(Double_t& x, Double_t& y, Double_t& z) const; virtual Int_tCurrentEvent() const; virtual Int_tCurrentMaterial(Float_t& a, Float_t& z, Float_t& dens, Float_t& radl, Float_t& absl) const; virtual Int_tCurrentMedium() const; virtual Int_tCurrentVolID(Int_t& copyNo) const; virtual const char*CurrentVolName() const; virtual Int_tCurrentVolOffID(Int_t off, Int_t& copyNo) const; virtual const char*CurrentVolOffName(Int_t off) const; virtual const char*CurrentVolPath(); virtual Bool_tDefineIon(const char* name, Int_t Z, Int_t A, Int_t Q, Double_t excEnergy, Double_t mass = 0.); virtual voidDefineOpSurface(const char* name, EMCOpSurfaceModel model, EMCOpSurfaceType surfaceType, EMCOpSurfaceFinish surfaceFinish, Double_t sigmaAlpha); virtual Bool_tDefineParticle(Int_t pdg, const char* name, TMCParticleType mcType, Double_t mass, Double_t charge, Double_t lifetime); virtual Bool_tDefineParticle(Int_t pdg, const char* name, TMCParticleType mcType, Double_t mass, Double_t charge, Double_t lifetime, const TString& pType, Double_t width, Int_t iSpin, Int_t iParity, Int_t iConjugation, Int_t iIsospin, Int_t iIsospinZ, Int_t gParity, Int_t lepton, Int_t baryon, Bool_t stable, Bool_t shortlived = kFALSE, const TString& subType = """", Int_t antiEncoding = 0, Double_t magMoment = 0.0, Double_t excitation = 0.0); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual Double_tEdep() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Double_tEtot() const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TVirtualMC.html:2348,charge,charge,2348,root/html530/TVirtualMC.html,https://root.cern,https://root.cern/root/html530/TVirtualMC.html,6,['charge'],['charge']
Energy Efficiency,"TObject(this,name,opt.Data(),bufsize);; 876 ; 877 const char *objname = name ? name : GetName();; 878 Error(""Write"",""The current directory (gDirectory) is null. The object (%s) has not been written."",objname);; 879 return 0;; 880}; 881 ; 882////////////////////////////////////////////////////////////////////////////////; 883/// Write this object to the current directory. For more see the; 884/// const version of this method.; 885 ; 886Int_t TObject::Write(const char *name, Int_t option, Int_t bufsize); 887{; 888 return ((const TObject*)this)->Write(name, option, bufsize);; 889}; 890 ; 891////////////////////////////////////////////////////////////////////////////////; 892/// Stream an object of class TObject.; 893 ; 894void TObject::Streamer(TBuffer &R__b); 895{; 896 if (IsA()->CanIgnoreTObjectStreamer()) return;; 897 UShort_t pidf;; 898 if (R__b.IsReading()) {; 899 R__b.SkipVersion(); // Version_t R__v = R__b.ReadVersion(); if (R__v) { }; 900 R__b >> fUniqueID;; 901 const UInt_t isonheap = fBits & kIsOnHeap; // Record how this instance was actually allocated.; 902 R__b >> fBits;; 903 fBits |= isonheap | kNotDeleted; // by definition de-serialized object are not yet deleted.; 904 if (TestBit(kIsReferenced)) {; 905 //if the object is referenced, we must read its old address; 906 //and store it in the ProcessID map in gROOT; 907 R__b >> pidf;; 908 pidf += R__b.GetPidOffset();; 909 TProcessID *pid = R__b.ReadProcessID(pidf);; 910 if (pid) {; 911 UInt_t gpid = pid->GetUniqueID();; 912 if (gpid>=0xff) {; 913 fUniqueID = fUniqueID | 0xff000000;; 914 } else {; 915 fUniqueID = ( fUniqueID & 0xffffff) + (gpid<<24);; 916 }; 917 pid->PutObjectWithID(this);; 918 }; 919 }; 920 } else {; 921 R__b.WriteVersion(TObject::IsA());; 922 // Can not read TFile.h here and avoid going through the interpreter by; 923 // simply hard-coding this value.; 924 // This **must** be equal to TFile::k630forwardCompatibility; 925 constexpr int TFile__k630forwardCompatibility = BIT(2);; 926 const auto",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TObject_8cxx_source.html:33285,allocate,allocated,33285,doc/master/TObject_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TObject_8cxx_source.html,1,['allocate'],['allocated']
Energy Efficiency,"TObject::SetObjectStat(Bool_t stat); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector&); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum EGridJobStatus { kUNKNOWN; kWAITING; kRUNNING; kABORTED; kFAIL; kDONE; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TGridJobStatus(); { }. EGridJobStatus GetStatus() const; These functions reduces the possible job states to the subset given above; in EGridJobStatus, for detailed status information query the specific; implementation. » Author: Jan Fiete Grosse-Oetringhaus 06/10/2004 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/net:$Id$ » Last generated: 2015-03-14 16:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGridJobStatus.html:5910,reduce,reduces,5910,root/html534/TGridJobStatus.html,https://root.cern,https://root.cern/root/html534/TGridJobStatus.html,1,['reduce'],['reduces']
Energy Efficiency,"TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TLorentzVector::(anonymous)kNUM_COORDINATES; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TLorentzVector::(anonymous)kSIZE; static TObject::(anonymous)TObject::kSingleKey; static TLorentzVector::(anonymous)kT; static TObject::(anonymous)TObject::kWriteDelete; static TLorentzVector::(anonymous)kX; static TLorentzVector::(anonymous)kY; static TLorentzVector::(anonymous)kZ; static TObject::(anonymous)TObject::kZombie. private:. Double_tfEtime or energy of (x,y,z,t) or (px,py,pz,e); TVector3fP3 vector component. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLorentzVector(); {}. TLorentzVector(Double_t x, Double_t y, Double_t z, Double_t t); {}. TLorentzVector(const Double_t* carray); {}. TLorentzVector(const Float_t* carray); {}. TLorentzVector(const TVector3& vector3, Double_t t); {}. TLorentzVector(const TLorentzVector& lorentzvector); {}. ~TLorentzVector(); {}. void Boost(Double_t , Double_t , Double_t ); Boost this Lorentz vector. Double_t Rapidity() const; return rapidity. TLorentzVector & Transform(const TLorentzRotation& ); Transform this Lorentzvector. void Streamer(TBuffer& ); Stream an object of class TLorentzVector. void Print(Option_t* option = """") const; Print the TLorentz vector components as (x,y,z,t) and (P,eta,phi,E) representations. Double_t X() const; { return fP.X(); }. Double_t Y() const; { return fP.Y(); }. Double_t Z() const; { return fP.Z(); }. Double_t T() const; { return fE; }. vo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TLorentzVector.html:15457,energy,energy,15457,root/html602/TLorentzVector.html,https://root.cern,https://root.cern/root/html602/TLorentzVector.html,2,['energy'],['energy']
Energy Efficiency,"TObjectTable. ;  ;  Static Public Member Functions inherited from RooPrintable; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static std::ostream & defaultPrintStream (std::ostream *os=nullptr);  Return a reference to the current default stream to use in Print(). ;  ; static void nameFieldLength (Int_t newLen);  Set length of field reserved from printing name of RooAbsArgs in multi-line collection printing to given amount. ;  . Protected Member Functions; bool canComputeBatchWithCuda () const override;  ; void doEval (RooFit::EvalContext &) const override;  Compute addition of PDFs in batches. ;  ; double evaluate () const override;  Evaluate this PDF / function / constant. Needs to be overridden by all derived classes. ;  ; RooAbsGenContext * genContext (const RooArgSet &vars, const RooDataSet *prototype=nullptr, const RooArgSet *auxProto=nullptr, bool verbose=false) const override;  Return specialized context to efficiently generate toy events from RooAddPdfs return RooAbsPdf::genContext(vars,prototype,auxProto,verbose) ; // WVE DEBUG. ;  ; AddCacheElem * getProjCache (const RooArgSet *nset, const RooArgSet *iset=nullptr) const;  Manager of cache with coefficient projections and transformations. ;  ; double getValV (const RooArgSet *set=nullptr) const override;  Calculate and return the current value. ;  ; bool redirectServersHook (const RooAbsCollection &, bool, bool, bool) override;  The cache manager. ;  ; void selectNormalization (const RooArgSet *depSet=nullptr, bool force=false) override;  Interface function used by test statistics to freeze choice of observables for interpretation of fraction coefficients. ;  ; void selectNormalizationRange (const char *rangeName=nullptr, bool force=false) override;  Interface function used by test statistics to freeze choice of range for interpretation of fraction coefficients. ;  ; void updateCoefficients (AddCache",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAddPdf.html:63045,efficient,efficiently,63045,doc/v632/classRooAddPdf.html,https://root.cern,https://root.cern/doc/v632/classRooAddPdf.html,2,['efficient'],['efficiently']
Energy Efficiency,"TProofServ::GetNextPacket ; (; Long64_t ; totalEntries = -1). Get next range of entries to be processed on this server. ; Definition at line 1141 of file TProofServ.cxx. ◆ GetOptions(). void TProofServ::GetOptions ; (; Int_t * ; argc, . char ** ; argv . ). overridevirtual . Get and handle command line options. ; Fixed format: ""proofserv""|""proofslave"" <confdir> ; Reimplemented from TApplication.; Definition at line 1280 of file TProofServ.cxx. ◆ GetOrdinal(). const char * TProofServ::GetOrdinal ; (; ); const. inline . Definition at line 253 of file TProofServ.h. ◆ GetPackMgr(). TPackMgr * TProofServ::GetPackMgr ; (; ); const. inline . Definition at line 249 of file TProofServ.h. ◆ GetPrefix(). const char * TProofServ::GetPrefix ; (; ); const. inline . Definition at line 276 of file TProofServ.h. ◆ GetPriority(). Int_t TProofServ::GetPriority ; (; ). private . Get the processing priority for the group the user belongs too. ; This priority is a number (0 - 100) determined by a scheduler (third party process) based on some basic priority the group has, e.g. we might want to give users in a specific group (e.g. promptana) a higher priority than users in other groups, and on the analysis of historical logging data (i.e. usage of CPU by the group in a previous time slot, as recorded in TPerfStats::WriteQueryLog()).; Currently the group priority is obtained by a query in a SQL DB table proofpriority, which has the format: CREATE TABLE proofpriority ( id INT NOT NULL PRIMARY KEY AUTO_INCREMENT, group VARCHAR(32) NOT NULL, priority INT ) ; Definition at line 5939 of file TProofServ.cxx. ◆ GetProof(). TProof * TProofServ::GetProof ; (; ); const. inline . Definition at line 237 of file TProofServ.h. ◆ GetProtocol(). Int_t TProofServ::GetProtocol ; (; ); const. inline . Definition at line 252 of file TProofServ.h. ◆ GetQuerySeqNum(). Int_t TProofServ::GetQuerySeqNum ; (; ); const. inline . Definition at line 260 of file TProofServ.h. ◆ GetRealTime(). Float_t TProofServ::GetRealTi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofServ.html:40757,schedul,scheduler,40757,doc/master/classTProofServ.html,https://root.cern,https://root.cern/doc/master/classTProofServ.html,1,['schedul'],['scheduler']
Energy Efficiency,"TRUE, 3, kTRUE, 3);; Double_t *xpeaks = s->GetPositionX();; for (i = 0; i < nfound; i++) {; a=xpeaks[i];; bin = 1 + Int_t(a + 0.5);; fPositionX[i] = h->GetBinCenter(bin);; fPositionY[i] = h->GetBinContent(bin);; }; TPolyMarker * pm = (TPolyMarker*)h->GetListOfFunctions()->FindObject(""TPolyMarker"");; if (pm) {; h->GetListOfFunctions()->Remove(pm);; delete pm;; }; pm = new TPolyMarker(nfound, fPositionX, fPositionY);; h->GetListOfFunctions()->Add(pm);; pm->SetMarkerStyle(23);; pm->SetMarkerColor(kRed);; pm->SetMarkerSize(1.3);; for (i = 0; i < nbins; i++) d->SetBinContent(i + 1,dest[i]);; d->SetLineColor(kRed);; d->Draw(""SAME"");; printf(""Found %d candidate peaks\n"",nfound);; for(i=0;i; ; Example 16 - script SearchHR3.c:; ; ; Peak # Position Sigma ; 1 118 26 ; 2 162 41 ; 3 310 4 ; 4 330 8 ; 5 482 22 ; 6 491 26 ; 7 740 21 ; 8 852 15 ; 9 954 12 ; 10 989 13 ; ; ; Table 4 Positions and sigma of peaks in the following examples.; ; ; ; Fig. 30 Influence of number of iterations (3-red, 10-blue, 100- green,; 1000-magenta), sigma=8, smoothing width=3.; ; ; ; Fig. 31 Influence of sigma (3-red, 8-blue, 20- green, 43-magenta),; num. iter.=10, sm. width=3.; ; ; ; Fig. 32 Influence smoothing width (0-red, 3-blue, 7- green, 20-magenta), num.; iter.=10, sigma=8.; ; Script:; ; // Example to illustrate the influence of number of iterations in deconvolution in high resolution peak searching function (class TSpectrum).; // To execute this example, do; // root > .x SearchHR3.C; #include ; void SearchHR3() {; Double_t fPositionX[100];; Double_t fPositionY[100];; Int_t fNPeaks = 0;; Int_t i,nfound,bin;; Double_t nbins = 1024,a;; Double_t xmin = 0;; Double_t xmax = nbins;; Double_t * source = new Double_t[nbins];; Double_t * dest = new Double_t[nbins];; TH1F *h = new TH1F(""h"",""Influence of # of iterations in deconvolution in peak searching"",nbins,xmin,xmax);; TH1F *d1 = new TH1F(""d1"","""",nbins,xmin,xmax);; TH1F *d2 = new TH1F(""d2"","""",nbins,xmin,xmax);; TH1F *d3 = new TH1F(""d3"","""",nbins,xmin,xm",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSpectrum.html:56303,green,green,56303,root/html602/TSpectrum.html,https://root.cern,https://root.cern/root/html602/TSpectrum.html,2,['green'],['green']
Energy Efficiency,TRefArray *fMuons; //array of Muon tracks only; TRef fLastTrack; //pointer to last track; TRef fHistoWeb; //EXEC:GetHistoWeb reference to an histogram in a TWebFile; TH1F *fH;; TBits fTriggerBits; //Bits triggered by this event. The EventHeader class has 3 data members (integers):; public:; Int_t fEvtNum;; Int_t fRun;; Int_t fDate;. The Event data member fTracks is a pointer to a TClonesArray.; It is an array of a variable number of tracks per event.; Each element of the array is an object of class Track with the members:; private:; Float_t fPx; //X component of the momentum; Float_t fPy; //Y component of the momentum; Float_t fPz; //Z component of the momentum; Float_t fRandom; //A random track quantity; Float_t fMass2; //The mass square of this particle; Float_t fBx; //X intercept at the vertex; Float_t fBy; //Y intercept at the vertex; Float_t fMeanCharge; //Mean charge deposition of all hits of this track; Float_t fXfirst; //X coordinate of the first point; Float_t fXlast; //X coordinate of the last point; Float_t fYfirst; //Y coordinate of the first point; Float_t fYlast; //Y coordinate of the last point; Float_t fZfirst; //Z coordinate of the first point; Float_t fZlast; //Z coordinate of the last point; Double32_t fCharge; //Charge of this track; Double32_t fVertex[3]; //Track vertex position; Int_t fNpoint; //Number of points for this track; Short_t fValid; //Validity criterion; Int_t fNsp; //Number of points for this track with a special value; Double32_t *fPointValue; //[fNsp] a special quantity for some point.; TBits fTriggerBits; //Bits triggered by this track. An example of a batch program to use the Event/Track classes is given; in this directory: MainEvent.; Look also in the same directory at the following macros:; - eventa.C an example how to read the tree; - eventb.C how to read events conditionally. During the processing of the event (optionally) also a large number; of histograms can be filled. The creation and handling of the; histograms is taken,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/Event.html:1616,charge,charge,1616,root/html528/Event.html,https://root.cern,https://root.cern/root/html528/Event.html,12,['charge'],['charge']
Energy Efficiency,"TString() : gTools().Color(""reset"");; 1485 ; 1486 Log() << Endl;; 1487 Log() << col << ""--- Short description:"" << colres << Endl;; 1488 Log() << Endl;; 1489 Log() << ""The DNN neural network is a feedforward"" << Endl;; 1490 Log() << ""multilayer perceptron implementation. The DNN has a user-"" << Endl;; 1491 Log() << ""defined hidden layer architecture, where the number of input (output)"" << Endl;; 1492 Log() << ""nodes is determined by the input variables (output classes, i.e., "" << Endl;; 1493 Log() << ""signal and one background, regression or multiclass). "" << Endl;; 1494 Log() << Endl;; 1495 Log() << col << ""--- Performance optimisation:"" << colres << Endl;; 1496 Log() << Endl;; 1497 ; 1498 const char* txt = ""The DNN supports various options to improve performance in terms of training speed and \n \; 1499reduction of overfitting: \n \; 1500\n \; 1501 - different training settings can be stacked. Such that the initial training \n\; 1502 is done with a large learning rate and a large drop out fraction whilst \n \; 1503 in a later stage learning rate and drop out can be reduced. \n \; 1504 - drop out \n \; 1505 [recommended: \n \; 1506 initial training stage: 0.0 for the first layer, 0.5 for later layers. \n \; 1507 later training stage: 0.1 or 0.0 for all layers \n \; 1508 final training stage: 0.0] \n \; 1509 Drop out is a technique where a at each training cycle a fraction of arbitrary \n \; 1510 nodes is disabled. This reduces co-adaptation of weights and thus reduces overfitting. \n \; 1511 - L1 and L2 regularization are available \n \; 1512 - Minibatches \n \; 1513 [recommended 10 - 150] \n \; 1514 Arbitrary mini-batch sizes can be chosen. \n \; 1515 - Multithreading \n \; 1516 [recommended: True] \n \; 1517 Multithreading can be turned on. The minibatches are distributed to the available \n \; 1518 cores. The algorithm is lock-free (\""Hogwild!\""-style) for each cycle. \n \; 1519 \n \; 1520 Options: \n \; 1521 \""Layout\"": \n \; 1522 - example: \""TANH|(N+30)*2,TAN",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDNN_8cxx_source.html:54781,reduce,reduced,54781,doc/master/MethodDNN_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDNN_8cxx_source.html,1,['reduce'],['reduced']
Energy Efficiency,"TSym<Element> &TMatrixTSym<Element> InvertFast(Double_t* det = 0); Invert the matrix and calculate its determinant. TMatrixTSym<Element> &TMatrixTSym<Element> Transpose(const TMatrixTSym<float>& source); Transpose a matrix. TMatrixTSym<Element> &TMatrixTSym<Element> Rank1Update(const TVectorT<float>& v, float alpha = 1.); Perform a rank 1 operation on the matrix:; A += alpha * v * v^T. TMatrixTSym<Element> &TMatrixTSym<Element> Similarity(const TMatrixT<Element> &b); Calculate B * (*this) * B^T , final matrix will be (nrowsb x nrowsb); This is a similarity transform when B is orthogonal . It is more; efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . TMatrixTSym<Element> &TMatrixTSym<Element> Similarity(const TMatrixTSym<Element> &b); Calculate B * (*this) * B^T , final matrix will be (nrowsb x nrowsb); This is a similarity transform when B is orthogonal . It is more; efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . Element TMatrixTSym<Element> Similarity(const TVectorT<float>& v) const; Calculate scalar v * (*this) * v^T. TMatrixTSym<Element> &TMatrixTSym<Element> SimilarityT(const TMatrixT<float>& n); Calculate B^T * (*this) * B , final matrix will be (ncolsb x ncolsb); It is more efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . TMatrixTSym<Element> &TMatrixTSym<Element> operator=(const TMatrixTSym<Element> &source). TMatrixTSym<Element> &TMatrixTSym<Element> operator=(const TMatrixTSymLazy<Element> &lazy_constructor). TMatrixTSym<Element> &TMatrixTSym<Element> operator=(Element val); Assign val to every element of the matrix. TMatrixTSym<Element> &TMatrixTSym<Element> operator+=(Element val); Add val to every element of the matrix. TMatrixTSym<Element> &TMatrixTSym<Element> operator-=(Element val); Subtract val from every element of the matrix. TMatrixTSym<Eleme",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMatrixTSym_float_.html:19045,efficient,efficient,19045,root/html602/TMatrixTSym_float_.html,https://root.cern,https://root.cern/root/html602/TMatrixTSym_float_.html,2,['efficient'],['efficient']
Energy Efficiency,"TTree class represents a columnar dataset. Any C++ type can be stored in the; 17 columns. The TTree has allowed to store about **1 EB** of data coming from the LHC alone:; 18 it is demonstrated to scale and it's battle tested. It has been optimized during the years; 19 to reduce dataset sizes on disk and to deliver excellent runtime performance.; 20 It allows to access only part of the columns of the datasets, too.; 21 The TNtuple and TNtupleD classes are specialisations of the TTree class which can; 22 only hold single precision and double precision floating-point numbers respectively;; 23 The TChain is a collection of TTrees, which can be located also in different files.; 24 ; 25*/; 26 ; 27/** \class TTree; 28\ingroup tree; 29 ; 30A TTree represents a columnar dataset. Any C++ type can be stored in its columns.; 31 ; 32A TTree, often called in jargon *tree*, consists of a list of independent columns or *branches*,; 33represented by the TBranch class.; 34Behind each branch, buffers are allocated automatically by ROOT.; 35Such buffers are automatically written to disk or kept in memory until the size stored in the; 36attribute fMaxVirtualSize is reached.; 37Variables of one branch are written to the same buffer. A branch buffer is; 38automatically compressed if the file compression attribute is set (default).; 39Branches may be written to different files (see TBranch::SetFile).; 40 ; 41The ROOT user can decide to make one single branch and serialize one object into; 42one single I/O buffer or to make several branches.; 43Making several branches is particularly interesting in the data analysis phase,; 44when it is desirable to have a high reading rate and not all columns are equally interesting; 45 ; 46\anchor creatingattreetoc; 47## Create a TTree to store columnar data; 48- [Construct a TTree](\ref creatingattree); 49- [Add a column of Fundamental Types and Arrays thereof](\ref addcolumnoffundamentaltypes); 50- [Add a column of a STL Collection instances](\ref addi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:1768,allocate,allocated,1768,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['allocate'],['allocated']
Energy Efficiency,"TUnfoldDensity and TUnfoldBinning ;  testUnfold7b.C Test program for the classes TUnfoldDensity and TUnfoldBinning ;  testUnfold7c.C Test program for the classes TUnfoldDensity and TUnfoldBinning ;  ► unuran;  unuranDemo.CExample macro to show unuran capabilities The results are compared with what is obtained using TRandom or TF1::GetRandom The macro is divided in 3 parts: ;  unuranFoamTest.CThis program must be compiled and executed with Aclic as follows ;  ► v7;  concurrentfill.cxx;  draw.cxx;  draw_subpads.cxx;  draw_th1.cxxThis macro generates a small V7 TH1D, fills it and draw it in a V7 canvas ;  draw_v6.cxx;  fitpanel.cxx;  histops.cxx;  line.cxx;  lineStyle.cxx;  lineWidth.cxx;  markerStyle.cxx;  pad.cxx;  perf.cxx;  perfcomp.cxx;  simple.cxx;  text.cxx;  ► vecops;  vo001_AdoptOrOwnMemory.C In this tutorial we learn how the RVec class can be used to adopt existing memory or allocate some ;  vo001_AdoptOrOwnMemory.py In this tutorial we learn how the RVec class can be used to adopt existing memory or allocate some ;  vo002_VectorCalculations.C In this tutorial we learn how the RVec class can be used to express easily mathematical operations involving arrays and scalars ;  vo003_LogicalOperations.C In this tutorial we learn how the RVec class can be used to express logical operations ;  ► xml;  DOMParsePerson.C ROOT implementation of a XML DOM Parser ;  DOMRecursive.C ROOT implementation of a XML DOM Parser ;  SAXHandler.C ROOT implementation of a simple SAX Handler ;  xmlmodifyfile.C Example to read, modify and store xml file, using TXMLEngine class The input file, produced by xmlnewfile.C macro is used If you need full xml syntax support, use TXMLParser instead ;  xmlnewfile.C Example to create a new xml file with the TXMLEngine class ;  xmlreadfile.C Example to read and parse any xml file, supported by TXMLEngine class The input file, produced by xmlnewfile.C macro is used If you need full xml syntax support, use TXMLParser instead ;  benchmarks.CThis macro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v614/files.html:165333,allocate,allocate,165333,doc/v614/files.html,https://root.cern,https://root.cern/doc/v614/files.html,1,['allocate'],['allocate']
Energy Efficiency,"TVirtualFitter::GetCovarianceMatrix() cannot be used.; One should use the TFitResult class, as shown in the example below. To get the matrix and values from an old fit do for example:; TFitResultPtr r = histo->Fit(func, ""S"");; ..... after performing other fits on the same function do; func->IntegralError(x1,x2,r->GetParams(), r->GetCovarianceMatrix()->GetMatrixArray() );. Double_t IntegralFast(const TGraph *g, Double_t a, Double_t b, Double_t *params); Gauss-Legendre integral, see CalcGaussLegendreSamplingPoints. Double_t IntegralMultiple(Int_t n, const Double_t* a, const Double_t* b, Double_t epsilon, Double_t& relerr); See more general prototype below.; This interface kept for back compatibility. Double_t IntegralMultiple(Int_t n, const Double_t* a, const Double_t* b, Int_t minpts, Int_t maxpts, Double_t epsilon, Double_t& relerr, Int_t& nfnevl, Int_t& ifail); Adaptive Quadrature for Multiple Integrals over N-Dimensional; Rectangular Regions. Author(s): A.C. Genz, A.A. Malik; converted/adapted by R.Brun to C++ from Fortran CERNLIB routine RADMUL (D120); The new code features many changes compared to the Fortran version.; Note that this function is currently called only by TF2::Integral (n=2); and TF3::Integral (n=3). This function computes, to an attempted specified accuracy, the value of; the integral over an n-dimensional rectangular region. Input parameters:. n : Number of dimensions [2,15]; a,b : One-dimensional arrays of length >= N . On entry A[i], and B[i],; contain the lower and upper limits of integration, respectively.; minpts: Minimum number of function evaluations requested. Must not exceed maxpts.; if minpts < 1 minpts is set to 2^n +2*n*(n+1) +1; maxpts: Maximum number of function evaluations to be allowed.; maxpts >= 2^n +2*n*(n+1) +1; if maxpts<minpts, maxpts is set to 10*minpts; eps : Specified relative accuracy. Output parameters:. relerr : Contains, on exit, an estimation of the relative accuracy of the result.; nfnevl : number of function evalua",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TF1.html:56972,adapt,adapted,56972,root/html528/TF1.html,https://root.cern,https://root.cern/root/html528/TF1.html,4,['adapt'],['adapted']
Energy Efficiency,"TVirtualMonitoringWriter(const TVirtualMonitoringWriter&). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; TList*fTmpOpenPhasesTo store open phases when there is not yet an object. private:. Double_tfValuedouble monitor value. Class Charts. Inheritance Chart:. TObject. ←; TNamed. ←; TVirtualMonitoringWriter. ←. TSQLMonitoringWriter. Function documentation; TVirtualMonitoringWriter(const TVirtualMonitoringWriter& ). TVirtualMonitoringWriter& operator=(const TVirtualMonitoringWriter& ). TVirtualMonitoringWriter(); { }. TVirtualMonitoringWriter(const char* name, Double_t value); { }. virtual ~TVirtualMonitoringWriter(); { if (fTmpOpenPhases) delete fTmpOpenPhases; }. Bool_t SendFileCloseEvent(TFile* ); TFile related info. In general they are gathered and sent only sometimes as summaries. { MayNotUse(""SendFileCloseEvent""); return kFALSE; }. Bool_t SendFileReadProgress(TFile* ); { MayNotUse(""SendFileReadProgress""); return kFALSE; }. Bool_t SendFileWriteProgress(TFile* ); { MayNotUse(""SendFileWriteProgress""); return kFALSE; }. Bool_t SendParameters(TList* , const char* = 0); { MayNotUse(""SendParameters""); return kFALSE; }. Bool_t SendInfoTime(); { MayNotUse(""SendInfoTime""); return kFALSE; }. Boo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TVirtualMonitoringWriter.html:6927,monitor,monitor,6927,root/html602/TVirtualMonitoringWriter.html,https://root.cern,https://root.cern/root/html602/TVirtualMonitoringWriter.html,2,['monitor'],['monitor']
Energy Efficiency,"TYPE=4,N=4,XY=(-3,0,3,0,0,-3,0,3) sets a plus shape of 7x7 pixels. void SetMarkerStyle(Style_t markerstyle); Set marker style. void SetOpacity(Int_t percent); Set opacity of a window. This image manipulation routine works; by adding to a percent amount of neutral to each pixels RGB.; Since it requires quite some additional color map entries is it; only supported on displays with more than > 8 color planes (> 256; colors). void CollectImageColors(ULong_t pixel, ULong_t*& orgcolors, Int_t& ncolors, Int_t& maxcolors); Collect in orgcolors all different original image colors. void MakeOpaqueColors(Int_t percent, ULong_t* orgcolors, Int_t ncolors); Get RGB values for orgcolors, add percent neutral to the RGB and; allocate fNewColors. Int_t FindColor(ULong_t pixel, ULong_t* orgcolors, Int_t ncolors); Returns index in orgcolors (and fNewColors) for pixel. void SetRGB(Int_t cindex, Float_t r, Float_t g, Float_t b); Set color intensities for given color index.; cindex : color index; r,g,b : red, green, blue intensities between 0.0 and 1.0. void SetTextAlign(Short_t talign = 11); Set text alignment.; txalh : horizontal text alignment; txalv : vertical text alignment. void SetTextColor(Color_t cindex); Set color index for text. Int_t SetTextFont(char* fontname, TVirtualX::ETextSetMode mode); Set text font to specified name.; mode : loading flag; mode=0 : search if the font exist (kCheck); mode=1 : search the font and load it if it exists (kLoad); font : font name. Set text font to specified name. This function returns 0 if; the specified font is found, 1 if not. void SetTextFont(Font_t fontnumber); Set current text font number. void SetTextSize(Float_t textsize); Set current text size. void Sync(Int_t mode); Set synchronisation on or off.; mode : synchronisation on/off; mode=1 on; mode<>0 off. void UpdateWindow(Int_t mode); Update display.; mode : (1) update; (0) sync. Synchronise client and server once (not permanent).; Copy the pixmap gCws->fDrawing on the window gCws->fWindo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGX11.html:34901,green,green,34901,root/html528/TGX11.html,https://root.cern,https://root.cern/root/html528/TGX11.html,6,['green'],['green']
Energy Efficiency,"TeXDump.h. ◆ NewPage(). void TTeXDump::NewPage ; (; ). overridevirtual . Start the TeX page. This function starts the tikzpicture environment. ; Implements TVirtualPS.; Definition at line 648 of file TTeXDump.cxx. ◆ Off(). void TTeXDump::Off ; (; ). Deactivate an already open TeX file. ; Definition at line 240 of file TTeXDump.cxx. ◆ On(). void TTeXDump::On ; (; ). Activate an already open TeX file. ; Definition at line 224 of file TTeXDump.cxx. ◆ Open(). void TTeXDump::Open ; (; const char * ; filename, . Int_t ; type = -111 . ). overridevirtual . Open a TeX file. ; Implements TVirtualPS.; Definition at line 131 of file TTeXDump.cxx. ◆ Range(). void TTeXDump::Range ; (; Float_t ; xrange, . Float_t ; yrange . ). Set the range for the paper in centimetres. ; Definition at line 672 of file TTeXDump.cxx. ◆ SetColor() [1/2]. void TTeXDump::SetColor ; (; Float_t ; r, . Float_t ; g, . Float_t ; b . ). overridevirtual . Set color with its R G B components. . r: % of red in [0,1]; g: % of green in [0,1]; b: % of blue in [0,1] . Implements TVirtualPS.; Definition at line 757 of file TTeXDump.cxx. ◆ SetColor() [2/2]. void TTeXDump::SetColor ; (; Int_t ; color = 1). Set color with its color index. ; Definition at line 736 of file TTeXDump.cxx. ◆ SetFillColor(). void TTeXDump::SetFillColor ; (; Color_t ; cindex = 1). overridevirtual . Set color index for fill areas. ; Reimplemented from TAttFill.; Definition at line 683 of file TTeXDump.cxx. ◆ SetLineColor(). void TTeXDump::SetLineColor ; (; Color_t ; cindex = 1). overridevirtual . Set color index for lines. ; Reimplemented from TAttLine.; Definition at line 691 of file TTeXDump.cxx. ◆ SetLineScale(). void TTeXDump::SetLineScale ; (; Float_t ; scale = 1). inline . Definition at line 67 of file TTeXDump.h. ◆ SetLineStyle(). void TTeXDump::SetLineStyle ; (; Style_t ; linestyle = 1). overridevirtual . Change the line style. . linestyle = 2 dashed; linestyle = 3 dotted; linestyle = 4 dash-dotted; linestyle = else solid (1 in is use",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTeXDump.html:31485,green,green,31485,doc/master/classTTeXDump.html,https://root.cern,https://root.cern/doc/master/classTTeXDump.html,1,['green'],['green']
Energy Efficiency,"Text::fTextAlignText alignment; Float_tTAttText::fTextAngleText angle; Color_tTAttText::fTextColorText color index; Font_tTAttText::fTextFontText font number; Float_tTAttText::fTextSizeText size; TStringTNamed::fTitleobject title; TStringfValueFormatVform numeric format for the value; Double_tfXX coordinate of the pie centre; Double_tfYY coordinate of the pie centre. private:. TLegend*fLegend!Legend for this piechart; Float_t*fSlices!Subdivisions of the slices; Float_tfSum!Sum for the slice values. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPie(); Default constructor. TPie(const char* , const char* , Int_t ); This constructor creates a pie chart when only the number of; the slices is known. The number of slices is fixed. TPie(const char* , const char* , Int_t , Double_t* , Int_t* cols = 0, const char** lbls = 0); Normal constructor. The 1st and 2nd parameters are the name of the object; and its title. The number of points passed at this point is used to allocate the memory. Slices values are given as Double_t. The 4th elements is an array containing, in double precision format,; the value of each slice. It is also possible to specify the filled color; of each slice. If the color array is not specfied the slices are colored; using a color sequence in the standard palette. TPie(const char* , const char* , Int_t , Float_t* , Int_t* cols = 0, const char** lbls = 0); Normal constructor (Float_t). TPie(const TH1* h); Constructor from a TH1. TPie(const TPie& ); Copy constructor. ~TPie(); Destructor. Int_t DistancetoPrimitive(Int_t px, Int_t py); Evaluate the distance to the chart in gPad. Int_t DistancetoSlice(Int_t , Int_t ); Returns the slice number at the pixel position (px,py).; Returns -1 if no slice is picked. Used by DistancetoPrimitive. void Draw(Option_t* option = ""l""); Draw the pie chart. The possible options are listed in the TPie::Paint() method. void DrawGhost(); This method is for internal use. It is used by Ex",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TPie.html:9784,allocate,allocate,9784,root/html528/TPie.html,https://root.cern,https://root.cern/root/html528/TPie.html,4,['allocate'],['allocate']
Energy Efficiency,"The Decompose() method is successful as long no zero diagonal element is encountered. Therefore, the user could perform decomposition and only after this step worry about the tolerance number.; If the matrix is flagged as being singular, operations with the decomposition will fail and will return matrices or vectors that are invalid. If one would like to monitor the tolerance parameter but not have the code stop in case of a number smaller than fTol, one could proceed as follows:; TVectorD b = ..;; TMatrixD a = ..;; .; TDecompLU lu(a);; Bool_t ok;; TVectorD x = lu.Solve(b,ok);; Int_t nr = 0;; while (!ok) {; lu.SetMatrix(a);; lu.SetTol(0.1*lu.GetTol());; if (nr++ > 10) break;; x = lu.Solve(b,ok);; }; if (x.IsValid()); cout << ""solved with tol ="" << lu.GetTol() << endl;; else; cout << ""solving failed "" << endl;; The observant reader will notice that by scaling the complete matrix by some small number the decomposition will detect a singular matrix. In this case, the user will have to reduce the tolerance number by this factor. (For CPU time saving we decided not to make this an automatic procedure).; 14.6.2 Condition number; The numerical accuracy of the solution x in Ax = b can be accurately estimated by calculating the condition number k of matrix \(A\), which is defined as:; \(k = ||A||_{1}||A^{-1}||_{1}\) where \(||A||_{1} = \underset{j}{max}(\sum_{i}|A_{ij}|)\); A good rule of thumb is that if the matrix condition number is 10n, the accuracy in x is 15 - n digits for double precision.; Hager devised an iterative method (W.W. Hager, Condition estimators, SIAM J. Sci. Stat. Comp., 5 (1984), pp. 311-316) to determine \(||A^{-1}||_{1}\) without actually having to calculate \(A^{-1}\). It is used when calling Condition().; A code example below shows the usage of the condition number. The matrix \(A\) is a (10x10) Hilbert matrix that is badly conditioned as its determinant shows. We construct a vector b by summing the matrix rows. Therefore, the components of the solut",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:794400,reduce,reduce,794400,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['reduce'],['reduce']
Energy Efficiency,"The following objects and methods automatically take advantage of multi-threading if a call to EnableImplicitMT has been made before usage:. RDataFrame internally runs the event-loop by parallelizing over clusters of entries; TTree::GetEntry reads multiple branches in parallel; TTree::FlushBaskets writes multiple baskets to disk in parallel; TTreeCacheUnzip decompresses the baskets contained in a TTreeCache in parallel; THx::Fit performs in parallel the evaluation of the objective function over the data; TMVA::DNN trains the deep neural networks in parallel; TMVA::BDT trains the classifier in parallel and multiclass BDTs are evaluated in parallel. EnableImplicitMT calls in turn EnableThreadSafety. The 'numthreads' parameter allows to control the number of threads to be used by the implicit multi-threading. However, this parameter is just a hint for ROOT: it will try to satisfy the request if the execution scenario allows it. For example, if ROOT is configured to use an external scheduler, setting a value for 'numthreads' might not have any effect. ; Definition at line 525 of file TROOT.cxx. ◆ EnableThreadSafety(). void ROOT::EnableThreadSafety ; (; ). Enables the global mutex to make ROOT thread safe/aware. ; The following becomes safe:; concurrent construction and destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); concurrent usage of different ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; concurrent calls to the interpreter through gInterpreter; concurrent loading of ROOT plug-ins. In addition, gDirectory, gFile and gPad become a thread-local variable. In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents. gFile and gPad default to nullptr, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v624/namespaceROOT.html:21022,schedul,scheduler,21022,doc/v624/namespaceROOT.html,https://root.cern,https://root.cern/doc/v624/namespaceROOT.html,1,['schedul'],['scheduler']
Energy Efficiency,"The following objects and methods automatically take advantage of multi-threading if a call to EnableImplicitMT has been made before usage:. RDataFrame internally runs the event-loop by parallelizing over clusters of entries; TTree::GetEntry reads multiple branches in parallel; TTree::FlushBaskets writes multiple baskets to disk in parallel; TTreeCacheUnzip decompresses the baskets contained in a TTreeCache in parallel; THx::Fit performs in parallel the evaluation of the objective function over the data; TMVA::DNN trains the deep neural networks in parallel; TMVA::BDT trains the classifier in parallel and multiclass BDTs are evaluated in parallel. EnableImplicitMT calls in turn EnableThreadSafety. The 'numthreads' parameter allows to control the number of threads to be used by the implicit multi-threading. However, this parameter is just a hint for ROOT: it will try to satisfy the request if the execution scenario allows it. For example, if ROOT is configured to use an external scheduler, setting a value for 'numthreads' might not have any effect. ; Definition at line 526 of file TROOT.cxx. ◆ EnableThreadSafety(). void ROOT::EnableThreadSafety ; (; ). Enables the global mutex to make ROOT thread safe/aware. ; The following becomes safe:; concurrent construction and destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); concurrent usage of different ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; concurrent calls to the interpreter through gInterpreter; concurrent loading of ROOT plug-ins. In addition, gDirectory, gFile and gPad become a thread-local variable. In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents. gFile and gPad default to nullptr, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v622/namespaceROOT.html:20983,schedul,scheduler,20983,doc/v622/namespaceROOT.html,https://root.cern,https://root.cern/doc/v622/namespaceROOT.html,1,['schedul'],['scheduler']
Energy Efficiency,"The following objects and methods automatically take advantage of multi-threading if a call to EnableImplicitMT has been made before usage:. RDataFrame internally runs the event-loop by parallelizing over clusters of entries; TTree::GetEntry reads multiple branches in parallel; TTree::FlushBaskets writes multiple baskets to disk in parallel; TTreeCacheUnzip decompresses the baskets contained in a TTreeCache in parallel; THx::Fit performs in parallel the evaluation of the objective function over the data; TMVA::DNN trains the deep neural networks in parallel; TMVA::BDT trains the classifier in parallel and multiclass BDTs are evaluated in parallel. EnableImplicitMT calls in turn EnableThreadSafety. The 'numthreads' parameter allows to control the number of threads to be used by the implicit multi-threading. However, this parameter is just a hint for ROOT: it will try to satisfy the request if the execution scenario allows it. For example, if ROOT is configured to use an external scheduler, setting a value for 'numthreads' might not have any effect. ; Definition at line 579 of file TROOT.cxx. ◆ EnableThreadSafety(). void ROOT::EnableThreadSafety ; (; ). Enables the global mutex to make ROOT thread safe/aware. ; The following becomes safe:; concurrent construction and destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); concurrent usage of different ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; concurrent calls to the interpreter through gInterpreter; concurrent loading of ROOT plug-ins. In addition, gDirectory, gFile and gPad become a thread-local variable. In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents. gFile and gPad default to nullptr, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v618/namespaceROOT.html:20293,schedul,scheduler,20293,doc/v618/namespaceROOT.html,https://root.cern,https://root.cern/doc/v618/namespaceROOT.html,1,['schedul'],['scheduler']
Energy Efficiency,"The following objects and methods automatically take advantage of multi-threading if a call to EnableImplicitMT has been made before usage:. RDataFrame internally runs the event-loop by parallelizing over clusters of entries; TTree::GetEntry reads multiple branches in parallel; TTree::FlushBaskets writes multiple baskets to disk in parallel; TTreeCacheUnzip decompresses the baskets contained in a TTreeCache in parallel; THx::Fit performs in parallel the evaluation of the objective function over the data; TMVA::DNN trains the deep neural networks in parallel; TMVA::BDT trains the classifier in parallel and multiclass BDTs are evaluated in parallel. EnableImplicitMT calls in turn EnableThreadSafety. The 'numthreads' parameter allows to control the number of threads to be used by the implicit multi-threading. However, this parameter is just a hint for ROOT: it will try to satisfy the request if the execution scenario allows it. For example, if ROOT is configured to use an external scheduler, setting a value for 'numthreads' might not have any effect. ; Definition at line 580 of file TROOT.cxx. ◆ EnableThreadSafety(). void ROOT::EnableThreadSafety ; (; ). Enables the global mutex to make ROOT thread safe/aware. ; The following becomes safe:; concurrent construction and destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); concurrent usage of different ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; concurrent calls to the interpreter through gInterpreter; concurrent loading of ROOT plug-ins. In addition, gDirectory, gFile and gPad become a thread-local variable. In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents. gFile and gPad default to nullptr, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v620/namespaceROOT.html:20385,schedul,scheduler,20385,doc/v620/namespaceROOT.html,https://root.cern,https://root.cern/doc/v620/namespaceROOT.html,1,['schedul'],['scheduler']
Energy Efficiency,"The following objects and methods automatically take advantage of multi-threading if a call to EnableImplicitMT has been made before usage:. RDataFrame internally runs the event-loop by parallelizing over clusters of entries; TTree::GetEntry reads multiple branches in parallel; TTree::FlushBaskets writes multiple baskets to disk in parallel; TTreeCacheUnzip decompresses the baskets contained in a TTreeCache in parallel; THx::Fit performs in parallel the evaluation of the objective function over the data; TMVA::DNN trains the deep neural networks in parallel; TMVA::BDT trains the classifier in parallel and multiclass BDTs are evaluated in parallel. EnableImplicitMT calls in turn EnableThreadSafety. The 'numthreads' parameter allows to control the number of threads to be used by the implicit multi-threading. However, this parameter is just a hint for ROOT: it will try to satisfy the request if the execution scenario allows it. For example, if ROOT is configured to use an external scheduler, setting a value for 'numthreads' might not have any effect. The maximum number of threads can be influenced by the environment variable ROOT_MAX_THREADS: export ROOT_MAX_THREADS=2 will try to set the maximum number of active threads to 2, if the scheduling library (such as tbb) ""permits"".; NoteUse DisableImplicitMT() to disable multi-threading (some locks will remain in place as described in EnableThreadSafety()). EnableImplicitMT(1) creates a thread-pool of size 1. ; Definition at line 539 of file TROOT.cxx. ◆ EnableThreadSafety(). void ROOT::EnableThreadSafety ; (; ). Enable support for multi-threading within the ROOT code in particular, enables the global mutex to make ROOT thread safe/aware. ; Enables the global mutex to make ROOT thread safe/aware.; The following becomes safe:; concurrent construction and destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); concurrent usage of different ROOT ob",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT.html:32588,schedul,scheduler,32588,doc/master/namespaceROOT.html,https://root.cern,https://root.cern/doc/master/namespaceROOT.html,3,['schedul'],['scheduler']
Energy Efficiency,"The following objects and methods automatically take advantage of multi-threading if a call to EnableImplicitMT has been made before usage:. RDataFrame internally runs the event-loop by parallelizing over clusters of entries; TTree::GetEntry reads multiple branches in parallel; TTree::FlushBaskets writes multiple baskets to disk in parallel; TTreeCacheUnzip decompresses the baskets contained in a TTreeCache in parallel; THx::Fit performs in parallel the evaluation of the objective function over the data; TMVA::DNN trains the deep neural networks in parallel; TMVA::BDT trains the classifier in parallel and multiclass BDTs are evaluated in parallel. EnableImplicitMT calls in turn EnableThreadSafety. The 'numthreads' parameter allows to control the number of threads to be used by the implicit multi-threading. However, this parameter is just a hint for ROOT: it will try to satisfy the request if the execution scenario allows it. For example, if ROOT is configured to use an external scheduler, setting a value for 'numthreads' might not have any effect.; NoteUse DisableImplicitMT() to disable multi-threading (some locks will remain in place as described in EnableThreadSafety()). EnableImplicitMT(1) creates a thread-pool of size 1. ; Definition at line 527 of file TROOT.cxx. ◆ EnableThreadSafety(). void ROOT::EnableThreadSafety ; (; ). Enable support for multi-threading within the ROOT code in particular, enables the global mutex to make ROOT thread safe/aware. ; Enables the global mutex to make ROOT thread safe/aware.; The following becomes safe:; concurrent construction and destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); concurrent usage of different ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; concurrent ca",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v628/namespaceROOT.html:25803,schedul,scheduler,25803,doc/v628/namespaceROOT.html,https://root.cern,https://root.cern/doc/v628/namespaceROOT.html,1,['schedul'],['scheduler']
Energy Efficiency,"The following objects and methods automatically take advantage of multi-threading if a call to EnableImplicitMT has been made before usage:. RDataFrame internally runs the event-loop by parallelizing over clusters of entries; TTree::GetEntry reads multiple branches in parallel; TTree::FlushBaskets writes multiple baskets to disk in parallel; TTreeCacheUnzip decompresses the baskets contained in a TTreeCache in parallel; THx::Fit performs in parallel the evaluation of the objective function over the data; TMVA::DNN trains the deep neural networks in parallel; TMVA::BDT trains the classifier in parallel and multiclass BDTs are evaluated in parallel. EnableImplicitMT calls in turn EnableThreadSafety. The 'numthreads' parameter allows to control the number of threads to be used by the implicit multi-threading. However, this parameter is just a hint for ROOT: it will try to satisfy the request if the execution scenario allows it. For example, if ROOT is configured to use an external scheduler, setting a value for 'numthreads' might not have any effect.; NoteUse DisableImplicitMT() to disable multi-threading (some locks will remain in place as described in EnableThreadSafety()). EnableImplicitMT(1) creates a thread-pool of size 1. ; Definition at line 527 of file TROOT.cxx. ◆ EnableThreadSafety(). void ROOT::EnableThreadSafety ; (; ). Enables the global mutex to make ROOT thread safe/aware. ; The following becomes safe:; concurrent construction and destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); concurrent usage of different ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; concurrent calls to the interpreter through gInterpreter; concurrent loading of ROOT plug-ins. In addition, gDirectory, gFile and gPad become ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v626/namespaceROOT.html:24041,schedul,scheduler,24041,doc/v626/namespaceROOT.html,https://root.cern,https://root.cern/doc/v626/namespaceROOT.html,1,['schedul'],['scheduler']
Energy Efficiency,"This is meant as a helper in writing thread-safe `Foreach`; 1629 /// actions when using `RDataFrame` after `ROOT::EnableImplicitMT()`.; 1630 /// The user-defined processing callable is able to follow different; 1631 /// *streams of processing* indexed by the first parameter.; 1632 /// `ForeachSlot` works just as well with single-thread execution: in that; 1633 /// case `slot` will always be `0`.; 1634 ///; 1635 /// ### Example usage:; 1636 /// ~~~{.cpp}; 1637 /// myDf.ForeachSlot([](unsigned int s, int i){ std::cout << ""Slot "" << s << "": ""<< i << std::endl;}, {""myIntColumn""});; 1638 /// ~~~; 1639 // clang-format on; 1640 template <typename F>; 1641 void ForeachSlot(F f, const ColumnNames_t &columns = {}); 1642 {; 1643 using ColTypes_t = TypeTraits::RemoveFirstParameter_t<typename TTraits::CallableTraits<F>::arg_types>;; 1644 constexpr auto nColumns = ColTypes_t::list_size;; 1645 ; 1646 const auto validColumnNames = GetValidatedColumnNames(nColumns, columns);; 1647 CheckAndFillDSColumns(validColumnNames, ColTypes_t());; 1648 ; 1649 using Helper_t = RDFInternal::ForeachSlotHelper<F>;; 1650 using Action_t = RDFInternal::RAction<Helper_t, Proxied>;; 1651 ; 1652 auto action = std::make_unique<Action_t>(Helper_t(std::move(f)), validColumnNames, fProxiedPtr, fColRegister);; 1653 ; 1654 fLoopManager->Run();; 1655 }; 1656 ; 1657 // clang-format off; 1658 ////////////////////////////////////////////////////////////////////////////; 1659 /// \brief Execute a user-defined reduce operation on the values of a column.; 1660 /// \tparam F The type of the reduce callable. Automatically deduced.; 1661 /// \tparam T The type of the column to apply the reduction to. Automatically deduced.; 1662 /// \param[in] f A callable with signature `T(T,T)`; 1663 /// \param[in] columnName The column to be reduced. If omitted, the first default column is used instead.; 1664 /// \return the reduced quantity wrapped in a ROOT::RDF:RResultPtr.; 1665 ///; 1666 /// A reduction takes two values of a colum",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RInterface_8hxx_source.html:92753,reduce,reduce,92753,doc/master/RInterface_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RInterface_8hxx_source.html,1,['reduce'],['reduce']
Energy Efficiency,"Tol = -1, . double ; relTol = -1, . unsigned int ; ncall = 0 . ). inlineexplicit . Generic constructor of multi dimensional Integrator. ; By default uses the Adaptive integration method; Parameters. typeintegration type (adaptive, MC methods, etc..) ; absToldesired absolute Error ; relToldesired relative Error ; ncallnumber of function calls (apply only to MC integration methods). In case no parameter values are passed the default ones used in IntegratorMultiDimOptions are used ; Definition at line 64 of file IntegratorMultiDim.h. ◆ IntegratorMultiDim() [2/3]. ROOT::Math::IntegratorMultiDim::IntegratorMultiDim ; (; const IMultiGenFunction & ; f, . IntegrationMultiDim::Type ; type = IntegrationMultiDim::kDEFAULT, . double ; absTol = -1, . double ; relTol = -1, . unsigned int ; ncall = 0 . ). inlineexplicit . Generic Constructor of multi dimensional Integrator passing a function. ; By default uses the adaptive integration method; Parameters. fintegration function (multi-dim interface) ; typeintegration type (adaptive, MC methods, etc..) ; absToldesired absolute Error ; relToldesired relative Error ; ncallnumber of function calls (apply only to MC integration methods) . Definition at line 79 of file IntegratorMultiDim.h. ◆ ~IntegratorMultiDim(). virtual ROOT::Math::IntegratorMultiDim::~IntegratorMultiDim ; (; ). inlinevirtual . Template Constructor of multi dimensional Integrator passing a generic function. ; By default uses the adaptive integration method; Parameters. fintegration function (generic function implementing operator()(const double *) ; dimfunction dimension ; typeintegration type (adaptive, MC methods, etc..) ; absToldesired absolute Error ; relToldesired relative Error ; ncallnumber of function calls (apply only to MC integration methods) destructor . Definition at line 105 of file IntegratorMultiDim.h. ◆ IntegratorMultiDim() [3/3]. ROOT::Math::IntegratorMultiDim::IntegratorMultiDim ; (; const IntegratorMultiDim & ; ). inlineprivate . Definition at line 1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1IntegratorMultiDim.html:5096,adapt,adaptive,5096,doc/master/classROOT_1_1Math_1_1IntegratorMultiDim.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1IntegratorMultiDim.html,1,['adapt'],['adaptive']
Energy Efficiency,"Tree file tree2.root; ; //create the file, the Tree and a few branches with; //a subset of gctrak; TFile f(""tree2.root"",""recreate"");; TTree t2(""t2"",""a Tree with data from a fake Geant3"");; Gctrak *gstep = new Gctrak;; t2.Branch(""track"",&gstep,8000,1);; ; //Initialize particle parameters at first point; Float_t px,py,pz,p,charge=0;; Float_t vout[7];; Float_t mass = 0.137;; Bool_t newParticle = kTRUE;; gstep->lmec = new Int_t[MAXMEC];; gstep->namec = new Int_t[MAXMEC];; gstep->step = 0.1;; gstep->destep = 0;; gstep->nmec = 0;; gstep->pid = 0;; ; //transport particles; for (Int_t i=0;i<10000;i++) {; //generate a new particle if necessary; if (newParticle) {; px = gRandom->Gaus(0,.02);; py = gRandom->Gaus(0,.02);; pz = gRandom->Gaus(0,.02);; p = TMath::Sqrt(px*px+py*py+pz*pz);; charge = 1; if (gRandom->Rndm() < 0.5) charge = -1;; gstep->pid += 1;; gstep->vect[0] = 0;; gstep->vect[1] = 0;; gstep->vect[2] = 0;; gstep->vect[3] = px/p;; gstep->vect[4] = py/p;; gstep->vect[5] = pz/p;; gstep->vect[6] = p*charge;; gstep->getot = TMath::Sqrt(p*p + mass*mass);; gstep->gekin = gstep->getot - mass;; newParticle = kFALSE;; }; ; // fill the Tree with current step parameters; t2.Fill();; ; //transport particle in magnetic field; helixStep(gstep->step, gstep->vect, vout); //make one step; ; //apply energy loss; gstep->destep = gstep->step*gRandom->Gaus(0.0002,0.00001);; gstep->gekin -= gstep->destep;; gstep->getot = gstep->gekin + mass;; gstep->vect[6] = charge*TMath::Sqrt(gstep->getot*gstep->getot - mass*mass);; gstep->vect[0] = vout[0];; gstep->vect[1] = vout[1];; gstep->vect[2] = vout[2];; gstep->vect[3] = vout[3];; gstep->vect[4] = vout[4];; gstep->vect[5] = vout[5];; gstep->nmec = (Int_t)(5*gRandom->Rndm());; for (Int_t l=0;l<gstep->nmec;l++) {; gstep->lmec[l] = l;; gstep->namec[l] = l+100;; }; if (gstep->gekin < 0.001) newParticle = kTRUE;; if (TMath::Abs(gstep->vect[2]) > 30) newParticle = kTRUE;; }; ; //save the Tree header. The file will be automatically closed; //when going o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tree2a_8C.html:3298,charge,charge,3298,doc/master/tree2a_8C.html,https://root.cern,https://root.cern/doc/master/tree2a_8C.html,2,['charge'],['charge']
Energy Efficiency,"TreeIndex.cxx. Member Function Documentation. ◆ Append(). void TTreeIndex::Append ; (; const TVirtualIndex * ; add, . bool ; delaySort = false . ). overridevirtual . Append 'add' to this index. ; Entry 0 in add will become entry n+1 in this. If delaySort is true, do not sort the value, then you must call Append(0,false); ; Implements TVirtualIndex.; Definition at line 240 of file TTreeIndex.cxx. ◆ Class(). static TClass * TTreeIndex::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TTreeIndex::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TTreeIndex::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 73 of file TTreeIndex.h. ◆ Clone(). TObject * TTreeIndex::Clone ; (; const char * ; newname = """"); const. overridevirtual . Create a deep copy of the TTreeIndex. ; Parameters. [in]newnameA new name for the index. The new index is allocated on the heap without being managed. Also, it is not attached to any tree. It is the responsibility of the caller to manage its lifetime and attach it to a tree if necessary. ; Reimplemented from TNamed.; Definition at line 650 of file TTreeIndex.cxx. ◆ ConvertOldToNew(). bool TTreeIndex::ConvertOldToNew ; (; ). conversion from old 64bit indexes return true if index was converted ; Definition at line 321 of file TTreeIndex.cxx. ◆ DeclFileName(). static const char * TTreeIndex::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 73 of file TTreeIndex.h. ◆ FindValues(). Long64_t TTreeIndex::FindValues ; (; Long64_t ; major, . Long64_t ; minor . ); const. find position where major|minor values are in the IndexValues tables this is the index in IndexValues table, not entry# ! use lower_bound STD algorithm. ; Definition at line 381 of file TTreeIndex.cxx. ◆ GetEntryNumberFriend(). Long64_t TTreeIndex::GetEntryNumberFriend ; (; const T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeIndex.html:18802,allocate,allocated,18802,doc/master/classTTreeIndex.html,https://root.cern,https://root.cern/doc/master/classTTreeIndex.html,1,['allocate'],['allocated']
Energy Efficiency,"TreeReader::h2TH2F * h2Definition h1analysisTreeReader.h:33; h1analysisTreeReader::fRendTTreeReaderArray< Float_t > fRendDefinition h1analysisTreeReader.h:27; h1analysisTreeReader::fEtads_dTTreeReaderValue< Float_t > fEtads_dDefinition h1analysisTreeReader.h:17; h1analysisTreeReader::hdmdTH1F * hdmdDefinition h1analysisTreeReader.h:32; h1analysisTreeReader::SlaveTerminatevoid SlaveTerminate() override; h1analysisTreeReader::fRstartTTreeReaderArray< Float_t > fRstartDefinition h1analysisTreeReader.h:26; h1analysisTreeReader::fDm_dTTreeReaderValue< Float_t > fDm_dDefinition h1analysisTreeReader.h:18; h1analysisTreeReader::fNlhkTTreeReaderArray< Float_t > fNlhkDefinition h1analysisTreeReader.h:28; h1analysisTreeReader::fPtds_dTTreeReaderValue< Float_t > fPtds_dDefinition h1analysisTreeReader.h:16; h1analysisTreeReader::Beginvoid Begin(TTree *) override; h1analysisTreeReader::Initvoid Init(TTree *myTree) overrideDefinition h1analysisTreeReader.h:67; lineTLine * lineDefinition entrylistblock_figure1.C:235; fdm5Double_t fdm5(Double_t *xx, Double_t *par)Definition h1analysisProxy.h:14; sigmaconst Double_t sigmaDefinition h1analysisProxy.h:11; dxbinconst Double_t dxbinDefinition h1analysisProxy.h:10; fdm2Double_t fdm2(Double_t *xx, Double_t *par)Definition h1analysisProxy.h:25; h1analysisTreeReader.h; c1return c1Definition legend1.C:41; xDouble_t x[n]Definition legend1.C:17; c2return c2Definition legend2.C:14; TMath::ExpDouble_t Exp(Double_t x)Returns the base-e exponential function of x, which is e raised to the power x.Definition TMath.h:709; TMath::PowerLongDouble_t Power(LongDouble_t x, LongDouble_t y)Returns x raised to the power y.Definition TMath.h:721; TMath::AbsShort_t Abs(Short_t d)Returns the absolute value of parameter Short_t d.Definition TMathBase.h:123; AuthorAnders Eie, 2013 ; Definition in file h1analysisTreeReader.C. tutorialstreeh1analysisTreeReader.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/h1analysisTreeReader_8C.html:17197,power,power,17197,doc/master/h1analysisTreeReader_8C.html,https://root.cern,https://root.cern/doc/master/h1analysisTreeReader_8C.html,2,['power'],['power']
Energy Efficiency,"Type _eMinimizerType=MinimizerType::fSteepest, double _learningRate=1e-5, double _momentum=0.3, int _repetitions=3, bool _useMultithreading=true);  c'tor ;  ; virtual ~ClassificationSettings ();  d'tor ;  ; virtual void endTestCycle ();  action to be done when the training cycle is ended (e.g. ;  ; void endTrainCycle (double);  action to be done when the training cycle is ended (e.g. ;  ; void setResultComputation (std::string _fileNameNetConfig, std::string _fileNameResult, std::vector< Pattern > *_resultPatternContainer);  preparation for monitoring output ;  ; void setWeightSums (double sumOfSigWeights, double sumOfBkgWeights);  set the weight sums to be scaled to (preparations for monitoring output) ;  ; virtual void startTestCycle ();  action to be done when the test cycle is started (e.g. ;  ; void startTrainCycle ();  action to be done when the training cycle is started (e.g. ;  ; void testIteration ();  callback for monitoring and loggging ;  ; void testSample (double error, double output, double target, double weight);  action to be done after the computation of a test sample (e.g. ;  ;  Public Member Functions inherited from TMVA::DNN::Settings;  Settings (TString name, size_t _convergenceSteps=15, size_t _batchSize=10, size_t _testRepetitions=7, double _factorWeightDecay=1e-5, TMVA::DNN::EnumRegularization _regularization=TMVA::DNN::EnumRegularization::NONE, MinimizerType _eMinimizerType=MinimizerType::fSteepest, double _learningRate=1e-5, double _momentum=0.3, int _repetitions=3, bool _multithreading=true);  c'tor ;  ; virtual ~Settings ();  d'tor ;  ; void addPoint (std::string histoName, double x);  for monitoring ;  ; void addPoint (std::string histoName, double x, double y);  for monitoring ;  ; size_t batchSize () const;  mini-batch size ;  ; void clear (std::string histoName);  for monitoring ;  ; virtual void computeResult (const Net &, std::vector< double > &);  callback for monitoring and logging ;  ; size_t convergenceCount () const;  returns t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1ClassificationSettings.html:1696,monitor,monitoring,1696,doc/master/classTMVA_1_1DNN_1_1ClassificationSettings.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1ClassificationSettings.html,1,['monitor'],['monitoring']
Energy Efficiency,"Type< vec, gen >;  ; class  AlgebraicProdType< vec, sym >;  ; class  AlgebraicSumType;  ; class  AlgebraicSumType< gen, vec >;  ; class  AlgebraicSumType< sym, vec >;  ; class  AlgebraicSumType< T, T >;  ; class  AlgebraicSumType< vec, gen >;  ; class  AlgebraicSumType< vec, sym >;  ; class  AnalyticalGradientCalculator;  ; class  BFGSErrorUpdator;  Update of the covariance matrix for the Variable Metric minimizer (MIGRAD) More...;  ; class  BFGSMinimizerType;  ; class  CombinedMinimizer;  Combined minimizer: combination of Migrad and Simplex. More...;  ; class  CombinedMinimumBuilder;  ; class  ContoursError;  ; class  DavidonErrorUpdator;  Update of the covariance matrix for the Variable Metric minimizer (MIGRAD) More...;  ; struct  DerivatorElement;  ; class  ExternalInternalGradientCalculator;  Similar to the AnalyticalGradientCalculator, the ExternalInternalGradientCalculator supplies Minuit with an externally calculated gradient. More...;  ; class  FCNAdapter;  template wrapped class for adapting to FCNBase signature More...;  ; class  FCNBase;  Interface (abstract class) defining the function to be minimized, which has to be implemented by the user. More...;  ; class  FCNGradAdapter;  template wrapped class for adapting to FCNBase signature a IGradFunction More...;  ; class  FCNGradientBase;  ; class  FumiliBuilder;  Builds the FunctionMinimum using the Fumili method. More...;  ; class  FumiliChi2FCN;  Extension of the FCNBase for the Fumili method. More...;  ; class  FumiliErrorUpdator;  In the case of the Fumili algorithm the Error matrix (or the Hessian matrix containing the (approximate) second derivatives) is calculated using a linearization of the model function negleting second derivatives. More...;  ; class  FumiliFCNAdapter;  template wrapped class for adapting to FumiliFCNBase signature More...;  ; class  FumiliFCNBase;  Extension of the FCNBase for the Fumili method. More...;  ; class  FumiliGradientCalculator;  Fumili gradient calculator using exte",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/namespaceROOT_1_1Minuit2.html:1711,adapt,adapting,1711,doc/v632/namespaceROOT_1_1Minuit2.html,https://root.cern,https://root.cern/doc/v632/namespaceROOT_1_1Minuit2.html,1,['adapt'],['adapting']
Energy Efficiency,"Type< vec, gen >;  ; class  AlgebraicProdType< vec, sym >;  ; class  AlgebraicSumType;  ; class  AlgebraicSumType< gen, vec >;  ; class  AlgebraicSumType< sym, vec >;  ; class  AlgebraicSumType< T, T >;  ; class  AlgebraicSumType< vec, gen >;  ; class  AlgebraicSumType< vec, sym >;  ; class  AnalyticalGradientCalculator;  ; class  BFGSErrorUpdator;  Update of the covariance matrix for the Variable Metric minimizer (MIGRAD) More...;  ; class  BFGSMinimizerType;  ; class  CombinedMinimizer;  Combined minimizer: combination of Migrad and Simplex. More...;  ; class  CombinedMinimumBuilder;  ; class  ContoursError;  ; class  DavidonErrorUpdator;  Update of the covariance matrix for the Variable Metric minimizer (MIGRAD) More...;  ; struct  DerivatorElement;  ; class  ExternalInternalGradientCalculator;  Similar to the AnalyticalGradientCalculator, the ExternalInternalGradientCalculator supplies Minuit with an externally calculated gradient. More...;  ; class  FCNAdapter;  template wrapped class for adapting to FCNBase signature More...;  ; class  FCNBase;  Interface (abstract class) defining the function to be minimized, which has to be implemented by the user. More...;  ; class  FCNGradAdapter;  template wrapped class for adapting to FCNBase signature a IGradFunction More...;  ; class  FCNGradientBase;  Extension of the FCNBase for providing the analytical Gradient of the function. More...;  ; class  FumiliBuilder;  Builds the FunctionMinimum using the Fumili method. More...;  ; class  FumiliChi2FCN;  Extension of the FCNBase for the Fumili method. More...;  ; class  FumiliErrorUpdator;  In the case of the Fumili algorithm the Error matrix (or the Hessian matrix containing the (approximate) second derivatives) is calculated using a linearization of the model function negleting second derivatives. More...;  ; class  FumiliFCNAdapter;  template wrapped class for adapting to FumiliFCNBase signature More...;  ; class  FumiliFCNBase;  Extension of the FCNBase for the Fumili m",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1Minuit2.html:1712,adapt,adapting,1712,doc/master/namespaceROOT_1_1Minuit2.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1Minuit2.html,1,['adapt'],['adapting']
Energy Efficiency,"Typedef Documentation. ◆ Size_T. using ROOT::Internal::VecOps::SmallVectorBase::Size_T = int32_t. Definition at line 142 of file RVec.hxx. Constructor & Destructor Documentation. ◆ SmallVectorBase() [1/2]. ROOT::Internal::VecOps::SmallVectorBase::SmallVectorBase ; (; ). protecteddelete . ◆ SmallVectorBase() [2/2]. ROOT::Internal::VecOps::SmallVectorBase::SmallVectorBase ; (; void * ; FirstEl, . size_t ; TotalCapacity . ). inlineprotected . Definition at line 156 of file RVec.hxx. Member Function Documentation. ◆ capacity(). size_t ROOT::Internal::VecOps::SmallVectorBase::capacity ; (; ); const. inlinenoexcept . Definition at line 175 of file RVec.hxx. ◆ empty(). bool ROOT::Internal::VecOps::SmallVectorBase::empty ; (; ); const. inline . Definition at line 177 of file RVec.hxx. ◆ grow_pod(). void ROOT::Internal::VecOps::SmallVectorBase::grow_pod ; (; void * ; FirstEl, . size_t ; MinSize, . size_t ; TSize . ). protected . This is an implementation of the grow() method which only works on POD-like data types and is out of line to reduce code duplication. ; This function will report a fatal error if it cannot increase capacity. ; Definition at line 51 of file RVec.cxx. ◆ Owns(). bool ROOT::Internal::VecOps::SmallVectorBase::Owns ; (; ); const. inlineprotected . If false, the RVec is in ""memory adoption"" mode, i.e. it is acting as a view on a memory buffer it does not own. ; Definition at line 171 of file RVec.hxx. ◆ report_at_maximum_capacity(). void ROOT::Internal::VecOps::SmallVectorBase::report_at_maximum_capacity ; (; ). staticprotected . Report that this vector is already at maximum capacity. ; Throws std::length_error or calls report_fatal_error. ; Definition at line 44 of file RVec.cxx. ◆ report_size_overflow(). void ROOT::Internal::VecOps::SmallVectorBase::report_size_overflow ; (; size_t ; MinSize). staticprotected . Report that MinSize doesn't fit into this vector's size type. ; Throws std::length_error or calls report_fatal_error. ; Definition at line 37 of f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Internal_1_1VecOps_1_1SmallVectorBase.html:2962,reduce,reduce,2962,doc/master/classROOT_1_1Internal_1_1VecOps_1_1SmallVectorBase.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Internal_1_1VecOps_1_1SmallVectorBase.html,1,['reduce'],['reduce']
Energy Efficiency,"UEUE); 19795 itmp = atoi(ctx->dd.config[CONNECTION_QUEUE_SIZE]);; 19796 if (itmp < 1) {; 19797 mg_cry_ctx_internal(ctx,; 19798 ""%s too small"",; 19799 config_options[CONNECTION_QUEUE_SIZE].name);; 19800 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19801 mg_snprintf(NULL,; 19802 NULL, /* No truncation check for error buffers */; 19803 error->text,; 19804 error->text_buffer_size,; 19805 ""Invalid configuration option value: %s"",; 19806 config_options[CONNECTION_QUEUE_SIZE].name);; 19807 }; 19808 free_context(ctx);; 19809 pthread_setspecific(sTlsKey, NULL);; 19810 return NULL;; 19811 }; 19812 ctx->squeue =; 19813 (struct socket *)mg_calloc((unsigned int)itmp, sizeof(struct socket));; 19814 if (ctx->squeue == NULL) {; 19815 mg_cry_ctx_internal(ctx,; 19816 ""Out of memory: Cannot allocate %s"",; 19817 config_options[CONNECTION_QUEUE_SIZE].name);; 19818 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19819 mg_snprintf(NULL,; 19820 NULL, /* No truncation check for error buffers */; 19821 error->text,; 19822 error->text_buffer_size,; 19823 ""Out of memory: Cannot allocate %s"",; 19824 config_options[CONNECTION_QUEUE_SIZE].name);; 19825 }; 19826 free_context(ctx);; 19827 pthread_setspecific(sTlsKey, NULL);; 19828 return NULL;; 19829 }; 19830 ctx->sq_size = itmp;; 19831#endif; 19832 ; 19833 /* Worker thread count option */; 19834 workerthreadcount = atoi(ctx->dd.config[NUM_THREADS]);; 19835 ; 19836 if ((workerthreadcount > MAX_WORKER_THREADS) || (workerthreadcount <= 0)) {; 19837 if (workerthreadcount <= 0) {; 19838 mg_cry_ctx_internal(ctx, ""%s"", ""Invalid number of worker threads"");; 19839 } else {; 19840 mg_cry_ctx_internal(ctx, ""%s"", ""Too many worker threads"");; 19841 }; 19842 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19843 mg_snprintf(NULL,; 19844 NULL, /* No truncation check for error buffers */; 19845 error->text,; 19846 error->text_buffer_size,; 19847 ""Invalid configuration option value: %s"",; 19848 config_options[NUM_THREADS].name);; 19849 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:592034,allocate,allocate,592034,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['allocate'],['allocate']
Energy Efficiency,"UEUE); 19796 itmp = atoi(ctx->dd.config[CONNECTION_QUEUE_SIZE]);; 19797 if (itmp < 1) {; 19798 mg_cry_ctx_internal(ctx,; 19799 ""%s too small"",; 19800 config_options[CONNECTION_QUEUE_SIZE].name);; 19801 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19802 mg_snprintf(NULL,; 19803 NULL, /* No truncation check for error buffers */; 19804 error->text,; 19805 error->text_buffer_size,; 19806 ""Invalid configuration option value: %s"",; 19807 config_options[CONNECTION_QUEUE_SIZE].name);; 19808 }; 19809 free_context(ctx);; 19810 pthread_setspecific(sTlsKey, NULL);; 19811 return NULL;; 19812 }; 19813 ctx->squeue =; 19814 (struct socket *)mg_calloc((unsigned int)itmp, sizeof(struct socket));; 19815 if (ctx->squeue == NULL) {; 19816 mg_cry_ctx_internal(ctx,; 19817 ""Out of memory: Cannot allocate %s"",; 19818 config_options[CONNECTION_QUEUE_SIZE].name);; 19819 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19820 mg_snprintf(NULL,; 19821 NULL, /* No truncation check for error buffers */; 19822 error->text,; 19823 error->text_buffer_size,; 19824 ""Out of memory: Cannot allocate %s"",; 19825 config_options[CONNECTION_QUEUE_SIZE].name);; 19826 }; 19827 free_context(ctx);; 19828 pthread_setspecific(sTlsKey, NULL);; 19829 return NULL;; 19830 }; 19831 ctx->sq_size = itmp;; 19832#endif; 19833 ; 19834 /* Worker thread count option */; 19835 workerthreadcount = atoi(ctx->dd.config[NUM_THREADS]);; 19836 ; 19837 if ((workerthreadcount > MAX_WORKER_THREADS) || (workerthreadcount <= 0)) {; 19838 if (workerthreadcount <= 0) {; 19839 mg_cry_ctx_internal(ctx, ""%s"", ""Invalid number of worker threads"");; 19840 } else {; 19841 mg_cry_ctx_internal(ctx, ""%s"", ""Too many worker threads"");; 19842 }; 19843 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19844 mg_snprintf(NULL,; 19845 NULL, /* No truncation check for error buffers */; 19846 error->text,; 19847 error->text_buffer_size,; 19848 ""Invalid configuration option value: %s"",; 19849 config_options[NUM_THREADS].name);; 19850 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:592067,allocate,allocate,592067,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['allocate'],['allocate']
Energy Efficiency,"UG???; 5175 // Allow TObject's to be registered again.; 5176 if(statsave) {; 5177 SetObjectStat(statsave);; 5178 }; 5179 ; 5180 } else {; 5181 Error(""New with placement"", ""This cannot happen!"");; 5182 }; 5183 ; 5184 return p;; 5185}; 5186 ; 5187////////////////////////////////////////////////////////////////////////////////; 5188/// Return a pointer to a newly allocated array of objects; 5189/// of this class.; 5190/// The class must have a default constructor. For meaning of; 5191/// defConstructor, see TClass::IsCallingNew().; 5192 ; 5193void *TClass::NewArray(Long_t nElements, ENewType defConstructor) const; 5194{; 5195 auto obj = NewObjectArray(nElements, defConstructor);; 5196 if (obj.GetPtr() && obj.GetAllocator()) {; 5197 // Register the object for special handling in the destructor.; 5198 RegisterAddressInRepository(""TClass::NewArray"", obj.GetPtr(), this);; 5199 }; 5200 return obj.GetPtr();; 5201}; 5202 ; 5203////////////////////////////////////////////////////////////////////////////////; 5204/// Return a pointer to a newly allocated array of objects; 5205/// of this class.; 5206/// The class must have a default constructor. For meaning of; 5207/// defConstructor, see TClass::IsCallingNew().; 5208 ; 5209TClass::ObjectPtr TClass::NewObjectArray(Long_t nElements, ENewType defConstructor) const; 5210{; 5211 ObjectPtr p;; 5212 ; 5213 if (fNewArray) {; 5214 // We have the new operator wrapper function,; 5215 // so there is a dictionary and it was generated; 5216 // by rootcint, so there should be a default; 5217 // constructor we can call through the wrapper.; 5218 {; 5219 TClass__GetCallingNewRAII callingNew(defConstructor);; 5220 p = fNewArray(nElements, nullptr);; 5221 }; 5222 if (!p) {; 5223 Error(""NewArray"", ""cannot create object of class %s version %d"", GetName(), fClassVersion);; 5224 }; 5225 } else if (HasInterpreterInfo()) {; 5226 // We have the dictionary but do not have the; 5227 // constructor wrapper, so the dictionary was; 5228 // not generated by r",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:198566,allocate,allocated,198566,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['allocate'],['allocated']
Energy Efficiency,"UG???; 5242 // Allow TObject's to be registered again.; 5243 if(statsave) {; 5244 SetObjectStat(statsave);; 5245 }; 5246 ; 5247 } else {; 5248 Error(""New with placement"", ""This cannot happen!"");; 5249 }; 5250 ; 5251 return p;; 5252}; 5253 ; 5254////////////////////////////////////////////////////////////////////////////////; 5255/// Return a pointer to a newly allocated array of objects; 5256/// of this class.; 5257/// The class must have a default constructor. For meaning of; 5258/// defConstructor, see TClass::IsCallingNew().; 5259 ; 5260void *TClass::NewArray(Long_t nElements, ENewType defConstructor) const; 5261{; 5262 auto obj = NewObjectArray(nElements, defConstructor);; 5263 if (obj.GetPtr() && obj.GetAllocator()) {; 5264 // Register the object for special handling in the destructor.; 5265 RegisterAddressInRepository(""TClass::NewArray"", obj.GetPtr(), this);; 5266 }; 5267 return obj.GetPtr();; 5268}; 5269 ; 5270////////////////////////////////////////////////////////////////////////////////; 5271/// Return a pointer to a newly allocated array of objects; 5272/// of this class.; 5273/// The class must have a default constructor. For meaning of; 5274/// defConstructor, see TClass::IsCallingNew().; 5275 ; 5276TClass::ObjectPtr TClass::NewObjectArray(Long_t nElements, ENewType defConstructor) const; 5277{; 5278 ObjectPtr p;; 5279 ; 5280 if (fNewArray) {; 5281 // We have the new operator wrapper function,; 5282 // so there is a dictionary and it was generated; 5283 // by rootcint, so there should be a default; 5284 // constructor we can call through the wrapper.; 5285 {; 5286 TClass__GetCallingNewRAII callingNew(defConstructor);; 5287 p = fNewArray(nElements, nullptr);; 5288 }; 5289 if (!p) {; 5290 Error(""NewArray"", ""cannot create object of class %s version %d"", GetName(), fClassVersion);; 5291 }; 5292 } else if (HasInterpreterInfo()) {; 5293 // We have the dictionary but do not have the; 5294 // constructor wrapper, so the dictionary was; 5295 // not generated by r",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:201317,allocate,allocated,201317,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['allocate'],['allocated']
Energy Efficiency,"UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. Float16_tfBx[0,0,10] X intercept at the vertex; Float16_tfBy[0,0,10] Y intercept at the vertex; Double32_tfCharge[-1,1,2] Charge of this track; Float16_tfMass2[0,0,8] The mass square of this particle; Float_tfMeanChargeMean charge deposition of all hits of this track; Int_tfNpointNumber of points for this track; Int_tfNspNumber of points for this track with a special value; Double32_t*fPointValue[fNsp][0,3] a special quantity for some point.; Float_tfPxX component of the momentum; Float_tfPyY component of the momentum; Float_tfPzZ component of the momentum; Float_tfRandomA random track quantity; TBitsfTriggerBitsBits triggered by this track.; Short_tfValidValidity criterion; Double32_tfVertex[3][-30,30,16] Track vertex position; Float16_tfXfirstX coordinate of the first point; Float16_tfXlastX coordinate of the last point; Float16_tfYfirstY coordinate of the first point; Float16_tfYlastY coordinate of the last point; Float16_tfZfirstZ coordinate of the first point; Float16_tfZlastZ coordinate of the last point. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Track(const Track& orig); Copy a track object. Track(Float_t random); Create a track object.; Note that ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/Track.html:8642,charge,charge,8642,root/html528/Track.html,https://root.cern,https://root.cern/root/html528/Track.html,1,['charge'],['charge']
Energy Efficiency,"ULong64(Int_t npar); Return field value as unsigned 64-bit integer. Double_t GetDouble(Int_t npar); Return field value as double. const char * GetString(Int_t npar); Return field value as string. Bool_t GetBinary(Int_t npar, void*& mem, Long_t& size); Return field value as binary array. Bool_t GetDate(Int_t npar, Int_t& year, Int_t& month, Int_t& day); Return field value as date. Bool_t GetTime(Int_t npar, Int_t& hour, Int_t& min, Int_t& sec); Return field value as time. Bool_t GetDatime(Int_t npar, Int_t& year, Int_t& month, Int_t& day, Int_t& hour, Int_t& min, Int_t& sec); Return field value as date & time. Bool_t GetTimestamp(Int_t npar, Int_t& year, Int_t& month, Int_t& day, Int_t& hour, Int_t& min, Int_t& sec, Int_t& ); Return field value as time stamp. Bool_t SetSQLParamType(Int_t npar, int sqltype, Bool_t sig, ULong_t sqlsize = 0); Set parameter type to be used as buffer.; Used in both setting data to database and retriving data from data base.; Initialize proper MYSQL_BIND structure and allocate required buffers. void * BeforeSet(const char* method, Int_t npar, Int_t sqltype, Bool_t sig = kTRUE, ULong_t size = 0); Check boundary condition before setting value of parameter.; Return address of parameter buffer. Bool_t SetNull(Int_t npar); Set NULL as parameter value.; If NULL should be set for statement parameter during first iteration,; one should call before proper Set... method to identify type of argument for; the future. For instance, if one suppose to have double as type of parameter,; code should look like:; stmt->SetDouble(2, 0.);; stmt->SetNull(2);. Bool_t SetInt(Int_t npar, Int_t value); Set parameter value as integer. Bool_t SetUInt(Int_t npar, UInt_t value); Set parameter value as unsigned integer. Bool_t SetLong(Int_t npar, Long_t value); Set parameter value as long integer. Bool_t SetLong64(Int_t npar, Long64_t value); Set parameter value as 64-bit integer. Bool_t SetULong64(Int_t npar, ULong64_t value); Set parameter value as unsigned 64-bit inte",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMySQLStatement.html:11744,allocate,allocate,11744,root/html534/TMySQLStatement.html,https://root.cern,https://root.cern/root/html534/TMySQLStatement.html,3,['allocate'],['allocate']
Energy Efficiency,"UserClass*);; MyClass(TRootIOCtor*);; MyClass(); // Or a constructor with all its arguments defaulted.; TRootIOCtorDefinition TRootIOCtor.h:33; When more than one pragma ioctortype is used, the first seen as priority For example with: #pragma link C++ ioctortype UserClass1;; #pragma link C++ ioctortype UserClass2;; We look in the following order: MyClass(UserClass1*);; MyClass(UserClass2*);; MyClass(TRootIOCtor*);; MyClass(); // Or a constructor with all its arguments defaulted. Definition at line 4978 of file TClass.cxx. ◆ New() [2/2]. void * TClass::New ; (; void * ; arena, . ENewType ; defConstructor = kClassNew . ); const. Return a pointer to a newly allocated object of this class. ; The class must have a default constructor. For meaning of defConstructor, see TClass::IsCallingNew(). ; Definition at line 5091 of file TClass.cxx. ◆ NewArray() [1/2]. void * TClass::NewArray ; (; Long_t ; nElements, . ENewType ; defConstructor = kClassNew . ); const. Return a pointer to a newly allocated array of objects of this class. ; The class must have a default constructor. For meaning of defConstructor, see TClass::IsCallingNew(). ; Definition at line 5193 of file TClass.cxx. ◆ NewArray() [2/2]. void * TClass::NewArray ; (; Long_t ; nElements, . void * ; arena, . ENewType ; defConstructor = kClassNew . ); const. Return a pointer to a newly allocated object of this class. ; The class must have a default constructor. For meaning of defConstructor, see TClass::IsCallingNew(). ; Definition at line 5295 of file TClass.cxx. ◆ NewObject() [1/2]. TClass::ObjectPtr TClass::NewObject ; (; ENewType ; defConstructor = kClassNew, . Bool_t ; quiet = kFALSE . ); const. Definition at line 4992 of file TClass.cxx. ◆ NewObject() [2/2]. TClass::ObjectPtr TClass::NewObject ; (; void * ; arena, . ENewType ; defConstructor = kClassNew . ); const. Return a pointer to a newly allocated object of this class. ; The class must have a default constructor. For meaning of defConstructor, see TClass::IsCa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTClass.html:106675,allocate,allocated,106675,doc/v632/classTClass.html,https://root.cern,https://root.cern/doc/v632/classTClass.html,1,['allocate'],['allocated']
Energy Efficiency,"UserClass*);; MyClass(TRootIOCtor*);; MyClass(); // Or a constructor with all its arguments defaulted.; TRootIOCtorDefinition TRootIOCtor.h:33; When more than one pragma ioctortype is used, the first seen as priority For example with: #pragma link C++ ioctortype UserClass1;; #pragma link C++ ioctortype UserClass2;; We look in the following order: MyClass(UserClass1*);; MyClass(UserClass2*);; MyClass(TRootIOCtor*);; MyClass(); // Or a constructor with all its arguments defaulted. Definition at line 5045 of file TClass.cxx. ◆ New() [2/2]. void * TClass::New ; (; void * ; arena, . ENewType ; defConstructor = kClassNew . ); const. Return a pointer to a newly allocated object of this class. ; The class must have a default constructor. For meaning of defConstructor, see TClass::IsCallingNew(). ; Definition at line 5158 of file TClass.cxx. ◆ NewArray() [1/2]. void * TClass::NewArray ; (; Long_t ; nElements, . ENewType ; defConstructor = kClassNew . ); const. Return a pointer to a newly allocated array of objects of this class. ; The class must have a default constructor. For meaning of defConstructor, see TClass::IsCallingNew(). ; Definition at line 5260 of file TClass.cxx. ◆ NewArray() [2/2]. void * TClass::NewArray ; (; Long_t ; nElements, . void * ; arena, . ENewType ; defConstructor = kClassNew . ); const. Return a pointer to a newly allocated object of this class. ; The class must have a default constructor. For meaning of defConstructor, see TClass::IsCallingNew(). ; Definition at line 5362 of file TClass.cxx. ◆ NewObject() [1/2]. TClass::ObjectPtr TClass::NewObject ; (; ENewType ; defConstructor = kClassNew, . Bool_t ; quiet = kFALSE . ); const. Definition at line 5059 of file TClass.cxx. ◆ NewObject() [2/2]. TClass::ObjectPtr TClass::NewObject ; (; void * ; arena, . ENewType ; defConstructor = kClassNew . ); const. Return a pointer to a newly allocated object of this class. ; The class must have a default constructor. For meaning of defConstructor, see TClass::IsCa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClass.html:106676,allocate,allocated,106676,doc/master/classTClass.html,https://root.cern,https://root.cern/doc/master/classTClass.html,1,['allocate'],['allocated']
Energy Efficiency,"UserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. private:. Int_tfColormap[64][3]colormap; Pixel_tfPixel[64]pixel values. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGColorPick(const TGWindow* p = 0, Int_t w = 1, Int_t h = 1, Int_t id = -1); TGColorPick constructor.; TGColorPick is a widget which allows a color to be picked from HLS space.; It consists of two elements: a color map window from where the user can; select the hue and saturation level of a color, and a slider to select; color's lightness. ~TGColorPick(); TGColorPick destructor. Bool_t HandleButton(Event_t* event); Handle mouse button events in color pick widget. Bool_t HandleMotion(Event_t* event); Handle mouse motion events in color pick widget. void CreateImages(); Create colormap and color slider images. void AllocColors(); Try to allocate first a palette of 64 colors. Used by the dithered; version of the color maps. void FreeColors(); Free allocated colors. void CreateDitheredImage(Pixmap_t image, Int_t which); Create a dithered version of the color map and lightness images for; display modes with reduced number of colors. The Floyd-Steinberg error; diffusion dithering algorithm is used.; This routine is called in PseudoColor modes only. void InitImages(); Initialize color palette and slider images. void SetSliderColor(); Set slider colors. void SetColor(Pixel_t color); Position the slider cursor on right color position. void UpdateCurrentColor(); Assign the current cursor position as currently selected color. void DoRedraw(); Redraw the color pick widget. void SetHScursor(Int_t x, Int_t y); Set hue / saturation cursor position. void SetLcursor(Int_t z); Set lightness slider cursor position. void DrawHScursor(Int_t onoff); Draw hue / saturation cursor. void DrawLcursor(Int_t onoff); Draw lightness slider cursor. Pixel_t GetCurrentColor() const. void ColorSelected(Pixel_t col = 0); { Emit(""ColorSelected(Pixel_t)"", col",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGColorPick.html:19667,allocate,allocated,19667,root/html528/TGColorPick.html,https://root.cern,https://root.cern/root/html528/TGColorPick.html,4,['allocate'],['allocated']
Energy Efficiency,"VA::BinaryTree::Log() const. private:. Double_tSamplePurity(TMVA::DecisionTree::EventList eventSample). Data Members; public:. static TMVA::DecisionTree::EPruneMethodkCostComplexityPruning; static TMVA::DecisionTree::EPruneMethodkExpectedErrorPruning; static TMVA::DecisionTree::EPruneMethodkNoPruning. protected:. UInt_tTMVA::BinaryTree::fDepthmaximal depth in tree reached; UInt_tTMVA::BinaryTree::fNNodestotal number of nodes in the tree (counted); TMVA::Node*TMVA::BinaryTree::fRootthe root node of the tree. private:. TMVA::Types::EAnalysisTypefAnalysisTypekClassification(=0=false) or kRegression(=1=true); TMVA::DataSetInfo*fDataSetInfo; UInt_tfMaxDepthmax depth; Double_tfMinLinCorrForFisherthe minimum linear correlation between two variables demanded for use in fisher criterium in node splitting; Double_tfMinNodeSizemin fraction of training events in node; Double_tfMinSepGainmin number of separation gain to perform node splitting; Double_tfMinSizemin number of events in node; TRandom3*fMyTrandomrandom number generator for randomised trees; Int_tfNCutsnumber of grid point in variable cut scans; Int_tfNNodesBeforePruningremember this one (in case of pruning, it allows to monitor the before/after; Double_tfNodePurityLimitpurity limit to decide whether a node is signal; UInt_tfNvarsnumber of variables used to separate S and B; TMVA::DecisionTree::EPruneMethodfPruneMethodmethod used for prunig; Double_tfPruneStrengtha parameter to set the ""amount"" of pruning..needs to be adjusted; Bool_tfRandomisedTreechoose at each node splitting a random set of variables; TMVA::RegressionVariance*fRegTypethe separation crition used in Regression; TMVA::SeparationBase*fSepTypethe separation crition; UInt_tfSigClassclass which is treated as signal when building the tree; Int_tfTreeIDjust an ID number given to the tree.. makes debugging easier as tree knows who he is.; Bool_tfUseExclusiveVarsindividual variables already used in fisher criterium are not anymore analysed individually for no",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__DecisionTree.html:7227,monitor,monitor,7227,root/html602/TMVA__DecisionTree.html,https://root.cern,https://root.cern/root/html602/TMVA__DecisionTree.html,2,['monitor'],['monitor']
Energy Efficiency,"VA::MethodPDERS, TMVA::MethodRuleFit, TMVA::MethodSVM, and TMVA::MethodTMlpANN. ◆ TrainingEnded(). bool TMVA::MethodBase::TrainingEnded ; (; ). inline . Definition at line 469 of file MethodBase.h. ◆ TrainMethod(). void TMVA::MethodBase::TrainMethod ; (; ). Definition at line 650 of file MethodBase.cxx. ◆ TxtWeightsOnly(). Bool_t TMVA::MethodBase::TxtWeightsOnly ; (; ); const. inlineprotected . Definition at line 534 of file MethodBase.h. ◆ Verbose(). Bool_t TMVA::MethodBase::Verbose ; (; ); const. inlineprotected . Definition at line 503 of file MethodBase.h. ◆ WriteEvaluationHistosToFile(). void TMVA::MethodBase::WriteEvaluationHistosToFile ; (; Types::ETreeType ; treetype). virtual . writes all MVA evaluation histograms to file ; Reimplemented in TMVA::MethodBoost.; Definition at line 2094 of file MethodBase.cxx. ◆ WriteMonitoringHistosToFile(). void TMVA::MethodBase::WriteMonitoringHistosToFile ; (; void ; ); const. virtual . write special monitoring histograms to file dummy implementation here --------------— ; Implements TMVA::IMethod.; Reimplemented in TMVA::MethodANNBase, TMVA::MethodLikelihood, TMVA::MethodBDT, TMVA::MethodBoost, TMVA::MethodCrossValidation, TMVA::MethodCuts, and TMVA::MethodRuleFit.; Definition at line 2133 of file MethodBase.cxx. ◆ WriteStateToFile(). void TMVA::MethodBase::WriteStateToFile ; (; ); const. write options and weights to file note that each one text file for the main configuration information and one ROOT file for ROOT objects are created ; Definition at line 1404 of file MethodBase.cxx. ◆ WriteStateToStream(). void TMVA::MethodBase::WriteStateToStream ; (; std::ostream & ; tf); const. private . general method used in writing the header of the weight files where the used variables, variable transformation type etc. ; is specified ; Definition at line 1267 of file MethodBase.cxx. ◆ WriteStateToXML(). void TMVA::MethodBase::WriteStateToXML ; (; void * ; parent); const. private . general method used in writing the header of the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodBase.html:78577,monitor,monitoring,78577,doc/master/classTMVA_1_1MethodBase.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodBase.html,1,['monitor'],['monitoring']
Energy Efficiency,"VC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::MethodPDERS. class TMVA::MethodPDERS: public TMVA::MethodBase. /*; This is a generalization of the above Likelihood methods to Nvar; dimensions, where Nvar is the number of input variables; used in the MVA. If the multi-dimensional probability density functions; (PDFs) for signal and background were known, this method contains the entire; physical information, and is therefore optimal. Usually, kernel estimation; methods are used to approximate the PDFs using the events from the; training sample. ; A very simple probability density estimator (PDE) has been suggested; in hep-ex/0211019. The; PDE for a given test event is obtained from counting the (normalized); number of signal and background (training) events that occur in the; ""vicinity"" of the test event. The volume that describes ""vicinity"" is; user-defined. A search; method based on binary-trees is used to effectively reduce the; selection time for the range search. Three different volume definitions; are optional: . MinMax:; the volume is defined in each dimension with respect; to the full variable range found in the training sample. ; RMS:; the volume is defined in each dimensions with respect; to the RMS estimated from the training sample. ; Adaptive:; a volume element is defined in each dimensions with; respect to the RMS estimated from the training sample. The overall; scale of the volume element is then determined for each event so; that the total number of events confined in the volume be within; a user-defined range. The adaptive range search is used by default.; . Function Members (Methods); public:. virtual~MethodPDERS(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType); virtual voidAddWeightsXMLTo(void* parent) cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MethodPDERS.html:1135,reduce,reduce,1135,root/html528/TMVA__MethodPDERS.html,https://root.cern,https://root.cern/root/html528/TMVA__MethodPDERS.html,5,['reduce'],['reduce']
Energy Efficiency,"Var bias2(""bias2"", ""bias2"", 0);; RooRealVar sigma2(""sigma2"", ""sigma2"", 5);; RooGaussModel gm2(""gm2"", ""gauss model 2"", dt, bias2, sigma2);; ; // Build a composite resolution model f*gm1+(1-f)*gm2; RooRealVar gm1frac(""gm1frac"", ""fraction of gm1"", 0.5);; RooAddModel gmsum(""gmsum"", ""sum of gm1 and gm2"", RooArgList(gm1, gm2), gm1frac);; ; // Construct decay(t) (x) (f*gm1 + (1-f)*gm2); RooDecay decay_gmsum(""decay_gmsum"", ""decay"", dt, tau, gmsum, RooDecay::DoubleSided);; ; // Plot pdf (red); decay_gmsum.plotOn(frame, LineColor(kRed));; ; // Draw all frames on canvas; new TCanvas(""rf209_anaconv"", ""rf209_anaconv"", 600, 600);; gPad->SetLeftMargin(0.15);; frame->GetYaxis()->SetTitleOffset(1.6);; frame->Draw();; }; RooAddModel.h; RooDataSet.h; RooDecay.h; RooGaussModel.h; RooPlot.h; RooRealVar.h; RooTruthModel.h; kRed@ kRedDefinition Rtypes.h:66; kDashed@ kDashedDefinition TAttLine.h:48; TAxis.h; TCanvas.h; TH1.h; gPad#define gPadDefinition TVirtualPad.h:308; RooAddModelRooAddModel is an efficient implementation of a sum of PDFs of the form.Definition RooAddModel.h:27; RooArgListRooArgList is a container object that can hold multiple RooAbsArg objects.Definition RooArgList.h:22; RooDecaySingle or double sided decay function that can be analytically convolved with any RooResolutionModel ...Definition RooDecay.h:22; RooDecay::DoubleSided@ DoubleSidedDefinition RooDecay.h:25; RooGaussModelClass RooGaussModel implements a RooResolutionModel that models a Gaussian distribution.Definition RooGaussModel.h:25; RooPlotPlot frame and a container for graphics objects within that frame.Definition RooPlot.h:45; RooPlot::framestatic RooPlot * frame(const RooAbsRealLValue &var, double xmin, double xmax, Int_t nBins)Create a new frame for a given variable in x.Definition RooPlot.cxx:225; RooPlot::GetYaxisTAxis * GetYaxis() constDefinition RooPlot.cxx:1264; RooPlot::Drawvoid Draw(Option_t *options=nullptr) overrideDraw this plot and all of the elements it contains.Definition RooPlot.cxx:637; Ro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf209__anaconv_8C.html:3306,efficient,efficient,3306,doc/master/rf209__anaconv_8C.html,https://root.cern,https://root.cern/doc/master/rf209__anaconv_8C.html,1,['efficient'],['efficient']
Energy Efficiency,"Virtual(TBuffer& b); voidSumw2(); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. THnSparseArrayChunk*AddChunk(); voidAddInternal(const THnSparse* h, Double_t c, Bool_t rebinned); Bool_tCheckConsistency(const THnSparse* h, const char* tag) const; THnSparse*CloneEmpty(const char* name, const char* title, const TObjArray* axes, Int_t chunksize, Bool_t keepTargetAxis) const; TH1*CreateHist(const char* name, const char* title, const TObjArray* axes, Bool_t keepTargetAxis) const; virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; Long64_tFill(Long64_t bin, Double_t w); voidFillExMap(); virtual TArray*GenerateArray() const; Long64_tGetBinIndexForCurrentBin(Bool_t allocate); THnSparseArrayChunk*GetChunk(Int_t idx) const; Int_tGetChunkSize() const; THnSparseCompactBinCoord*GetCompactCoord() const; Bool_tIsInRange(Int_t* coord) const; voidTObject::MakeZombie(); Bool_tPrintBin(Long64_t idx, Int_t* coord, Option_t* options) const; TObject*ProjectionAny(Int_t ndim, const Int_t* dim, Bool_t wantSparse, Option_t* option = """") const. private:. THnSparse&operator=(const THnSparse&). Data Members; public:. enum { kNoInt; kValidInt; kInvalidInt; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TObjArrayfAxesaxes of the histogram",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/THnSparse.html:12635,allocate,allocate,12635,root/html528/THnSparse.html,https://root.cern,https://root.cern/root/html528/THnSparse.html,3,['allocate'],['allocate']
Energy Efficiency,"VirtualCollectionProxy.; Definition at line 993 of file TGenCollectionProxy.cxx. ◆ GetConversionReadMemberWiseActions(). TStreamerInfoActions::TActionSequence * TGenCollectionProxy::GetConversionReadMemberWiseActions ; (; TClass * ; oldClass, . Int_t ; version . ). overridevirtual . Return the set of action necessary to stream in this collection member-wise coming from the old value class layout refered to by 'version'. ; Implements TVirtualCollectionProxy.; Definition at line 1747 of file TGenCollectionProxy.cxx. ◆ GetFunctionCopyIterator(). TVirtualCollectionProxy::CopyIterator_t TGenCollectionProxy::GetFunctionCopyIterator ; (; Bool_t ; read = kTRUE). overridevirtual . See typedef void (*CopyIterator_t)(void *&dest, const void *source); Copy the iterator source, into dest. ; dest should contain should contain the location of memory arena of size fgIteratorSize. If the collection iterator are of that size or less, the iterator will be constructed in place in this location (new with placement) Otherwise the iterator will be allocated via a regular new and its address returned by modifying the value of dest. ; Implements TVirtualCollectionProxy.; Definition at line 1642 of file TGenCollectionProxy.cxx. ◆ GetFunctionCreateIterators(). TVirtualCollectionProxy::CreateIterators_t TGenCollectionProxy::GetFunctionCreateIterators ; (; Bool_t ; read = kTRUE). overridevirtual . See typedef void (*CreateIterators_t)(void *collection, void *&begin_arena, void *&end_arena); begin_arena and end_arena should contain the location of memory arena of size fgIteratorSize. ; If the collection iterator are of that size or less, the iterators will be constructed in place in those location (new with placement) Otherwise the iterators will be allocated via a regular new and their address returned by modifying the value of begin_arena and end_arena. ; Implements TVirtualCollectionProxy.; Definition at line 1607 of file TGenCollectionProxy.cxx. ◆ GetFunctionDeleteIterator(). TVirtualCollecti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGenCollectionProxy.html:18751,allocate,allocated,18751,doc/master/classTGenCollectionProxy.html,https://root.cern,https://root.cern/doc/master/classTGenCollectionProxy.html,1,['allocate'],['allocated']
Energy Efficiency,"VirtualXProxy::TGWin32VirtualXProxy ; (; const char * ; name, . const char * ; title . ). inline . Definition at line 39 of file TGWin32VirtualXProxy.h. ◆ ~TGWin32VirtualXProxy(). TGWin32VirtualXProxy::~TGWin32VirtualXProxy ; (; ). inlineoverride . Definition at line 40 of file TGWin32VirtualXProxy.h. Member Function Documentation. ◆ AddWindow(). Int_t TGWin32VirtualXProxy::AddWindow ; (; ULongptr_t ; qwid, . UInt_t ; w, . UInt_t ; h . ). overridevirtual . Registers a window created by Qt as a ROOT window. ; Parameters. [in]qwidwindow identifier ; [in]w,hthe width and height, which define the window size . Reimplemented from TVirtualX. ◆ AllocColor(). Bool_t TGWin32VirtualXProxy::AllocColor ; (; Colormap_t ; cmap, . ColorStruct_t & ; color . ). overridevirtual . Allocates a read-only colormap entry corresponding to the closest RGB value supported by the hardware. ; If no cell could be allocated it returns kFALSE, otherwise kTRUE.; The pixel value is set to default. Let system think we could allocate color.; Parameters. [in]cmapthe colormap ; [in]colorspecifies and returns the values actually used in the cmap . Reimplemented from TVirtualX. ◆ Bell(). void TGWin32VirtualXProxy::Bell ; (; Int_t ; percent). overridevirtual . Sets the sound bell. Percent is loudness from -100% to 100%. ; Reimplemented from TVirtualX. ◆ ChangeActivePointerGrab(). void TGWin32VirtualXProxy::ChangeActivePointerGrab ; (; Window_t ; , . UInt_t ; , . Cursor_t ;  . ). overridevirtual . Changes the specified dynamic parameters if the pointer is actively grabbed by the client and if the specified time is no earlier than the last-pointer-grab time and no later than the current X server time. ; Reimplemented from TVirtualX. ◆ ChangeGC(). void TGWin32VirtualXProxy::ChangeGC ; (; GContext_t ; gc, . GCValues_t * ; gval . ). overridevirtual . Changes the components specified by the mask in gval for the specified GC. ; Parameters. [in]gcspecifies the GC to be changed ; [in]gvalspecifies the mask and the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGWin32VirtualXProxy.html:53168,allocate,allocate,53168,doc/master/classTGWin32VirtualXProxy.html,https://root.cern,https://root.cern/doc/master/classTGWin32VirtualXProxy.html,1,['allocate'],['allocate']
Energy Efficiency,"When the T2 branch is created, the StreamerInfo for the class Bar; is created with no optimization (mandatory for the split mode).; The optimized Bar StreamerInfo is going to be used to read; the TClonesArray in T1. The result will be Bar objects with; data member values not in the right sequence.; The solution to this problem is to call BypassStreamer(kFALSE); for the TClonesArray. In this case, the normal Bar::Streamer function; will be called. The Bar::Streamer function works OK independently; if the Bar StreamerInfo had been generated in optimized mode or not. void Compress(); Remove empty slots from array. void Clear(Option_t* option = """"); Clear the clones array. Only use this routine when your objects don't; allocate memory since it will not call the object dtors.; However, if the class in the TClonesArray implements the function; Clear(Option_t *option) and if option = ""C"" the function Clear(); is called for all objects in the array. In the function Clear(), one; can delete objects or dynamic arrays allocated in the class.; This procedure is much faster than calling TClonesArray::Delete(). void Delete(Option_t* option = """"); Clear the clones array. Use this routine when your objects allocate; memory (e.g. objects inheriting from TNamed or containing TStrings; allocate memory). If not you better use Clear() since if is faster. void Expand(Int_t newSize); Expand or shrink the array to newSize elements. void ExpandCreate(Int_t n); Expand or shrink the array to n elements and create the clone; objects by calling their default ctor. If n is less than the current size; the array is shrinked and the allocated space is freed.; This routine is typically used to create a clonesarray into which; one can directly copy object data without going via the; ""new (arr[i]) MyObj()"" (i.e. the vtbl is already set correctly). void ExpandCreateFast(Int_t n); Expand or shrink the array to n elements and create the clone; objects by calling their default ctor. If n is less than the c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TClonesArray.html:14701,allocate,allocated,14701,root/html526/TClonesArray.html,https://root.cern,https://root.cern/root/html526/TClonesArray.html,1,['allocate'],['allocated']
Energy Efficiency,"When the T2 branch is created, the StreamerInfo for the class Bar; is created with no optimization (mandatory for the split mode).; The optimized Bar StreamerInfo is going to be used to read; the TClonesArray in T1. The result will be Bar objects with; data member values not in the right sequence.; The solution to this problem is to call BypassStreamer(kFALSE); for the TClonesArray. In this case, the normal Bar::Streamer function; will be called. The Bar::Streamer function works OK independently; if the Bar StreamerInfo had been generated in optimized mode or not. void Compress(); Remove empty slots from array. void Clear(Option_t* option = """"); Clear the clones array. Only use this routine when your objects don't; allocate memory since it will not call the object dtors.; However, if the class in the TClonesArray implements the function; Clear(Option_t *option) and if option = ""C"" the function Clear(); is called for all objects in the array. In the function Clear(), one; can delete objects or dynamic arrays allocated in the class.; This procedure is much faster than calling TClonesArray::Delete().; When the option starts with ""C+"", eg ""C+xyz"" the objects in the array; are in turn cleared with the option ""xyz"". void Delete(Option_t* option = """"); Clear the clones array. Use this routine when your objects allocate; memory (e.g. objects inheriting from TNamed or containing TStrings; allocate memory). If not you better use Clear() since if is faster. void Expand(Int_t newSize); Expand or shrink the array to newSize elements. void ExpandCreate(Int_t n); Expand or shrink the array to n elements and create the clone; objects by calling their default ctor. If n is less than the current size; the array is shrinked and the allocated space is freed.; This routine is typically used to create a clonesarray into which; one can directly copy object data without going via the; ""new (arr[i]) MyObj()"" (i.e. the vtbl is already set correctly). void ExpandCreateFast(Int_t n); Expand or ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TClonesArray.html:17354,allocate,allocated,17354,root/html528/TClonesArray.html,https://root.cern,https://root.cern/root/html528/TClonesArray.html,2,['allocate'],['allocated']
Energy Efficiency,"Win32VirtualXProxy.cxx:68; namechar name[80]Definition TGX11.cxx:110; THttpEngine.h; THttpLongPollEngine.h; THttpServer.h; THttpWSHandler.h; TObjArray.h; gDebugInt_t gDebugDefinition TROOT.cxx:597; TROOT.h; gROOT#define gROOTDefinition TROOT.h:406; TRegexp.h; TRootSnifferStore.h; TRootSniffer.h; TSystem.h; gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:561; TThread.h; TTimer.h; TUrl.h; mime_typeconst char * mime_typeDefinition civetweb.c:8027; ext_lensize_t ext_lenDefinition civetweb.c:8026; free#define freeDefinition civetweb.c:1539; extensionconst char * extensionDefinition civetweb.c:8025; builtin_mime_typesstatic const struct @142 builtin_mime_types[]; malloc#define mallocDefinition civetweb.c:1536; TCivetwebTHttpEngine implementation, based on civetweb embedded server.Definition TCivetweb.h:21; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClass::Newvoid * New(ENewType defConstructor=kClassNew, Bool_t quiet=kFALSE) constReturn a pointer to a newly allocated object of this class.Definition TClass.cxx:5045; TClass::LoadClassstatic TClass * LoadClass(const char *requestedname, Bool_t silent)Helper function used by TClass::GetClass().Definition TClass.cxx:5816; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:3035; TEnv::GetValuevirtual Int_t GetValue(const char *name, Int_t dflt) constReturns the integer value for a resource.Definition TEnv.cxx:491; TFastCgiTHttpEngine implementation, based on fastcgi package.Definition TFastCgi.h:20; THttpCallArgContains arguments for single HTTP call.Definition THttpCallArg.h:27; THttpCallArg::Set404void Set404()mark reply as 404 error - page/request not exists or refusedDefinition THttpCallArg.h:163; THttpCallArg::kZipAlways@ kZipAlwaysDefinition THttpCallArg.h:38; THttpEngineAbstract class for implementing http p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THttpServer_8cxx_source.html:55442,allocate,allocated,55442,doc/master/THttpServer_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THttpServer_8cxx_source.html,1,['allocate'],['allocated']
Energy Efficiency,"WorkMax. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void TMatrixTSparse<Element> Allocate(Int_t nrows, Int_t ncols, Int_t row_lwb = 0, Int_t col_lwb = 0, Int_t init = 0, Int_t nr_nonzeros = 0); Allocate new matrix. Arguments are number of rows, columns, row lowerbound (0 default); and column lowerbound (0 default), 0 initialization flag and number of non-zero; elements (only relevant for sparse format). TMatrixTBase<Element> &TMatrixTSparse<Element> InsertRow(Int_t row, Int_t col, const double* v, Int_t n = -1); Insert in row rown, n elements of array v at column coln. void TMatrixTSparse<Element> ExtractRow(Int_t row, Int_t col, double* v, Int_t n = -1) const; Store in array v, n matrix elements of row rown starting at column coln. void TMatrixTSparse<Element> AMultBt(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMultBt(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMultBt(const TMatrixT<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixTSparse<Element> &a,const TMatrixT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMatrixTSparse_double_.html:18767,allocate,allocated,18767,root/html602/TMatrixTSparse_double_.html,https://root.cern,https://root.cern/root/html602/TMatrixTSparse_double_.html,2,['allocate'],['allocated']
Energy Efficiency,"Wrap a ROOT Function class (like TF1) in a IParamFunction interface of one dimensions to be used in the ROOT::Math numerical algorithms The wrapper does not own bby default the TF1 pointer, so it assumes it exists during the wrapper lifetime. More...;  . Typedefs; typedef TRandomEngine DefaultEngineType;  Documentation for the RandomFunction class. ;  ; typedef BasicFitMethodFunction< ROOT::Math::IMultiGenFunction > FitMethodFunction;  ; typedef BasicFitMethodFunction< ROOT::Math::IMultiGradFunction > FitMethodGradFunction;  ; typedef double(* FreeFunctionPtr) (double);  ; typedef double(* FreeMultiFunctionPtr) (const double *);  ; typedef double(* FreeParamMultiFunctionPtr) (const double *, const double *);  ; typedef void(* GSLFdfPointer) (double, void *, double *, double *);  ; typedef double(* GSLFuncPointer) (double, void *);  Function pointer corresponding to gsl_function signature. ;  ; typedef double(* GSLMonteFuncPointer) (double *, size_t, void *);  Class for adapting any multi-dimension C++ functor class to C function pointers used by GSL MonteCarlo integration algorithms. ;  ; typedef void(* GSLMultiFitDfPointer) (const gsl_vector *, void *, gsl_matrix *);  ; typedef void(* GSLMultiFitFdfPointer) (const gsl_vector *, void *, gsl_vector *, gsl_matrix *);  ; typedef double(* GSLMultiFitFPointer) (const gsl_vector *, void *, gsl_vector *);  ; typedef void(* GSLMultiMinDfPointer) (const gsl_vector *, void *, gsl_vector *);  ; typedef void(* GSLMultiMinFdfPointer) (const gsl_vector *, void *, double *, gsl_vector *);  ; typedef double(* GSLMultiMinFuncPointer) (const gsl_vector *, void *);  ; typedef void(* GSLMultiRootDfPointer) (const gsl_vector *, void *, gsl_matrix *);  ; typedef void(* GSLMultiRootFdfPointer) (const gsl_vector *, void *, gsl_vector *, gsl_matrix *);  ; typedef double(* GSLMultiRootFPointer) (const gsl_vector *, void *, gsl_vector *);  ; typedef GSLRngRanLuxS1 GSLRngRanLux1;  ; typedef GSLRngRanLuxS2 GSLRngRanLux2;  ; typedef GSLRngRanLuxD",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1Math.html:35712,adapt,adapting,35712,doc/master/namespaceROOT_1_1Math.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1Math.html,2,['adapt'],['adapting']
Energy Efficiency,"X**2 + Y**2 + Z**2 ); 314 */; 315 Scalar P2() const { return P() * P(); }; 316 /**; 317 return the square of the transverse spatial component ( X**2 + Y**2 ); 318 */; 319 Scalar Perp2( ) const { return fCoordinates.Perp2();}; 320 ; 321 /**; 322 return the transverse spatial component sqrt ( X**2 + Y**2 ); 323 */; 324 Scalar Pt() const { return fCoordinates.Pt(); }; 325 Scalar Rho() const { return fCoordinates.Pt(); }; 326 ; 327 /**; 328 return the transverse mass squared; 329 \f[ m_t^2 = E^2 - p{_z}^2 \f]; 330 */; 331 Scalar Mt2() const { return fCoordinates.Mt2(); }; 332 ; 333 /**; 334 return the transverse mass; 335 \f[ \sqrt{ m_t^2 = E^2 - p{_z}^2} X sign(E^ - p{_z}^2) \f]; 336 */; 337 Scalar Mt() const { return fCoordinates.Mt(); }; 338 ; 339 /**; 340 return the transverse energy squared; 341 \f[ e_t = \frac{E^2 p_{\perp}^2 }{ |p|^2 } \f]; 342 */; 343 Scalar Et2() const { return fCoordinates.Et2(); }; 344 ; 345 /**; 346 return the transverse energy; 347 \f[ e_t = \sqrt{ \frac{E^2 p_{\perp}^2 }{ |p|^2 } } X sign(E) \f]; 348 */; 349 Scalar Et() const { return fCoordinates.Et(); }; 350 ; 351 /**; 352 azimuthal Angle; 353 */; 354 Scalar Phi() const { return fCoordinates.Phi();}; 355 ; 356 /**; 357 polar Angle; 358 */; 359 Scalar Theta() const { return fCoordinates.Theta(); }; 360 ; 361 /**; 362 pseudorapidity; 363 \f[ \eta = - \ln { \tan { \frac { \theta} {2} } } \f]; 364 */; 365 Scalar Eta() const { return fCoordinates.Eta(); }; 366 ; 367 /**; 368 get the spatial components of the Vector in a; 369 DisplacementVector based on Cartesian Coordinates; 370 */; 371 ::ROOT::Math::DisplacementVector3D<Cartesian3D<Scalar> > Vect() const {; 372 return ::ROOT::Math::DisplacementVector3D<Cartesian3D<Scalar> >( X(), Y(), Z() );; 373 }; 374 ; 375 // ------ Operations combining two Lorentz vectors ------; 376 ; 377 /**; 378 scalar (Dot) product of two LorentzVector vectors (metric is -,-,-,+); 379 Enable the product using any other LorentzVector implementing; 380 the x(), y() , y",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/GenVector_2LorentzVector_8h_source.html:11415,energy,energy,11415,doc/master/GenVector_2LorentzVector_8h_source.html,https://root.cern,https://root.cern/doc/master/GenVector_2LorentzVector_8h_source.html,1,['energy'],['energy']
Energy Efficiency,"Zh. Eksp. Teor. Fiz. 32 (1957) 920].; The probability density function of the Vavilov distribution as function of Landau's parameter is given by: ; \[ p(\lambda_L; \kappa, \beta^2) =; \frac{1}{2 \pi i}\int_{c-i\infty}^{c+i\infty} \phi(s) e^{\lambda_L s} ds\]. where \(\phi(s) = e^{C} e^{\psi(s)}\) with \( C = \kappa (1+\beta^2 \gamma )\) and \(\psi(s)= s \ln \kappa + (s+\beta^2 \kappa); \cdot \left ( \int \limits_{0}^{1}; \frac{1 - e^{\frac{-st}{\kappa}}}{t} \,d t- \gamma \right ); - \kappa \, e^{\frac{-s}{\kappa}}\). \( \gamma = 0.5772156649\dots\) is Euler's constant.; For the class Vavilov, Pdf returns the Vavilov distribution as function of Landau's parameter \(\lambda_L = \lambda_V/\kappa - \ln \kappa\), which is the convention used in the CERNLIB routines, and in the tables by S.M. Seltzer and M.J. Berger: Energy loss stragglin of protons and mesons: Tabulation of the Vavilov distribution, pp 187-203 in: National Research Council (U.S.), Committee on Nuclear Science: Studies in penetration of charged particles in matter, Nat. Akad. Sci. Publication 1133, Nucl. Sci. Series Report No. 39, Washington (Nat. Akad. Sci.) 1964, 388 pp. Available from Google books; Therefore, for small values of \(\kappa < 0.01\), pdf approaches the Landau distribution.; For values \(\kappa > 10\), the Gauss approximation should be used with \(\mu\) and \(\sigma\) given by Vavilov::Mean(kappa, beta2) and sqrt(Vavilov::Variance(kappa, beta2).; The original Vavilov pdf is obtained by v.Pdf(lambdaV/kappa-log(kappa))/kappa.; Two subclasses are provided:; VavilovFast uses the algorithm by A. Rotondi and P. Montagna, Fast calculation of Vavilov distribution, Nucl. Instr. and Meth. B47 (1990) 215-224, which has been implemented in CERNLIB (G115).; VavilovAccurate uses the algorithm by B. Schorr, Programs for the Landau and the Vavilov distributions and the corresponding random numbers, Computer Phys. Comm. 7 (1974) 215-224, which has been implemented in CERNLIB (G116). Both subclasses store c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1Vavilov.html:1530,charge,charged,1530,doc/master/classROOT_1_1Math_1_1Vavilov.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1Vavilov.html,1,['charge'],['charged']
Energy Efficiency,"[0m; : ; : ␛[1m--- Short description:␛[0m; : ; : Fisher discriminants select events by distinguishing the mean ; : values of the signal and background distributions in a trans- ; : formed variable space where linear correlations are removed.; : ; : (More precisely: the ""linear discriminator"" determines; : an axis in the (correlated) hyperspace of the input ; : variables such that, when projecting the output classes ; : (signal and background) upon this axis, they are pushed ; : as far as possible away from each other, while events; : of a same class are confined in a close vicinity. The ; : linearity property of this classifier is reflected in the ; : metric with which ""far apart"" and ""close vicinity"" are ; : determined: the covariance matrix of the discriminating; : variable space.); : ; : ␛[1m--- Performance optimisation:␛[0m; : ; : Optimal performance for Fisher discriminants is obtained for ; : linearly correlated Gaussian-distributed variables. Any deviation; : from this ideal reduces the achievable separation power. In ; : particular, no discrimination at all is achieved for a variable; : that has the same sample mean for signal and background, even if ; : the shapes of the distributions are very different. Thus, Fisher ; : discriminants often benefit from suitable transformations of the ; : input variables. For example, if a variable x in [-1,1] has a ; : a parabolic signal distributions, and a uniform background; : distributions, their mean value is zero in both cases, leading ; : to no separation. The simple transformation x -> |x| renders this ; : variable powerful for the use in a Fisher discriminant.; : ; : ␛[1m--- Performance tuning via configuration options:␛[0m; : ; : <None>; : ; : <Suppress this message by specifying ""!H"" in the booking option>; : ␛[1m================================================================␛[0m; : ; Fisher : Results for Fisher coefficients:; : -----------------------; : Variable: Coefficient:; : -----------------------; : m_j",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__Higgs__Classification_8C.html:19617,reduce,reduces,19617,doc/master/TMVA__Higgs__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__Higgs__Classification_8C.html,4,"['power', 'reduce']","['power', 'reduces']"
Energy Efficiency,"[in] a array of parameters; 4765///; 4766/// based on CERNLIB routine LSQ: Translated to C++ by Rene Brun; 4767/// (E.Keil. revised by B.Schorr, 23.10.1981.); 4768 ; 4769void H1LeastSquareFit(Int_t n, Int_t m, Double_t *a); 4770{; 4771 const Double_t zero = 0.;; 4772 const Double_t one = 1.;; 4773 const Int_t idim = 20;; 4774 ; 4775 Double_t b[400] /* was [20][20] */;; 4776 Int_t i, k, l, ifail;; 4777 Double_t power;; 4778 Double_t da[20], xk, yk;; 4779 ; 4780 if (m <= 2) {; 4781 H1LeastSquareLinearFit(n, a[0], a[1], ifail);; 4782 return;; 4783 }; 4784 if (m > idim || m > n) return;; 4785 b[0] = Double_t(n);; 4786 da[0] = zero;; 4787 for (l = 2; l <= m; ++l) {; 4788 b[l-1] = zero;; 4789 b[m + l*20 - 21] = zero;; 4790 da[l-1] = zero;; 4791 }; 4792 TVirtualFitter *hFitter = TVirtualFitter::GetFitter();; 4793 TH1 *curHist = (TH1*)hFitter->GetObjectFit();; 4794 Int_t hxfirst = hFitter->GetXfirst();; 4795 Int_t hxlast = hFitter->GetXlast();; 4796 for (k = hxfirst; k <= hxlast; ++k) {; 4797 xk = curHist->GetBinCenter(k);; 4798 yk = curHist->GetBinContent(k);; 4799 power = one;; 4800 da[0] += yk;; 4801 for (l = 2; l <= m; ++l) {; 4802 power *= xk;; 4803 b[l-1] += power;; 4804 da[l-1] += power*yk;; 4805 }; 4806 for (l = 2; l <= m; ++l) {; 4807 power *= xk;; 4808 b[m + l*20 - 21] += power;; 4809 }; 4810 }; 4811 for (i = 3; i <= m; ++i) {; 4812 for (k = i; k <= m; ++k) {; 4813 b[k - 1 + (i-1)*20 - 21] = b[k + (i-2)*20 - 21];; 4814 }; 4815 }; 4816 H1LeastSquareSeqnd(m, b, idim, ifail, 1, da);; 4817 ; 4818 for (i=0; i<m; ++i) a[i] = da[i];; 4819 ; 4820}; 4821 ; 4822////////////////////////////////////////////////////////////////////////////////; 4823/// Least square linear fit without weights.; 4824///; 4825/// extracted from CERNLIB LLSQ: Translated to C++ by Rene Brun; 4826/// (added to LSQ by B. Schorr, 15.02.1982.); 4827 ; 4828void H1LeastSquareLinearFit(Int_t ndata, Double_t &a0, Double_t &a1, Int_t &ifail); 4829{; 4830 Double_t xbar, ybar, x2bar;; 4831 Int_t i, n;; 4832 Do",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:195648,power,power,195648,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,7,['power'],['power']
Energy Efficiency,"\chi^{2} \) test for comparison two usual (unweighted) histograms.; Overview:; Comparison of two histograms expect hypotheses that two histograms represent identical distributions. To make a decision p-value should be calculated. The hypotheses of identity is rejected if the p-value is lower then some significance level. Traditionally significance levels 0.1, 0.05 and 0.01 are used. The comparison procedure should include an analysis of the residuals which is often helpful in identifying the bins of histograms responsible for a significant overall \( \chi^{2} \) value. Residuals are the difference between bin contents and expected bin contents. Most convenient for analysis are the normalized residuals. If hypotheses of identity are valid then normalized residuals are approximately independent and identically distributed random variables having N(0,1) distribution. Analysis of residuals expect test of above mentioned properties of residuals. Notice that indirectly the analysis of residuals increase the power of \( \chi^{2} \) test.; Methods of comparison:; \( \chi^{2} \) test for comparison two (unweighted) histograms: Let us consider two histograms with the same binning and the number of bins equal to r. Let us denote the number of events in the ith bin in the first histogram as ni and as mi in the second one. The total number of events in the first histogram is equal to: ; \[; N = \sum_{i=1}^{r} n_{i}; \]. and ; \[; M = \sum_{i=1}^{r} m_{i}; \]. in the second histogram. The hypothesis of identity (homogeneity) [3] is that the two histograms represent random values with identical distributions. It is equivalent that there exist r constants p1,...,pr, such that ; \[; \sum_{i=1}^{r} p_{i}=1; \]. and the probability of belonging to the ith bin for some measured value in both experiments is equal to pi. The number of events in the ith bin is a random variable with a distribution approximated by a Poisson probability distribution ; \[; \frac{e^{-Np_{i}}(Np_{i})^{n_{i}}}{",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH1.html:88405,power,power,88405,doc/master/classTH1.html,https://root.cern,https://root.cern/doc/master/classTH1.html,1,['power'],['power']
Energy Efficiency,"\sqrt{ m_t^2 = E^2 - p{_z}^2} X sign(E^ - p{_z}^2) \f]. { return fCoordinates.Mt(); }. Scalar Et2() const. return the transverse energy squared; \f[ e_t = \frac{E^2 p_{\perp}^2 }{ |p|^2 } \f]. { return fCoordinates.Et2(); }. Scalar Et() const. return the transverse energy; \f[ e_t = \sqrt{ \frac{E^2 p_{\perp}^2 }{ |p|^2 } } X sign(E) \f]. { return fCoordinates.Et(); }. Scalar Phi() const. azimuthal Angle. { return fCoordinates.Phi();}. Scalar Theta() const. polar Angle. { return fCoordinates.Theta(); }. Scalar Eta() const. pseudorapidity; \f[ \eta = - \ln { \tan { \frac { \theta} {2} } } \f]. { return fCoordinates.Eta(); }. return operator*( Scalar(-1) ); LorentzVector<CoordinateType> v(*this);; v.Negate();. Scalar Rapidity() const; ---- Relativistic Properties ----. Rapidity relative to the Z axis: .5 log [(E+Pz)/(E-Pz)]. Scalar ColinearRapidity() const. Rapidity in the direction of travel: atanh (|P|/E)=.5 log[(E+P)/(E-P)]. bool isTimelike() const. Determine if momentum-energy can represent a physical massive particle. bool isLightlike(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<Double32_t> >::Scalar tolerance = 100*std::numeric_limits<Scalar>::epsilon()) const. Determine if momentum-energy can represent a massless particle. bool isSpacelike() const. Determine if momentum-energy is spacelike, and represents a tachyon. BetaVector BoostToCM() const. The beta vector for the boost that would bring this vector into; its center of mass frame (zero momentum). return - Vect(); TODO - should attempt to Throw with msg about; boostVector computed for LorentzVector with t=0. Scalar Beta() const; beta and gamma. Return beta scalar value. Scalar Gamma() const. Return Gamma scalar value. Scalar x() const; Method providing limited backward name compatibility with CLHEP ----. { return fCoordinates.Px(); }. Scalar y() const; { return fCoordinates.Py(); }. Scalar z() const; { return fCoordinates.Pz(); }. Scalar t() const; { return fCoordinates.E(); }. Scalar px() const; { retu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__LorentzVector_-p1PtEtaPhiE4D_Double32_t___.html:15748,energy,energy,15748,root/html528/ROOT__Math__LorentzVector_-p1PtEtaPhiE4D_Double32_t___.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__LorentzVector_-p1PtEtaPhiE4D_Double32_t___.html,4,['energy'],['energy']
Energy Efficiency,"\sqrt{ m_t^2 = E^2 - p{_z}^2} X sign(E^ - p{_z}^2) \f]. { return fCoordinates.Mt(); }. Scalar Et2() const. return the transverse energy squared; \f[ e_t = \frac{E^2 p_{\perp}^2 }{ |p|^2 } \f]. { return fCoordinates.Et2(); }. Scalar Et() const. return the transverse energy; \f[ e_t = \sqrt{ \frac{E^2 p_{\perp}^2 }{ |p|^2 } } X sign(E) \f]. { return fCoordinates.Et(); }. Scalar Phi() const. azimuthal Angle. { return fCoordinates.Phi();}. Scalar Theta() const. polar Angle. { return fCoordinates.Theta(); }. Scalar Eta() const. pseudorapidity; \f[ \eta = - \ln { \tan { \frac { \theta} {2} } } \f]. { return fCoordinates.Eta(); }. return operator*( Scalar(-1) ); LorentzVector<CoordinateType> v(*this);; v.Negate();. Scalar Rapidity() const; ---- Relativistic Properties ----. Rapidity relative to the Z axis: .5 log [(E+Pz)/(E-Pz)]. Scalar ColinearRapidity() const. Rapidity in the direction of travel: atanh (|P|/E)=.5 log[(E+P)/(E-P)]. bool isTimelike() const. Determine if momentum-energy can represent a physical massive particle. bool isLightlike(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<double> >::Scalar tolerance = 100 * std::numeric_limits<Scalar>::epsilon()) const. Determine if momentum-energy can represent a massless particle. bool isSpacelike() const. Determine if momentum-energy is spacelike, and represents a tachyon. BetaVector BoostToCM() const. The beta vector for the boost that would bring this vector into; its center of mass frame (zero momentum). return - Vect(); TODO - should attempt to Throw with msg about; boostVector computed for LorentzVector with t=0. Scalar Beta() const; beta and gamma. Return beta scalar value. Scalar Gamma() const. Return Gamma scalar value. Scalar x() const; Method providing limited backward name compatibility with CLHEP ----. { return fCoordinates.Px(); }. Scalar y() const; { return fCoordinates.Py(); }. Scalar z() const; { return fCoordinates.Pz(); }. Scalar t() const; { return fCoordinates.E(); }. Scalar px() const; { return",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__LorentzVector_-p1PtEtaPhiE4D_Double32_t___.html:15261,energy,energy,15261,root/html602/ROOT__Math__LorentzVector_-p1PtEtaPhiE4D_Double32_t___.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__LorentzVector_-p1PtEtaPhiE4D_Double32_t___.html,4,['energy'],['energy']
Energy Efficiency,"\sqrt{ m_t^2 = E^2 - p{_z}^2} X sign(E^ - p{_z}^2) \f]. { return fCoordinates.Mt(); }. Scalar Et2() const. return the transverse energy squared; \f[ e_t = \frac{E^2 p_{\perp}^2 }{ |p|^2 } \f]. { return fCoordinates.Et2(); }. Scalar Et() const. return the transverse energy; \f[ e_t = \sqrt{ \frac{E^2 p_{\perp}^2 }{ |p|^2 } } X sign(E) \f]. { return fCoordinates.Et(); }. Scalar Phi() const. azimuthal Angle. { return fCoordinates.Phi();}. Scalar Theta() const. polar Angle. { return fCoordinates.Theta(); }. Scalar Eta() const. pseudorapidity; \f[ \eta = - \ln { \tan { \frac { \theta} {2} } } \f]. { return fCoordinates.Eta(); }. return operator*( Scalar(-1) ); LorentzVector<CoordinateType> v(*this);; v.Negate();. Scalar Rapidity() const; ---- Relativistic Properties ----. Rapidity relative to the Z axis: .5 log [(E+Pz)/(E-Pz)]. Scalar ColinearRapidity() const. Rapidity in the direction of travel: atanh (|P|/E)=.5 log[(E+P)/(E-P)]. bool isTimelike() const. Determine if momentum-energy can represent a physical massive particle. bool isLightlike(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<Double32_t> >::Scalar tolerance = 100*std::numeric_limits<Scalar>::epsilon()) const. Determine if momentum-energy can represent a massless particle. bool isSpacelike() const. Determine if momentum-energy is spacelike, and represents a tachyon. BetaVector BoostToCM() const. The beta vector for the boost that would bring this vector into; its center of mass frame (zero momentum). return - Vect(); TODO - should attempt to Throw with msg about; boostVector computed for LorentzVector with t=0. Scalar Beta() const; beta and gamma. Return beta scalar value. Scalar Gamma() const. Return Gamma scalar value. Scalar x() const; Method providing limited backward name compatibility with CLHEP ----. { return fCoordinates.Px(); }. Scalar y() const; { return fCoordinates.Py(); }. Scalar z() const; { return fCoordinates.Pz(); }. Scalar t() const; { return fCoordinates.E(); }. Scalar px() const; { retu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__LorentzVector_-p1PtEtaPhiM4D_Double32_t___.html:15748,energy,energy,15748,root/html528/ROOT__Math__LorentzVector_-p1PtEtaPhiM4D_Double32_t___.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__LorentzVector_-p1PtEtaPhiM4D_Double32_t___.html,4,['energy'],['energy']
Energy Efficiency,"\sqrt{ m_t^2 = E^2 - p{_z}^2} X sign(E^ - p{_z}^2) \f]. { return fCoordinates.Mt(); }. Scalar Et2() const. return the transverse energy squared; \f[ e_t = \frac{E^2 p_{\perp}^2 }{ |p|^2 } \f]. { return fCoordinates.Et2(); }. Scalar Et() const. return the transverse energy; \f[ e_t = \sqrt{ \frac{E^2 p_{\perp}^2 }{ |p|^2 } } X sign(E) \f]. { return fCoordinates.Et(); }. Scalar Phi() const. azimuthal Angle. { return fCoordinates.Phi();}. Scalar Theta() const. polar Angle. { return fCoordinates.Theta(); }. Scalar Eta() const. pseudorapidity; \f[ \eta = - \ln { \tan { \frac { \theta} {2} } } \f]. { return fCoordinates.Eta(); }. return operator*( Scalar(-1) ); LorentzVector<CoordinateType> v(*this);; v.Negate();. Scalar Rapidity() const; ---- Relativistic Properties ----. Rapidity relative to the Z axis: .5 log [(E+Pz)/(E-Pz)]. Scalar ColinearRapidity() const. Rapidity in the direction of travel: atanh (|P|/E)=.5 log[(E+P)/(E-P)]. bool isTimelike() const. Determine if momentum-energy can represent a physical massive particle. bool isLightlike(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >::Scalar tolerance = 100 * std::numeric_limits<Scalar>::epsilon()) const. Determine if momentum-energy can represent a massless particle. bool isSpacelike() const. Determine if momentum-energy is spacelike, and represents a tachyon. BetaVector BoostToCM() const. The beta vector for the boost that would bring this vector into; its center of mass frame (zero momentum). return - Vect(); TODO - should attempt to Throw with msg about; boostVector computed for LorentzVector with t=0. Scalar Beta() const; beta and gamma. Return beta scalar value. Scalar Gamma() const. Return Gamma scalar value. Scalar x() const; Method providing limited backward name compatibility with CLHEP ----. { return fCoordinates.Px(); }. Scalar y() const; { return fCoordinates.Py(); }. Scalar z() const; { return fCoordinates.Pz(); }. Scalar t() const; { return fCoordinates.E(); }. Scalar px() const; { return",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__LorentzVector_-p1PtEtaPhiM4D_Double32_t___.html:15261,energy,energy,15261,root/html602/ROOT__Math__LorentzVector_-p1PtEtaPhiM4D_Double32_t___.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__LorentzVector_-p1PtEtaPhiM4D_Double32_t___.html,4,['energy'],['energy']
Energy Efficiency,"\sqrt{ m_t^2 = E^2 - p{_z}^2} X sign(E^ - p{_z}^2) \f]. { return fCoordinates.Mt(); }. Scalar Et2() const. return the transverse energy squared; \f[ e_t = \frac{E^2 p_{\perp}^2 }{ |p|^2 } \f]. { return fCoordinates.Et2(); }. Scalar Et() const. return the transverse energy; \f[ e_t = \sqrt{ \frac{E^2 p_{\perp}^2 }{ |p|^2 } } X sign(E) \f]. { return fCoordinates.Et(); }. Scalar Phi() const. azimuthal Angle. { return fCoordinates.Phi();}. Scalar Theta() const. polar Angle. { return fCoordinates.Theta(); }. Scalar Eta() const. pseudorapidity; \f[ \eta = - \ln { \tan { \frac { \theta} {2} } } \f]. { return fCoordinates.Eta(); }. return operator*( Scalar(-1) ); LorentzVector<CoordinateType> v(*this);; v.Negate();. Scalar Rapidity() const; ---- Relativistic Properties ----. Rapidity relative to the Z axis: .5 log [(E+Pz)/(E-Pz)]. Scalar ColinearRapidity() const. Rapidity in the direction of travel: atanh (|P|/E)=.5 log[(E+P)/(E-P)]. bool isTimelike() const. Determine if momentum-energy can represent a physical massive particle. bool isLightlike(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<Double32_t> >::Scalar tolerance = 100*std::numeric_limits<Scalar>::epsilon()) const. Determine if momentum-energy can represent a massless particle. bool isSpacelike() const. Determine if momentum-energy is spacelike, and represents a tachyon. BetaVector BoostToCM() const. The beta vector for the boost that would bring this vector into; its center of mass frame (zero momentum). return - Vect(); TODO - should attempt to Throw with msg about; boostVector computed for LorentzVector with t=0. Scalar Beta() const; beta and gamma. Return beta scalar value. Scalar Gamma() const. Return Gamma scalar value. Scalar x() const; Method providing limited backward name compatibility with CLHEP ----. { return fCoordinates.Px(); }. Scalar y() const; { return fCoordinates.Py(); }. Scalar z() const; { return fCoordinates.Pz(); }. Scalar t() const; { return fCoordinates.E(); }. Scalar px() const; { return",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__LorentzVector_-p1PxPyPzE4D_Double32_t___.html:15466,energy,energy,15466,root/html528/ROOT__Math__LorentzVector_-p1PxPyPzE4D_Double32_t___.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__LorentzVector_-p1PxPyPzE4D_Double32_t___.html,4,['energy'],['energy']
Energy Efficiency,"\sqrt{ m_t^2 = E^2 - p{_z}^2} X sign(E^ - p{_z}^2) \f]. { return fCoordinates.Mt(); }. Scalar Et2() const. return the transverse energy squared; \f[ e_t = \frac{E^2 p_{\perp}^2 }{ |p|^2 } \f]. { return fCoordinates.Et2(); }. Scalar Et() const. return the transverse energy; \f[ e_t = \sqrt{ \frac{E^2 p_{\perp}^2 }{ |p|^2 } } X sign(E) \f]. { return fCoordinates.Et(); }. Scalar Phi() const. azimuthal Angle. { return fCoordinates.Phi();}. Scalar Theta() const. polar Angle. { return fCoordinates.Theta(); }. Scalar Eta() const. pseudorapidity; \f[ \eta = - \ln { \tan { \frac { \theta} {2} } } \f]. { return fCoordinates.Eta(); }. return operator*( Scalar(-1) ); LorentzVector<CoordinateType> v(*this);; v.Negate();. Scalar Rapidity() const; ---- Relativistic Properties ----. Rapidity relative to the Z axis: .5 log [(E+Pz)/(E-Pz)]. Scalar ColinearRapidity() const. Rapidity in the direction of travel: atanh (|P|/E)=.5 log[(E+P)/(E-P)]. bool isTimelike() const. Determine if momentum-energy can represent a physical massive particle. bool isLightlike(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >::Scalar tolerance = 100 * std::numeric_limits<Scalar>::epsilon()) const. Determine if momentum-energy can represent a massless particle. bool isSpacelike() const. Determine if momentum-energy is spacelike, and represents a tachyon. BetaVector BoostToCM() const. The beta vector for the boost that would bring this vector into; its center of mass frame (zero momentum). return - Vect(); TODO - should attempt to Throw with msg about; boostVector computed for LorentzVector with t=0. Scalar Beta() const; beta and gamma. Return beta scalar value. Scalar Gamma() const. Return Gamma scalar value. Scalar x() const; Method providing limited backward name compatibility with CLHEP ----. { return fCoordinates.Px(); }. Scalar y() const; { return fCoordinates.Py(); }. Scalar z() const; { return fCoordinates.Pz(); }. Scalar t() const; { return fCoordinates.E(); }. Scalar px() const; { return f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__LorentzVector_-p1PxPyPzE4D_Double32_t___.html:14977,energy,energy,14977,root/html602/ROOT__Math__LorentzVector_-p1PxPyPzE4D_Double32_t___.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__LorentzVector_-p1PxPyPzE4D_Double32_t___.html,4,['energy'],['energy']
Energy Efficiency,"\sqrt{ m_t^2 = E^2 - p{_z}^2} X sign(E^ - p{_z}^2) \f]. { return fCoordinates.Mt(); }. Scalar Et2() const. return the transverse energy squared; \f[ e_t = \frac{E^2 p_{\perp}^2 }{ |p|^2 } \f]. { return fCoordinates.Et2(); }. Scalar Et() const. return the transverse energy; \f[ e_t = \sqrt{ \frac{E^2 p_{\perp}^2 }{ |p|^2 } } X sign(E) \f]. { return fCoordinates.Et(); }. Scalar Phi() const. azimuthal Angle. { return fCoordinates.Phi();}. Scalar Theta() const. polar Angle. { return fCoordinates.Theta(); }. Scalar Eta() const. pseudorapidity; \f[ \eta = - \ln { \tan { \frac { \theta} {2} } } \f]. { return fCoordinates.Eta(); }. return operator*( Scalar(-1) ); LorentzVector<CoordinateType> v(*this);; v.Negate();. Scalar Rapidity() const; ---- Relativistic Properties ----. Rapidity relative to the Z axis: .5 log [(E+Pz)/(E-Pz)]. Scalar ColinearRapidity() const. Rapidity in the direction of travel: atanh (|P|/E)=.5 log[(E+P)/(E-P)]. bool isTimelike() const. Determine if momentum-energy can represent a physical massive particle. bool isLightlike(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<Double32_t> >::Scalar tolerance = 100*std::numeric_limits<Scalar>::epsilon()) const. Determine if momentum-energy can represent a massless particle. bool isSpacelike() const. Determine if momentum-energy is spacelike, and represents a tachyon. BetaVector BoostToCM() const. The beta vector for the boost that would bring this vector into; its center of mass frame (zero momentum). return - Vect(); TODO - should attempt to Throw with msg about; boostVector computed for LorentzVector with t=0. Scalar Beta() const; beta and gamma. Return beta scalar value. Scalar Gamma() const. Return Gamma scalar value. Scalar x() const; Method providing limited backward name compatibility with CLHEP ----. { return fCoordinates.Px(); }. Scalar y() const; { return fCoordinates.Py(); }. Scalar z() const; { return fCoordinates.Pz(); }. Scalar t() const; { return fCoordinates.E(); }. Scalar px() const; { return",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__LorentzVector_-p1PxPyPzM4D_Double32_t___.html:15466,energy,energy,15466,root/html528/ROOT__Math__LorentzVector_-p1PxPyPzM4D_Double32_t___.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__LorentzVector_-p1PxPyPzM4D_Double32_t___.html,4,['energy'],['energy']
Energy Efficiency,"\sqrt{ m_t^2 = E^2 - p{_z}^2} X sign(E^ - p{_z}^2) \f]. { return fCoordinates.Mt(); }. Scalar Et2() const. return the transverse energy squared; \f[ e_t = \frac{E^2 p_{\perp}^2 }{ |p|^2 } \f]. { return fCoordinates.Et2(); }. Scalar Et() const. return the transverse energy; \f[ e_t = \sqrt{ \frac{E^2 p_{\perp}^2 }{ |p|^2 } } X sign(E) \f]. { return fCoordinates.Et(); }. Scalar Phi() const. azimuthal Angle. { return fCoordinates.Phi();}. Scalar Theta() const. polar Angle. { return fCoordinates.Theta(); }. Scalar Eta() const. pseudorapidity; \f[ \eta = - \ln { \tan { \frac { \theta} {2} } } \f]. { return fCoordinates.Eta(); }. return operator*( Scalar(-1) ); LorentzVector<CoordinateType> v(*this);; v.Negate();. Scalar Rapidity() const; ---- Relativistic Properties ----. Rapidity relative to the Z axis: .5 log [(E+Pz)/(E-Pz)]. Scalar ColinearRapidity() const. Rapidity in the direction of travel: atanh (|P|/E)=.5 log[(E+P)/(E-P)]. bool isTimelike() const. Determine if momentum-energy can represent a physical massive particle. bool isLightlike(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >::Scalar tolerance = 100 * std::numeric_limits<Scalar>::epsilon()) const. Determine if momentum-energy can represent a massless particle. bool isSpacelike() const. Determine if momentum-energy is spacelike, and represents a tachyon. BetaVector BoostToCM() const. The beta vector for the boost that would bring this vector into; its center of mass frame (zero momentum). return - Vect(); TODO - should attempt to Throw with msg about; boostVector computed for LorentzVector with t=0. Scalar Beta() const; beta and gamma. Return beta scalar value. Scalar Gamma() const. Return Gamma scalar value. Scalar x() const; Method providing limited backward name compatibility with CLHEP ----. { return fCoordinates.Px(); }. Scalar y() const; { return fCoordinates.Py(); }. Scalar z() const; { return fCoordinates.Pz(); }. Scalar t() const; { return fCoordinates.E(); }. Scalar px() const; { return f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__LorentzVector_-p1PxPyPzM4D_Double32_t___.html:14977,energy,energy,14977,root/html602/ROOT__Math__LorentzVector_-p1PxPyPzM4D_Double32_t___.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__LorentzVector_-p1PxPyPzM4D_Double32_t___.html,4,['energy'],['energy']
Energy Efficiency,"] + (f1*vect[kPZ] + f3);; vout[kPX] = vect[kPX] + (f4*vect[kPX] - f5*vect[kPY]);; vout[kPY] = vect[kPY] + (f4*vect[kPY] + f5*vect[kPX]);; vout[kPZ] = vect[kPZ] + (f4*vect[kPZ] + f6);; }; ; void tree2aw(); {; //create a Tree file tree2.root; ; //create the file, the Tree and a few branches with; //a subset of gctrak; TFile f(""tree2.root"",""recreate"");; TTree t2(""t2"",""a Tree with data from a fake Geant3"");; Gctrak *gstep = new Gctrak;; t2.Branch(""track"",&gstep,8000,1);; ; //Initialize particle parameters at first point; Float_t px,py,pz,p,charge=0;; Float_t vout[7];; Float_t mass = 0.137;; Bool_t newParticle = kTRUE;; gstep->lmec = new Int_t[MAXMEC];; gstep->namec = new Int_t[MAXMEC];; gstep->step = 0.1;; gstep->destep = 0;; gstep->nmec = 0;; gstep->pid = 0;; ; //transport particles; for (Int_t i=0;i<10000;i++) {; //generate a new particle if necessary; if (newParticle) {; px = gRandom->Gaus(0,.02);; py = gRandom->Gaus(0,.02);; pz = gRandom->Gaus(0,.02);; p = TMath::Sqrt(px*px+py*py+pz*pz);; charge = 1; if (gRandom->Rndm() < 0.5) charge = -1;; gstep->pid += 1;; gstep->vect[0] = 0;; gstep->vect[1] = 0;; gstep->vect[2] = 0;; gstep->vect[3] = px/p;; gstep->vect[4] = py/p;; gstep->vect[5] = pz/p;; gstep->vect[6] = p*charge;; gstep->getot = TMath::Sqrt(p*p + mass*mass);; gstep->gekin = gstep->getot - mass;; newParticle = kFALSE;; }; ; // fill the Tree with current step parameters; t2.Fill();; ; //transport particle in magnetic field; helixStep(gstep->step, gstep->vect, vout); //make one step; ; //apply energy loss; gstep->destep = gstep->step*gRandom->Gaus(0.0002,0.00001);; gstep->gekin -= gstep->destep;; gstep->getot = gstep->gekin + mass;; gstep->vect[6] = charge*TMath::Sqrt(gstep->getot*gstep->getot - mass*mass);; gstep->vect[0] = vout[0];; gstep->vect[1] = vout[1];; gstep->vect[2] = vout[2];; gstep->vect[3] = vout[3];; gstep->vect[4] = vout[4];; gstep->vect[5] = vout[5];; gstep->nmec = (Int_t)(5*gRandom->Rndm());; for (Int_t l=0;l<gstep->nmec;l++) {; gstep->lmec[l] = l;;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tree2a_8C.html:3259,charge,charge,3259,doc/master/tree2a_8C.html,https://root.cern,https://root.cern/doc/master/tree2a_8C.html,1,['charge'],['charge']
Energy Efficiency,"] = 0; if (*l <=0) continue;; 984 f[j] = new Float_t[*l];; 985 b.ReadFastArrayFloat16(f[j],*l,aElement);; 986 }; 987 }; 988 continue;; 989 }; 990 case TStreamerInfo::kOffsetP + TStreamerInfo::kDouble32+ kHaveLoop: {; 991 const int imethod = compinfo[i]->fMethod+eoffset;; 992 for(Int_t k=0; k<narr; ++k) {; 993 Char_t isArray;; 994 b >> isArray;; 995 Int_t *l = (Int_t*)(arr[k]+imethod);; 996 Double_t **f = (Double_t**)(arr[k]+ioffset);; 997 int j;; 998 for(j=0;j<compinfo[i]->fLength;j++) {; 999 delete [] f[j];; 1000 f[j] = 0; if (*l <=0) continue;; 1001 f[j] = new Double_t[*l];; 1002 b.ReadFastArrayDouble32(f[j],*l,aElement);; 1003 }; 1004 }; 1005 continue;; 1006 }; 1007 }; 1008 ; 1009 switch (kase) {; 1010 ; 1011 // char*; 1012 case TStreamerInfo::kCharStar: {; 1013 DOLOOP {; 1014 char **f = (char**)(arr[k]+ioffset);; 1015 b.ReadCharStar(*f);; 1016 }; 1017 }; 1018 continue;; 1019 ; 1020 // special case for TObject::fBits in case of a referenced object; 1021 case TStreamerInfo::kBits: {; 1022 DOLOOP {; 1023 UInt_t *x=(UInt_t*)(arr[k]+ioffset);; 1024 const UInt_t isonheap = *x & TObject::kIsOnHeap; // Record how this instance was actually allocated.; 1025 b >> *x;; 1026 *x |= isonheap | TObject::kNotDeleted; // by definition de-serialized object are not yet deleted.; 1027 if ((*x & kIsReferenced) != 0) {; 1028 UShort_t pidf;; 1029 b >> pidf;; 1030 pidf += b.GetPidOffset();; 1031 TProcessID *pid = b.ReadProcessID(pidf);; 1032 if (pid!=0) {; 1033 TObject *obj = (TObject*)(arr[k]+eoffset);; 1034 UInt_t gpid = pid->GetUniqueID();; 1035 UInt_t uid;; 1036 if (gpid>=0xff) {; 1037 uid = obj->GetUniqueID() | 0xff000000;; 1038 } else {; 1039 uid = ( obj->GetUniqueID() & 0xffffff) + (gpid<<24);; 1040 }; 1041 obj->SetUniqueID(uid);; 1042 pid->PutObjectWithID(obj);; 1043 }; 1044 }; 1045 }; 1046 }; 1047 continue;; 1048 ; 1049 // array counter //[n]; 1050 case TStreamerInfo::kCounter: {; 1051 DOLOOP {; 1052 Int_t *x=(Int_t*)(arr[k]+ioffset);; 1053 b >> *x;; 1054 }; 1055 }; 1056 conti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfoReadBuffer_8cxx_source.html:45060,allocate,allocated,45060,doc/master/TStreamerInfoReadBuffer_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfoReadBuffer_8cxx_source.html,1,['allocate'],['allocated']
Energy Efficiency,"]. ParamHistFunc::ParamHistFunc ; (; const ParamHistFunc & ; other, . const char * ; name = nullptr . ). Definition at line 173 of file ParamHistFunc.cxx. Member Function Documentation. ◆ addParamSet(). Int_t ParamHistFunc::addParamSet ; (; const RooArgList & ; params). protected . Definition at line 524 of file ParamHistFunc.cxx. ◆ analyticalIntegralWN(). double ParamHistFunc::analyticalIntegralWN ; (; Int_t ; code, . const RooArgSet * ; normSet, . const char * ; rangeName = nullptr . ); const. overridevirtual . Implement analytical integrations by doing appropriate weighting from component integrals functions to integrators of components. ; Reimplemented from RooAbsReal.; Definition at line 655 of file ParamHistFunc.cxx. ◆ binBoundaries(). std::list< double > * ParamHistFunc::binBoundaries ; (; RooAbsRealLValue & ; obs, . double ; xlo, . double ; xhi . ); const. overridevirtual . Return sampling hint for making curves of (projections) of this function as the recursive division strategy of RooCurve cannot deal efficiently with the vertical lines that occur in a non-interpolated histogram. ; Reimplemented from RooAbsReal.; Definition at line 721 of file ParamHistFunc.cxx. ◆ binVolume(). double ParamHistFunc::binVolume ; (; ); const. inline . Definition at line 49 of file ParamHistFunc.h. ◆ Class(). static TClass * ParamHistFunc::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * ParamHistFunc::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t ParamHistFunc::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 111 of file ParamHistFunc.h. ◆ clone(). TObject * ParamHistFunc::clone ; (; const char * ; newname); const. inlineoverridevirtual . Implements RooAbsArg.; Definition at line 32 of file ParamHistFunc.h. ◆ createParamSet() [1/3]. RooArgList ParamHistFunc::createParamSet ; (; const std::string & ; Prefix, . Int_t ; numBins, .",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classParamHistFunc.html:65167,efficient,efficiently,65167,doc/master/classParamHistFunc.html,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html,1,['efficient'],['efficiently']
Energy Efficiency,"]. virtual const RooArgSet * RooStats::MarkovChain::Get ; (; Int_t ; i); const. inlinevirtual . get the entry at position i ; Definition at line 54 of file MarkovChain.h. ◆ GetAsConstDataSet(). virtual const RooDataSet * RooStats::MarkovChain::GetAsConstDataSet ; (; ); const. inlinevirtual . Definition at line 82 of file MarkovChain.h. ◆ GetAsDataHist() [1/2]. RooFit::OwningPtr< RooDataHist > MarkovChain::GetAsDataHist ; (; const RooCmdArg & ; arg1, . const RooCmdArg & ; arg2 = {}, . const RooCmdArg & ; arg3 = {}, . const RooCmdArg & ; arg4 = {}, . const RooCmdArg & ; arg5 = {}, . const RooCmdArg & ; arg6 = {}, . const RooCmdArg & ; arg7 = {}, . const RooCmdArg & ; arg8 = {} . ); const. virtual . Get a clone of the markov chain on which this interval is based as a RooDataHist. ; You own the returned RooDataHist* Deprecated:Will be removed in ROOT 6.36. ; Deprecated:Will be removed in ROOT 6.36. Please implement this functionality by calling RooAbsData::reduce on the Markov Chain's RooDataSet* (obtained using MarkovChain::GetAsConstDataSet), and then obtaining its binned clone. ; Definition at line 172 of file MarkovChain.cxx. ◆ GetAsDataHist() [2/2]. RooFit::OwningPtr< RooDataHist > MarkovChain::GetAsDataHist ; (; RooArgSet * ; whichVars = nullptr); const. virtual . get this MarkovChain as a RooDataHist whose entries contain the values of whichVars. ; Call with whichVars = nullptr (default) to get values of all variables (including NLL value and weight); Note: caller owns the returned data hist ; Definition at line 154 of file MarkovChain.cxx. ◆ GetAsDataSet() [1/2]. RooFit::OwningPtr< RooDataSet > MarkovChain::GetAsDataSet ; (; const RooCmdArg & ; arg1, . const RooCmdArg & ; arg2 = {}, . const RooCmdArg & ; arg3 = {}, . const RooCmdArg & ; arg4 = {}, . const RooCmdArg & ; arg5 = {}, . const RooCmdArg & ; arg6 = {}, . const RooCmdArg & ; arg7 = {}, . const RooCmdArg & ; arg8 = {} . ); const. virtual . Get a clone of the markov chain on which this interval is based a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooStats_1_1MarkovChain.html:17718,reduce,reduce,17718,doc/master/classRooStats_1_1MarkovChain.html,https://root.cern,https://root.cern/doc/master/classRooStats_1_1MarkovChain.html,1,['reduce'],['reduce']
Energy Efficiency,"^2 }{ |p|^2 } } X sign(E) \f]. { return fCoordinates.Et(); }. Scalar Phi() const. azimuthal Angle. { return fCoordinates.Phi();}. Scalar Theta() const. polar Angle. { return fCoordinates.Theta(); }. Scalar Eta() const. pseudorapidity; \f[ \eta = - \ln { \tan { \frac { \theta} {2} } } \f]. { return fCoordinates.Eta(); }. return operator*( Scalar(-1) ); LorentzVector<CoordinateType> v(*this);; v.Negate();. Scalar Rapidity() const; ---- Relativistic Properties ----. Rapidity relative to the Z axis: .5 log [(E+Pz)/(E-Pz)]. Scalar ColinearRapidity() const. Rapidity in the direction of travel: atanh (|P|/E)=.5 log[(E+P)/(E-P)]. bool isTimelike() const. Determine if momentum-energy can represent a physical massive particle. bool isLightlike(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<double> >::Scalar tolerance = 100 * std::numeric_limits<Scalar>::epsilon()) const. Determine if momentum-energy can represent a massless particle. bool isSpacelike() const. Determine if momentum-energy is spacelike, and represents a tachyon. BetaVector BoostToCM() const. The beta vector for the boost that would bring this vector into; its center of mass frame (zero momentum). return - Vect(); TODO - should attempt to Throw with msg about; boostVector computed for LorentzVector with t=0. Scalar Beta() const; beta and gamma. Return beta scalar value. Scalar Gamma() const. Return Gamma scalar value. Scalar x() const; Method providing limited backward name compatibility with CLHEP ----. { return fCoordinates.Px(); }. Scalar y() const; { return fCoordinates.Py(); }. Scalar z() const; { return fCoordinates.Pz(); }. Scalar t() const; { return fCoordinates.E(); }. Scalar px() const; { return fCoordinates.Px(); }. Scalar py() const; { return fCoordinates.Py(); }. Scalar pz() const; { return fCoordinates.Pz(); }. Scalar e() const; { return fCoordinates.E(); }. Scalar theta() const; { return fCoordinates.Theta(); }. Scalar phi() const; { return fCoordinates.Phi(); }. Scalar rho() const; { return fCo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__LorentzVector_-p1PtEtaPhiE4D_Double32_t___.html:15573,energy,energy,15573,root/html602/ROOT__Math__LorentzVector_-p1PtEtaPhiE4D_Double32_t___.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__LorentzVector_-p1PtEtaPhiE4D_Double32_t___.html,4,['energy'],['energy']
Energy Efficiency,"^2 }{ |p|^2 } } X sign(E) \f]. { return fCoordinates.Et(); }. Scalar Phi() const. azimuthal Angle. { return fCoordinates.Phi();}. Scalar Theta() const. polar Angle. { return fCoordinates.Theta(); }. Scalar Eta() const. pseudorapidity; \f[ \eta = - \ln { \tan { \frac { \theta} {2} } } \f]. { return fCoordinates.Eta(); }. return operator*( Scalar(-1) ); LorentzVector<CoordinateType> v(*this);; v.Negate();. Scalar Rapidity() const; ---- Relativistic Properties ----. Rapidity relative to the Z axis: .5 log [(E+Pz)/(E-Pz)]. Scalar ColinearRapidity() const. Rapidity in the direction of travel: atanh (|P|/E)=.5 log[(E+P)/(E-P)]. bool isTimelike() const. Determine if momentum-energy can represent a physical massive particle. bool isLightlike(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >::Scalar tolerance = 100 * std::numeric_limits<Scalar>::epsilon()) const. Determine if momentum-energy can represent a massless particle. bool isSpacelike() const. Determine if momentum-energy is spacelike, and represents a tachyon. BetaVector BoostToCM() const. The beta vector for the boost that would bring this vector into; its center of mass frame (zero momentum). return - Vect(); TODO - should attempt to Throw with msg about; boostVector computed for LorentzVector with t=0. Scalar Beta() const; beta and gamma. Return beta scalar value. Scalar Gamma() const. Return Gamma scalar value. Scalar x() const; Method providing limited backward name compatibility with CLHEP ----. { return fCoordinates.Px(); }. Scalar y() const; { return fCoordinates.Py(); }. Scalar z() const; { return fCoordinates.Pz(); }. Scalar t() const; { return fCoordinates.E(); }. Scalar px() const; { return fCoordinates.Px(); }. Scalar py() const; { return fCoordinates.Py(); }. Scalar pz() const; { return fCoordinates.Pz(); }. Scalar e() const; { return fCoordinates.E(); }. Scalar theta() const; { return fCoordinates.Theta(); }. Scalar phi() const; { return fCoordinates.Phi(); }. Scalar rho() const; { return fCo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__LorentzVector_-p1PtEtaPhiM4D_Double32_t___.html:15573,energy,energy,15573,root/html602/ROOT__Math__LorentzVector_-p1PtEtaPhiM4D_Double32_t___.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__LorentzVector_-p1PtEtaPhiM4D_Double32_t___.html,4,['energy'],['energy']
Energy Efficiency,"^2 }{ |p|^2 } } X sign(E) \f]. { return fCoordinates.Et(); }. Scalar Phi() const. azimuthal Angle. { return fCoordinates.Phi();}. Scalar Theta() const. polar Angle. { return fCoordinates.Theta(); }. Scalar Eta() const. pseudorapidity; \f[ \eta = - \ln { \tan { \frac { \theta} {2} } } \f]. { return fCoordinates.Eta(); }. return operator*( Scalar(-1) ); LorentzVector<CoordinateType> v(*this);; v.Negate();. Scalar Rapidity() const; ---- Relativistic Properties ----. Rapidity relative to the Z axis: .5 log [(E+Pz)/(E-Pz)]. Scalar ColinearRapidity() const. Rapidity in the direction of travel: atanh (|P|/E)=.5 log[(E+P)/(E-P)]. bool isTimelike() const. Determine if momentum-energy can represent a physical massive particle. bool isLightlike(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<Double32_t> >::Scalar tolerance = 100*std::numeric_limits<Scalar>::epsilon()) const. Determine if momentum-energy can represent a massless particle. bool isSpacelike() const. Determine if momentum-energy is spacelike, and represents a tachyon. BetaVector BoostToCM() const. The beta vector for the boost that would bring this vector into; its center of mass frame (zero momentum). return - Vect(); TODO - should attempt to Throw with msg about; boostVector computed for LorentzVector with t=0. Scalar Beta() const; beta and gamma. Return beta scalar value. Scalar Gamma() const. Return Gamma scalar value. Scalar x() const; Method providing limited backward name compatibility with CLHEP ----. { return fCoordinates.Px(); }. Scalar y() const; { return fCoordinates.Py(); }. Scalar z() const; { return fCoordinates.Pz(); }. Scalar t() const; { return fCoordinates.E(); }. Scalar px() const; { return fCoordinates.Px(); }. Scalar py() const; { return fCoordinates.Py(); }. Scalar pz() const; { return fCoordinates.Pz(); }. Scalar e() const; { return fCoordinates.E(); }. Scalar theta() const; { return fCoordinates.Theta(); }. Scalar phi() const; { return fCoordinates.Phi(); }. Scalar rho() const; { return fCo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__LorentzVector_-p1PxPyPzE4D_Double32_t___.html:15778,energy,energy,15778,root/html528/ROOT__Math__LorentzVector_-p1PxPyPzE4D_Double32_t___.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__LorentzVector_-p1PxPyPzE4D_Double32_t___.html,4,['energy'],['energy']
Energy Efficiency,"^2 }{ |p|^2 } } X sign(E) \f]. { return fCoordinates.Et(); }. Scalar Phi() const. azimuthal Angle. { return fCoordinates.Phi();}. Scalar Theta() const. polar Angle. { return fCoordinates.Theta(); }. Scalar Eta() const. pseudorapidity; \f[ \eta = - \ln { \tan { \frac { \theta} {2} } } \f]. { return fCoordinates.Eta(); }. return operator*( Scalar(-1) ); LorentzVector<CoordinateType> v(*this);; v.Negate();. Scalar Rapidity() const; ---- Relativistic Properties ----. Rapidity relative to the Z axis: .5 log [(E+Pz)/(E-Pz)]. Scalar ColinearRapidity() const. Rapidity in the direction of travel: atanh (|P|/E)=.5 log[(E+P)/(E-P)]. bool isTimelike() const. Determine if momentum-energy can represent a physical massive particle. bool isLightlike(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<Double32_t> >::Scalar tolerance = 100*std::numeric_limits<Scalar>::epsilon()) const. Determine if momentum-energy can represent a massless particle. bool isSpacelike() const. Determine if momentum-energy is spacelike, and represents a tachyon. BetaVector BoostToCM() const. The beta vector for the boost that would bring this vector into; its center of mass frame (zero momentum). return - Vect(); TODO - should attempt to Throw with msg about; boostVector computed for LorentzVector with t=0. Scalar Beta() const; beta and gamma. Return beta scalar value. Scalar Gamma() const. Return Gamma scalar value. Scalar x() const; Method providing limited backward name compatibility with CLHEP ----. { return fCoordinates.Px(); }. Scalar y() const; { return fCoordinates.Py(); }. Scalar z() const; { return fCoordinates.Pz(); }. Scalar t() const; { return fCoordinates.E(); }. Scalar px() const; { return fCoordinates.Px(); }. Scalar py() const; { return fCoordinates.Py(); }. Scalar pz() const; { return fCoordinates.Pz(); }. Scalar e() const; { return fCoordinates.E(); }. Scalar theta() const; { return fCoordinates.Theta(); }. Scalar phi() const; { return fCoordinates.Phi(); }. Scalar rho() const; { return fCo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__LorentzVector_-p1PxPyPzM4D_Double32_t___.html:15778,energy,energy,15778,root/html528/ROOT__Math__LorentzVector_-p1PxPyPzM4D_Double32_t___.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__LorentzVector_-p1PxPyPzM4D_Double32_t___.html,4,['energy'],['energy']
Energy Efficiency,"_Download__ApMon.html,; current version:; http://monalisa.cacr.caltech.edu/download/apmon/ApMon_cpp-2.0.6.tar.gz. The ROOT implementation is primary optimized for process/job monitoring,; although all other generic MonaLisa ApMon functionality can be exploited; through the ApMon class directly (gMonitoringWriter->GetApMon()). Monitoring information in MonaLisa is structured in the following tree; structure:; <farmname>; |; ---> <nodename1>; |; ---> <key1> - <value1>; ---> <key2> - <value2>; ---> <nodename2>; |; ---> <key3> - <value3>; ---> <key4> - <value4>. The parameter monid is equivalent to the MonaLisa node name, for the; case of process monitoring it can be just an identifier to classify; the type of jobs e.g. ""PROOF_PROCESSING"".; If monid is not specified, TMonaLisaWriter tries to set it in this order; from environement variables:; - PROOF_JOB_ID; - GRID_JOB_ID; - LCG_JOB_ID; - ALIEN_MASTERJOB_ID; - ALIEN_PROC_ID. The parameter montag is equivalent to the MonaLisa farm name, for the; case of process monitoring it can be a process identifier e.g. a PROOF; session ID. The parameter monserver specifies the server to whom to send the; monitoring UDP packets. If not specified, the hostname (the port is; a default one) is specified in the environment variable APMON_CONFIG. To use TMonaLisaWriter, libMonaLisa.so has to be loaded. According to the fact, that the deepness of the MonaLisa naming scheme; is only 3 (<farm><node><value>), a special naming scheme is used for; process monitoring. There is a high-level method to send progress; information of Tree analysis (# of events, datasize).; To distinguish individual nodes running the processing, part of the; information is kept in the <value> parameter of ML.; <value> is named as:; <site-name>:<host-name>:<pid>:<valuetag>; <site-name> is taken from an environment variable in the following order:; - PROOF_SITE; - GRID_SITE; - ALIEN_SITE; - default 'none'; <host-name> is taken from gSystem->Hostname(); <pid> is the proc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMonaLisaWriter.html:10708,monitor,monitoring,10708,root/html530/TMonaLisaWriter.html,https://root.cern,https://root.cern/root/html530/TMonaLisaWriter.html,2,['monitor'],['monitoring']
Energy Efficiency,"_MACOSX; 3306 ; 3307#if defined (R__LINUX) || defined (R__FBSD); 3308 ; 3309////////////////////////////////////////////////////////////////////////////////; 3310/// Callback for dl_iterate_phdr(), see `man dl_iterate_phdr`.; 3311/// Collects opened libraries.; 3312 ; 3313static int callback_for_dl_iterate_phdr(struct dl_phdr_info *info, size_t size, void *data); 3314{; 3315 // This function is called through UpdateListOfLoadedSharedLibraries() which is locked.; 3316 static std::unordered_set<decltype(info->dlpi_addr)> sKnownLoadedLibBaseAddrs;; 3317 ; 3318 auto newLibs = static_cast<std::vector<std::string>*>(data);; 3319 if (!sKnownLoadedLibBaseAddrs.count(info->dlpi_addr)) {; 3320 // Skip \0, """", and kernel pseudo-libs linux-vdso.so.1 or linux-gate.so.1; 3321 if (info->dlpi_name && info->dlpi_name[0]; 3322#if defined(R__FBSD); 3323 //skip the executable (with null addr); 3324 && info->dlpi_addr; 3325 //has no path; 3326 && strncmp(info->dlpi_name, ""[vdso]"", 6); 3327 //the linker does not like to be mmapped; 3328 //causes a crash in cling::DynamicLibraryManager::loadLibrary()); 3329 //with error message ""mmap of entire address space failed: Cannot allocate memory""; 3330 && strncmp(info->dlpi_name, ""/libexec/ld-elf.so.1"", 20); 3331#endif; 3332 && strncmp(info->dlpi_name, ""linux-vdso.so"", 13); 3333 && strncmp(info->dlpi_name, ""linux-vdso32.so"", 15); 3334 && strncmp(info->dlpi_name, ""linux-vdso64.so"", 15); 3335 && strncmp(info->dlpi_name, ""linux-gate.so"", 13)); 3336 newLibs->emplace_back(info->dlpi_name);; 3337 sKnownLoadedLibBaseAddrs.insert(info->dlpi_addr);; 3338 }; 3339 // No matter what the doc says, return != 0 means ""stop the iteration"".; 3340 return 0;; 3341}; 3342 ; 3343#endif // R__LINUX || R__FBSD; 3344 ; 3345 ; 3346////////////////////////////////////////////////////////////////////////////////; 3347 ; 3348void TCling::UpdateListOfLoadedSharedLibraries(); 3349{; 3350#if defined(R__WIN32) || defined(__CYGWIN__); 3351 HMODULE hModules[1024];; 3352 void *hPro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:128824,allocate,allocate,128824,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['allocate'],['allocate']
Energy Efficiency,"_b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void TPerfStats::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 153 of file TPerfStats.h. ◆ UnzipEvent(). void TPerfStats::UnzipEvent ; (; TObject * ; tree, . Long64_t ; pos, . Double_t ; start, . Int_t ; complen, . Int_t ; objlen . ). overridevirtual . Record TTree file unzip event. ; start is the TimeStamp before unzip pos is where in the file the compressed buffer came from complen is the length of the compressed buffer objlen is the length of the de-compressed buffer ; Implements TVirtualPerfStats.; Definition at line 597 of file TPerfStats.cxx. ◆ UpdateBranchIndices(). void TPerfStats::UpdateBranchIndices ; (; TObjArray * ; ). inlineoverridevirtual . Implements TVirtualPerfStats.; Definition at line 145 of file TPerfStats.h. ◆ WriteQueryLog(). void TPerfStats::WriteQueryLog ; (; ). private . Send to the connected monitoring servers information related to this query. ; The information is of three types: 'summary', 'dataset' and 'files'. Actual 'table' formatting is done by the relevant sender, implementation of TProofMonSender, where the details are given. ; Definition at line 648 of file TPerfStats.cxx. Friends And Related Symbol Documentation. ◆ TProofMonSender. friend class TProofMonSender. friend . Definition at line 72 of file TPerfStats.h. Member Data Documentation. ◆ fBytesRead. Long64_t TPerfStats::fBytesRead. private . histogram of cpu time spent processing packets ; Definition at line 85 of file TPerfStats.h. ◆ fCpuTimeHist. TH2D* TPerfStats::fCpuTimeHist. private . histogram of real time spent processing packets ; Definition at line 84 of file TPerfStats.h. ◆ fDataSet. TString TPerfStats::fDataSet. private . Monitoring engines. ; Definition at line 102 of file TPerfStats.h. ◆ fDataSetLen. Int_t TPerfStats::fDataSetLen. private . Dataset string. ; Definition at line 103 of file TPerfStats.h. ◆ fDataS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPerfStats.html:22317,monitor,monitoring,22317,doc/master/classTPerfStats.html,https://root.cern,https://root.cern/doc/master/classTPerfStats.html,1,['monitor'],['monitoring']
Energy Efficiency,"_buffer_size,; 19784 ""Invalid configuration option value: %s"",; 19785 config_options[MAX_REQUEST_SIZE].name);; 19786 }; 19787 free_context(ctx);; 19788 pthread_setspecific(sTlsKey, NULL);; 19789 return NULL;; 19790 }; 19791 ctx->max_request_size = (unsigned)itmp;; 19792 ; 19793 /* Queue length */; 19794#if !defined(ALTERNATIVE_QUEUE); 19795 itmp = atoi(ctx->dd.config[CONNECTION_QUEUE_SIZE]);; 19796 if (itmp < 1) {; 19797 mg_cry_ctx_internal(ctx,; 19798 ""%s too small"",; 19799 config_options[CONNECTION_QUEUE_SIZE].name);; 19800 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19801 mg_snprintf(NULL,; 19802 NULL, /* No truncation check for error buffers */; 19803 error->text,; 19804 error->text_buffer_size,; 19805 ""Invalid configuration option value: %s"",; 19806 config_options[CONNECTION_QUEUE_SIZE].name);; 19807 }; 19808 free_context(ctx);; 19809 pthread_setspecific(sTlsKey, NULL);; 19810 return NULL;; 19811 }; 19812 ctx->squeue =; 19813 (struct socket *)mg_calloc((unsigned int)itmp, sizeof(struct socket));; 19814 if (ctx->squeue == NULL) {; 19815 mg_cry_ctx_internal(ctx,; 19816 ""Out of memory: Cannot allocate %s"",; 19817 config_options[CONNECTION_QUEUE_SIZE].name);; 19818 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19819 mg_snprintf(NULL,; 19820 NULL, /* No truncation check for error buffers */; 19821 error->text,; 19822 error->text_buffer_size,; 19823 ""Out of memory: Cannot allocate %s"",; 19824 config_options[CONNECTION_QUEUE_SIZE].name);; 19825 }; 19826 free_context(ctx);; 19827 pthread_setspecific(sTlsKey, NULL);; 19828 return NULL;; 19829 }; 19830 ctx->sq_size = itmp;; 19831#endif; 19832 ; 19833 /* Worker thread count option */; 19834 workerthreadcount = atoi(ctx->dd.config[NUM_THREADS]);; 19835 ; 19836 if ((workerthreadcount > MAX_WORKER_THREADS) || (workerthreadcount <= 0)) {; 19837 if (workerthreadcount <= 0) {; 19838 mg_cry_ctx_internal(ctx, ""%s"", ""Invalid number of worker threads"");; 19839 } else {; 19840 mg_cry_ctx_internal(ctx, ""%s"", """,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:591741,allocate,allocate,591741,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['allocate'],['allocate']
Energy Efficiency,"_buffer_size,; 19785 ""Invalid configuration option value: %s"",; 19786 config_options[MAX_REQUEST_SIZE].name);; 19787 }; 19788 free_context(ctx);; 19789 pthread_setspecific(sTlsKey, NULL);; 19790 return NULL;; 19791 }; 19792 ctx->max_request_size = (unsigned)itmp;; 19793 ; 19794 /* Queue length */; 19795#if !defined(ALTERNATIVE_QUEUE); 19796 itmp = atoi(ctx->dd.config[CONNECTION_QUEUE_SIZE]);; 19797 if (itmp < 1) {; 19798 mg_cry_ctx_internal(ctx,; 19799 ""%s too small"",; 19800 config_options[CONNECTION_QUEUE_SIZE].name);; 19801 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19802 mg_snprintf(NULL,; 19803 NULL, /* No truncation check for error buffers */; 19804 error->text,; 19805 error->text_buffer_size,; 19806 ""Invalid configuration option value: %s"",; 19807 config_options[CONNECTION_QUEUE_SIZE].name);; 19808 }; 19809 free_context(ctx);; 19810 pthread_setspecific(sTlsKey, NULL);; 19811 return NULL;; 19812 }; 19813 ctx->squeue =; 19814 (struct socket *)mg_calloc((unsigned int)itmp, sizeof(struct socket));; 19815 if (ctx->squeue == NULL) {; 19816 mg_cry_ctx_internal(ctx,; 19817 ""Out of memory: Cannot allocate %s"",; 19818 config_options[CONNECTION_QUEUE_SIZE].name);; 19819 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19820 mg_snprintf(NULL,; 19821 NULL, /* No truncation check for error buffers */; 19822 error->text,; 19823 error->text_buffer_size,; 19824 ""Out of memory: Cannot allocate %s"",; 19825 config_options[CONNECTION_QUEUE_SIZE].name);; 19826 }; 19827 free_context(ctx);; 19828 pthread_setspecific(sTlsKey, NULL);; 19829 return NULL;; 19830 }; 19831 ctx->sq_size = itmp;; 19832#endif; 19833 ; 19834 /* Worker thread count option */; 19835 workerthreadcount = atoi(ctx->dd.config[NUM_THREADS]);; 19836 ; 19837 if ((workerthreadcount > MAX_WORKER_THREADS) || (workerthreadcount <= 0)) {; 19838 if (workerthreadcount <= 0) {; 19839 mg_cry_ctx_internal(ctx, ""%s"", ""Invalid number of worker threads"");; 19840 } else {; 19841 mg_cry_ctx_internal(ctx, ""%s"", """,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:591774,allocate,allocate,591774,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['allocate'],['allocate']
Energy Efficiency,"_constructible<T>::value) &&; 327 std::is_trivially_destructible<T>::value>; 328class R__CLING_PTRCHECK(off) SmallVectorTemplateBase : public SmallVectorTemplateCommon<T> {; 329protected:; 330 SmallVectorTemplateBase(size_t Size) : SmallVectorTemplateCommon<T>(Size) {}; 331 ; 332 static void destroy_range(T *S, T *E); 333 {; 334 while (S != E) {; 335 --E;; 336 E->~T();; 337 }; 338 }; 339 ; 340 /// Move the range [I, E) into the uninitialized memory starting with ""Dest"",; 341 /// constructing elements as needed.; 342 template <typename It1, typename It2>; 343 static void uninitialized_move(It1 I, It1 E, It2 Dest); 344 {; 345 std::uninitialized_copy(std::make_move_iterator(I), std::make_move_iterator(E), Dest);; 346 }; 347 ; 348 /// Copy the range [I, E) onto the uninitialized memory starting with ""Dest"",; 349 /// constructing elements as needed.; 350 template <typename It1, typename It2>; 351 static void uninitialized_copy(It1 I, It1 E, It2 Dest); 352 {; 353 std::uninitialized_copy(I, E, Dest);; 354 }; 355 ; 356 /// Grow the allocated memory (without initializing new elements), doubling; 357 /// the size of the allocated memory. Guarantees space for at least one more; 358 /// element, or MinSize more elements if specified.; 359 void grow(size_t MinSize = 0);; 360 ; 361public:; 362 void push_back(const T &Elt); 363 {; 364 if (R__unlikely(this->size() >= this->capacity())); 365 this->grow();; 366 ::new ((void *)this->end()) T(Elt);; 367 this->set_size(this->size() + 1);; 368 }; 369 ; 370 void push_back(T &&Elt); 371 {; 372 if (R__unlikely(this->size() >= this->capacity())); 373 this->grow();; 374 ::new ((void *)this->end()) T(::std::move(Elt));; 375 this->set_size(this->size() + 1);; 376 }; 377 ; 378 void pop_back(); 379 {; 380 this->set_size(this->size() - 1);; 381 this->end()->~T();; 382 }; 383};; 384 ; 385// Define this out-of-line to dissuade the C++ compiler from inlining it.; 386template <typename T, bool TriviallyCopyable>; 387void R__CLING_PTRCHECK(off) SmallVec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RVec_8hxx_source.html:12785,allocate,allocated,12785,doc/master/RVec_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html,4,['allocate'],['allocated']
Energy Efficiency,"_eMinimizerType=MinimizerType::fSteepest, double _learningRate=1e-5, double _momentum=0.3, int _repetitions=3, bool _multithreading=true);  c'tor ;  ; virtual ~Settings ();  d'tor ;  ; void addPoint (std::string histoName, double x);  for monitoring ;  ; void addPoint (std::string histoName, double x, double y);  for monitoring ;  ; size_t batchSize () const;  mini-batch size ;  ; void clear (std::string histoName);  for monitoring ;  ; virtual void computeResult (const Net &, std::vector< double > &);  callback for monitoring and logging ;  ; size_t convergenceCount () const;  returns the current convergence count ;  ; size_t convergenceSteps () const;  how many steps until training is deemed to have converged ;  ; void create (std::string histoName, int bins, double min, double max);  for monitoring ;  ; void create (std::string histoName, int bins, double min, double max, int bins2, double min2, double max2);  for monitoring ;  ; virtual void cycle (double progress, TString text);  ; virtual void drawSample (const std::vector< double > &, const std::vector< double > &, const std::vector< double > &, double);  callback for monitoring and logging ;  ; const std::vector< double > & dropFractions () const;  ; size_t dropRepetitions () const;  ; virtual void endTestCycle ();  callback for monitoring and loggging ;  ; virtual void endTrainCycle (double);  callback for monitoring and logging ;  ; bool exists (std::string histoName);  for monitoring ;  ; double factorWeightDecay () const;  get the weight-decay factor ;  ; virtual bool hasConverged (double testError);  has this training converged already? ;  ; double learningRate () const;  get the learning rate ;  ; size_t maxConvergenceCount () const;  returns the max convergence count so far ;  ; size_t minError () const;  returns the smallest error so far ;  ; MinimizerType minimizerType () const;  which minimizer shall be used (e.g. SGD) ;  ; double momentum () const;  get the momentum (e.g. for SGD) ;  ; void pads (",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1Settings.html:869,monitor,monitoring,869,doc/master/classTMVA_1_1DNN_1_1Settings.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1Settings.html,10,['monitor'],['monitoring']
Energy Efficiency,"_events = d[4] # Number of events; samples.append(sample); df[sample] = ROOT.RDataFrame(""mini"", ""{}/1lep/{}/{}.1lep.root"".format(dataset_path, folder, sample)); ; # Scale down the datasets if requested; if args.full_dataset and lumi_scale < 1.0:; df[sample] = df[sample].Range(int(num_events * lumi_scale)); ; # Select events for the analysis; ; # Just-in-time compile custom helper function performing complex computations; ROOT.gInterpreter.Declare(""""""; bool GoodElectronOrMuon(int type, float pt, float eta, float phi, float e, float trackd0pv, float tracksigd0pv, float z0); {; ROOT::Math::PtEtaPhiEVector p(pt / 1000.0, eta, phi, e / 1000.0);; if (abs(z0 * sin(p.theta())) > 0.5) return false;; if (type == 11 && abs(eta) < 2.46 && (abs(eta) < 1.37 || abs(eta) > 1.52)) {; if (abs(trackd0pv / tracksigd0pv) > 5) return false;; return true;; }; if (type == 13 && abs(eta) < 2.5) {; if (abs(trackd0pv / tracksigd0pv) > 3) return false;; return true;; }; return false;; }; """"""); ; for s in samples:; # Select events with a muon or electron trigger and with a missing transverse energy larger than 30 GeV; df[s] = df[s].Filter(""trigE || trigM"")\; .Filter(""met_et > 30000""); ; # Find events with exactly one good lepton; df[s] = df[s].Define(""good_lep"", ""lep_isTightID && lep_pt > 35000 && lep_ptcone30 / lep_pt < 0.1 && lep_etcone20 / lep_pt < 0.1"")\; .Filter(""ROOT::VecOps::Sum(good_lep) == 1""); ; # Apply additional cuts in case the lepton is an electron or muon; df[s] = df[s].Define(""idx"", ""ROOT::VecOps::ArgMax(good_lep)"")\; .Filter(""GoodElectronOrMuon(lep_type[idx], lep_pt[idx], lep_eta[idx], lep_phi[idx], lep_E[idx], lep_trackd0pvunbiased[idx], lep_tracksigd0pvunbiased[idx], lep_z0[idx])""); ; # Apply luminosity, scale factors and MC weights for simulated events; for s in samples:; if ""data"" in s:; df[s] = df[s].Define(""weight"", ""1.0""); else:; df[s] = df[s].Define(""weight"", ""scaleFactor_ELE * scaleFactor_MUON * scaleFactor_LepTRIGGER * scaleFactor_PILEUP * mcWeight * {} / {} * {}"".form",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/df105__WBosonAnalysis_8py.html:4107,energy,energy,4107,doc/master/df105__WBosonAnalysis_8py.html,https://root.cern,https://root.cern/doc/master/df105__WBosonAnalysis_8py.html,1,['energy'],['energy']
Energy Efficiency,"_iterator rbegin () const noexcept;  ; reverse_iterator rbegin () noexcept;  ; const_reverse_iterator rend () const noexcept;  ; reverse_iterator rend () noexcept;  ; size_t size () const;  ; size_type size_in_bytes () const;  ;  Public Member Functions inherited from ROOT::Internal::VecOps::SmallVectorBase; size_t capacity () const noexcept;  ; bool empty () const;  ; void set_size (size_t N);  Set the array size to N, which the current array must have enough capacity for. ;  ; size_t size () const;  . Protected Member Functions;  SmallVectorTemplateCommon (size_t Size);  ; void grow_pod (size_t MinSize, size_t TSize);  ; bool isSmall () const;  Return true if this is a smallvector which has not had dynamic memory allocated for it. ;  ; void resetToSmall ();  Put this vector in a state of being small. ;  ;  Protected Member Functions inherited from ROOT::Internal::VecOps::SmallVectorBase;  SmallVectorBase ()=delete;  ;  SmallVectorBase (void *FirstEl, size_t TotalCapacity);  ; void grow_pod (void *FirstEl, size_t MinSize, size_t TSize);  This is an implementation of the grow() method which only works on POD-like data types and is out of line to reduce code duplication. ;  ; bool Owns () const;  If false, the RVec is in ""memory adoption"" mode, i.e. it is acting as a view on a memory buffer it does not own. ;  . Private Types; using Base = SmallVectorBase;  . Private Member Functions; void * getFirstEl () const;  Find the address of the first element. ;  . Additional Inherited Members;  Static Protected Member Functions inherited from ROOT::Internal::VecOps::SmallVectorBase; static void report_at_maximum_capacity ();  Report that this vector is already at maximum capacity. ;  ; static void report_size_overflow (size_t MinSize);  Report that MinSize doesn't fit into this vector's size type. ;  ; static constexpr size_t SizeTypeMax ();  The maximum value of the Size_T used. ;  ;  Protected Attributes inherited from ROOT::Internal::VecOps::SmallVectorBase; void * fBeginX",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Internal_1_1VecOps_1_1SmallVectorTemplateCommon.html:3149,reduce,reduce,3149,doc/master/classROOT_1_1Internal_1_1VecOps_1_1SmallVectorTemplateCommon.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Internal_1_1VecOps_1_1SmallVectorTemplateCommon.html,1,['reduce'],['reduce']
Energy Efficiency,"_nonzeros = 0); Allocate new matrix. Arguments are number of rows, columns, row lowerbound (0 default); and column lowerbound (0 default), 0 initialization flag and number of non-zero; elements (only relevant for sparse format). TMatrixTBase<Element> &TMatrixTSparse<Element> InsertRow(Int_t row, Int_t col, const double* v, Int_t n = -1); Insert in row rown, n elements of array v at column coln. void TMatrixTSparse<Element> ExtractRow(Int_t row, Int_t col, double* v, Int_t n = -1) const; Store in array v, n matrix elements of row rown starting at column coln. void TMatrixTSparse<Element> AMultBt(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMultBt(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMultBt(const TMatrixT<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixTSparse<Element> &a,const TMatri",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMatrixTSparse_double_.html:17979,allocate,allocated,17979,root/html528/TMatrixTSparse_double_.html,https://root.cern,https://root.cern/root/html528/TMatrixTSparse_double_.html,6,['allocate'],['allocated']
Energy Efficiency,"_t &higherBin, Double_t &lowerBinValue, Double_t &higherBinValue, Double_t y, Bool_t isMonotonouslyIncreasingFunction=kFALSE) const;  find bin from value on ordinate ;  ; Double_t GetIntegral () const;  computes normalisation ;  ; Double_t GetPdfHistBinWidth () const;  ; MsgLogger & Log () const;  ; void SmoothHistogram ();  ; Bool_t UseHistogram () const;  . Static Private Member Functions; static PDF *& GetThisPdfThreadLocal ();  ; static Double_t IGetVal (Double_t *, Double_t *);  static external auxiliary function (integrand) ;  ; static PDF * ThisPDF (void);  . Private Attributes; TString fBorderMethodString;  ; Bool_t fCheckHist;  check of source histogram ;  ; Float_t fFineFactor;  fine tuning factor for Adaptive KDE ;  ; TGraph * fGraph;  ! needed to create PDF from histogram ;  ; TH1 * fHist;  copy of input histogram ;  ; Int_t fHistAvgEvtPerBin;  avg event per source hist bin ;  ; Int_t fHistDefinedNBins;  source hist bin num set by user ;  ; TH1 * fHistOriginal;  the input histogram ;  ; TF1 * fIGetVal;  integration interface ;  ; TString fInterpolateString;  ; TMVA::PDF::EInterpolateMethod fInterpolMethod;  interpolation method ;  ; KDEKernel::EKernelBorder fKDEborder;  The method to take care about ""border"" effects (string) ;  ; KDEKernel::EKernelIter fKDEiter;  Number of iterations (adaptive or not) ;  ; TString fKDEiterString;  ; KDEKernel::EKernelType fKDEtype;  Kernel type to use for KDE. ;  ; TString fKDEtypeString;  strings used to read definitions ;  ; MsgLogger * fLogger;  ! message logger ;  ; Int_t fMaxNsmooth;  Max number of smoothing iterations. ;  ; Int_t fMinNsmooth;  Min number of smoothing iterations. ;  ; Bool_t fNormalize;  normalize histogram (false for cumulative distribution used in GaussTranform) ;  ; Int_t fNsmooth;  Min number of smoothing iterations. ;  ; TH1 * fNSmoothHist;  number of smooth for each bin ;  ; TH1 * fPDFHist;  the high-binned histogram corresponding to the PDF ;  ; TString fPDFName;  for output ;  ; UInt_t fRead",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1PDF.html:16563,adapt,adaptive,16563,doc/master/classTMVA_1_1PDF.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1PDF.html,1,['adapt'],['adaptive']
Energy Efficiency,"_t *option="""") constCompute and return the chisquare of this histogram with respect to a function The chisquare is comput...Definition TH1.cxx:2496; TH1::Chi2Testvirtual Double_t Chi2Test(const TH1 *h2, Option_t *option=""UU"", Double_t *res=nullptr) consttest for comparing weighted and unweighted histograms.Definition TH1.cxx:2008; TH1::DoFillNvirtual void DoFillN(Int_t ntimes, const Double_t *x, const Double_t *w, Int_t stride=1)Internal method to fill histogram content from a vector called directly by TH1::BufferEmpty.Definition TH1.cxx:3473; TH1::GetMinimumAndMaximumvirtual void GetMinimumAndMaximum(Double_t &min, Double_t &max) constRetrieve the minimum and maximum values in the histogram.Definition TH1.cxx:8731; TH1::kNstat@ kNstatSize of statistics data (up to TProfile3D)Definition TH1.h:184; TH1::GetMaximumBinvirtual Int_t GetMaximumBin() constReturn location of bin with maximum value in the range.Definition TH1.cxx:8577; TH1::AutoP2GetBinsstatic Int_t AutoP2GetBins(Int_t n)Auxiliary function to get the next power of 2 integer value larger then n.Definition TH1.cxx:1321; TH1::fEntriesDouble_t fEntriesNumber of entries.Definition TH1.h:95; TH1::Mergevirtual Long64_t Merge(TCollection *list)Definition TH1.h:345; TH1::SetColorsvirtual void SetColors(Color_t linecolor=-1, Color_t markercolor=-1, Color_t fillcolor=-1)Shortcut to set the three histogram colors with a single call.Definition TH1.cxx:4467; TH1::ExecuteEventvoid ExecuteEvent(Int_t event, Int_t px, Int_t py) overrideExecute action corresponding to one event.Definition TH1.cxx:3240; TH1::GetIntegralvirtual Double_t * GetIntegral()Return a pointer to the array of bins integral.Definition TH1.cxx:2586; TH1::fZaxisTAxis fZaxisZ axis descriptor.Definition TH1.h:92; TH1::fStatOverflowsEStatOverflows fStatOverflowsPer object flag to use under/overflows in statistics.Definition TH1.h:114; TH1::IsATClass * IsA() const overrideDefinition TH1.h:444; TH1::FillNvirtual void FillN(Int_t ntimes, const Double_t *x, const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:453242,power,power,453242,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,1,['power'],['power']
Energy Efficiency,"_t * ; y, . Int_t ; n, . Double_t * ; ys, . Double_t ; span, . Int_t ; iter, . Double_t ; delta . ). Lowess regression smoother. ; Based on R function clowess: Translated to C++ by C. Stratowa (R source file: lowess.c by R Development Core Team (C) 1999-2001) ; Definition at line 247 of file TGraphSmooth.cxx. ◆ Lowest(). void TGraphSmooth::Lowest ; (; Double_t * ; x, . Double_t * ; y, . Int_t ; n, . Double_t & ; xs, . Double_t & ; ys, . Int_t ; nleft, . Int_t ; nright, . Double_t * ; w, . Bool_t ; userw, . Double_t * ; rw, . Bool_t & ; ok . ). static . Fit value at x[i] Based on R function lowest: Translated to C++ by C. ; Stratowa (R source file: lowess.c by R Development Core Team (C) 1999-2001) ; Definition at line 370 of file TGraphSmooth.cxx. ◆ operator=(). TGraphSmooth & TGraphSmooth::operator= ; (; const TGraphSmooth & ; ). private . ◆ Psort(). void TGraphSmooth::Psort ; (; Double_t * ; x, . Int_t ; n, . Int_t ; k . ). static . Static function based on R function rPsort: adapted to C++ by Christian Stratowa (R source file: R_sort.c by R Development Core Team (C) 1999-2001) ; Definition at line 1105 of file TGraphSmooth.cxx. ◆ Rank(). void TGraphSmooth::Rank ; (; Int_t ; n, . Double_t * ; a, . Int_t * ; index, . Int_t * ; rank, . Bool_t ; down = kTRUE . ). static . static function ; Definition at line 1125 of file TGraphSmooth.cxx. ◆ Rcmp(). Int_t TGraphSmooth::Rcmp ; (; Double_t ; x, . Double_t ; y . ). static . Static function if (ISNAN(x)) return 1; if (ISNAN(y)) return -1;. ; Definition at line 1093 of file TGraphSmooth.cxx. ◆ Smoothin(). void TGraphSmooth::Smoothin ; (; TGraph * ; grin). Sort input data points. ; Definition at line 72 of file TGraphSmooth.cxx. ◆ SmoothKern(). TGraph * TGraphSmooth::SmoothKern ; (; TGraph * ; grin, . Option_t * ; option = ""normal"", . Double_t ; bandwidth = 0.5, . Int_t ; nout = 100, . Double_t * ; xout = nullptr . ). Smooth data with Kernel smoother. ; Smooth grin with the Nadaraya-Watson kernel regression estimate.; Parame",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGraphSmooth.html:22489,adapt,adapted,22489,doc/master/classTGraphSmooth.html,https://root.cern,https://root.cern/doc/master/classTGraphSmooth.html,1,['adapt'],['adapted']
Energy Efficiency,"_t Erfc(Double_t x)Computes the complementary error function erfc(x).Definition TMath.cxx:199; TMath::VavilovIDouble_t VavilovI(Double_t x, Double_t kappa, Double_t beta2)Returns the value of the Vavilov cumulative distribution function (lower tail integral of the probabi...Definition TMath.cxx:2815; TMath::Sigmaconstexpr Double_t Sigma()Stefan-Boltzmann constant in : .Definition TMath.h:270; TMath::BetaDouble_t Beta(Double_t p, Double_t q)Calculates Beta-function Gamma(p)*Gamma(q)/Gamma(p+q).Definition TMath.cxx:2011; TMath::Kcgsconstexpr Double_t Kcgs()Definition TMath.h:254; TMath::SqDouble_t Sq(Double_t x)Returns x*x.Definition TMath.h:656; TMath::PoissonDouble_t Poisson(Double_t x, Double_t par)Computes the Poisson distribution function for (x,par).Definition TMath.cxx:587; TMath::Hconstexpr Double_t H()Planck's constant in : .Definition TMath.h:188; TMath::SqrtDouble_t Sqrt(Double_t x)Returns the square root of x.Definition TMath.h:662; TMath::PowerLongDouble_t Power(LongDouble_t x, LongDouble_t y)Returns x raised to the power y.Definition TMath.h:721; TMath::CeilNintInt_t CeilNint(Double_t x)Returns the nearest integer of TMath::Ceil(x).Definition TMath.h:674; TMath::LdexpDouble_t Ldexp(Double_t x, Int_t exp)Returns the result of multiplying x (the significant) by 2 raised to the power of exp (the exponent).Definition TMath.h:715; TMath::BesselJ0Double_t BesselJ0(Double_t x)Modified Bessel function K_1(x)Definition TMath.cxx:1634; TMath::LogEconstexpr Double_t LogE()Base-10 log of e (to convert ln to log)Definition TMath.h:107; TMath::GammaDouble_t Gamma(Double_t z)Computation of gamma(z) for all z.Definition TMath.cxx:353; TMath::MWairconstexpr Double_t MWair()Molecular weight of dry air 1976 US Standard Atmosphere in orDefinition TMath.h:317; TMath::Gcgsconstexpr Double_t Gcgs()Definition TMath.h:143; TMath::StruveL0Double_t StruveL0(Double_t x)Struve functions of order 1.Definition TMath.cxx:1923; TMath::NormQuantileDouble_t NormQuantile(Double_t p)Computes",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMath_8h_source.html:66196,power,power,66196,doc/master/TMath_8h_source.html,https://root.cern,https://root.cern/doc/master/TMath_8h_source.html,1,['power'],['power']
Energy Efficiency,"_t a, Double_t z, Double_t weight)Definition TGeoMaterial.h:226; or:; void AddElement(TGeoMaterial* mat, Double_t weight);; void AddElement(TGeoElement* elem, Double_t weight);; void AddElement(TGeoElement* elem, Int_t natoms);; void AddElement(Double_t a, Double_t z, Double_t weight). iel: index of the element[0,nel-1]; a and z: the atomic mass and charge; weight: proportion by mass of the elements; natoms: number of atoms of the element in the molecule making the mixture. The radiation length is automatically computed when all elements are defined. Since tracking MC provide several other ways to create materials/mixtures, the materials classes are likely to evolve as the interfaces to these engines are being developed. Generally in the process of tracking material properties are not enough and more specific media properties have to be defined. These highly depend on the MC performing tracking and sometimes allow the definition of different media properties (e.g. energy or range cuts) for the same material. Radionuclides; A new class TGeoElementRN was introduced in this version to provide support for radioactive nuclides and their decays. A database of 3162 radionuclides can be loaded on demand via the table of elements (TGeoElementTable class). One can make then materials/mixtures based on these radionuclides and use them in a geometry; root[] TGeoManager *geom = new TGeoManager(""geom"",""radionuclides"");; root[] TGeoElementTable *table = geom->GetElementTable();; root[] TGeoElementRN *c14 = table->GetElementRN(14,6); // A,Z; root[] c14->Print();; 6-C-014 ENDF=60140; A=14; Z=6; Iso=0; Level=0[MeV]; Dmass=3.0199[MeV];; Hlife=1.81e+11[s] J/P=0+; Abund=0; Htox=5.8e-10; Itox=5.8e-10; Stat=0; Decay modes:; BetaMinus Diso: 0 BR: 100.000% Qval: 0.1565; TGeoElementRNClass representing a radionuclidevoid TGeoManager::SetDefaultRootUnits() { if ( fgDefaultUnits == kRo...Definition TGeoElement.h:132; TGeoElementRN::Printvoid Print(Option_t *option="""") const overridePrint info a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Materials__classes.html:6122,energy,energy,6122,doc/master/group__Materials__classes.html,https://root.cern,https://root.cern/doc/master/group__Materials__classes.html,1,['energy'],['energy']
Energy Efficiency,"_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. THnSparseArrayChunk*THnSparse::AddChunk(); voidTHnBase::AddInternal(const THnBase* h, Double_t c, Bool_t rebinned); Bool_tTHnBase::CheckConsistency(const THnBase* h, const char* tag) const; THnBase*THnBase::CloneEmpty(const char* name, const char* title, const TObjArray* axes, Bool_t keepTargetAxis) const; TH1*THnBase::CreateHist(const char* name, const char* title, const TObjArray* axes, Bool_t keepTargetAxis) const; static THnBase*THnBase::CreateHnAny(const char* name, const char* title, const TH1* h1, Bool_t sparse, Int_t chunkSize = 1024*16); static THnBase*THnBase::CreateHnAny(const char* name, const char* title, const THnBase* hn, Bool_t sparse, Int_t chunkSize = 1024*16); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual voidTHnSparse::FillBin(Long64_t bin, Double_t w); voidTHnBase::FillBinBase(Double_t w); voidTHnSparse::FillExMap(); Long64_tTHnSparse::GetBinIndexForCurrentBin(Bool_t allocate); THnSparseArrayChunk*THnSparse::GetChunk(Int_t idx) const; THnSparseCompactBinCoord*THnSparse::GetCompactCoord() const; voidTHnBase::Init(const char* name, const char* title, const TObjArray* axes, Bool_t keepTargetAxis, Int_t chunkSize = 1024*16); virtual voidTHnSparse::InitStorage(Int_t* nbins, Int_t chunkSize); voidTObject::MakeZombie(); Bool_tTHnBase::PrintBin(Long64_t idx, Int_t* coord, Option_t* options) const; TObject*THnBase::ProjectionAny(Int_t ndim, const Int_t* dim, Bool_t wantNDim, Option_t* option = """") const; THnBase*THnBase::RebinBase(Int_t group) const; THnBase*THnBase::RebinBase(const Int_t* group) const; virtual voidTHnSparse::Reserve(Long64_t nbins); voidTHnBase::ResetBase(Option_t* option = """"); voidTHnBase::UpdateXStat(const Double_t* x, Double_t w = 1.). Data Members; public:. enum THnBase::[unnamed] { kNoInt; kValidInt; kInvalidInt; };; enum TObject::EStatusBits { kCanDe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/THnSparseT_TArrayC_.html:11539,allocate,allocate,11539,root/html534/THnSparseT_TArrayC_.html,https://root.cern,https://root.cern/root/html534/THnSparseT_TArrayC_.html,6,['allocate'],['allocate']
Energy Efficiency,"_t dark, Int_t light); Draw a Frame around a box. mode = -1 the box looks as it is behind the screen; mode = 1 the box looks as it is in front of the screen; border is the border size in already pre-computed dark is the; color for the dark part of the frame light is the color for the light; part of the frame. void DrawPolyMarker(Int_t n, Float_t* x, Float_t* y); not used. void DrawPolyMarker(Int_t n, Double_t* x, Double_t* y); draw polymarker. void DrawPS(Int_t n, Double_t* xw, Double_t* yw); This function defines a path with xw and yw and draw it according the; value of nn:. If nn > 0 a line is drawn.; If nn < 0 a closed polygon is drawn. void DrawPS(Int_t n, Float_t* xw, Float_t* yw); not used. void DrawDashPolyLine(Int_t npoints, TPoint* pt, UInt_t nDash, const char* pDash, const char* col, UInt_t thick); draw dashed polyline. void NewPage(); new page. void Text(Double_t x, Double_t y, const char* string); Draw text. x: x position of the text; y: y position of the text. void CellArrayBegin(Int_t W, Int_t H, Double_t x1, Double_t x2, Double_t y1, Double_t y2); cell array begin. void CellArrayFill(Int_t r, Int_t g, Int_t b); Cell array fill. void CellArrayEnd(); Cell array end. void SetColor(Float_t r, Float_t g, Float_t b); Set color with its R G B components. r: % of red in [0,1]; g: % of green in [0,1]; b: % of blue in [0,1]. Int_t XtoPixel(Double_t x); x to pixel. Int_t YtoPixel(Double_t y); y to pixel. void * GetStream() const; { return (void*)fImage; }. void SetType(Int_t type = -111); { fType = type; }. Int_t GetType() const; { return fType; }. TImage * GetImage() const; { return fImage; }. » Author: Valeriy Onuchin 29/04/2005 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/postscript:$Id: TImageDump.h 22872 2008-03-27 16:59:12Z couet $ » Last generated: 2010-10-11 11:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TImageDump.html:12683,green,green,12683,root/html528/TImageDump.html,https://root.cern,https://root.cern/root/html528/TImageDump.html,1,['green'],['green']
Energy Efficiency,"_t dark, Int_t light); Draw a Frame around a box. mode = -1 the box looks as it is behind the screen; mode = 1 the box looks as it is in front of the screen; border is the border size in already pre-computed dark is the; color for the dark part of the frame light is the color for the light; part of the frame. void DrawPolyMarker(Int_t n, Float_t* x, Float_t* y); not used. void DrawPolyMarker(Int_t n, Double_t* x, Double_t* y); draw polymarker. void DrawPS(Int_t n, Double_t* xw, Double_t* yw); This function defines a path with xw and yw and draw it according the; value of nn:. If nn > 0 a line is drawn.; If nn < 0 a closed polygon is drawn. void DrawPS(Int_t n, Float_t* xw, Float_t* yw); not used. void DrawDashPolyLine(Int_t npoints, TPoint* pt, UInt_t nDash, const char* pDash, const char* col, UInt_t thick); draw dashed polyline. void NewPage(); new page. void Text(Double_t x, Double_t y, const char* string); Draw text. x: x position of the text; y: y position of the text. void CellArrayBegin(Int_t W, Int_t H, Double_t x1, Double_t x2, Double_t y1, Double_t y2); cell array begin. void CellArrayFill(Int_t r, Int_t g, Int_t b); Cell array fill. void CellArrayEnd(); Cell array end. void SetColor(Float_t r, Float_t g, Float_t b); Set color with its R G B components. r: % of red in [0,1]; g: % of green in [0,1]; b: % of blue in [0,1]. Int_t XtoPixel(Double_t x); x to pixel. Int_t YtoPixel(Double_t y); y to pixel. void * GetStream() const; { return (void*)fImage; }. void SetType(Int_t type = -111); { fType = type; }. Int_t GetType() const; { return fType; }. TImage * GetImage() const; { return fImage; }. » Author: Valeriy Onuchin 29/04/2005 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/postscript:$Id: TImageDump.h 22872 2008-03-27 16:59:12Z couet $ » Last generated: 2011-07-04 15:33; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TImageDump.html:12752,green,green,12752,root/html530/TImageDump.html,https://root.cern,https://root.cern/root/html530/TImageDump.html,1,['green'],['green']
Energy Efficiency,"_t dark, Int_t light); Draw a Frame around a box. mode = -1 the box looks as it is behind the screen; mode = 1 the box looks as it is in front of the screen; border is the border size in already pre-computed dark is the; color for the dark part of the frame light is the color for the light; part of the frame. void DrawPolyMarker(Int_t n, Float_t* x, Float_t* y); not used. void DrawPolyMarker(Int_t n, Double_t* x, Double_t* y); draw polymarker. void DrawPS(Int_t n, Double_t* xw, Double_t* yw); This function defines a path with xw and yw and draw it according the; value of nn:. If nn > 0 a line is drawn.; If nn < 0 a closed polygon is drawn. void DrawPS(Int_t n, Float_t* xw, Float_t* yw); not used. void DrawDashPolyLine(Int_t npoints, TPoint* pt, UInt_t nDash, const char* pDash, const char* col, UInt_t thick); draw dashed polyline. void NewPage(); new page. void Text(Double_t x, Double_t y, const char* string); Draw text. x: x position of the text; y: y position of the text. void CellArrayBegin(Int_t W, Int_t H, Double_t x1, Double_t x2, Double_t y1, Double_t y2); cell array begin. void CellArrayFill(Int_t r, Int_t g, Int_t b); Cell array fill. void CellArrayEnd(); Cell array end. void SetColor(Float_t r, Float_t g, Float_t b); Set color with its R G B components. r: % of red in [0,1]; g: % of green in [0,1]; b: % of blue in [0,1]. Int_t XtoPixel(Double_t x); x to pixel. Int_t YtoPixel(Double_t y); y to pixel. void * GetStream() const; { return (void*)fImage; }. void SetType(Int_t type = -111); { fType = type; }. Int_t GetType() const; { return fType; }. TImage * GetImage() const; { return fImage; }. » Author: Valeriy Onuchin 29/04/2005 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/postscript:$Id: TImageDump.h 22872 2008-03-27 16:59:12Z couet $ » Last generated: 2011-12-02 14:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TImageDump.html:12752,green,green,12752,root/html532/TImageDump.html,https://root.cern,https://root.cern/root/html532/TImageDump.html,1,['green'],['green']
Energy Efficiency,"_t date, Int_t time); TDatime(Int_t year, Int_t month, Int_t day, Int_t hour, Int_t min, Int_t sec). Data Members; protected:. UInt_tfDatimeDate (relative to 1995) + time. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TDatime(); Create a TDatime and set it to the current time. TDatime(Int_t date, Int_t time); Create a TDatime and set it to the specified date and time.; See Set(Int_t, Int_t) about the date, time format. TDatime(Int_t year, Int_t month, Int_t day, Int_t hour, Int_t min, Int_t sec); Create a TDatime and set it to the specified year, month,; day, time, hour, minute and second. See Set() about the format. TDatime(const char* sqlDateTime); Expects as input a string in SQL date/time compatible format, like:; yyyy-mm-dd hh:mm:ss. Int_t GetDayOfWeek() const; Returns day of week, with Monday being day 1 and Sunday day 7. const char * AsString() const; Return the date & time as a string (ctime() format).; Copy result because it points to a statically allocated string. const char * AsString(char* out) const; Return the date & time as a string (ctime() format).; Result is copied into out (and out is returned). Make sure; out can at least contain 26 characters. Thread safe. const char * AsSQLString() const; Return the date & time in SQL compatible string format, like:; 1997-01-15 20:16:28. The returned string buffer is static and; will be reused. UInt_t Convert(Bool_t toGMT = kFALSE) const; Convert fDatime from TDatime format to the standard time_t format.; If toGMT is true, the time offset of the current local time zone is; subtracted from the returned time_t. One use of such a non-standard time_t; value is to convert a TDatime object that contains local time to GMT,; as in this example:. TDatime now;; now.Set(now.Convert(kTRUE));. Caution: the time_t returned from Convert(kTRUE) is incompatible with; regular Unix time - it contains an artificial, locale-dependent offset. void Copy(TDatime& datime) const; Copy this to ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TDatime.html:3045,allocate,allocated,3045,root/html602/TDatime.html,https://root.cern,https://root.cern/root/html602/TDatime.html,2,['allocate'],['allocated']
Energy Efficiency,"_t green[9] = { 0.0000, 0.1147, 0.3616, 0.5041, 0.4577, 0.4691, 0.6905, 0.9237, 1.0000};; 3059 Double_t blue[9] = { 0.0000, 0.2669, 0.3121, 0.1318, 0.2236, 0.6741, 0.9882, 0.9593, 1.0000};; 3060 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3061 }; 3062 break;; 3063 ; 3064 // Green Red Violet; 3065 case 59:; 3066 {; 3067 Double_t red[9] = {13./255., 23./255., 25./255., 63./255., 76./255., 104./255., 137./255., 161./255., 206./255.};; 3068 Double_t green[9] = {95./255., 67./255., 37./255., 21./255., 0./255., 12./255., 35./255., 52./255., 79./255.};; 3069 Double_t blue[9] = { 4./255., 3./255., 2./255., 6./255., 11./255., 22./255., 49./255., 98./255., 208./255.};; 3070 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3071 }; 3072 break;; 3073 ; 3074 // Blue Red Yellow; 3075 case 60:; 3076 {; 3077 Double_t red[9] = {0./255., 61./255., 89./255., 122./255., 143./255., 160./255., 185./255., 204./255., 231./255.};; 3078 Double_t green[9] = {0./255., 0./255., 0./255., 0./255., 14./255., 37./255., 72./255., 132./255., 235./255.};; 3079 Double_t blue[9] = {0./255., 140./255., 224./255., 144./255., 4./255., 5./255., 6./255., 9./255., 13./255.};; 3080 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3081 }; 3082 break;; 3083 ; 3084 // Ocean; 3085 case 61:; 3086 {; 3087 Double_t red[9] = { 14./255., 7./255., 2./255., 0./255., 5./255., 11./255., 55./255., 131./255., 229./255.};; 3088 Double_t green[9] = {105./255., 56./255., 26./255., 1./255., 42./255., 74./255., 131./255., 171./255., 229./255.};; 3089 Double_t blue[9] = { 2./255., 21./255., 35./255., 60./255., 92./255., 113./255., 160./255., 185./255., 229./255.};; 3090 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3091 }; 3092 break;; 3093 ; 3094 // Color Printable On Grey; 3095 case 62:; 3096 {; 3097 Double_t red[9] = { 0./255., 0./255., 0./255., 70./255., 148./255., 231./255., 235./255., 237./25",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TColor_8cxx_source.html:116326,green,green,116326,doc/master/TColor_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html,1,['green'],['green']
Energy Efficiency,"_t obegin) override;  Copy errors from fE*** to arrays[***] or to f*** Copy points. ;  ; Bool_t CtorAllocate ();  Should be called from ctors after fNpoints has been set. ;  ; Bool_t DoMerge (const TGraph *g) override;  Protected function to perform the merge operation of a graph with asymmetric errors. ;  ; void FillZero (Int_t begin, Int_t end, Bool_t from_ctor=kTRUE) override;  Set zero values for point arrays in the range [begin, end] ;  ; void SwapPoints (Int_t pos1, Int_t pos2) override;  Swap points. ;  ; void UpdateArrays (const std::vector< Int_t > &sorting_indices, Int_t numSortedPoints, Int_t low) override;  Update the fX, fY, fEXlow, fEXhigh, fEYlow and fEYhigh arrays with the sorted values. ;  ;  Protected Member Functions inherited from TGraph; Double_t ** AllocateArrays (Int_t Narrays, Int_t arraySize);  Allocate arrays. ;  ; Bool_t CtorAllocate ();  In constructors set fNpoints than call this method. ;  ; Double_t ** ExpandAndCopy (Int_t size, Int_t iend);  if size > fMaxSize allocate new arrays of 2*size points and copy iend first points. ;  ; TString SaveArray (std::ostream &out, const char *suffix, Int_t frameNumber, Double_t *arr);  Save array as C++ code Returns name of created array. ;  ; void SaveHistogramAndFunctions (std::ostream &out, const char *varname, Int_t &frameNumber, Option_t *option);  Save histogram and list of functions of TGraph as C++ statement Used in all TGraph-derived classes. ;  ; Double_t ** ShrinkAndCopy (Int_t size, Int_t iend);  if size*2 <= fMaxSize allocate new arrays of size points, copy points [0,oend). ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Private Member Functions; void addPoint (Axis_t binCenter, double y, double yscale, double exlow, double exhigh, double eylow, double eyhigh);  . Private Attributes; double _entries = 0.0;  Number of entr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooHist.html:38655,allocate,allocate,38655,doc/master/classRooHist.html,https://root.cern,https://root.cern/doc/master/classRooHist.html,1,['allocate'],['allocate']
Energy Efficiency,"_t obegin) override;  Copy errors from fE*** to arrays[***] or to f*** Copy points. ;  ; Bool_t CtorAllocate ();  Should be called from ctors after fNpoints has been set. ;  ; Bool_t DoMerge (const TGraph *g) override;  Protected function to perform the merge operation of a graph with asymmetric errors. ;  ; void FillZero (Int_t begin, Int_t end, Bool_t from_ctor=kTRUE) override;  Set zero values for point arrays in the range [begin, end] ;  ; void SwapPoints (Int_t pos1, Int_t pos2) override;  Swap points. ;  ; void UpdateArrays (const std::vector< Int_t > &sorting_indices, Int_t numSortedPoints, Int_t low) override;  Update the fX, fY, fEXlow, fEXhigh, fEYlow and fEYhigh arrays with the sorted values. ;  ;  Protected Member Functions inherited from TGraph; Double_t ** AllocateArrays (Int_t Narrays, Int_t arraySize);  Allocate arrays. ;  ; Bool_t CtorAllocate ();  In constructors set fNpoints than call this method. ;  ; Double_t ** ExpandAndCopy (Int_t size, Int_t iend);  if size > fMaxSize allocate new arrays of 2*size points and copy iend first points. ;  ; TString SaveArray (std::ostream &out, const char *suffix, Int_t frameNumber, Double_t *arr);  Save array as C++ code Returns name of created array. ;  ; void SaveHistogramAndFunctions (std::ostream &out, const char *varname, Int_t &frameNumber, Option_t *option);  Save histogram and list of functions of TGraph as C++ statement Used in all TGraph-derived classes. ;  ; Double_t ** ShrinkAndCopy (Int_t size, Int_t iend);  if size*2 <= fMaxSize allocate new arrays of size points, copy points [0,oend). ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; Double_t * fEXhigh {nullptr};  [fNpoints] array of X high errors ;  ; Double_t * fEXlow {nullptr};  [fNpoints] array of X low errors ;  ; Double_t * fEYhigh {nullptr};  [fNpoints] ar",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGraphAsymmErrors.html:32217,allocate,allocate,32217,doc/master/classTGraphAsymmErrors.html,https://root.cern,https://root.cern/doc/master/classTGraphAsymmErrors.html,1,['allocate'],['allocate']
Energy Efficiency,"_t r, uint8_t g, uint8_t b);  Construct color with provided r,g,b values. ;  ;  RColor (uint8_t r, uint8_t g, uint8_t b, float alpha);  Construct color with provided r,g,b and alpha values. ;  ; std::string AsHex (bool with_alpha=false) const;  Returns color value in hex format like ""66FF66"" - without any prefix Alpha parameter can be optionally included. ;  ; std::vector< uint8_t > AsRGBA () const;  Returns color as RGBA array, trying also convert color name into RGBA value. ;  ; const std::string & AsString () const;  Returns color as it stored as string. ;  ; std::string AsSVG () const;  Returns color value as it will be used in SVG drawing It either include hex format #66FF66 or just plain SVG name. ;  ; void Clear ();  ; uint8_t GetAlpha () const;  Returns color alpha (opacity) as uint8_t 0..255. ;  ; float GetAlphaFloat () const;  Returns color alpha (opacity) as float from 0..1. ;  ; uint8_t GetBlue () const;  Returns blue color component 0..255. ;  ; uint8_t GetGreen () const;  Returns green color component 0..255. ;  ; bool GetHLS (float &hue, float &light, float &satur) const;  Return the Hue, Light, Saturation (HLS) definition of this RColor. ;  ; float GetOrdinal () const;  Return ordinal value, which was set before with SetOrdinal() call. ;  ; uint8_t GetRed () const;  Returns red color component 0..255. ;  ; bool HasAlpha () const;  Returns true if color alpha (opacity) was specified. ;  ; bool IsAuto () const;  Returns true if color specified as auto color. ;  ; bool IsEmpty () const;  Returns true if color is empty. ;  ; bool IsName () const;  Returns true if color specified as name. ;  ; bool IsOrdinal () const;  Returns if color codes ordinal value from palette. ;  ; bool IsRGB () const;  returns true if color stored as RGB ;  ; bool IsRGBA () const;  returns true if color stored as RGBA ;  ; void SetAlpha (uint8_t alpha);  Set alpha as value from range 0..255. ;  ; void SetAlphaFloat (float alpha);  Set alpha as float value from range 0..1. ;  ; v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RColor.html:2084,green,green,2084,doc/master/classROOT_1_1Experimental_1_1RColor.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RColor.html,1,['green'],['green']
Energy Efficiency,"_t space = kTRUE); virtual voidWriteReal(Float_t r); Double_tXtoPDF(Double_t x); Double_tYtoPDF(Double_t y). protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Float_tfBluePer cent of blue; char*TVirtualPS::fBufferFile buffer; Bool_tfCompressTrue when fBuffer must be compressed; Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; Float_tfGreenPer cent of green; const char*TVirtualPS::fImplicitCREscEscape symbol before enforced new line; Int_tTVirtualPS::fLenBufferBuffer length; Color_tTAttLine::fLineColorline color; Float_tfLineScaleLine width scale factor; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; Color_tTAttMarker::fMarkerColorMarker color index; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; Int_tTVirtualPS::fNByteNumber of bytes written in the file (PDF); TStringTNamed::fNameobject identifier; Int_tfNbObjNumber of objects; Int_tfNbPageNumber of pages; Int_t*fObjPosObjets position; Int_tfObjPosSizeReal size of fObjPos; Int_tfPageFormatPage format (A4, Letter etc ...); Bool_tfPageNotEmptyTrue if the current page is not empty; Int_tfPageOrientationPage orientation (Portrait, Landscape); Bool_tTVirtualPS::fPrintedTrue when a page must be printed; Bool_tfRangeTrue when a range has been defined; Float_tfRedPer cent of red; Int_tTVirtualPS::fSizBufferBuffer size; Int_tfStartStream; ofstream*TVirtualPS::fStreamFile stream identifier; Short_tTAttText::fTextAlignText alignment; Float_tTAttText::fTextAngleText angle; Color_tTAttText::fTextColorText color index; Font_tTAttText::fTextFontText font ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TPDF.html:11177,green,green,11177,root/html528/TPDF.html,https://root.cern,https://root.cern/root/html528/TPDF.html,3,['green'],['green']
Energy Efficiency,"_t w)THnBaseinlineprotected; FillBuffer(char *&buffer)TNamedvirtual; FillExMap()THnSparseprotected; FindObject(const char *name) constTObjectvirtual; FindObject(const TObject *obj) constTObjectvirtual; fIntegralTHnBaseprotected; fIntegralStatusTHnBaseprotected; Fit(TF1 *f1, Option_t *option="""", Option_t *goption="""")THnBase; fNameTNamedprotected; fNdimensionsTHnBaseprotected; fTitleTNamedprotected; fTsumwTHnBaseprotected; fTsumw2THnBaseprotected; fTsumwxTHnBaseprotected; fTsumwx2THnBaseprotected; fUniqueIDTObjectprivate; GenerateArray() const =0THnSparseprotectedpure virtual; GetAxis(Int_t dim) constTHnBaseinline; GetBin(const Int_t *idx) const overrideTHnSparseinlinevirtual; GetBin(const Double_t *x) const overrideTHnSparseinlinevirtual; GetBin(const char *name[]) const overrideTHnSparseinlinevirtual; GetBin(const Int_t *idx, Bool_t allocate=kTRUE) overrideTHnSparsevirtual; GetBin(const Double_t *x, Bool_t allocate=kTRUE) overrideTHnSparsevirtual; GetBin(const char *name[], Bool_t allocate=kTRUE) overrideTHnSparsevirtual; GetBinCenter(const std::vector< Int_t > &idx) constTHnBase; GetBinContent(const Int_t *idx) constTHnSparseinline; GetBinContent(Long64_t bin, Int_t *idx=nullptr) const overrideTHnSparsevirtual; GetBinError(const Int_t *idx) constTHnBaseinline; GetBinError(Long64_t linidx) constTHnBaseinline; GetBinError2(Long64_t linidx) const overrideTHnSparsevirtual; GetBinIndexForCurrentBin(Bool_t allocate)THnSparseprotected; GetCalculateErrors() constTHnBaseinline; GetChunk(Int_t idx) constTHnSparseinlineprotected; GetChunkSize() constTHnSparseinline; GetCompactCoord() constTHnSparseprotected; GetDrawOption() constTObjectvirtual; GetDtorOnly()TObjectstatic; GetEntries() constTHnBaseinline; GetIconName() constTObjectvirtual; GetListOfAxes()THnBaseinline; GetListOfAxes() constTHnBaseinline; GetListOfFunctions()THnBaseinline; GetName() const overrideTNamedinlinevirtual; GetNbins() const overrideTHnSparseinlinevirtual; GetNChunks() constTHnSparseinline; GetNdimensio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHnSparse-members.html:4663,allocate,allocate,4663,doc/master/classTHnSparse-members.html,https://root.cern,https://root.cern/doc/master/classTHnSparse-members.html,1,['allocate'],['allocate']
Energy Efficiency,"_t(0x1000))->second)) - ((char*)PValue_t(0x1000));; 494 }; 495 };; 496 ; 497 ; 498 public:; 499 const std::type_info &fInfo;; 500 size_t fIterSize;; 501 size_t fValueDiff;; 502 int fValueOffset;; 503 void* (*fSizeFunc)(void*);; 504 void (*fResizeFunc)(void*,size_t);; 505 void* (*fClearFunc)(void*);; 506 void* (*fFirstFunc)(void*);; 507 void* (*fNextFunc)(void*);; 508 void* (*fConstructFunc)(void*,size_t);; 509 void (*fDestructFunc)(void*,size_t);; 510 void* (*fFeedFunc)(void*,void*,size_t);; 511 void* (*fCollectFunc)(void*,void*);; 512 void* (*fCreateEnv)();; 513 ; 514 // Set of function of direct iteration of the collections.; 515 void (*fCreateIterators)(void *collection, void **begin_arena, void **end_arena, TVirtualCollectionProxy *proxy);; 516 // begin_arena and end_arena should contain the location of memory arena of size fgIteratorSize.; 517 // If the collection iterator are of that size or less, the iterators will be constructed in place in those location (new with placement); 518 // Otherwise the iterators will be allocated via a regular new and their address returned by modifying the value of begin_arena and end_arena.; 519 ; 520 void* (*fCopyIterator)(void *dest, const void *source);; 521 // Copy the iterator source, into dest. dest should contain should contain the location of memory arena of size fgIteratorSize.; 522 // If the collection iterator are of that size or less, the iterator will be constructed in place in this location (new with placement); 523 // Otherwise the iterator will be allocated via a regular new and its address returned by modifying the value of dest.; 524 ; 525 void* (*fNext)(void *iter, const void *end);; 526 // iter and end should be pointer to respectively an iterator to be incremented and the result of colleciton.end(); 527 // 'Next' will increment the iterator 'iter' and return 0 if the iterator reached the end.; 528 // If the end is not reached, 'Next' will return the address of the content unless the collection contains point",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCollectionProxyInfo_8h_source.html:16937,allocate,allocated,16937,doc/master/TCollectionProxyInfo_8h_source.html,https://root.cern,https://root.cern/doc/master/TCollectionProxyInfo_8h_source.html,1,['allocate'],['allocated']
Energy Efficiency,"_t) (void *from, size_t size);  ; typedef void *(* Collectfunc_t) (void *from, void *to);  ; typedef ROOT::Detail::TCollectionProxyInfo::Environ< char[64]> Env_t;  ; typedef ROOT::Detail::TCollectionProxyInfo::EnvironBase EnvironBase_t;  ; typedef void *(* Feedfunc_t) (void *from, void *to, size_t size);  ; typedef std::vector< EnvironBase_t * > Proxies_t;  ; typedef void(* Sizing_t) (void *obj, size_t size);  ; typedef std::vector< TStaging * > Staged_t;  Collection of pre-allocated staged array for associative containers. ;  ;  Protected Attributes inherited from TGenCollectionProxy; Method fClear;  Method cache for container accessors: clear container. ;  ; Collectfunc_t fCollect;  Method to collect objects from container. ;  ; ArrIterfunc_t fConstruct;  Container accessors: block construct. ;  ; std::map< std::string, TObjArray * > * fConversionReadMemberWise;  Array of bundle of TStreamerInfoActions to stream out (read) derived from another class. ;  ; Method0 fCreateEnv;  Method to allocate an Environment holder. ;  ; Sizing_t fDestruct;  Container accessors: block destruct. ;  ; EnvironBase_t * fEnv;  Address of the currently proxied object. ;  ; Feedfunc_t fFeed;  Container accessors: block feed. ;  ; Method fFirst;  Container accessors: generic iteration: first. ;  ; CopyIterator_t fFunctionCopyIterator;  ; CreateIterators_t fFunctionCreateIterators;  ; DeleteIterator_t fFunctionDeleteIterator;  ; DeleteTwoIterators_t fFunctionDeleteTwoIterators;  ; Next_t fFunctionNextIterator;  ; Value * fKey;  Descriptor of the key_type. ;  ; std::string fName;  Name of the class being proxied. ;  ; Method fNext;  Container accessors: generic iteration: next. ;  ; TClass * fOnFileClass;  On file class. ;  ; Bool_t fPointers;  Flag to indicate if containee has pointers (key or value) ;  ; Proxies_t fProxyKept;  Optimization: Keep proxies once they were created. ;  ; Proxies_t fProxyList;  Stack of recursive proxies. ;  ; TObjArray * fReadMemberWise;  Array of bundle of TS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEmulatedCollectionProxy.html:11629,allocate,allocate,11629,doc/master/classTEmulatedCollectionProxy.html,https://root.cern,https://root.cern/doc/master/classTEmulatedCollectionProxy.html,2,['allocate'],['allocate']
Energy Efficiency,"_t* data = 0, Double_t xMin = 0.0, Double_t xMax = 0.0, Option_t* option = ""KernelType:Gaussian;Iteration:Adaptive;Mirror:noMirror;Binning:RelaxedBinning"", Double_t rho = 1.0); Class constructor. ~TKDE(); Class destructor. void Instantiate(TKDE::KernelFunction_Ptr kernfunc, UInt_t events, const Double_t* data, Double_t xMin, Double_t xMax, Option_t* option, Double_t rho); Template's constructor surrogate. void SetOptions(Option_t* option, Double_t rho); Sets User defined construction options. void SetDrawOptions(Option_t* option, TString& plotOpt, TString& drawOpt); Sets User defined drawing options. void GetOptions(string optionType, string option); Gets User defined KDE construction options. void AssureOptions(); Sets missing construction options to default ones. void CheckOptions(Bool_t isUserDefinedKernel = kFALSE); Sets User global options. void SetKernelType(TKDE::EKernelType kern); Sets User option for the choice of kernel estimator. void SetIteration(TKDE::EIteration iter); Sets User option for fixed or adaptive iteration. void SetMirror(TKDE::EMirror mir); Sets User option for mirroring the data. void SetBinning(TKDE::EBinning ); Sets User option for binning the weights. void SetNBins(UInt_t nbins); Sets User option for number of bins. void SetUseBinsNEvents(UInt_t nEvents); Sets User option for the minimum number of events for allowing automatic binning. void SetTuneFactor(Double_t rho); Factor which can be used to tune the smoothing.; It is used as multiplicative factor for the fixed and adaptive bandwidth.; A value < 1 will reproduce better the tails but oversmooth the peak; while a factor > 1 will overestimate the tail. void SetRange(Double_t xMin, Double_t xMax); Sets minimum range value and maximum range value. void SetUseBins(); Sets User option for using binned weights. void SetMirror(); Sets the mirroring. void SetData(const Double_t* data); Sets the data events input sample or bin centres for binned option and computes basic estimators. void InitF",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TKDE.html:11903,adapt,adaptive,11903,root/html528/TKDE.html,https://root.cern,https://root.cern/root/html528/TKDE.html,4,['adapt'],['adaptive']
Energy Efficiency,"_t* free); We try to read a buffer that has already been unzipped; Returns -1 in case of read failure, 0 in case it's not in the; cache and n>0 in case read from cache (number of bytes copied).; pos and len are the original values as were passed to ReadBuffer; but instead we will return the inflated buffer.; Note!! : If *buf == 0 we will allocate the buffer and it will be the; responsability of the caller to free it... it is useful for example; to pass it to the creator of TBuffer. void SetUnzipRelBufferSize(Float_t relbufferSize); static function: Sets the unzip relatibe buffer size; FABRIZIO: PLEASE DOCUMENT and also in TTree::Set... void SetUnzipBufferSize(Long64_t bufferSize); Sets the size for the unzipping cache... by default it should be; two times the size of the prefetching cache. Int_t UnzipBuffer(char** dest, char* src); UNzips a ROOT specific buffer... by reading the header at the beginning.; returns the size of the inflated buffer or -1 if error; Note!! : If *dest == 0 we will allocate the buffer and it will be the; responsability of the caller to free it... it is useful for example; to pass it to the creator of TBuffer; src is the original buffer with the record (header+compressed data); *dest is the inflated buffer (including the header). Int_t UnzipCache(Int_t& startindex, Int_t& locbuffsz, char*& locbuff); This inflates all the buffers in the cache.. passing the data to a new; buffer that will only wait there to be read...; We can not inflate all the buffers in the cache so we will try to do; it until the cache gets full... there is a member called fUnzipBufferSize which will; tell us the max size we can allocate for this cache. note that we will unzip in the order they were put into the cache not; the order of the transference so it has to be read in that order or the; pre-unzipping will be useless. startindex is used as start index to check for blks to be unzipped. returns 0 in normal conditions or -1 if error, 1 if it would like to sleep. This fun",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreeCacheUnzip.html:17514,allocate,allocate,17514,root/html528/TTreeCacheUnzip.html,https://root.cern,https://root.cern/root/html528/TTreeCacheUnzip.html,6,['allocate'],['allocate']
Energy Efficiency,"_t,Double_t>_wMap; vector<vector<Double_t> >*_weights!; vector<vector<Double_t> >_weights0; vector<vector<Double_t> >_weights1; Double_t_widthFactor; vector<Double_t>_x; vector<Double_t>_x0; vector<Double_t>_x1; vector<Double_t>_x2; vector<Double_t>_xDatHi; vector<Double_t>_xDatHi3s; vector<Double_t>_xDatLo; vector<Double_t>_xDatLo3s; vector<Double_t>_xVarHi; vector<Double_t>_xVarHiM3s; vector<Double_t>_xVarHiP3s; vector<Double_t>_xVarLo; vector<Double_t>_xVarLoM3s; vector<Double_t>_xVarLoP3s; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooNDKeysPdf(const char *name, const char *title,			 const RooArgList& varList, RooDataSet& data,			 TString options, Double_t rho, Double_t nSigma, Bool_t rotate); Construct N-dimensional kernel estimation p.d.f. in observables 'varList'; from dataset 'data'. Options can be. 'a' = Use adaptive kernels (width varies with local event density); 'm' = Mirror data points over observable boundaries. Improves modeling; behavior at edges for distributions that are not close to zero; at edge; 'd' = Debug flag; 'v' = Verbose flag. The parameter rho (default = 1) provides an overall scale factor that can; be applied to the bandwith calculated for each kernel. The nSigma parameter; determines the size of the box that is used to search for contributing kernels; around a given point in observable space. The nSigma parameters is used; in case of non-adaptive bandwidths and for the 1st non-adaptive pass for; the calculation of adaptive keys p.d.f.s. The optional weight arguments allows to specify an observable or function; expression in observables that specifies the weight of each event. RooNDKeysPdf(const char *name, const char *title, RooAbsReal& x, RooDataSet& data, Mirror mirror, Double_t rho, Double_t nSigma, Bool_t rotate); Backward compatibility constructor for (1-dim) RooKeysPdf. If you are a new user,; please use the fir",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooNDKeysPdf.html:43051,adapt,adaptive,43051,root/html526/RooNDKeysPdf.html,https://root.cern,https://root.cern/root/html526/RooNDKeysPdf.html,1,['adapt'],['adaptive']
Energy Efficiency,"_t<TTraits::RemoveFirstParameter_t<ArgTypes>>>; 2913 RResultPtr<U> Aggregate(AccFun aggregator, MergeFun merger, std::string_view columnName = """"); 2914 {; 2915 static_assert(; 2916 std::is_default_constructible<U>::value,; 2917 ""aggregated object cannot be default-constructed. Please provide an initialisation value (aggIdentity)"");; 2918 return Aggregate(std::move(aggregator), std::move(merger), columnName, U());; 2919 }; 2920 ; 2921 // clang-format off; 2922 ////////////////////////////////////////////////////////////////////////////; 2923 /// \brief Book execution of a custom action using a user-defined helper object.; 2924 /// \tparam FirstColumn The type of the first column used by this action. Inferred together with OtherColumns if not present.; 2925 /// \tparam OtherColumns A list of the types of the other columns used by this action; 2926 /// \tparam Helper The type of the user-defined helper. See below for the required interface it should expose.; 2927 /// \param[in] helper The Action Helper to be scheduled.; 2928 /// \param[in] columns The names of the columns on which the helper acts.; 2929 /// \return the result of the helper wrapped in a RResultPtr.; 2930 ///; 2931 /// This method books a custom action for execution. The behavior of the action is completely dependent on the; 2932 /// Helper object provided by the caller. The required interface for the helper is described below (more; 2933 /// methods that the ones required can be present, e.g. a constructor that takes the number of worker threads is usually useful):; 2934 ///; 2935 /// ### Mandatory interface; 2936 ///; 2937 /// * `Helper` must publicly inherit from `ROOT::Detail::RDF::RActionImpl<Helper>`; 2938 /// * `Helper::Result_t`: public alias for the type of the result of this action helper. `Result_t` must be default-constructible.; 2939 /// * `Helper(Helper &&)`: a move-constructor is required. Copy-constructors are discouraged.; 2940 /// * `std::shared_ptr<Result_t> GetResultPtr() const`: retu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RInterface_8hxx_source.html:164772,schedul,scheduled,164772,doc/master/RInterface_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RInterface_8hxx_source.html,1,['schedul'],['scheduled']
Energy Efficiency,"_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoMaterialEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for material editor. ~TGeoMaterialEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected material. void DoName(); Perform name change. void DoA(); Slot for atomic mass. void DoZ(); Slot for charge. void DoState(Int_t state); Slot for material state. void DoTemperature(); Slot for material temperature. void DoPressure(); Slot for material pressure. void DoDensity(); Slot for density.; fMatDensity->SetNumber(fDensityi);. void DoRadAbs(); Slot for radiation/absorbtion length. void DoApply(); Slot for applying modifications. void DoUndo(); Slot for cancelling current modifications. void DoModified(); Slot for signaling modifications. TGeoMaterialEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()). » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-06-02 16:01; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGeoMaterialEditor.html:22483,charge,charge,22483,root/html604/TGeoMaterialEditor.html,https://root.cern,https://root.cern/root/html604/TGeoMaterialEditor.html,1,['charge'],['charge']
Energy Efficiency,"_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoMaterialEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for material editor. ~TGeoMaterialEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected material. void DoName(); Perform name change. void DoA(); Slot for atomic mass. void DoZ(); Slot for charge. void DoState(Int_t state); Slot for material state. void DoTemperature(); Slot for material temperature. void DoPressure(); Slot for material pressure. void DoDensity(); Slot for density.; fMatDensity->SetNumber(fDensityi);. void DoRadAbs(); Slot for radiation/absorbtion length. void DoApply(); Slot for applying modifications. void DoUndo(); Slot for cancelling current modifications. void DoModified(); Slot for signaling modifications. TGeoMaterialEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()). » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-06-30 15:01; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoMaterialEditor.html:22483,charge,charge,22483,root/html602/TGeoMaterialEditor.html,https://root.cern,https://root.cern/root/html602/TGeoMaterialEditor.html,1,['charge'],['charge']
Energy Efficiency,"_tTObject::HandleTimer(TTimer* timer); Bool_tTEveElement::HasChild(TEveElement* el); Bool_tTEveElement::HasChildren() const; virtual ULong_tTNamed::Hash() const; virtual Bool_tTEveElement::HasMainColor() const; virtual Bool_tTEveElement::HasMainTrans() const; Bool_tTEveElement::HasParents() const; virtual Bool_tTEveProjectable::HasProjecteds() const; virtual voidTEveElement::HighlightElement(Bool_t state); voidTEveElement::IncDenyDestroy(); virtual voidTEveElement::IncImpliedHighlighted(); virtual voidTEveElement::IncImpliedSelected(); voidTEveElement::IncParentIgnoreCnt(); virtual voidTEveRefBackPtr::IncRefCount(TEveElement* re); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTEveElement::InitMainTrans(Bool_t can_edit = kTRUE); voidInitTrack(const TEveVectorD& v, Int_t charge); voidInitTrack(const TEveVectorF& v, Int_t charge); virtual voidTObject::Inspect() constMENU ; Bool_tIntersectPlane(const TEveVectorD& p, const TEveVectorD& point, const TEveVectorD& normal, TEveVectorD& itsect); voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; static Bool_tIsOutsideBounds(const TEveVectorD& point, Double_t maxRsqr, Double_t maxZ); Bool_tTEveElement::IsPickable() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; TEveElement*TEveElement::LastChild() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTEveElement::NameTitleChanged(); virtual Bool_tTObject::Notify(); Int_tTEveElement::NumChildren() const; Int_tTEveElement::NumParents() const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual voidOnZeroRefCount(); stati",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TEveTrackPropagator.html:10978,charge,charge,10978,root/html530/TEveTrackPropagator.html,https://root.cern,https://root.cern/root/html530/TEveTrackPropagator.html,3,['charge'],['charge']
Energy Efficiency,"_tTObject::HandleTimer(TTimer* timer); Bool_tTEveElement::HasChild(TEveElement* el); Bool_tTEveElement::HasChildren() const; virtual ULong_tTNamed::Hash() const; virtual Bool_tTEveElement::HasMainColor() const; virtual Bool_tTEveElement::HasMainTrans() const; Bool_tTEveElement::HasParents() const; virtual Bool_tTEveProjectable::HasProjecteds() const; virtual voidTEveElement::HighlightElement(Bool_t state); voidTEveElement::IncDenyDestroy(); virtual voidTEveElement::IncImpliedHighlighted(); virtual voidTEveElement::IncImpliedSelected(); voidTEveElement::IncParentIgnoreCnt(); virtual voidTEveRefBackPtr::IncRefCount(TEveElement* re); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTEveElement::InitMainTrans(Bool_t can_edit = kTRUE); voidInitTrack(const TEveVectorD& v, Int_t charge); voidInitTrack(const TEveVectorF& v, Int_t charge); virtual voidTObject::Inspect() constMENU ; Bool_tIntersectPlane(const TEveVectorD& p, const TEveVectorD& point, const TEveVectorD& normal, TEveVectorD& itsect); voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; static Bool_tIsOutsideBounds(const TEveVectorD& point, Double_t maxRsqr, Double_t maxZ); Bool_tTEveElement::IsPickable() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; TEveElement*TEveElement::LastChild() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTEveElement::NameTitleChanged(); virtual Bool_tTObject::Notify(); Int_tTEveElement::NumChildren() const; Int_tTEveElement::NumParents() const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual voidOnZeroRefCount(); voidT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEveTrackPropagator.html:11305,charge,charge,11305,root/html602/TEveTrackPropagator.html,https://root.cern,https://root.cern/root/html602/TEveTrackPropagator.html,2,['charge'],['charge']
Energy Efficiency,"_type;; 482 ; 483 void push_back(const T &Elt); 484 {; 485 if (R__unlikely(this->size() >= this->capacity())); 486 this->grow();; 487 memcpy(reinterpret_cast<void *>(this->end()), &Elt, sizeof(T));; 488 this->set_size(this->size() + 1);; 489 }; 490 ; 491 void pop_back() { this->set_size(this->size() - 1); }; 492};; 493 ; 494/// Storage for the SmallVector elements. This is specialized for the N=0 case; 495/// to avoid allocating unnecessary storage.; 496template <typename T, unsigned N>; 497struct SmallVectorStorage {; 498 alignas(T) char InlineElts[N * sizeof(T)]{};; 499};; 500 ; 501/// We need the storage to be properly aligned even for small-size of 0 so that; 502/// the pointer math in \a SmallVectorTemplateCommon::getFirstEl() is; 503/// well-defined.; 504template <typename T>; 505struct alignas(T) SmallVectorStorage<T, 0> {; 506};; 507 ; 508/// The size of the inline storage of an RVec.; 509/// Our policy is to allocate at least 8 elements (or more if they all fit into one cacheline); 510/// unless the size of the buffer with 8 elements would be over a certain maximum size.; 511template <typename T>; 512struct RVecInlineStorageSize {; 513private:; 514#ifdef R__HAS_HARDWARE_INTERFERENCE_SIZE; 515 constexpr std::size_t cacheLineSize = std::hardware_destructive_interference_size;; 516#else; 517 // safe bet: assume the typical 64 bytes; 518 static constexpr std::size_t cacheLineSize = 64;; 519#endif; 520 static constexpr unsigned elementsPerCacheLine = (cacheLineSize - sizeof(SmallVectorBase)) / sizeof(T);; 521 static constexpr unsigned maxInlineByteSize = 1024;; 522 ; 523public:; 524 static constexpr unsigned value =; 525 elementsPerCacheLine >= 8 ? elementsPerCacheLine : (sizeof(T) * 8 > maxInlineByteSize ? 0 : 8);; 526};; 527 ; 528// A C++14-compatible implementation of std::uninitialized_value_construct; 529template <typename ForwardIt>; 530void UninitializedValueConstruct(ForwardIt first, ForwardIt last); 531{; 532#if __cplusplus < 201703L; 533 for (; first !=",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RVec_8hxx_source.html:18641,allocate,allocate,18641,doc/v632/RVec_8hxx_source.html,https://root.cern,https://root.cern/doc/v632/RVec_8hxx_source.html,1,['allocate'],['allocate']
Energy Efficiency,"_type;; 482 ; 483 void push_back(const T &Elt); 484 {; 485 if (R__unlikely(this->size() >= this->capacity())); 486 this->grow();; 487 memcpy(reinterpret_cast<void *>(this->end()), &Elt, sizeof(T));; 488 this->set_size(this->size() + 1);; 489 }; 490 ; 491 void pop_back() { this->set_size(this->size() - 1); }; 492};; 493 ; 494/// Storage for the SmallVector elements. This is specialized for the N=0 case; 495/// to avoid allocating unnecessary storage.; 496template <typename T, unsigned N>; 497struct SmallVectorStorage {; 498 alignas(T) char InlineElts[N * sizeof(T)]{};; 499};; 500 ; 501/// We need the storage to be properly aligned even for small-size of 0 so that; 502/// the pointer math in \a SmallVectorTemplateCommon::getFirstEl() is; 503/// well-defined.; 504template <typename T>; 505struct alignas(T) SmallVectorStorage<T, 0> {; 506};; 507 ; 508/// The size of the inline storage of an RVec.; 509/// Our policy is to allocate at least 8 elements (or more if they all fit into one cacheline); 510/// unless the size of the buffer with 8 elements would be over a certain maximum size.; 511template <typename T>; 512struct RVecInlineStorageSize {; 513private:; 514#ifdef R__HAS_HARDWARE_INTERFERENCE_SIZE; 515 static constexpr std::size_t cacheLineSize = std::hardware_destructive_interference_size;; 516#else; 517 // safe bet: assume the typical 64 bytes; 518 static constexpr std::size_t cacheLineSize = 64;; 519#endif; 520 static constexpr unsigned elementsPerCacheLine = (cacheLineSize - sizeof(SmallVectorBase)) / sizeof(T);; 521 static constexpr unsigned maxInlineByteSize = 1024;; 522 ; 523public:; 524 static constexpr unsigned value =; 525 elementsPerCacheLine >= 8 ? elementsPerCacheLine : (sizeof(T) * 8 > maxInlineByteSize ? 0 : 8);; 526};; 527 ; 528// A C++14-compatible implementation of std::uninitialized_value_construct; 529template <typename ForwardIt>; 530void UninitializedValueConstruct(ForwardIt first, ForwardIt last); 531{; 532#if __cplusplus < 201703L; 533 for (; f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RVec_8hxx_source.html:18642,allocate,allocate,18642,doc/master/RVec_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html,1,['allocate'],['allocate']
Energy Efficiency,"_t ; phi1, . Double_t ; theta2, . Double_t ; phi2, . Double_t ; theta3, . Double_t ; phi3 . ). Create rotation matrix named 'mat<index>'. . index rotation matrix number; theta1 polar angle for axis X; phi1 azimuthal angle for axis X; theta2 polar angle for axis Y; phi2 azimuthal angle for axis Y; theta3 polar angle for axis Z; phi3 azimuthal angle for axis Z . Definition at line 1276 of file TGeoManager.cxx. ◆ Medium(). TGeoMedium * TGeoManager::Medium ; (; const char * ; name, . Int_t ; numed, . Int_t ; nmat, . Int_t ; isvol, . Int_t ; ifield, . Double_t ; fieldm, . Double_t ; tmaxfd, . Double_t ; stemax, . Double_t ; deemax, . Double_t ; epsil, . Double_t ; stmin . ). Create tracking medium. . numed tracking medium number assigned; name tracking medium name; nmat material number; isvol sensitive volume flag; ifield magnetic field; fieldm max. field value (kilogauss); tmaxfd max. angle due to field (deg/step); stemax max. step allowed; deemax max. fraction of energy lost in a step; epsil tracking precision (cm); stmin min. step due to continuous processes (cm); ifield = 0 if no magnetic field; ifield = -1 if user decision in guswim;; ifield = 1 if tracking performed with g3rkuta; ifield = 2 if tracking performed with g3helix; ifield = 3 if tracking performed with g3helx3. . Definition at line 1331 of file TGeoManager.cxx. ◆ Mixture() [1/2]. TGeoMaterial * TGeoManager::Mixture ; (; const char * ; name, . Double_t * ; a, . Double_t * ; z, . Double_t ; dens, . Int_t ; nelem, . Double_t * ; wmat, . Int_t ; uid . ). Create mixture OR COMPOUND IMAT as composed by THE BASIC nelem materials defined by arrays A,Z and WMAT, having an unique id. ; Definition at line 1306 of file TGeoManager.cxx. ◆ Mixture() [2/2]. TGeoMaterial * TGeoManager::Mixture ; (; const char * ; name, . Float_t * ; a, . Float_t * ; z, . Double_t ; dens, . Int_t ; nelem, . Float_t * ; wmat, . Int_t ; uid . ). Create mixture OR COMPOUND IMAT as composed by THE BASIC nelem materials defined by arrays A,Z a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoManager.html:123306,energy,energy,123306,doc/master/classTGeoManager.html,https://root.cern,https://root.cern/doc/master/classTGeoManager.html,1,['energy'],['energy']
Energy Efficiency,"_t ; temperatureAdaptiveStep, . Bool_t ; useDefaultScale, . Bool_t ; useDefaultTemperature . ). option setter ; Definition at line 73 of file SimulatedAnnealing.cxx. ◆ SetTemperatureScale(). void TMVA::SimulatedAnnealing::SetTemperatureScale ; (; Double_t ; scale). inline . Definition at line 66 of file SimulatedAnnealing.h. ◆ ShouldGoIn(). Bool_t TMVA::SimulatedAnnealing::ShouldGoIn ; (; Double_t ; currentFit, . Double_t ; localFit, . Double_t ; currentTemperature . ). private . result checker ; Definition at line 219 of file SimulatedAnnealing.cxx. ◆ Streamer(). virtual void TMVA::SimulatedAnnealing::Streamer ; (; TBuffer & ; ). virtual . ◆ StreamerNVirtual(). void TMVA::SimulatedAnnealing::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 127 of file SimulatedAnnealing.h. Member Data Documentation. ◆ fAdaptiveSpeed. Double_t TMVA::SimulatedAnnealing::fAdaptiveSpeed. private . how fast temperature change in adaptive (in adaptive two variables describe the change of temperature, but fAdaptiveSpeed should be 1.0 and its not recommended to change it) ; Definition at line 110 of file SimulatedAnnealing.h. ◆ fEps. Double_t TMVA::SimulatedAnnealing::fEps. private . epsilon ; Definition at line 108 of file SimulatedAnnealing.h. ◆ fExitFromTraining. bool* TMVA::SimulatedAnnealing::fExitFromTraining = nullptr. private . Definition at line 125 of file SimulatedAnnealing.h. ◆ fFitterTarget. IFitterTarget& TMVA::SimulatedAnnealing::fFitterTarget. private . the fitter target ; Definition at line 100 of file SimulatedAnnealing.h. ◆ fInitialTemperature. Double_t TMVA::SimulatedAnnealing::fInitialTemperature. private . initial temperature ; Definition at line 106 of file SimulatedAnnealing.h. ◆ fIPyCurrentIter. UInt_t* TMVA::SimulatedAnnealing::fIPyCurrentIter = nullptr. private . Definition at line 124 of file SimulatedAnnealing.h. ◆ fKernelTemperature. enum TMVA::SimulatedAnnealing::EKernelTemperature TMVA::SimulatedAnnealing::fKernelTem",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1SimulatedAnnealing.html:9596,adapt,adaptive,9596,doc/master/classTMVA_1_1SimulatedAnnealing.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1SimulatedAnnealing.html,2,['adapt'],['adaptive']
Energy Efficiency,"_t ; x, . Long64_t ; y . ). inline . Returns x raised to the power y. ; Definition at line 727 of file TMath.h. ◆ Power() [5/5]. LongDouble_t TMath::Power ; (; LongDouble_t ; x, . LongDouble_t ; y . ). inline . Returns x raised to the power y. ; Definition at line 721 of file TMath.h. ◆ Prob(). Double_t TMath::Prob ; (; Double_t ; chi2, . Int_t ; ndf . ). Computation of the probability for a certain Chi-squared (chi2) and number of degrees of freedom (ndf). ; Calculations are based on the incomplete gamma function P(a,x), where a=ndf/2 and x=chi2/2.; P(a,x) represents the probability that the observed Chi-squared for a correct model should be less than the value chi2.; The returned probability corresponds to 1-P(a,x), which denotes the probability that an observed Chi-squared exceeds the value chi2 by chance, even for a correct model.; AuthorNvE 14-nov-1998 UU-SAP Utrecht ; Definition at line 637 of file TMath.cxx. ◆ Qe(). constexpr Double_t TMath::Qe ; (; ). constexpr . Elementary charge in \( C \) . ; Definition at line 339 of file TMath.h. ◆ QeUncertainty(). constexpr Double_t TMath::QeUncertainty ; (; ). constexpr . Elementary charge uncertainty. ; Definition at line 346 of file TMath.h. ◆ Quantiles(). void TMath::Quantiles ; (; Int_t ; n, . Int_t ; nprob, . Double_t * ; x, . Double_t * ; quantiles, . Double_t * ; prob, . Bool_t ; isSorted = kTRUE, . Int_t * ; index = nullptr, . Int_t ; type = 7 . ). Computes sample quantiles, corresponding to the given probabilities. ; Parameters. [in]xthe data sample ; [in]nits size ; [out]quantilescomputed quantiles are returned in there ; [in]probprobabilities where to compute quantiles ; [in]nprobsize of prob array ; [in]isSortedis the input array x sorted ? ; [in]indexparameter index ; [in]typemethod to compute (from 1 to 9). NOTE:; When the input is not sorted, an array of integers of size n needs to be allocated. It can be passed by the user in parameter index, or, if not passed, it will be allocated inside the function. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceTMath.html:73321,charge,charge,73321,doc/master/namespaceTMath.html,https://root.cern,https://root.cern/doc/master/namespaceTMath.html,1,['charge'],['charge']
Energy Efficiency,"_{\frac{1}{2}}) = \frac{1}{2}; 1973/// \f]; 1974///; 1975/// \param[in] n maximum size of array xp and size of array p; 1976/// \param[out] xp array filled with n quantiles evaluated at p. Memory has to be preallocated by caller.; 1977/// \param[in] p array of cumulative probabilities where quantiles should be evaluated.; 1978/// It is assumed to contain at least n values.; 1979/// \return n, the number of quantiles computed (same as input argument n); 1980///; 1981/// Getting quantiles from two histograms and storing results in a TGraph,; 1982/// a so-called QQ-plot; 1983///; 1984/// TGraph *gr = new TGraph(nprob);; 1985/// f1->GetQuantiles(nprob,gr->GetX(),p);; 1986/// f2->GetQuantiles(nprob,gr->GetY(),p);; 1987/// gr->Draw(""alp"");; 1988///; 1989/// \author Eddy Offermann; 1990/// \warning Function leads to undefined behavior if xp or p are null or; 1991/// their size does not match with n; 1992 ; 1993 ; 1994Int_t TF1::GetQuantiles(Int_t n, Double_t *xp, const Double_t *p); 1995{; 1996 // LM: change to use fNpx; 1997 // should we change code to use a root finder ?; 1998 // It should be more precise and more efficient; 1999 const Int_t npx = TMath::Max(fNpx, 2 * n);; 2000 const Double_t xMin = GetXmin();; 2001 const Double_t xMax = GetXmax();; 2002 const Double_t dx = (xMax - xMin) / npx;; 2003 ; 2004 TArrayD integral(npx + 1);; 2005 TArrayD alpha(npx);; 2006 TArrayD beta(npx);; 2007 TArrayD gamma(npx);; 2008 ; 2009 integral[0] = 0;; 2010 Int_t intNegative = 0;; 2011 Int_t i;; 2012 for (i = 0; i < npx; i++) {; 2013 Double_t integ = Integral(Double_t(xMin + i * dx), Double_t(xMin + i * dx + dx), 0.0);; 2014 if (integ < 0) {; 2015 intNegative++;; 2016 integ = -integ;; 2017 }; 2018 integral[i + 1] = integral[i] + integ;; 2019 }; 2020 ; 2021 if (intNegative > 0); 2022 Warning(""GetQuantiles"", ""function:%s has %d negative values: abs assumed"",; 2023 GetName(), intNegative);; 2024 if (integral[npx] == 0) {; 2025 Error(""GetQuantiles"", ""Integral of function is zero"");; 2026",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TF1_8cxx_source.html:73528,efficient,efficient,73528,doc/master/TF1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html,1,['efficient'],['efficient']
Energy Efficiency,"_{b}\) is often called \(CL_{s}\), and is considered useful, though it is not a probability. Finally, the p-value of the null can be transformed into a number of equivalent Gaussian sigma using the Significance method.; The p-value of the null for a given test statistic is rigorously defined and this is the starting point for the following conventions. Conventions used in this class; The p-value for the null and alternate are on the same side of the observed value of the test statistic. This is the more standard convention and avoids confusion when doing inverted tests.; For exclusion, we also want the formula \(CL_{s} = CL_{s+b} / CL_{b}\) to hold which therefore defines our conventions for \(CL_{s+b}\) and \(CL_{b}\). \(CL_{s}\) was specifically invented for exclusion and therefore all quantities need be related through the assignments as they are for exclusion: \(CL_{s+b} = p_{s+b}\); \(CL_{b} = p_{b}\). This is derived by considering the scenarios of a powerful and not powerful inverted test, where for the not so powerful test, \(CL_{s}\) must be close to one.; For results of Hypothesis tests, \(CL_{s}\) has no similar direct interpretation as for exclusion and can be larger than one. ; Definition at line 22 of file HypoTestResult.h. Public Member Functions;  HypoTestResult (const char *name, double nullp, double altp);  constructor from name, null and alternate p values ;  ;  HypoTestResult (const char *name=nullptr);  default constructor ;  ;  HypoTestResult (const HypoTestResult &other);  copy constructor ;  ;  ~HypoTestResult () override;  destructor ;  ; virtual double AlternatePValue () const;  Return p-value for alternate hypothesis. ;  ; virtual void Append (const HypoTestResult *other);  add values from another HypoTestResult ;  ; virtual double CLb () const;  Convert NullPValue into a ""confidence level"". ;  ; double CLbError () const;  The error on the ""confidence level"" of the null hypothesis. ;  ; TObject * Clone (const char *newname=nullptr) const o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooStats_1_1HypoTestResult.html:1733,power,powerful,1733,doc/master/classRooStats_1_1HypoTestResult.html,https://root.cern,https://root.cern/doc/master/classRooStats_1_1HypoTestResult.html,3,['power'],['powerful']
Energy Efficiency,"a & operator= (const RooAbsData &other);  ; virtual RooPlot * plotOn (RooPlot *frame, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={}) const;  ; virtual RooPlot * plotOn (RooPlot *frame, const RooLinkedList &cmdList) const;  Plot dataset on specified frame. ;  ; void Print (Option_t *options=nullptr) const override;  This method must be overridden when a class wants to print itself. ;  ; void printClassName (std::ostream &os) const override;  Print class name of dataset. ;  ; void printName (std::ostream &os) const override;  Print name of dataset. ;  ; void printTitle (std::ostream &os) const override;  Print title of dataset. ;  ; void RecursiveRemove (TObject *obj) override;  If one of the TObject we have a referenced to is deleted, remove the reference. ;  ; RooFit::OwningPtr< RooAbsData > reduce (const char *cut) const;  Create a subset of the data set by applying the given cut on the data points. ;  ; RooFit::OwningPtr< RooAbsData > reduce (const RooArgSet &varSubset, const char *cut=nullptr) const;  Create a subset of the data set by applying the given cut on the data points and reducing the dimensions to the specified set. ;  ; RooFit::OwningPtr< RooAbsData > reduce (const RooArgSet &varSubset, const RooFormulaVar &cutVar) const;  Create a subset of the data set by applying the given cut on the data points and reducing the dimensions to the specified set. ;  ; RooFit::OwningPtr< RooAbsData > reduce (const RooCmdArg &arg1, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={}) const;  Create a reduced copy of this dataset. ;  ; RooFit::OwningPtr< RooAbsData > reduce (const RooFormulaVar &cutVar) const;  Create a subset of the data set by applying the given cut on the data points",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooDataSet.html:15160,reduce,reduce,15160,doc/master/classRooDataSet.html,https://root.cern,https://root.cern/doc/master/classRooDataSet.html,1,['reduce'],['reduce']
Energy Efficiency,"a ; RooNDKeysPdf General N-dimensional non-parametric kernel estimation p.d.f; RooNLLVar Function representing (extended) -log(L) of p.d.f and dataset; RooNameReg String name registry; RooNameSet A sterile version of RooArgSet, containing only the names of the contained RooAbsArgs; RooNonCPEigenDecay PDF to model CP-violating decays to final states which are not CP eigenstates; RooNormSetCache Management tool for tracking sets of similar integration/normalization sets; RooNovosibirsk Novosibirsk PDF; RooNumCdf Numeric calculator for CDF for a given PDF; RooNumConvPdf Operator PDF implementing numeric convolution of 2 input PDFs; RooNumConvolution Operator PDF implementing numeric convolution of 2 input functions; RooNumGenConfig Numeric (MC) Event generator configuration ; RooNumGenFactory Numeric Generator factory; RooNumIntConfig Numeric Integrator configuration ; RooNumIntFactory Numeric Integrator factory; RooNumRunningInt Numeric calculator for running integral of a given function; RooNumber wrapper class for portable numerics; RooObjCacheManager Cache manager for generic caches that contain RooAbsArg objects; RooParamBinning Binning specification with ranges parameterized by external RooAbsReal functions; RooParametricStepFunction Parametric Step Function Pdf; RooPlot Plot frame and container for graphics objects; RooPlotable Abstract interface for plotable objects in a RooPlot; RooPoisson A Poisson PDF; RooPolyVar Polynomial function; RooPolynomial Polynomial PDF; RooPrintable Interface for printable objects; RooProdGenContext Context for efficient generation of a a dataset from a RooProdPdf; RooProdPdf PDF representing a product of PDFs; RooProduct Product of RooAbsReal and/or RooAbsCategory terms; RooProfileLL Real-valued function representing profile likelihood of external (likelihood) function; RooProjectedPdf Operator p.d.f calculating projection of another p.d.f; RooProofDriverSelector ; RooPullVar Calculation of pull of measurement w.r.t a truth value; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ClassIndex.html:39321,efficient,efficient,39321,root/html526/ClassIndex.html,https://root.cern,https://root.cern/root/html526/ClassIndex.html,1,['efficient'],['efficient']
Energy Efficiency,"a = 1.0); Perform a rank 1 operation on the matrix:; A += alpha * v * v^T. TMatrixTSym<Element> &TMatrixTSym<Element> Similarity(const TMatrixT<Element> &b); Calculate B * (*this) * B^T , final matrix will be (nrowsb x nrowsb); This is a similarity transform when B is orthogonal . It is more; efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . TMatrixTSym<Element> &TMatrixTSym<Element> Similarity(const TMatrixTSym<Element> &b); Calculate B * (*this) * B^T , final matrix will be (nrowsb x nrowsb); This is a similarity transform when B is orthogonal . It is more; efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . Element TMatrixTSym<Element> Similarity(const TVectorT<float>& v) const; Calculate scalar v * (*this) * v^T. TMatrixTSym<Element> &TMatrixTSym<Element> SimilarityT(const TMatrixT<float>& n); Calculate B^T * (*this) * B , final matrix will be (ncolsb x ncolsb); It is more efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . TMatrixTSym<Element> &TMatrixTSym<Element> operator=(const TMatrixTSym<Element> &source). TMatrixTSym<Element> &TMatrixTSym<Element> operator=(const TMatrixTSymLazy<Element> &lazy_constructor). TMatrixTSym<Element> &TMatrixTSym<Element> operator=(Element val); Assign val to every element of the matrix. TMatrixTSym<Element> &TMatrixTSym<Element> operator+=(Element val); Add val to every element of the matrix. TMatrixTSym<Element> &TMatrixTSym<Element> operator-=(Element val); Subtract val from every element of the matrix. TMatrixTSym<Element> &TMatrixTSym<Element> operator*=(float val); Multiply every element of the matrix with val. TMatrixTSym<Element> &TMatrixTSym<Element> operator+=(const TMatrixTSym<Element> &source); Add the source matrix. TMatrixTSym<Element> &TMatrixTSym<Element> operator-=(const TMatrixTSym<Element> &source); Subtract the s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMatrixTSym_float_.html:18644,efficient,efficient,18644,root/html528/TMatrixTSym_float_.html,https://root.cern,https://root.cern/root/html528/TMatrixTSym_float_.html,4,['efficient'],['efficient']
Energy Efficiency,"a ROOT session. One simply adds the name of the script(s) after the ROOT command. Be warned: after finishing the execution of the script, ROOT will normally enter a new session.; -q process command line script files and exit. For example if you would like to run a script myMacro.C in the background, redirect the output into a file myMacro.log, and exit after the script execution, use the following syntax:; root -b -q myMacro.C > myMacro.log; If you need to pass a parameter to the script use:; root -b -q 'myMacro.C(3)' > myMacro.log; Be mindful of the quotes, i.e. if you need to pass a string as a parameter, the syntax is:; root -b -q 'myMacro.C(""text"")' > myMacro.log; You can build a shared library with ACLiC and then use this shared library on the command line for a quicker execution (i.e. the compiled speed rather than the interpreted speed). See also “Cling the C++ Interpreter”.; root -b -q myMacro.so > myMacro.log; ROOT has a powerful C/C++ interpreter giving you access to all available ROOT classes, global variables, and functions via the command line. By typing C++ statements at the prompt, you can create objects, call functions, execute scripts, etc. For example:; root[] 1+sqrt(9); (const double)4.00000000000000000e+00; root[] for (int i = 0; i<4; i++) cout << ""Hello"" << i << endl; Hello 0; Hello 1; Hello 2; Hello 3; root[] .q; To exit the ROOT session, type .q.; root[] .q; 2.3 Using the GUI; The basic whiteboard on which an object is drawn in ROOT is called a canvas (defined by the class TCanvas). Every object in the canvas is a graphical object in the sense that you can grab it, resize it, and change some characteristics using the mouse. The canvas area can be divided in several sub areas, so-called pads (the class TPad). A pad is a canvas sub area that can contain other pads or graphical objects. At any one time, just one pad is the so-called active pad. Any object at the moment of drawing will be drawn in the active pad. The obvious question is: what is th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:34606,power,powerful,34606,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['power'],['powerful']
Energy Efficiency,"a branch count and are not a counter. ; Definition at line 4574 of file TBranchElement.cxx. ◆ ReadLeavesMemberCounter(). void TBranchElement::ReadLeavesMemberCounter ; (; TBuffer & ; b). protected . Read leaves into i/o buffers for this branch. ; For split-class branch, base class branch, data member branch, or top-level branch. which do not have a branch count and are a counter. ; Definition at line 4611 of file TBranchElement.cxx. ◆ ReleaseObject(). void TBranchElement::ReleaseObject ; (; ). protected . Delete any object we may have allocated on a previous call to SetAddress. ; Definition at line 4672 of file TBranchElement.cxx. ◆ Reset(). void TBranchElement::Reset ; (; Option_t * ; option = """"). overridevirtual . Reset a Branch. ; Existing i/o buffers are deleted. Entries, max and min are reset. ; Reimplemented from TBranch.; Definition at line 4752 of file TBranchElement.cxx. ◆ ResetAddress(). void TBranchElement::ResetAddress ; (; ). overridevirtual . Set branch address to zero and free all allocated memory. ; Reimplemented from TBranch.; Definition at line 4780 of file TBranchElement.cxx. ◆ ResetAfterMerge(). void TBranchElement::ResetAfterMerge ; (; TFileMergeInfo * ; info). overridevirtual . Reset a Branch after a Merge operation (drop data but keep customizations) ; Reimplemented from TBranch.; Definition at line 4767 of file TBranchElement.cxx. ◆ ResetDeleteObject(). void TBranchElement::ResetDeleteObject ; (; ). virtual . Release ownership of any allocated objects. ; Note: This interface was added so that clone trees could be told they do not own the allocated objects. ; Definition at line 4814 of file TBranchElement.cxx. ◆ ResetInitInfo(). void TBranchElement::ResetInitInfo ; (; bool ; recurse). virtual . Reset offset and StreamerInfo information from this branch. ; Parameters. [in]recurseWhen true call ResetInitInfo on all subbranches. . Definition at line 4831 of file TBranchElement.cxx. ◆ SetActionSequence(). void TBranchElement::SetActionSequence ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBranchElement.html:64825,allocate,allocated,64825,doc/master/classTBranchElement.html,https://root.cern,https://root.cern/doc/master/classTBranchElement.html,1,['allocate'],['allocated']
Energy Efficiency,"a class wants to print itself. ;  ; void printArgs (std::ostream &os) const override;  Print argument of dataset, i.e. the observable names. ;  ; void printClassName (std::ostream &os) const override;  Print class name of dataset. ;  ; void printMultiline (std::ostream &os, Int_t content, bool verbose, TString indent) const override;  Detailed printing interface. ;  ; void printName (std::ostream &os) const override;  Print name of dataset. ;  ; void printTitle (std::ostream &os) const override;  Print title of dataset. ;  ; void printValue (std::ostream &os) const override;  Print value of the dataset, i.e. the sum of weights contained in the dataset. ;  ; virtual void recalculateCache (const RooArgSet *, Int_t, Int_t, Int_t, bool);  ; virtual std::unique_ptr< RooAbsDataStore > reduce (RooStringView name, RooStringView title, const RooArgSet &vars, const RooFormulaVar *cutVar, const char *cutRange, std::size_t nStart, std::size_t nStop)=0;  ; virtual void reset ()=0;  ; virtual void resetBuffers ()=0;  ; virtual void resetCache ()=0;  ; virtual void setArgStatus (const RooArgSet &set, bool active)=0;  ; virtual void setDirtyProp (bool flag);  ; virtual void setExternalWeightArray (const double *, const double *, const double *, const double *);  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual double sumEntries () const;  ; virtual const TTree * tree () const;  ; virtual double weight () const =0;  ; double weight (Int_t index) const;  ; virtual void weightError (double &lo, double &hi, RooAbsData::ErrorType etype=RooAbsData::Poisson) const =0;  ; virtual double weightError (RooAbsData::ErrorType etype=RooAbsData::Poisson) const =0;  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsDataStore.html:3597,reduce,reduce,3597,doc/master/classRooAbsDataStore.html,https://root.cern,https://root.cern/doc/master/classRooAbsDataStore.html,1,['reduce'],['reduce']
Energy Efficiency,"a file containg a Tree; static TTree::ELockStatusBitsTTree::kFindBranch; static TTree::ELockStatusBitsTTree::kFindLeaf; static TTree::ELockStatusBitsTTree::kGetAlias; static TTree::ELockStatusBitsTTree::kGetBranch; static TTree::ELockStatusBitsTTree::kGetEntry; static TTree::ELockStatusBitsTTree::kGetEntryWithIndex; static TTree::ELockStatusBitsTTree::kGetFriend; static TTree::ELockStatusBitsTTree::kGetFriendAlias; static TTree::ELockStatusBitsTTree::kGetLeaf; static TTree::ELockStatusBitsTTree::kLoadTree; static TTree::ELockStatusBitsTTree::kPrint; static TTree::ELockStatusBitsTTree::kRemoveFriend; static TTree::ELockStatusBitsTTree::kSetBranchStatus. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TNtuple(); Default constructor for Ntuple*-*-*-*-*-*-*-*-; *-* ==============================. TNtuple(const char* name, const char* title, const char* varlist, Int_t bufsize = 32000); Create an Ntuple*-*-; *-* ================; The parameter varlist describes the list of the ntuple variables; separated by a colon:; example: ""x:y:z:energy""; For each variable in the list a separate branch is created. NOTE:; -Use TTree to create branches with variables of different data types.; -Use TTree when the number of branches is large (> 100).; -. ~TNtuple(); Default destructor for an Ntuple*-*-*-*-*-*-; *-* ================================. TTree* CloneTree(Long64_t nentries = -1, Option_t* option = """"); Create a clone of this tree and copy nentries. By default copy all entries.; Note that only active branches are copied.; The compression level of the cloned tree is set to the destination file's; compression level. See TTree::CloneTree for more details. void ResetBranchAddress(TBranch* ); Reset the branch addresses to the internal fArgs array. Use this; method when the addresses were changed via calls to SetBranchAddress(). void ResetBranchAddresses(); Reset the branch addresses to the internal fArgs array. Use this; method when the addres",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TNtuple.html:28279,energy,energy,28279,root/html602/TNtuple.html,https://root.cern,https://root.cern/root/html602/TNtuple.html,2,['energy'],['energy']
Energy Efficiency,"a function of nTest of the most significant; principal components p, and return it in x.; It's the users responsibility to make sure that both x and p are; of the right size (i.e., memory must be allocated for x). void Print(Option_t* opt = ""MSE"") const; Print the statistics; Options are; M Print mean values of original data; S Print sigma values of original data; E Print eigenvalues of covariance matrix; V Print eigenvectors of covariance matrix; Default is MSE. void SumOfSquareResiduals(const Double_t* x, Double_t* s); PRIVATE METHOD:. /*; >; Calculates the sum of the square residuals, that is; . where; ; , is the; component of the principal vector, corresponding to; , the original data; I.e., the square distance to the space; spanned by eigenvectors.; . */; . void Test(Option_t* option = """"); Test the PCA, bye calculating the sum square of residuals; (see method SumOfSquareResiduals), and display the histogram. void X2P(const Double_t* x, Double_t* p); Calculate the principal components from the original data vector; x, and return it in p.; It's the users responsibility to make sure that both x and p are; of the right size (i.e., memory must be allocated for p). const TMatrixD * GetCovarianceMatrix() const; {return &fCovarianceMatrix;}. const TVectorD * GetEigenValues() const; {return &fEigenValues;}. const TMatrixD * GetEigenVectors() const; {return &fEigenVectors;}. TList * GetHistograms() const; {return fHistograms;}. const TVectorD * GetMeanValues() const; {return &fMeanValues;}. const TVectorD * GetSigmas() const; {return &fSigmas;}. const TVectorD * GetUserData() const; {return &fUserData;}. Bool_t IsFolder() const; { return kTRUE;}. » Author: Christian Holm Christensen 1/8/2000 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/hist:$Id$ » Last generated: 2015-03-14 16:47; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TPrincipal.html:17955,allocate,allocated,17955,root/html534/TPrincipal.html,https://root.cern,https://root.cern/root/html534/TPrincipal.html,1,['allocate'],['allocated']
Energy Efficiency,"a function of nTest of the most significant; principal components p, and return it in x.; It's the users responsibility to make sure that both x and p are; of the right size (i.e., memory must be allocated for x). void Print(Option_t* opt = ""MSE"") const; Print the statistics; Options are; M Print mean values of original data; S Print sigma values of original data; E Print eigenvalues of covariance matrix; V Print eigenvectors of covariance matrix; Default is MSE. void SumOfSquareResiduals(const Double_t* x, Double_t* s); PRIVATE METHOD:. /*; >; Calculates the sum of the square residuals, that is; . where; ; , is the; component of the principal vector, corresponding to; , the original data; I.e., the square distance to the space; spanned by eigenvectors.; . */; . void Test(Option_t* option = """"); Test the PCA, bye calculating the sum square of residuals; (see method SumOfSquareResiduals), and display the histogram. void X2P(const Double_t* x, Double_t* p); Calculate the principal components from the original data vector; x, and return it in p.; It's the users responsibility to make sure that both x and p are; of the right size (i.e., memory must be allocated for p). const TMatrixD * GetCovarianceMatrix() const; {return &fCovarianceMatrix;}. const TVectorD * GetEigenValues() const; {return &fEigenValues;}. const TMatrixD * GetEigenVectors() const; {return &fEigenVectors;}. TList * GetHistograms() const; {return fHistograms;}. const TVectorD * GetMeanValues() const; {return &fMeanValues;}. const TVectorD * GetSigmas() const; {return &fSigmas;}. const TVectorD * GetUserData() const; {return &fUserData;}. Bool_t IsFolder() const; { return kTRUE;}. » Author: Christian Holm Christensen 1/8/2000 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/hist:$Id$ » Last generated: 2015-06-02 16:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TPrincipal.html:18418,allocate,allocated,18418,root/html604/TPrincipal.html,https://root.cern,https://root.cern/root/html604/TPrincipal.html,1,['allocate'],['allocated']
Energy Efficiency,"a function of nTest of the most significant; principal components p, and return it in x.; It's the users responsibility to make sure that both x and p are; of the right size (i.e., memory must be allocated for x). void Print(Option_t* opt = ""MSE"") const; Print the statistics; Options are; M Print mean values of original data; S Print sigma values of original data; E Print eigenvalues of covariance matrix; V Print eigenvectors of covariance matrix; Default is MSE. void SumOfSquareResiduals(const Double_t* x, Double_t* s); PRIVATE METHOD:. /*; >; Calculates the sum of the square residuals, that is; . where; ; , is the; component of the principal vector, corresponding to; , the original data; I.e., the square distance to the space; spanned by eigenvectors.; . */; . void Test(Option_t* option = """"); Test the PCA, bye calculating the sum square of residuals; (see method SumOfSquareResiduals), and display the histogram. void X2P(const Double_t* x, Double_t* p); Calculate the principal components from the original data vector; x, and return it in p.; It's the users responsibility to make sure that both x and p are; of the right size (i.e., memory must be allocated for p). const TMatrixD * GetCovarianceMatrix() const; {return &fCovarianceMatrix;}. const TVectorD * GetEigenValues() const; {return &fEigenValues;}. const TMatrixD * GetEigenVectors() const; {return &fEigenVectors;}. TList * GetHistograms() const; {return fHistograms;}. const TVectorD * GetMeanValues() const; {return &fMeanValues;}. const TVectorD * GetSigmas() const; {return &fSigmas;}. const TVectorD * GetUserData() const; {return &fUserData;}. Bool_t IsFolder() const; { return kTRUE;}. » Author: Christian Holm Christensen 1/8/2000 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/hist:$Id$ » Last generated: 2015-06-30 15:25; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TPrincipal.html:18418,allocate,allocated,18418,root/html602/TPrincipal.html,https://root.cern,https://root.cern/root/html602/TPrincipal.html,1,['allocate'],['allocated']
Energy Efficiency,"a members of fCurrentClass and of bc to datamembers, recursively.; Real data members are in idx 0..2 (public, protected, private access),; enum constants in idx 3..5. void AnchorFromLine(const TString& line, TString& anchor); Create an anchor from the given line, by hashing it and; convertig the hash into a custom base64 string. void Convert(ostream& out, istream& in, const char* relpath, Bool_t isCode, Bool_t interpretDirectives); Parse text file ""in"", add links etc, and write output to ""out"".; If ""isCode"", ""in"" is assumed to be C++ code. void DecorateKeywords(ostream& out, const char* text); Expand keywords in text, writing to out. void DecorateKeywords(TString& text); Find keywords in line and create URLs around them. Escape characters with a; special meaning for HTML. Protect ""Begin_Html""/""End_Html"" pairs, and set the; parsing context. Evaluate sequences like a::b->c.; Skip regions where directives are active. void DecrementMethodCount(const char* name); reduce method count for method called name,; removing it from fMethodCounts once the count reaches 0. void DeleteDirectiveOutput() const; Delete output generated by prior runs of all known directives;; the output file names might have changes. void ExpandCPPLine(TString& line, Ssiz_t& pos); Expand preprocessor statements. Input: line - line containing the CPP statement,; pos - position of '#'. NOTE: Looks for the #include statements and; creates link to the corresponding file; if such file exists. void GetCurrentModule(TString& out_module) const; Return the name of module for which sources are currently parsed. Bool_t HandleDirective(TString& keyword, Ssiz_t& pos, TString& word, Ssiz_t& copiedToCommentUpTo); Process directives to the documentation engine, like ""Begin_Html"" / ""End_Html"",; ""Begin_Macro"" / ""End_Macro"", and ""Begin_Latex"" / ""End_Latex"". UInt_t InContext(Int_t context) const; checks whether we are in a parse context, return the entry closest; to the current context.; If context is a EParseContextFlag j",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TDocParser.html:12312,reduce,reduce,12312,root/html528/TDocParser.html,https://root.cern,https://root.cern/root/html528/TDocParser.html,5,['reduce'],['reduce']
Energy Efficiency,"a members; class charts. ROOT; » MATH; » FFTW; » TFFTReal. class TFFTReal: public TVirtualFFT. TFFTReal; One of the interface classes to the FFTW package, can be used directly; or via the TVirtualFFT class. Only the basic interface of FFTW is implemented. Computes transforms called r2r in FFTW manual:; - transforms of real input and output in ""halfcomplex"" format i.e.; real and imaginary parts for a transform of size n stored as; (r0, r1, r2, ..., rn/2, i(n+1)/2-1, ..., i2, i1); - discrete Hartley transform; - sine and cosine transforms (DCT-I,II,III,IV and DST-I,II,III,IV); For the detailed information on the computed; transforms please refer to the FFTW manual, chapter ""What FFTW really computes"". How to use it:; 1) Create an instance of TFFTReal - this will allocate input and output; arrays (unless an in-place transform is specified); 2) Run the Init() function with the desired flags and settings (see function; comments for possible kind parameters); 3) Set the data (via SetPoints()or SetPoint() functions); 4) Run the Transform() function; 5) Get the output (via GetPoints() or GetPoint() functions); 6) Repeat steps 3)-5) as needed; For a transform of the same size, but of different kind (or with different flags),; rerun the Init() function and continue with steps 3)-5). NOTE: 1) running Init() function will overwrite the input array! Don't set any data; before running the Init() function!; 2) FFTW computes unnormalized transform, so doing a transform followed by; its inverse will lead to the original array scaled BY:; - transform size (N) for R2HC, HC2R, DHT transforms; - 2*(N-1) for DCT-I (REDFT00); - 2*(N+1) for DST-I (RODFT00); - 2*N for the remaining transforms; Transform inverses:; R2HC<-->HC2R; DHT<-->DHT; DCT-I<-->DCT-I; DCT-II<-->DCT-III; DCT-IV<-->DCT-IV; DST-I<-->DST-I; DST-II<-->DST-III; DST-IV<-->DST-IV. Function Members (Methods); public:. TFFTReal(); TFFTReal(const TFFTReal&); TFFTReal(Int_t n, Bool_t inPlace = kFALSE); TFFTReal(Int_t ndim, Int_t* n,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFFTReal.html:965,allocate,allocate,965,root/html528/TFFTReal.html,https://root.cern,https://root.cern/root/html528/TFFTReal.html,4,['allocate'],['allocate']
Energy Efficiency,"a members; class charts. ROOT; » MATH; » FFTW; » TFFTReal. class TFFTReal: public TVirtualFFT. TFFTReal; One of the interface classes to the FFTW package, can be used directly; or via the TVirtualFFT class. Only the basic interface of FFTW is implemented. Computes transforms called r2r in FFTW manual:; - transforms of real input and output in ""halfcomplex"" format i.e.; real and imaginary parts for a transform of size n stored as; (r0, r1, r2, ..., rn/2, i(n+1)/2-1, ..., i2, i1); - discrete Hartley transform; - sine and cosine transforms (DCT-I,II,III,IV and DST-I,II,III,IV); For the detailed information on the computed; transforms please refer to the FFTW manual, chapter ""What FFTW really computes"". How to use it:; 1) Create an instance of TFFTReal - this will allocate input and output; arrays (unless an in-place transform is specified); 2) Run the Init() function with the desired flags and settings (see function; comments for possible kind parameters); 3) Set the data (via SetPoints()or SetPoint() functions); 4) Run the Transform() function; 5) Get the output (via GetPoints() or GetPoint() functions); 6) Repeat steps 3)-5) as needed; For a transform of the same size, but of different kind (or with different flags),; rerun the Init() function and continue with steps 3)-5). NOTE: 1) running Init() function will overwrite the input array! Don't set any data; before running the Init() function!; 2) FFTW computes unnormalized transform, so doing a transform followed by; its inverse will lead to the original array scaled BY:; - transform size (N) for R2HC, HC2R, DHT transforms; - 2*(N-1) for DCT-I (REDFT00); - 2*(N+1) for DST-I (RODFT00); - 2*N for the remaining transforms; Transform inverses:; R2HC<-->HC2R; DHT<-->DHT; DCT-I<-->DCT-I; DCT-II<-->DCT-III; DCT-IV<-->DCT-IV; DST-I<-->DST-I; DST-II<-->DST-III; DST-IV<-->DST-IV. Function Members (Methods); public:. virtual~TFFTReal(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TFFTReal.html:965,allocate,allocate,965,root/html602/TFFTReal.html,https://root.cern,https://root.cern/root/html602/TFFTReal.html,2,['allocate'],['allocate']
Energy Efficiency,"a memory free operation. This function is only called via; the custom ROOT delete operator. void * Alloc(size_t size); Allocate a block of memory, that later can be resized using; TStorage::ReAlloc(). void Dealloc(void* ptr); De-allocate block of memory, that was allocated via TStorage::Alloc(). void * ReAlloc(void* vp, size_t size); Reallocate (i.e. resize) block of memory. Don't use if size is larger; than old size, use ReAlloc(void *, size_t, size_t) instead. void * ReAlloc(void* vp, size_t size, size_t oldsize); Reallocate (i.e. resize) block of memory. Checks if current size is; equal to oldsize. If not memory was overwritten. char * ReAllocChar(char* vp, size_t size, size_t oldsize); Reallocate (i.e. resize) array of chars. Size and oldsize are; in number of chars. Int_t * ReAllocInt(Int_t* vp, size_t size, size_t oldsize); Reallocate (i.e. resize) array of integers. Size and oldsize are; number of integers (not number of bytes). void * ObjectAlloc(size_t size); Used to allocate a TObject on the heap (via TObject::operator new()).; Directly after this routine one can call (in the TObject ctor); TStorage::FilledByObjectAlloc() to find out if the just created object is on; the heap. This technique is necessary as there is one stack per thread; and we can not rely on comparison with the current stack memory position. void * ObjectAlloc(size_t size, void* vp); Used to allocate a TObject on the heap (via TObject::operator new(size_t,void*)); in position vp. vp is already allocated (maybe on heap, maybe on; stack) so just return. void ObjectDealloc(void* vp); Used to deallocate a TObject on the heap (via TObject::operator delete()). void ObjectDealloc(void* vp, void* ptr); Used to deallocate a TObject on the heap (via TObject::operator delete(void*,void*)). void SetFreeHook(FreeHookFun_t func, void* data); Set a free handler. void SetReAllocHooks(ReAllocFun_t func1, ReAllocCFun_t func2); Set a custom ReAlloc handlers. This function is typically; called via a static o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TStorage.html:4431,allocate,allocate,4431,root/html604/TStorage.html,https://root.cern,https://root.cern/root/html604/TStorage.html,1,['allocate'],['allocate']
Energy Efficiency,"a memory free operation. This function is only called via; the custom ROOT delete operator. void * Alloc(size_t size); Allocate a block of memory, that later can be resized using; TStorage::ReAlloc(). void Dealloc(void* ptr); De-allocate block of memory, that was allocated via TStorage::Alloc(). void * ReAlloc(void* vp, size_t size); Reallocate (i.e. resize) block of memory. Don't use if size is larger; than old size, use ReAlloc(void *, size_t, size_t) instead. void * ReAlloc(void* vp, size_t size, size_t oldsize); Reallocate (i.e. resize) block of memory. Checks if current size is; equal to oldsize. If not memory was overwritten. char * ReAllocChar(char* vp, size_t size, size_t oldsize); Reallocate (i.e. resize) array of chars. Size and oldsize are; in number of chars. Int_t * ReAllocInt(Int_t* vp, size_t size, size_t oldsize); Reallocate (i.e. resize) array of integers. Size and oldsize are; number of integers (not number of bytes). void * ObjectAlloc(size_t size); Used to allocate a TObject on the heap (via TObject::operator new()).; Directly after this routine one can call (in the TObject ctor); TStorage::FilledByObjectAlloc() to find out if the just created object is on; the heap. void * ObjectAlloc(size_t size, void* vp); Used to allocate a TObject on the heap (via TObject::operator new(size_t,void*)); in position vp. vp is already allocated (maybe on heap, maybe on; stack) so just return. void ObjectDealloc(void* vp); Used to deallocate a TObject on the heap (via TObject::operator delete()). void ObjectDealloc(void* vp, void* ptr); Used to deallocate a TObject on the heap (via TObject::operator delete(void*,void*)). void SetFreeHook(FreeHookFun_t func, void* data); Set a free handler. void SetReAllocHooks(ReAllocFun_t func1, ReAllocCFun_t func2); Set a custom ReAlloc handlers. This function is typically; called via a static object in the ROOT libNew.so shared library. void PrintStatistics(); Print memory usage statistics. void EnableStatistics(int size = -1, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TStorage.html:4419,allocate,allocate,4419,root/html534/TStorage.html,https://root.cern,https://root.cern/root/html534/TStorage.html,2,['allocate'],['allocate']
Energy Efficiency,"a point x using an adaptive forward; difference algorithm with a step size h.; The function is evaluated only at points greater than x and at x itself. double EvalBackward(double x, double h = 1.0E-8) const. Computes the numerical derivative at a point x using an adaptive backward; difference algorithm with a step size h.; The function is evaluated only at points less than x and at x itself. double Eval(const ROOT::Math::IGenFunction& f, double x, double h = 1.0E-8); @name --- Static methods ---; This methods don't require to use a Derivator object, and are designed to be used in; fast calculation. Error and status code cannot be retrieved in this case. Computes the numerical derivative of a function f at a point x.; It uses Derivator::EvalCentral to compute the derivative using an; adaptive central difference algorithm with a step size h. double EvalCentral(const ROOT::Math::IGenFunction& f, double x, double h = 1.0E-8). Computes the numerical derivative of a function f at a point x using an adaptive central; difference algorithm with a step size h. double EvalForward(const ROOT::Math::IGenFunction& f, double x, double h = 1.0E-8). Computes the numerical derivative of a function f at a point x using an adaptive forward; difference algorithm with a step size h.; The function is evaluated only at points greater than x and at x itself. double EvalBackward(const ROOT::Math::IGenFunction& f, double x, double h = 1.0E-8). Computes the numerical derivative of a function f at a point x using an adaptive backward; difference algorithm with a step size h.; The function is evaluated only at points less than x and at x itself. double Eval(const ROOT::Math::IMultiGenFunction& f, const double* x, unsigned int icoord = 0, double h = 1.0E-8); Derivatives for multi-dimension functions. Evaluate the partial derivative of a multi-dim function; with respect coordinate x_icoord at the point x[]. double Eval(ROOT::Math::IParamFunction& f, double x, const double* p, unsigned int ipar = 0,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__Derivator.html:4633,adapt,adaptive,4633,root/html602/ROOT__Math__Derivator.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__Derivator.html,2,['adapt'],['adaptive']
Energy Efficiency,"a previous call to SetAddress. ; Definition at line 4672 of file TBranchElement.cxx. ◆ Reset(). void TBranchElement::Reset ; (; Option_t * ; option = """"). overridevirtual . Reset a Branch. ; Existing i/o buffers are deleted. Entries, max and min are reset. ; Reimplemented from TBranch.; Definition at line 4752 of file TBranchElement.cxx. ◆ ResetAddress(). void TBranchElement::ResetAddress ; (; ). overridevirtual . Set branch address to zero and free all allocated memory. ; Reimplemented from TBranch.; Definition at line 4780 of file TBranchElement.cxx. ◆ ResetAfterMerge(). void TBranchElement::ResetAfterMerge ; (; TFileMergeInfo * ; info). overridevirtual . Reset a Branch after a Merge operation (drop data but keep customizations) ; Reimplemented from TBranch.; Definition at line 4767 of file TBranchElement.cxx. ◆ ResetDeleteObject(). void TBranchElement::ResetDeleteObject ; (; ). virtual . Release ownership of any allocated objects. ; Note: This interface was added so that clone trees could be told they do not own the allocated objects. ; Definition at line 4814 of file TBranchElement.cxx. ◆ ResetInitInfo(). void TBranchElement::ResetInitInfo ; (; bool ; recurse). virtual . Reset offset and StreamerInfo information from this branch. ; Parameters. [in]recurseWhen true call ResetInitInfo on all subbranches. . Definition at line 4831 of file TBranchElement.cxx. ◆ SetActionSequence(). void TBranchElement::SetActionSequence ; (; TClass * ; originalClass, . TStreamerInfo * ; localInfo, . TStreamerInfoActions::TActionSequence::SequenceGetter_t ; create, . TStreamerInfoActions::TActionSequence *& ; actionSequence . ). protected . Set the sequence of actions needed to read the data out of the buffer. ; Definition at line 5628 of file TBranchElement.cxx. ◆ SetAddress(). void TBranchElement::SetAddress ; (; void * ; addr). overridevirtual . Point this branch at an object. ; For a sub-branch, addr is a pointer to the branch object.; For a top-level branch the meaning of addr i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBranchElement.html:65402,allocate,allocated,65402,doc/master/classTBranchElement.html,https://root.cern,https://root.cern/doc/master/classTBranchElement.html,1,['allocate'],['allocated']
Energy Efficiency,"a0+a1*x+a2*x*x); fixA0 - logical value of a0 parameter, which allows to fix the parameter (not to fit); a1Init - initial value of a1 parameter; fixA1 - logical value of a1 parameter, which allows to fix the parameter (not to fit); a2Init - initial value of a2 parameter; fixA2 - logical value of a2 parameter, which allows to fix the parameter (not to fit) . Definition at line 2693 of file TSpectrumFit.cxx. ◆ SetFitParameters(). void TSpectrumFit::SetFitParameters ; (; Int_t ; xmin, . Int_t ; xmax, . Int_t ; numberIterations, . Double_t ; alpha, . Int_t ; statisticType, . Int_t ; alphaOptim, . Int_t ; power, . Int_t ; fitTaylor . ). This function sets the following fitting parameters: . xmin, xmax - fitting region; numberIterations - # of desired iterations in the fit; alpha - convergence coefficient, it should be positive number and <=1, for details see references; statisticType - type of statistics, possible values kFitOptimChiCounts (chi square statistics with counts as weighting coefficients), kFitOptimChiFuncValues (chi square statistics with function values as weighting coefficients),kFitOptimMaxLikelihood; alphaOptim - optimization of convergence algorithm, possible values kFitAlphaHalving, kFitAlphaOptimal; power - possible values kFitPower2,4,6,8,10,12, for details see references. It applies only for Awmi fitting function.; fitTaylor - order of Taylor expansion, possible values kFitTaylorOrderFirst, kFitTaylorOrderSecond. It applies only for Awmi fitting function. . Definition at line 2610 of file TSpectrumFit.cxx. ◆ SetPeakParameters(). void TSpectrumFit::SetPeakParameters ; (; Double_t ; sigma, . Bool_t ; fixSigma, . const Double_t * ; positionInit, . const Bool_t * ; fixPosition, . const Double_t * ; ampInit, . const Bool_t * ; fixAmp . ). This function sets the following fitting parameters of peaks: . sigma - initial value of sigma parameter; fixSigma - logical value of sigma parameter, which allows to fix the parameter (not to fit); positionInit - array o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSpectrumFit.html:46088,power,power,46088,doc/master/classTSpectrumFit.html,https://root.cern,https://root.cern/doc/master/classTSpectrumFit.html,1,['power'],['power']
Energy Efficiency,"a::allClientsCached(RooAbsArg*, const RooArgSet&); voidRooDirItem::appendToDir(TObject* obj, Bool_t forceMemoryResident = kFALSE); virtual voidRooAbsData::attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); virtual voidRooAbsData::cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0, Bool_t skipZeroWeights = kFALSE); virtual RooAbsData*cacheClone(const RooAbsArg* newCacheOwner, const RooArgSet* newCacheVars, const char* newName = 0); static voidcleanup(); Double_tRooAbsData::corrcov(RooRealVar& x, RooRealVar& y, const char* cutSpec, const char* cutRange, Bool_t corr) const; TMatrixDSym*RooAbsData::corrcovMatrix(const RooArgList& vars, const char* cutSpec, const char* cutRange, Bool_t corr) const; RooRealVar*RooAbsData::dataRealVar(const char* methodname, RooRealVar& extVar) const; virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidinitialize(const char* wgtVarName); voidTObject::MakeZombie(); virtual voidRooAbsData::optimizeReadingWithCaching(RooAbsArg& arg, const RooArgSet& cacheList, const RooArgSet& keepObsList); virtual RooPlot*RooAbsData::plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsData::PlotOpt o) const; virtual RooPlot*RooAbsData::plotEffOn(RooPlot* frame, const RooAbsCategoryLValue& effCat, RooAbsData::PlotOpt o) const; virtual RooPlot*RooAbsData::plotOn(RooPlot* frame, RooAbsData::PlotOpt o) const; virtual RooAbsData*reduceEng(const RooArgSet& varSubset, const RooFormulaVar* cutVar, const char* cutRange = 0, Int_t nStart = 0, Int_t nStop = 2000000000, Bool_t copyCache = kTRUE); voidRooDirItem::removeFromDir(TObject* obj); virtual voidRooAbsData::resetCache(); RooDataSet(const char* name, const char* title, RooDataSet* ntuple, const RooArgSet& vars, const RooFormulaVar* cutVar, const char* cutRange, int nStart, int nStop, Bool_t copyCache, const char* wgtVarName = 0); virtual voidRooAbsData::setArgStatus(const RooArgSet& set, Bool_t active).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooDataSet.html:15927,reduce,reduceEng,15927,root/html602/RooDataSet.html,https://root.cern,https://root.cern/root/html602/RooDataSet.html,2,['reduce'],['reduceEng']
Energy Efficiency,"a::fCoordErrorsPtrstd::vector< const double * > fCoordErrorsPtrDefinition BinData.h:616; ROOT::Fit::BinData::Appendvoid Append(unsigned int newPoints, unsigned int dim=1, ErrorType err=kValueError)Equivalent to Initialize()Definition BinData.cxx:320; ROOT::Fit::BinData::fDataErrorLowstd::vector< double > fDataErrorLowDefinition BinData.h:622; ROOT::Fit::BinData::AddBinUpEdgevoid AddBinUpEdge(const double *xup)add the bin width data, a pointer to an array with the bin upper edge information.Definition BinData.cxx:613; ROOT::Fit::BinData::fDataErrorLowPtrconst double * fDataErrorLowPtrDefinition BinData.h:625; ROOT::Fit::BinData::fDataErrorHighstd::vector< double > fDataErrorHighDefinition BinData.h:621; ROOT::Fit::BinData::LogTransformBinData & LogTransform()apply a Log transformation of the data values can be used for example when fitting an exponential or ...Definition BinData.cxx:349; ROOT::Fit::BinData::BinDataBinData(unsigned int maxpoints=0, unsigned int dim=1, ErrorType err=kValueError)constructor from dimension of point and max number of points (to pre-allocate vector) Give a zero val...Definition BinData.cxx:24; ROOT::Fit::BinData::fErrorTypeErrorType fErrorTypeDefinition BinData.h:602; ROOT::Fit::BinData::fpTmpCoordErrorVectordouble * fpTmpCoordErrorVectornot threadsafe stuff!Definition BinData.h:629; ROOT::Fit::BinData::InitDataVectorvoid InitDataVector()Definition BinData.cxx:645; ROOT::Fit::BinData::fIsWeightedbool fIsWeightedflag to indicate weighted dataDefinition BinData.h:603; ROOT::Fit::BinData::InitBinEdgevoid InitBinEdge()Definition BinData.cxx:725; ROOT::Fit::BinData::fCoordErrorsstd::vector< std::vector< double > > fCoordErrorsDefinition BinData.h:615; ROOT::Fit::BinData::Addvoid Add(double x, double y)add one dim data with only coordinate and valuesDefinition BinData.cxx:408; ROOT::Fit::BinData::fSumContentdouble fSumContenttotal sum of the bin data contentDefinition BinData.h:605; ROOT::Fit::BinData::operator=BinData & operator=(const BinData ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/BinData_8cxx_source.html:28181,allocate,allocate,28181,doc/master/BinData_8cxx_source.html,https://root.cern,https://root.cern/doc/master/BinData_8cxx_source.html,1,['allocate'],['allocate']
Energy Efficiency,"aHist::printArgs ; (; std::ostream & ; os); const. overridevirtual . Print argument of dataset, i.e. the observable names. ; Reimplemented from RooPrintable.; Definition at line 2263 of file RooDataHist.cxx. ◆ printDataHistogram(). void RooDataHist::printDataHistogram ; (; std::ostream & ; os, . RooRealVar * ; obs . ); const. Definition at line 2320 of file RooDataHist.cxx. ◆ printMultiline(). void RooDataHist::printMultiline ; (; std::ostream & ; os, . Int_t ; content, . bool ; verbose = false, . TString ; indent = """" . ); const. overridevirtual . Print the details on the dataset contents. ; Reimplemented from RooAbsData.; Definition at line 2299 of file RooDataHist.cxx. ◆ printValue(). void RooDataHist::printValue ; (; std::ostream & ; os); const. overridevirtual . Print value of the dataset, i.e. the sum of weights contained in the dataset. ; Reimplemented from RooPrintable.; Definition at line 2252 of file RooDataHist.cxx. ◆ reduceEng(). std::unique_ptr< RooAbsData > RooDataHist::reduceEng ; (; const RooArgSet & ; varSubset, . const RooFormulaVar * ; cutVar, . const char * ; cutRange = nullptr, . std::size_t ; nStart = 0, . std::size_t ; nStop = std::numeric_limits<std::size_t>::max() . ); const. overrideprotectedvirtual . Implementation of RooAbsData virtual method that drives the RooAbsData::reduce() methods. ; Implements RooAbsData.; Definition at line 916 of file RooDataHist.cxx. ◆ registerWeightArraysToDataStore(). void RooDataHist::registerWeightArraysToDataStore ; (; ); const. private . Hand over pointers to our weight arrays to the data store implementation. ; Definition at line 2413 of file RooDataHist.cxx. ◆ removeSelfFromDir(). void RooDataHist::removeSelfFromDir ; (; ). inline . Definition at line 164 of file RooDataHist.h. ◆ reset(). void RooDataHist::reset ; (; ). overridevirtual . Reset all bin weights to zero. ; Reimplemented from RooAbsData.; Definition at line 2158 of file RooDataHist.cxx. ◆ set() [1/4]. void RooDataHist::set ; (; const RooArgSe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooDataHist.html:73966,reduce,reduceEng,73966,doc/master/classRooDataHist.html,https://root.cern,https://root.cern/doc/master/classRooDataHist.html,1,['reduce'],['reduceEng']
Energy Efficiency,"aSet* ntuple, const RooArgSet& vars, const RooFormulaVar* cutVar, const char* cutRange, int nStart, int nStop, Bool_t copyCache, const char* wgtVarName = 0); RooArgSetaddWgtVar(const RooArgSet& origVars, const RooAbsArg* wgtVar); Bool_tRooAbsData::allClientsCached(RooAbsArg*, const RooArgSet&); voidRooDirItem::appendToDir(TObject* obj, Bool_t forceMemoryResident = kFALSE); virtual voidRooAbsData::attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); virtual voidRooAbsData::cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0); virtual RooAbsData*cacheClone(const RooAbsArg* newCacheOwner, const RooArgSet* newCacheVars, const char* newName = 0); static voidcleanup(); Double_tRooAbsData::corrcov(RooRealVar& x, RooRealVar& y, const char* cutSpec, const char* cutRange, Bool_t corr) const; TMatrixDSym*RooAbsData::corrcovMatrix(const RooArgList& vars, const char* cutSpec, const char* cutRange, Bool_t corr) const; RooRealVar*RooAbsData::dataRealVar(const char* methodname, RooRealVar& extVar) const; virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidinitialize(const char* wgtVarName); voidTObject::MakeZombie(); virtual voidRooAbsData::optimizeReadingWithCaching(RooAbsArg& arg, const RooArgSet& cacheList, const RooArgSet& keepObsList); virtual RooPlot*RooAbsData::plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsData::PlotOpt o) const; virtual RooPlot*RooAbsData::plotEffOn(RooPlot* frame, const RooAbsCategoryLValue& effCat, RooAbsData::PlotOpt o) const; virtual RooPlot*RooAbsData::plotOn(RooPlot* frame, RooAbsData::PlotOpt o) const; virtual RooAbsData*reduceEng(const RooArgSet& varSubset, const RooFormulaVar* cutVar, const char* cutRange = 0, Int_t nStart = 0, Int_t nStop = 2000000000, Bool_t copyCache = kTRUE); voidRooDirItem::removeFromDir(TObject* obj); virtual voidRooAbsData::resetCache(); virtual voidRooAbsData::setArgStatus(const RooArgSet& set, Bool_t active).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooDataSet.html:15687,reduce,reduceEng,15687,root/html530/RooDataSet.html,https://root.cern,https://root.cern/root/html530/RooDataSet.html,2,['reduce'],['reduceEng']
Energy Efficiency,"aY, const double* dataZ); ROOT::Fit::UnBinDataUnBinData(unsigned int maxpoints, const double* dataX, const double* dataY, const ROOT::Fit::DataRange& range); ROOT::Fit::UnBinDataUnBinData(unsigned int maxpoints, const double* dataX, const double* dataY, const double* dataZ, const ROOT::Fit::DataRange& range). protected:. voidSetNPoints(unsigned int n). private:. ROOT::Fit::UnBinData&operator=(const ROOT::Fit::UnBinData&); ROOT::Fit::UnBinDataUnBinData(const ROOT::Fit::UnBinData&). Data Members; private:. ROOT::Fit::DataVector*fDataVectorpointer to internal data vector (null for external data); ROOT::Fit::DataWrapper*fDataWrapperpointer to structure wrapping external data (null when data are copied in); unsigned intfDimcoordinate data dimension; unsigned intfNPointsnumer of fit points. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; explicit UnBinData(unsigned int maxpoints = 0, unsigned int dim = 1 ). constructor from dimension of point and max number of points (to pre-allocate vector). explicit UnBinData(const DataRange & range, unsigned int maxpoints = 0, unsigned int dim = 1). constructor from range and default option. UnBinData(const DataOptions & opt, const DataRange & range, unsigned int maxpoints = 0, unsigned int dim = 1 ). constructor from options and range. UnBinData(unsigned int n, const double * dataX ). constructor for 1D external data (data are not copied inside). UnBinData(unsigned int n, const double * dataX, const double * dataY ). constructor for 2D external data (data are not copied inside). UnBinData(unsigned int n, const double * dataX, const double * dataY, const double * dataZ ). constructor for 3D external data (data are not copied inside). UnBinData(unsigned int n, unsigned int dim, Iterator dataItr ). constructor for multi-dim external data (data are not copied inside); Uses as argument an iterator of a list (or vector) containing the const double * of the data; An example could be the std::vector<c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Fit__UnBinData.html:3830,allocate,allocate,3830,root/html526/ROOT__Fit__UnBinData.html,https://root.cern,https://root.cern/root/html526/ROOT__Fit__UnBinData.html,1,['allocate'],['allocate']
Energy Efficiency,"ability p. ;  ; Bool_t Odd (Long_t a);  Returns true if a is odd. ;  ; Bool_t Permute (Int_t n, Int_t *a);  Simple recursive algorithm to find the permutations of n natural numbers, not necessarily all distinct adapted from CERNLIB routine PERMU. ;  ; constexpr Double_t Pi ();  \( \pi\) ;  ; constexpr Double_t PiOver2 ();  \( \frac{\pi}{2} \) ;  ; constexpr Double_t PiOver4 ();  \( \frac{\pi}{4} \) ;  ; Double_t Poisson (Double_t x, Double_t par);  Computes the Poisson distribution function for (x,par). ;  ; Double_t PoissonI (Double_t x, Double_t par);  Computes the Discrete Poisson distribution function for (x,par). ;  ; Double_t Power (Double_t x, Double_t y);  Returns x raised to the power y. ;  ; Double_t Power (Double_t x, Int_t y);  Returns x raised to the power y. ;  ; LongDouble_t Power (Long64_t x, Long64_t y);  Returns x raised to the power y. ;  ; LongDouble_t Power (LongDouble_t x, Long64_t y);  Returns x raised to the power y. ;  ; LongDouble_t Power (LongDouble_t x, LongDouble_t y);  Returns x raised to the power y. ;  ; Double_t Prob (Double_t chi2, Int_t ndf);  Computation of the probability for a certain Chi-squared (chi2) and number of degrees of freedom (ndf). ;  ; constexpr Double_t Qe ();  Elementary charge in \( C \) . ;  ; constexpr Double_t QeUncertainty ();  Elementary charge uncertainty. ;  ; void Quantiles (Int_t n, Int_t nprob, Double_t *x, Double_t *quantiles, Double_t *prob, Bool_t isSorted=kTRUE, Int_t *index=nullptr, Int_t type=7);  Computes sample quantiles, corresponding to the given probabilities. ;  ; Double_t QuietNaN ();  Returns a quiet NaN as defined by IEEE 754. ;  ; constexpr Double_t R ();  Universal gas constant ( \( Na K \)) in \( J K^{-1} mol^{-1} \) ;  ; constexpr Double_t RadToDeg ();  Conversion from radian to degree: \( \frac{180}{\pi} \). ;  ; Double_t Range (Double_t lb, Double_t ub, Double_t x);  Returns x if lb < x < up, lb if x < lb and ub if x > ub. ;  ; Int_t Range (Int_t lb, Int_t ub, Int_t x);  Returns x if",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceTMath.html:17410,power,power,17410,doc/master/namespaceTMath.html,https://root.cern,https://root.cern/doc/master/namespaceTMath.html,1,['power'],['power']
Energy Efficiency,able ;  CVariableNormalizeTransformLinear interpolation class ;  CVariablePCATransformLinear interpolation class ;  CVariableRearrangeTransformRearrangement of input variables ;  CVariableTransformBaseLinear interpolation class ;  CVarTransformHandler;  CVolumeVolume for BinarySearchTree ;  ►NTStreamerInfoActions;  CTActionSequence;  CTConfigurationBase class of the Configurations ;  CTConfiguredAction;  CTLoopConfigurationBase class of the Configurations for the member wise looping routines ;  ►Nwriter;  Cwriter;  C_x3d_data_;  C_x3d_sizeof_;  CAnyCollectionProxy;  CAnyCollectionStreamer;  CApplicationWindowMain Qt&Root Application Window: ;  CBalancerInfo;  ►CBidirMMapPipeBidirMMapPipe creates a bidirectional channel between the current process and a child it forks ;  CPollEntryFor poll() interface ;  CBinaryOpPolicy;  CBinomialNeymanInterval;  CBinomialProbHelper;  CClusterD;  CColorStruct_t;  CCompareAsc;  CcompareBAasc;  CcompareBAdesc;  CCompareDesc;  CContDistFree functions adapter needed by UNURAN for onedimensional continuous distributions ;  CContextSmall helper to keep current directory context ;  CCpuInfo_t;  CData;  CDebuggingSamplerDebuggingSampler is a simple implementation of the DistributionCreator interface used for debugging ;  CDebuggingTestStatDebuggingTestStat is a simple implementation of the DistributionCreator interface used for debugging ;  CDiscrDistFree functions adapter needed by UNURAN for one-dimensional discrete distribution ;  CDUMMY;  CEditor;  CEvent_t;  CExceptionContext_t;  CFeldmanCousinsBinomialInterval;  CFeldmanCousinsSorter;  CFileStat_t;  CFontAttributes_t;  CFontMetrics_t;  CFoption_t;  CFUMILI2;  Cfuncptr_and_voidptr_t;  CGaussFunction;  CGcCache_t;  CGCValues_t;  Cgroup;  CGSL_BFGS;  CGSL_BFGS2;  CGSL_FR;  CGSL_NLS;  CGSL_PR;  Ch1analysis;  Ch1analysisTreeReader;  CHelperOps;  CHEPEVT_DEFHEPEVT common block ;  CHit;  CHoption_tHistogram option structure ;  CHparam_tHistogram parameters structure ;  CJet;  CJetEvent;  CLI,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v610/annotated.html:81000,adapt,adapter,81000,doc/v610/annotated.html,https://root.cern,https://root.cern/doc/v610/annotated.html,1,['adapt'],['adapter']
Energy Efficiency,"able at the home page of the Minuit2 minimization package"". . Classes; class  ROOT::Minuit2::FCNAdapter< Function >;  template wrapped class for adapting to FCNBase signature More...;  ; class  ROOT::Minuit2::FCNBase;  Interface (abstract class) defining the function to be minimized, which has to be implemented by the user. More...;  ; class  ROOT::Minuit2::FCNGradAdapter< Function >;  template wrapped class for adapting to FCNBase signature a IGradFunction More...;  ; class  ROOT::Minuit2::FumiliBuilder;  Builds the FunctionMinimum using the Fumili method. More...;  ; class  ROOT::Minuit2::FumiliChi2FCN;  Extension of the FCNBase for the Fumili method. More...;  ; class  ROOT::Minuit2::FumiliErrorUpdator;  In the case of the Fumili algorithm the Error matrix (or the Hessian matrix containing the (approximate) second derivatives) is calculated using a linearization of the model function negleting second derivatives. More...;  ; class  ROOT::Minuit2::FumiliFCNAdapter< Function >;  template wrapped class for adapting to FumiliFCNBase signature More...;  ; class  ROOT::Minuit2::FumiliFCNBase;  Extension of the FCNBase for the Fumili method. More...;  ; class  ROOT::Minuit2::FumiliMaximumLikelihoodFCN;  Extension of the FCNBase for the Fumili method. More...;  ; class  ROOT::Minuit2::FumiliMinimizer;  Instantiates the seed generator and Minimum builder for the Fumili minimization method. More...;  ; class  ROOT::Minuit2::FumiliStandardChi2FCN;  Class implementing the standard chi square function, which is the sum of the squares of the figures-of-merit calculated for each measurement point, the individual figures-of-merit being: (the Value predicted by the model-measured Value)/standard deviation. More...;  ; class  ROOT::Minuit2::FumiliStandardMaximumLikelihoodFCN;  Class implementing the Elements member function for the standard maximum likelihood method. More...;  ; class  ROOT::Minuit2::GenericFunction;  Class from which all the other classes, representing functions,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Minuit.html:1285,adapt,adapting,1285,doc/master/group__Minuit.html,https://root.cern,https://root.cern/doc/master/group__Minuit.html,1,['adapt'],['adapting']
Energy Efficiency,"ableImplicitMT() before constructing the RDataFrame object to indicate that it should take advantage of a pool of worker threads. Each worker thread processes a distinct subset of entries, and their partial results are merged before returning the final values to the user. There are no guarantees on the order in which threads will process the batches of entries. In particular, note that this means that, for multi-thread event loops, there is no guarantee on the order in which Snapshot() will write entries: they could be scrambled with respect to the input dataset. The values of the special rdfentry_ column will also not correspond to the entry numbers in the input dataset (e.g. TChain) in multi-thread runs.; WarningBy default, RDataFrame will use as many threads as the hardware supports, using up all the resources on a machine. This might be undesirable on shared computing resources such as a batch cluster. Therefore, when running on shared computing resources, use ROOT::EnableImplicitMT(i); replacing i with the number of CPUs/slots that were allocated for this job. Thread-safety of user-defined expressions; RDataFrame operations such as Histo1D() or Snapshot() are guaranteed to work correctly in multi-thread event loops. User-defined expressions, such as strings or lambdas passed to Filter(), Define(), Foreach(), Reduce() or Aggregate() will have to be thread-safe, i.e. it should be possible to call them concurrently from different threads.; Note that simple Filter() and Define() transformations will inherently satisfy this requirement: Filter() / Define() expressions will often be pure in the functional programming sense (no side-effects, no dependency on external state), which eliminates all risks of race conditions.; In order to facilitate writing of thread-safe operations, some RDataFrame features such as Foreach(), Define() or OnPartialResult() offer thread-aware counterparts (ForeachSlot(), DefineSlot(), OnPartialResultSlot()): their only difference is that th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html:46250,allocate,allocated,46250,doc/v632/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html,2,['allocate'],['allocated']
Energy Efficiency,"about the on-disk metadata of an RNTuple.; A new RNTupleParallelWriter class has been added, providing (initial) support for parallel writing of RNTuples.; A new static method RFieldBase::Check() has been added, which produces a support status report of a type with regards to RNTuple I/O.; A new internal RNTupleMerger class has been added, enabling the merging of different page sources into one page sink. This also means that RNTuples can be merged through hadd.; Zero-copy bulk reading has been added, with extra optimizations for ROOT::RVec fields.; It is now possible to use the RNTupleView with an external address with type erasure, e.g.:; std::shared_ptr<void> data{new float()};; auto view = reader->GetView(""pt"", data);; This enables use cases such as reading one specific entry of one specific field into a previously allocated memory location.; Further integration with RDataFrame: it is now possible to create RDataFrame for chains of RNTuples. This addition also comes with improvements to the multi-threaded work scheduling.; Many additional bug fixes and improvements. Please, report any issues regarding the above mentioned features should you encounter them. RNTuple is still in pre-production. The on-disk format is scheduled to be finalized by the end of 2024. Thus, we appreciate feedback and suggestions for improvement.; Histogram Libraries. Implement the FLT_MAX mechanism for THStack::GetMaximum() and THStack::GetMiniumum().; Print a warning when the range given to TAxis::SetRange is invalid.; Fix projection name in TH3 as requested here. Parallelism. The ROOT::Experimental::TFuture template has been removed. RooFit Libraries; New CPU likelihood evaluation backend by default; The new vectorizing CPU evaluation backend is not the default for RooFit likelihoods. Likelihood minimization is now up to 10x faster on a single CPU core.; If you experience unexpected problems related to the likelihood evaluation, you can revert back to the old backend by passing RooFit::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/release-notes.html:7378,schedul,scheduling,7378,doc/v632/release-notes.html,https://root.cern,https://root.cern/doc/v632/release-notes.html,1,['schedul'],['scheduling']
Energy Efficiency,"ace for the PROOF internal performance measurement and event tracing ;  CTPGONA polygon ;  CTPgSQLResult;  CTPgSQLRow;  CTPgSQLServer;  CTPgSQLStatement;  CTPickerStackGuard;  CTPieDraw a Pie Chart, ;  CTPieEditor;  CTPieSliceA slice of a piechart, see the TPie class ;  CTPieSliceEditor;  CTPluginHandler;  CTPluginManagerThis class implements a plugin library manager ;  CTPMERegexpWrapper for PCRE library (Perl Compatible Regular Expressions) ;  CTPoint;  CTPoints2-D graphics point (world coordinates) ;  CTPoints3D;  CTPoints3DABCAbstract class to define Arrays of 3D points ;  CTPointsArray3D;  CTPointSet3DTPolyMarker3D using TPointSet3DGL for direct OpenGL rendering ;  CTPointSet3DGLDirect OpenGL renderer for TPointSet3D ;  CTPolyLineDefined by an array on N points in a 2-D space ;  CTPolyLine3DA 3-dimensional polyline ;  CTPolyLineShape;  CTPolyMarkerA PolyMarker is defined by an array on N points in a 2-D space ;  CTPolyMarker3DA 3D polymarker ;  CTPoolManagerA manager for the scheduler behind ROOT multithreading operations ;  CTPosixCondition;  CTPosixMutex;  CTPosixThread;  CTPosixThreadCleanUp;  CTPosixThreadFactory;  CTPostScriptInterface to PostScript ;  CTPRegexp;  CTPrimaryOld version of a dynamic particle class created by event generators ;  CTPrincipalPrincipal Components Analysis (PCA) ;  CTProcessEventTimer;  CTProcessIDA TProcessID identifies a ROOT job in a unique way in time and space ;  CTProcessUUIDThis class is a specialized TProcessID managing the list of UUIDs ;  CTProfileProfile Histogram ;  CTProfile2DProfile2D histograms are used to display the mean value of Z and its RMS for each cell in X,Y ;  CTProfile2Poly2D Profile Histogram with Polygonal Bins ;  CTProfile2PolyBinHelper class to represent a bin in the TProfile2Poly histogram ;  CTProfile3DProfile3D histograms are used to display the mean value of T and its RMS for each cell in X,Y,Z ;  CTProfileHelper;  ►CTProofThis class controls a Parallel ROOT Facility, PROOF, cluster ;  CMD5Mod_t; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/annotated.html:201477,schedul,scheduler,201477,doc/v616/annotated.html,https://root.cern,https://root.cern/doc/v616/annotated.html,1,['schedul'],['scheduler']
Energy Efficiency,"ace to RooCustomizer. EDIT::name( orig, substNode=origNode), ... ] -- Create a clone of input object orig, with the specified replacements operations executed. Interface to RooClassFactory. CEXPR::name('expr',var,...] -- Create an custom compiled p.d.f that evaluates the given expression; cexpr::name('expr',var,...] -- Create an custom compiled function that evaluates the given expression. $MetaType(...) - Meta argument that does not result in construction of an object but is used logically organize; input arguments in certain operator p.d.f. constructions. The defined meta arguments are context dependent. The only meta argument that is defined globally is $Alias(typeName,aliasName) to; define aliases for type names. For the definition of meta arguments in operator p.d.f.s; see the definitions below. std::string processExpression(const char* expr); Process a single high-level expression or list of; expressions. The returned string a the reduced expression where; all inline object creations have been executed and substituted; with the name of the created object. e.g. 'RooGaussian::g(x,m,s)' --> 'g'; '{x(-10,10),s} --> '{x,s}'. std::string processCompositeExpression(const char* arg); Process a single composite expression. e.g. 'A=RooGaussian::g[x,m,s]' --> 'A=g'; e.g. 'f[0,1]*RooGaussian::g[x,m,s]' --> 'f*g'; e.g. 'RooGaussian::g(x,y,s)|x' --> g|x'; e.g. '$MetaArg(RooGaussian::g[x,m,s],blah)' --> '$MetaArg(g,blah)'. std::string processSingleExpression(const char* arg); Process a single high-level expression. The returned string a the reduced; expression where all inline object creations have been executed and substituted; with the name of the created object. e.g. 'RooGaussian::g(x,m,s)' --> 'g'; e.g. 'x[-10,10]' --> 'x'. string processListExpression(const char* arg); Process a list of high-level expression. The returned string a the reduced; expression list where all inline object creations have been executed and substituted; with the name of the created object. E.g. '",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooFactoryWSTool.html:16511,reduce,reduced,16511,root/html526/RooFactoryWSTool.html,https://root.cern,https://root.cern/root/html526/RooFactoryWSTool.html,2,['reduce'],['reduced']
Energy Efficiency,"aceAll( ""]"", ""_"" );; 816 snew.ReplaceAll( ""="", ""_E_"" );; 817 snew.ReplaceAll( "">"", ""_GT_"" );; 818 snew.ReplaceAll( ""<"", ""_LT_"" );; 819 snew.ReplaceAll( ""("", ""_"" );; 820 snew.ReplaceAll( "")"", ""_"" );; 821 ; 822 return snew;; 823}; 824 ; 825////////////////////////////////////////////////////////////////////////////////; 826/// human readable color strings; 827 ; 828const TString& TMVA::Tools::Color( const TString& c ); 829{; 830 static const TString gClr_none = """" ;; 831 static const TString gClr_white = ""\033[1;37m""; // white; 832 static const TString gClr_black = ""\033[30m""; // black; 833 static const TString gClr_blue = ""\033[34m""; // blue; 834 static const TString gClr_red = ""\033[1;31m"" ; // red; 835 static const TString gClr_yellow = ""\033[1;33m""; // yellow; 836 static const TString gClr_darkred = ""\033[31m""; // dark red; 837 static const TString gClr_darkgreen = ""\033[32m""; // dark green; 838 static const TString gClr_darkyellow = ""\033[33m""; // dark yellow; 839 ; 840 static const TString gClr_bold = ""\033[1m"" ; // bold; 841 static const TString gClr_black_b = ""\033[30m"" ; // bold black; 842 static const TString gClr_lblue_b = ""\033[1;34m"" ; // bold light blue; 843 static const TString gClr_cyan_b = ""\033[0;36m"" ; // bold cyan; 844 static const TString gClr_lgreen_b = ""\033[1;32m""; // bold light green; 845 ; 846 static const TString gClr_blue_bg = ""\033[44m""; // blue background; 847 static const TString gClr_red_bg = ""\033[1;41m""; // white on red background; 848 static const TString gClr_whiteonblue = ""\033[1;44m""; // white on blue background; 849 static const TString gClr_whiteongreen = ""\033[1;42m""; // white on green background; 850 static const TString gClr_grey_bg = ""\033[47m""; // grey background; 851 ; 852 static const TString gClr_reset = ""\033[0m""; // reset; 853 ; 854 if (!gConfig().UseColor()) return gClr_none;; 855 ; 856 if (c == ""white"" ) return gClr_white;; 857 if (c == ""blue"" ) return gClr_blue;; 858 if (c == ""black"" ) return gClr_black;; 859 if (c ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Tools_8cxx_source.html:28632,green,green,28632,doc/master/Tools_8cxx_source.html,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html,3,['green'],['green']
Energy Efficiency,"ach basic material in the mixture. If nlmat < 0 then wmat contains the number of atoms; of a given kind into the molecule of the compound.; In this case, wmat in output is changed to relative; weights. void Medium(Int_t& kmed, const char* name, Int_t nmat, Int_t isvol, Int_t ifield, Double_t fieldm, Double_t tmaxfd, Double_t stemax, Double_t deemax, Double_t epsil, Double_t stmin, Float_t* ubuf, Int_t nbuf); The same as previous but in double precision; Define a medium.; kmed tracking medium number assigned; name tracking medium name; nmat material number; isvol sensitive volume flag; ifield magnetic field:; - ifield = 0 if no magnetic field;; - ifield = -1 if user decision in guswim;; - ifield = 1 if tracking performed with g3rkuta;; - ifield = 2 if tracking performed with g3helix;; - ifield = 3 if tracking performed with g3helx3.; fieldm max. field value (kilogauss); tmaxfd max. angle due to field (deg/step); stemax max. step allowed; deemax max. fraction of energy lost in a step; epsil tracking precision (cm); stmin min. step due to continuous processes (cm); ubuf pointer to an array of user words; nbuf number of user words. void Matrix(Int_t& krot, Double_t thetaX, Double_t phiX, Double_t thetaY, Double_t phiY, Double_t thetaZ, Double_t phiZ); The same as previous but in double precision; Define a rotation matrix; krot rotation matrix number assigned; thetaX polar angle for axis X; phiX azimuthal angle for axis X; thetaY polar angle for axis Y; phiY azimuthal angle for axis Y; thetaZ polar angle for axis Z; phiZ azimuthal angle for axis Z. Int_t Gsvolu(const char* name, const char* shape, Int_t nmed, Float_t* upar, Int_t np); Change the value of cut or mechanism param; to a new value parval for tracking medium itmed.; In Geant3, the data structure JTMED contains the standard tracking; parameters (CUTS and flags to control the physics processes) which; are used by default for all tracking media.; It is possible to redefine individually with this function any of th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualMC.html:19074,energy,energy,19074,root/html528/TVirtualMC.html,https://root.cern,https://root.cern/root/html528/TVirtualMC.html,6,['energy'],['energy']
Energy Efficiency,"acheUnzip.h. ◆ GetNUnzip(). Int_t TTreeCacheUnzip::GetNUnzip ; (; ). inline . Definition at line 152 of file TTreeCacheUnzip.h. ◆ GetParallelUnzip(). TTreeCacheUnzip::EParUnzipMode TTreeCacheUnzip::GetParallelUnzip ; (; ). static . Static function that returns the parallel option (to indicate an additional thread) ; Definition at line 407 of file TTreeCacheUnzip.cxx. ◆ GetRecordHeader(). Int_t TTreeCacheUnzip::GetRecordHeader ; (; char * ; buf, . Int_t ; maxbytes, . Int_t & ; nbytes, . Int_t & ; objlen, . Int_t & ; keylen . ). Read the logical record header from the buffer buf. ; That must be the pointer tho the header part not the object by itself and must contain data of at least maxbytes Returns nread;; In output arguments:. nbytes : number of bytes in record if negative, this is a deleted record if 0, cannot read record, wrong value of argument first; objlen : uncompressed object size; keylen : length of logical record header. Note that the arguments objlen and keylen are returned only if maxbytes >=16 Note: This was adapted from TFile... so some things dont apply ; Definition at line 469 of file TTreeCacheUnzip.cxx. ◆ GetUnzipBuffer(). Int_t TTreeCacheUnzip::GetUnzipBuffer ; (; char ** ; buf, . Long64_t ; pos, . Int_t ; len, . bool * ; free . ). overridevirtual . We try to read a buffer that has already been unzipped Returns -1 in case of read failure, 0 in case it's not in the cache and n>0 in case read from cache (number of bytes copied). ; pos and len are the original values as were passed to ReadBuffer but instead we will return the inflated buffer. Note!! : If *buf == 0 we will allocate the buffer and it will be the responsibility of the caller to free it... it is useful for example to pass it to the creator of TBuffer ; Reimplemented from TFileCacheRead.; Definition at line 668 of file TTreeCacheUnzip.cxx. ◆ GetUnzipGroupSize(). Int_t TTreeCacheUnzip::GetUnzipGroupSize ; (; ). inline . Definition at line 142 of file TTreeCacheUnzip.h. ◆ Init(). void TTree",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCacheUnzip.html:30435,adapt,adapted,30435,doc/v632/classTTreeCacheUnzip.html,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html,1,['adapt'],['adapted']
Energy Efficiency,"acheUnzip.h. ◆ GetNUnzip(). Int_t TTreeCacheUnzip::GetNUnzip ; (; ). inline . Definition at line 152 of file TTreeCacheUnzip.h. ◆ GetParallelUnzip(). TTreeCacheUnzip::EParUnzipMode TTreeCacheUnzip::GetParallelUnzip ; (; ). static . Static function that returns the parallel option (to indicate an additional thread) ; Definition at line 408 of file TTreeCacheUnzip.cxx. ◆ GetRecordHeader(). Int_t TTreeCacheUnzip::GetRecordHeader ; (; char * ; buf, . Int_t ; maxbytes, . Int_t & ; nbytes, . Int_t & ; objlen, . Int_t & ; keylen . ). Read the logical record header from the buffer buf. ; That must be the pointer tho the header part not the object by itself and must contain data of at least maxbytes Returns nread;; In output arguments:. nbytes : number of bytes in record if negative, this is a deleted record if 0, cannot read record, wrong value of argument first; objlen : uncompressed object size; keylen : length of logical record header. Note that the arguments objlen and keylen are returned only if maxbytes >=16 Note: This was adapted from TFile... so some things dont apply ; Definition at line 470 of file TTreeCacheUnzip.cxx. ◆ GetUnzipBuffer(). Int_t TTreeCacheUnzip::GetUnzipBuffer ; (; char ** ; buf, . Long64_t ; pos, . Int_t ; len, . bool * ; free . ). overridevirtual . We try to read a buffer that has already been unzipped Returns -1 in case of read failure, 0 in case it's not in the cache and n>0 in case read from cache (number of bytes copied). ; pos and len are the original values as were passed to ReadBuffer but instead we will return the inflated buffer. Note!! : If *buf == 0 we will allocate the buffer and it will be the responsibility of the caller to free it... it is useful for example to pass it to the creator of TBuffer ; Reimplemented from TFileCacheRead.; Definition at line 669 of file TTreeCacheUnzip.cxx. ◆ GetUnzipGroupSize(). Int_t TTreeCacheUnzip::GetUnzipGroupSize ; (; ). inline . Definition at line 142 of file TTreeCacheUnzip.h. ◆ Init(). void TTree",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeCacheUnzip.html:30439,adapt,adapted,30439,doc/master/classTTreeCacheUnzip.html,https://root.cern,https://root.cern/doc/master/classTTreeCacheUnzip.html,1,['adapt'],['adapted']
Energy Efficiency,"actions to be executed to write the data to the basket.Definition TBranchElement.h:100; TBranchElement::Printvoid Print(Option_t *option="""") const overridePrint TBranch parameters.Definition TBranchElement.cxx:3836; TBranchElement::GetIDInt_t GetID() constDefinition TBranchElement.h:195; TBranchElement::GetClassNameconst char * GetClassName() const overrideReturn the name of the user class whose content is stored in this branch, if any.Definition TBranchElement.h:186; TBranchElement::GetInfoTStreamerInfo * GetInfo() constGet streamer info for the branch class.Definition TBranchElement.cxx:1024; TBranchElement::ReadLeavesCollectionvoid ReadLeavesCollection(TBuffer &b)Read leaves into i/o buffers for this branch.Definition TBranchElement.cxx:4267; TBranchElement::SetupAddressesvoid SetupAddresses() overrideIf the branch address is not set, we set all addresses starting with the top level parent branch.Definition TBranchElement.cxx:5892; TBranchElement::ResetAddressvoid ResetAddress() overrideSet branch address to zero and free all allocated memory.Definition TBranchElement.cxx:4780; TBranchElement::SetTypevirtual void SetType(Int_t btype)Definition TBranchElement.h:234; TBranchElement::FillLeavesMembervoid FillLeavesMember(TBuffer &b)Write leaves into i/o buffers for this branch.Definition TBranchElement.cxx:1734; TBranchElement::SetBranchCountvoid SetBranchCount(TBranchElement *bre)Set the branch counter for this branch.Definition TBranchElement.cxx:5529; TBranchElement::SwitchContainerstatic void SwitchContainer(TObjArray *)Modify the container type of the branches.Definition TBranchElement.cxx:85; TBranchElement::SetReadActionSequencevoid SetReadActionSequence()Set the sequence of actions needed to read the data out of the buffer.Definition TBranchElement.cxx:5663; TBranchElement::IsMissingCollectionbool IsMissingCollection() constDetect a collection written using a zero pointer in old versions of root.Definition TBranchElement.cxx:3776; TBranchElement::FillImplInt_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBranchElement_8cxx_source.html:255939,allocate,allocated,255939,doc/master/TBranchElement_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html,1,['allocate'],['allocated']
Energy Efficiency,"ac{E^2 p_{\perp}^2 }{ |p|^2 } } X sign(E) \f]. { return fCoordinates.Et(); }. Scalar Phi() const. azimuthal Angle. { return fCoordinates.Phi();}. Scalar Theta() const. polar Angle. { return fCoordinates.Theta(); }. Scalar Eta() const. pseudorapidity; \f[ \eta = - \ln { \tan { \frac { \theta} {2} } } \f]. { return fCoordinates.Eta(); }. return operator*(const ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<Double32_t> >::Scalar& a) const; LorentzVector<CoordinateType> v(*this);; v.Negate();. Scalar Rapidity() const; ---- Relativistic Properties ----. Rapidity relative to the Z axis: .5 log [(E+Pz)/(E-Pz)]. Scalar ColinearRapidity() const. Rapidity in the direction of travel: atanh (|P|/E)=.5 log[(E+P)/(E-P)]. bool isTimelike() const. Determine if momentum-energy can represent a physical massive particle. bool isLightlike(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<Double32_t> >::Scalar tolerance = 100*std::numeric_limits<Scalar>::epsilon()) const. Determine if momentum-energy can represent a massless particle. bool isSpacelike() const. Determine if momentum-energy is spacelike, and represents a tachyon. BetaVector BoostToCM() const. The beta vector for the boost that would bring this vector into; its center of mass frame (zero momentum). return - Vect() const; TODO - should attempt to Throw with msg about; boostVector computed for LorentzVector with t=0. Scalar Beta() const; beta and gamma. Return beta scalar value. Scalar Gamma() const. Return Gamma scalar value. Scalar x() const; Method providing limited backward name compatibility with CLHEP ----. { return fCoordinates.Px(); }. Scalar y() const; { return fCoordinates.Py(); }. Scalar z() const; { return fCoordinates.Pz(); }. Scalar t() const; { return fCoordinates.E(); }. Scalar px() const; { return fCoordinates.Px(); }. Scalar py() const; { return fCoordinates.Py(); }. Scalar pz() const; { return fCoordinates.Pz(); }. Scalar e() const; { return fCoordinates.E(); }. Scalar theta() const; { return fCoordinat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__LorentzVector_-p1PtEtaPhiE4D_Double32_t___.html:16046,energy,energy,16046,root/html526/ROOT__Math__LorentzVector_-p1PtEtaPhiE4D_Double32_t___.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__LorentzVector_-p1PtEtaPhiE4D_Double32_t___.html,1,['energy'],['energy']
Energy Efficiency,"ac{E^2 p_{\perp}^2 }{ |p|^2 } } X sign(E) \f]. { return fCoordinates.Et(); }. Scalar Phi() const. azimuthal Angle. { return fCoordinates.Phi();}. Scalar Theta() const. polar Angle. { return fCoordinates.Theta(); }. Scalar Eta() const. pseudorapidity; \f[ \eta = - \ln { \tan { \frac { \theta} {2} } } \f]. { return fCoordinates.Eta(); }. return operator*(const ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<Double32_t> >::Scalar& a) const; LorentzVector<CoordinateType> v(*this);; v.Negate();. Scalar Rapidity() const; ---- Relativistic Properties ----. Rapidity relative to the Z axis: .5 log [(E+Pz)/(E-Pz)]. Scalar ColinearRapidity() const. Rapidity in the direction of travel: atanh (|P|/E)=.5 log[(E+P)/(E-P)]. bool isTimelike() const. Determine if momentum-energy can represent a physical massive particle. bool isLightlike(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<Double32_t> >::Scalar tolerance = 100*std::numeric_limits<Scalar>::epsilon()) const. Determine if momentum-energy can represent a massless particle. bool isSpacelike() const. Determine if momentum-energy is spacelike, and represents a tachyon. BetaVector BoostToCM() const. The beta vector for the boost that would bring this vector into; its center of mass frame (zero momentum). return - Vect() const; TODO - should attempt to Throw with msg about; boostVector computed for LorentzVector with t=0. Scalar Beta() const; beta and gamma. Return beta scalar value. Scalar Gamma() const. Return Gamma scalar value. Scalar x() const; Method providing limited backward name compatibility with CLHEP ----. { return fCoordinates.Px(); }. Scalar y() const; { return fCoordinates.Py(); }. Scalar z() const; { return fCoordinates.Pz(); }. Scalar t() const; { return fCoordinates.E(); }. Scalar px() const; { return fCoordinates.Px(); }. Scalar py() const; { return fCoordinates.Py(); }. Scalar pz() const; { return fCoordinates.Pz(); }. Scalar e() const; { return fCoordinates.E(); }. Scalar theta() const; { return fCoordinat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__LorentzVector_-p1PtEtaPhiM4D_Double32_t___.html:16046,energy,energy,16046,root/html526/ROOT__Math__LorentzVector_-p1PtEtaPhiM4D_Double32_t___.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__LorentzVector_-p1PtEtaPhiM4D_Double32_t___.html,1,['energy'],['energy']
Energy Efficiency,"ad branches from an input stream. ;  ; void RecursiveRemove (TObject *obj) override;  Make sure that obj (which is being deleted or will soon be) is no longer referenced by this TTree. ;  ; virtual void RegisterExternalFriend (TFriendElement *);  Record a TFriendElement that we need to warn when the chain switches to a new file (typically this is because this chain is a friend of another TChain) ;  ; virtual void RemoveExternalFriend (TFriendElement *);  Removes external friend. ;  ; virtual void RemoveFriend (TTree *);  Remove a friend from the list of friends. ;  ; virtual void Reset (Option_t *option="""");  Reset baskets, buffers and entries count in all branches and leaves. ;  ; virtual void ResetAfterMerge (TFileMergeInfo *);  Resets the state of this TTree after a merge (keep the customization but forget the data). ;  ; virtual void ResetBranchAddress (TBranch *);  Tell all of our branches to set their addresses to zero. ;  ; virtual void ResetBranchAddresses ();  Tell all of our branches to drop their current objects and allocate new ones. ;  ; virtual Long64_t Scan (const char *varexp="""", const char *selection="""", Option_t *option="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0);  Loop over tree entries and print entries passing selection. ;  ; virtual bool SetAlias (const char *aliasName, const char *aliasFormula);  Set a tree variable alias. ;  ; virtual void SetAutoFlush (Long64_t autof=-30000000);  This function may be called at the start of a program to change the default value for fAutoFlush. ;  ; virtual void SetAutoSave (Long64_t autos=-300000000);  In case of a program crash, it will be possible to recover the data in the tree up to the last AutoSave point. ;  ; virtual void SetBasketSize (const char *bname, Int_t buffsize=16000);  Set a branch's basket size. ;  ; template<class T > ; Int_t SetBranchAddress (const char *bname, T **add, TBranch **ptr=nullptr);  ; template<class T > ; Int_t SetBranchAddress (const char *bname, T *add, TBranch ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeSQL.html:18405,allocate,allocate,18405,doc/master/classTTreeSQL.html,https://root.cern,https://root.cern/doc/master/classTTreeSQL.html,1,['allocate'],['allocate']
Energy Efficiency,"ading back the truncated x, say xt.; The variance of (x-xt)/x will be better than when specifying a range; for the same number of bits. However the precision relative to the; range (x-xt)/(xmax-xmin) will be worst, and vice-versa.; The format [0,0,8] is also interesting when the range of x is infinite; or unknown. --NOTE 2; It is important to understand the difference with the meaning of nbits; -in case of [-1,1,nbits], nbits is the total number of bits used to make; the conversion from a double to an integer; -in case of [0,0,nbits], nbits is the number of bits used for the mantissa. see example of use of the Double32_t data type in tutorial double32.C. /*; ; */. Int_t ReadArray(Bool_t *&b); Read array of bools from the I/O buffer. Returns the number of; bools read. If argument is a 0 pointer then space will be; allocated for the array. Int_t ReadArray(Char_t *&c); Read array of characters from the I/O buffer. Returns the number of; characters read. If argument is a 0 pointer then space will be; allocated for the array. Int_t ReadArray(Short_t *&h); Read array of shorts from the I/O buffer. Returns the number of shorts; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Int_t *&ii); Read array of ints from the I/O buffer. Returns the number of ints; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Long_t *&ll); Read array of longs from the I/O buffer. Returns the number of longs; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Long64_t *&ll); Read array of long longs from the I/O buffer. Returns the number of; long longs read. If argument is a 0 pointer then space will be; allocated for the array. Int_t ReadArray(Float_t *&f); Read array of floats from the I/O buffer. Returns the number of floats; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Double_t *&d); Read array of doubles from th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TBufferFile.html:25664,allocate,allocated,25664,root/html526/TBufferFile.html,https://root.cern,https://root.cern/root/html526/TBufferFile.html,1,['allocate'],['allocated']
Energy Efficiency,"ading back the truncated x, say xt.; The variance of (x-xt)/x will be better than when specifying a range; for the same number of bits. However the precision relative to the; range (x-xt)/(xmax-xmin) will be worst, and vice-versa.; The format [0,0,8] is also interesting when the range of x is infinite; or unknown. --NOTE 2; It is important to understand the difference with the meaning of nbits; -in case of [-1,1,nbits], nbits is the total number of bits used to make; the conversion from a double to an integer; -in case of [0,0,nbits], nbits is the number of bits used for the mantissa. see example of use of the Double32_t data type in tutorial double32.C. /*; ; */. Int_t ReadArray(Bool_t*& b); Read array of bools from the I/O buffer. Returns the number of; bools read. If argument is a 0 pointer then space will be; allocated for the array. Int_t ReadArray(Char_t*& c); Read array of characters from the I/O buffer. Returns the number of; characters read. If argument is a 0 pointer then space will be; allocated for the array. Int_t ReadArray(Short_t*& h); Read array of shorts from the I/O buffer. Returns the number of shorts; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Int_t*& i); Read array of ints from the I/O buffer. Returns the number of ints; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Long_t*& l); Read array of longs from the I/O buffer. Returns the number of longs; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Long64_t*& l); Read array of long longs from the I/O buffer. Returns the number of; long longs read. If argument is a 0 pointer then space will be; allocated for the array. Int_t ReadArray(Float_t*& f); Read array of floats from the I/O buffer. Returns the number of floats; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Double_t*& d); Read array of doubles from the I",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TBufferFile.html:26961,allocate,allocated,26961,root/html528/TBufferFile.html,https://root.cern,https://root.cern/root/html528/TBufferFile.html,6,['allocate'],['allocated']
Energy Efficiency,"afterwards with Derivator::SetFunction. explicit Derivator(const IGenFunction &f). Construct using a ROOT::Math::IGenFunction interface. explicit Derivator(const ROOT::Math::Derivator::GSLFuncPointer& f, void* p = 0). Construct using a GSL function pointer type; @param f : free function pointer of the GSL required type; @param p : pointer to the object carrying the function state; (for example the function object itself). virtual ~Derivator(); destructor. Derivator(const Derivator &); disable copying. void SetFunction(const ROOT::Math::IGenFunction& f). Template methods for generic functions; Set the function f for evaluating the derivative.; The function type must implement the assigment operator,; <em> double operator() ( double x ) </em>. SetFunction(const ROOT::Math::Derivator::GSLFuncPointer& f, void* p = 0). double Eval(double x, double h = 1.0E-8) const. Computes the numerical derivative of a function f at a point x.; It uses Derivator::EvalCentral to compute the derivative using an; adaptive central difference algorithm with a step size h. double EvalCentral(double x, double h = 1.0E-8) const. Computes the numerical derivative at a point x using an adaptive central; difference algorithm with a step size h. double EvalForward(double x, double h = 1.0E-8) const. Computes the numerical derivative at a point x using an adaptive forward; difference algorithm with a step size h.; The function is evaluated only at points greater than x and at x itself. double EvalBackward(double x, double h = 1.0E-8) const. Computes the numerical derivative at a point x using an adaptive backward; difference algorithm with a step size h.; The function is evaluated only at points less than x and at x itself. double Eval(const ROOT::Math::IGenFunction& f, double x, double h = 1.0E-8); @name --- Static methods ---; This methods don't require to use a Derivator object, and are designed to be used in; fast calculation. Error and status code cannot be retrieved in this case. Computes the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__Derivator.html:3305,adapt,adaptive,3305,root/html602/ROOT__Math__Derivator.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__Derivator.html,2,['adapt'],['adaptive']
Energy Efficiency,"ain window with menubar and drawing area; TRootContextMenu ROOT native GUI context sensitive popup menu; TRootControlBar ROOT native GUI implementation of TControlBar; TRootDialog Native GUI method argument prompt dialog box; TRootEmbeddedCanvas A ROOT TCanvas that can be embedded in a TGFrame; TRootGuiBuilder ROOT GUI Builder; TRootGuiFactory Factory for ROOT GUI components; TRootHelpDialog Dialog to display help text; TRootIOCtor ; TRootSecContext Class providing host specific authentication information; TRotMatrix Rotation Matrix for 3-D geometry objects; TRotation Rotations of TVector3 objects; TSAXParser SAX Parser; TSPHE SPHE shape; TSPlot class to disentangle signal from background; TSQLClassColumnInfo Keeps information about single column in class table; TSQLClassInfo Keeps the table information relevant for one class ; TSQLColumnData Single SQL column data.; TSQLColumnInfo Summury information about column from SQL table; TSQLFile ROOT TFile interface to SQL database; TSQLMonitoringWriter Sending monitoring data to a SQL DB; TSQLObjectData Keeps the data requested from the SQL server for an object.; TSQLObjectDataPool XML object keeper class ; TSQLObjectInfo Info (classname, version) about object in database ; TSQLResult SQL query result; TSQLRow One row of an SQL query result; TSQLServer Connection to SQL server; TSQLStatement SQL statement; TSQLStructure Table/structure description used internally by YBufferSQL.; TSQLTableData Collection of columns data for single SQL table; TSQLTableInfo Summury information about SQL table; TSVDUnfold Data unfolding using Singular Value Decomposition (hep-ph/9509307) ; TSVG SVG driver; TSecContext Class providing host specific authentication information; TSecContextCleanup Update the remote authentication table; TSelector A utility class for tree and object processing; TSelectorCint A utility class for tree and object processing (interpreted version); TSelectorDraw A specialized TSelector for TTree::Draw; TSelectorEntries ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ClassIndex.html:122720,monitor,monitoring,122720,root/html530/ClassIndex.html,https://root.cern,https://root.cern/root/html530/ClassIndex.html,1,['monitor'],['monitoring']
Energy Efficiency,"ainCyclevirtual void startTrainCycle()Definition NeuralNet.h:782; TMVA::DNN::Settings::convergenceStepssize_t convergenceSteps() consthow many steps until training is deemed to have convergedDefinition NeuralNet.h:766; TMVA::DNN::Settings::factorWeightDecaydouble factorWeightDecay() constget the weight-decay factorDefinition NeuralNet.h:769; TMVA::DNN::Settings::maxConvergenceCountsize_t maxConvergenceCount() constreturns the max convergence count so farDefinition NeuralNet.h:828; TMVA::DNN::Settings::padsvoid pads(int numPads)preparation for monitoringDefinition NeuralNet.h:818; TMVA::DNN::Settings::batchSizesize_t batchSize() constmini-batch sizeDefinition NeuralNet.h:767; TMVA::DNN::Settings::computeResultvirtual void computeResult(const Net &, std::vector< double > &)callback for monitoring and loggingDefinition NeuralNet.h:809; TMVA::DNN::Settings::dropRepetitionssize_t dropRepetitions() constDefinition NeuralNet.h:761; TMVA::DNN::Settings::createvoid create(std::string histoName, int bins, double min, double max)for monitoringDefinition NeuralNet.h:819; TMVA::DNN::Settings::startTestCyclevirtual void startTestCycle()callback for monitoring and logggingDefinition NeuralNet.h:804; TMVA::DNN::Steepest::m_repetitionssize_t m_repetitionsDefinition NeuralNet.h:337; TMVA::DNN::Steepest::m_betadouble m_betainternal parameter (momentum)Definition NeuralNet.h:372; TMVA::DNN::Steepest::m_localGradientsstd::vector< double > m_localGradientslocal gradients for reuse in thread.Definition NeuralNet.h:376; TMVA::DNN::Steepest::m_prevGradientsstd::vector< double > m_prevGradientsvector remembers the gradients of the previous stepDefinition NeuralNet.h:373; TMVA::DNN::Steepest::m_alphadouble m_alphainternal parameter (learningRate)Definition NeuralNet.h:371; TMVA::DNN::Steepest::m_localWeightsstd::vector< double > m_localWeightslocal weights for reuse in thread.Definition NeuralNet.h:375; TMVA::DNN::Steepest::operator()double operator()(Function &fitnessFunction, Weights &weight",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/NeuralNet_8icc_source.html:69606,monitor,monitoringDefinition,69606,doc/master/NeuralNet_8icc_source.html,https://root.cern,https://root.cern/doc/master/NeuralNet_8icc_source.html,1,['monitor'],['monitoringDefinition']
Energy Efficiency,"ainers or lists of other objects). ;  ; virtual Double_t MakeChi2 (const Double_t *coeff=nullptr);  Calculate Chi square over either the test sample. ;  ; virtual void MakeCode (const char *functionName=""MDF"", Option_t *option="""");  Generate the file <filename> with .C appended if argument doesn't end in .cxx or .C. ;  ; virtual void MakeHistograms (Option_t *option=""A"");  Make histograms of the result of the analysis. ;  ; virtual void MakeMethod (const Char_t *className=""MDF"", Option_t *option="""");  Generate the file <classname>MDF.cxx which contains the implementation of the method: ;  ; void Print (Option_t *option=""ps"") const override;  Print statistics etc. ;  ; void SetBinVarX (Int_t nbbinvarx);  ; void SetBinVarY (Int_t nbbinvary);  ; void SetMaxAngle (Double_t angle=0);  Set the max angle (in degrees) between the initial data vector to be fitted, and the new candidate function to be included in the fit. ;  ; void SetMaxFunctions (Int_t n);  ; void SetMaxPowers (const Int_t *powers);  Set the maximum power to be considered in the fit for each variable. ;  ; void SetMaxStudy (Int_t n);  ; void SetMaxTerms (Int_t terms);  ; void SetMinAngle (Double_t angle=1);  Set the min angle (in degrees) between a new candidate function and the subspace spanned by the previously accepted functions. ;  ; void SetMinRelativeError (Double_t error);  Set the acceptable relative error for when sum of square residuals is considered minimized. ;  ; void SetPowerLimit (Double_t limit=1e-3);  Set the user parameter for the function selection. ;  ; virtual void SetPowers (const Int_t *powers, Int_t terms);  Define a user function. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMultiDimFit.html:23074,power,powers,23074,doc/master/classTMultiDimFit.html,https://root.cern,https://root.cern/doc/master/classTMultiDimFit.html,2,['power'],"['power', 'powers']"
Energy Efficiency,"air<Double_t,Double_t> > vec, const Double_t quantile, const Double_t SumOfWeights = 0.0); calculates the quantile of the distribution of the first pair entries weighted with the values in the second pair entries. Double_t GradBoost(vector<TMVA::Event*> , TMVA::DecisionTree* dt, UInt_t cls = 0); Calculate the desired response value for each region. Double_t GradBoostRegression(vector<TMVA::Event*> , TMVA::DecisionTree* dt); Implementation of M_TreeBoost using a Huber loss function as desribed by Friedman 1999. void InitGradBoost(vector<TMVA::Event*> ); initialize targets for first tree. Double_t TestTreeQuality(TMVA::DecisionTree* dt); test the tree quality.. in terms of Miscalssification. Double_t Boost(vector<TMVA::Event*> , TMVA::DecisionTree* dt, Int_t iTree, UInt_t cls = 0); apply the boosting alogrithim (the algorithm is selecte via the the ""option"" given; in the constructor. The return value is the boosting weight. void BoostMonitor(Int_t iTree); fills the ROCIntegral vs Itree from the testSample for the monitoring plots; during the training .. but using the testing events. Double_t AdaBoost(vector<TMVA::Event*> , TMVA::DecisionTree* dt); the AdaBoost implementation.; a new training sample is generated by weighting; events that are misclassified by the decision tree. The weight; applied is w = (1-err)/err or more general:; w = ((1-err)/err)^beta; where err is the fraction of misclassified events in the tree ( <0.5 assuming; demanding the that previous selection was better than random guessing); and ""beta"" being a free parameter (standard: beta = 1) that modifies the; boosting. Double_t Bagging(vector<TMVA::Event*> , Int_t iTree); call it boot-strapping, re-sampling or whatever you like, in the end it is nothing; else but applying ""random"" weights to each event. Double_t RegBoost(vector<TMVA::Event*> , TMVA::DecisionTree* dt); a special boosting only for Regression ...; maybe I'll implement it later... Double_t AdaBoostR2(vector<TMVA::Event*> , TMVA::DecisionTr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__MethodBDT.html:31163,monitor,monitoring,31163,root/html530/TMVA__MethodBDT.html,https://root.cern,https://root.cern/root/html530/TMVA__MethodBDT.html,2,['monitor'],['monitoring']
Energy Efficiency,"aks; amplitudes, input parameters��������� ; ����� AmpXY[i] = 0;; �� }; �� //filling in the initial; estimates of the input parameters; �� TSpectrumFit2 *pfit=new; TSpectrumFit2(nfound);; ��; pfit->SetFitParameters(xmin, xmax-1, ymin, ymax-1, 1000, 0.1,; pfit->kFitOptimChiCounts, pfit->kFitAlphaHalving, pfit->kFitPower2,; pfit->kFitTaylorOrderFirst);�� ; ��; pfit->SetPeakParameters(2, kFALSE, 2, kFALSE, 0, kTRUE, PosX, (Bool_t *); FixPosX, PosY, (Bool_t *) FixPosY, PosX, (Bool_t *) FixPosX, PosY, (Bool_t *); FixPosY, Amp, (Bool_t *) FixAmp, AmpXY, (Bool_t *) FixAmp, AmpXY, (Bool_t *); FixAmp);����� ; ��; pfit->SetBackgroundParameters(0, kFALSE, 0, kTRUE, 0, kTRUE);�� ; ��; pfit->FitStiefel(source);; ��� for (i = 0; i <; nbinsx; i++){; ���� for (j = 0; j <; nbinsy; j++){; ���� ���������� ��search->SetBinContent(i; + 1, j + 1,source[i][j]);; �� ������������ �}; �� }�� ; ��; search->Draw(""SURF"");; }. void SetFitParameters(Int_t xmin, Int_t xmax, Int_t ymin, Int_t ymax, Int_t numberIterations, Double_t alpha, Int_t statisticType, Int_t alphaOptim, Int_t power, Int_t fitTaylor). SETTER FUNCTION. This function sets the following fitting parameters:; -xmin, xmax, ymin, ymax - fitting region; -numberIterations - # of desired iterations in the fit; -alpha - convergence coefficient, it should be positive number and <=1, for details see references; -statisticType - type of statistics, possible values kFitOptimChiCounts (chi square statistics with counts as weighting coefficients), kFitOptimChiFuncValues (chi square statistics with function values as weighting coefficients),kFitOptimMaxLikelihood; -alphaOptim - optimization of convergence algorithm, possible values kFitAlphaHalving, kFitAlphaOptimal; -power - possible values kFitPower2,4,6,8,10,12, for details see references. It applies only for Awmi fitting function.; -fitTaylor - order of Taylor expansion, possible values kFitTaylorOrderFirst, kFitTaylorOrderSecond. It applies only for Awmi fitting function. void SetPeakParam",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSpectrum2Fit.html:63042,power,power,63042,root/html528/TSpectrum2Fit.html,https://root.cern,https://root.cern/root/html528/TSpectrum2Fit.html,6,['power'],['power']
Energy Efficiency,"al (M ) and external (user) parameters. External parameters can be specified as std::vector\(<\)double\(>\) or as MnUserParameters. The return value is always a MnUserParameterState.; The optional argument \(\mbox{maxcalls}\) specifies the (approximate) maximum number of function calls after which the calculation will be stopped.; 5.5 MnMachinePrecision; [api:epsmac]; 5.5.1 MnMachinePrecision(); M determines the nominal precision itself in the default constructor MnMachinePrecision().; 5.5.2 setPrecision(double eps); Informs M that the relative floating point arithmetic precision is \(\mbox{eps}\). The method can be used to override M ’s own determination, when the user knows that the \(\mbox{FCN}\) function value is not calculated to the nominal machine accuracy. Typical values of \(\mbox{eps}\) are between \(10^{-5}\) and \(10^{-14}\).; 5.6 MnMigrad and VariableMetricMinimizer; [api:migrad]; MnMigrad provides minimization of the function by the method of \(\mbox{MIGRAD}\), the most efficient and complete single method, recommended for general functions (see also [api:minimize]), and the functionality for parameters interaction. It also retains the result from the last minimization in case the user may want to do subsequent minimization steps with parameter interactions in between the minimization requests. The minimization is done by the VariableMetricMinimizer. Minimization of the function can be done by directly using the VariableMetricMinimizer if no parameters interaction is required. The minimization produces as a by-product the error matrix of the parameters, which is usually reliable unless warning messages are produced.; 5.6.1 MnMigrad(const FCNBase&, const std::vector\(<\)double\(>\)&, const std::vector\(<\)double\(>\)&, unsigned int); Constructor for the minimal required interface: \(\mbox{FCN}\) and starting values for parameters and uncertainties. Optional the strategy level in MnStrategy can be specified.; 5.6.2 MnMigrad(const FCNBase&, const MnUserPa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/minuit2/Minuit2.html:47059,efficient,efficient,47059,root/html534/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/html534/guides/minuit2/Minuit2.html,2,['efficient'],['efficient']
Energy Efficiency,"al . Definition at line 49 of file TXTRU.h. ◆ GetXvtx(). virtual Float_t * TXTRU::GetXvtx ; (; ); const. inlinevirtual . Definition at line 45 of file TXTRU.h. ◆ GetY0(). virtual Float_t * TXTRU::GetY0 ; (; ); const. inlinevirtual . Definition at line 50 of file TXTRU.h. ◆ GetYvtx(). virtual Float_t * TXTRU::GetYvtx ; (; ); const. inlinevirtual . Definition at line 46 of file TXTRU.h. ◆ GetZ(). virtual Float_t * TXTRU::GetZ ; (; ); const. inlinevirtual . Definition at line 47 of file TXTRU.h. ◆ IsA(). TClass * TXTRU::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TShape.; Definition at line 92 of file TXTRU.h. ◆ operator=(). TXTRU & TXTRU::operator= ; (; const TXTRU & ; rhs). Deep assignment operator. ; Definition at line 166 of file TXTRU.cxx. ◆ Print(). void TXTRU::Print ; (; Option_t * ; option = """"); const. overridevirtual . Dump the info of this TXTRU shape Option: . ""xy"" to get x-y information; ""z"" to get z information; ""alloc"" to show full allocated arrays (not just used values) . Reimplemented from TNamed.; Definition at line 394 of file TXTRU.cxx. ◆ SetPoints(). void TXTRU::SetPoints ; (; Double_t * ; points); const. overrideprotectedvirtual . Create TXTRU points in buffer order as expected by other methods (counterclockwise xy, increasing z) ; Reimplemented from TShape.; Definition at line 469 of file TXTRU.cxx. ◆ Sizeof3D(). void TXTRU::Sizeof3D ; (; ); const. overridevirtual . Return total X3D needed by TNode::ls (when called with option ""x"") ; Reimplemented from TAtt3D.; Definition at line 505 of file TXTRU.cxx. ◆ SplitConcavePolygon(). void TXTRU::SplitConcavePolygon ; (; Bool_t ; split = kTRUE). (Dis)Enable the splitting of concave polygon outlines into multiple convex polygons. ; This would make for better rendering in solid mode, but introduces extra, potentially confusing, lines in wireframe mode.; *** Not yet implemented *** ; Definition at line 520 of file TXTRU.cxx. ◆ Streamer(). void TXTR",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTXTRU.html:27692,allocate,allocated,27692,doc/master/classTXTRU.html,https://root.cern,https://root.cern/doc/master/classTXTRU.html,1,['allocate'],['allocated']
Energy Efficiency,"al . Remove a friend from the list of friends. ; Reimplemented in TChain.; Definition at line 7977 of file TTree.cxx. ◆ Reset(). void TTree::Reset ; (; Option_t * ; option = """"). virtual . Reset baskets, buffers and entries count in all branches and leaves. ; Reimplemented in TChain.; Definition at line 8003 of file TTree.cxx. ◆ ResetAfterMerge(). void TTree::ResetAfterMerge ; (; TFileMergeInfo * ; info). virtual . Resets the state of this TTree after a merge (keep the customization but forget the data). ; Reimplemented in TChain.; Definition at line 8034 of file TTree.cxx. ◆ ResetBranchAddress(). void TTree::ResetBranchAddress ; (; TBranch * ; br). virtual . Tell all of our branches to set their addresses to zero. ; Note: If any of our branches own any objects, they are deleted. ; Reimplemented in TChain, TNtuple, and TNtupleD.; Definition at line 8065 of file TTree.cxx. ◆ ResetBranchAddresses(). void TTree::ResetBranchAddresses ; (; ). virtual . Tell all of our branches to drop their current objects and allocate new ones. ; Reimplemented in TChain, TNtuple, and TNtupleD.; Definition at line 8075 of file TTree.cxx. ◆ Scan(). Long64_t TTree::Scan ; (; const char * ; varexp = """", . const char * ; selection = """", . Option_t * ; option = """", . Long64_t ; nentries = kMaxEntries, . Long64_t ; firstentry = 0 . ). virtual . Loop over tree entries and print entries passing selection. . If varexp is 0 (or """") then print only first 8 columns.; If varexp = ""*"" print all columns. Otherwise a columns selection can be made using ""var1:var2:var3"". See alsoTTreePlayer::Scan for more information ; Reimplemented in TChain.; Definition at line 8094 of file TTree.cxx. ◆ SetAlias(). bool TTree::SetAlias ; (; const char * ; aliasName, . const char * ; aliasFormula . ). virtual . Set a tree variable alias. ; Set an alias for an expression/formula based on the tree 'variables'.; The content of 'aliasName' can be used in TTreeFormula (i.e. TTree::Draw, TTree::Scan, TTreeViewer) and will be ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTree.html:197456,allocate,allocate,197456,doc/v632/classTTree.html,https://root.cern,https://root.cern/doc/v632/classTTree.html,1,['allocate'],['allocate']
Energy Efficiency,"al . Remove a friend from the list of friends. ; Reimplemented in TChain.; Definition at line 7977 of file TTree.cxx. ◆ Reset(). void TTree::Reset ; (; Option_t * ; option = """"). virtual . Reset baskets, buffers and entries count in all branches and leaves. ; Reimplemented in TChain.; Definition at line 8003 of file TTree.cxx. ◆ ResetAfterMerge(). void TTree::ResetAfterMerge ; (; TFileMergeInfo * ; info). virtual . Resets the state of this TTree after a merge (keep the customization but forget the data). ; Reimplemented in TChain.; Definition at line 8034 of file TTree.cxx. ◆ ResetBranchAddress(). void TTree::ResetBranchAddress ; (; TBranch * ; br). virtual . Tell all of our branches to set their addresses to zero. ; Note: If any of our branches own any objects, they are deleted. ; Reimplemented in TChain, TNtuple, and TNtupleD.; Definition at line 8065 of file TTree.cxx. ◆ ResetBranchAddresses(). void TTree::ResetBranchAddresses ; (; ). virtual . Tell all of our branches to drop their current objects and allocate new ones. ; Reimplemented in TChain, TNtuple, and TNtupleD.; Definition at line 8075 of file TTree.cxx. ◆ Scan(). Long64_t TTree::Scan ; (; const char * ; varexp = """", . const char * ; selection = """", . Option_t * ; option = """", . Long64_t ; nentries = kMaxEntries, . Long64_t ; firstentry = 0 . ). virtual . Loop over tree entries and print entries passing selection. ; Interactive pagination break is on by default. If varexp is 0 (or """") then print only first 8 columns.; If varexp = ""*"" print all columns. Otherwise a columns selection can be made using ""var1:var2:var3"".; Parameters. firstentryfirst entry to scan ; nentriestotal number of entries to scan (starting from firstentry). Defaults to all entries. . See alsoTTree::SetScanField to control how many lines are printed between pagination breaks (Use 0 to disable pagination) . TTreePlayer::Scan for more information ; Reimplemented in TChain.; Definition at line 8099 of file TTree.cxx. ◆ SetAlias(). bool T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTree.html:199644,allocate,allocate,199644,doc/master/classTTree.html,https://root.cern,https://root.cern/doc/master/classTTree.html,1,['allocate'],['allocate']
Energy Efficiency,"al and background for each variable ; Definition at line 128 of file BinarySearchTree.h. ◆ Mean(). Float_t TMVA::BinarySearchTree::Mean ; (; Types::ESBType ; sb, . UInt_t ; var . ). inline . access to mean for signal and background for each variable ; Definition at line 119 of file BinarySearchTree.h. ◆ Min(). Float_t TMVA::BinarySearchTree::Min ; (; Types::ESBType ; sb, . UInt_t ; var . ). inline . access to Minimum for signal and background for each variable ; Definition at line 125 of file BinarySearchTree.h. ◆ NormalizeTree() [1/2]. void TMVA::BinarySearchTree::NormalizeTree ; (; ). Normalisation of tree. ; Definition at line 343 of file BinarySearchTree.cxx. ◆ NormalizeTree() [2/2]. void TMVA::BinarySearchTree::NormalizeTree ; (; std::vector< std::pair< Double_t, const TMVA::Event * > >::iterator ; leftBound, . std::vector< std::pair< Double_t, const TMVA::Event * > >::iterator ; rightBound, . UInt_t ; actDim . ). private . normalises the binary-search tree to reduce the branch length and hence speed up the search procedure (on average). ; Definition at line 286 of file BinarySearchTree.cxx. ◆ RMS() [1/2]. Float_t TMVA::BinarySearchTree::RMS ; (; Types::ESBType ; sb, . UInt_t ; var . ). inline . access to RMS for signal and background for each variable ; Definition at line 122 of file BinarySearchTree.h. ◆ RMS() [2/2]. Float_t TMVA::BinarySearchTree::RMS ; (; UInt_t ; var). inline . access to RMS for each variable ; Definition at line 133 of file BinarySearchTree.h. ◆ Search() [1/2]. TMVA::BinarySearchTreeNode * TMVA::BinarySearchTree::Search ; (; Event * ; event, . Node * ; node . ); const. private . Private, recursive, function for searching. ; Definition at line 201 of file BinarySearchTree.cxx. ◆ Search() [2/2]. TMVA::BinarySearchTreeNode * TMVA::BinarySearchTree::Search ; (; Event * ; event); const. search the tree to find the node matching ""event"" ; Definition at line 193 of file BinarySearchTree.cxx. ◆ SearchVolume() [1/2]. Double_t TMVA::BinarySearchTre",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1BinarySearchTree.html:13414,reduce,reduce,13414,doc/master/classTMVA_1_1BinarySearchTree.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1BinarySearchTree.html,1,['reduce'],['reduce']
Energy Efficiency,"al array of integer ideices.; Int_tTEvePointSet::fIntIdsPerPointNumber of integer indices assigned to each point.; TEveElement::sLTI_tTEveElement::fItems! Set of list-tree-items.; Int_tTPolyMarker3D::fLastPointThe index of the last filled point; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Color_t*TEveElement::fMainColorPtrPointer to main-color variable.; TEveTrans*TEveElement::fMainTransPointer to main transformation matrix.; Char_tTEveElement::fMainTransparencyMain-transparency variable.; TEveProjectionManager*TEveProjected::fManagermanager; Color_tTAttMarker::fMarkerColorMarker color index; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; Int_tTPolyMarker3D::fNNumber of allocated points; TStringTPolyMarker3D::fNameName of polymarker; Int_tTEveElement::fNumChildren!; TStringTPolyMarker3D::fOptionOptions; Bool_tTPointSet3D::fOwnIdsFlag specifying id-objects are owned by the point-set; Float_t*TPolyMarker3D::fP[3*fN] Array of X,Y,Z coordinates; Int_tTEveElement::fParentIgnoreCnt! Counter for parents that are ignored in ref-counting.; TEveElement::List_tTEveElement::fParentsList of parents.; Bool_tTEveElement::fPickable; TEveProjectable*TEveProjected::fProjectablelink to original object; TEveProjectable::ProjList_tTEveProjectable::fProjectedListreferences to projected instances.; Bool_tTEveElement::fRnrChildrenRender children of this element.; Bool_tTEveLine::fRnrLine; Bool_tTEveLine::fRnrPoints; Bool_tTEveElement::fRnrSelfRender this element.; Bool_tTEveElement::fSelected!; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Bool_tTEveLine::fSmooth; TRefTEveElement::fSourceExternal object that is represented by this element.; TEvePointSelectorConsumer::ETreeVarType_eTEvePointSelectorConsumer::fSourceCSCo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEveLineProjected.html:27752,allocate,allocated,27752,root/html602/TEveLineProjected.html,https://root.cern,https://root.cern/root/html602/TEveLineProjected.html,2,['allocate'],['allocated']
Energy Efficiency,"al data structure see convention for numbering bins in TH1::GetBin. ;  ; virtual void SavePrimitiveHelp (std::ostream &out, const char *hname, Option_t *option="""");  Helper function for the SavePrimitive functions from TH1 or classes derived from TH1, eg TProfile, TProfile2D. ;  ; virtual void UpdateBinContent (Int_t bin, Double_t content);  Raw update of bin content on internal data structure see convention for numbering bins in TH1::GetBin. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Static Protected Member Functions; static TH1D * DoProject1D (const TH3 &h, const char *name, const char *title, const TAxis *projX, bool computeErrors, bool originalRange, bool useUF, bool useOF);  static methdod performing the projection to 1D histogram ;  ; static TH2D * DoProject2D (const TH3 &h, const char *name, const char *title, const TAxis *projX, const TAxis *projY, bool computeErrors, bool originalRange, bool useUF, bool useOF);  static methdod performing the projection to 2D histogram ;  ;  Static Protected Member Functions inherited from TH1; static Int_t AutoP2GetBins (Int_t n);  Auxiliary function to get the next power of 2 integer value larger then n. ;  ; static Double_t AutoP2GetPower2 (Double_t x, Bool_t next=kTRUE);  Auxiliary function to get the power of 2 next (larger) or previous (smaller) a given x. ;  ; static bool CheckAxisLimits (const TAxis *a1, const TAxis *a2);  Check that the axis limits of the histograms are the same. ;  ; static bool CheckBinLabels (const TAxis *a1, const TAxis *a2);  Check that axis have same labels. ;  ; static bool CheckBinLimits (const TAxis *a1, const TAxis *a2);  Check bin limits. ;  ; static int CheckConsistency (const TH1 *h1, const TH1 *h2);  Check histogram compatibility. ;  ; static bool CheckConsistentSubAxes (const TAxis *a1, Int_t firstBin1, Int_t lastB",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH3.html:52554,power,power,52554,doc/master/classTH3.html,https://root.cern,https://root.cern/doc/master/classTH3.html,1,['power'],['power']
Energy Efficiency,"al number of bins including under/overflow Reallocate bin contents array.Definition TH1.cxx:9763; TH1S::~TH1S~TH1S() overrideDestructor.Definition TH1.cxx:9707; TH1S::AddBinContentvoid AddBinContent(Int_t bin) overrideIncrement bin content by 1.Definition TH1.cxx:9724; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TH1::~TH1~TH1() overrideHistogram default destructor.Definition TH1.cxx:643; TH1::SetErrorvirtual void SetError(const Double_t *error)Replace bin errors by values in array error.Definition TH1.cxx:8951; TH1::SetDirectoryvirtual void SetDirectory(TDirectory *dir)By default, when a histogram is created, it is added to the list of histogram objects in the current ...Definition TH1.cxx:8937; TH1::FitPanelvirtual void FitPanel()Display a panel with all histogram fit options.Definition TH1.cxx:4284; TH1::fBufferDouble_t * fBuffer[fBufferSize] entry bufferDefinition TH1.h:108; TH1::AutoP2FindLimitsvirtual Int_t AutoP2FindLimits(Double_t min, Double_t max)Buffer-based estimate of the histogram range using the power of 2 algorithm.Definition TH1.cxx:1343; TH1::GetEffectiveEntriesvirtual Double_t GetEffectiveEntries() constNumber of effective entries of the histogram.Definition TH1.cxx:4448; TH1::GetObjectInfochar * GetObjectInfo(Int_t px, Int_t py) const overrideRedefines TObject::GetObjectInfo.Definition TH1.cxx:4502; TH1::Smoothvirtual void Smooth(Int_t ntimes=1, Option_t *option="""")Smooth bin contents of this histogram.Definition TH1.cxx:6879; TH1::GetBinCentervirtual Double_t GetBinCenter(Int_t bin) constReturn bin center for 1D histogram.Definition TH1.cxx:9141; TH1::Rebuildvirtual void Rebuild(Option_t *option="""")Using the current bin info, recompute the arrays for contents and errors.Definition TH1.cxx:7087; TH1::SetBarOffsetvirtual void SetBarOffset(Float_t offset=0.25)Set the bar offset as fraction of the bin width for drawing mode ""B"".Definition TH1.h:364; TH1::fgStatOverflowsstatic Bool_t fgStatOverflows! Flag to use unde",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:433229,power,power,433229,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,1,['power'],['power']
Energy Efficiency,"al void setProgressLimits(double minProgress=0, double maxProgress=100)Definition NeuralNet.h:790; TMVA::DNN::Settings::m_maxProgressdouble m_maxProgresscurrent limits for the progress barDefinition NeuralNet.h:834; TMVA::DNN::Settings::endTrainCyclevirtual void endTrainCycle(double)callback for monitoring and loggingDefinition NeuralNet.h:788; TMVA::DNN::Settings::count_dEsize_t count_dEDefinition NeuralNet.h:843; TMVA::DNN::Settings::drawSamplevirtual void drawSample(const std::vector< double > &, const std::vector< double > &, const std::vector< double > &, double)callback for monitoring and loggingDefinition NeuralNet.h:807; TMVA::DNN::Settings::learningRatedouble learningRate() constget the learning rateDefinition NeuralNet.h:771; TMVA::DNN::Settings::m_dropRepetitionsdouble m_dropRepetitionsDefinition NeuralNet.h:849; TMVA::DNN::Settings::dropFractionsconst std::vector< double > & dropFractions() constDefinition NeuralNet.h:762; TMVA::DNN::Settings::addPointvoid addPoint(std::string histoName, double x)for monitoringDefinition NeuralNet.h:821; TMVA::DNN::Settings::~Settingsvirtual ~Settings()d'torDefinition NeuralNet.cxx:261; TMVA::DNN::Settings::m_convergenceCountsize_t m_convergenceCountDefinition NeuralNet.h:857; TMVA::DNN::Settings::m_regularizationEnumRegularization m_regularizationDefinition NeuralNet.h:847; TMVA::DNN::Settings::repetitionsint repetitions() consthow many steps have to be gone until the batch is changedDefinition NeuralNet.h:773; TMVA::DNN::Settings::m_minErrordouble m_minErrorDefinition NeuralNet.h:859; TMVA::DNN::Settings::testSamplevirtual void testSample(double, double, double, double)virtual function to be used for monitoring (callback)Definition NeuralNet.h:781; TMVA::DNN::Settings::plotvoid plot(std::string histoName, std::string options, int pad, EColor color)for monitoringDefinition NeuralNet.h:823; TMVA::DNN::Settings::startTrainCyclevirtual void startTrainCycle()Definition NeuralNet.h:782; TMVA::DNN::Settings::convergenceStepssi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/NeuralNet_8h_source.html:74963,monitor,monitoringDefinition,74963,doc/master/NeuralNet_8h_source.html,https://root.cern,https://root.cern/doc/master/NeuralNet_8h_source.html,1,['monitor'],['monitoringDefinition']
Energy Efficiency,"al"", 0.8, 0.0, 1.0); sig = ROOT.RooAddPdf(""sig"", ""Signal"", [sig1, sig2], [sig1frac]); ; # Sum the composite signal and background; bkgfrac = ROOT.RooRealVar(""bkgfrac"", ""fraction of background"", 0.5, 0.0, 1.0); model = ROOT.RooAddPdf(""model"", ""g1+g2+a"", [bkg, sig], [bkgfrac]); ; # Create biuned dataset; # -----------------------------------------; ; d = model.generate({x}, 10000); dh = d.binnedClone(); ; # Construct a chi^2 of the data and the model.; # When a p.d.f. is used in a chi^2 fit, probability density scaled; # by the number of events in the dataset to obtain the fit function; # If model is an extended p.d.f, expected number events is used; # instead of the observed number of events.; ll = ROOT.RooLinkedList(); model.chi2FitTo(dh, ll); ; # NB: It is also possible to fit a ROOT.RooAbsReal function to a ROOT.RooDataHist; # using chi2FitTo().; ; # Note that entries with zero bins are _not_ allowed; # for a proper chi^2 calculation and will give error; # messages; dsmall = d.reduce(ROOT.RooFit.EventRange(1, 100)); dhsmall = dsmall.binnedClone(); chi2_lowstat = model.createChi2(dhsmall); print(chi2_lowstat.getVal()); [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- The following expressions have been identified as constant and will be precalculated and cached: (sig1,sig2); [#1] INFO:Minimization -- The following expressions will be evaluated in cache-and-track mode: (bkg); Minuit2Minimizer: Minimize with max-calls 2000 convergence for edm < 1 strategy 1; Minuit2Minimizer : Valid minimum - status = 0; FVAL = 104.639633447510988; Edm = 0.000778057047730882148; Nfcn =",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf602__chi2fit_8py.html:2244,reduce,reduce,2244,doc/master/rf602__chi2fit_8py.html,https://root.cern,https://root.cern/doc/master/rf602__chi2fit_8py.html,1,['reduce'],['reduce']
Energy Efficiency,"al, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti); Progress signal. void Progress(TProofProgressInfo* pi); Progress signal. void Feedback(TList* objs); Feedback signal. void StopProcess(Bool_t abort, Int_t timeout = -1); Stop process after this event. Int_t AddOutputObject(TObject* obj); Incorporate the received object 'obj' into the output list fOutput.; The latter is created if not existing.; This method short cuts 'StoreOutput + MergeOutput' optimizing the memory; consumption.; Returns -1 in case of error, 1 if the object has been merged into another; one (so that its ownership has not been taken and can be deleted), and 0; otherwise. void RedirectOutput(Bool_t on = kTRUE); Control output redirection to TProof::fLogFileW. void AddOutput(TList* out); Incorporate the content of the received output list 'out' into the final; output list fOutput. The latter is created if not existing.; This method short cuts 'StoreOutput + MergeOutput' limiting the memory; consumption. void NotifyMemory(TObject* obj); Printout the memory record after merging object 'obj'; This record is used by the memory monitor. void SetLastMergingMsg(TObject* obj); Set the message to be notified in case of exception. Int_t Incorporate(TObject* obj, TList* out, Bool_t& merged); Incorporate object 'newobj' in the list 'outlist'.; The object is merged with an object of the same name already existing in; the list, or just added.; The boolean merged is set to kFALSE when the object is just added to 'outlist';; this happens if the Merge() method does not exist or if a object named as 'obj'; is not already in the list. If the obj is not 'merged' than it should not be; deleted, unless outlist is not owner of its objects.; Return 0 on success, -1 on error. TObject * HandleHistogram(TObject* obj); Low statistic histograms need a special treatment when using autobin. Bool_t HistoSameAxis(TH1* h0, TH1* h1); Return kTRUE is the histograms 'h0' and 'h",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TProofPlayerRemote.html:18024,consumption,consumption,18024,root/html530/TProofPlayerRemote.html,https://root.cern,https://root.cern/root/html530/TProofPlayerRemote.html,1,['consumption'],['consumption']
Energy Efficiency,"al, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti); Progress signal. void Progress(TProofProgressInfo* pi); Progress signal. void Feedback(TList* objs); Feedback signal. void StopProcess(Bool_t abort, Int_t timeout = -1); Stop process after this event. Int_t AddOutputObject(TObject* obj); Incorporate the received object 'obj' into the output list fOutput.; The latter is created if not existing.; This method short cuts 'StoreOutput + MergeOutput' optimizing the memory; consumption.; Returns -1 in case of error, 1 if the object has been merged into another; one (so that its ownership has not been taken and can be deleted), and 0; otherwise. void RedirectOutput(Bool_t on = kTRUE); Control output redirection to TProof::fLogFileW. void AddOutput(TList* out); Incorporate the content of the received output list 'out' into the final; output list fOutput. The latter is created if not existing.; This method short cuts 'StoreOutput + MergeOutput' limiting the memory; consumption. void NotifyMemory(TObject* obj); Printout the memory record after merging object 'obj'; This record is used by the memory monitor. void SetLastMergingMsg(TObject* obj); Set the message to be notified in case of exception. Int_t Incorporate(TObject* obj, TList* out, Bool_t& merged); Incorporate object 'newobj' in the list 'outlist'.; The object is merged with an object of the same name already existing in; the list, or just added.; The boolean merged is set to kFALSE when the object is just added to 'outlist';; this happens if the Merge() method does not exist or if a object named as 'obj'; is not already in the list. If the obj is not 'merged' than it should not be; deleted, unless outlist is not owner of its objects.; Return 0 on success, -1 on error. TObject * HandleHistogram(TObject* obj); Low statistic histograms need a special treatment when using autobin. void StoreOutput(TList* out); Store received output list. TList * MergeFeedback();",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofPlayerRemote.html:17796,consumption,consumption,17796,root/html528/TProofPlayerRemote.html,https://root.cern,https://root.cern/root/html528/TProofPlayerRemote.html,1,['consumption'],['consumption']
Energy Efficiency,"al, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti); Progress signal. void Progress(TProofProgressInfo* pi); Progress signal. void Feedback(TList* objs); Feedback signal. void StopProcess(Bool_t abort, Int_t timeout = -1); Stop process after this event. Int_t AddOutputObject(TObject* obj); Incorporate the received object 'obj' into the output list fOutput.; The latter is created if not existing.; This method short cuts 'StoreOutput + MergeOutput' optimizing the memory; consumption.; Returns -1 in case of error, 1 if the object has been merged into another; one (so that its ownership has not been taken and can be deleted), and 0; otherwise. void RedirectOutput(Bool_t on = kTRUE); Control output redirection to TProof::fLogFileW. void AddOutput(TList* out); Incorporate the content of the received output list 'out' into the final; output list fOutput. The latter is created if not existing.; This method short cuts 'StoreOutput + MergeOutput' limiting the memory; consumption. void NotifyMemory(TObject* obj); Printout the memory record after merging object 'obj'; This record is used by the memory monitor. void SetLastMergingMsg(TObject* obj); Set the message to be notified in case of exception. Int_t Incorporate(TObject* obj, TList* out, Bool_t& merged); Incorporate object 'newobj' in the list 'outlist'.; The object is merged with an object of the same name already existing in; the list, or just added.; The boolean merged is set to kFALSE when the object is just added to 'outlist';; this happens if the Merge() method does not exist or if a object named as 'obj'; is not already in the list. If the obj is not 'merged' than it should not be; deleted, unless outlist is not owner of its objects.; Return 0 on success, -1 on error. TObject * HandleHistogram(TObject* obj, Bool_t& merged); Low statistic histograms need a special treatment when using autobin. Bool_t HistoSameAxis(TH1* h0, TH1* h1); Return kTRUE is the histog",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TProofPlayerRemote.html:18040,consumption,consumption,18040,root/html532/TProofPlayerRemote.html,https://root.cern,https://root.cern/root/html532/TProofPlayerRemote.html,4,['consumption'],['consumption']
Energy Efficiency,"al, RooGamma, RooGaussian, RooGaussModel, RooGExpModel, RooJohnson, RooKeysPdf, RooLandau, RooLegacyExpPoly, RooLognormal, RooNDKeysPdf, RooNovosibirsk, RooParametricStepFunction, RooPoisson, RooPolynomial, RooPowerSum, RooUniform, RooConvCoefVar, RooEfficiency, RooHistFunc, RooHistPdf, RooMultiVarGaussian, RooPolyVar, RooTruthModel, RooLegendre, RooNonCentralChiSquare, RooSpHarmonic, RooAddition, RooBinSamplingPdf, RooWrapperPdf, and RooFixedProdPdf.; Definition at line 366 of file RooAbsReal.cxx. ◆ getAnalyticalIntegralWN(). Int_t RooAbsReal::getAnalyticalIntegralWN ; (; RooArgSet & ; allDeps, . RooArgSet & ; analDeps, . const RooArgSet * ; normSet, . const char * ; rangeName = nullptr . ); const. virtual . Variant of getAnalyticalIntegral that is also passed the normalization set that should be applied to the integrand of which the integral is requested. ; For certain operator p.d.f it is useful to overload this function rather than analyticalIntegralWN() as the additional normalization information may be useful in determining a more efficient decomposition of the requested integral. ; Reimplemented in RooNormalizedPdf, ParamHistFunc, PiecewiseInterpolation, RooParamHistFunc, RooAbsAnaConvPdf, RooAbsCachedPdf, RooAbsCachedReal, RooBinSamplingPdf, RooExtendPdf, RooProduct, RooProjectedPdf, RooWrapperPdf, RooFixedProdPdf, RooLagrangianMorphFunc, RooAddModel, RooAddPdf, RooProdPdf, RooRealSumFunc, RooRealSumPdf, and RooSimultaneous.; Definition at line 349 of file RooAbsReal.cxx. ◆ getForceNumInt(). bool RooAbsReal::getForceNumInt ; (; ); const. inline . Definition at line 174 of file RooAbsReal.h. ◆ getIntegratorConfig() [1/2]. RooNumIntConfig * RooAbsReal::getIntegratorConfig ; (; ). Return the numeric integration configuration used for this object. ; If a specialized configuration was associated with this object, that configuration is returned, otherwise the default configuration for all RooAbsReals is returned ; Definition at line 3404 of file RooAbsReal.cxx. ◆ ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAbsReal.html:110368,efficient,efficient,110368,doc/v632/classRooAbsReal.html,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html,1,['efficient'],['efficient']
Energy Efficiency,"al, RooGamma, RooGaussian, RooGaussModel, RooGExpModel, RooJohnson, RooKeysPdf, RooLandau, RooLegacyExpPoly, RooLognormal, RooNDKeysPdf, RooNovosibirsk, RooParametricStepFunction, RooPoisson, RooPolynomial, RooPowerSum, RooUniform, RooConvCoefVar, RooEfficiency, RooHistFunc, RooHistPdf, RooMultiVarGaussian, RooPolyVar, RooTruthModel, RooLegendre, RooNonCentralChiSquare, RooSpHarmonic, RooAddition, RooBinSamplingPdf, RooWrapperPdf, and RooFixedProdPdf.; Definition at line 368 of file RooAbsReal.cxx. ◆ getAnalyticalIntegralWN(). Int_t RooAbsReal::getAnalyticalIntegralWN ; (; RooArgSet & ; allDeps, . RooArgSet & ; analDeps, . const RooArgSet * ; normSet, . const char * ; rangeName = nullptr . ); const. virtual . Variant of getAnalyticalIntegral that is also passed the normalization set that should be applied to the integrand of which the integral is requested. ; For certain operator p.d.f it is useful to overload this function rather than analyticalIntegralWN() as the additional normalization information may be useful in determining a more efficient decomposition of the requested integral. ; Reimplemented in RooNormalizedPdf, ParamHistFunc, PiecewiseInterpolation, RooParamHistFunc, RooAbsAnaConvPdf, RooAbsCachedPdf, RooAbsCachedReal, RooBinSamplingPdf, RooExtendPdf, RooProduct, RooProjectedPdf, RooWrapperPdf, RooFixedProdPdf, RooLagrangianMorphFunc, RooAddModel, RooAddPdf, RooProdPdf, RooRealSumFunc, RooRealSumPdf, and RooSimultaneous.; Definition at line 351 of file RooAbsReal.cxx. ◆ getForceNumInt(). bool RooAbsReal::getForceNumInt ; (; ); const. inline . Definition at line 174 of file RooAbsReal.h. ◆ getIntegratorConfig() [1/2]. RooNumIntConfig * RooAbsReal::getIntegratorConfig ; (; ). Return the numeric integration configuration used for this object. ; If a specialized configuration was associated with this object, that configuration is returned, otherwise the default configuration for all RooAbsReals is returned ; Definition at line 3322 of file RooAbsReal.cxx. ◆ ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsReal.html:109109,efficient,efficient,109109,doc/master/classRooAbsReal.html,https://root.cern,https://root.cern/doc/master/classRooAbsReal.html,1,['efficient'],['efficient']
Energy Efficiency,"alGLProxy.cxx:51; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; destOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t destDefinition TGWin32VirtualXProxy.cxx:164; TClassRefTClassRef is used to implement a permanent reference to a TClass object.Definition TClassRef.h:28; TClassRef::GetClassTClass * GetClass() constDefinition TClassRef.h:66; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClass::NewArrayvoid * NewArray(Long_t nElements, ENewType defConstructor=kClassNew) constReturn a pointer to a newly allocated array of objects of this class.Definition TClass.cxx:5260; TClass::Newvoid * New(ENewType defConstructor=kClassNew, Bool_t quiet=kFALSE) constReturn a pointer to a newly allocated object of this class.Definition TClass.cxx:5045; TClass::Destructorvoid Destructor(void *obj, Bool_t dtorOnly=kFALSE)Explicitly call destructor for object.Definition TClass.cxx:5467; TClass::DeleteArrayvoid DeleteArray(void *ary, Bool_t dtorOnly=kFALSE)Explicitly call operator delete[] for an array.Definition TClass.cxx:5596; TClass::NewObjectArrayObjectPtr NewObjectArray(Long_t nElements, ENewType defConstructor=kClassNew) constReturn a pointer to a newly allocated array of objects of this class.Definition TClass.cxx:5276; TClass::NewObjectObjectPtr NewObject(ENewType defConstructor=kClassNew, Bool_t quiet=kFALSE) constDefinition TClass.cxx:5059; TStreamerInfoActions::TActionSequenceDefinition TStreamerInfoActions.h:177; TVirtualCollectionProxy::TPushPopRAII helper class that ensures that PushProxy() / PopProxy() are called when entering / leaving a C++...Definition TVirtualCollectionProxy.h:75; TVirtualCollectionProxy::TPushPop::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TVirtualCollectionProxy_8h_source.html:14671,allocate,allocated,14671,doc/master/TVirtualCollectionProxy_8h_source.html,https://root.cern,https://root.cern/doc/master/TVirtualCollectionProxy_8h_source.html,1,['allocate'],['allocated']
Energy Efficiency,"alReferenceCutOrientation (Double_t cutOrientation);  ; void SetSilentFile (Bool_t status);  ; void SetTestTime (Double_t testTime);  ; void SetTestvarName (const TString &v="""");  ; void SetTrainTime (Double_t trainTime);  ; void SetupMethod ();  setup of methods ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void TestClassification ();  initialization ;  ; virtual void TestMulticlass ();  test multiclass classification ;  ; virtual void TestRegression (Double_t &bias, Double_t &biasT, Double_t &dev, Double_t &devT, Double_t &rms, Double_t &rmsT, Double_t &mInf, Double_t &mInfT, Double_t &corr, Types::ETreeType type);  calculate <sum-of-deviation-squared> of regression output versus ""true"" value from test sample ;  ; bool TrainingEnded ();  ; void TrainMethod ();  ; virtual void WriteEvaluationHistosToFile (Types::ETreeType treetype);  writes all MVA evaluation histograms to file ;  ; virtual void WriteMonitoringHistosToFile () const;  write special monitoring histograms to file dummy implementation here --------------— ;  ; void WriteStateToFile () const;  write options and weights to file note that each one text file for the main configuration information and one ROOT file for ROOT objects are created ;  ;  Public Member Functions inherited from TMVA::IMethod;  IMethod ();  ; virtual ~IMethod ();  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TMVA::Configurable;  Configurable (const TString &theOption="""");  constructor ;  ; virtual ~Configurable ();  default destructor ;  ; void AddOptionsXMLTo (void *parent) const;  write options to XML file ;  ; template<class T > ; void AddPreDefVal (const T &);  ; template<class T > ; void AddPreDefVal (const TString &optname, const T &);  ; void CheckForUnusedOptions () const;  checks for unused options in option string ;  ; template<class T > ; TMVA::OptionBase * DeclareOptionRef (T &ref, const TString &name, const TString &desc);  ; t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodSVM.html:11788,monitor,monitoring,11788,doc/master/classTMVA_1_1MethodSVM.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodSVM.html,1,['monitor'],['monitoring']
Energy Efficiency,"alarType >::PtEtaPhiM4D ; (; const CoordSystem & ; c). inlineexplicitconstexpr . Generic constructor from any 4D coordinate system implementing Pt(), Eta(), Phi() and M() ; Definition at line 82 of file PtEtaPhiM4D.h. ◆ PtEtaPhiM4D() [4/4]. template<class ScalarType > . ROOT::Math::PtEtaPhiM4D< ScalarType >::PtEtaPhiM4D ; (; const PtEtaPhiM4D< ScalarType > & ; v). inline . copy constructor ; Definition at line 91 of file PtEtaPhiM4D.h. Member Function Documentation. ◆ E(). template<class ScalarType > . Scalar ROOT::Math::PtEtaPhiM4D< ScalarType >::E ; (; ); const. inline . Energy (timelike component of momentum-energy 4-vector) ; Definition at line 198 of file PtEtaPhiM4D.h. ◆ E2(). template<class ScalarType > . Scalar ROOT::Math::PtEtaPhiM4D< ScalarType >::E2 ; (; ); const. inline . energy squared ; Definition at line 189 of file PtEtaPhiM4D.h. ◆ Et(). template<class ScalarType > . Scalar ROOT::Math::PtEtaPhiM4D< ScalarType >::Et ; (; ); const. inline . transverse energy ; Definition at line 250 of file PtEtaPhiM4D.h. ◆ Et2(). template<class ScalarType > . Scalar ROOT::Math::PtEtaPhiM4D< ScalarType >::Et2 ; (; ); const. inline . transverse energy squared ; Definition at line 241 of file PtEtaPhiM4D.h. ◆ Eta(). template<class ScalarType > . Scalar ROOT::Math::PtEtaPhiM4D< ScalarType >::Eta ; (; ); const. inline . Definition at line 142 of file PtEtaPhiM4D.h. ◆ GetCoordinates() [1/2]. template<class ScalarType > . void ROOT::Math::PtEtaPhiM4D< ScalarType >::GetCoordinates ; (; Scalar & ; pt, . Scalar & ; eta, . Scalar & ; phi, . Scalar & ; mass . ); const. inline . get internal data into 4 Scalar numbers ; Definition at line 134 of file PtEtaPhiM4D.h. ◆ GetCoordinates() [2/2]. template<class ScalarType > . void ROOT::Math::PtEtaPhiM4D< ScalarType >::GetCoordinates ; (; Scalar ; dest[]); const. inline . get internal data into an array of 4 Scalar numbers ; Definition at line 118 of file PtEtaPhiM4D.h. ◆ M(). template<class ScalarType > . Scalar ROOT::Math::PtEtaPhiM4D",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1PtEtaPhiM4D.html:6339,energy,energy,6339,doc/master/classROOT_1_1Math_1_1PtEtaPhiM4D.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1PtEtaPhiM4D.html,1,['energy'],['energy']
Energy Efficiency,"alcAverageResponse() note that 0 offset is used ; Definition at line 1491 of file RuleFitParams.cxx. ◆ ErrorRateBin(). Double_t TMVA::RuleFitParams::ErrorRateBin ; (; ). protected . Estimates the error rate with the current set of parameters It uses a binary estimate of (y-F*(x)) (y-F*(x)) = (Num of events where sign(F)!=sign(y))/Neve y = {+1 if event is signal, -1 otherwise} — NOT USED —. ; Definition at line 1008 of file RuleFitParams.cxx. ◆ ErrorRateReg(). Double_t TMVA::RuleFitParams::ErrorRateReg ; (; ). protected . Estimates the error rate with the current set of parameters This code is pretty messy at the moment. ; Cleanup is needed. – NOT USED — ; Definition at line 964 of file RuleFitParams.cxx. ◆ ErrorRateRoc(). Double_t TMVA::RuleFitParams::ErrorRateRoc ; (; ). protected . Estimates the error rate with the current set of parameters. ; It calculates the area under the bkg rejection vs signal efficiency curve. The value returned is 1-area. This works but is less efficient than calculating the Risk using RiskPerf(). ; Definition at line 1107 of file RuleFitParams.cxx. ◆ ErrorRateRocRaw(). Double_t TMVA::RuleFitParams::ErrorRateRocRaw ; (; std::vector< Double_t > & ; sFsig, . std::vector< Double_t > & ; sFbkg . ). protected . Estimates the error rate with the current set of parameters. ; It calculates the area under the bkg rejection vs signal efficiency curve. The value returned is 1-area. ; Definition at line 1042 of file RuleFitParams.cxx. ◆ ErrorRateRocTst(). void TMVA::RuleFitParams::ErrorRateRocTst ; (; ). protected . Estimates the error rate with the current set of parameters. ; It calculates the area under the bkg rejection vs signal efficiency curve. The value returned is 1-area.; See comment under ErrorRateRoc(). ; Definition at line 1155 of file RuleFitParams.cxx. ◆ EvaluateAverage(). void TMVA::RuleFitParams::EvaluateAverage ; (; UInt_t ; ind1, . UInt_t ; ind2, . std::vector< Double_t > & ; avsel, . std::vector< Double_t > & ; avrul . ). protected ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1RuleFitParams.html:10678,efficient,efficient,10678,doc/master/classTMVA_1_1RuleFitParams.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1RuleFitParams.html,1,['efficient'],['efficient']
Energy Efficiency,"alculation ; Definition at line 154 of file Derivator.cxx. ◆ Eval() [1/5]. double ROOT::Math::Derivator::Eval ; (; const IGenFunction & ; f, . double ; x, . double ; h = 1E-8 . ). static . Computes the numerical derivative of a function f at a point x. ; It uses Derivator::EvalCentral to compute the derivative using an adaptive central difference algorithm with a step size h ; Definition at line 110 of file Derivator.cxx. ◆ Eval() [2/5]. double ROOT::Math::Derivator::Eval ; (; const IMultiGenFunction & ; f, . const double * ; x, . unsigned int ; icoord = 0, . double ; h = 1E-8 . ). static . Evaluate the partial derivative of a multi-dim function with respect coordinate x_icoord at the point x[]. ; Definition at line 126 of file Derivator.cxx. ◆ Eval() [3/5]. double ROOT::Math::Derivator::Eval ; (; double ; x, . double ; h = 1E-8 . ); const. Computes the numerical derivative of a function f at a point x. ; It uses Derivator::EvalCentral to compute the derivative using an adaptive central difference algorithm with a step size h ; Definition at line 93 of file Derivator.cxx. ◆ Eval() [4/5]. double ROOT::Math::Derivator::Eval ; (; IParamFunction & ; f, . double ; x, . const double * ; p, . unsigned int ; ipar = 0, . double ; h = 1E-8 . ). static . Evaluate the derivative with respect a parameter for one-dim parameteric function at the point ( x,p[]) with respect the parameter p_ipar. ; Definition at line 134 of file Derivator.cxx. ◆ Eval() [5/5]. double ROOT::Math::Derivator::Eval ; (; IParamMultiFunction & ; f, . const double * ; x, . const double * ; p, . unsigned int ; ipar = 0, . double ; h = 1E-8 . ). static . Evaluate the derivative with respect a parameter for a multi-dim parameteric function at the point ( x[],p[]) with respect the parameter p_ipar. ; Definition at line 143 of file Derivator.cxx. ◆ EvalBackward() [1/2]. double ROOT::Math::Derivator::EvalBackward ; (; const IGenFunction & ; f, . double ; x, . double ; h = 1E-8 . ). static . Computes the numerical",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1Derivator.html:6629,adapt,adaptive,6629,doc/master/classROOT_1_1Math_1_1Derivator.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1Derivator.html,1,['adapt'],['adaptive']
Energy Efficiency,"alculator& hc, RooRealVar* scannedVariable, double size = 0.05); RooStats::HypoTestInverterHypoTestInverter(RooAbsData& data, RooStats::ModelConfig& sb, RooStats::ModelConfig& b, RooRealVar* scannedVariable = 0, RooStats::HypoTestInverter::ECalculatorType type = kFrequentist, double size = 0.05); virtual TClass*IsA() const; RooStats::SamplingDistribution*RebuildDistributions(bool isUpper = true, int nToys = 100, TList* clsDist = 0, TList* clsbDist = 0, TList* clbDist = 0, const char* outputfile = ""HypoTestInverterRebuiltDist.root""); boolRunFixedScan(int nBins, double xMin, double xMax, bool scanLog = false) const; boolRunLimit(double& limit, double& limitErr, double absTol = 0, double relTol = 0, const double* hint = 0) const; boolRunOnePoint(double thisX, bool adaptive = false, double clTarget = -1) const; voidSetAutoScan(); static voidSetCloseProof(Bool_t flag); virtual voidSetConfidenceLevel(Double_t cl); virtual voidSetData(RooAbsData&); voidSetFixedScan(int nBins, double xMin = 1, double xMax = -1, bool scanLog = false); voidSetMaximumToys(int ntoys); virtual voidSetModel(const RooStats::ModelConfig&); voidSetNumErr(double err); virtual voidSetTestSize(Double_t size); boolSetTestStatistic(RooStats::TestStatistic& stat); voidSetVerbose(int level = 1); virtual voidShowMembers(TMemberInspector&); virtual Double_tSize() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidUseCLs(bool on = true). protected:. static voidCheckInputModels(const RooStats::HypoTestCalculatorGeneric& hc, const RooRealVar& scanVar); voidCreateResults() const; RooStats::HypoTestResult*Eval(RooStats::HypoTestCalculatorGeneric& hc, bool adaptive, double clsTarget) const; static RooRealVar*GetVariableToScan(const RooStats::HypoTestCalculatorGeneric& hc); RooStats::HypoTestInverterHypoTestInverter(const RooStats::HypoTestInverter& rhs); RooStats::HypoTestInverter&operator=(const RooStats::HypoTestInverter& rhs). Data Members; public:. enum ECalc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStats__HypoTestInverter.html:3313,adapt,adaptive,3313,root/html534/RooStats__HypoTestInverter.html,https://root.cern,https://root.cern/root/html534/RooStats__HypoTestInverter.html,1,['adapt'],['adaptive']
Energy Efficiency,"algorithm). GSLSimAnFunc(). derived classes might need to re-define completely the class. {}. virtual ~GSLSimAnFunc(); virtual distructor (no operations). { }. GSLSimAnFunc & FastCopy(const ROOT::Math::GSLSimAnFunc& f). fast copy method called by GSL simuated annealing internally; copy only the things which have been changed; must be re-implemented by derived classes if needed. GSLSimAnFunc * Clone() const. clone method. Needs to be re-implemented by the derived classes for deep copying. return new GSLSimAnFunc(const ROOT::Math::GSLSimAnFunc& ). double Energy() const. evaluate the energy ( objective function value); re-implement by derived classes if needed to be modified. void Step(const ROOT::Math::GSLRandomEngine& r, double maxstep). change the x[i] value using a random value urndm generated between [0,1]; up to a maximum value maxstep; re-implement by derived classes if needed to be modified. double Distance(const ROOT::Math::GSLSimAnFunc& func) const. calculate the distance (metric) between this one and another configuration; Presently a cartesian metric is used.; re-implement by derived classes if needed to be modified. void Print(). print the position in the standard output ostream; GSL prints in addition n iteration, n function calls, temperature and energy; re-implement by derived classes if necessary. void SetX(const double* x). change the x values (used by sim annealing to take a step). void SetX(unsigned int i, double x). unsigned int NDim() const; { return fX.size(); }. double X(unsigned int i) const; { return fX[i]; }. const std::vector<double> & X() const; { return fX; }. double Scale(unsigned int i) const; { return fScale[i]; }. » Author: L. Moneta Thu Jan 25 11:13:48 2007 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathmore:$Id$ » Last generated: 2015-09-08 16:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__GSLSimAnFunc.html:3526,energy,energy,3526,root/html534/ROOT__Math__GSLSimAnFunc.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLSimAnFunc.html,1,['energy'],['energy']
Energy Efficiency,"alidObject = (1ULL << ( 13 )). };  . Public Member Functions;  TMap (Int_t capacity=TCollection::kInitHashTableCapacity, Int_t rehash=0);  TMap ctor. See THashTable for a description of the arguments. ;  ; virtual ~TMap ();  TMap dtor. ;  ; void Add (TObject *key, TObject *value);  Add a (key,value) pair to the map. ;  ; void Add (TObject *obj) override;  This function may not be used (but we need to provide it since it is a pure virtual in TCollection). ;  ; Float_t AverageCollisions () const;  Return the ratio of entries vs occupied slots. ;  ; Int_t Capacity () const;  Return number of slots in the hashtable. ;  ; void Clear (Option_t *option="""") override;  Remove all (key,value) pairs from the map. ;  ; Int_t Collisions (const char *keyname) const;  Returns the number of collisions for a key with a certain name (i.e. ;  ; Int_t Collisions (TObject *key) const;  Returns the number of collisions for a key (i.e. ;  ; void Delete (Option_t *option="""") override;  Remove all (key,value) pairs from the map AND delete the keys when they are allocated on the heap. ;  ; void DeleteAll ();  Remove all (key,value) pairs from the map AND delete the keys AND values when they are allocated on the heap. ;  ; Bool_t DeleteEntry (TObject *key);  Remove (key,value) pair with key from the map. ;  ; void DeleteKeys ();  ; void DeleteValues ();  Remove all (key,value) pairs from the map AND delete the values when they are allocated on the heap. ;  ; TObject * FindObject (const char *keyname) const override;  Check if a (key,value) pair exists with keyname as name of the key. ;  ; TObject * FindObject (const TObject *key) const override;  Check if a (key,value) pair exists with key as key. ;  ; TObject ** GetObjectRef (const TObject *obj) const override;  ; const THashTable * GetTable () const;  ; TObject * GetValue (const char *keyname) const;  Returns a pointer to the value associated with keyname as name of the key. ;  ; TObject * GetValue (const TObject *key) const;  Returns a poin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMap.html:2595,allocate,allocated,2595,doc/master/classTMap.html,https://root.cern,https://root.cern/doc/master/classTMap.html,1,['allocate'],['allocated']
Energy Efficiency,"all nodes; 243 std::vector<RGeomNode> fDesc; ///<! converted description, send to client; 244 std::vector<RGeomNodeVisibility> fVisibility; ///<! custom visibility flags for physical nodes; 245 ; 246 TGeoVolume *fDrawVolume{nullptr};///<! select volume independent from TGeoManager; 247 std::vector<int> fSelectedStack; ///<! selected branch of geometry by stack; 248 ; 249 std::vector<int> fHighlightedStack; ///<! highlighted element by stack; 250 std::vector<int> fClickedStack; ///<! clicked element by stack; 251 ; 252 std::vector<int> fSortMap; ///<! nodes in order large -> smaller volume; 253 std::vector<ShapeDescr> fShapes; ///<! shapes with created descriptions; 254 ; 255 std::string fSearch; ///<! search string in hierarchy; 256 std::string fSearchJson; ///<! drawing json for search; 257 std::string fDrawJson; ///<! JSON with main nodes drawn by client; 258 int fDrawIdCut{0}; ///<! sortid used for selection of most-significant nodes; 259 int fActualLevel{0}; ///<! level can be reduced when selecting nodes; 260 bool fPreferredOffline{false}; ///<! indicates that full description should be provided to client; 261 int fJsonComp{0}; ///<! default JSON compression; 262 std::string fActiveItemName; ///<! name of item which should be activated in hierarchy; 263 ; 264 RGeomConfig fCfg; ///<! configuration parameter editable from GUI; 265 ; 266 TVirtualMutex *fMutex{nullptr}; ///<! external mutex used to protect all data; 267 ; 268 std::vector<std::pair<const void *, RGeomSignalFunc_t>> fSignals; ///<! registered signals; 269 ; 270 void PackMatrix(std::vector<float> &arr, TGeoMatrix *matr);; 271 ; 272 int MarkVisible(bool on_screen = false);; 273 ; 274 void ProduceIdShifts();; 275 ; 276 int ScanNodes(bool only_visible, int maxlvl, RGeomScanFunc_t func);; 277 ; 278 void ResetRndrInfos();; 279 ; 280 ShapeDescr &FindShapeDescr(TGeoShape *shape);; 281 ; 282 ShapeDescr &MakeShapeDescr(TGeoShape *shape);; 283 ; 284 int GetUsedNSegments(int min = 20);; 285 ; 286 int CountShapeF",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RGeomData_8hxx_source.html:9485,reduce,reduced,9485,doc/master/RGeomData_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RGeomData_8hxx_source.html,2,['reduce'],['reduced']
Energy Efficiency,"alling Sort() or for TSortedList); TObjLink*TList::fCache! cache to speedup sequential calling of Before() and After() functions; TObjLink*TList::fFirst! pointer to first entry in linked list; TObjLink*TList::fLast! pointer to last entry in linked list; TStringTCollection::fNamename of the collection; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted; THashTable*fTableHashtable used for quick lookup of objects; static TCollection::(anonymous)TCollection::kIsOwner. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THashList(Int_t capacity = TCollection::kInitHashTableCapacity, Int_t rehash = 0); Create a THashList object. Capacity is the initial hashtable capacity; (i.e. number of slots), by default kInitHashTableCapacity = 17, and; rehash is the value at which a rehash will be triggered. I.e. when the; average size of the linked lists at a slot becomes longer than rehash; then the hashtable will be resized and refilled to reduce the collision; rate to about 1. The higher the collision rate, i.e. the longer the; linked lists, the longer lookup will take. If rehash=0 the table will; NOT automatically be rehashed. Use Rehash() for manual rehashing.; WARNING !!!; If the name of an object in the HashList is modified, The hashlist; must be Rehashed. THashList(TObject* parent, Int_t capacity = TCollection::kInitHashTableCapacity, Int_t rehash = 0); For backward compatibility only. Use other ctor. ~THashList(); Delete a hashlist. Objects are not deleted unless the THashList is the; owner (set via SetOwner()). void AddFirst(TObject* obj); Add object at the beginning of the list. void AddFirst(TObject* obj, Option_t* opt); Add object at the beginning of the list and also store option.; Storing an option is useful when one wants to change the behaviour; of an object a little without having to create a complete new; copy of the object. This feature is used, for example",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/THashList.html:11671,reduce,reduce,11671,root/html602/THashList.html,https://root.cern,https://root.cern/root/html602/THashList.html,2,['reduce'],['reduce']
Energy Efficiency,"alling ~xxx; CallFunc_t*fFuncCINT method invocation environment; TFunction*fMetPtrpointer to the method or function info; TStringfMethodmethod name; Long_tfOffsetoffset added to object pointer before method invocation; TStringfParamsargument string; TStringfProtoprototype string; TMethodCall::EReturnTypefRetTypemethod return type. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMethodCall(); Default TMethodCall ctor. Use Init() to initialize the method call; environment. TMethodCall(TClass* cl, CallFunc_t* callfunc, Long_t offset = 0); Create a method invocation environment for a specific class, method; described by the callfunc. TMethodCall(TClass* cl, const char* method, const char* params); Create a method invocation environment for a specific class, method and; parameters. The parameter string has the form: ""\""aap\"", 3, 4.35"".; To execute the method call TMethodCall::Execute(object,...).; This two step method is much more efficient than calling for; every invocation TInterpreter::Execute(...). TMethodCall(const char* function, const char* params); Create a global function invocation environment. The parameter; string has the form: ""\""aap\"", 3, 4,35"". To execute the; function call TMethodCall::Execute(...).; This two step method is much more efficient than calling for; every invocation TInterpreter::Execute(...). TMethodCall(TFunction* func); Create a global function invocation environment base on a TFunction object.; To execute the function call TMethodCall::Execute(...).; This two step method is much more efficient than calling for; every invocation TInterpreter::Execute(...). TMethodCall(const TMethodCall& org); Copy ctor. TMethodCall & operator=(const TMethodCall& rhs); Assignement operator. ~TMethodCall(); TMethodCall dtor. TObject * Clone(const char* newname = """") const; Return an exact copy of this object. void Init(TClass* cl, CallFunc_t* func, Long_t offset = 0); Initialize the method invocation environment bas",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMethodCall.html:9095,efficient,efficient,9095,root/html602/TMethodCall.html,https://root.cern,https://root.cern/root/html602/TMethodCall.html,2,['efficient'],['efficient']
Energy Efficiency,"ally 'msg' to the appropriate units (file, stdout, window) If defined, 'sfx' is added after 'msg' (typically a line-feed);. ;  ; void operator= (const TProof &);  ; void ParseConfigField (const char *config);  The config file field may contain special instructions which need to be parsed at the beginning, e.g. ;  ; Int_t Ping (ESlaves list);  Ping PROOF slaves. Returns the number of slaves that responded. ;  ; void PrintProgress (Long64_t total, Long64_t processed, Float_t procTime=-1., Long64_t bytesread=-1);  Print a progress bar on stderr. Used in batch mode. ;  ; Bool_t Prompt (const char *p);  Prompt the question 'p' requiring an answer y,Y,n,N Return kTRUE is the answer was y or Y, kFALSE in all other cases. ;  ; void RecvLogFile (TSocket *s, Int_t size);  Receive the log file of the slave with socket s. ;  ; void RedirectWorker (TSocket *s, TSlave *sl, Int_t output_size);  Redirect output of worker sl to some merger. ;  ; void ReleaseMonitor (TMonitor *mon);  Release the used monitor to be used, making sure to delete newly created monitors. ;  ; void ResetMergePrg ();  Reset the merge progress notificator. ;  ; void ResetMergers ();  ; Int_t RestoreActiveList ();  Restore saved list of active workers. ;  ; void SaveActiveList ();  Save current list of active workers. ;  ; Int_t SendCommand (const char *cmd, ESlaves list=kActive);  Send command to be executed on the PROOF master and/or slaves. ;  ; Int_t SendCurrentState (ESlaves list=kActive);  Transfer the current state of the master to the active slave servers. ;  ; Int_t SendCurrentState (TList *list);  Transfer the current state of the master to the active slave servers. ;  ; Int_t SendGroupView ();  Send to all active slaves servers the current slave group size and their unique id. ;  ; Int_t SendInitialState ();  Transfer the initial (i.e. ;  ; Int_t SendObject (const TObject *obj, ESlaves list=kActive);  Send object to master or slave servers. ;  ; Int_t SendPrint (Option_t *option="""");  Send print com",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProof.html:52184,monitor,monitor,52184,doc/master/classTProof.html,https://root.cern,https://root.cern/doc/master/classTProof.html,2,['monitor'],"['monitor', 'monitors']"
Energy Efficiency,"already running. Int_t StopThreadUnzip(); To stop the thread we only need to change the value of the variable; fActiveThread to false and the loop will stop (of course, we will have); to do the cleaning after that.; Note: The syncronization part is important here or we will try to delete; teh object while it's still processing the queue. void* UnzipLoop(void* arg); This is a static function.; This is the call that will be executed in the Thread generated by; StartThreadTreeCacheUnzip... what we want to do is to inflate the next; series of buffers leaving them in the second cache.; Returns 0 when it finishes. Int_t GetRecordHeader(char* buf, Int_t maxbytes, Int_t& nbytes, Int_t& objlen, Int_t& keylen); Read the logical record header from the buffer buf.; That must be the pointer tho the header part not the object by itself and; must contain data of at least maxbytes; Returns nread;; In output arguments:; nbytes : number of bytes in record; if negative, this is a deleted record; if 0, cannot read record, wrong value of argument first; objlen : uncompressed object size; keylen : length of logical record header; Note that the arguments objlen and keylen are returned only; if maxbytes >=16; Note: This was adapted from TFile... so some things dont apply. void ResetCache(); This will delete the list of buffers that are in the unzipping cache; and will reset certain values in the cache.; This name is ambiguos because the method doesn't reset the whole cache,; only the part related to the unzipping; Note: This method is completely different from TTreeCache::ResetCache(),; in that method we were cleaning the prefetching buffer while here we; delete the information about the unzipped buffers. Int_t GetUnzipBuffer(char** buf, Long64_t pos, Int_t len, Bool_t* free); We try to read a buffer that has already been unzipped; Returns -1 in case of read failure, 0 in case it's not in the; cache and n>0 in case read from cache (number of bytes copied).; pos and len are the original valu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreeCacheUnzip.html:15956,adapt,adapted,15956,root/html528/TTreeCacheUnzip.html,https://root.cern,https://root.cern/root/html528/TTreeCacheUnzip.html,6,['adapt'],['adapted']
Energy Efficiency,"already"",name);; 1259 return nullptr;; 1260 }; 1261 }; 1262 TDirectoryFile *newdir = nullptr;; 1263 if (const char *slash = strchr(name,'/')) {; 1264 TString workname(name, Long_t(slash-name));; 1265 TDirectoryFile *tmpdir = nullptr;; 1266 GetObject(workname.Data(), tmpdir);; 1267 if (!tmpdir) {; 1268 tmpdir = (TDirectoryFile*)mkdir(workname.Data(),title);; 1269 if (!tmpdir) return nullptr;; 1270 }; 1271 if (!newdir) newdir = tmpdir;; 1272 tmpdir->mkdir(slash+1);; 1273 return newdir;; 1274 }; 1275 ; 1276 TDirectory::TContext ctxt(this);; 1277 ; 1278 newdir = new TDirectoryFile(name, title, """", this);; 1279 ; 1280 return newdir;; 1281}; 1282 ; 1283////////////////////////////////////////////////////////////////////////////////; 1284/// Purge lowest key cycles in a directory.; 1285///; 1286/// By default, only the highest cycle of a key is kept. Keys for which; 1287/// the ""KEEP"" flag has been set are not removed. See TKey::Keep().; 1288/// NOTE: This does not reduce the size of a TFile--; 1289/// the space is simply freed up to be overwritten.; 1290 ; 1291void TDirectoryFile::Purge(Short_t); 1292{; 1293 if (!IsWritable()) return;; 1294 ; 1295 TDirectory::TContext ctxt(this);; 1296 ; 1297 TKey *key;; 1298 TIter prev(GetListOfKeys(), kIterBackward);; 1299 ; 1300 while ((key = (TKey*)prev())) { // reverse loop on keys; 1301 TKey *keyprev = (TKey*)GetListOfKeys()->Before(key);; 1302 if (!keyprev) break;; 1303 if (key->GetKeep() == 0) {; 1304 if (strcmp(key->GetName(), keyprev->GetName()) == 0) {; 1305 key->Delete(); // Remove from the file.; 1306 delete key; // Remove from memory.; 1307 }; 1308 }; 1309 }; 1310 TFile *f = GetFile();; 1311 if (fModified && f) {; 1312 WriteKeys(); // Write new keys structure; 1313 WriteDirHeader(); // Write new directory header; 1314 f->WriteFree(); // Write new free segments list; 1315 f->WriteHeader(); // Write new file header; 1316 }; 1317}; 1318 ; 1319////////////////////////////////////////////////////////////////////////////////; 1320/",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TDirectoryFile_8cxx_source.html:43718,reduce,reduce,43718,doc/master/TDirectoryFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TDirectoryFile_8cxx_source.html,1,['reduce'],['reduce']
Energy Efficiency,"als;  ; Bool_t fSignalsBlocked;  list of connections to this object ;  ;  Static Protected Attributes inherited from TQObject; static Bool_t fgAllSignalsBlocked = kFALSE;  flag used for suppression of signals ;  . #include <TMonitor.h>. Inheritance diagram for TMonitor:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Enumeration Documentation. ◆ EInterest. enum TMonitor::EInterest. EnumeratorkRead ; kWrite . Definition at line 54 of file TMonitor.h. Constructor & Destructor Documentation. ◆ TMonitor() [1/2]. TMonitor::TMonitor ; (; Bool_t ; mainloop = kTRUE). Create a monitor object. ; If mainloop is true the monitoring will be done in the main event loop. ; Definition at line 109 of file TMonitor.cxx. ◆ TMonitor() [2/2]. TMonitor::TMonitor ; (; const TMonitor & ; m). Copy constructor. ; Definition at line 123 of file TMonitor.cxx. ◆ ~TMonitor(). TMonitor::~TMonitor ; (; ). virtual . Cleanup the monitor object. Does not delete sockets being monitored. ; Definition at line 153 of file TMonitor.cxx. Member Function Documentation. ◆ Activate(). void TMonitor::Activate ; (; TSocket * ; sock). virtual . Activate a de-activated socket. ; Definition at line 250 of file TMonitor.cxx. ◆ ActivateAll(). void TMonitor::ActivateAll ; (; ). virtual . Activate all de-activated sockets. ; Definition at line 268 of file TMonitor.cxx. ◆ Add(). void TMonitor::Add ; (; TSocket * ; sock, . Int_t ; interest = kRead . ). virtual . Add socket to the monitor's active list. ; If interest=kRead then we want to monitor the socket for read readiness, if interest=kWrite then we monitor the socket for write readiness, if interest=kRead|kWrite then we monitor both read and write readiness. ; Definition at line 168 of file TMonitor.cxx. ◆ Class(). static TClass * TMonitor::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TMonitor::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Ver",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMonitor.html:17264,monitor,monitored,17264,doc/master/classTMonitor.html,https://root.cern,https://root.cern/doc/master/classTMonitor.html,1,['monitor'],['monitored']
Energy Efficiency,"alse) const;  ; virtual Double_t RetrieveBinContent (Int_t bin) const;  Raw retrieval of bin content on internal data structure see convention for numbering bins in TH1::GetBin. ;  ; virtual void SavePrimitiveHelp (std::ostream &out, const char *hname, Option_t *option="""");  Helper function for the SavePrimitive functions from TH1 or classes derived from TH1, eg TProfile, TProfile2D. ;  ; virtual void UpdateBinContent (Int_t bin, Double_t content);  Raw update of bin content on internal data structure see convention for numbering bins in TH1::GetBin. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Static Protected Member Functions; static Int_t AutoP2GetBins (Int_t n);  Auxiliary function to get the next power of 2 integer value larger then n. ;  ; static Double_t AutoP2GetPower2 (Double_t x, Bool_t next=kTRUE);  Auxiliary function to get the power of 2 next (larger) or previous (smaller) a given x. ;  ; static bool CheckAxisLimits (const TAxis *a1, const TAxis *a2);  Check that the axis limits of the histograms are the same. ;  ; static bool CheckBinLabels (const TAxis *a1, const TAxis *a2);  Check that axis have same labels. ;  ; static bool CheckBinLimits (const TAxis *a1, const TAxis *a2);  Check bin limits. ;  ; static int CheckConsistency (const TH1 *h1, const TH1 *h2);  Check histogram compatibility. ;  ; static bool CheckConsistentSubAxes (const TAxis *a1, Int_t firstBin1, Int_t lastBin1, const TAxis *a2, Int_t firstBin2=0, Int_t lastBin2=0);  Check that two sub axis are the same. ;  ; static bool CheckEqualAxes (const TAxis *a1, const TAxis *a2);  Check that the axis are the same. ;  ; static Bool_t RecomputeAxisLimits (TAxis &destAxis, const TAxis &anAxis);  Finds new limits for the axis for the Merge function. ;  ; static Bool_t SameLimitsAndNBins (const TAxis &axis1, const TAxis &axis2);  S",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH1.html:66096,power,power,66096,doc/master/classTH1.html,https://root.cern,https://root.cern/doc/master/classTH1.html,1,['power'],['power']
Energy Efficiency,"alsh-Haar, Cosine-Walsh, Cosine-Haar, Sine-Walsh, Sine-Haar transforms; Int_tfDirectionforward or inverse transform; Double_tfEnhanceCoeffmultiplication coefficient applied in enhanced region;; Double_tfFilterCoeffvalue set in the filtered region; Int_tfSizeXx length of transformed data; Int_tfSizeYy length of transformed data; Int_tfTransformTypetype of transformation (Haar, Walsh, Cosine, Sine, Fourier, Hartley, Fourier-Walsh, Fourier-Haar, Walsh-Haar, Cosine-Walsh, Cosine-Haar, Sine-Walsh, Sine-Haar); Int_tfXmaxlast channel x of filtered or enhanced region; Int_tfXminfirst channel x of filtered or enhanced region; Int_tfYmaxlast channel y of filtered or enhanced region; Int_tfYminfirst channel y of filtered or enhanced region. Class Charts. Inheritance Chart:. TObject. ←; TSpectrum2Transform. Function documentation; TSpectrum2Transform(); default constructor. TSpectrum2Transform(Int_t sizeX, Int_t sizeY); the constructor creates TSpectrum2Transform object. Its sizes must be > than zero and must be power of 2.; It sets default transform type to be Cosine transform. Transform parameters can be changed using setter functions. ~TSpectrum2Transform(); destructor. void Haar(Double_t* working_space, Int_t num, Int_t direction). AUXILIARY FUNCION. This function calculates Haar transform of a part of data; Function parameters:; -working_space-pointer to vector of transformed data; -num-length of processed data; -direction-forward or inverse transform. void Walsh(Double_t* working_space, Int_t num). AUXILIARY FUNCION. This function calculates Walsh transform of a part of data; Function parameters:; -working_space-pointer to vector of transformed data; -num-length of processed data. void BitReverse(Double_t* working_space, Int_t num). AUXILIARY FUNCION. This function carries out bir-reverse reordering of data; Function parameters:; -working_space-pointer to vector of processed data; -num-length of processed data. void Fourier(Double_t* working_space, Int_t num, Int_t hartle",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSpectrum2Transform.html:9997,power,power,9997,root/html602/TSpectrum2Transform.html,https://root.cern,https://root.cern/root/html602/TSpectrum2Transform.html,2,['power'],['power']
Energy Efficiency,"alsh-Haar, Cosine-Walsh, Cosine-Haar, Sine-Walsh, Sine-Haar transforms; Int_tfDirectionforward or inverse transform; Float_tfEnhanceCoeffmultiplication coefficient applied in enhanced region;; Float_tfFilterCoeffvalue set in the filtered region; Int_tfSizeXx length of transformed data; Int_tfSizeYy length of transformed data ; Int_tfTransformTypetype of transformation (Haar, Walsh, Cosine, Sine, Fourier, Hartley, Fourier-Walsh, Fourier-Haar, Walsh-Haar, Cosine-Walsh, Cosine-Haar, Sine-Walsh, Sine-Haar); Int_tfXmaxlast channel x of filtered or enhanced region; Int_tfXminfirst channel x of filtered or enhanced region; Int_tfYmaxlast channel y of filtered or enhanced region ; Int_tfYminfirst channel y of filtered or enhanced region. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSpectrum2Transform(); default constructor. TSpectrum2Transform(Int_t sizeX, Int_t sizeY); the constructor creates TSpectrum2Transform object. Its sizes must be > than zero and must be power of 2.; It sets default transform type to be Cosine transform. Transform parameters can be changed using setter functions. ~TSpectrum2Transform(); destructor. void Haar(Float_t* working_space, Int_t num, Int_t direction). AUXILIARY FUNCION. This function calculates Haar transform of a part of data; Function parameters:; -working_space-pointer to vector of transformed data; -num-length of processed data; -direction-forward or inverse transform. void Walsh(Float_t* working_space, Int_t num). AUXILIARY FUNCION. This function calculates Walsh transform of a part of data; Function parameters:; -working_space-pointer to vector of transformed data; -num-length of processed data. void BitReverse(Float_t* working_space, Int_t num). AUXILIARY FUNCION. This function carries out bir-reverse reordering of data; Function parameters:; -working_space-pointer to vector of processed data; -num-length of processed data. void Fourier(Float_t* working_space, Int_t num, Int_t hartley, I",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSpectrum2Transform.html:8829,power,power,8829,root/html528/TSpectrum2Transform.html,https://root.cern,https://root.cern/root/html528/TSpectrum2Transform.html,4,['power'],['power']
Energy Efficiency,"alue = evaluate() ;; 322 ; 323 if (TMath::IsNaN(value)) {; 324 logEvalError(""function value is NAN"") ;; 325 }; 326 ; 327 //cxcoutD(Tracing) << ""RooAbsReal::getValF("" << GetName() << "") operMode = "" << _operMode << "" recalculated, new value = "" << value << std::endl ;; 328 ; 329 //Standard tracing code goes here; 330 if (!isValidReal(value)) {; 331 coutW(Tracing) << ""RooAbsReal::traceEval("" << GetName(); 332 << ""): validation failed: "" << value << std::endl ;; 333 }; 334 ; 335 //Call optional subclass tracing code; 336 // traceEvalHook(value) ;; 337 ; 338 return value ;; 339}; 340 ; 341 ; 342 ; 343////////////////////////////////////////////////////////////////////////////////; 344/// Variant of getAnalyticalIntegral that is also passed the normalization set; 345/// that should be applied to the integrand of which the integral is requested.; 346/// For certain operator p.d.f it is useful to overload this function rather; 347/// than analyticalIntegralWN() as the additional normalization information; 348/// may be useful in determining a more efficient decomposition of the; 349/// requested integral.; 350 ; 351Int_t RooAbsReal::getAnalyticalIntegralWN(RooArgSet& allDeps, RooArgSet& analDeps,; 352 const RooArgSet* /*normSet*/, const char* rangeName) const; 353{; 354 return _forceNumInt ? 0 : getAnalyticalIntegral(allDeps,analDeps,rangeName) ;; 355}; 356 ; 357 ; 358 ; 359////////////////////////////////////////////////////////////////////////////////; 360/// Interface function getAnalyticalIntergral advertises the; 361/// analytical integrals that are supported. 'integSet'; 362/// is the set of dependents for which integration is requested. The; 363/// function should copy the subset of dependents it can analytically; 364/// integrate to anaIntSet and return a unique identification code for; 365/// this integration configuration. If no integration can be; 366/// performed, zero should be returned.; 367 ; 368Int_t RooAbsReal::getAnalyticalIntegral(RooArgSet& /*integSet*/",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8cxx_source.html:11826,efficient,efficient,11826,doc/master/RooAbsReal_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html,1,['efficient'],['efficient']
Energy Efficiency,"alued object. More...;  ; class  RooConvCoefVar;  Auxiliary class that represents the coefficient of a RooAbsAnaConvPdf implementation as a separate RooAbsReal object to be able to interface these coefficient terms with the generic RooRealIntegral integration mechanism. More...;  ; class  RooConvGenContext;  Efficient implementation of the generator context specific for RooAbsAnaConvPdf objects. More...;  ; class  RooConvIntegrandBinding;  Implementation of RooAbsFunc that represent the integrand of a generic (numeric) convolution A (x) B so that it can be passed to a numeric integrator. More...;  ; class  RooCurve;  One-dimensional graphical representation of a real-valued function. More...;  ; class  RooDataHist;  Container class to hold N-dimensional binned data. More...;  ; class  RooDataHistSliceIter;  Iterates over all bins in a RooDataHist that occur in a slice defined by the bin coordinates of the input sliceSet. More...;  ; class  RooDataProjBinding;  adaptor that projects a real function via summation of states provided in a dataset. More...;  ; class  RooDataSet;  Container class to hold unbinned data. More...;  ; class  RooDerivative;  Represents the first, second, or third order derivative of any RooAbsReal as calculated (numerically) by the MathCore Richardson derivator class. More...;  ; class  RooDirItem;  Utility base class for RooFit objects that are to be attached to ROOT directories. More...;  ; class  RooDLLSignificanceMCSModule;  Add-on module to RooMCStudy that calculates the significance of a signal by comparing the likelihood of a fit fit with a given parameter floating with a fit with that given parameter fixed to a nominal value (usually zero). More...;  ; class  RooDouble;  Minimal implementation of a TObject holding a double value. More...;  ; class  RooEffGenContext;  Specialized generator context for p.d.fs represented by class RooEffProd, which are p.d.fs multiplied with an efficiency function. More...;  ; class  RooEfficiency;  A PDF ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Roofitcore.html:8424,adapt,adaptor,8424,doc/master/group__Roofitcore.html,https://root.cern,https://root.cern/doc/master/group__Roofitcore.html,1,['adapt'],['adaptor']
Energy Efficiency,"am & ; os, . Int_t ; contents, . bool ; verbose = false, . TString ; indent = """" . ); const. overridevirtual . Interface for detailed printing of object. ; Reimplemented from RooPrintable.; Reimplemented in RooDataHist, and RooDataSet.; Definition at line 806 of file RooAbsData.cxx. ◆ printName(). void RooAbsData::printName ; (; std::ostream & ; os); const. overridevirtual . Print name of dataset. ; Reimplemented from RooPrintable.; Definition at line 783 of file RooAbsData.cxx. ◆ printTitle(). void RooAbsData::printTitle ; (; std::ostream & ; os); const. overridevirtual . Print title of dataset. ; Reimplemented from RooPrintable.; Definition at line 791 of file RooAbsData.cxx. ◆ RecursiveRemove(). void RooAbsData::RecursiveRemove ; (; TObject * ; obj). overridevirtual . If one of the TObject we have a referenced to is deleted, remove the reference. ; Reimplemented from TObject.; Definition at line 2458 of file RooAbsData.cxx. ◆ reduce() [1/5]. RooFit::OwningPtr< RooAbsData > RooAbsData::reduce ; (; const char * ; cut); const. Create a subset of the data set by applying the given cut on the data points. ; The cut expression can refer to any variable in the data set. For cuts involving other variables, such as intermediate formula objects, use the equivalent reduce method specifying the as a RooFormulVar reference. ; Definition at line 472 of file RooAbsData.cxx. ◆ reduce() [2/5]. RooFit::OwningPtr< RooAbsData > RooAbsData::reduce ; (; const RooArgSet & ; varSubset, . const char * ; cut = nullptr . ); const. Create a subset of the data set by applying the given cut on the data points and reducing the dimensions to the specified set. ; The cut expression can refer to any variable in the data set. For cuts involving other variables, such as intermediate formula objects, use the equivalent reduce method specifying the as a RooFormulVar reference. ; Definition at line 500 of file RooAbsData.cxx. ◆ reduce() [3/5]. RooFit::OwningPtr< RooAbsData > RooAbsData::reduce ; (; co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsData.html:61983,reduce,reduce,61983,doc/master/classRooAbsData.html,https://root.cern,https://root.cern/doc/master/classRooAbsData.html,1,['reduce'],['reduce']
Energy Efficiency,"am::TFoam ; (; const Char_t * ; Name). User constructor, to be employed by the user. ; Definition at line 166 of file TFoam.cxx. ◆ ~TFoam(). TFoam::~TFoam ; (; ). override . Default destructor. ; Definition at line 228 of file TFoam.cxx. ◆ TFoam() [3/3]. TFoam::TFoam ; (; const TFoam & ; From). Copy Constructor NOT IMPLEMENTED (NEVER USED) ; Definition at line 267 of file TFoam.cxx. Member Function Documentation. ◆ Carver(). void TFoam::Carver ; (; Int_t & ; kBest, . Double_t & ; xBest, . Double_t & ; yBest . ). virtual . Internal method used by Initialize. ; Determines the best edge-candidate and the position of the division plane for the future cell division, in the case of the optimization of the maximum weight. It exploits results of the cell MC exploration run stored in fHistEdg. ; Definition at line 749 of file TFoam.cxx. ◆ CellFill(). Int_t TFoam::CellFill ; (; Int_t ; Status, . TFoamCell * ; parent . ). virtual . Internal method used by Initialize. ; It initializes content of the newly allocated active cell. ; Definition at line 477 of file TFoam.cxx. ◆ CheckAll(). void TFoam::CheckAll ; (; Int_t ; level). virtual . User utility, miscellaneous and debug. ; Checks all pointers in the tree of cells. This is useful auto diagnostic.; level=0, no printout, failures causes STOP; level=1, printout, failures lead to WARNINGS only . Definition at line 1380 of file TFoam.cxx. ◆ Class(). static TClass * TFoam::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TFoam::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TFoam::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 143 of file TFoam.h. ◆ DeclFileName(). static const char * TFoam::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 143 of file TFoam.h. ◆ Divide(). Int_t TFoam::Divide ; (; TFoamCell * ; cell). vi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFoam.html:25529,allocate,allocated,25529,doc/master/classTFoam.html,https://root.cern,https://root.cern/doc/master/classTFoam.html,1,['allocate'],['allocated']
Energy Efficiency,"am[in] labSize New size (0 erase the label); 2779/// \param[in] labAlign New alignment value; 2780/// \param[in] labColor New label color; 2781/// \param[in] labFont New label font; 2782/// \param[in] labText New label text; 2783///; 2784/// #### Example:; 2785///; 2786/// Begin_Macro(source); 2787/// {; 2788/// auto c = new TCanvas(""c1"",""Examples of TGaxis"",900,100);; 2789/// c->Range(-6,-0.1,6,0.1);; 2790/// auto *axis = new TGaxis(-5.5,0.,5.5,0.,0.0,100,510,""S"");; 2791/// axis->SetName(""axis1"");; 2792/// axis->SetTitle(""Axis Title"");; 2793/// axis->SetTitleSize(0.2);; 2794/// axis->SetLabelSize(0.2);; 2795/// axis->SetTickSize(0.15);; 2796/// axis->SetTitleColor(kBlue);; 2797/// axis->SetTitleFont(42);; 2798/// axis->ChangeLabelByValue(0., -1, -1, -1, kRed);; 2799/// axis->ChangeLabelByValue(20., -1, 0);; 2800/// axis->ChangeLabelByValue(40., 30.);; 2801/// axis->ChangeLabelByValue(50., -1, -1, -1, kBlue, -1, ""blue for 50."");; 2802/// axis->ChangeLabelByValue(90., -1, -1, -1, kGreen, -1, ""green for 90."");; 2803/// axis->Draw();; 2804/// }; 2805/// End_Macro; 2806///; 2807/// #### Notes:; 2808///; 2809/// - If an attribute should not be changed just give the value ""-1"".; 2810/// - To erase a label set labSize to 0; 2811/// - If labText is not specified or is an empty string, the text label is not changed.; 2812 ; 2813void TGaxis::ChangeLabelByValue(Double_t labValue, Double_t labAngle, Double_t labSize,; 2814 Int_t labAlign, Int_t labColor, Int_t labFont,; 2815 const TString &labText); 2816{; 2817 // special situation when mod labs taken from axis - one have to reset pointer; 2818 if (fModLabs && !IsOwnedModLabs()) {; 2819 fModLabs = nullptr;; 2820 fNModLabs = 0;; 2821 }; 2822 ; 2823 fNModLabs++;; 2824 if (!fModLabs) {; 2825 fModLabs = new TList();; 2826 fModLabs->SetOwner(kTRUE);; 2827 }; 2828 ; 2829 TAxisModLab *ml = FindModLab(0, 0, labValue, 0.);; 2830 if (!ml) {; 2831 ml = new TAxisModLab();; 2832 ml->SetLabValue(labValue);; 2833 fModLabs->Add(ml);; 2834 }; 2",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGaxis_8cxx_source.html:95176,green,green,95176,doc/master/TGaxis_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGaxis_8cxx_source.html,1,['green'],['green']
Energy Efficiency,"ame response function (not changing the shape) along the entire energy scale. So the response matrix is composed of mutually shifted response functions by one channel, however of the same shape. Original 1-dimensional spectrum. Response function (one peak). The result after deconvolution is given in Figure 4.3. It substantially improves the resolution in the spectrum. Result after deconvolution. We have developed a new high resolution deconvolution algorithm. We have observed that the Gold deconvolution converges to its stable state (solution). It is useless to increase the number of iterations, the result obtained does not change. To continue decreasing the width of peaks, we have found that when the solution reaches its stable state, it is necessary to stop iterations, then to change the vector in a way and repeat again the Gold deconvolution. We have found that in order to change the particular solution we need to apply a non-linear boosting function to it. The power function proved to give the best results. At the beginning the function calculates exact solution of the Toeplitz system of linear equations.; \[ x^{(0)} = [x_e^2(0),x_e^2(1),...,x_e^2(N-1),]^T\] where \[ x_e=H^{'-1}y^{'}\]; Then it applies the Gold deconvolution algorithm to the solution and carries out preset number of iterations. Then the power function with the exponent equal to the boosting coefficient is applied to the deconvolved data. These data are then used as initial estimate of the solution of linear system of equations and again the Gold algorithm is employed. The whole procedure is repeated number_of_repetitions times.; The form of the high-resolution deconvolution function is; char *Deconvolution1HighResolution(float *source,; const float *resp,; int size,; int number_of_iterations,; int number_of_repetitions,; double boost);; This function calculates deconvolution from the source spectrum according to the response spectrum.; The result is placed in the vector pointed by the source poi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html:26402,power,power,26402,root/htmldoc/guides/spectrum/Spectrum.html,https://root.cern,https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html,1,['power'],['power']
Energy Efficiency,"ame, const char* title, const RooArgSet& vars, const char* wgtVarName = 0); Constructor of an empty data set from a RooArgSet defining the dimensions; of the data space. RooDataSet(const char* name, const char* title, RooDataSet* data, const RooArgSet& vars, const char* cuts = 0, const char* wgtVarName = 0); Constructor of a data set from (part of) an existing data; set. The dimensions of the data set are defined by the 'vars'; RooArgSet, which can be identical to 'dset' dimensions, or a; subset thereof. The 'cuts' string is an optional RooFormula; expression and can be used to select the subset of the data; points in 'dset' to be copied. The cut expression can refer to; any variable in the source dataset. For cuts involving variables; other than those contained in the source data set, such as; intermediate formula objects, use the equivalent constructor; accepting RooFormulaVar reference as cut specification. For most uses the RooAbsData::reduce() wrapper function, which; uses this constructor, is the most convenient way to create a; subset of an existing data. RooDataSet(const char* name, const char* title, RooDataSet* data, const RooArgSet& vars, const RooFormulaVar& cutVar, const char* wgtVarName = 0); Constructor of a data set from (part of) an existing data; set. The dimensions of the data set are defined by the 'vars'; RooArgSet, which can be identical to 'dset' dimensions, or a; subset thereof. The 'cutVar' formula variable is used to select; the subset of data points to be copied. For subsets without; selection on the data points, or involving cuts operating; exclusively and directly on the data set dimensions, the; equivalent constructor with a string based cut expression is; recommended. For most uses the RooAbsData::reduce() wrapper function, which; uses this constructor, is the most convenient way to create a; subset of an existing data. RooDataSet(const char* name, const char* title, TTree* t, const RooArgSet& vars, const RooFormulaVar& cutVar, const ch",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooDataSet.html:20669,reduce,reduce,20669,root/html528/RooDataSet.html,https://root.cern,https://root.cern/root/html528/RooDataSet.html,6,['reduce'],['reduce']
Energy Efficiency,"ame; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. Bool_tRooAbsCollection::_allRRVAll contents are RRV; RooLinkedListRooAbsCollection::_listActual object store; TStringRooAbsCollection::_nameOur name.; static Int_tRooPrintable::_nameLength; Bool_tRooAbsCollection::_ownContFlag to identify a list that owns its contents.; static char*_poolBegin! Start of memory pool; static char*_poolCur! Next free slot in memory pool; static char*_poolEnd! End of memory pool ; TNamed*RooAbsCollection::_structureTag! Structure tag; TNamed*RooAbsCollection::_typedStructureTag! Typed structure tag. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void cleanup(); Clear memoery pool on exit to avoid reported memory leaks. void* operator new(size_t bytes); Overloaded new operator guarantees that all RooArgSets allocated with new; have a unique address, a property that is exploited in several places; in roofit to quickly index contents on normalization set pointers.; The memory pool only allocates space for the class itself. The elements; stored in the set are stored outside the pool. void operator delete(void* ptr); Memory is owned by pool, we need to do nothing to release it. RooArgSet(); Default constructor. RooArgSet(const RooArgList& list); Constructor from a RooArgList. If the list contains multiple; objects with the same name, only the first is store in the set.; Warning messages will be printed for dropped items. RooArgSet(const RooArgList& list, const RooAbsArg* var1); Constructor from a RooArgList. If the list contains multiple; objects with the same name, only the first is store in the set.; Warning messages will be printed for dropped items. RooArgSet(const char* name); Empty set constructor. RooArgSet(const RooArgSet& set1, const RooArgSet& set2, const char* name = """"); Construct a set from two existing sets. Roo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooArgSet.html:14617,allocate,allocated,14617,root/html532/RooArgSet.html,https://root.cern,https://root.cern/root/html532/RooArgSet.html,2,['allocate'],['allocated']
Energy Efficiency,"ameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooNonCPEigenDecay(const char* name, const char* title, RooRealVar& t, RooAbsCategory& tag, RooAbsReal& tau, RooAbsReal& dm, RooAbsReal& avgW, RooAbsReal& delW, RooAbsCategory& rhoQ, RooAbsReal& correctQ, RooAbsReal& wQ, RooAbsReal& a, RooAbsReal& C, RooAbsReal& delC, RooAbsReal& S, RooAbsReal& delS, const RooResolutionModel& model, RooNonCPEigenDecay::DecayType type = DoubleSided). RooNonCPEigenDecay(const char* name, const char* title, RooRealVar& t, RooAbsCategory& tag, RooAbsReal& tau, RooAbsReal& dm, RooAbsReal& avgW, RooAbsReal& delW, RooAbsCategory& rhoQ, RooAbsReal& correctQ, RooAbsReal& a, RooAbsReal& C, RooAbsReal& delC, RooAbsReal& S, RooAbsReal& delS, const RooResolutionModel& model, RooNonCPEigenDecay::DecayType type = DoubleSided). RooNonCPEigenDecay(const RooNonCPEigenDecay& other, const char* name = 0); Copy constructor. ~RooNonCPEigenDecay( void ); Destructor. Double_t coefficient(Int_t basisIndex) const; B0 : _tag == -1; B0bar : _tag == +1; rho+ : _rhoQ == +1; rho- : _rhoQ == -1; the charge corrrection factor ""_correctQ"" serves to implement mis-charges. Int_t getCoefAnalyticalIntegral(Int_t coef, RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const. Double_t coefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const; correct for the right/wrong charge... Int_t getGenerator(const RooArgSet& directVars, RooArgSet& generateVars, Bool_t staticInitOK = kTRUE) const. void initGenerator(Int_t code). void generateEvent(Int_t code). inline RooNonCPEigenDecay( void ); Constructors, assignment etc. { }. TObject* clone(const char* newname) const. » Last changed: Mon Dec 7 13:48:26 2009 » Last generated: 2009-12-07 13:48; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooNonCPEigenDecay.html:43623,charge,charge,43623,root/html526/RooNonCPEigenDecay.html,https://root.cern,https://root.cern/root/html526/RooNonCPEigenDecay.html,3,['charge'],"['charge', 'charges']"
Energy Efficiency,"ameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooNonCPEigenDecay(const char* name, const char* title, RooRealVar& t, RooAbsCategory& tag, RooAbsReal& tau, RooAbsReal& dm, RooAbsReal& avgW, RooAbsReal& delW, RooAbsCategory& rhoQ, RooAbsReal& correctQ, RooAbsReal& wQ, RooAbsReal& a, RooAbsReal& C, RooAbsReal& delC, RooAbsReal& S, RooAbsReal& delS, const RooResolutionModel& model, RooNonCPEigenDecay::DecayType type = DoubleSided). RooNonCPEigenDecay(const char* name, const char* title, RooRealVar& t, RooAbsCategory& tag, RooAbsReal& tau, RooAbsReal& dm, RooAbsReal& avgW, RooAbsReal& delW, RooAbsCategory& rhoQ, RooAbsReal& correctQ, RooAbsReal& a, RooAbsReal& C, RooAbsReal& delC, RooAbsReal& S, RooAbsReal& delS, const RooResolutionModel& model, RooNonCPEigenDecay::DecayType type = DoubleSided). RooNonCPEigenDecay(const RooNonCPEigenDecay& other, const char* name = 0); Copy constructor. ~RooNonCPEigenDecay( void ); Destructor. Double_t coefficient(Int_t basisIndex) const; B0 : _tag == -1; B0bar : _tag == +1; rho+ : _rhoQ == +1; rho- : _rhoQ == -1; the charge corrrection factor ""_correctQ"" serves to implement mis-charges. Int_t getCoefAnalyticalIntegral(Int_t coef, RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const. Double_t coefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const; correct for the right/wrong charge... Int_t getGenerator(const RooArgSet& directVars, RooArgSet& generateVars, Bool_t staticInitOK = kTRUE) const. void initGenerator(Int_t code). void generateEvent(Int_t code). inline RooNonCPEigenDecay( void ); Constructors, assignment etc. { }. TObject* clone(const char* newname) const. » Last changed: Mon Jul 4 15:23:29 2011 » Last generated: 2011-07-04 15:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooNonCPEigenDecay.html:44659,charge,charge,44659,root/html530/RooNonCPEigenDecay.html,https://root.cern,https://root.cern/root/html530/RooNonCPEigenDecay.html,3,['charge'],"['charge', 'charges']"
Energy Efficiency,"ameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooNonCPEigenDecay(const char* name, const char* title, RooRealVar& t, RooAbsCategory& tag, RooAbsReal& tau, RooAbsReal& dm, RooAbsReal& avgW, RooAbsReal& delW, RooAbsCategory& rhoQ, RooAbsReal& correctQ, RooAbsReal& wQ, RooAbsReal& a, RooAbsReal& C, RooAbsReal& delC, RooAbsReal& S, RooAbsReal& delS, const RooResolutionModel& model, RooNonCPEigenDecay::DecayType type = DoubleSided). RooNonCPEigenDecay(const char* name, const char* title, RooRealVar& t, RooAbsCategory& tag, RooAbsReal& tau, RooAbsReal& dm, RooAbsReal& avgW, RooAbsReal& delW, RooAbsCategory& rhoQ, RooAbsReal& correctQ, RooAbsReal& a, RooAbsReal& C, RooAbsReal& delC, RooAbsReal& S, RooAbsReal& delS, const RooResolutionModel& model, RooNonCPEigenDecay::DecayType type = DoubleSided). RooNonCPEigenDecay(const RooNonCPEigenDecay& other, const char* name = 0); Copy constructor. ~RooNonCPEigenDecay( void ); Destructor. Double_t coefficient(Int_t basisIndex) const; B0 : _tag == -1; B0bar : _tag == +1; rho+ : _rhoQ == +1; rho- : _rhoQ == -1; the charge corrrection factor ""_correctQ"" serves to implement mis-charges. Int_t getCoefAnalyticalIntegral(Int_t coef, RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const. Double_t coefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const; correct for the right/wrong charge... Int_t getGenerator(const RooArgSet& directVars, RooArgSet& generateVars, Bool_t staticInitOK = kTRUE) const. void initGenerator(Int_t code). void generateEvent(Int_t code). inline RooNonCPEigenDecay( void ); Constructors, assignment etc. { }. TObject* clone(const char* newname) const. » Last changed: Sat Oct 9 22:38:45 2010 » Last generated: 2010-10-09 22:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooNonCPEigenDecay.html:44291,charge,charge,44291,root/html528/RooNonCPEigenDecay.html,https://root.cern,https://root.cern/root/html528/RooNonCPEigenDecay.html,3,['charge'],"['charge', 'charges']"
Energy Efficiency,"ameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooNonCPEigenDecay(const char* name, const char* title, RooRealVar& t, RooAbsCategory& tag, RooAbsReal& tau, RooAbsReal& dm, RooAbsReal& avgW, RooAbsReal& delW, RooAbsCategory& rhoQ, RooAbsReal& correctQ, RooAbsReal& wQ, RooAbsReal& a, RooAbsReal& C, RooAbsReal& delC, RooAbsReal& S, RooAbsReal& delS, const RooResolutionModel& model, RooNonCPEigenDecay::DecayType type = DoubleSided). RooNonCPEigenDecay(const char* name, const char* title, RooRealVar& t, RooAbsCategory& tag, RooAbsReal& tau, RooAbsReal& dm, RooAbsReal& avgW, RooAbsReal& delW, RooAbsCategory& rhoQ, RooAbsReal& correctQ, RooAbsReal& a, RooAbsReal& C, RooAbsReal& delC, RooAbsReal& S, RooAbsReal& delS, const RooResolutionModel& model, RooNonCPEigenDecay::DecayType type = DoubleSided). RooNonCPEigenDecay(const RooNonCPEigenDecay& other, const char* name = 0); Copy constructor. ~RooNonCPEigenDecay( void ); Destructor. Double_t coefficient(Int_t basisIndex) const; B0 : _tag == -1; B0bar : _tag == +1; rho+ : _rhoQ == +1; rho- : _rhoQ == -1; the charge corrrection factor ""_correctQ"" serves to implement mis-charges. Int_t getCoefAnalyticalIntegral(Int_t coef, RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const. Double_t coefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const; correct for the right/wrong charge... Int_t getGenerator(const RooArgSet& directVars, RooArgSet& generateVars, Bool_t staticInitOK = kTRUE) const. void initGenerator(Int_t code). void generateEvent(Int_t code). inline RooNonCPEigenDecay( void ); Constructors, assignment etc. { }. TObject* clone(const char* newname) const. » Last changed: Thu Nov 3 20:08:46 2011 » Last generated: 2011-11-03 20:08; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooNonCPEigenDecay.html:45066,charge,charge,45066,root/html532/RooNonCPEigenDecay.html,https://root.cern,https://root.cern/root/html532/RooNonCPEigenDecay.html,3,['charge'],"['charge', 'charges']"
Energy Efficiency,"ameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooNonCPEigenDecay(const char* name, const char* title, RooRealVar& t, RooAbsCategory& tag, RooAbsReal& tau, RooAbsReal& dm, RooAbsReal& avgW, RooAbsReal& delW, RooAbsCategory& rhoQ, RooAbsReal& correctQ, RooAbsReal& wQ, RooAbsReal& a, RooAbsReal& C, RooAbsReal& delC, RooAbsReal& S, RooAbsReal& delS, const RooResolutionModel& model, RooNonCPEigenDecay::DecayType type = DoubleSided). RooNonCPEigenDecay(const char* name, const char* title, RooRealVar& t, RooAbsCategory& tag, RooAbsReal& tau, RooAbsReal& dm, RooAbsReal& avgW, RooAbsReal& delW, RooAbsCategory& rhoQ, RooAbsReal& correctQ, RooAbsReal& a, RooAbsReal& C, RooAbsReal& delC, RooAbsReal& S, RooAbsReal& delS, const RooResolutionModel& model, RooNonCPEigenDecay::DecayType type = DoubleSided). RooNonCPEigenDecay(const RooNonCPEigenDecay& other, const char* name = 0); Copy constructor. ~RooNonCPEigenDecay( void ); Destructor. Double_t coefficient(Int_t basisIndex) const; B0 : _tag == -1; B0bar : _tag == +1; rho+ : _rhoQ == +1; rho- : _rhoQ == -1; the charge corrrection factor ""_correctQ"" serves to implement mis-charges. Int_t getCoefAnalyticalIntegral(Int_t coef, RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const. Double_t coefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const; correct for the right/wrong charge... Int_t getGenerator(const RooArgSet& directVars, RooArgSet& generateVars, Bool_t staticInitOK = kTRUE) const. void initGenerator(Int_t code). void generateEvent(Int_t code). inline RooNonCPEigenDecay( void ); Constructors, assignment etc. { }. TObject* clone(const char* newname) const. » Last changed: Tue Jun 2 15:32:32 2015 » Last generated: 2015-06-02 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooNonCPEigenDecay.html:49263,charge,charge,49263,root/html604/RooNonCPEigenDecay.html,https://root.cern,https://root.cern/root/html604/RooNonCPEigenDecay.html,3,['charge'],"['charge', 'charges']"
Energy Efficiency,"amerElement object corresponding to the j-th; element of a compressed array in fElems. parameters description:; - i: the serial number in array fElem; - j: the element number in the array of consecutive types; In the above example the class TAttLine has 3 consecutive data members; of the same type ""short"". Compile makes one single array of 3 elements.; To access the TStreamerElement for the second element; of this array, one can call:; TStreamerElement *el = GetStreamerElementReal(0,1);; const char* membername = el->GetName();; This function is typically called from TBuffer, TXmlBuffer. void InsertArtificialElements(const TObjArray* rules); Insert new members as expressed in the array of TSchemaRule(s). void ls(Option_t* option = """") const; List the TStreamerElement list and also the precomputed tables; if option contains the string ""incOrig"", also prints the original; (non-optimized elements in the list of compiled elements. void* New(void* obj = 0); An emulated object is created at address obj, if obj is null we; allocate memory for the object. void* NewArray(Long_t nElements, void* ary = 0); An array of emulated objects is created at address ary, if ary is null,; we allocate memory for the array. void DestructorImpl(void* p, Bool_t dtorOnly); Internal part of the destructor.; Destruct each of the datamembers in the same order; as the implicit destructor would. void Destructor(void* p, Bool_t dtorOnly = kFALSE); Emulated destructor for this class.; An emulated object is destroyed at address p.; Destruct each of the datamembers in the same order; as the implicit destructor would. void DeleteArray(void* p, Bool_t dtorOnly = kFALSE); Destroy an array of emulated objects, with optional delete. void PrintValue(const char* name, char* pointer, Int_t i, Int_t len, Int_t lenmax = 1000) const; print value of element i in object at pointer; The function may be called in two ways:; -method1 len < 0; i is assumed to be the TStreamerElement number i in StreamerInfo; -method2 le",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TStreamerInfo.html:22929,allocate,allocate,22929,root/html534/TStreamerInfo.html,https://root.cern,https://root.cern/root/html534/TStreamerInfo.html,3,['allocate'],['allocate']
Energy Efficiency,"ameter. void SetMinosError(unsigned int i, double elow, double eup); set the Minos errors for parameter i (called by the Fitter class when running Minos). double LowerError(unsigned int i) const; lower Minos error. If Minos has not run for parameter i return the parabolic error. double UpperError(unsigned int i) const; upper Minos error. If Minos has not run for parameter i return the parabolic error. double GlobalCC(unsigned int i) const; parameter global correlation coefficient. double CovMatrix(unsigned int i, unsigned int j) const; retrieve covariance matrix element. double Correlation(unsigned int i, unsigned int j) const; retrieve correlation elements. void GetCovarianceMatrix(TMatrixTSym<double>& mat) const; fill covariance matrix elements using a generic matrix class implementing operator(i,j); the matrix must be previously allocates with right size (npar * npar). void GetCorrelationMatrix(TMatrixTSym<double>& mat) const; fill a correlation matrix elements using a generic symmetric matrix class implementing operator(i,j); the matrix must be previously allocates with right size (npar * npar). void GetConfidenceIntervals(unsigned int n, unsigned int stride1, unsigned int stride2, const double* x, double* ci, double cl = 0.95, bool norm = true) const. get confidence intervals for an array of n points x.; stride1 indicates the stride in the coordinate space while stride2 the stride in dimension space.; For 1-dim points : stride1=1, stride2=1; for multi-dim points arranged as (x0,x1,...,xN,y0,....yN) stride1=1 stride2=n; for multi-dim points arraged as (x0,y0,..,x1,y1,...,xN,yN,..) stride1=ndim, stride2=1. the confidence interval are returned in the array ci; cl is the desired confidedence interval value; norm is a flag to control if the intervals need to be normalized to the chi2/ndf value; By default the intervals are corrected using the chi2/ndf value of the fit if a chi2 fit is performed. void GetConfidenceIntervals(const ROOT::Fit::BinData& data, double* ci,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Fit__FitResult.html:9020,allocate,allocates,9020,root/html528/ROOT__Fit__FitResult.html,https://root.cern,https://root.cern/root/html528/ROOT__Fit__FitResult.html,1,['allocate'],['allocates']
Energy Efficiency,"ameters for this method are Eta, EtaDecay, Delta and Epsilon.; 5.12.3.3 Steepest Descent Algorithm; Weights are set to the minimum along the line defined by the gradient. The only parameter for this method is Tau. Lower Tau = higher precision = slower search. A value Tau=3 seems reasonable.; 5.12.3.4 Conjugate Gradients With the Polak-Ribiere Updating Formula; Weights are set to the minimum along the line defined by the conjugate gradient. Parameters are Tau and Reset, which defines the epochs where the direction is reset to the steepest descent (estimated by using the Polak-Ribiere formula).; 5.12.3.5 Conjugate Gradients With the Fletcher-Reeves Updating Formula; Weights are set to the minimum along the line defined by the conjugate gradient. Parameters are Tau and Reset, which defines the epochs where the direction is reset to the steepest descent (estimated by using the Fletcher-Reeves formula).; 5.12.3.6 The Broyden, Fletcher, Goldfarb, Shanno (BFGS) Method; It implies the computation of a NxN matrix, but seems more powerful at least for less than 300 weights. Parameters are Tau and Reset, which defines the epochs where the direction is reset to the steepest descent.; 5.12.4 Using the Network; Neural network are build from a set of “samples”. A sample is a set of values defining the inputs and the corresponding output that the network should ideally provide. In ROOT this is a TTree entry. The first thing to be decided is the network layout. This layout is described in a string where the layers are separated by semicolons. The input/output layers are defined by giving the expression for each neuron, separated by comas. Hidden layers are just described by the number of neurons.; In addition, input and output layer formulas can be preceded by ‘@’ (e.g. “@out”) if one wants to normalize the corresponding value. Also, if the string ends with ‘!’, output neurons are set up for classification, i.e. with a sigmoid (1 neuron) or softmax (more neurons) activation function",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:234327,power,powerful,234327,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['power'],['powerful']
Energy Efficiency,ams. protected . List of histograms. ; Definition at line 96 of file TMultiDimFit.h. ◆ fIsUserFunction. Bool_t TMultiDimFit::fIsUserFunction. protected . Flag for user defined function. ; Definition at line 105 of file TMultiDimFit.h. ◆ fIsVerbose. Bool_t TMultiDimFit::fIsVerbose. protected . Definition at line 106 of file TMultiDimFit.h. ◆ fMaxAngle. Double_t TMultiDimFit::fMaxAngle. protected . Max angle for accepting new function. ; Definition at line 51 of file TMultiDimFit.h. ◆ fMaxFuncNV. Int_t TMultiDimFit::fMaxFuncNV. protected . fMaxFunctions*fNVariables ; Definition at line 62 of file TMultiDimFit.h. ◆ fMaxFunctions. Int_t TMultiDimFit::fMaxFunctions. protected . max number of functions ; Definition at line 59 of file TMultiDimFit.h. ◆ fMaxPowers. Int_t* TMultiDimFit::fMaxPowers. protected . [fNVariables] maximum powers ; Definition at line 54 of file TMultiDimFit.h. ◆ fMaxPowersFinal. Int_t* TMultiDimFit::fMaxPowersFinal. protected . [fNVariables] maximum powers from fit; ; Definition at line 68 of file TMultiDimFit.h. ◆ fMaxQuantity. Double_t TMultiDimFit::fMaxQuantity. protected . Max value of dependent quantity. ; Definition at line 31 of file TMultiDimFit.h. ◆ fMaxResidual. Double_t TMultiDimFit::fMaxResidual. protected . Max residual value. ; Definition at line 73 of file TMultiDimFit.h. ◆ fMaxResidualRow. Int_t TMultiDimFit::fMaxResidualRow. protected . Row giving max residual. ; Definition at line 75 of file TMultiDimFit.h. ◆ fMaxStudy. Int_t TMultiDimFit::fMaxStudy. protected . max functions to study ; Definition at line 61 of file TMultiDimFit.h. ◆ fMaxTerms. Int_t TMultiDimFit::fMaxTerms. protected . Max terms expected in final expr. ; Definition at line 52 of file TMultiDimFit.h. ◆ fMaxVariables. TVectorD TMultiDimFit::fMaxVariables. protected . max value of independent variables ; Definition at line 39 of file TMultiDimFit.h. ◆ fMeanQuantity. Double_t TMultiDimFit::fMeanQuantity. protected . Mean of dependent quantity. ; Definition at line 30 o,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMultiDimFit.html:63589,power,powers,63589,doc/master/classTMultiDimFit.html,https://root.cern,https://root.cern/doc/master/classTMultiDimFit.html,1,['power'],['powers']
Energy Efficiency,"ams[ 5] *= ratio;; f2params[10] *= ratio;; f2->SetParameters(f2params);; h2->Fit(""f2"",""N"");; auto cutg = new TCutG(""cutg"",5);; cutg->SetPoint(0,-7,-7);; cutg->SetPoint(1, 2,-7);; cutg->SetPoint(2, 2, 2);; cutg->SetPoint(3,-7, 2);; cutg->SetPoint(4,-7,-7);; h2->Draw(""lego2 0"");; h2->SetFillColor(38);; f2->SetNpx(80);; f2->SetNpy(80);; f2->Draw(""surf1 same bb [cutg]"");; return c;; }; c#define c(i)Definition RSha256.hxx:101; TCanvas.h; TCutG.h; TF2.h; resultOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t resultDefinition TGWin32VirtualXProxy.cxx:174; TH2.h; nentriesint nentriesDefinition THbookFile.cxx:91; TMath.h; TStyle.h; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; TCanvasThe Canvas class.Definition TCanvas.h:23; TCutGGraphical cut class.Definition TCutG.h:20; TF2A 2-Dim function with parameters.Definition TF2.h:29; TH2F2-D histogram with a float per channel (see TH1 documentation)Definition TH2.h:307; TStyle::SetOptStatvoid SetOptStat(Int_t stat=1)The type of information printed in the histogram statistics box can be selected via the parameter mod...Definition TStyle.cxx:1640; TStyle::SetPalettevoid SetPalette(Int_t ncolors=kBird, Int_t *colors=nullptr, Float_t alpha=1.)See TColor::SetPalette.Definition TStyle.cxx:1888; double; xDouble_t x[n]Definition legend1.C:17; RooFit::Detail::MathFuncs::ratiodouble ratio(double numerator, double denominator)Definition MathFuncs.h:103; TMVA_SOFIE_GNN_Parser.h2h2Definition TMVA_SOFIE_GNN_Parser.py:188; TMath::ExpDouble_t Exp(Double_t x)Returns the base-e exponential function of x, which is e raised to the power x.Definition TMath.h:709; AuthorRene Brun ; Definition in file fit2a.C. tutorialsfitfit2a.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/fit2a_8C.html:4018,power,power,4018,doc/master/fit2a_8C.html,https://root.cern,https://root.cern/doc/master/fit2a_8C.html,1,['power'],['power']
Energy Efficiency,"an analytically; 78integrate to `anaIntSet`, and return a unique identification code for; 79this integration configuration. If no integration can be; 80performed, zero should be returned. Second,; 81 ; 82```; 83double analyticalIntegral(Int_t code); 84```; 85 ; 86implements the actual analytical integral(s) advertised by; 87`getAnalyticalIntegral()`. This function will only be called with; 88codes returned by `getAnalyticalIntegral()`, except code zero.; 89 ; 90The integration range for each dependent to be integrated can; 91be obtained from the dependent's proxy functions `min()` and; 92`max()`. Never call these proxy functions for any proxy not known to; 93be a dependent via the integration code. Doing so may be; 94ill-defined, e.g., in case the proxy holds a function, and will; 95trigger an assert. Integrated category dependents should always be; 96summed over all of their states.; 97 ; 98 ; 99 ; 100### Direct generation of observables; 101 ; 102Distributions for any PDF can be generated with the accept/reject method,; 103but for certain PDFs, more efficient methods may be implemented. To; 104implement direct generation of one or more observables, two; 105functions need to be implemented, similar to those for analytical; 106integrals:; 107 ; 108```; 109Int_t getGenerator(const RooArgSet& generateVars, RooArgSet& directVars); 110```; 111and; 112```; 113void generateEvent(Int_t code); 114```; 115 ; 116The first function advertises observables, for which distributions can be generated,; 117similar to the way analytical integrals are advertised. The second; 118function implements the actual generator for the advertised observables.; 119 ; 120The generated dependent values should be stored in the proxy; 121objects. For this, the assignment operator can be used (i.e. `xProxy; 122= 3.0` ). Never call assign to any proxy not known to be a dependent; 123via the generation code. Doing so may be ill-defined, e.g. in case; 124the proxy holds a function, and will trigger an as",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html:5000,efficient,efficient,5000,doc/master/RooAbsPdf_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html,1,['efficient'],['efficient']
Energy Efficiency,"an contain a query identifier without tree_name, but; generally urls can not be written with them because of ambiguity with the; wildcard character. (Also see the documentaiton for TChain::AddFile,; which does not support wildcards but allows the url to contain query). NB. To add all the files of a TChain to a chain, use Add(TChain *chain). A- if nentries <= 0, the file is connected and the tree header read; in memory to get the number of entries. B- if (nentries > 0, the file is not connected, nentries is assumed to be; the number of entries in the file. In this case, no check is made that; the file exists and the Tree existing in the file. This second mode; is interesting in case the number of entries in the file is already stored; in a run data base for example. C- if (nentries == kBigNumber) (default), the file is not connected.; the number of entries in each file will be read only when the file; will need to be connected to read an entry.; This option is the default and very efficient if one process; the chain sequentially. Note that in case TChain::GetEntry(entry); is called and entry refers to an entry in the 3rd file, for example,; this forces the Tree headers in the first and second file; to be read to find the number of entries in these files.; Note that if one calls TChain::GetEntriesFast() after having created; a chain with this default, GetEntriesFast will return kBigNumber!; TChain::GetEntries will force of the Tree headers in the chain to be; read to read the number of entries in each Tree. D- The TChain data structure; Each TChainElement has a name equal to the tree name of this TChain; and a title equal to the file name. So, to loop over the; TFiles that have been added to this chain:. TObjArray *fileElements=chain->GetListOfFiles();; TIter next(fileElements);; TChainElement *chEl=0;; while (( chEl=(TChainElement*)next() )) {; TFile f(chEl->GetTitle());; ... do something with f ...; }. Return value:. If nentries>0 (including the default of kBigNumber",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TChain.html:30810,efficient,efficient,30810,root/html534/TChain.html,https://root.cern,https://root.cern/root/html534/TChain.html,3,['efficient'],['efficient']
Energy Efficiency,"an interpolator class from number of data points and with Interpolation::Type type.; The data can be set later on with the SetData method.; In case the data size is not known, better using the default of zero or the next constructor later on.; The default interpolation type is Cubic spline. Interpolator(const vector<double>& x, const vector<double>& y, ROOT::Math::Interpolation::Type type = Interpolation::kCSPLINE). Constructs an interpolator class from vector of data points \f$ (x_i, y_i )\f$ and with Interpolation::Type type.; The method will compute a continuous interpolating function \f$ y(x) \f$ such that \f$ y_i = y ( x_i )\f$.; The default interpolation type is Cubic spline. virtual ~Interpolator(). Interpolator(const ROOT::Math::Interpolator& ); usually copying is non trivial, so we make this unaccessible. bool SetData(const vector<double>& x, const vector<double>& y). Set the data vector ( x[] and y[] ); To be efficient, the size of the data must be the same of the value used in the constructor (ndata); If this is not the case a new re-initialization is performed with the new data size. bool SetData(unsigned int ndata, const double* x, const double* y). Set the data vector ( x[] and y[] ); To be efficient, the size of the data must be the same of the value used when constructing the class (ndata); If this is not the case a new re-initialization is performed with the new data size. double Eval(double x) const. Return the interpolated value at point x. double Deriv(double x) const. Return the derivative of the interpolated function at point x. double Deriv2(double x) const. Return the second derivative of the interpolated function at point x. double Integ(double a, double b) const. Return the Integral of the interpolated function over the range [a,b]. std::string Type() const. Return the type of interpolation method. std::string TypeGet() const. » Last changed: root/mathmore:$Id$ » Last generated: 2015-06-30 14:22; This page has been automatically generated. F",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__Interpolator.html:2873,efficient,efficient,2873,root/html602/ROOT__Math__Interpolator.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__Interpolator.html,1,['efficient'],['efficient']
Energy Efficiency,"an interpolator class from number of data points and with Interpolation::Type type.; The data can be set later on with the SetData method.; In case the data size is not known, better using the default of zero or the next constructor later on.; The default interpolation type is Cubic spline. Interpolator(const vector<double>& x, const vector<double>& y, ROOT::Math::Interpolation::Type type = Interpolation::kCSPLINE). Constructs an interpolator class from vector of data points \f$ (x_i, y_i )\f$ and with Interpolation::Type type.; The method will compute a continuous interpolating function \f$ y(x) \f$ such that \f$ y_i = y ( x_i )\f$.; The default interpolation type is Cubic spline. virtual ~Interpolator(). Interpolator(const ROOT::Math::Interpolator& ); usually copying is non trivial, so we make this unaccessible. bool SetData(const vector<double>& x, const vector<double>& y). Set the data vector ( x[] and y[] ); To be efficient, the size of the data must be the same of the value used in the constructor (ndata); If this is not the case a new re-initialization is performed with the new data size. bool SetData(unsigned int ndata, const double* x, const double* y). Set the data vector ( x[] and y[] ); To be efficient, the size of the data must be the same of the value used when constructing the class (ndata); If this is not the case a new re-initialization is performed with the new data size. double Eval(double x) const. Return the interpolated value at point x. double Deriv(double x) const. Return the derivative of the interpolated function at point x. double Deriv2(double x) const. Return the second derivative of the interpolated function at point x. double Integ(double a, double b) const. Return the Integral of the interpolated function over the range [a,b]. std::string Type() const. Return the type of interpolation method. std::string TypeGet() const. » Last changed: root/mathmore:$Id$ » Last generated: 2015-09-08 16:59; This page has been automatically generated. F",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__Interpolator.html:2873,efficient,efficient,2873,root/html534/ROOT__Math__Interpolator.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__Interpolator.html,1,['efficient'],['efficient']
Energy Efficiency,"an interpolator class from number of data points and with Interpolation::Type type.; The data can be set later on with the SetData method.; In case the data size is not known, better using the default of zero or the next constructor later on.; The default interpolation type is Cubic spline. Interpolator(const vector<double>& x, const vector<double>& y, ROOT::Math::Interpolation::Type type = Interpolation::kCSPLINE). Constructs an interpolator class from vector of data points \f$ (x_i, y_i )\f$ and with Interpolation::Type type.; The method will compute a continuous interpolating function \f$ y(x) \f$ such that \f$ y_i = y ( x_i )\f$.; The default interpolation type is Cubic spline. virtual ~Interpolator(). Interpolator(const ROOT::Math::Interpolator& ); usually copying is non trivial, so we make this unaccessible. bool SetData(const vector<double>& x, const vector<double>& y). Set the data vector ( x[] and y[] ); To be efficient, the size of the data must be the same of the value used in the constructor (ndata); If this is not the case a new re-initialization is performed with the new data size. bool SetData(unsigned int ndata, const double* x, const double* y). Set the data vector ( x[] and y[] ); To be efficient, the size of the data must be the same of the value used when constructing the class (ndata); If this is not the case a new re-initialization is performed with the new data size. double Eval(double x) const. Return the interpolated value at point x. double Deriv(double x) const. Return the derivative of the interpolated function at point x. double Deriv2(double x) const. Return the second derivative of the interpolated function at point x. double Integ(double a, double b) const. Return the Integral of the interpolated function over the range [a,b]. std::string Type() const. Return the type of interpolation method. std::string TypeGet() const. » Last changed: root/mathmore:$Id$ » Last generated: 2015-09-08 17:34; This page has been automatically generated. F",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/ROOT__Math__Interpolator.html:2873,efficient,efficient,2873,root/html604/ROOT__Math__Interpolator.html,https://root.cern,https://root.cern/root/html604/ROOT__Math__Interpolator.html,1,['efficient'],['efficient']
Energy Efficiency,"an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual const Event * Transform (const Event *const, Int_t cls) const;  apply the Gauss transformation ;  ; void WriteTransformationToStream (std::ostream &) const;  ;  Public Member Functions inherited from TMVA::VariableTransformBase;  VariableTransformBase (DataSetInfo &dsi, Types::EVariableTransform tf, const TString &trfName);  standard constructor ;  ; virtual ~VariableTransformBase (void);  ; virtual void CountVariableTypes (UInt_t &nvars, UInt_t &ntgts, UInt_t &nspcts) const;  count variables, targets and spectators ;  ; virtual Bool_t GetInput (const Event *event, std::vector< Float_t > &input, std::vector< Char_t > &mask, Bool_t backTransform=kFALSE) const;  select the values from the event ;  ; virtual const char * GetName () const;  Returns name of object. ;  ; TString GetShortName () const;  ; virtual std::vector< TString > * GetTransformationStrings (Int_t cls) const;  TODO --> adapt to variable,target,spectator selection default transformation output --> only indicate that transformation occurred. ;  ; Types::EVariableTransform GetVariableTransform () const;  ; Bool_t IsCreated () const;  ; Bool_t IsEnabled () const;  ; Bool_t IsNormalised () const;  ; MsgLogger & Log () const;  ; virtual void SelectInput (const TString &inputVariables, Bool_t putIntoVariables=kFALSE);  select the variables/targets/spectators which serve as input to the transformation ;  ; void SetEnabled (Bool_t e);  ; void SetNormalise (Bool_t n);  ; virtual void SetOutput (Event *event, std::vector< Float_t > &output, std::vector< Char_t > &mask, const Event *oldEvent=nullptr, Bool_t backTransform=kFALSE) const;  select the values from the event ;  ; void SetOutputDataSetInfo (DataSetInfo *outputDsi);  ; void SetTMVAVersion (TMVAVersion_t v);  ; void SetUseSignalTransform (Bool_t e=kTRUE);  ; const std::vector< TMVA::VariableInfo > & Spectators () const;  ; void StreamerNVirtual (TBuffe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1VariableGaussTransform.html:2566,adapt,adapt,2566,doc/master/classTMVA_1_1VariableGaussTransform.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1VariableGaussTransform.html,1,['adapt'],['adapt']
Energy Efficiency,"and 1. The difference between consecutive ""Stops"" values gives the fraction of space in the whole table that should be used for the interval between the corresponding color values.; Normally the first element of Stops should be 0 and the last should be 1. If this is not true, fewer than NColors will be used in proportion with the total interval between the first and last elements of Stops.; This definition is similar to the povray-definition of gradient color tables.; For instance: UInt_t Number = 3;; Double_t Red[3] = { 0.0, 1.0, 1.0 };; Double_t Green[3] = { 0.0, 0.0, 1.0 };; Double_t Blue[3] = { 1.0, 0.0, 1.0 };; Double_t Stops[3] = { 0.0, 0.4, 1.0 };; unsigned int; This defines a table in which there are three color end points: RGB = {0, 0, 1}, {1, 0, 0}, and {1, 1, 1} = blue, red, white The first 40% of the table is used to go linearly from blue to red. The remaining 60% of the table is used to go linearly from red to white.; If you define a very short interval such that less than one color fits in it, no colors at all will be allocated. If this occurs for all intervals, ROOT will revert to the default palette.; Original code by Andreas Zoglauer (zog@m.nosp@m.pe.m.nosp@m.pg.de) ; Definition at line 2730 of file TColor.cxx. ◆ DeclFileName(). static const char * TColor::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 113 of file TColor.h. ◆ DefinedColors(). Bool_t TColor::DefinedColors ; (; Int_t ; set_always_on = 0). static . Static method returning kTRUE if some new colors have been defined after initialisation or since the last call to this method. ; This allows to avoid the colors and palette streaming in TCanvas::Streamer if not needed. If method called once with set_always_on = 1, all next canvases will be To reset such mode, just call methoid once with set_always_on = -1 ; Definition at line 1537 of file TColor.cxx. ◆ GetAlpha(). Float_t TColor::GetAlpha ; (; ); const. inline . Definition at ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTColor.html:49871,allocate,allocated,49871,doc/master/classTColor.html,https://root.cern,https://root.cern/doc/master/classTColor.html,1,['allocate'],['allocated']
Energy Efficiency,"and A. Consequently, if the parameter Z is not integer, then; this material represents some sort of mixture.; Inputs:; TString& volumeName The volume name; Outputs:; TSrting &name Material name; Int_t &imat Material index number; Double_t &a Average Atomic mass of material; Double_t &z Average Atomic number of material; Double_t &dens Density of material [g/cm^3]; Double_t &radl Average radiation length of material [cm]; Double_t &inter Average interaction length of material [cm]; TArrayD &par A TArrayD of user defined parameters.; Return:; kTRUE if no errors. Bool_t GetMedium(const TString& volumeName, TString& name, Int_t& imed, Int_t& nmat, Int_t& isvol, Int_t& ifield, Double_t& fieldm, Double_t& tmaxfd, Double_t& stemax, Double_t& deemax, Double_t& epsil, Double_t& stmin, TArrayD& par); Returns the Medium and its parameters for the volume specified; by volumeName.; Inputs:; TString& volumeName The volume name.; Outputs:; TString &name Medium name; Int_t &nmat Material number defined for this medium; Int_t &imed The medium index number; Int_t &isvol volume number defined for this medium; Int_t &iflield Magnetic field flag; Double_t &fieldm Magnetic field strength; Double_t &tmaxfd Maximum angle of deflection per step; Double_t &stemax Maximum step size; Double_t &deemax Maximum fraction of energy allowed to be lost; to continuous process.; Double_t &epsil Boundary crossing precision; Double_t &stmin Minimum step size allowed; TArrayD &par A TArrayD of user parameters with all of the; parameters of the specified medium.; Return:; kTRUE if there where no errors. TGeoMCGeometry(const char* name, const char* title, Bool_t g3CompatibleVolumeNames = false). void Gsbool(const char* , const char* ); {}. TGeoMCGeometry& operator=(const TGeoMCGeometry& ). » Last changed: root/vmc:$Id$ » Last generated: 2015-03-14 16:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoMCGeometry.html:21540,energy,energy,21540,root/html534/TGeoMCGeometry.html,https://root.cern,https://root.cern/root/html534/TGeoMCGeometry.html,1,['energy'],['energy']
Energy Efficiency,"and A. Consequently, if the parameter Z is not integer, then; this material represents some sort of mixture.; Inputs:; TString& volumeName The volume name; Outputs:; TSrting &name Material name; Int_t &imat Material index number; Double_t &a Average Atomic mass of material; Double_t &z Average Atomic number of material; Double_t &dens Density of material [g/cm^3]; Double_t &radl Average radiation length of material [cm]; Double_t &inter Average interaction length of material [cm]; TArrayD &par A TArrayD of user defined parameters.; Return:; kTRUE if no errors. Bool_t GetMedium(const TString& volumeName, TString& name, Int_t& imed, Int_t& nmat, Int_t& isvol, Int_t& ifield, Double_t& fieldm, Double_t& tmaxfd, Double_t& stemax, Double_t& deemax, Double_t& epsil, Double_t& stmin, TArrayD& par); Returns the Medium and its parameters for the volume specified; by volumeName.; Inputs:; TString& volumeName The volume name.; Outputs:; TString &name Medium name; Int_t &nmat Material number defined for this medium; Int_t &imed The medium index number; Int_t &isvol volume number defined for this medium; Int_t &iflield Magnetic field flag; Double_t &fieldm Magnetic field strength; Double_t &tmaxfd Maximum angle of deflection per step; Double_t &stemax Maximum step size; Double_t &deemax Maximum fraction of energy allowed to be lost; to continuous process.; Double_t &epsil Boundary crossing precision; Double_t &stmin Minimum step size allowed; TArrayD &par A TArrayD of user parameters with all of the; parameters of the specified medium.; Return:; kTRUE if there where no errors. TGeoMCGeometry(const char* name, const char* title, Bool_t g3CompatibleVolumeNames = false). void Gsbool(const char* , const char* ); {}. TGeoMCGeometry& operator=(const TGeoMCGeometry& ). » Last changed: root/vmc:$Id$ » Last generated: 2015-06-02 16:01; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGeoMCGeometry.html:22001,energy,energy,22001,root/html604/TGeoMCGeometry.html,https://root.cern,https://root.cern/root/html604/TGeoMCGeometry.html,1,['energy'],['energy']
Energy Efficiency,"and A. Consequently, if the parameter Z is not integer, then; this material represents some sort of mixture.; Inputs:; TString& volumeName The volume name; Outputs:; TSrting &name Material name; Int_t &imat Material index number; Double_t &a Average Atomic mass of material; Double_t &z Average Atomic number of material; Double_t &dens Density of material [g/cm^3]; Double_t &radl Average radiation length of material [cm]; Double_t &inter Average interaction length of material [cm]; TArrayD &par A TArrayD of user defined parameters.; Return:; kTRUE if no errors. Bool_t GetMedium(const TString& volumeName, TString& name, Int_t& imed, Int_t& nmat, Int_t& isvol, Int_t& ifield, Double_t& fieldm, Double_t& tmaxfd, Double_t& stemax, Double_t& deemax, Double_t& epsil, Double_t& stmin, TArrayD& par); Returns the Medium and its parameters for the volume specified; by volumeName.; Inputs:; TString& volumeName The volume name.; Outputs:; TString &name Medium name; Int_t &nmat Material number defined for this medium; Int_t &imed The medium index number; Int_t &isvol volume number defined for this medium; Int_t &iflield Magnetic field flag; Double_t &fieldm Magnetic field strength; Double_t &tmaxfd Maximum angle of deflection per step; Double_t &stemax Maximum step size; Double_t &deemax Maximum fraction of energy allowed to be lost; to continuous process.; Double_t &epsil Boundary crossing precision; Double_t &stmin Minimum step size allowed; TArrayD &par A TArrayD of user parameters with all of the; parameters of the specified medium.; Return:; kTRUE if there where no errors. TGeoMCGeometry(const char* name, const char* title, Bool_t g3CompatibleVolumeNames = false). void Gsbool(const char* , const char* ); {}. TGeoMCGeometry& operator=(const TGeoMCGeometry& ). » Last changed: root/vmc:$Id$ » Last generated: 2015-06-30 15:01; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoMCGeometry.html:22001,energy,energy,22001,root/html602/TGeoMCGeometry.html,https://root.cern,https://root.cern/root/html602/TGeoMCGeometry.html,1,['energy'],['energy']
Energy Efficiency,"and background distributions in a trans- ; : formed variable space where linear correlations are removed.; : The LD implementation here is equivalent to the ""Fisher"" discriminant; : for classification, but also provides linear regression.; : ; : (More precisely: the ""linear discriminator"" determines; : an axis in the (correlated) hyperspace of the input ; : variables such that, when projecting the output classes ; : (signal and background) upon this axis, they are pushed ; : as far as possible away from each other, while events; : of a same class are confined in a close vicinity. The ; : linearity property of this classifier is reflected in the ; : metric with which ""far apart"" and ""close vicinity"" are ; : determined: the covariance matrix of the discriminating; : variable space.); : ; : ␛[1m--- Performance optimisation:␛[0m; : ; : Optimal performance for the linear discriminant is obtained for ; : linearly correlated Gaussian-distributed variables. Any deviation; : from this ideal reduces the achievable separation power. In ; : particular, no discrimination at all is achieved for a variable; : that has the same sample mean for signal and background, even if ; : the shapes of the distributions are very different. Thus, the linear ; : discriminant often benefits from a suitable transformation of the ; : input variables. For example, if a variable x in [-1,1] has a ; : a parabolic signal distributions, and a uniform background; : distributions, their mean value is zero in both cases, leading ; : to no separation. The simple transformation x -> |x| renders this ; : variable powerful for the use in a linear discriminant.; : ; : ␛[1m--- Performance tuning via configuration options:␛[0m; : ; : <None>; : ; : <Suppress this message by specifying ""!H"" in the booking option>; : ␛[1m================================================================␛[0m; : ; LD : Results for LD coefficients:; : -----------------------; : Variable: Coefficient:; : -----------------------; : myvar1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAClassification_8C.html:36491,reduce,reduces,36491,doc/master/TMVAClassification_8C.html,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html,2,"['power', 'reduce']","['power', 'reduces']"
Energy Efficiency,"and colors=0, a Deep Sea palette is used.; 2523 if ncolors = 52 and colors=0, a Grey Scale palette is used.; 2524 if ncolors = 53 and colors=0, a Dark Body Radiator palette is used.; 2525 if ncolors = 54 and colors=0, a two-color hue palette palette is used.(dark blue through neutral gray to bright yellow); 2526 if ncolors = 55 and colors=0, a Rain Bow palette is used.; 2527 if ncolors = 56 and colors=0, an inverted Dark Body Radiator palette is used.; 2528 ; 2529 ; 2530If `ncolors > 0 && colors == 0`, the default palette is used with a maximum of ncolors.; 2531 ; 2532The default palette defines:; 2533 ; 2534- index 0 to 9 : shades of grey; 2535- index 10 to 19 : shades of brown; 2536- index 20 to 29 : shades of blue; 2537- index 30 to 39 : shades of red; 2538- index 40 to 49 : basic colors; 2539 ; 2540The color numbers specified in the palette can be viewed by selecting; 2541the item `colors` in the `VIEW` menu of the canvas tool bar.; 2542The red, green, and blue components of a color can be changed thanks to; 2543`TColor::SetRGB()`.; 2544 ; 2545\since **ROOT version 6.19/01**; 2546 ; 2547As default labels and ticks are drawn by `TGAxis` at equidistant (lin or log); 2548points as controlled by SetNdivisions.; 2549If option ""CJUST"" is given labels and ticks are justified at the; 2550color boundaries defined by the contour levels.; 2551For more details see `TPaletteAxis`; 2552 ; 2553\anchor HP24; 2554### Drawing a sub-range of a 2D histogram; the [cutg] option; 2555 ; 2556 ; 2557Using a `TCutG` object, it is possible to draw a sub-range of a 2D; 2558histogram. One must create a graphical cut (mouse or C++) and specify the name; 2559of the cut between `[]` in the `Draw()` option.; 2560For example (fit2a.C), with a `TCutG` named `cutg`, one can call:; 2561 ; 2562 myhist->Draw(""surf1 [cutg]"");; 2563 ; 2564To invert the cut, it is enough to put a `-` in front of its name:; 2565 ; 2566 myhist->Draw(""surf1 [-cutg]"");; 2567 ; 2568It is possible to apply several cuts (`,` m",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THistPainter_8cxx_source.html:103300,green,green,103300,doc/master/THistPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html,1,['green'],['green']
Energy Efficiency,"and data on x; # -------------------------------------------------; ; # Make plain projection of data and pdf on x observable; frame = x.frame(Title=""Projection of 3D data and pdf on X"", Bins=40); data.plotOn(frame); model.plotOn(frame); ; # Define projected signal likelihood ratio; # ----------------------------------------------------------------------------------; ; # Calculate projection of signal and total likelihood on (y,z) observables; # i.e. integrate signal and composite model over x; sigyz = sig.createProjection({x}); totyz = model.createProjection({x}); ; # Construct the log of the signal / signal+background probability; llratio_func = ROOT.RooFormulaVar(""llratio"", ""log10(@0)-log10(@1)"", [sigyz, totyz]); ; # Plot data with a LL ratio cut; # -------------------------------------------------------; ; # Calculate the llratio value for each event in the dataset; data.addColumn(llratio_func); ; # Extract the subset of data with large signal likelihood; dataSel = data.reduce(Cut=""llratio>0.7""); ; # Make plot frame; frame2 = x.frame(Title=""Same projection on X with LLratio(y,z)>0.7"", Bins=40); ; # Plot select data on frame; dataSel.plotOn(frame2); ; # Make MC projection of pdf with same LL ratio cut; # ---------------------------------------------------------------------------------------------; ; # Generate large number of events for MC integration of pdf projection; mcprojData = model.generate({x, y, z}, 10000); ; # Calculate LL ratio for each generated event and select MC events with; # llratio)0.7; mcprojData.addColumn(llratio_func); mcprojDataSel = mcprojData.reduce(Cut=""llratio>0.7""); ; # Project model on x, projected observables (y,z) with Monte Carlo technique; # on set of events with the same llratio cut as was applied to data; model.plotOn(frame2, ProjWData=mcprojDataSel); ; c = ROOT.TCanvas(""rf316_llratioplot"", ""rf316_llratioplot"", 800, 400); c.Divide(2); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.4); frame.Draw(); c.cd",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf316__llratioplot_8py.html:2329,reduce,reduce,2329,doc/master/rf316__llratioplot_8py.html,https://root.cern,https://root.cern/doc/master/rf316__llratioplot_8py.html,1,['reduce'],['reduce']
Energy Efficiency,"andard Atmosphere](http://atmos.nmsu.edu/jsdap/encyclopediawork.html); 316/// in \f$ kg kmol^{-1} \f$ or \f$ gm mol^{-1} \f$; 317constexpr Double_t MWair(); 318{; 319 return 28.9644;; 320}; 321 ; 322////////////////////////////////////////////////////////////////////////////////; 323/// [Dry Air Gas Constant (R / MWair)](http://atmos.nmsu.edu/education_and_outreach/encyclopedia/gas_constant.htm); 324/// in \f$ J kg^{-1} K^{-1} \f$; 325constexpr Double_t Rgair(); 326{; 327 return (1000.0 * R()) / MWair();; 328}; 329 ; 330////////////////////////////////////////////////////////////////////////////////; 331/// Euler-Mascheroni Constant.; 332constexpr Double_t EulerGamma(); 333{; 334 return 0.577215664901532860606512090082402431042;; 335}; 336 ; 337////////////////////////////////////////////////////////////////////////////////; 338/// Elementary charge in \f$ C \f$ .; 339constexpr Double_t Qe(); 340{; 341 return 1.602176634e-19;; 342}; 343 ; 344////////////////////////////////////////////////////////////////////////////////; 345/// Elementary charge uncertainty.; 346constexpr Double_t QeUncertainty(); 347{; 348 // constant is exact according to 2019 redefinition; 349 // (https://en.wikipedia.org/wiki/2019_redefinition_of_the_SI_base_units); 350 return 0.0;; 351}; 352 ; 353////////////////////////////////////////////////////////////////////////////////; 354// Mathematical Functions; 355 ; 356////////////////////////////////////////////////////////////////////////////////; 357// Trigonometrical Functions; 358 ; 359inline Double_t Sin(Double_t);; 360inline Double_t Cos(Double_t);; 361inline Double_t Tan(Double_t);; 362inline Double_t SinH(Double_t);; 363inline Double_t CosH(Double_t);; 364inline Double_t TanH(Double_t);; 365inline Double_t ASin(Double_t);; 366inline Double_t ACos(Double_t);; 367inline Double_t ATan(Double_t);; 368inline Double_t ATan2(Double_t y, Double_t x);; 369Double_t ASinH(Double_t);; 370Double_t ACosH(Double_t);; 371Double_t ATanH(Double_t);; 372Dou",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMath_8h_source.html:10953,charge,charge,10953,doc/master/TMath_8h_source.html,https://root.cern,https://root.cern/doc/master/TMath_8h_source.html,1,['charge'],['charge']
Energy Efficiency,"andard deviations away from the mean. ; nLExponent of power-law tail on the left. ; alphaRLocation of transition to a power law on the right, in standard deviations away from the mean. ; nRExponent of power-law tail on the right. . Definition at line 73 of file RooCrystalBall.cxx. ◆ RooCrystalBall() [3/5]. RooCrystalBall::RooCrystalBall ; (; const char * ; name, . const char * ; title, . RooAbsReal & ; x, . RooAbsReal & ; x0, . RooAbsReal & ; sigmaLR, . RooAbsReal & ; alphaL, . RooAbsReal & ; nL, . RooAbsReal & ; alphaR, . RooAbsReal & ; nR . ). Create a crystal ball shape with symmetric Gaussian core and asymmetric tails (just like RooDSCBShape). ; Parameters. nameName that identifies the PDF in computations. ; titleTitle for plotting. ; xThe variable of the PDF. ; x0Location parameter of the Gaussian component. ; sigmaLRWidth parameter of the Gaussian component. ; alphaLLocation of transition to a power law on the left, in standard deviations away from the mean. ; nLExponent of power-law tail on the left. ; alphaRLocation of transition to a power law on the right, in standard deviations away from the mean. ; nRExponent of power-law tail on the right. . Definition at line 102 of file RooCrystalBall.cxx. ◆ RooCrystalBall() [4/5]. RooCrystalBall::RooCrystalBall ; (; const char * ; name, . const char * ; title, . RooAbsReal & ; x, . RooAbsReal & ; x0, . RooAbsReal & ; sigmaLR, . RooAbsReal & ; alpha, . RooAbsReal & ; n, . bool ; doubleSided = false . ). Create a crystal ball shape with symmetric Gaussian core and only a tail on one side (just like RooCBShape) or two symmetric tails (like RooSDSCBShape). ; Parameters. nameName that identifies the PDF in computations. ; titleTitle for plotting. ; xThe variable of the PDF. ; x0Location parameter of the Gaussian component. ; sigmaLRWidth parameter of the Gaussian component. ; alphaLocation of transition to a power law, in standard deviations away from the mean. ; nExponent of power-law tail. ; doubleSidedWhether the tail ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCrystalBall.html:77105,power,power-law,77105,doc/master/classRooCrystalBall.html,https://root.cern,https://root.cern/doc/master/classRooCrystalBall.html,1,['power'],['power-law']
Energy Efficiency,"andard deviations away from the mean. ; nRExponent of power-law tail on the right. . Definition at line 73 of file RooCrystalBall.cxx. ◆ RooCrystalBall() [3/5]. RooCrystalBall::RooCrystalBall ; (; const char * ; name, . const char * ; title, . RooAbsReal & ; x, . RooAbsReal & ; x0, . RooAbsReal & ; sigmaLR, . RooAbsReal & ; alphaL, . RooAbsReal & ; nL, . RooAbsReal & ; alphaR, . RooAbsReal & ; nR . ). Create a crystal ball shape with symmetric Gaussian core and asymmetric tails (just like RooDSCBShape). ; Parameters. nameName that identifies the PDF in computations. ; titleTitle for plotting. ; xThe variable of the PDF. ; x0Location parameter of the Gaussian component. ; sigmaLRWidth parameter of the Gaussian component. ; alphaLLocation of transition to a power law on the left, in standard deviations away from the mean. ; nLExponent of power-law tail on the left. ; alphaRLocation of transition to a power law on the right, in standard deviations away from the mean. ; nRExponent of power-law tail on the right. . Definition at line 102 of file RooCrystalBall.cxx. ◆ RooCrystalBall() [4/5]. RooCrystalBall::RooCrystalBall ; (; const char * ; name, . const char * ; title, . RooAbsReal & ; x, . RooAbsReal & ; x0, . RooAbsReal & ; sigmaLR, . RooAbsReal & ; alpha, . RooAbsReal & ; n, . bool ; doubleSided = false . ). Create a crystal ball shape with symmetric Gaussian core and only a tail on one side (just like RooCBShape) or two symmetric tails (like RooSDSCBShape). ; Parameters. nameName that identifies the PDF in computations. ; titleTitle for plotting. ; xThe variable of the PDF. ; x0Location parameter of the Gaussian component. ; sigmaLRWidth parameter of the Gaussian component. ; alphaLocation of transition to a power law, in standard deviations away from the mean. ; nExponent of power-law tail. ; doubleSidedWhether the tail is only on one side or on both sides . Definition at line 129 of file RooCrystalBall.cxx. ◆ RooCrystalBall() [5/5]. RooCrystalBall::RooCrystalBall ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCrystalBall.html:77252,power,power-law,77252,doc/master/classRooCrystalBall.html,https://root.cern,https://root.cern/doc/master/classRooCrystalBall.html,1,['power'],['power-law']
Energy Efficiency,"ange [-PI,PI) More...;  ; class  Polar3D;  Class describing a polar coordinate system based on r, theta and phi Phi is restricted to be in the range [-PI,PI) More...;  ; class  Polynomial;  Parametric Function class describing polynomials of order n. More...;  ; class  PositionVector2D;  Class describing a generic position vector (point) in 2 dimensions. More...;  ; class  PositionVector3D;  Class describing a generic position vector (point) in 3 dimensions. More...;  ; class  PtEtaPhiE4D;  Class describing a 4D cylindrical coordinate system using Pt , Phi, Eta and E (or rho, phi, eta , T) The metric used is (-,-,-,+). More...;  ; class  PtEtaPhiM4D;  Class describing a 4D cylindrical coordinate system using Pt , Phi, Eta and M (mass) The metric used is (-,-,-,+). More...;  ; class  PxPyPzE4D;  Class describing a 4D cartesian coordinate system (x, y, z, t coordinates) or momentum-energy vectors stored as (Px, Py, Pz, E). More...;  ; class  PxPyPzM4D;  Class describing a 4D coordinate system or momentum-energy vectors stored as (Px, Py, Pz, M). More...;  ; class  QuasiRandom;  User class for MathMore random numbers template on the Engine type. More...;  ; class  Quaternion;  Rotation class with the (3D) rotation represented by a unit quaternion (u, i, j, k). More...;  ; class  Random;  Documentation for the Random class. More...;  ; class  RandomFunctions;  ; class  RandomFunctions< EngineType, ROOT::Math::GSLRandomEngine >;  Specialized implementation of the Random functions based on the GSL library. More...;  ; class  RandomFunctionsImpl;  Definition of the generic implementation class for the RandomFunctions. More...;  ; class  RandomFunctionsImpl< TRandomEngine >;  Implementation class for the RandomFunction for all the engined that derives from TRandomEngine class, which defines an interface which has TRandomEngine::Rndm() In this way we can have a common implementation for the RandomFunctions. More...;  ; class  RanluxppCompatEngineGslRanlxd;  Compatibility engi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1Math.html:26699,energy,energy,26699,doc/master/namespaceROOT_1_1Math.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1Math.html,2,['energy'],['energy']
Energy Efficiency,"ange node hangs from a filter node, and the range has a begin parameter of 10, that means the range will skip the first 10 entries that pass the preceding filter.; Ranges allow ""early quitting"": if all branches of execution of a functional graph reached their end value of processed entries, the event-loop is immediately interrupted. This is useful for debugging and quick data explorations. Custom columns; Custom columns are created by invoking Define(name, f, columnList). As usual, f can be any callable object (function, lambda expression, functor class...); it takes the values of the columns listed in columnList (a list of strings) as parameters, in the same order as they are listed in columnList. f must return the value that will be assigned to the temporary column.; A new variable is created called name, accessible as if it was contained in the dataset from subsequent transformations/actions.; Use cases include:; caching the results of complex calculations for easy and efficient multiple access; extraction of quantities of interest from complex objects; branch aliasing, i.e. changing the name of a branch. An exception is thrown if the name of the new column/branch is already in use for another branch in the TTree.; It is also possible to specify the quantity to be stored in the new temporary column as a C++ expression with the method Define(name, expression). For example this invocation; df.Define(""pt"", ""sqrt(px*px + py*py)"");; will create a new column called ""pt"" the value of which is calculated starting from the columns px and py. The system builds a just-in-time compiled function starting from the expression after having deduced the list of necessary branches from the names of the variables specified by the user.; Custom columns as function of slot and entry number; It is possible to create custom columns also as a function of the processing slot and entry numbers. The methods that can be invoked are:; DefineSlot(name, f, columnList). In this case the callable",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html:31174,efficient,efficient,31174,doc/v632/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html,2,['efficient'],['efficient']
Energy Efficiency,"angle, given a longitude; in degrees. Return value will always be between 0 and 24 (hours).; Sidereal time is most accurately calculated from UT1. If fSec and; fNanoSec are in UTC (which they are by default), the optional argument; UT1Offset can be supplied (in milliseconds). If UT1Offset is not; supplied, conversion has maximum error of 1s. If offset is supplied error; can be reduced to us level. Values for UT1Offset can be found in IERS; Bulletin B: ftp://ftp.iers.org/products/eop/bulletinb/format_2009. Double_t AsLAST(Double_t Longitude, Double_t UT1Offset = 0) const; Return local apparant sidereal time (LAST) in hour-angle, given a; longitude in degrees. Return value will always be between 0 and 24; (hours). Sidereal time is most accurately calculated from UT1. If fSec; and fNanoSec are in UTC (which they are by default), the optional; argument UT1Offset can be supplied (in milliseconds). If UT1Offset is not; supplied, conversion has maximum error of 1s. If offset is supplied error; can be reduced to us level. Values for UT1Offset can be found in IERS; Bulletin B: ftp://ftp.iers.org/products/eop/bulletinb/format_2009. const Char_t * AsString(Option_t* option = """") const; Return the date & time as a string. Result is pointer to a statically allocated string.; User should copy this into their own buffer before calling; this method again. Option ""l"" returns it in local zone format; (can be applied to default or compact format). Default format is RFC822 compliant:; ""Mon, 02 Jan 2001 18:11:12 +0000 (GMT) +999999999 nsec""; ""Mon, 02 Jan 2001 10:11:12 -0800 (PST) +999999999 nsec"". Option ""c"" compact is (almost) ISO 8601 compliant:; ""2001-01-02 18:11:12.9999999999Z""; ""2001-01-02 10:11:12.9999999999-0800"" if PST; * uses ""-"" as date separator as specified in ISO 8601; * uses ""."" rather than preferred "","" for decimal separator; * -HHMM is the difference between local and UTC (if behind, + if ahead).; The ""-HHMM"" is replaced with ""Z"" if given as UTC.; To be strictly conformin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTimeStamp.html:7574,reduce,reduced,7574,root/html534/TTimeStamp.html,https://root.cern,https://root.cern/root/html534/TTimeStamp.html,1,['reduce'],['reduced']
Energy Efficiency,"angle, given a longitude; in degrees. Return value will always be between 0 and 24 (hours).; Sidereal time is most accurately calculated from UT1. If fSec and; fNanoSec are in UTC (which they are by default), the optional argument; UT1Offset can be supplied (in milliseconds). If UT1Offset is not; supplied, conversion has maximum error of 1s. If offset is supplied error; can be reduced to us level. Values for UT1Offset can be found in IERS; Bulletin B: ftp://ftp.iers.org/products/eop/bulletinb/format_2009. Double_t AsLAST(Double_t Longitude, Double_t UT1Offset = 0) const; Return local apparant sidereal time (LAST) in hour-angle, given a; longitude in degrees. Return value will always be between 0 and 24; (hours). Sidereal time is most accurately calculated from UT1. If fSec; and fNanoSec are in UTC (which they are by default), the optional; argument UT1Offset can be supplied (in milliseconds). If UT1Offset is not; supplied, conversion has maximum error of 1s. If offset is supplied error; can be reduced to us level. Values for UT1Offset can be found in IERS; Bulletin B: ftp://ftp.iers.org/products/eop/bulletinb/format_2009. const Char_t * AsString(const Option_t* option = """") const; Return the date & time as a string. Result is pointer to a statically allocated string.; User should copy this into their own buffer before calling; this method again. Option ""l"" returns it in local zone format; (can be applied to default or compact format). Default format is RFC822 compliant:; ""Mon, 02 Jan 2001 18:11:12 +0000 (GMT) +999999999 nsec""; ""Mon, 02 Jan 2001 10:11:12 -0800 (PST) +999999999 nsec"". Option ""c"" compact is (almost) ISO 8601 compliant:; ""2001-01-02 18:11:12.9999999999Z""; ""2001-01-02 10:11:12.9999999999-0800"" if PST; * uses ""-"" as date separator as specified in ISO 8601; * uses ""."" rather than preferred "","" for decimal separator; * -HHMM is the difference between local and UTC (if behind, + if ahead).; The ""-HHMM"" is replaced with ""Z"" if given as UTC.; To be strictly con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TTimeStamp.html:7600,reduce,reduced,7600,root/html604/TTimeStamp.html,https://root.cern,https://root.cern/root/html604/TTimeStamp.html,1,['reduce'],['reduced']
Energy Efficiency,"anks to Marc Escalier for asking how to do this correctly. ; #include <RooDataSet.h>; #include <RooExponential.h>; #include <RooPlot.h>; #include <RooRealVar.h>; #include <TCanvas.h>; ; using namespace RooFit;; ; void rf212_plottingInRanges_blinding(); {; // Make a fit model; RooRealVar x(""x"", ""The observable"", 1, 30);; RooRealVar tau(""tau"", ""The exponent"", -0.1337, -10., -0.1);; RooExponential expo(""expo"", ""A falling exponential function"", x, tau);; ; // Define the sidebands (e.g. background regions); x.setRange(""full"", 1, 30);; x.setRange(""left"", 1, 10);; x.setRange(""right"", 20, 30);; ; // Generate toy data, and cut out the blinded region.; std::unique_ptr<RooDataSet> data{expo.generate(x, 1000)};; std::unique_ptr<RooAbsData> blindedData{data->reduce(CutRange(""left,right""))};; ; // Kick tau a bit, and run an unbinned fit where the blinded data are missing.; // ----------------------------------------------------------------------------------------------------------; // The fit should be done only in the unblinded regions, otherwise it would; // try to make the model adapt to the empty bins in the blinded region.; tau.setVal(-2.);; expo.fitTo(*blindedData, Range(""left,right""), PrintLevel(-1));; ; // Clear the ""fitrange"" attribute of the PDF. Otherwise, the fitrange would; // be automatically taken as the NormRange() for plotting. We want to avoid; // this, because the point of this tutorial is to show what can go wrong when; // the NormRange() is not specified.; expo.removeStringAttribute(""fitrange"");; ; ; // Here we will plot the results; TCanvas *canvas=new TCanvas(""canvas"",""canvas"",800,600);; canvas->Divide(2,1);; ; ; // Wrong:; // ----------------------------------------------------------------------------------------------------------; // Plotting each slice on its own normalises the PDF over its plotting range. For the full curve, that means; // that the blinded region where data is missing is included in the normalisation calculation. The PDF therefore; // co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf212__plottingInRanges__blinding_8C.html:1863,adapt,adapt,1863,doc/master/rf212__plottingInRanges__blinding_8C.html,https://root.cern,https://root.cern/doc/master/rf212__plottingInRanges__blinding_8C.html,1,['adapt'],['adapt']
Energy Efficiency,"antiles of the bigger sample by linear interpolation. ;  ; void Quartiles ();  compute quartiles a quartile is a 25 per cent or 75 per cent quantile ;  ;  Protected Member Functions inherited from TGraph; virtual Double_t ** Allocate (Int_t newsize);  Allocate internal data structures for newsize points. ;  ; Double_t ** AllocateArrays (Int_t Narrays, Int_t arraySize);  Allocate arrays. ;  ; virtual void CopyAndRelease (Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin);  Copy points from fX and fY to arrays[0] and arrays[1] or to fX and fY if arrays == 0 and ibegin != iend. ;  ; virtual Bool_t CopyPoints (Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin);  Copy points from fX and fY to arrays[0] and arrays[1] or to fX and fY if arrays == 0 and ibegin != iend. ;  ; Bool_t CtorAllocate ();  In constructors set fNpoints than call this method. ;  ; virtual Bool_t DoMerge (const TGraph *g);  protected function to perform the merge operation of a graph ;  ; Double_t ** ExpandAndCopy (Int_t size, Int_t iend);  if size > fMaxSize allocate new arrays of 2*size points and copy iend first points. ;  ; virtual void FillZero (Int_t begin, Int_t end, Bool_t from_ctor=kTRUE);  Set zero values for point arrays in the range [begin, end) Should be redefined in descendant classes. ;  ; TString SaveArray (std::ostream &out, const char *suffix, Int_t frameNumber, Double_t *arr);  Save array as C++ code Returns name of created array. ;  ; void SaveHistogramAndFunctions (std::ostream &out, const char *varname, Int_t &frameNumber, Option_t *option);  Save histogram and list of functions of TGraph as C++ statement Used in all TGraph-derived classes. ;  ; Double_t ** ShrinkAndCopy (Int_t size, Int_t iend);  if size*2 <= fMaxSize allocate new arrays of size points, copy points [0,oend). ;  ; virtual void SwapPoints (Int_t pos1, Int_t pos2);  Swap points. ;  ; virtual void UpdateArrays (const std::vector< Int_t > &sorting_indices, Int_t numSortedPoints, Int_t low);  Upda",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGraphQQ.html:30674,allocate,allocate,30674,doc/master/classTGraphQQ.html,https://root.cern,https://root.cern/doc/master/classTGraphQQ.html,1,['allocate'],['allocate']
Energy Efficiency,"anual</A>; 59 */; 60 ; 61 ; 62 template<class UserFunc>; 63 class GSLFunctionAdapter {; 64 ; 65 public:; 66 ; 67 GSLFunctionAdapter() {}; 68 virtual ~GSLFunctionAdapter() {}; 69 ; 70 static double F( double x, void * p) {; 71 ; 72 UserFunc * function = reinterpret_cast< UserFunc *> (p);; 73 return (*function)( x );; 74 }; 75 ; 76 ; 77 static double Df( double x, void * p) {; 78 ; 79 UserFunc * function = reinterpret_cast< UserFunc *> (p);; 80 return (*function).Derivative( x );; 81 }; 82 ; 83 static void Fdf( double x, void * p, double *f, double *df ) {; 84 ; 85 UserFunc * function = reinterpret_cast< UserFunc *> (p);; 86 *f = (*function) ( x );; 87 *df = (*function).Derivative( x );; 88 }; 89 ; 90 };; 91 ; 92 ; 93} // namespace Math; 94} // namespace ROOT; 95 ; 96 ; 97#endif /* ROOT_Math_GSLFunctionAdapter */; f#define f(i)Definition RSha256.hxx:104; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; ROOT::Math::GSLFunctionAdapterClass for adapting any C++ functor class to C function pointers used by GSL.Definition GSLFunctionAdapter.h:63; ROOT::Math::GSLFunctionAdapter::Fdfstatic void Fdf(double x, void *p, double *f, double *df)Definition GSLFunctionAdapter.h:83; ROOT::Math::GSLFunctionAdapter::GSLFunctionAdapterGSLFunctionAdapter()Definition GSLFunctionAdapter.h:67; ROOT::Math::GSLFunctionAdapter::Fstatic double F(double x, void *p)Definition GSLFunctionAdapter.h:70; ROOT::Math::GSLFunctionAdapter::~GSLFunctionAdaptervirtual ~GSLFunctionAdapter()Definition GSLFunctionAdapter.h:68; ROOT::Math::GSLFunctionAdapter::Dfstatic double Df(double x, void *p)Definition GSLFunctionAdapter.h:77; double; xDouble_t x[n]Definition legend1.C:17; MathNamespace for new Math classes and functions.; ROOT::Math::GSLFuncPointerdouble(* GSLFuncPointer)(double, void *)Function pointer corresponding to gsl_function signature.Definition GSLFunctionAdapter.h:45; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forwa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/GSLFunctionAdapter_8h_source.html:3412,adapt,adapting,3412,doc/master/GSLFunctionAdapter_8h_source.html,https://root.cern,https://root.cern/doc/master/GSLFunctionAdapter_8h_source.html,1,['adapt'],['adapting']
Energy Efficiency,"ap ; (; ULong_t ; pixid, . UInt_t ; w, . UInt_t ; h . ). overridevirtual . Register pixmap created by gVirtualGL. ; Parameters. [in]pixidPixmap identifier ; [in]w,hWidth and height of the pixmap. register new pixmap ; Reimplemented from TVirtualX.; Definition at line 3645 of file TGX11.cxx. ◆ AddWindow(). Int_t TGX11::AddWindow ; (; ULong_t ; qwid, . UInt_t ; w, . UInt_t ; h . ). overridevirtual . Register a window created by Qt as a ROOT window (like InitWindow()). ; Reimplemented from TVirtualX.; Definition at line 1378 of file TGX11.cxx. ◆ AllocColor() [1/2]. Bool_t TGX11::AllocColor ; (; Colormap ; cmap, . RXColor * ; color . ). protected . Allocate color in colormap. ; If we are on an <= 8 plane machine we will use XAllocColor. If we are on a >= 15 (15, 16 or 24) plane true color machine we will calculate the pixel value using: for 15 and 16 bit true colors have 6 bits precision per color however only the 5 most significant bits are used in the color index. Except for 16 bits where green uses all 6 bits. I.e.: 15 bits = rrrrrgggggbbbbb; 16 bits = rrrrrggggggbbbbb; for 24 bits each r, g and b are represented by 8 bits.; Since all colors are set with a max of 65535 (16 bits) per r, g, b we just right shift them by 10, 11 and 10 bits for 16 planes, and (10, 10, 10 for 15 planes) and by 8 bits for 24 planes. Returns kFALSE in case color allocation failed. ; Definition at line 366 of file TGX11.cxx. ◆ AllocColor() [2/2]. Bool_t TGX11::AllocColor ; (; Colormap_t ; cmap, . ColorStruct_t & ; color . ). overridevirtual . Find and allocate a color cell according to the color values specified in the ColorStruct_t. ; If no cell could be allocated it returns kFALSE, otherwise kTRUE. ; Reimplemented from TVirtualX.; Definition at line 1351 of file GX11Gui.cxx. ◆ Bell(). void TGX11::Bell ; (; Int_t ; percent). overridevirtual . Sound bell. Percent is loudness from -100% .. 100%. ; Reimplemented from TVirtualX.; Definition at line 1675 of file GX11Gui.cxx. ◆ ChangeActivePointe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGX11.html:54584,green,green,54584,doc/master/classTGX11.html,https://root.cern,https://root.cern/doc/master/classTGX11.html,1,['green'],['green']
Energy Efficiency,"ap, 2 * oldCap)) : ms - 1;; 1229 return cap;; 1230}; 1231 ; 1232////////////////////////////////////////////////////////////////////////////////; 1233/// Clear string without changing its capacity.; 1234 ; 1235void TString::Clear(); 1236{; 1237 Clobber(Capacity());; 1238}; 1239 ; 1240////////////////////////////////////////////////////////////////////////////////; 1241/// Clear string and make sure it has a capacity of nc.; 1242/// \warning If nc > MaxSize(), then Fatal() is raised, and only MaxSize(); 1243/// elements are allocated if Fatal does not abort; 1244/// \return Resulting allocated capacity (after clamping, if needed); 1245 ; 1246Ssiz_t TString::Clobber(Ssiz_t nc); 1247{; 1248 if (nc > MaxSize()) {; 1249 Fatal(""TString::Clobber"", ""capacity too large (%d, max = %d)"", nc, MaxSize());; 1250 // In the rare case where Fatal does not abort, we erase, clamp and continue; 1251 UnLink();; 1252 Zero();; 1253 nc = MaxSize(); // Clamping after deleting to avoid corruption; 1254 }; 1255 ; 1256 if (nc < kMinCap) {; 1257 UnLink();; 1258 Zero();; 1259 } else {; 1260 char *data = GetLongPointer();; 1261 Ssiz_t cap = Recommend(nc);; 1262 if (cap != Capacity()) {; 1263 data = new char[cap+1];; 1264 UnLink();; 1265 SetLongCap(cap+1);; 1266 SetLongPointer(data);; 1267 }; 1268 SetLongSize(0);; 1269 data[0] = 0;; 1270 }; 1271 return nc;; 1272}; 1273 ; 1274////////////////////////////////////////////////////////////////////////////////; 1275/// Make self a distinct copy with capacity of at least tot, where tot cannot; 1276/// be smaller than the current length. Preserve previous contents.; 1277/// \warning If tot > MaxSize(), then Fatal() is raised and only MaxSize() elements are allocated; 1278 ; 1279void TString::Clone(Ssiz_t tot); 1280{; 1281 Ssiz_t len = Length();; 1282 if (len >= tot) return;; 1283 ; 1284 if (tot > MaxSize()) {; 1285 Fatal(""TString::Clone"", ""tot too large (%d, max = %d)"", tot, MaxSize());; 1286 tot = MaxSize();; 1287 }; 1288 ; 1289 Ssiz_t capac = Capacity()",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TString_8cxx_source.html:37982,allocate,allocated,37982,doc/master/TString_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TString_8cxx_source.html,2,['allocate'],['allocated']
Energy Efficiency,"ape.cxx. ◆ TShape() [3/3]. TShape::TShape ; (; const TShape & ; ts). copy constructor ; Definition at line 78 of file TShape.cxx. ◆ ~TShape(). TShape::~TShape ; (; ). override . Shape default destructor. ; Definition at line 109 of file TShape.cxx. Member Function Documentation. ◆ Class(). static TClass * TShape::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TShape::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TShape::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 65 of file TShape.h. ◆ DeclFileName(). static const char * TShape::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 65 of file TShape.h. ◆ FillBuffer3D(). void TShape::FillBuffer3D ; (; TBuffer3D & ; buffer, . Int_t ; reqSections . ); const. protectedvirtual . We have to set kRawSize (unless already done) to allocate buffer space before kRaw can be filled. ; Definition at line 211 of file TShape.cxx. ◆ GetBasicColor(). Int_t TShape::GetBasicColor ; (; ); const. protected . Get basic color. ; Definition at line 241 of file TShape.cxx. ◆ GetBuffer3D(). const TBuffer3D & TShape::GetBuffer3D ; (; Int_t ; reqSections); const. virtual . Stub to avoid forcing implementation at this stage. ; Reimplemented in TBRIK, TPCON, TSPHE, TTUBE, TTUBS, and TXTRU.; Definition at line 252 of file TShape.cxx. ◆ GetMaterial(). TMaterial * TShape::GetMaterial ; (; ); const. inline . Definition at line 56 of file TShape.h. ◆ GetNumber(). virtual Int_t TShape::GetNumber ; (; ); const. inlinevirtual . Definition at line 57 of file TShape.h. ◆ GetVisibility(). Int_t TShape::GetVisibility ; (; ); const. inline . Definition at line 58 of file TShape.h. ◆ IsA(). TClass * TShape::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TNamed.; Reimplemented in TSPHE, TTRA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTShape.html:18581,allocate,allocate,18581,doc/master/classTShape.html,https://root.cern,https://root.cern/doc/master/classTShape.html,1,['allocate'],['allocate']
Energy Efficiency,"ar *func, Int_t ndiv, Option_t *chopt,; 115 Double_t gridlength); 116~~~; 117Where:; 118 ; 119- xmin : X origin coordinate in user's coordinates space.; 120- xmax : X end axis coordinate in user's coordinates space.; 121- ymin : Y origin coordinate in user's coordinates space.; 122- ymax : Y end axis coordinate in user's coordinates space.; 123- func : function defining axis labels and tick marks.; 124- ndiv : Number of divisions.; 125 - ndiv=N1 + 100*N2 + 10000*N3; 126 - N1=number of 1st divisions.; 127 - N2=number of 2nd divisions.; 128 - N3=number of 3rd divisions. e.g.:; 129 - ndiv=0 --> no tick marks.; 130 - ndiv=2 --> 2 divisions, one tick mark in the middle of the axis.; 131- chopt : Drawing options (see below).; 132- gridlength: grid length on main tick marks.; 133 ; 134It should be noted that `func` is not defined in the user's coordinate space,; 135but in the new TGaxis space. If `x` is the original axis, `w` the new axis,; 136and `w = f(x)` (for example, `f` is a calibration function converting ADC; 137channels `x` to energy `w`), then `func` must be supplied as `f^{-1}(w)`.; 138 ; 139Examples:; 140 ; 141Begin_Macro(source); 142{; 143 TCanvas *c2 = new TCanvas(""c2"",""c2"",10,10,700,500);; 144 ; 145 gPad->DrawFrame(0.,-2.,10.,2);; 146 ; 147 TF1 *f1=new TF1(""f1"",""-x"",-10,10);; 148 TGaxis *A1 = new TGaxis(0,2,10,2,""f1"",510,""-"");; 149 A1->SetTitle(""axis with decreasing values"");; 150 A1->Draw();; 151 ; 152 TF1 *f2=new TF1(""f2"",""exp(x)"",0,2);; 153 TGaxis *A2 = new TGaxis(1,1,9,1,""f2"");; 154 A2->SetTitle(""exponential axis"");; 155 A2->SetLabelSize(0.03);; 156 A2->SetTitleSize(0.03);; 157 A2->SetTitleOffset(1.2);; 158 A2->Draw();; 159 ; 160 TF1 *f3=new TF1(""f3"",""log10(x)"",1,1000);; 161 TGaxis *A3 = new TGaxis(2,-2,2,0,""f3"",505,"""");; 162 A3->SetTitle(""logarithmic axis"");; 163 A3->SetLabelSize(0.02);; 164 A3->SetTitleSize(0.03);; 165 A3->SetTitleOffset(0.); // Axis title automatically placed; 166 A3->Draw();; 167}; 168End_Macro; 169 ; 170Note that this functionality h",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGaxis_8cxx_source.html:5077,energy,energy,5077,doc/master/TGaxis_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGaxis_8cxx_source.html,1,['energy'],['energy']
Energy Efficiency,"ar Theta() const. polar angle. Scalar Eta() const. pseudorapidity. void SetPx(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar px); --------- Set Coordinates of this system ---------------. set X value. void SetPy(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar py). set Y value. void SetPz(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar pz). set Z value. void SetM(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar m). set T value. void SetPxPyPzE(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar px, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar py, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar pz, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar e). set all values. void Negate(); ------ Manipulations -------------. negate the 4-vector - Note that the energy cannot be negate (would need an additional data member); therefore negate will work only on the spatial components.; One would need to use negate only with vectors having the energy as data members. void Scale(const ROOT::Math::PxPyPzM4D<Double32_t>::Scalar& a). scale coordinate values by a scalar quantity a. Scalar x() const; ============= Compatibility section ==================; The following make this coordinate system look enough like a CLHEP; vector that an assignment member template can work with either. { return X(); }. Scalar y() const; { return Y(); }. Scalar z() const; { return Z(); }. Scalar t() const; { return E(); }. void SetPt(Double32_t pt); ====== Set member functions for coordinates in other systems =======. void SetEta(Double32_t eta). void SetPhi(Double32_t phi). void SetE(Double32_t energy). void RestrictNegMass(); restrict the value of negative mass to avoid unphysical negative E2 values; M2 must be less than P2 for the tachionic particles - otherwise use positive values. » Last changed: root/mathcore:$Id: PxPyPzM4D.h 30568 2009-10-06 07:17:59Z moneta $ » Last generated: 2009-12-07 13:44; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__PxPyPzM4D_Double32_t_.html:8546,energy,energy,8546,root/html526/ROOT__Math__PxPyPzM4D_Double32_t_.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__PxPyPzM4D_Double32_t_.html,1,['energy'],['energy']
Energy Efficiency,"ar Theta() const. polar angle. Scalar Eta() const. pseudorapidity. void SetPx(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar px); --------- Set Coordinates of this system ---------------. set X value. void SetPy(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar py). set Y value. void SetPz(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar pz). set Z value. void SetM(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar m). set T value. void SetPxPyPzE(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar px, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar py, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar pz, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar e). set all values. void Negate(); ------ Manipulations -------------. negate the 4-vector - Note that the energy cannot be negate (would need an additional data member); therefore negate will work only on the spatial components.; One would need to use negate only with vectors having the energy as data members. void Scale(const ROOT::Math::PxPyPzM4D<Double32_t>::Scalar& a). scale coordinate values by a scalar quantity a. Scalar x() const; ============= Compatibility section ==================; The following make this coordinate system look enough like a CLHEP; vector that an assignment member template can work with either. { return X(); }. Scalar y() const; { return Y(); }. Scalar z() const; { return Z(); }. Scalar t() const; { return E(); }. void SetPt(Double32_t pt); ====== Set member functions for coordinates in other systems =======. void SetEta(Double32_t eta). void SetPhi(Double32_t phi). void SetE(Double32_t energy). void RestrictNegMass(); restrict the value of negative mass to avoid unphysical negative E2 values; M2 must be less than P2 for the tachionic particles - otherwise use positive values. » Last changed: root/mathcore:$Id: PxPyPzM4D.h 31938 2009-12-18 14:49:38Z moneta $ » Last generated: 2010-09-23 19:56; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__PxPyPzM4D_Double32_t_.html:8546,energy,energy,8546,root/html528/ROOT__Math__PxPyPzM4D_Double32_t_.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__PxPyPzM4D_Double32_t_.html,1,['energy'],['energy']
Energy Efficiency,"ar Theta() const. polar angle. Scalar Eta() const. pseudorapidity. void SetPx(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar px); --------- Set Coordinates of this system ---------------. set X value. void SetPy(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar py). set Y value. void SetPz(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar pz). set Z value. void SetM(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar m). set T value. void SetPxPyPzE(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar px, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar py, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar pz, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar e). set all values. void Negate(); ------ Manipulations -------------. negate the 4-vector - Note that the energy cannot be negate (would need an additional data member); therefore negate will work only on the spatial components.; One would need to use negate only with vectors having the energy as data members. void Scale(const ROOT::Math::PxPyPzM4D<Double32_t>::Scalar& a). scale coordinate values by a scalar quantity a. Scalar x() const; ============= Compatibility section ==================; The following make this coordinate system look enough like a CLHEP; vector that an assignment member template can work with either. { return X(); }. Scalar y() const; { return Y(); }. Scalar z() const; { return Z(); }. Scalar t() const; { return E(); }. void SetPt(Double32_t pt); ====== Set member functions for coordinates in other systems =======. void SetEta(Double32_t eta). void SetPhi(Double32_t phi). void SetE(Double32_t energy). void RestrictNegMass(); restrict the value of negative mass to avoid unphysical negative E2 values; M2 must be less than P2 for the tachionic particles - otherwise use positive values. » Last changed: root/mathcore:$Id: PxPyPzM4D.h 31938 2009-12-18 14:49:38Z moneta $ » Last generated: 2011-07-04 15:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ROOT__Math__PxPyPzM4D_Double32_t_.html:8548,energy,energy,8548,root/html530/ROOT__Math__PxPyPzM4D_Double32_t_.html,https://root.cern,https://root.cern/root/html530/ROOT__Math__PxPyPzM4D_Double32_t_.html,1,['energy'],['energy']
Energy Efficiency,"ar Theta() const. polar angle. Scalar Eta() const. pseudorapidity. void SetPx(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar px); --------- Set Coordinates of this system ---------------. set X value. void SetPy(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar py). set Y value. void SetPz(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar pz). set Z value. void SetM(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar m). set T value. void SetPxPyPzE(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar px, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar py, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar pz, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar e). set all values. void Negate(); ------ Manipulations -------------. negate the 4-vector - Note that the energy cannot be negate (would need an additional data member); therefore negate will work only on the spatial components.; One would need to use negate only with vectors having the energy as data members. void Scale(const ROOT::Math::PxPyPzM4D<Double32_t>::Scalar& a). scale coordinate values by a scalar quantity a. Scalar x() const; ============= Compatibility section ==================; The following make this coordinate system look enough like a CLHEP; vector that an assignment member template can work with either. { return X(); }. Scalar y() const; { return Y(); }. Scalar z() const; { return Z(); }. Scalar t() const; { return E(); }. void SetPt(Double32_t pt); ====== Set member functions for coordinates in other systems =======. void SetEta(Double32_t eta). void SetPhi(Double32_t phi). void SetE(Double32_t energy). void RestrictNegMass(); restrict the value of negative mass to avoid unphysical negative E2 values; M2 must be less than P2 for the tachionic particles - otherwise use positive values. » Last changed: root/mathcore:$Id: PxPyPzM4D.h 31938 2009-12-18 14:49:38Z moneta $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ROOT__Math__PxPyPzM4D_Double32_t_.html:8548,energy,energy,8548,root/html532/ROOT__Math__PxPyPzM4D_Double32_t_.html,https://root.cern,https://root.cern/root/html532/ROOT__Math__PxPyPzM4D_Double32_t_.html,1,['energy'],['energy']
Energy Efficiency,"ar pi(); { return M_PI; }. void RestrictNegMass(); restrict the value of negative mass to avoid unphysical negative E2 values; M2 must be less than P2 for the tachionic particles - otherwise use positive values. Scalar Theta() const. polar angle. void SetPt(ROOT::Math::PtEtaPhiM4D<double>::Scalar pt); --------- Set Coordinates of this system ---------------. set Pt value. void SetEta(ROOT::Math::PtEtaPhiM4D<double>::Scalar eta). set eta value. void SetPhi(ROOT::Math::PtEtaPhiM4D<double>::Scalar phi). set phi value. void SetM(ROOT::Math::PtEtaPhiM4D<double>::Scalar mass). set M value. void SetPxPyPzE(ROOT::Math::PtEtaPhiM4D<double>::Scalar px, ROOT::Math::PtEtaPhiM4D<double>::Scalar py, ROOT::Math::PtEtaPhiM4D<double>::Scalar pz, ROOT::Math::PtEtaPhiM4D<double>::Scalar e). set values using cartesian coordinate system. void Negate(); ------ Manipulations -------------. negate the 4-vector -- Note that the energy cannot be negate (would need an additional data member); therefore negate will work only on the spatial components; One would need to use negate only with vectors having the energy as data members. void Scale(ROOT::Math::PtEtaPhiM4D<double>::Scalar a). Scale coordinate values by a scalar quantity a. Scalar x() const; ============= Compatibility secition ==================; The following make this coordinate system look enough like a CLHEP; vector that an assignment member template can work with either. { return X(); }. Scalar y() const; { return Y(); }. Scalar z() const; { return Z(); }. Scalar t() const; { return E(); }. void SetPx(ROOT::Math::PtEtaPhiM4D<double>::Scalar px); ====== Set member functions for coordinates in other systems =======. void SetPy(ROOT::Math::PtEtaPhiM4D<double>::Scalar py). void SetPz(ROOT::Math::PtEtaPhiM4D<double>::Scalar pz). void SetE(ROOT::Math::PtEtaPhiM4D<double>::Scalar energy). » Last changed: root/mathcore:$Id$ » Last generated: 2015-09-08 17:00; This page has been automatically generated. For comments or suggestions regard",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__PtEtaPhiM4D_double_.html:8015,energy,energy,8015,root/html534/ROOT__Math__PtEtaPhiM4D_double_.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__PtEtaPhiM4D_double_.html,2,['energy'],['energy']
Energy Efficiency,"ar pi(); { return M_PI; }. void RestrictNegMass(); restrict the value of negative mass to avoid unphysical negative E2 values; M2 must be less than P2 for the tachionic particles - otherwise use positive values. Scalar Theta() const. polar angle. void SetPt(ROOT::Math::PtEtaPhiM4D<double>::Scalar pt); --------- Set Coordinates of this system ---------------. set Pt value. void SetEta(ROOT::Math::PtEtaPhiM4D<double>::Scalar eta). set eta value. void SetPhi(ROOT::Math::PtEtaPhiM4D<double>::Scalar phi). set phi value. void SetM(ROOT::Math::PtEtaPhiM4D<double>::Scalar mass). set M value. void SetPxPyPzE(ROOT::Math::PtEtaPhiM4D<double>::Scalar px, ROOT::Math::PtEtaPhiM4D<double>::Scalar py, ROOT::Math::PtEtaPhiM4D<double>::Scalar pz, ROOT::Math::PtEtaPhiM4D<double>::Scalar e). set values using cartesian coordinate system. void Negate(); ------ Manipulations -------------. negate the 4-vector -- Note that the energy cannot be negate (would need an additional data member); therefore negate will work only on the spatial components; One would need to use negate only with vectors having the energy as data members. void Scale(ROOT::Math::PtEtaPhiM4D<double>::Scalar a). Scale coordinate values by a scalar quantity a. Scalar x() const; ============= Compatibility secition ==================; The following make this coordinate system look enough like a CLHEP; vector that an assignment member template can work with either. { return X(); }. Scalar y() const; { return Y(); }. Scalar z() const; { return Z(); }. Scalar t() const; { return E(); }. void SetPx(ROOT::Math::PtEtaPhiM4D<double>::Scalar px); ====== Set member functions for coordinates in other systems =======. void SetPy(ROOT::Math::PtEtaPhiM4D<double>::Scalar py). void SetPz(ROOT::Math::PtEtaPhiM4D<double>::Scalar pz). void SetE(ROOT::Math::PtEtaPhiM4D<double>::Scalar energy). » Last changed: root/mathcore:$Id: PtEtaPhiM4D.h 30568 2009-10-06 07:17:59Z moneta $ » Last generated: 2009-12-07 13:44; This page has been automatic",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__PtEtaPhiM4D_double_.html:8013,energy,energy,8013,root/html526/ROOT__Math__PtEtaPhiM4D_double_.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__PtEtaPhiM4D_double_.html,2,['energy'],['energy']
Energy Efficiency,"ar pi(); { return M_PI; }. void RestrictNegMass(); restrict the value of negative mass to avoid unphysical negative E2 values; M2 must be less than P2 for the tachionic particles - otherwise use positive values. Scalar Theta() const. polar angle. void SetPt(ROOT::Math::PtEtaPhiM4D<double>::Scalar pt); --------- Set Coordinates of this system ---------------. set Pt value. void SetEta(ROOT::Math::PtEtaPhiM4D<double>::Scalar eta). set eta value. void SetPhi(ROOT::Math::PtEtaPhiM4D<double>::Scalar phi). set phi value. void SetM(ROOT::Math::PtEtaPhiM4D<double>::Scalar mass). set M value. void SetPxPyPzE(ROOT::Math::PtEtaPhiM4D<double>::Scalar px, ROOT::Math::PtEtaPhiM4D<double>::Scalar py, ROOT::Math::PtEtaPhiM4D<double>::Scalar pz, ROOT::Math::PtEtaPhiM4D<double>::Scalar e). set values using cartesian coordinate system. void Negate(); ------ Manipulations -------------. negate the 4-vector -- Note that the energy cannot be negate (would need an additional data member); therefore negate will work only on the spatial components; One would need to use negate only with vectors having the energy as data members. void Scale(ROOT::Math::PtEtaPhiM4D<double>::Scalar a). Scale coordinate values by a scalar quantity a. Scalar x() const; ============= Compatibility secition ==================; The following make this coordinate system look enough like a CLHEP; vector that an assignment member template can work with either. { return X(); }. Scalar y() const; { return Y(); }. Scalar z() const; { return Z(); }. Scalar t() const; { return E(); }. void SetPx(ROOT::Math::PtEtaPhiM4D<double>::Scalar px); ====== Set member functions for coordinates in other systems =======. void SetPy(ROOT::Math::PtEtaPhiM4D<double>::Scalar py). void SetPz(ROOT::Math::PtEtaPhiM4D<double>::Scalar pz). void SetE(ROOT::Math::PtEtaPhiM4D<double>::Scalar energy). » Last changed: root/mathcore:$Id: PtEtaPhiM4D.h 31938 2009-12-18 14:49:38Z moneta $ » Last generated: 2010-09-23 19:56; This page has been automatic",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__PtEtaPhiM4D_double_.html:8013,energy,energy,8013,root/html528/ROOT__Math__PtEtaPhiM4D_double_.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__PtEtaPhiM4D_double_.html,2,['energy'],['energy']
Energy Efficiency,"ar pi(); { return M_PI; }. void RestrictNegMass(); restrict the value of negative mass to avoid unphysical negative E2 values; M2 must be less than P2 for the tachionic particles - otherwise use positive values. Scalar Theta() const. polar angle. void SetPt(ROOT::Math::PtEtaPhiM4D<double>::Scalar pt); --------- Set Coordinates of this system ---------------. set Pt value. void SetEta(ROOT::Math::PtEtaPhiM4D<double>::Scalar eta). set eta value. void SetPhi(ROOT::Math::PtEtaPhiM4D<double>::Scalar phi). set phi value. void SetM(ROOT::Math::PtEtaPhiM4D<double>::Scalar mass). set M value. void SetPxPyPzE(ROOT::Math::PtEtaPhiM4D<double>::Scalar px, ROOT::Math::PtEtaPhiM4D<double>::Scalar py, ROOT::Math::PtEtaPhiM4D<double>::Scalar pz, ROOT::Math::PtEtaPhiM4D<double>::Scalar e). set values using cartesian coordinate system. void Negate(); ------ Manipulations -------------. negate the 4-vector -- Note that the energy cannot be negate (would need an additional data member); therefore negate will work only on the spatial components; One would need to use negate only with vectors having the energy as data members. void Scale(ROOT::Math::PtEtaPhiM4D<double>::Scalar a). Scale coordinate values by a scalar quantity a. Scalar x() const; ============= Compatibility secition ==================; The following make this coordinate system look enough like a CLHEP; vector that an assignment member template can work with either. { return X(); }. Scalar y() const; { return Y(); }. Scalar z() const; { return Z(); }. Scalar t() const; { return E(); }. void SetPx(ROOT::Math::PtEtaPhiM4D<double>::Scalar px); ====== Set member functions for coordinates in other systems =======. void SetPy(ROOT::Math::PtEtaPhiM4D<double>::Scalar py). void SetPz(ROOT::Math::PtEtaPhiM4D<double>::Scalar pz). void SetE(ROOT::Math::PtEtaPhiM4D<double>::Scalar energy). » Last changed: root/mathcore:$Id: PtEtaPhiM4D.h 31938 2009-12-18 14:49:38Z moneta $ » Last generated: 2011-07-04 15:19; This page has been automatic",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ROOT__Math__PtEtaPhiM4D_double_.html:8015,energy,energy,8015,root/html530/ROOT__Math__PtEtaPhiM4D_double_.html,https://root.cern,https://root.cern/root/html530/ROOT__Math__PtEtaPhiM4D_double_.html,2,['energy'],['energy']
Energy Efficiency,"ar pi(); { return M_PI; }. void RestrictNegMass(); restrict the value of negative mass to avoid unphysical negative E2 values; M2 must be less than P2 for the tachionic particles - otherwise use positive values. Scalar Theta() const. polar angle. void SetPt(ROOT::Math::PtEtaPhiM4D<double>::Scalar pt); --------- Set Coordinates of this system ---------------. set Pt value. void SetEta(ROOT::Math::PtEtaPhiM4D<double>::Scalar eta). set eta value. void SetPhi(ROOT::Math::PtEtaPhiM4D<double>::Scalar phi). set phi value. void SetM(ROOT::Math::PtEtaPhiM4D<double>::Scalar mass). set M value. void SetPxPyPzE(ROOT::Math::PtEtaPhiM4D<double>::Scalar px, ROOT::Math::PtEtaPhiM4D<double>::Scalar py, ROOT::Math::PtEtaPhiM4D<double>::Scalar pz, ROOT::Math::PtEtaPhiM4D<double>::Scalar e). set values using cartesian coordinate system. void Negate(); ------ Manipulations -------------. negate the 4-vector -- Note that the energy cannot be negate (would need an additional data member); therefore negate will work only on the spatial components; One would need to use negate only with vectors having the energy as data members. void Scale(ROOT::Math::PtEtaPhiM4D<double>::Scalar a). Scale coordinate values by a scalar quantity a. Scalar x() const; ============= Compatibility secition ==================; The following make this coordinate system look enough like a CLHEP; vector that an assignment member template can work with either. { return X(); }. Scalar y() const; { return Y(); }. Scalar z() const; { return Z(); }. Scalar t() const; { return E(); }. void SetPx(ROOT::Math::PtEtaPhiM4D<double>::Scalar px); ====== Set member functions for coordinates in other systems =======. void SetPy(ROOT::Math::PtEtaPhiM4D<double>::Scalar py). void SetPz(ROOT::Math::PtEtaPhiM4D<double>::Scalar pz). void SetE(ROOT::Math::PtEtaPhiM4D<double>::Scalar energy). » Last changed: root/mathcore:$Id: PtEtaPhiM4D.h 31938 2009-12-18 14:49:38Z moneta $ » Last generated: 2011-11-03 20:05; This page has been automatic",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ROOT__Math__PtEtaPhiM4D_double_.html:8015,energy,energy,8015,root/html532/ROOT__Math__PtEtaPhiM4D_double_.html,https://root.cern,https://root.cern/root/html532/ROOT__Math__PtEtaPhiM4D_double_.html,2,['energy'],['energy']
Energy Efficiency,"ar* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. UShort_t*fColorAlpha[fNumPoints] alpha at each anchor point; UShort_t*fColorBlue[fNumPoints] blue color at each anchor point; UShort_t*fColorGreen[fNumPoints] green color at each anchor point; UShort_t*fColorRed[fNumPoints] red color at each anchor point; UInt_tfNumPointsnumber of anchor points; Double_t*fPoints[fNumPoints] value of each anchor point [0..1]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TImagePalette(); Default constructor, sets all pointers to 0. TImagePalette(UInt_t numPoints); Constructor for a palette with numPoints anchor points.; It allocates the memory but does not set any colors. TImagePalette(const TImagePalette& palette); Copy constructor. TImagePalette(Int_t ncolors, Int_t* colors); Creates palette in the same way as TStyle::SetPalette. ~TImagePalette(); Destructor. TImagePalette & operator=(const TImagePalette& palette); Assignment operator. Int_t FindColor(UShort_t r, UShort_t g, UShort_t b); returns an index of the closest color. Int_t * GetRootColors(); Returns a list of ROOT colors. Could be used to set histogram palette.; See also http://root.cern.ch/root/htmldoc/TStyle.html#TStyle:SetPalette. » Author: Reiner Rohlfs 24/03/02 » Copyright (C) 2001-2002, Rene Brun, Fons Rademakers and Reiner Rohlfs *; » Last changed: root/graf:$Id$ » Last generated: 2015-03-14 16:42; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TImagePalette.html:8269,allocate,allocates,8269,root/html534/TImagePalette.html,https://root.cern,https://root.cern/root/html534/TImagePalette.html,1,['allocate'],['allocates']
Energy Efficiency,"ar* name, const char* title, const RooArgSet& vars, const char* wgtVarName = 0); Constructor of an empty data set from a RooArgSet defining the dimensions; of the data space. RooDataSet(const char *name, const char *title, RooDataSet *dset, 		 const RooArgSet& vars, const char *cuts, const char* wgtVarName); Constructor of a data set from (part of) an existing data; set. The dimensions of the data set are defined by the 'vars'; RooArgSet, which can be identical to 'dset' dimensions, or a; subset thereof. The 'cuts' string is an optional RooFormula; expression and can be used to select the subset of the data; points in 'dset' to be copied. The cut expression can refer to; any variable in the source dataset. For cuts involving variables; other than those contained in the source data set, such as; intermediate formula objects, use the equivalent constructor; accepting RooFormulaVar reference as cut specification. For most uses the RooAbsData::reduce() wrapper function, which; uses this constructor, is the most convenient way to create a; subset of an existing data. RooDataSet(const char *name, const char *title, RooDataSet *dset, 		 const RooArgSet& vars, const RooFormulaVar& cutVar, const char* wgtVarName); Constructor of a data set from (part of) an existing data; set. The dimensions of the data set are defined by the 'vars'; RooArgSet, which can be identical to 'dset' dimensions, or a; subset thereof. The 'cutVar' formula variable is used to select; the subset of data points to be copied. For subsets without; selection on the data points, or involving cuts operating; exclusively and directly on the data set dimensions, the; equivalent constructor with a string based cut expression is; recommended. For most uses the RooAbsData::reduce() wrapper function, which; uses this constructor, is the most convenient way to create a; subset of an existing data. RooDataSet(const char *name, const char *title, TTree *intree, 		 const RooArgSet& vars, const RooFormulaVar& cutVar, c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooDataSet.html:20374,reduce,reduce,20374,root/html526/RooDataSet.html,https://root.cern,https://root.cern/root/html526/RooDataSet.html,1,['reduce'],['reduce']
Energy Efficiency,"ar, . Int_t ; month, . Int_t ; day, . Int_t ; hour, . Int_t ; min, . Int_t ; sec . ). Create a TDatime and set it to the specified year, month, day, time, hour, minute and second. ; See Set() about the format. ; Definition at line 68 of file TDatime.cxx. ◆ TDatime() [6/6]. TDatime::TDatime ; (; const char * ; sqlDateTime). Expects as input a string in SQL date/time compatible format, like: yyyy-mm-dd hh:mm:ss. ; Definition at line 78 of file TDatime.cxx. ◆ ~TDatime(). virtual TDatime::~TDatime ; (; ). inlinevirtual . Definition at line 53 of file TDatime.h. Member Function Documentation. ◆ AsSQLString(). const char * TDatime::AsSQLString ; (; ); const. Return the date & time in SQL compatible string format, like: 1997-01-15 20:16:28. ; The returned string buffer is static and will be reused. ; Definition at line 152 of file TDatime.cxx. ◆ AsString() [1/2]. const char * TDatime::AsString ; (; ); const. Return the date & time as a string (ctime() format). ; Copy result because it points to a statically allocated string. ; Definition at line 102 of file TDatime.cxx. ◆ AsString() [2/2]. const char * TDatime::AsString ; (; char * ; out); const. Return the date & time as a string (ctime() format). ; Result is copied into out (and out is returned). Make sure out can at least contain 26 characters. Thread safe. ; Definition at line 121 of file TDatime.cxx. ◆ Class(). static TClass * TDatime::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TDatime::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TDatime::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 95 of file TDatime.h. ◆ Convert(). UInt_t TDatime::Convert ; (; Bool_t ; toGMT = kFALSE); const. Convert fDatime from TDatime format to the standard time_t format. ; If toGMT is true, the time offset of the current local time zone is subtracted from the returned time_t. One use o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDatime.html:6324,allocate,allocated,6324,doc/master/classTDatime.html,https://root.cern,https://root.cern/doc/master/classTDatime.html,1,['allocate'],['allocated']
Energy Efficiency,"ar.; ; Rotation and zooming. Rotation:; ; When the plot is selected, it can be rotated by pressing and holding the left mouse button and move the cursor.; Zoom/Unzoom:; ; Mouse wheel or 'j', 'J', 'k', 'K' keys.; ; Panning. The selected plot can be moved in a pad's area by; pressing and holding the left mouse button and the shift key. Box cut; Surface, iso, box, TF3 and parametric painters support box cut by pressing the 'c' or; 'C' key when the mouse cursor is in a plot's area. That will display a transparent box,; cutting away part of the surface (or boxes) in order to show internal part of plot.; This box can be moved inside the plot's area (the full size of the box is equal to the plot's; surrounding box) by selecting one of the box cut axes and pressing the left mouse button to move it.; Plot specific interactions (dynamic slicing etc.); Currently, all gl-plots support some form of slicing.; When back plane is selected (and if it's highlighted in green); you can press and hold left mouse button and shift key; and move this back plane inside plot's area, creating the slice.; During this ""slicing"" plot becomes semi-transparent. To remove all slices (and projected curves for surfaces); - double click with left mouse button in a plot's area.; ; Surface with option ""GLSURF"". The surface profile is displayed on the slicing plane.; The profile projection is drawn on the back plane; by pressing 'p' or 'P' key.; TF3. The contour plot is drawn on the slicing plane.; For TF3 the color scheme can be changed by pressing 's' or 'S'.; Box. The contour plot corresponding to slice plane position is drawn in real time.; Iso. Slicing is similar to ""GLBOX"" option.; Parametric plot. No slicing. Additional keys: 's' or 'S' to change color scheme - about 20 color schemes supported; ('s' for ""scheme""); 'l' or 'L' to increase number of polygons ('l' for ""level"" of details),; 'w' or 'W' to show outlines ('w' for ""wireframe"").; ; . Function Members (Methods); public:. TGLHistPainter(TH1* ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGLHistPainter.html:4382,green,green,4382,root/html528/TGLHistPainter.html,https://root.cern,https://root.cern/root/html528/TGLHistPainter.html,4,['green'],['green']
Energy Efficiency,"ar.; ; Rotation and zooming. Rotation:; ; When the plot is selected, it can be rotated by pressing and holding the left mouse button and move the cursor.; Zoom/Unzoom:; ; Mouse wheel or 'j', 'J', 'k', 'K' keys.; ; Panning. The selected plot can be moved in a pad's area by; pressing and holding the left mouse button and the shift key. Box cut; Surface, iso, box, TF3 and parametric painters support box cut by pressing the 'c' or; 'C' key when the mouse cursor is in a plot's area. That will display a transparent box,; cutting away part of the surface (or boxes) in order to show internal part of plot.; This box can be moved inside the plot's area (the full size of the box is equal to the plot's; surrounding box) by selecting one of the box cut axes and pressing the left mouse button to move it.; Plot specific interactions (dynamic slicing etc.); Currently, all gl-plots support some form of slicing.; When back plane is selected (and if it's highlighted in green); you can press and hold left mouse button and shift key; and move this back plane inside plot's area, creating the slice.; During this ""slicing"" plot becomes semi-transparent. To remove all slices (and projected curves for surfaces); - double click with left mouse button in a plot's area.; ; Surface with option ""GLSURF"". The surface profile is displayed on the slicing plane.; The profile projection is drawn on the back plane; by pressing 'p' or 'P' key.; TF3. The contour plot is drawn on the slicing plane.; For TF3 the color scheme can be changed by pressing 's' or 'S'.; Box. The contour plot corresponding to slice plane position is drawn in real time.; Iso. Slicing is similar to ""GLBOX"" option.; Parametric plot. No slicing. Additional keys: 's' or 'S' to change color scheme - about 20 color schemes supported; ('s' for ""scheme""); 'l' or 'L' to increase number of polygons ('l' for ""level"" of details),; 'w' or 'W' to show outlines ('w' for ""wireframe"").; ; . Function Members (Methods); public:. virtual~TGLHistPaint",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGLHistPainter.html:4551,green,green,4551,root/html602/TGLHistPainter.html,https://root.cern,https://root.cern/root/html602/TGLHistPainter.html,2,['green'],['green']
Energy Efficiency,"ar[i]);; 828}; 829 ; 830 ; 831////////////////////////////////////////////////////////////////////////////////; 832/// Least squares lpolynomial fitting without weights.; 833///; 834/// - m number of parameters; 835/// - a array of parameters; 836/// - first 1st point number to fit (default =0); 837/// - last last point number to fit (default=fNpoints-1); 838///; 839/// based on CERNLIB routine LSQ: Translated to C++ by Rene Brun; 840 ; 841void TMultiGraph::LeastSquareFit(Int_t m, Double_t *a, Double_t xmin, Double_t xmax); 842{; 843 const Double_t zero = 0.;; 844 const Double_t one = 1.;; 845 const Int_t idim = 20;; 846 ; 847 Double_t b[400] /* was [20][20] */;; 848 Int_t i, k, l, ifail, bin;; 849 Double_t power;; 850 Double_t da[20], xk, yk;; 851 ; 852 ; 853 //count the total number of points to fit; 854 TGraph *g;; 855 TIter next(fGraphs);; 856 Double_t *px, *py;; 857 Int_t n=0;; 858 Int_t npp;; 859 while ((g = (TGraph*) next())) {; 860 px=g->GetX();; 861 npp=g->GetN();; 862 for (bin=0; bin<npp; bin++) {; 863 xk=px[bin];; 864 if (xk < xmin || xk > xmax) continue;; 865 n++;; 866 }; 867 }; 868 if (m <= 2) {; 869 LeastSquareLinearFit(n, a[0], a[1], ifail, xmin, xmax);; 870 return;; 871 }; 872 if (m > idim || m > n) return;; 873 da[0] = zero;; 874 for (l = 2; l <= m; ++l) {; 875 b[l-1] = zero;; 876 b[m + l*20 - 21] = zero;; 877 da[l-1] = zero;; 878 }; 879 Int_t np = 0;; 880 ; 881 next.Reset();; 882 while ((g = (TGraph*) next())) {; 883 px=g->GetX();; 884 py=g->GetY();; 885 npp=g->GetN();; 886 ; 887 for (k = 0; k <= npp; ++k) {; 888 xk = px[k];; 889 if (xk < xmin || xk > xmax) continue;; 890 np++;; 891 yk = py[k];; 892 power = one;; 893 da[0] += yk;; 894 for (l = 2; l <= m; ++l) {; 895 power *= xk;; 896 b[l-1] += power;; 897 da[l-1] += power*yk;; 898 }; 899 for (l = 2; l <= m; ++l) {; 900 power *= xk;; 901 b[m + l*20 - 21] += power;; 902 }; 903 }; 904 }; 905 b[0] = Double_t(np);; 906 for (i = 3; i <= m; ++i) {; 907 for (k = i; k <= m; ++k) {; 908 b[k - 1 + (i-1)*20 - 2",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMultiGraph_8cxx_source.html:28019,power,power,28019,doc/master/TMultiGraph_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TMultiGraph_8cxx_source.html,1,['power'],['power']
Energy Efficiency,"aramConst(Int_t , Bool_t = kTRUE). RooArgList createParamSet(RooWorkspace& w, const string& , const RooArgList& Vars). RooArgList createParamSet(RooWorkspace& w, const string& , const RooArgList& Vars, Double_t , Double_t ). RooArgList createParamSet(const string& , Int_t , Double_t , Double_t ). Int_t addVarSet(const RooArgList& vars). Int_t addParamSet(const RooArgList& params). Double_t evaluate() const. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertise that all integrals can be handled internally. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implement analytical integrations by doing appropriate weighting from component integrals; functions to integrators of components. list<Double_t>* plotSamplingHint(RooAbsRealLValue& obs, Double_t xlo, Double_t xhi) const; Return sampling hint for making curves of (projections) of this function; as the recursive division strategy of RooCurve cannot deal efficiently; with the vertical lines that occur in a non-interpolated histogram. std::list<Double_t>* binBoundaries(RooAbsRealLValue& , Double_t , Double_t ) const; Return sampling hint for making curves of (projections) of this function; as the recursive division strategy of RooCurve cannot deal efficiently; with the vertical lines that occur in a non-interpolated histogram. TObject* clone(const char* newname) const; { return new ParamHistFunc(*this, newname); }. const RooArgList& paramList() const; void printMetaArgs(ostream& os) const ;. { return _paramSet ; }. Bool_t forceAnalyticalInt(const RooAbsArg& ) const; { return kTRUE ; }. Bool_t isBinnedDistribution(const RooArgSet& ) const; {return kTRUE;}. » Last changed: Fri Dec 2 14:26:24 2011 » Last generated: 2011-12-02 14:26; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ParamHistFunc.html:36451,efficient,efficiently,36451,root/html532/ParamHistFunc.html,https://root.cern,https://root.cern/root/html532/ParamHistFunc.html,1,['efficient'],['efficiently']
Energy Efficiency,"arameters ;  ; double getParameterValue (const char *name) const;  set one parameter to a specific value ;  ; std::vector< std::string > getSamples () const;  return the vector of sample names, used to build the morph func ;  ; RooAbsReal * getSampleWeight (const char *name);  retrieve the weight (prefactor) of a sample with the given name ;  ; double getScale ();  get energy scale of the EFT expansion ;  ; RooProduct * getSumElement (const char *name) const;  return the RooProduct that is the element of the RooRealSumPdfi corresponding to the given sample name ;  ; bool hasParameter (const char *paramname) const;  check if a parameter of the given name is contained in the list of known parameters ;  ; void insert (RooWorkspace *ws);  ; TClass * IsA () const override;  ; bool isBinnedDistribution (const RooArgSet &obs) const override;  check if this PDF is a binned distribution in the given observable ;  ; bool isCouplingUsed (const char *couplname);  check if there is any morphing power provided for the given coupling morphing power is provided as soon as any two samples provide different, non-zero values for this coupling ;  ; bool isParameterConstant (const char *paramname) const;  return true if the parameter with the given name is set constant, false otherwise ;  ; bool isParameterUsed (const char *paramname) const;  check if there is any morphing power provided for the given parameter morphing power is provided as soon as any two samples provide different, non-zero values for this parameter ;  ; int nParameters () const;  return the number of parameters in this morphing function ;  ; int nPolynomials () const;  return the number of samples in this morphing function ;  ; int nSamples () const;  ; std::list< double > * plotSamplingHint (RooAbsRealLValue &, double, double) const override;  retrieve the sample Hint ;  ; void printCouplings () const;  print a set of couplings ;  ; void printEvaluation () const;  print the contributing samples and their respective w",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooLagrangianMorphFunc.html:9275,power,power,9275,doc/master/classRooLagrangianMorphFunc.html,https://root.cern,https://root.cern/doc/master/classRooLagrangianMorphFunc.html,1,['power'],['power']
Energy Efficiency,"arameters. funca callable object, such as a lambda expression, an std::function, a functor object or a function that takes zero arguments (for the first signature) or one (for the second signature). ; argsa standard vector, a ROOT::TSeq of integer type or an initializer list for the second signature. An integer only for the first. Note: in cases where the function to be executed takes more than zero/one argument but all are fixed except zero/one, the function can be wrapped in a lambda or via std::bind to give it the right signature.; Return value:; An std::vector. The elements in the container will be the objects returned by func. ROOT::Internal::TExecutor::MapReduce; This set of methods behaves exactly like Map, but takes an additional function as a third argument. This function is applied to the set of objects returned by the corresponding Map execution to ""squash"" them into a single object. The signature of the reduce function should be (const std::vector<T>) -> T; An integer can be passed as the fourth argument indicating the number of chunks we want to divide our work in. (Note: Please be aware that chunking is only available when the policy is kMultiThread, ignoring this argument in other cases) This may be useful to avoid the overhead introduced when running really short tasks. In this case, the reduction function should be independent of the size of the vector returned by Map due to optimization of the number of chunks.; Examples:; root[] ROOT::Internal::TExecutor pool; auto ten = pool.MapReduce([]() { return 1; }, 10, [](const std::vector<int>; &v) { return std::accumulate(v.begin(), v.end(), 0); }); root[] ROOT::Internal::TExecutor; pool(ROOT::EExecutionPolicy::kMultiProcess); auto hist = pool.MapReduce(CreateAndFillHists, 10,; PoolUtils::ReduceObjects);; ROOT::ExecutorUtils::ReduceObjectsMerge collection of TObjects.Definition PoolUtils.h:35; ROOT::Internal::TExecutorThis class implements the interface to execute the same task multiple times, sequentially",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1Internal_1_1TExecutor.html:2159,reduce,reduce,2159,doc/v632/classROOT_1_1Internal_1_1TExecutor.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1Internal_1_1TExecutor.html,2,['reduce'],['reduce']
Energy Efficiency,"arams() const; parameter values (return const pointer). { return &fParams.front();}. double Value(unsigned int i) const; parameter value by index. { return fParams[i]; }. double Error(unsigned int i) const; parameter error by index. void SetMinosError(unsigned int i, double elow, double eup); set the Minos errors for parameter i (called by the Fitter class when running Minos). double LowerError(unsigned int i) const; lower Minos error. If Minos has not run for parameter i return the parabolic error. double UpperError(unsigned int i) const; upper Minos error. If Minos has not run for parameter i return the parabolic error. double GlobalCC(unsigned int i) const; parameter global correlation coefficient. double CovMatrix(unsigned int i, unsigned int j) const; retrieve covariance matrix element. double Correlation(unsigned int i, unsigned int j) const; retrieve correlation elements. void GetCovarianceMatrix(TMatrixTSym<double>& mat) const; fill covariance matrix elements using a generic matrix class implementing operator(i,j); the matrix must be previously allocates with right size (npar * npar). void GetCorrelationMatrix(TMatrixTSym<double>& mat) const; fill a correlation matrix elements using a generic symmetric matrix class implementing operator(i,j); the matrix must be previously allocates with right size (npar * npar). void GetConfidenceIntervals(unsigned int n, unsigned int stride1, unsigned int stride2, const double* x, double* ci, double cl = 0.95) const. get confidence intervals for an array of n points x.; stride1 indicates the stride in the coordinate space while stride2 the stride in dimension space.; For 1-dim points : stride1=1, stride2=1; for multi-dim points arranged as (x0,x1,...,xN,y0,....yN) stride1=1 stride2=n; for multi-dim points arraged as (x0,y0,..,x1,y1,...,xN,yN,..) stride1=ndim, stride2=1. the confidence interval are returned in the array ci; cl is the desired confidedence interval value. void GetConfidenceIntervals(const ROOT::Fit::BinData& d",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Fit__FitResult.html:8246,allocate,allocates,8246,root/html526/ROOT__Fit__FitResult.html,https://root.cern,https://root.cern/root/html526/ROOT__Fit__FitResult.html,1,['allocate'],['allocates']
Energy Efficiency,"ard (double x, double h);  Computes the numerical derivative at a point x using an adaptive backward difference algorithm with a step size h. ;  ; double EvalCentral (double x, double h);  Computes the numerical derivative at a point x using an adaptive central difference algorithm with a step size h. ;  ; double EvalForward (double x, double h);  Computes the numerical derivative at a point x using an adaptive forward difference algorithm with a step size h. ;  ; void SetFunction (const IGenFunction &f);  Set the function for calculating the derivatives. ;  ; void SetFunction (GSLFuncPointer f, void *p=nullptr);  Set the function f for evaluating the derivative using a GSL function pointer type. ;  . — Static methods —; int fStatus;  ; double fResult;  ; double fError;  ; GSLFunctionWrapper fFunction;  ; int Status () const;  return the error status of the last integral calculation ;  ; double Result () const;  return the result of the last derivative calculation ;  ; double Error () const;  return the estimate of the absolute error of the last derivative calculation ;  ; static double EvalCentral (const IGenFunction &f, double x, double h);  Computes the numerical derivative of a function f at a point x using an adaptive central difference algorithm with a step size h. ;  ; static double EvalForward (const IGenFunction &f, double x, double h);  Computes the numerical derivative of a function f at a point x using an adaptive forward difference algorithm with a step size h. ;  ; static double EvalBackward (const IGenFunction &f, double x, double h);  Computes the numerical derivative of a function f at a point x using an adaptive backward difference algorithm with a step size h. ;  . #include </home/sftnight/build/workspace/root-makedoc-master/rootspi/rdoc/src/master/math/mathmore/src/GSLDerivator.h>; Constructor & Destructor Documentation. ◆ GSLDerivator(). ROOT::Math::GSLDerivator::GSLDerivator ; (; ). inline . Default Constructor of a GSLDerivator class based on G",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1GSLDerivator.html:2035,adapt,adaptive,2035,doc/master/classROOT_1_1Math_1_1GSLDerivator.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1GSLDerivator.html,1,['adapt'],['adaptive']
Energy Efficiency,"are the same as; 323/// in the format above.; 324///; 325/// <h4>Details of the nentries parameter</h4>; 326/// Depending on the value of the parameter, the number of entries in the file; 327/// is retrieved differently:; 328/// - If <tt>nentries <= 0</tt>, the file is connected and the tree header read; 329/// in memory to get the number of entries.; 330/// - If <tt>nentries > 0</tt>, the file is not connected, \p nentries is; 331/// assumed to be the number of entries in the file. In this case, no check is; 332/// made that the file exists and that the corresponding tree exists as well.; 333/// This second mode is interesting in case the number of entries in the file; 334/// is already stored in a run data base for example.; 335/// - If <tt>nentries == TTree::kMaxEntries</tt> (default), the file is not; 336/// connected. The number of entries in each file will be read only when the; 337/// file will need to be connected to read an entry. This option is the; 338/// default and very efficient if one processes the chain sequentially. Note; 339/// that in case TChain::GetEntry(entry) is called and entry refers to an; 340/// entry in the 3rd file, for example, this forces the tree headers in the; 341/// first and second file to be read to find the number of entries in these; 342/// files. Note that calling TChain::GetEntriesFast after having; 343/// created a chain with this default returns TTree::kMaxEntries ! Using; 344/// TChain::GetEntries instead will force all the tree headers in the chain to; 345/// be read to get the number of entries in each tree.; 346///; 347/// <h4>The %TChain data structure</h4>; 348/// Each element of the chain is a TChainElement object. It has a name equal to; 349/// the tree name of this chain (or the name of the specific tree in the added; 350/// file if it was explicitly tagged) and a title equal to the file name. So, to; 351/// loop over the files that have been added to this chain:; 352/// ~~~ {.cpp}; 353/// TObjArray *fileElements=ch",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TChain_8cxx_source.html:12651,efficient,efficient,12651,doc/master/TChain_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TChain_8cxx_source.html,1,['efficient'],['efficient']
Energy Efficiency,"areOptions(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTMVA::FitterBase::fClassNameremove TMVA:: from TObject name; TMVA::IFitterTarget&TMVA::FitterBase::fFitterTargetpointer to target of fitting procedure; TMVA::MsgLogger*TMVA::FitterBase::fLoggermessage logger; Int_tTMVA::FitterBase::fNparsnumber of parameters; const vector<TMVA::Interval*>TMVA::FitterBase::fRangesallowed intervals. private:. Double_tfAdaptiveSpeedhow fast temperature change in adaptive (in adaptive two variables describe; Double_tfEpsrelative required FCN accuracy at minimum; Double_tfInitialTemperatureinitial temperature (depends on FCN); TStringfKernelTemperatureSstring just to set fKernelTemperature; Int_tfMaxCallsmax number of FCN calls; Double_tfMinTemperatureminimum temperature before SA quit; Double_tfTemperatureAdaptiveStepused to calculate InitialTemperature if fUseDefaultTemperature; Double_tfTemperatureScalehow fast temperature change; Bool_tfUseDefaultScaleif TRUE, SA calculates its own TemperatureScale; Bool_tfUseDefaultTemperatureif TRUE, SA calculates its own InitialTemperature (MinTemperautre). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SimulatedAnnealingFitter(TMVA::IFitterTarget& target, const TString& name, const vector<TMVA::Interval*>& ranges, const TString& theOption); constructor. void DeclareOptions(); declare SA options. void SetParameters(Int_t fMaxCalls, Double_t fInitialTemperature, Double_t fMinTemperature, Double_t fEps, TString fKernelTemperatureS, Double_t fTemperatureScale, Double_t fTemperatureAdaptiveStep, Bool_t fUseDefaultScale, Bool_t fUseDefaultTemperature); set SA configuration parameters. Double_t Run(vector<Double_t>& pars); Execute fitting. virtual ~Simulated",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__SimulatedAnnealingFitter.html:7397,adapt,adaptive,7397,root/html528/TMVA__SimulatedAnnealingFitter.html,https://root.cern,https://root.cern/root/html528/TMVA__SimulatedAnnealingFitter.html,8,['adapt'],['adaptive']
Energy Efficiency,"arg is a RooAbsReal. Bool_t isIdentical(const RooAbsArg& other, Bool_t assumeSameType = kFALSE). TString getTitle(Bool_t appendUnit = kFALSE) const; Return this variable's title string. If appendUnit is true and; this variable has units, also append a string "" (<unit>)"". Double_t getValV(const RooArgSet* set = 0) const; Return value of object. If the cache is clean, return the; cached value, otherwise recalculate on the fly and refill; the cache. Int_t numEvalErrorItems(). Double_t traceEval(const RooArgSet* set) const; Calculate current value of object, with error tracing wrapper. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Variant of getAnalyticalIntegral that is also passed the normalization set; that should be applied to the integrand of which the integral is request.; For certain operator p.d.f it is useful to overload this function rather; than analyticalIntegralWN() as the additional normalization information; may be useful in determining a more efficient decomposition of the; requested integral. Int_t getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; Interface function getAnalyticalIntergral advertises the; analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. Double_t analyticalIntegral(Int_t code, const char* rangeName = 0) const; Implements the actual analy",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsReal.html:35676,efficient,efficient,35676,root/html534/RooAbsReal.html,https://root.cern,https://root.cern/root/html534/RooAbsReal.html,3,['efficient'],['efficient']
Energy Efficiency,"arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); Create a reduced copy of this dataset. The caller takes ownership of the returned dataset. The following optional named arguments are accepted. SelectVars(const RooArgSet& vars) -- Only retain the listed observables in the output dataset; Cut(const char* expression) -- Only retain event surviving the given cut expression; Cut(const RooFormulaVar& expr) -- Only retain event surviving the given cut formula; CutRange(const char* name) -- Only retain events inside range with given name. Multiple CutRange; arguments may be given to select multiple ranges; EventRange(int lo, int hi) -- Only retain events with given sequential event numbers; Name(const char* name) -- Give specified name to output dataset; Title(const char* name) -- Give specified title to output dataset. RooAbsData* reduce(const char* cut); Create a subset of the data set by applying the given cut on the data points.; The cut expression can refer to any variable in the data set. For cuts involving; other variables, such as intermediate formula objects, use the equivalent; reduce method specifying the as a RooFormulVar reference. RooAbsData* reduce(const RooFormulaVar& cutVar); Create a subset of the data set by applying the given cut on the data points.; The 'cutVar' formula variable is used to select the subset of data points to be; retained in the reduced data collection. RooAbsData* reduce(const RooArgSet& varSubset, const char* cut = 0); Create a subset of the data set by applying the given cut on the data points; and reducing the dimensions to the specified set. The cut expression can refer to any variable in the data set. For cuts involving; other variables, such as intermediate formula objects, use the equivalent; reduce method specifying the as a RooFormulVar reference. RooAbsData* reduce(const RooArgSet& varSubset, const RooFormulaV",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsData.html:15775,reduce,reduce,15775,root/html528/RooAbsData.html,https://root.cern,https://root.cern/root/html528/RooAbsData.html,6,['reduce'],['reduce']
Energy Efficiency,"arge number of new and delete calls in large; loops like this (O(100000) x O(10000) times new/delete):. TObjArray a(10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000) events; for (int i = 0; i < ev->Ntracks; i++) { // O(10000) tracks; a[i] = new TTrack(x,y,z,...);. }. a.Delete();; }. One better uses a TClonesArray which reduces the number of; new/delete calls to only O(10000):. TClonesArray a(""TTrack"", 10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000) events; for (int i = 0; i < ev->Ntracks; i++) { // O(10000) tracks; new(a[i]) TTrack(x,y,z,...);. }. a.Delete();; }. Note: the only supported way to add objects to a TClonesArray is; via the new with placement method. The diffrent Add() methods of; TObjArray and its base classes are not allowed. Considering that a new/delete costs about 70 mus on a 300 MHz HP,; O(10^9) new/deletes will save about 19 hours. NOTE 1. C/C++ offer the possibility to allocate and delete memory.; Forgetting to delete allocated memory is a programming error that originate ""leaks"",; i.e. the memory of your process grows and eventually your program crashes.; Even if you *always* delete the allocated memory, the recovered space may not be; efficiently reused. The process knows that there are portions of free memory,; but when you allocate it again, a fresh piece of memory is grabbed.; Your program is free from semantic errors, but the total memory of your process; still grows. Moreover your program's memory is full of ""holes"" which reduce the; efficiency of memory access, this is called ""memory fragmentation"".; Moreover new / delete are expensive operations in terms of CPU time. Without entering into technical details, the TClonesArray allow to ""reuse"" the; same portion of memory for new/delete avoiding memory fragmentation and memory; growth and improving by orders of magnitude the performance. Every time the; memory of the TClonesArray has to be reused, the Clear() method is employed.; To provide its benefits, each TClone",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TClonesArray.html:1543,allocate,allocated,1543,root/html528/TClonesArray.html,https://root.cern,https://root.cern/root/html528/TClonesArray.html,2,['allocate'],['allocated']
Energy Efficiency,"argument returning a single number result:; ties = ""ordered"" (iTies = 0): input x are ""ordered""; ties = ""mean"" (iTies = 1): function ""mean""; ties = ""min"" (iTies = 2): function ""min""; ties = ""max"" (iTies = 3): function ""max"". Details:; At least two complete (x, y) pairs are required.; If there are duplicated (tied) x values and ties is a function it is; applied to the y values for each distinct x value. Useful functions in; this context include mean, min, and max.; If ties=""ordered"" the x values are assumed to be already ordered. The; first y value will be used for interpolation to the left and the last; one for interpolation to the right. Value:; approx returns a graph with components x and y, containing n coordinates; which interpolate the given data points according to the method (and rule); desired. Double_t Approx1(Double_t v, Double_t f, Double_t* x, Double_t* y, Int_t n, Int_t iKind, Double_t Ylow, Double_t Yhigh); Approximate one data point*-*-*-*-*-; *-* ==========================. Approximate y(v), given (x,y)[i], i = 0,..,n-1; Based on R function approx1: Translated to C++ by Christian Stratowa; (R source file: approx.c by R Development Core Team (C) 1999-2001). Int_t Rcmp(Double_t x, Double_t y); static function; if (ISNAN(x)) return 1;; if (ISNAN(y)) return -1;. void Psort(Double_t* x, Int_t n, Int_t k); static function; based on R function rPsort: adapted to C++ by Christian Stratowa; (R source file: R_sort.c by R Development Core Team (C) 1999-2001). void Rank(Int_t n, Double_t* a, Int_t* index, Int_t* rank, Bool_t down = kTRUE); static function. TGraphSmooth(const TGraphSmooth& ). TGraphSmooth& operator=(const TGraphSmooth& ). » Author: Christian Stratowa 30/09/2001 » Copyright (c) 2001- , Dr. Christian Stratowa, Vienna, Austria. *; » Last changed: root/hist:$Id$ » Last generated: 2015-03-14 16:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGraphSmooth.html:17223,adapt,adapted,17223,root/html534/TGraphSmooth.html,https://root.cern,https://root.cern/root/html534/TGraphSmooth.html,1,['adapt'],['adapted']
Energy Efficiency,"argument returning a single number result:; ties = ""ordered"" (iTies = 0): input x are ""ordered""; ties = ""mean"" (iTies = 1): function ""mean""; ties = ""min"" (iTies = 2): function ""min""; ties = ""max"" (iTies = 3): function ""max"". Details:; At least two complete (x, y) pairs are required.; If there are duplicated (tied) x values and ties is a function it is; applied to the y values for each distinct x value. Useful functions in; this context include mean, min, and max.; If ties=""ordered"" the x values are assumed to be already ordered. The; first y value will be used for interpolation to the left and the last; one for interpolation to the right. Value:; approx returns a graph with components x and y, containing n coordinates; which interpolate the given data points according to the method (and rule); desired. Double_t Approx1(Double_t v, Double_t f, Double_t* x, Double_t* y, Int_t n, Int_t iKind, Double_t Ylow, Double_t Yhigh); Approximate one data point*-*-*-*-*-; *-* ==========================. Approximate y(v), given (x,y)[i], i = 0,..,n-1; Based on R function approx1: Translated to C++ by Christian Stratowa; (R source file: approx.c by R Development Core Team (C) 1999-2001). Int_t Rcmp(Double_t x, Double_t y); static function; if (ISNAN(x)) return 1;; if (ISNAN(y)) return -1;. void Psort(Double_t* x, Int_t n, Int_t k); static function; based on R function rPsort: adapted to C++ by Christian Stratowa; (R source file: R_sort.c by R Development Core Team (C) 1999-2001). void Rank(Int_t n, Double_t* a, Int_t* index, Int_t* rank, Bool_t down = kTRUE); static function. TGraphSmooth(const TGraphSmooth& ). TGraphSmooth& operator=(const TGraphSmooth& ). » Author: Christian Stratowa 30/09/2001 » Copyright (c) 2001- , Dr. Christian Stratowa, Vienna, Austria. *; » Last changed: root/hist:$Id$ » Last generated: 2015-06-02 16:06; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGraphSmooth.html:17714,adapt,adapted,17714,root/html604/TGraphSmooth.html,https://root.cern,https://root.cern/root/html604/TGraphSmooth.html,1,['adapt'],['adapted']
Energy Efficiency,"argument returning a single number result:; ties = ""ordered"" (iTies = 0): input x are ""ordered""; ties = ""mean"" (iTies = 1): function ""mean""; ties = ""min"" (iTies = 2): function ""min""; ties = ""max"" (iTies = 3): function ""max"". Details:; At least two complete (x, y) pairs are required.; If there are duplicated (tied) x values and ties is a function it is; applied to the y values for each distinct x value. Useful functions in; this context include mean, min, and max.; If ties=""ordered"" the x values are assumed to be already ordered. The; first y value will be used for interpolation to the left and the last; one for interpolation to the right. Value:; approx returns a graph with components x and y, containing n coordinates; which interpolate the given data points according to the method (and rule); desired. Double_t Approx1(Double_t v, Double_t f, Double_t* x, Double_t* y, Int_t n, Int_t iKind, Double_t Ylow, Double_t Yhigh); Approximate one data point*-*-*-*-*-; *-* ==========================. Approximate y(v), given (x,y)[i], i = 0,..,n-1; Based on R function approx1: Translated to C++ by Christian Stratowa; (R source file: approx.c by R Development Core Team (C) 1999-2001). Int_t Rcmp(Double_t x, Double_t y); static function; if (ISNAN(x)) return 1;; if (ISNAN(y)) return -1;. void Psort(Double_t* x, Int_t n, Int_t k); static function; based on R function rPsort: adapted to C++ by Christian Stratowa; (R source file: R_sort.c by R Development Core Team (C) 1999-2001). void Rank(Int_t n, Double_t* a, Int_t* index, Int_t* rank, Bool_t down = kTRUE); static function. TGraphSmooth(const TGraphSmooth& ). TGraphSmooth& operator=(const TGraphSmooth& ). » Author: Christian Stratowa 30/09/2001 » Copyright (c) 2001- , Dr. Christian Stratowa, Vienna, Austria. *; » Last changed: root/hist:$Id$ » Last generated: 2015-06-30 15:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGraphSmooth.html:17714,adapt,adapted,17714,root/html602/TGraphSmooth.html,https://root.cern,https://root.cern/root/html602/TGraphSmooth.html,1,['adapt'],['adapted']
Energy Efficiency,"ariablePCATransform.cxx. ◆ IsA(). virtual TClass * TMVA::VariablePCATransform::IsA ; (; ); const. inlinevirtual . ReturnsTClass describing current object ; Reimplemented from TMVA::VariableTransformBase.; Definition at line 80 of file VariablePCATransform.h. ◆ MakeFunction(). void TMVA::VariablePCATransform::MakeFunction ; (; std::ostream & ; fout, . const TString & ; fncName, . Int_t ; part, . UInt_t ; trCounter, . Int_t ; cls . ). virtual . creates C++ code fragment of the PCA transform for inclusion in standalone C++ class ; Implements TMVA::VariableTransformBase.; Definition at line 531 of file VariablePCATransform.cxx. ◆ P2X(). void TMVA::VariablePCATransform::P2X ; (; std::vector< Float_t > & ; x, . const std::vector< Float_t > & ; pc, . Int_t ; cls . ); const. private . Perform the back-transformation from the principal components pc, and return x It's the users responsibility to make sure that both x and pc are of the right size (i.e., memory must be allocated for p) ; Definition at line 299 of file VariablePCATransform.cxx. ◆ PrepareTransformation(). Bool_t TMVA::VariablePCATransform::PrepareTransformation ; (; const std::vector< Event * > & ; events). virtual . calculate the principal components using the ROOT class TPrincipal and the normalization ; Implements TMVA::VariableTransformBase.; Definition at line 89 of file VariablePCATransform.cxx. ◆ ReadFromXML(). void TMVA::VariablePCATransform::ReadFromXML ; (; void * ; trfnode). virtual . Read the transformation matrices from the xml node. ; Implements TMVA::VariableTransformBase.; Definition at line 384 of file VariablePCATransform.cxx. ◆ ReadTransformationFromStream(). void TMVA::VariablePCATransform::ReadTransformationFromStream ; (; std::istream & ; istr, . const TString & ; classname . ). virtual . Read mean values from input stream. ; Implements TMVA::VariableTransformBase.; Definition at line 450 of file VariablePCATransform.cxx. ◆ Streamer(). virtual void TMVA::VariablePCATransform::Streamer ; (; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1VariablePCATransform.html:19623,allocate,allocated,19623,doc/master/classTMVA_1_1VariablePCATransform.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1VariablePCATransform.html,1,['allocate'],['allocated']
Energy Efficiency,"aries. Function documentation; ~VariableTransformBase(). void SelectInput(const TString& inputVariables, Bool_t putIntoVariables = kFALSE); select the variables/targets/spectators which serve as input to the transformation. Bool_t GetInput(const TMVA::Event* event, vector<Float_t>& input, vector<Char_t>& mask, Bool_t backTransform = kFALSE) const; select the values from the event. void SetOutput(TMVA::Event* event, vector<Float_t>& output, vector<Char_t>& mask, const TMVA::Event* oldEvent = 0, Bool_t backTransform = kFALSE) const; select the values from the event. void CountVariableTypes(UInt_t& nvars, UInt_t& ntgts, UInt_t& nspcts) const; count variables, targets and spectators. void CalcNorm(const vector<TMVA::Event*,allocator<TMVA::Event*> >& ); TODO --> adapt to variable,target,spectator selection; method to calculate minimum, maximum, mean, and RMS for all; variables used in the MVA. std::vector<TString>* GetTransformationStrings(Int_t cls) const; TODO --> adapt to variable,target,spectator selection; default transformation output; --> only indicate that transformation occurred. void UpdateNorm(Int_t ivar, Double_t x); TODO --> adapt to variable,target,spectator selection; update min and max of a given variable (target) and a given transformation method. void AttachXMLTo(void* parent); create XML description the transformation (write out info of selected variables). void ReadFromXML(void* trfnode); Read the input variables from the XML node. void MakeFunction(ostream& fout, const TString& fncName, Int_t part, UInt_t trCounter, Int_t cls); getinput and setoutput equivalent. void Initialize(). Bool_t PrepareTransformation(const vector<TMVA::Event*,allocator<TMVA::Event*> >& ). const Event* Transform(const TMVA::Event *const , Int_t cls) const. const Event* InverseTransform(const TMVA::Event *const , Int_t cls) const. void SetEnabled(Bool_t e); accessors. { fEnabled = e; }. void SetNormalise(Bool_t n); { fNormalise = n; }. Bool_t IsEnabled() const; { return fEnable",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__VariableTransformBase.html:9877,adapt,adapt,9877,root/html530/TMVA__VariableTransformBase.html,https://root.cern,https://root.cern/root/html530/TMVA__VariableTransformBase.html,2,['adapt'],['adapt']
Energy Efficiency,"arker) ;  ; static Style_t GetMarkerStyleBase (Style_t style);  Internal helper function that returns the corresponding marker style with line width 1 for the given style. ;  . Protected Member Functions; virtual Double_t ** Allocate (Int_t newsize);  Allocate internal data structures for newsize points. ;  ; Double_t ** AllocateArrays (Int_t Narrays, Int_t arraySize);  Allocate arrays. ;  ; virtual void CopyAndRelease (Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin);  Copy points from fX and fY to arrays[0] and arrays[1] or to fX and fY if arrays == 0 and ibegin != iend. ;  ; virtual Bool_t CopyPoints (Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin);  Copy points from fX and fY to arrays[0] and arrays[1] or to fX and fY if arrays == 0 and ibegin != iend. ;  ; Bool_t CtorAllocate ();  In constructors set fNpoints than call this method. ;  ; virtual Bool_t DoMerge (const TGraph *g);  protected function to perform the merge operation of a graph ;  ; Double_t ** ExpandAndCopy (Int_t size, Int_t iend);  if size > fMaxSize allocate new arrays of 2*size points and copy iend first points. ;  ; virtual void FillZero (Int_t begin, Int_t end, Bool_t from_ctor=kTRUE);  Set zero values for point arrays in the range [begin, end) Should be redefined in descendant classes. ;  ; TString SaveArray (std::ostream &out, const char *suffix, Int_t frameNumber, Double_t *arr);  Save array as C++ code Returns name of created array. ;  ; void SaveHistogramAndFunctions (std::ostream &out, const char *varname, Int_t &frameNumber, Option_t *option);  Save histogram and list of functions of TGraph as C++ statement Used in all TGraph-derived classes. ;  ; Double_t ** ShrinkAndCopy (Int_t size, Int_t iend);  if size*2 <= fMaxSize allocate new arrays of size points, copy points [0,oend). ;  ; virtual void SwapPoints (Int_t pos1, Int_t pos2);  Swap points. ;  ; virtual void UpdateArrays (const std::vector< Int_t > &sorting_indices, Int_t numSortedPoints, Int_t low);  Upda",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGraph.html:28918,allocate,allocate,28918,doc/master/classTGraph.html,https://root.cern,https://root.cern/doc/master/classTGraph.html,1,['allocate'],['allocate']
Energy Efficiency,"arrays[***] or to f*** Copy points. ; Reimplemented from TGraph.; Definition at line 777 of file TGraphMultiErrors.cxx. ◆ CtorAllocate(). Bool_t TGraphMultiErrors::CtorAllocate ; (; ). protected . Should be called from ctors after fNpoints has been set Note: This function should be called only from the constructor since it does not delete previously existing arrays. ; Definition at line 718 of file TGraphMultiErrors.cxx. ◆ DeclFileName(). static const char * TGraphMultiErrors::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 213 of file TGraphMultiErrors.h. ◆ DeleteYError(). void TGraphMultiErrors::DeleteYError ; (; Int_t ; e). virtual . Deletes the y error with the index e. ; Note that you must keep at least 1 error ; Definition at line 1422 of file TGraphMultiErrors.cxx. ◆ Divide(). void TGraphMultiErrors::Divide ; (; const TH1 * ; pass, . const TH1 * ; total, . Option_t * ; opt = ""cp"" . ). This function was adapted from the TGraphAsymmErrors class. ; See TGraphAsymmErrors::Divide for the documentation; Only the first error dimension is affected. ; Definition at line 1001 of file TGraphMultiErrors.cxx. ◆ DoMerge(). Bool_t TGraphMultiErrors::DoMerge ; (; const TGraph * ; tg). overrideprotectedvirtual . Protected function to perform the merge operation of a graph with multiple asymmetric errors. ; Reimplemented from TGraph.; Definition at line 838 of file TGraphMultiErrors.cxx. ◆ FillZero(). void TGraphMultiErrors::FillZero ; (; Int_t ; begin, . Int_t ; end, . Bool_t ; from_ctor = kTRUE . ). overrideprotectedvirtual . Set zero values for point arrays in the range [begin, end]. ; Reimplemented from TGraph.; Definition at line 802 of file TGraphMultiErrors.cxx. ◆ GetAttFill(). TAttFill * TGraphMultiErrors::GetAttFill ; (; Int_t ; e). virtual . Get AttFill pointer for specified error dimension. ; Definition at line 1621 of file TGraphMultiErrors.cxx. ◆ GetAttLine(). TAttLine * TGraphMultiErrors::GetAttLin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGraphMultiErrors.html:60659,adapt,adapted,60659,doc/master/classTGraphMultiErrors.html,https://root.cern,https://root.cern/doc/master/classTGraphMultiErrors.html,1,['adapt'],['adapted']
Energy Efficiency,"arse< Element >::AMinusB ; (; const TMatrixT< Element > & ; a, . const TMatrixTSparse< Element > & ; b, . Int_t ; constr = 0 . ). protected . General matrix subtraction. ; Replace this matrix with C such that C = A - B. Note, matrix C is allocated for constr=1. ; Definition at line 1151 of file TMatrixTSparse.cxx. ◆ AMinusB() [2/3]. template<class Element > . void TMatrixTSparse< Element >::AMinusB ; (; const TMatrixTSparse< Element > & ; a, . const TMatrixT< Element > & ; b, . Int_t ; constr = 0 . ). protected . General matrix subtraction. ; Replace this matrix with C such that C = A - B. Note, matrix C is allocated for constr=1. ; Definition at line 1080 of file TMatrixTSparse.cxx. ◆ AMinusB() [3/3]. template<class Element > . void TMatrixTSparse< Element >::AMinusB ; (; const TMatrixTSparse< Element > & ; a, . const TMatrixTSparse< Element > & ; b, . Int_t ; constr = 0 . ). protected . General matrix subtraction. ; Replace this matrix with C such that C = A - B. Note, matrix C is allocated for constr=1. ; Definition at line 998 of file TMatrixTSparse.cxx. ◆ AMultB() [1/3]. template<class Element > . void TMatrixTSparse< Element >::AMultB ; (; const TMatrixT< Element > & ; a, . const TMatrixTSparse< Element > & ; b, . Int_t ; constr = 0 . ). inlineprotected . Definition at line 54 of file TMatrixTSparse.h. ◆ AMultB() [2/3]. template<class Element > . void TMatrixTSparse< Element >::AMultB ; (; const TMatrixTSparse< Element > & ; a, . const TMatrixT< Element > & ; b, . Int_t ; constr = 0 . ). inlineprotected . Definition at line 51 of file TMatrixTSparse.h. ◆ AMultB() [3/3]. template<class Element > . void TMatrixTSparse< Element >::AMultB ; (; const TMatrixTSparse< Element > & ; a, . const TMatrixTSparse< Element > & ; b, . Int_t ; constr = 0 . ). inlineprotected . Definition at line 48 of file TMatrixTSparse.h. ◆ AMultBt() [1/3]. template<class Element > . void TMatrixTSparse< Element >::AMultBt ; (; const TMatrixT< Element > & ; a, . const TMatrixTSparse< Elemen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMatrixTSparse.html:34583,allocate,allocated,34583,doc/master/classTMatrixTSparse.html,https://root.cern,https://root.cern/doc/master/classTMatrixTSparse.html,1,['allocate'],['allocated']
Energy Efficiency,"article parameters at first point; Float_t px,py,pz,p,charge=0;; Float_t vout[7];; Float_t mass = 0.137;; Bool_t newParticle = kTRUE;; gstep->lmec = new Int_t[MAXMEC];; gstep->namec = new Int_t[MAXMEC];; gstep->step = 0.1;; gstep->destep = 0;; gstep->nmec = 0;; gstep->pid = 0;; ; //transport particles; for (Int_t i=0;i<10000;i++) {; //generate a new particle if necessary; if (newParticle) {; px = gRandom->Gaus(0,.02);; py = gRandom->Gaus(0,.02);; pz = gRandom->Gaus(0,.02);; p = TMath::Sqrt(px*px+py*py+pz*pz);; charge = 1; if (gRandom->Rndm() < 0.5) charge = -1;; gstep->pid += 1;; gstep->vect[0] = 0;; gstep->vect[1] = 0;; gstep->vect[2] = 0;; gstep->vect[3] = px/p;; gstep->vect[4] = py/p;; gstep->vect[5] = pz/p;; gstep->vect[6] = p*charge;; gstep->getot = TMath::Sqrt(p*p + mass*mass);; gstep->gekin = gstep->getot - mass;; newParticle = kFALSE;; }; ; // fill the Tree with current step parameters; t2.Fill();; ; //transport particle in magnetic field; helixStep(gstep->step, gstep->vect, vout); //make one step; ; //apply energy loss; gstep->destep = gstep->step*gRandom->Gaus(0.0002,0.00001);; gstep->gekin -= gstep->destep;; gstep->getot = gstep->gekin + mass;; gstep->vect[6] = charge*TMath::Sqrt(gstep->getot*gstep->getot - mass*mass);; gstep->vect[0] = vout[0];; gstep->vect[1] = vout[1];; gstep->vect[2] = vout[2];; gstep->vect[3] = vout[3];; gstep->vect[4] = vout[4];; gstep->vect[5] = vout[5];; gstep->nmec = (Int_t)(5*gRandom->Rndm());; for (Int_t l=0;l<gstep->nmec;l++) {; gstep->lmec[l] = l;; gstep->namec[l] = l+100;; }; if (gstep->gekin < 0.001) newParticle = kTRUE;; if (TMath::Abs(gstep->vect[2]) > 30) newParticle = kTRUE;; }; ; //save the Tree header. The file will be automatically closed; //when going out of the function scope; t2.Write();; }; ; void tree2ar(); {; //read the Tree generated by tree2w and fill one histogram; //we are only interested by the destep branch.; ; //note that we use ""new"" to create the TFile and TTree objects !; //because we want to keep the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tree2a_8C.html:3775,energy,energy,3775,doc/master/tree2a_8C.html,https://root.cern,https://root.cern/doc/master/tree2a_8C.html,1,['energy'],['energy']
Energy Efficiency,"as(""c2"",""c2"",500,300);; ; auto legend = new TLegend(0.2, 0.2, .8, .8);; auto h = new TH1F("""", """", 1, 0, 1);; ; legend->SetNColumns(2);; ; legend->AddEntry(h, ""Column 1 line 1"", ""l"");; legend->AddEntry(h, ""Column 2 line 1"", ""l"");; legend->AddEntry(h, ""Column 1 line 2"", ""l"");; legend->AddEntry(h, ""Column 2 line 2"", ""l"");; ; legend->Draw();; }; c3return c3Definition legend3.C:15. SinceROOT version 6.09/03; The legend can be placed automatically in the current pad in an empty space found at painting time.; The following example illustrate this facility. Only the width and height of the legend is specified in percentage of the pad size.; ; void legendautoplaced(); {; auto c4 = new TCanvas(""c"", ""c"", 600,500);; auto hpx = new TH1D(""hpx"",""This is the hpx distribution"",100,-4.,4.);; hpx->FillRandom(""gaus"", 50000);; hpx->Draw(""E"");; hpx->GetYaxis()->SetTitle(""Y Axis title"");; hpx->GetYaxis()->SetTitleOffset(1.3); hpx->GetYaxis()->CenterTitle(true);; hpx->GetXaxis()->SetTitle(""X Axis title"");; hpx->GetXaxis()->CenterTitle(true);; ; auto h1 = new TH1D(""h1"",""A green histogram"",100,-2.,2.);; h1->FillRandom(""gaus"", 10000);; h1->SetLineColor(kGreen);; h1->Draw(""same"");; ; auto g = new TGraph();; g->SetPoint(0, -3.5, 100 );; g->SetPoint(1, -3.0, 300 );; g->SetPoint(2, -2.0, 1000 );; g->SetPoint(3, 1.0, 800 );; g->SetPoint(4, 0.0, 200 );; g->SetPoint(5, 3.0, 200 );; g->SetPoint(6, 3.0, 700 );; g->Draw(""L"");; g->SetTitle(""This is a TGraph"");; g->SetLineColor(kRed);; g->SetFillColor(0);; ; // TPad::BuildLegend() default placement values are such that they trigger; // the automatic placement.; c4->BuildLegend();; }; g#define g(i)Definition RSha256.hxx:105; TGraphA TGraph is an object made of two arrays X and Y with npoints each.Definition TGraph.h:41; TH1D1-D histogram with a double per channel (see TH1 documentation)Definition TH1.h:670; . Definition at line 23 of file TLegend.h. Public Member Functions;  TLegend ();  Default constructor. ;  ;  TLegend (const TLegend &legend);  Copy con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTLegend.html:8330,green,green,8330,doc/master/classTLegend.html,https://root.cern,https://root.cern/doc/master/classTLegend.html,1,['green'],['green']
Energy Efficiency,"asConverged (double testError);  has this training converged already? ;  ; double learningRate () const;  get the learning rate ;  ; size_t maxConvergenceCount () const;  returns the max convergence count so far ;  ; size_t minError () const;  returns the smallest error so far ;  ; MinimizerType minimizerType () const;  which minimizer shall be used (e.g. SGD) ;  ; double momentum () const;  get the momentum (e.g. for SGD) ;  ; void pads (int numPads);  preparation for monitoring ;  ; void plot (std::string histoName, std::string options, int pad, EColor color);  for monitoring ;  ; EnumRegularization regularization () const;  some regularization of the DNN is turned on? ;  ; int repetitions () const;  how many steps have to be gone until the batch is changed ;  ; template<typename Iterator > ; void setDropOut (Iterator begin, Iterator end, size_t _dropRepetitions);  set the drop-out configuration (layer-wise) ;  ; void setMonitoring (std::shared_ptr< Monitoring > ptrMonitoring);  prepared for monitoring ;  ; virtual void setProgressLimits (double minProgress=0, double maxProgress=100);  ; virtual void startTestCycle ();  callback for monitoring and loggging ;  ; virtual void startTrainCycle ();  ; virtual void startTraining ();  ; virtual void testIteration ();  callback for monitoring and loggging ;  ; size_t testRepetitions () const;  how often is the test data tested ;  ; virtual void testSample (double, double, double, double);  virtual function to be used for monitoring (callback) ;  ; bool useMultithreading () const;  is multithreading turned on? ;  . Public Attributes; size_t count_dE;  ; size_t count_E;  ; size_t count_mb_dE;  ; size_t count_mb_E;  ; double fLearningRate;  ; MinimizerType fMinimizerType;  ; double fMomentum;  ; int fRepetitions;  ; size_t m_batchSize;  mini-batch size ;  ; size_t m_convergenceCount;  ; size_t m_convergenceSteps;  number of steps without improvement to consider the DNN to have converged ;  ; std::vector< double > m_dropOut;  ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1Settings.html:2661,monitor,monitoring,2661,doc/master/classTMVA_1_1DNN_1_1Settings.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1Settings.html,6,['monitor'],['monitoring']
Energy Efficiency,"ase 84:; 3316 {; 3317 Double_t red[9] = { 5./255., 18./255., 45./255., 124./255., 193./255., 223./255., 205./255., 128./255., 49./255.};; 3318 Double_t green[9] = { 48./255., 134./255., 207./255., 230./255., 193./255., 113./255., 28./255., 0./255., 7./255.};; 3319 Double_t blue[9] = { 6./255., 15./255., 41./255., 121./255., 193./255., 226./255., 208./255., 130./255., 49./255.};; 3320 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3321 }; 3322 break;; 3323 ; 3324 // Island; 3325 case 85:; 3326 {; 3327 Double_t red[9] = { 180./255., 106./255., 104./255., 135./255., 164./255., 188./255., 189./255., 165./255., 144./255.};; 3328 Double_t green[9] = { 72./255., 126./255., 154./255., 184./255., 198./255., 207./255., 205./255., 190./255., 179./255.};; 3329 Double_t blue[9] = { 41./255., 120./255., 158./255., 188./255., 194./255., 181./255., 145./255., 100./255., 62./255.};; 3330 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3331 }; 3332 break;; 3333 ; 3334 // Lake; 3335 case 86:; 3336 {; 3337 Double_t red[9] = { 57./255., 72./255., 94./255., 117./255., 136./255., 154./255., 174./255., 192./255., 215./255.};; 3338 Double_t green[9] = { 0./255., 33./255., 68./255., 109./255., 140./255., 171./255., 192./255., 196./255., 209./255.};; 3339 Double_t blue[9] = { 116./255., 137./255., 173./255., 201./255., 200./255., 201./255., 203./255., 190./255., 187./255.};; 3340 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3341 }; 3342 break;; 3343 ; 3344 // Light Temperature; 3345 case 87:; 3346 {; 3347 Double_t red[9] = { 31./255., 71./255., 123./255., 160./255., 210./255., 222./255., 214./255., 199./255., 183./255.};; 3348 Double_t green[9] = { 40./255., 117./255., 171./255., 211./255., 231./255., 220./255., 190./255., 132./255., 65./255.};; 3349 Double_t blue[9] = { 234./255., 214./255., 228./255., 222./255., 210./255., 160./255., 105./255., 60./255., 34./255.};; 3350 Idx = TColor::Creat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TColor_8cxx_source.html:129709,green,green,129709,doc/master/TColor_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html,1,['green'],['green']
Energy Efficiency,"ase class information; * @param nth base class; * @return pointer to base class information. Type ByName(const string& key). * ByName will look for a type given as a string and return it's; * reflection type information; * @param key fully qualified name of the type as string; * @return reflection type information. Type ByTypeInfo(const type_info& tid). * ByTypeInfo will look for a type given as a; * std::type_info and return its reflection information; * @param tid std::type_info to look for; * @return reflection information of type. Object CastObject(const Reflex::Type& to, const Reflex::Object& obj) const. * CastObject an object from this class type to another one; * @param to is the class type to cast into; * @param obj the memory address of the object to be casted. Member DataMemberAt(size_t nth, Reflex::EMEMBERQUERY inh = INHERITEDMEMBERS_DEFAULT) const. * Construct will call the constructor of a given type and allocate; * the memory for it; * @param signature of the constructor; * @param values for parameters of the constructor; * @param mem place in memory for implicit construction; * @return new object. Object Construct( const Type & signature,; const std::vector < Object > & values,; void * mem = 0 ) const;. * DataMemberAt will return the nth data member of the type; * @param nth the nth data member; * @return nth data member. Type DynamicType(const Reflex::Object& obj) const. * DynamicType is used to discover the dynamic type (useful in; * case of polymorphism); * @param mem is the memory address of the object to checked; * @return the actual class of the object. Member FunctionMemberAt(size_t nth, Reflex::EMEMBERQUERY inh = INHERITEDMEMBERS_DEFAULT) const. * FunctionMemberAt will return the nth function member of the type; * @param nth function member; * @return reflection information of nth function member. void GenerateDict(Reflex::DictionaryGenerator& generator) const. * GenerateDict will produce the dictionary information of this type; * @param genera",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/Reflex__Type.html:13915,allocate,allocate,13915,root/html526/Reflex__Type.html,https://root.cern,https://root.cern/root/html526/Reflex__Type.html,5,['allocate'],['allocate']
Energy Efficiency,"ase::fTsumwx2total sum of weight*X*X for each dimension. private:. TObjArrayfBinContentarray of THnSparseArrayChunk; TExMapfBins! filled bins; TExMapfBinsContinued! filled bins for non-unique hashes, containing pairs of (bin index 0, bin index 1); Int_tfChunkSizenumber of entries for each chunk; THnSparseCompactBinCoord*fCompactCoord! compact coordinate; Long64_tfFilledBinsnumber of filled bins. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~THnSparse(); Destruct a THnSparse. void AddBinContent(Long64_t bin, Double_t v = 1.); Add ""v"" to the content of bin with index ""bin"". THnSparseArrayChunk* AddChunk(); Create a new chunk of bin content. void InitStorage(Int_t* nbins, Int_t chunkSize); Initialize the storage of a histogram created via Init(). void FillExMap(); We have been streamed; set up fBins. void Reserve(Long64_t nbins); Initialize storage for nbins. Long64_t GetBin(const Double_t* x, Bool_t allocate = kTRUE); Get the bin index for the n dimensional tuple x,; allocate one if it doesn't exist yet and ""allocate"" is true. Long64_t GetBin(const char* name[], Bool_t allocate /* = kTRUE */); Get the bin index for the n dimensional tuple addressed by ""name"",; allocate one if it doesn't exist yet and ""allocate"" is true. Long64_t GetBin(const Int_t* idx, Bool_t allocate = kTRUE); Get the bin index for the n dimensional coordinates coord,; allocate one if it doesn't exist yet and ""allocate"" is true. Double_t GetBinContent(Long64_t bin, Int_t* idx = 0) const; Return the content of the filled bin number ""idx"".; If coord is non-null, it will contain the bin's coordinates for each axis; that correspond to the bin. Double_t GetBinError2(Long64_t linidx) const; Get square of the error of bin addressed by linidx as. If errors are not enabled (via Sumw2() or CalculateErrors()); return contents. Long64_t GetBinIndexForCurrentBin(Bool_t allocate); Return the index for fCurrentBinIndex.; If it doesn't exist then return -1, or allocate ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/THnSparse.html:16874,allocate,allocate,16874,root/html534/THnSparse.html,https://root.cern,https://root.cern/root/html534/THnSparse.html,3,['allocate'],['allocate']
Energy Efficiency,"aseBinIter* CreateIter(Bool_t respectAxisRange) const override;; 54 Long64_t GetNbins() const override { return GetArray().GetNbins(); }; 55 ; 56 Long64_t GetBin(const Int_t* idx) const override {; 57 return GetArray().GetBin(idx);; 58 }; 59 Long64_t GetBin(const Double_t* x) const override {; 60 if (fCoordBuf.empty()); 61 AllocCoordBuf();; 62 for (Int_t d = 0; d < fNdimensions; ++d) {; 63 fCoordBuf[d] = GetAxis(d)->FindFixBin(x[d]);; 64 }; 65 return GetArray().GetBin(fCoordBuf.data());; 66 }; 67 Long64_t GetBin(const char* name[]) const override {; 68 if (fCoordBuf.empty()); 69 AllocCoordBuf();; 70 for (Int_t d = 0; d < fNdimensions; ++d) {; 71 fCoordBuf[d] = GetAxis(d)->FindBin(name[d]);; 72 }; 73 return GetArray().GetBin(fCoordBuf.data());; 74 }; 75 ; 76 Long64_t GetBin(const Int_t* idx, Bool_t /*allocate*/ = kTRUE) override {; 77 return const_cast<const THn*>(this)->GetBin(idx);; 78 }; 79 Long64_t GetBin(const Double_t* x, Bool_t /*allocate*/ = kTRUE) override {; 80 return const_cast<const THn*>(this)->GetBin(x);; 81 }; 82 Long64_t GetBin(const char* name[], Bool_t /*allocate*/ = kTRUE) override {; 83 return const_cast<const THn*>(this)->GetBin(name);; 84 }; 85 ; 86 /// Increment the bin content of ""bin"" by ""w"", return the bin index.; 87 void FillBin(Long64_t bin, Double_t w) override {; 88 GetArray().AddAt(bin, w);; 89 if (GetCalculateErrors()) {; 90 fSumw2.AddAt(bin, w * w);; 91 }; 92 FillBinBase(w);; 93 }; 94 ; 95 /// Forwards to THnBase::SetBinContent().; 96 /// Non-virtual, CINT-compatible replacement of a using declaration.; 97 void SetBinContent(const Int_t* idx, Double_t v) {; 98 THnBase::SetBinContent(idx, v);; 99 }; 100 void SetBinContent(Long64_t bin, Double_t v) override {; 101 GetArray().SetAsDouble(bin, v);; 102 }; 103 void SetBinError2(Long64_t bin, Double_t e2) override {; 104 if (!GetCalculateErrors()) Sumw2();; 105 fSumw2.At(bin) = e2;; 106 }; 107 /// Forwards to THnBase::SetBinContent().; 108 /// Non-virtual, CINT-compatible replacement of a us",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THn_8h_source.html:2485,allocate,allocate,2485,doc/master/THn_8h_source.html,https://root.cern,https://root.cern/doc/master/THn_8h_source.html,3,['allocate'],['allocate']
Energy Efficiency,"asha Murat. ; -* for CLHEP see: http://wwwinfo.cern.ch/asd/lhc++/clhep/ ; -* Adaption to ROOT by Peter Malzacher ; *. ; TLorentzVector; TLorentzVector is a general four-vector class, which can be used; either for the description of position and time (x,y,z,t) or momentum and; energy (px,py,pz,E).;  . Declaration; TLorentzVector has been implemented as a set a TVector3 and a Double_t variable.; By default all components are initialized by zero.;   TLorentzVector v1;      // initialized; by (0., 0., 0., 0.);   TLorentzVector v2(1., 1., 1., 1.);;   TLorentzVector v3(v1);;   TLorentzVector v4(TVector3(1., 2., 3.),4.);; For backward compatibility there are two constructors from an Double_t; and Float_t  C array.;  . Access to the components; There are two sets of access functions to the components of a LorentzVector:; X(), Y(), Z(), T() and Px(),; Py(), Pz() and E(). Both sets return the same values; but the first set is more relevant for use where TLorentzVector; describes a combination of position and time and the second set is more; relevant where TLorentzVector describes momentum and energy:;   Double_t xx =v.X();;   ...;   Double_t tt = v.T();;   Double_t px = v.Px();;   ...;   Double_t ee = v.E();; The components of TLorentzVector can also accessed by index:;   xx = v(0);       or    ; xx = v[0];;   yy = v(1);             ; yy = v[1];;   zz = v(2);             ; zz = v[2];;   tt = v(3);             ; tt = v[3];; You can use the Vect() member function to get the vector component; of TLorentzVector:;   TVector3 p = v.Vect();; For setting components also two sets of member functions can be used:; SetX(),.., SetPx(),..:;  ;   v.SetX(1.);        or   ; v.SetPx(1.);;   ...                              ; ...;   v.SetT(1.);             ; v.SetE(1.);; To set more the one component by one call you can use the SetVect(); function for the TVector3 part or SetXYZT(), SetPxPyPzE(). For convenience there is; also a SetXYZM():;   v.SetVect(TVector3(1,2,3));;   v.SetXYZT(x,y,z,t);;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TLorentzVector.html:1774,energy,energy,1774,root/html528/TLorentzVector.html,https://root.cern,https://root.cern/root/html528/TLorentzVector.html,6,['energy'],['energy']
Energy Efficiency,"asket.h:34; TBasket::DropBuffersvirtual Int_t DropBuffers()Drop buffers of this basket if it is not the current basket.Definition TBasket.cxx:173; TBasket::GetBufferSizeInt_t GetBufferSize() constDefinition TBasket.h:122; TBasket::EIOBits::kSupported@ kSupported; TBranchClonesA Branch for the case of an array of clone objects.Definition TBranchClones.h:29; TBranchElementA Branch for the case of an object.Definition TBranchElement.h:39; TBranchElement::IsObjectOwnervirtual bool IsObjectOwner() constDefinition TBranchElement.h:213; TBranchElement::SetBranchFoldervirtual void SetBranchFolder()Definition TBranchElement.h:226; TBranchElement::Classstatic TClass * Class(); TBranchElement::GetClassVersionInt_t GetClassVersion()Definition TBranchElement.h:210; TBranchElement::GetClassNameconst char * GetClassName() const overrideReturn the name of the user class whose content is stored in this branch, if any.Definition TBranchElement.h:186; TBranchElement::ResetAddressvoid ResetAddress() overrideSet branch address to zero and free all allocated memory.Definition TBranchElement.cxx:4780; TBranchElement::UnrollInt_t Unroll(const char *name, TClass *cltop, TClass *cl, char *ptr, Int_t basketsize, Int_t splitlevel, Int_t btype)Split class cl into sub-branches of this branch.Definition TBranchElement.cxx:6212; TBranchElement::SetAddressvoid SetAddress(void *addobj) overridePoint this branch at an object.Definition TBranchElement.cxx:4962; TBranchElement::SetTargetClassvirtual void SetTargetClass(const char *name)Set the name of the class of the in-memory object into which the data will loaded.Definition TBranchElement.cxx:5855; TBranchElement::GetCheckSumUInt_t GetCheckSum()Definition TBranchElement.h:185; TBranchElement::SetObjectvoid SetObject(void *objadd) overrideSet object this branch is pointing to.Definition TBranchElement.cxx:5575; TBranchObjectA Branch for the case of an object.Definition TBranchObject.h:26; TBranchRefA branch containing and managing a TRefTable for TRe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:392290,allocate,allocated,392290,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['allocate'],['allocated']
Energy Efficiency,ass = fM; }. Scalar Pt() const; --------- Coordinates and Coordinate-like Scalar properties -------------; 4-D Cylindrical eta coordinate accessors. { return fPt; }. Scalar Eta() const; { return fEta; }. Scalar Phi() const. M() is the invariant mass;; in this coordinate system it can be negagative if set that way. { return fPhi; }. Scalar M() const; { return fM; }. Scalar Mag() const; { return M(); }. Scalar Perp() const; { return Pt(); }. Scalar Rho() const; { return Pt(); }. Scalar Px() const; other coordinate representation. { return fPt*cos(fPhi);}. Scalar X() const; { return Px(); }. Scalar Py() const; { return fPt*sin(fPhi);}. Scalar Y() const; { return Py(); }. Scalar Pz() const. Scalar Z() const; { return Pz(); }. Scalar P() const. magnitude of momentum. Scalar R() const; { return P(); }. Scalar P2() const. squared magnitude of spatial components (momentum squared). { Scalar p = P(); return p*p; }. Scalar E2() const. energy squared. Scalar E() const. Energy (timelike component of momentum-energy 4-vector). { return std::sqrt(E2() ); }. Scalar T() const; { return E(); }. Scalar M2() const. vector magnitude squared (or mass squared); In case of negative mass (spacelike particles return negative values). Scalar Mag2() const; { return M2(); }. Scalar Pt2() const. transverse spatial component squared. { return fPt*fPt;}. Scalar Perp2() const; { return Pt2(); }. Scalar Mt2() const. transverse mass squared. { return M2() + fPt*fPt; }. Scalar Mt() const. transverse mass - will be negative if Mt2() is negative. Scalar Et2() const. transverse energy squared. Scalar Et() const. transverse energy. Scalar pi(); { return M_PI; }. void RestrictNegMass(); restrict the value of negative mass to avoid unphysical negative E2 values; M2 must be less than P2 for the tachionic particles - otherwise use positive values. Scalar Theta() const. polar angle. void SetPt(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar pt); --------- Set Coordinates of this system ---------------. set Pt valu,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__PtEtaPhiM4D_Double32_t_.html:6843,energy,energy,6843,root/html526/ROOT__Math__PtEtaPhiM4D_Double32_t_.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__PtEtaPhiM4D_Double32_t_.html,5,['energy'],['energy']
Energy Efficiency,ass = fM; }. Scalar Pt() const; --------- Coordinates and Coordinate-like Scalar properties -------------; 4-D Cylindrical eta coordinate accessors. { return fPt; }. Scalar Eta() const; { return fEta; }. Scalar Phi() const. M() is the invariant mass;; in this coordinate system it can be negagative if set that way. { return fPhi; }. Scalar M() const; { return fM; }. Scalar Mag() const; { return M(); }. Scalar Perp() const; { return Pt(); }. Scalar Rho() const; { return Pt(); }. Scalar Px() const; other coordinate representation. { return fPt*cos(fPhi);}. Scalar X() const; { return Px(); }. Scalar Py() const; { return fPt*sin(fPhi);}. Scalar Y() const; { return Py(); }. Scalar Pz() const. Scalar Z() const; { return Pz(); }. Scalar P() const. magnitude of momentum. Scalar R() const; { return P(); }. Scalar P2() const. squared magnitude of spatial components (momentum squared). { Scalar p = P(); return p*p; }. Scalar E2() const. energy squared. Scalar E() const. Energy (timelike component of momentum-energy 4-vector). { return std::sqrt(E2() ); }. Scalar T() const; { return E(); }. Scalar M2() const. vector magnitude squared (or mass squared); In case of negative mass (spacelike particles return negative values). Scalar Mag2() const; { return M2(); }. Scalar Pt2() const. transverse spatial component squared. { return fPt*fPt;}. Scalar Perp2() const; { return Pt2(); }. Scalar Mt2() const. transverse mass squared. { return M2() + fPt*fPt; }. Scalar Mt() const. transverse mass - will be negative if Mt2() is negative. Scalar Et2() const. transverse energy squared. Scalar Et() const. transverse energy. Scalar pi(); { return M_PI; }. void RestrictNegMass(); restrict the value of negative mass to avoid unphysical negative E2 values; M2 must be less than P2 for the tachionic particles - otherwise use positive values. Scalar Theta() const. polar angle. void SetPt(ROOT::Math::PtEtaPhiM4D<double>::Scalar pt); --------- Set Coordinates of this system ---------------. set Pt value. v,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__PtEtaPhiM4D_double_.html:6483,energy,energy,6483,root/html526/ROOT__Math__PtEtaPhiM4D_double_.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__PtEtaPhiM4D_double_.html,5,['energy'],['energy']
Energy Efficiency,"ass ROOT::Math::RanluxppEngine< p >Implementation of the RANLUX++ generator. ; RANLUX++ is an LCG equivalent of RANLUX using 576 bit numbers.; The idea of the generator (such as the initialization method) and the algorithm for the modulo operation are described in A. Sibidanov, A revision of the subtract-with-borrow random numbergenerators, Computer Physics Communications*, 221(2017), 299-303, preprint https://arxiv.org/pdf/1705.03123.pdf; The code is loosely based on the Assembly implementation by A. Sibidanov available at https://github.com/sibidanov/ranluxpp/.; Compared to the original generator, this implementation contains a fix to ensure that the modulo operation of the LCG always returns the smallest value congruent to the modulus (based on notes by M. Lüscher). Also, the generator converts the LCG state back to RANLUX numbers (implementation based on notes by M. Lüscher). This avoids a bias in the generated numbers because the upper bits of the LCG state, that is smaller than the modulus \( m = 2^{576} - 2^{240} + 1 \) (not a power of 2!), have a higher probability of being 0 than 1. And finally, this implementation draws 48 random bits for each generated floating point number (instead of 52 bits as in the original generator) to maintain the theoretical properties from understanding the original transition function of RANLUX as a chaotic dynamical system. ; Definition at line 27 of file RanluxppEngine.h. Public Member Functions;  RanluxppEngine (uint64_t seed=314159265);  ;  ~RanluxppEngine () override;  ; uint64_t IntRndm ();  Generate a random integer value with 48 bits. ;  ; double operator() ();  Generate a double-precision random number (non-virtual method) ;  ; double Rndm () override;  Generate a double-precision random number with 48 bits of randomness. ;  ; void SetSeed (uint64_t seed);  Initialize and seed the state of the generator. ;  ; void Skip (uint64_t n);  Skip n random numbers without generating them. ;  ;  Public Member Functions inherited",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1RanluxppEngine.html:1426,power,power,1426,doc/master/classROOT_1_1Math_1_1RanluxppEngine.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1RanluxppEngine.html,1,['power'],['power']
Energy Efficiency,"ass constructor is called using; New(). If not, return a pointer to the correct memory location.; This explicitly to deal with TObject classes that allocate memory; which will be reset (but not deallocated) in their Clear(); functions. void Clear(Option_t* option = """"); Clear the clones array. Only use this routine when your objects don't; allocate memory since it will not call the object dtors.; However, if the class in the TClonesArray implements the function; Clear(Option_t *option) and if option = ""C"" the function Clear(); is called for all objects in the array. In the function Clear(), one; can delete objects or dynamic arrays allocated in the class.; This procedure is much faster than calling TClonesArray::Delete().; When the option starts with ""C+"", eg ""C+xyz"" the objects in the array; are in turn cleared with the option ""xyz"". void Delete(Option_t* option = """"); Clear the clones array. Use this routine when your objects allocate; memory (e.g. objects inheriting from TNamed or containing TStrings; allocate memory). If not you better use Clear() since if is faster. void Expand(Int_t newSize); Expand or shrink the array to newSize elements. void ExpandCreate(Int_t n); Expand or shrink the array to n elements and create the clone; objects by calling their default ctor. If n is less than the current size; the array is shrunk and the allocated space is freed.; This routine is typically used to create a clonesarray into which; one can directly copy object data without going via the; ""new (arr[i]) MyObj()"" (i.e. the vtbl is already set correctly). void ExpandCreateFast(Int_t n); Expand or shrink the array to n elements and create the clone; objects by calling their default ctor. If n is less than the current size; the array is shrinked but the allocated space is _not_ freed.; This routine is typically used to create a clonesarray into which; one can directly copy object data without going via the; ""new (arr[i]) MyObj()"" (i.e. the vtbl is already set correctly).; This",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TClonesArray.html:20013,allocate,allocate,20013,root/html532/TClonesArray.html,https://root.cern,https://root.cern/root/html532/TClonesArray.html,4,['allocate'],['allocate']
Energy Efficiency,"ass_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TMVA::VariableTransformBase; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Additional Inherited Members;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TMVA::VariableTransformBase; void CalcNorm (const std::vector< const Event * > &);  TODO --> adapt to variable,target,spectator selection method to calculate minimum, maximum, mean, and RMS for all variables used in the MVA. ;  ; Int_t GetNClasses () const;  ; UInt_t GetNSpectators () const;  ; UInt_t GetNTargets () const;  ; UInt_t GetNVariables () const;  ; void SetCreated (Bool_t c=kTRUE);  ; void SetName (const TString &c);  ; void SetNVariables (UInt_t i);  ; std::vector< TMVA::VariableInfo > & Spectators ();  ; std::vector< TMVA::VariableInfo > & Targets ();  ; std::vector< TMVA::VariableInfo > & Variables ();  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Attributes inherited from TMVA::VariableTransformBase; Event * fBackTransformedEvent;  holds the current back-transformed event ;  ; DataSetInfo & fDsi;  ; DataSetInfo * fDsiOutput; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1VariableRearrangeTransform.html:13180,adapt,adapt,13180,doc/master/classTMVA_1_1VariableRearrangeTransform.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1VariableRearrangeTransform.html,1,['adapt'],['adapt']
Energy Efficiency,"assificationSettings(). virtual TMVA::DNN::ClassificationSettings::~ClassificationSettings ; (; ). inlinevirtual . d'tor ; Definition at line 924 of file NeuralNet.h. Member Function Documentation. ◆ endTestCycle(). void TMVA::DNN::ClassificationSettings::endTestCycle ; (; ). virtual . action to be done when the training cycle is ended (e.g. ; update some monitoring output) ; Reimplemented from TMVA::DNN::Settings.; Definition at line 326 of file NeuralNet.cxx. ◆ endTrainCycle(). void TMVA::DNN::ClassificationSettings::endTrainCycle ; (; double ; ). virtual . action to be done when the training cycle is ended (e.g. ; update some monitoring output) ; Reimplemented from TMVA::DNN::Settings.; Definition at line 296 of file NeuralNet.cxx. ◆ setResultComputation(). void TMVA::DNN::ClassificationSettings::setResultComputation ; (; std::string ; _fileNameNetConfig, . std::string ; _fileNameResult, . std::vector< Pattern > * ; _resultPatternContainer . ). preparation for monitoring output ; Definition at line 520 of file NeuralNet.cxx. ◆ setWeightSums(). void TMVA::DNN::ClassificationSettings::setWeightSums ; (; double ; sumOfSigWeights, . double ; sumOfBkgWeights . ). set the weight sums to be scaled to (preparations for monitoring output) ; Definition at line 512 of file NeuralNet.cxx. ◆ startTestCycle(). void TMVA::DNN::ClassificationSettings::startTestCycle ; (; ). virtual . action to be done when the test cycle is started (e.g. ; update some monitoring output) ; Reimplemented from TMVA::DNN::Settings.; Definition at line 316 of file NeuralNet.cxx. ◆ startTrainCycle(). void TMVA::DNN::ClassificationSettings::startTrainCycle ; (; ). virtual . action to be done when the training cycle is started (e.g. ; update some monitoring output) ; Reimplemented from TMVA::DNN::Settings.; Definition at line 281 of file NeuralNet.cxx. ◆ testIteration(). void TMVA::DNN::ClassificationSettings::testIteration ; (; ). inlinevirtual . callback for monitoring and loggging ; Reimplemented fro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1ClassificationSettings.html:8090,monitor,monitoring,8090,doc/master/classTMVA_1_1DNN_1_1ClassificationSettings.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1ClassificationSettings.html,1,['monitor'],['monitoring']
Energy Efficiency,"astHelper< unsigned short, unsigned short >;  CSwizzledVector;  CVector;  CVectorHelper;  CVectorHelper< _M128 >;  CVectorHelper< _M128D >;  CVectorHelper< _M128I >;  CVectorHelper< double >;  CVectorHelper< float >;  CVectorHelper< float8 >;  CVectorHelper< int >;  CVectorHelper< M256 >;  CVectorHelper< signed short >;  CVectorHelper< unsigned int >;  CVectorHelper< unsigned short >;  CVectorHelperSize;  CVectorTraits;  CVectorTypeHelper;  CVectorTypeHelper< double >;  CVectorTypeHelper< float >;  CVectorTypeHelper< sfloat >;  CWriteMaskedVector;  C_MemorySizeCalculation;  CBinaryOperation;  CCpuIdThis class is available for x86 / AMD64 systems to read and interpret information about the CPU's capabilities ;  CDetermineEntryType;  CDetermineEntryType< sfloat >;  CImplementationT;  CMath;  CMath< double >;  CMath< float >;  CMemoryA helper class for fixed-size two-dimensional arrays ;  CMemory< V, 0u, 0u >A helper class that is very similar to Memory<V, Size> but with dynamically allocated memory and thus dynamic size ;  CMemory< V, Size, 0u >A helper class to simplify usage of correctly aligned and padded memory, allowing both vector and scalar access ;  CMemoryBaseCommon interface to all Memory classes, independent of allocation on the stack or heap ;  CMemoryDimensionBase;  CMemoryDimensionBase< V, Parent, 1, RowMemory >;  CMemoryDimensionBase< V, Parent, 2, RowMemory >;  CNegateTypeHelper;  CNegateTypeHelper< unsigned char >;  CNegateTypeHelper< unsigned int >;  CNegateTypeHelper< unsigned short >;  COperand;  Csfloat;  CTrigonometric;  CVectorPointerHelperHelper class for the Memory::vector(size_t) class of functions ;  CVectorPointerHelperConstHelper class for the Memory::vector(size_t) class of functions ;  C_ConfigurationConfiguration ------------------------------------------------------------— ;  C_ExpandMacroFunctionPut std namespace directly onto ROOT ----------------------------------—— ;  CModuleFacadeAllow loading ROOT classes as attributes ----------",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html606/annotated.html:68080,allocate,allocated,68080,root/html606/annotated.html,https://root.cern,https://root.cern/root/html606/annotated.html,1,['allocate'],['allocated']
Energy Efficiency,"asymmetric, and may perform better in the presence of strong correlations. Bool_t plotSanityChecks(RooPlot* frame) const; Utility function for plotOn(), perform general sanity check on frame to ensure safe plotting operations. void makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; Utility function for plotOn() that constructs the set of; observables to project when plotting ourselves as function of; 'plotVar'. 'allVars' is the list of variables that must be; projected, but may contain variables that we do not depend on. If; 'silent' is cleared, warnings about inconsistent input parameters; will be printed. Bool_t isSelectedComp() const; If true, the current pdf is a selected component (for use in plotting). void globalSelectComp(Bool_t flag); Global switch controlling the activation of the selectComp() functionality. RooAbsFunc * bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; Create an interface adaptor f(vars) that binds us to the specified variables; (in arbitrary order). For example, calling bindVars({x1,x3}) on an object; F(x1,x2,x3,x4) returns an object f(x1,x3) that is evaluated using the; current values of x2 and x4. The caller takes ownership of the returned adaptor. void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE); Copy the cached value of another RooAbsArg to our cache.; Warning: This function copies the cached values of source,; it is the callers responsibility to make sure the cache is clean. void attachToTree(TTree& t, Int_t bufSize = 32000); Attach object to a branch of given TTree. By default it will; register the internal value cache RooAbsReal::_value as branch; buffer for a Double_t tree branch with the same name as this; object. If no Double_t branch is found with the name of this; object, this method looks for a Float_t Int_t, UChar_t and UInt_t; branch in that order. If any of these are found the buffer for; that ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsReal.html:55239,adapt,adaptor,55239,root/html526/RooAbsReal.html,https://root.cern,https://root.cern/root/html526/RooAbsReal.html,3,['adapt'],['adaptor']
Energy Efficiency,"asymmetric, and may perform better in the presence of strong correlations. Bool_t plotSanityChecks(RooPlot* frame) const; Utility function for plotOn(), perform general sanity check on frame to ensure safe plotting operations. void makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; Utility function for plotOn() that constructs the set of; observables to project when plotting ourselves as function of; 'plotVar'. 'allVars' is the list of variables that must be; projected, but may contain variables that we do not depend on. If; 'silent' is cleared, warnings about inconsistent input parameters; will be printed. Bool_t isSelectedComp() const; If true, the current pdf is a selected component (for use in plotting). void globalSelectComp(Bool_t flag); Global switch controlling the activation of the selectComp() functionality. RooAbsFunc * bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; Create an interface adaptor f(vars) that binds us to the specified variables; (in arbitrary order). For example, calling bindVars({x1,x3}) on an object; F(x1,x2,x3,x4) returns an object f(x1,x3) that is evaluated using the; current values of x2 and x4. The caller takes ownership of the returned adaptor. void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE, Bool_t setValDirty = kTRUE); Copy the cached value of another RooAbsArg to our cache.; Warning: This function copies the cached values of source,; it is the callers responsibility to make sure the cache is clean. void attachToVStore(RooVectorDataStore& vstore). void attachToTree(TTree& t, Int_t bufSize = 32000); Attach object to a branch of given TTree. By default it will; register the internal value cache RooAbsReal::_value as branch; buffer for a Double_t tree branch with the same name as this; object. If no Double_t branch is found with the name of this; object, this method looks for a Float_t Int_t, UChar_t and ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsReal.html:56754,adapt,adaptor,56754,root/html532/RooAbsReal.html,https://root.cern,https://root.cern/root/html532/RooAbsReal.html,4,['adapt'],['adaptor']
Energy Efficiency,"at can be made such that the error between linear-helix extrapolation is less than EPSIL. ;  ; const Double_t * GetCurrentDirection () const;  ; const Double_t * GetCurrentPoint () const;  ; Double_t GetStep () const;  ; Double_t GetTotalCurvature () const;  Compute helix total curvature. ;  ; Double_t GetXYcurvature () const;  ; void InitDirection (Double_t *dir, Bool_t is_normalized=kTRUE);  Initialize particle direction (tangent on the helix in initial point) ;  ; void InitDirection (Double_t dirx, Double_t diry, Double_t dirz, Bool_t is_normalized=kTRUE);  Initialize particle direction (tangent on the helix in initial point) ;  ; void InitPoint (Double_t *point);  Set initial point on the helix. ;  ; void InitPoint (Double_t x0, Double_t y0, Double_t z0);  Initialize coordinates of a point on the helix. ;  ; TClass * IsA () const override;  ; Bool_t IsRightHanded () const;  ; void ResetStep ();  Reset current point/direction to initial values. ;  ; void SetCharge (Int_t charge);  Positive charge means left-handed helix. ;  ; void SetField (Double_t bx, Double_t by, Double_t bz, Bool_t is_normalized=kTRUE);  Initialize particle direction (tangent on the helix in initial point) ;  ; void SetHelixStep (Double_t hstep);  Set Z step of the helix on a complete turn. Positive or null. ;  ; void SetXYcurvature (Double_t curvature);  Set XY curvature: c = 1/Rxy. ;  ; void Step (Double_t step);  Make a step from current point along the helix and compute new point, direction and angle To reach a plane/ shape boundary, one has to: ;  ; Double_t StepToPlane (Double_t *point, Double_t *norm);  Propagate initial point up to a given Z position in MARS. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void UpdateHelix ();  Update the local helix matrix. ;  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoHelix.html:3767,charge,charge,3767,doc/master/classTGeoHelix.html,https://root.cern,https://root.cern/doc/master/classTGeoHelix.html,2,['charge'],['charge']
Energy Efficiency,"at contains all; 8193/// the data for a (consecutive) set of entries and that is stored; 8194/// consecutively on the disk. When reading all the branches, this; 8195/// is the minimum set of baskets that the TTreeCache will read.; 8196 ; 8197void TTree::SetAutoFlush(Long64_t autof /* = -30000000 */ ); 8198{; 8199 // Implementation note:; 8200 //; 8201 // A positive value of autoflush determines the size (in number of entries) of; 8202 // a cluster of baskets.; 8203 //; 8204 // If the value of autoflush is changed over time (this happens in; 8205 // particular when the TTree results from fast merging many trees),; 8206 // we record the values of fAutoFlush in the data members:; 8207 // fClusterRangeEnd and fClusterSize.; 8208 // In the code we refer to a range of entries where the size of the; 8209 // cluster of baskets is the same (i.e the value of AutoFlush was; 8210 // constant) is called a ClusterRange.; 8211 //; 8212 // The 2 arrays (fClusterRangeEnd and fClusterSize) have fNClusterRange; 8213 // active (used) values and have fMaxClusterRange allocated entries.; 8214 //; 8215 // fClusterRangeEnd contains the last entries number of a cluster range.; 8216 // In particular this means that the 'next' cluster starts at fClusterRangeEnd[]+1; 8217 // fClusterSize contains the size in number of entries of all the cluster; 8218 // within the given range.; 8219 // The last range (and the only one if fNClusterRange is zero) start at; 8220 // fNClusterRange[fNClusterRange-1]+1 and ends at the end of the TTree. The; 8221 // size of the cluster in this range is given by the value of fAutoFlush.; 8222 //; 8223 // For example printing the beginning and end of each the ranges can be done by:; 8224 //; 8225 // Printf(""%-16s %-16s %-16s %5s"",; 8226 // ""Cluster Range #"", ""Entry Start"", ""Last Entry"", ""Size"");; 8227 // Int_t index= 0;; 8228 // Long64_t clusterRangeStart = 0;; 8229 // if (fNClusterRange) {; 8230 // for( ; index < fNClusterRange; ++index) {; 8231 // Printf(""%-16d %-16l",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:319446,allocate,allocated,319446,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['allocate'],['allocated']
Energy Efficiency,at line 1168 of file MethodPDERS.cxx. Member Data Documentation. ◆ fAverageRMS. std::vector<Float_t> TMVA::MethodPDERS::fAverageRMS. private . average RMS of signal and background ; Definition at line 181 of file MethodPDERS.h. ◆ fBinaryTree. BinarySearchTree* TMVA::MethodPDERS::fBinaryTree. private . binary tree ; Definition at line 177 of file MethodPDERS.h. ◆ fDelta. std::vector<Float_t>* TMVA::MethodPDERS::fDelta. private . size of volume ; Definition at line 179 of file MethodPDERS.h. ◆ fDeltaFrac. Float_t TMVA::MethodPDERS::fDeltaFrac. private . fraction of RMS ; Definition at line 185 of file MethodPDERS.h. ◆ fFcnCall. Int_t TMVA::MethodPDERS::fFcnCall. protected . Definition at line 113 of file MethodPDERS.h. ◆ fGaussSigma. Double_t TMVA::MethodPDERS::fGaussSigma. private . size of Gauss in adaptive volume ; Definition at line 186 of file MethodPDERS.h. ◆ fGaussSigmaNorm. Double_t TMVA::MethodPDERS::fGaussSigmaNorm. private . size of Gauss in adaptive volume (normalised to dimensions) ; Definition at line 187 of file MethodPDERS.h. ◆ fHelpVolume. Volume* TMVA::MethodPDERS::fHelpVolume. protected . Definition at line 112 of file MethodPDERS.h. ◆ fInitializedVolumeEle. Bool_t TMVA::MethodPDERS::fInitializedVolumeEle. private . is volume element initialized ? ; Definition at line 197 of file MethodPDERS.h. ◆ fInitialScale. Float_t TMVA::MethodPDERS::fInitialScale. private . initial scale for adaptive volume ; Definition at line 195 of file MethodPDERS.h. ◆ fKernelEstimator. enum TMVA::MethodPDERS::EKernelEstimator TMVA::MethodPDERS::fKernelEstimator. private . ◆ fKernelString. TString TMVA::MethodPDERS::fKernelString. private . Definition at line 149 of file MethodPDERS.h. ◆ fkNNMax. Int_t TMVA::MethodPDERS::fkNNMax. private . max number of events in kNN tree ; Definition at line 200 of file MethodPDERS.h. ◆ fkNNMin. Int_t TMVA::MethodPDERS::fkNNMin. private . min number of events in kNN tree ; Definition at line 199 of file MethodPDERS.h. ◆ fMax_distance. Doub,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodPDERS.html:45314,adapt,adaptive,45314,doc/master/classTMVA_1_1MethodPDERS.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodPDERS.html,1,['adapt'],['adaptive']
Energy Efficiency,"at line 82 of file THnSparse.h. ◆ DeclFileName(). static const char * THnSparse::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 169 of file THnSparse.h. ◆ FillBin(). void THnSparse::FillBin ; (; Long64_t ; bin, . Double_t ; w . ). inlineoverrideprotectedvirtual . Increment the bin content of ""bin"" by ""w"", return the bin index. ; Implements THnBase.; Definition at line 67 of file THnSparse.h. ◆ FillExMap(). void THnSparse::FillExMap ; (; ). protected . We have been streamed; set up fBins. ; Definition at line 655 of file THnSparse.cxx. ◆ GenerateArray(). virtual TArray * THnSparse::GenerateArray ; (; ); const. protectedpure virtual . Implemented in THnSparseT< CONT >. ◆ GetBin() [1/6]. Long64_t THnSparse::GetBin ; (; const char * ; name[]); const. inlineoverridevirtual . Implements THnBase.; Definition at line 98 of file THnSparse.h. ◆ GetBin() [2/6]. Long64_t THnSparse::GetBin ; (; const char * ; name[], . Bool_t ; allocate = kTRUE . ). overridevirtual . Get the bin index for the n dimensional tuple addressed by ""name"", allocate one if it doesn't exist yet and ""allocate"" is true. ; Implements THnBase.; Definition at line 718 of file THnSparse.cxx. ◆ GetBin() [3/6]. Long64_t THnSparse::GetBin ; (; const Double_t * ; x); const. inlineoverridevirtual . Implements THnBase.; Definition at line 97 of file THnSparse.h. ◆ GetBin() [4/6]. Long64_t THnSparse::GetBin ; (; const Double_t * ; x, . Bool_t ; allocate = kTRUE . ). overridevirtual . Get the bin index for the n dimensional tuple x, allocate one if it doesn't exist yet and ""allocate"" is true. ; Implements THnBase.; Definition at line 702 of file THnSparse.cxx. ◆ GetBin() [5/6]. Long64_t THnSparse::GetBin ; (; const Int_t * ; idx); const. inlineoverridevirtual . Implements THnBase.; Definition at line 96 of file THnSparse.h. ◆ GetBin() [6/6]. Long64_t THnSparse::GetBin ; (; const Int_t * ; idx, . Bool_t ; allocate = kTRUE . ). overridevirtual . Get the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHnSparse.html:33243,allocate,allocate,33243,doc/master/classTHnSparse.html,https://root.cern,https://root.cern/doc/master/classTHnSparse.html,1,['allocate'],['allocate']
Energy Efficiency,"at line 91 of file KDEKernel.h. ◆ DeclFileName(). static const char * TMVA::KDEKernel::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 91 of file KDEKernel.h. ◆ GetBinKernelIntegral(). Float_t TMVA::KDEKernel::GetBinKernelIntegral ; (; Float_t ; lowr, . Float_t ; highr, . Float_t ; mean, . Int_t ; binnum . ). calculates the integral of the Kernel ; Definition at line 217 of file KDEKernel.cxx. ◆ GetName(). const char * TMVA::KDEKernel::GetName ; (; ); const. inline . Definition at line 71 of file KDEKernel.h. ◆ IsA(). virtual TClass * TMVA::KDEKernel::IsA ; (; ); const. inlinevirtual . ReturnsTClass describing current object ; Definition at line 91 of file KDEKernel.h. ◆ Log(). MsgLogger & TMVA::KDEKernel::Log ; (; ); const. inlineprivate . Definition at line 89 of file KDEKernel.h. ◆ SetKernelType(). void TMVA::KDEKernel::SetKernelType ; (; EKernelType ; ktype = kGauss). fIter == 1 —> nonadaptive KDE fIter == 2 —> adaptive KDE ; Definition at line 112 of file KDEKernel.cxx. ◆ Streamer(). virtual void TMVA::KDEKernel::Streamer ; (; TBuffer & ; ). virtual . ◆ StreamerNVirtual(). void TMVA::KDEKernel::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 91 of file KDEKernel.h. Member Data Documentation. ◆ fFineFactor. Float_t TMVA::KDEKernel::fFineFactor. private . fine tuning factor for Adaptive KDE: factor to multiply the ""width"" of the Kernel function ; Definition at line 79 of file KDEKernel.h. ◆ fFirstIterHist. TH1F* TMVA::KDEKernel::fFirstIterHist. private . histogram to be filled in the hidden iteration ; Definition at line 83 of file KDEKernel.h. ◆ fHiddenIteration. Bool_t TMVA::KDEKernel::fHiddenIteration. private . Defines if whats currently running is the. ; Definition at line 85 of file KDEKernel.h. ◆ fHist. TH1F* TMVA::KDEKernel::fHist. private . copy of input histogram ; Definition at line 82 of file KDEKernel.h. ◆ fIter. EKernelIter TMVA::KDEKernel::f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1KDEKernel.html:4708,adapt,adaptive,4708,doc/master/classTMVA_1_1KDEKernel.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1KDEKernel.html,1,['adapt'],['adaptive']
Energy Efficiency,"at once; multi.bin - perform several requests at once, return result in binary form. All data will be automatically zipped if ‘.gz’ extension is appended. Like:; [shell] wget http://localhost:8080/Objects/subfolder/obj/root.json.gz; If the access to the server is restricted with htdigest, it is recommended to use the curl program since only curl correctly implements such authentication method. The command will look like:; [shell] curl --user ""accout:password"" http://localhost:8080/Objects/subfolder/obj/root.json --digest -o root.json; 1.7.1 Objects data access in JSON format; Request root.json implemented with TBufferJSON class. TBufferJSON generates such object representation, which could be directly used in JSROOT for drawing. root.json request returns either complete object or just object member like:; [shell] wget http://localhost:8080/Objects/subfolder/obj/fTitle/root.json; The result will be: “title”.; For the root.json request one could specify the ‘compact’ parameter, which allow to reduce the number of spaces and new lines without data lost. This parameter can have values from ‘0’ (no compression) till ‘3’ (no spaces and new lines at all).; Usage of root.json request is about as efficient as binary root.bin request. Comparison of different request methods with TH1 object shown in the table:. Request; Size. root.bin; 1658 bytes. root.bin.gz; 782 bytes. root.json; 7555 bytes. root.json?compact=3; 5381 bytes. root.json.gz?compact=3; 1207 bytes. One should remember that JSON representation always includes names of the data fields which are not present in the binary representation. Even then the size difference is negligible.; root.json used in JSROOT to request objects from THttpServer.; 1.7.2 Generating images out of objects; For the ROOT classes which are implementing Draw method (like TH1 or TGraph) one could produce images with requests: root.png, root.gif, root.jpeg. For example:; wget ""http://localhost:8080/Files/hsimple.root/hpx/root.png?w=500&h=500&opt=l",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/HttpServer/HttpServer.html:11492,reduce,reduce,11492,root/html534/guides/HttpServer/HttpServer.html,https://root.cern,https://root.cern/root/html534/guides/HttpServer/HttpServer.html,1,['reduce'],['reduce']
Energy Efficiency,"at represent sometimes thousands of parameters.; the calculation of the inversion matrix of such a size is practically impossible.; the awmi method is based on the assumption that off-diagonal terms in the matrix A are equal to zero. \[; \Delta a_{k}^{(t+1)} = \alpha^{(t)}; \frac{; \sum_{i=1}^{N} \frac{e_{i}^{(t)}}{y_i}\frac{\partial f(i,a^{(t)})}{\partial a_k}; }{; \sum_{i=1}^{N} \left[ \frac{\partial f(i,a^{(t)})}{\partial a_k}\right]^2\frac{1}{y_i}; }; \]; where the error in the channel \(i\) is \(e_{i}^{(t)} = y_i-f(i,a^{(t)}); k=1,2,...,M\) and \(\alpha^{(t)}=1\) if the process is convergent or \(\alpha^{(t)}=0.5 \alpha^{(t-1)}\) if it is divergent. Another possibility is to optimize this coefficient.; the error of \(k\)-th parameter estimate is; \[; \Delta a_k^{(e)}=; \sqrt{\frac; {\sum_{i=1}^{N}\frac{e_i^2}{y_i}}; {\sum_{i=1}^{N} \left[ \frac{\partial f(i,a^{(t)})}{\partial a_k}\right]^2\frac{1}{y_i}}; }; \]; algorithm with higher powers w=1,2,3…; \[; \Delta a_{k,w}^{(t+1)}=; \alpha^{(t)}; \frac; {\sum_{i=1}^{N} \frac{e_i}{y_i}\left[ \frac{\partial f(i,a^{(t)})}{\partial a_k}\right]^{2w-1}}; {\sum_{i=1}^{N} \left[ \frac{\partial f(i,a^{(t)})}{\partial a_k}\right]^{2w}\frac{1}{y_i}}; \]; we have implemented the nonsymmetrical semiempirical peak shape function.; it contains the symmetrical Gaussian as well as nonsymmetrical terms.; \[; f(i,a) =; \sum_{i=1}^{M} A(j); \left\{; exp\left[\frac{-(i-p(j))^2}{2\sigma^2}\right]; +\frac{1}{2}T.exp\left[\frac{(i-p(j))}{B\sigma}\right]; .erfc\left[\frac{(i-p(j))}{\sigma}+\frac{1}{2B}\right]; +\frac{1}{2}S.erfc\left[\frac{(i-p(j))}{\sigma}\right]; \right\}; \]; where \(T,S\) are relative amplitudes and \(B\) is a slope.; Detailed description of the algorithm is given in [13].; The fitting function implementing the algorithm without matrix inversion has the form; char* Fit1Awmi(float *source,; TSpectrumOneDimFit *p,; int size);; This function fits the source spectrum. The calling program should fill in input parameters of th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/spectrum/Spectrum.html:37010,power,powers,37010,root/html534/guides/spectrum/Spectrum.html,https://root.cern,https://root.cern/root/html534/guides/spectrum/Spectrum.html,1,['power'],['powers']
Energy Efficiency,"at). TMatrixTBase<Element> &TMatrixTSparse<Element> InsertRow(Int_t row, Int_t col, const float* v, Int_t n = -1); Insert in row rown, n elements of array v at column coln. void TMatrixTSparse<Element> ExtractRow(Int_t row, Int_t col, float* v, Int_t n = -1) const; Store in array v, n matrix elements of row rown starting at column coln. void TMatrixTSparse<Element> AMultBt(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMultBt(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMultBt(const TMatrixT<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixT<Element> &a,const TMatrixTSparse<E",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMatrixTSparse_float_.html:17988,allocate,allocated,17988,root/html528/TMatrixTSparse_float_.html,https://root.cern,https://root.cern/root/html528/TMatrixTSparse_float_.html,6,['allocate'],['allocated']
Energy Efficiency,"at_t TGWin32::fCharacterUpY. protected . Character Up vector along Y. ; Definition at line 117 of file TGWin32.h. ◆ fColormap. GdkColormap* TGWin32::fColormap. protected . Default colormap, 0 if b/w. ; Definition at line 109 of file TGWin32.h. ◆ fColors. TExMap* TGWin32::fColors. private . Hash list of colors. ; Definition at line 81 of file TGWin32.h. ◆ fCursors. GdkCursor* TGWin32::fCursors[kNumCursors]. private . List of cursors. ; Definition at line 82 of file TGWin32.h. ◆ fDepth. Int_t TGWin32::fDepth. protected . Number of color planes. ; Definition at line 119 of file TGWin32.h. ◆ fFillColorModified. Bool_t TGWin32::fFillColorModified. protected . Definition at line 129 of file TGWin32.h. ◆ fFillStyleModified. Bool_t TGWin32::fFillStyleModified. protected . Definition at line 130 of file TGWin32.h. ◆ fGreenDiv. Int_t TGWin32::fGreenDiv. protected . Green value divider. ; Definition at line 121 of file TGWin32.h. ◆ fGreenShift. Int_t TGWin32::fGreenShift. protected . Bits to left shift green. ; Definition at line 124 of file TGWin32.h. ◆ fHasTTFonts. Bool_t TGWin32::fHasTTFonts. protected . True when TrueType fonts are used. ; Definition at line 111 of file TGWin32.h. ◆ fLineColorModified. Bool_t TGWin32::fLineColorModified. protected . Definition at line 131 of file TGWin32.h. ◆ fMarkerColorModified. Bool_t TGWin32::fMarkerColorModified. protected . Definition at line 134 of file TGWin32.h. ◆ fMarkerStyleModified. Bool_t TGWin32::fMarkerStyleModified. protected . Definition at line 133 of file TGWin32.h. ◆ fMaxNumberOfWindows. Int_t TGWin32::fMaxNumberOfWindows. private . Maximum number of windows. ; Definition at line 79 of file TGWin32.h. ◆ fPenModified. Bool_t TGWin32::fPenModified. protected . line syle || width modified ; Definition at line 132 of file TGWin32.h. ◆ fRedDiv. Int_t TGWin32::fRedDiv. protected . Red value divider, -1 if no TrueColor visual. ; Definition at line 120 of file TGWin32.h. ◆ fRedShift. Int_t TGWin32::fRedShift. protected . Bits t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGWin32.html:123867,green,green,123867,doc/master/classTGWin32.html,https://root.cern,https://root.cern/doc/master/classTGWin32.html,1,['green'],['green']
Energy Efficiency,"at_t h4 = field*2.99792e-4;; Float_t rho = -h4/vect[kPP];; Float_t tet = rho*step;; Float_t tsint = tet*tet/6;; Float_t sintt = 1 - tsint;; Float_t sint = tet*sintt;; Float_t cos1t = tet/2;; Float_t f1 = step*sintt;; Float_t f2 = step*cos1t;; Float_t f3 = step*tsint*vect[kPZ];; Float_t f4 = -tet*cos1t;; Float_t f5 = sint;; Float_t f6 = tet*cos1t*vect[kPZ];; vout[kX] = vect[kX] + (f1*vect[kPX] - f2*vect[kPY]);; vout[kY] = vect[kY] + (f1*vect[kPY] + f2*vect[kPX]);; vout[kZ] = vect[kZ] + (f1*vect[kPZ] + f3);; vout[kPX] = vect[kPX] + (f4*vect[kPX] - f5*vect[kPY]);; vout[kPY] = vect[kPY] + (f4*vect[kPY] + f5*vect[kPX]);; vout[kPZ] = vect[kPZ] + (f4*vect[kPZ] + f6);; }; ; void tree2aw(); {; //create a Tree file tree2.root; ; //create the file, the Tree and a few branches with; //a subset of gctrak; TFile f(""tree2.root"",""recreate"");; TTree t2(""t2"",""a Tree with data from a fake Geant3"");; Gctrak *gstep = new Gctrak;; t2.Branch(""track"",&gstep,8000,1);; ; //Initialize particle parameters at first point; Float_t px,py,pz,p,charge=0;; Float_t vout[7];; Float_t mass = 0.137;; Bool_t newParticle = kTRUE;; gstep->lmec = new Int_t[MAXMEC];; gstep->namec = new Int_t[MAXMEC];; gstep->step = 0.1;; gstep->destep = 0;; gstep->nmec = 0;; gstep->pid = 0;; ; //transport particles; for (Int_t i=0;i<10000;i++) {; //generate a new particle if necessary; if (newParticle) {; px = gRandom->Gaus(0,.02);; py = gRandom->Gaus(0,.02);; pz = gRandom->Gaus(0,.02);; p = TMath::Sqrt(px*px+py*py+pz*pz);; charge = 1; if (gRandom->Rndm() < 0.5) charge = -1;; gstep->pid += 1;; gstep->vect[0] = 0;; gstep->vect[1] = 0;; gstep->vect[2] = 0;; gstep->vect[3] = px/p;; gstep->vect[4] = py/p;; gstep->vect[5] = pz/p;; gstep->vect[6] = p*charge;; gstep->getot = TMath::Sqrt(p*p + mass*mass);; gstep->gekin = gstep->getot - mass;; newParticle = kFALSE;; }; ; // fill the Tree with current step parameters; t2.Fill();; ; //transport particle in magnetic field; helixStep(gstep->step, gstep->vect, vout); //make one step; ; //",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tree2a_8C.html:2797,charge,charge,2797,doc/master/tree2a_8C.html,https://root.cern,https://root.cern/doc/master/tree2a_8C.html,1,['charge'],['charge']
Energy Efficiency,"ata = generateBinnedAsimov(expo, x, 10000); ; # If you do the fit the usual was in RooFit, you will get a bias in the; # result. This is because the continuous, normalized pdf is evaluated only; # at the bin centers.; fit1 = expo.fitTo(expo_data, Save=True, PrintLevel=-1, SumW2Error=False); fit1.Print(); ; # In the case of an exponential function, the bias that you get by; # evaluating the pdf only at the bin centers is a constant scale factor in; # each bin. Here, we can do a trick to get rid of the bias: we also; # evaluate the normalization integral for the pdf the same way, i.e.,; # summing the values of the unnormalized pdf at the bin centers. Like this; # the bias cancels out. You can achieve this by customizing the way how the; # pdf is integrated (see also the rf901_numintconfig tutorial).; enableBinIntegrator(expo, x.numBins()); fit2 = expo.fitTo(expo_data, Save=True, PrintLevel=-1, SumW2Error=False); fit2.Print(); disableBinIntegrator(expo); ; # Power law example; # -----------------; ; # Let's not look at another example: a power law \f[x^a\f].; a = ROOT.RooRealVar(""a"", ""a"", -0.3, -5.0, 5.0); powerlaw = ROOT.RooPowerSum(""powerlaw"", ""powerlaw"", x, ROOT.RooFit.RooConst(1.0), a); powerlaw_data = generateBinnedAsimov(powerlaw, x, 10000); ; # Again, if you do a vanilla fit, you'll get a bias; fit3 = powerlaw.fitTo(powerlaw_data, Save=True, PrintLevel=-1, SumW2Error=False); fit3.Print(); ; # This time, the bias is not the same factor in each bin! This means our; # trick by sampling the integral in the same way doesn't cancel out the; # bias completely. The average bias is canceled, but there are per-bin; # biases that remain. Still, this method has some value: it is cheaper than; # rigurously correcting the bias by integrating the pdf in each bin. So if; # you know your per-bin bias variations are small or performance is an; # issue, this approach can be sufficient.; enableBinIntegrator(powerlaw, x.numBins()); fit4 = powerlaw.fitTo(powerlaw_data, Save=True, Pri",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf614__binned__fit__problems_8py.html:3936,power,power,3936,doc/master/rf614__binned__fit__problems_8py.html,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8py.html,1,['power'],['power']
Energy Efficiency,"ata > RooAbsData::reduce ; (; const char * ; cut); const. Create a subset of the data set by applying the given cut on the data points. ; The cut expression can refer to any variable in the data set. For cuts involving other variables, such as intermediate formula objects, use the equivalent reduce method specifying the as a RooFormulVar reference. ; Definition at line 472 of file RooAbsData.cxx. ◆ reduce() [2/5]. RooFit::OwningPtr< RooAbsData > RooAbsData::reduce ; (; const RooArgSet & ; varSubset, . const char * ; cut = nullptr . ); const. Create a subset of the data set by applying the given cut on the data points and reducing the dimensions to the specified set. ; The cut expression can refer to any variable in the data set. For cuts involving other variables, such as intermediate formula objects, use the equivalent reduce method specifying the as a RooFormulVar reference. ; Definition at line 500 of file RooAbsData.cxx. ◆ reduce() [3/5]. RooFit::OwningPtr< RooAbsData > RooAbsData::reduce ; (; const RooArgSet & ; varSubset, . const RooFormulaVar & ; cutVar . ); const. Create a subset of the data set by applying the given cut on the data points and reducing the dimensions to the specified set. ; The 'cutVar' formula variable is used to select the subset of data points to be retained in the reduced data collection. ; Definition at line 530 of file RooAbsData.cxx. ◆ reduce() [4/5]. RooFit::OwningPtr< RooAbsData > RooAbsData::reduce ; (; const RooCmdArg & ; arg1, . const RooCmdArg & ; arg2 = {}, . const RooCmdArg & ; arg3 = {}, . const RooCmdArg & ; arg4 = {}, . const RooCmdArg & ; arg5 = {}, . const RooCmdArg & ; arg6 = {}, . const RooCmdArg & ; arg7 = {}, . const RooCmdArg & ; arg8 = {} . ); const. Create a reduced copy of this dataset. ; The caller takes ownership of the returned dataset; The following optional named arguments are accepted . SelectVars(const RooArgSet& vars) Only retain the listed observables in the output dataset . Cut(const char* expression) Onl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsData.html:62966,reduce,reduce,62966,doc/master/classRooAbsData.html,https://root.cern,https://root.cern/doc/master/classRooAbsData.html,1,['reduce'],['reduce']
Energy Efficiency,"ata.cxx. ◆ reduce() [1/5]. RooFit::OwningPtr< RooAbsData > RooAbsData::reduce ; (; const char * ; cut); const. Create a subset of the data set by applying the given cut on the data points. ; The cut expression can refer to any variable in the data set. For cuts involving other variables, such as intermediate formula objects, use the equivalent reduce method specifying the as a RooFormulVar reference. ; Definition at line 472 of file RooAbsData.cxx. ◆ reduce() [2/5]. RooFit::OwningPtr< RooAbsData > RooAbsData::reduce ; (; const RooArgSet & ; varSubset, . const char * ; cut = nullptr . ); const. Create a subset of the data set by applying the given cut on the data points and reducing the dimensions to the specified set. ; The cut expression can refer to any variable in the data set. For cuts involving other variables, such as intermediate formula objects, use the equivalent reduce method specifying the as a RooFormulVar reference. ; Definition at line 500 of file RooAbsData.cxx. ◆ reduce() [3/5]. RooFit::OwningPtr< RooAbsData > RooAbsData::reduce ; (; const RooArgSet & ; varSubset, . const RooFormulaVar & ; cutVar . ); const. Create a subset of the data set by applying the given cut on the data points and reducing the dimensions to the specified set. ; The 'cutVar' formula variable is used to select the subset of data points to be retained in the reduced data collection. ; Definition at line 530 of file RooAbsData.cxx. ◆ reduce() [4/5]. RooFit::OwningPtr< RooAbsData > RooAbsData::reduce ; (; const RooCmdArg & ; arg1, . const RooCmdArg & ; arg2 = {}, . const RooCmdArg & ; arg3 = {}, . const RooCmdArg & ; arg4 = {}, . const RooCmdArg & ; arg5 = {}, . const RooCmdArg & ; arg6 = {}, . const RooCmdArg & ; arg7 = {}, . const RooCmdArg & ; arg8 = {} . ); const. Create a reduced copy of this dataset. ; The caller takes ownership of the returned dataset; The following optional named arguments are accepted . SelectVars(const RooArgSet& vars) Only retain the listed observables i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsData.html:62906,reduce,reduce,62906,doc/master/classRooAbsData.html,https://root.cern,https://root.cern/doc/master/classRooAbsData.html,1,['reduce'],['reduce']
Energy Efficiency,"ataset. ; Reimplemented from RooPrintable.; Definition at line 783 of file RooAbsData.cxx. ◆ printTitle(). void RooAbsData::printTitle ; (; std::ostream & ; os); const. overridevirtual . Print title of dataset. ; Reimplemented from RooPrintable.; Definition at line 791 of file RooAbsData.cxx. ◆ RecursiveRemove(). void RooAbsData::RecursiveRemove ; (; TObject * ; obj). overridevirtual . If one of the TObject we have a referenced to is deleted, remove the reference. ; Reimplemented from TObject.; Definition at line 2458 of file RooAbsData.cxx. ◆ reduce() [1/5]. RooFit::OwningPtr< RooAbsData > RooAbsData::reduce ; (; const char * ; cut); const. Create a subset of the data set by applying the given cut on the data points. ; The cut expression can refer to any variable in the data set. For cuts involving other variables, such as intermediate formula objects, use the equivalent reduce method specifying the as a RooFormulVar reference. ; Definition at line 472 of file RooAbsData.cxx. ◆ reduce() [2/5]. RooFit::OwningPtr< RooAbsData > RooAbsData::reduce ; (; const RooArgSet & ; varSubset, . const char * ; cut = nullptr . ); const. Create a subset of the data set by applying the given cut on the data points and reducing the dimensions to the specified set. ; The cut expression can refer to any variable in the data set. For cuts involving other variables, such as intermediate formula objects, use the equivalent reduce method specifying the as a RooFormulVar reference. ; Definition at line 500 of file RooAbsData.cxx. ◆ reduce() [3/5]. RooFit::OwningPtr< RooAbsData > RooAbsData::reduce ; (; const RooArgSet & ; varSubset, . const RooFormulaVar & ; cutVar . ); const. Create a subset of the data set by applying the given cut on the data points and reducing the dimensions to the specified set. ; The 'cutVar' formula variable is used to select the subset of data points to be retained in the reduced data collection. ; Definition at line 530 of file RooAbsData.cxx. ◆ reduce() [4/5]. Ro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsData.html:62367,reduce,reduce,62367,doc/master/classRooAbsData.html,https://root.cern,https://root.cern/doc/master/classRooAbsData.html,1,['reduce'],['reduce']
Energy Efficiency,"ate . the matrix of covariance 'between class' reflects the dispersion of the events of a class relative to the global center of gravity of all the class hence the separation between classes ; Definition at line 417 of file MethodFisher.cxx. ◆ GetCov_Full(). void TMVA::MethodFisher::GetCov_Full ; (; void ; ). private . compute full covariance matrix from sum of within and between matrices ; Definition at line 440 of file MethodFisher.cxx. ◆ GetCov_WithinClass(). void TMVA::MethodFisher::GetCov_WithinClass ; (; void ; ). private . the matrix of covariance 'within class' reflects the dispersion of the events relative to the center of gravity of their own class ; Definition at line 351 of file MethodFisher.cxx. ◆ GetDiscrimPower(). void TMVA::MethodFisher::GetDiscrimPower ; (; void ; ). private . computation of discrimination power indicator for each variable small values of ""fWith"" indicates little compactness of sig & of backgd big values of ""fBetw"" indicates large separation between sig & backgd ; we want signal & backgd classes as compact and separated as possible the discriminating power is then defined as the ration ""fBetw/fWith"" ; Definition at line 528 of file MethodFisher.cxx. ◆ GetFisherCoeff(). void TMVA::MethodFisher::GetFisherCoeff ; (; void ; ). private . Fisher = Sum { [coeff]*[variables] }. ; let Xs be the array of the mean values of variables for signal evts let Xb be the array of the mean values of variables for backgd evts let InvWith be the inverse matrix of the 'within class' correlation matrix; then the array of Fisher coefficients is [coeff] =sqrt(fNsig*fNbgd)/fNevt*transpose{Xs-Xb}*InvWith ; Definition at line 457 of file MethodFisher.cxx. ◆ GetFisherMethod(). EFisherMethod TMVA::MethodFisher::GetFisherMethod ; (; void ; ). inline . Definition at line 87 of file MethodFisher.h. ◆ GetHelpMessage(). void TMVA::MethodFisher::GetHelpMessage ; (; ); const. protectedvirtual . get help message text ; typical length of text line: ""|----------------------",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodFisher.html:35745,power,power,35745,doc/master/classTMVA_1_1MethodFisher.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodFisher.html,2,['power'],['power']
Energy Efficiency,"ate a lego plot fot the top volume, according to option. ; Definition at line 1332 of file TGeoVolume.cxx. ◆ MakeCopyNodes(). void TGeoVolume::MakeCopyNodes ; (; const TGeoVolume * ; other). make a new list of nodes and copy all nodes of other volume inside ; Definition at line 1908 of file TGeoVolume.cxx. ◆ MakeCopyVolume(). TGeoVolume * TGeoVolume::MakeCopyVolume ; (; TGeoShape * ; newshape). virtual . make a copy of this volume build a volume with same name, shape and medium ; Reimplemented in TGeoVolumeMulti.; Definition at line 1928 of file TGeoVolume.cxx. ◆ MakeReflectedVolume(). TGeoVolume * TGeoVolume::MakeReflectedVolume ; (; const char * ; newname = """"); const. Make a copy of this volume which is reflected with respect to XY plane. ; Definition at line 1958 of file TGeoVolume.cxx. ◆ operator=(). TGeoVolume & TGeoVolume::operator= ; (; const TGeoVolume & ; ). privatedelete . ◆ OptimizeVoxels(). Bool_t TGeoVolume::OptimizeVoxels ; (; ). Perform an extensive sampling to find which type of voxelization is most efficient. ; Definition at line 1247 of file TGeoVolume.cxx. ◆ Paint(). void TGeoVolume::Paint ; (; Option_t * ; option = """"). overridevirtual . paint volume ; Reimplemented from TObject.; Definition at line 1267 of file TGeoVolume.cxx. ◆ Print(). void TGeoVolume::Print ; (; Option_t * ; option = """"); const. overridevirtual . Print volume info. ; Reimplemented from TObject.; Definition at line 1257 of file TGeoVolume.cxx. ◆ PrintNodes(). void TGeoVolume::PrintNodes ; (; ); const. print nodes ; Definition at line 1320 of file TGeoVolume.cxx. ◆ PrintVoxels(). void TGeoVolume::PrintVoxels ; (; ); const. Print the voxels for this volume. ; Definition at line 1282 of file TGeoVolume.cxx. ◆ RandomPoints(). void TGeoVolume::RandomPoints ; (; Int_t ; npoints = 1000000, . Option_t * ; option = """" . ). Draw random points in the bounding box of this volume. ; Definition at line 1392 of file TGeoVolume.cxx. ◆ RandomRays(). void TGeoVolume::RandomRays ; (; Int_t ; nr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoVolume.html:60013,efficient,efficient,60013,doc/master/classTGeoVolume.html,https://root.cern,https://root.cern/doc/master/classTGeoVolume.html,1,['efficient'],['efficient']
Energy Efficiency,"ate reference distributions (PDFs) from signal and background events: fill histograms and smooth them; if decorrelation is required, compute corresponding square-root matrices the reference histograms require the correct boundaries. ;  ; void WriteMonitoringHistosToFile () const;  write histograms and PDFs to file for monitoring purposes ;  ; virtual void WriteOptionsToStream (std::ostream &o, const TString &prefix) const;  write options to stream ;  ; void WriteWeightsToStream (TFile &rf) const;  write reference PDFs to ROOT file ;  ;  Public Member Functions inherited from TMVA::MethodBase;  MethodBase (const TString &jobName, Types::EMVA methodType, const TString &methodTitle, DataSetInfo &dsi, const TString &theOption="""");  standard constructor ;  ;  MethodBase (Types::EMVA methodType, DataSetInfo &dsi, const TString &weightFile);  constructor used for Testing + Application of the MVA, only (no training), using given WeightFiles ;  ; virtual ~MethodBase ();  destructor ;  ; void AddOutput (Types::ETreeType type, Types::EAnalysisType analysisType);  ; TDirectory * BaseDir () const;  returns the ROOT directory where info/histograms etc of the corresponding MVA method instance are stored ;  ; virtual void CheckSetup ();  check may be overridden by derived class (sometimes, eg, fitters are used which can only be implemented during training phase) ;  ; DataSet * Data () const;  ; DataSetInfo & DataInfo () const;  ; void DisableWriting (Bool_t setter);  ; Bool_t DoMulticlass () const;  ; Bool_t DoRegression () const;  ; void ExitFromTraining ();  ; Types::EAnalysisType GetAnalysisType () const;  ; UInt_t GetCurrentIter ();  ; virtual Double_t GetEfficiency (const TString &, Types::ETreeType, Double_t &err);  fill background efficiency (resp. ;  ; const Event * GetEvent () const;  ; const Event * GetEvent (const TMVA::Event *ev) const;  ; const Event * GetEvent (Long64_t ievt) const;  ; const Event * GetEvent (Long64_t ievt, Types::ETreeType type) const;  ; const std::v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodLikelihood.html:4593,monitor,monitoring,4593,doc/master/classTMVA_1_1MethodLikelihood.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodLikelihood.html,1,['monitor'],['monitoring']
Energy Efficiency,"ateOnTheFly);  Returns the specialized integrator configuration for this RooAbsReal. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from RooAbsReal;  RooAbsReal ();  coverity[UNINIT_CTOR] Default constructor ;  ;  RooAbsReal (const char *name, const char *title, const char *unit="""");  Constructor with unit label. ;  ;  RooAbsReal (const char *name, const char *title, double minVal, double maxVal, const char *unit="""");  Constructor with plot range and unit label. ;  ;  RooAbsReal (const RooAbsReal &other, const char *name=nullptr);  Copy constructor. ;  ;  ~RooAbsReal () override;  Destructor. ;  ; TF1 * asTF (const RooArgList &obs, const RooArgList &pars=RooArgList(), const RooArgSet &nset=RooArgSet()) const;  Return a ROOT TF1,2,3 object bound to this RooAbsReal with given definition of observables and parameters. ;  ; RooFit::OwningPtr< RooAbsFunc > bindVars (const RooArgSet &vars, const RooArgSet *nset=nullptr, bool clipInvalid=false) const;  Create an interface adaptor f(vars) that binds us to the specified variables (in arbitrary order). ;  ; virtual RooFit::OwningPtr< RooFitResult > chi2FitTo (RooDataHist &data, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={});  Perform a \( \chi^2 \) fit to given histogram. ;  ; virtual RooFit::OwningPtr< RooFitResult > chi2FitTo (RooDataHist &data, const RooLinkedList &cmdList);  Calls RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList) and returns fit result. ;  ; virtual RooFit::OwningPtr< RooFitResult > chi2FitTo (RooDataSet &xydata, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={});  Perform a 2-D \( \chi^2 \) fit using a series of x ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooHistPdf.html:16652,adapt,adaptor,16652,doc/master/classRooHistPdf.html,https://root.cern,https://root.cern/doc/master/classRooHistPdf.html,1,['adapt'],['adaptor']
Energy Efficiency,"ateOnTheFly);  Returns the specialized integrator configuration for this RooAbsReal. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from RooAbsReal;  RooAbsReal ();  coverity[UNINIT_CTOR] Default constructor ;  ;  RooAbsReal (const char *name, const char *title, const char *unit="""");  Constructor with unit label. ;  ;  RooAbsReal (const char *name, const char *title, double minVal, double maxVal, const char *unit="""");  Constructor with plot range and unit label. ;  ;  RooAbsReal (const RooAbsReal &other, const char *name=nullptr);  Copy constructor. ;  ;  ~RooAbsReal () override;  Destructor. ;  ; TF1 * asTF (const RooArgList &obs, const RooArgList &pars=RooArgList(), const RooArgSet &nset=RooArgSet()) const;  Return a ROOT TF1,2,3 object bound to this RooAbsReal with given definition of observables and parameters. ;  ; RooFit::OwningPtr< RooAbsFunc > bindVars (const RooArgSet &vars, const RooArgSet *nset=nullptr, bool clipInvalid=false) const;  Create an interface adaptor f(vars) that binds us to the specified variables (in arbitrary order). ;  ; virtual std::string buildCallToAnalyticIntegral (Int_t code, const char *rangeName, RooFit::Detail::CodeSquashContext &ctx) const;  This function defines the analytical integral translation for the class. ;  ; virtual RooFit::OwningPtr< RooFitResult > chi2FitTo (RooDataHist &data, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={});  Perform a \( \chi^2 \) fit to given histogram. ;  ; virtual RooFit::OwningPtr< RooFitResult > chi2FitTo (RooDataHist &data, const RooLinkedList &cmdList);  Calls RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList) and returns fit result. ;  ; virtual RooFit::OwningPtr< RooFitResult > chi2FitTo (RooDataSet &xydata, const RooCmdArg &arg1={}, const RooCmdArg &arg2={},",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooWrapperPdf.html:15659,adapt,adaptor,15659,doc/master/classRooWrapperPdf.html,https://root.cern,https://root.cern/doc/master/classRooWrapperPdf.html,2,['adapt'],['adaptor']
Energy Efficiency,"atedAnnealing::SetDefaultScale ; (; ). private . setting of default scale ; Definition at line 230 of file SimulatedAnnealing.cxx. ◆ SetInitTemp(). void TMVA::SimulatedAnnealing::SetInitTemp ; (; Double_t ; it). inline . Definition at line 63 of file SimulatedAnnealing.h. ◆ SetIPythonInteractive(). void TMVA::SimulatedAnnealing::SetIPythonInteractive ; (; bool * ; ExitFromTraining, . UInt_t * ; fIPyCurrentIter_ . ). inline . Definition at line 74 of file SimulatedAnnealing.h. ◆ SetMaxCalls(). void TMVA::SimulatedAnnealing::SetMaxCalls ; (; Int_t ; mc). inline . Definition at line 62 of file SimulatedAnnealing.h. ◆ SetMinTemp(). void TMVA::SimulatedAnnealing::SetMinTemp ; (; Double_t ; min). inline . Definition at line 64 of file SimulatedAnnealing.h. ◆ SetOptions(). void TMVA::SimulatedAnnealing::SetOptions ; (; Int_t ; maxCalls, . Double_t ; initialTemperature, . Double_t ; minTemperature, . Double_t ; eps, . TString ; kernelTemperatureS, . Double_t ; temperatureScale, . Double_t ; adaptiveSpeed, . Double_t ; temperatureAdaptiveStep, . Bool_t ; useDefaultScale, . Bool_t ; useDefaultTemperature . ). option setter ; Definition at line 73 of file SimulatedAnnealing.cxx. ◆ SetTemperatureScale(). void TMVA::SimulatedAnnealing::SetTemperatureScale ; (; Double_t ; scale). inline . Definition at line 66 of file SimulatedAnnealing.h. ◆ ShouldGoIn(). Bool_t TMVA::SimulatedAnnealing::ShouldGoIn ; (; Double_t ; currentFit, . Double_t ; localFit, . Double_t ; currentTemperature . ). private . result checker ; Definition at line 219 of file SimulatedAnnealing.cxx. ◆ Streamer(). virtual void TMVA::SimulatedAnnealing::Streamer ; (; TBuffer & ; ). virtual . ◆ StreamerNVirtual(). void TMVA::SimulatedAnnealing::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 127 of file SimulatedAnnealing.h. Member Data Documentation. ◆ fAdaptiveSpeed. Double_t TMVA::SimulatedAnnealing::fAdaptiveSpeed. private . how fast temperature change in adaptive (in a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1SimulatedAnnealing.html:8608,adapt,adaptiveSpeed,8608,doc/master/classTMVA_1_1SimulatedAnnealing.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1SimulatedAnnealing.html,1,['adapt'],['adaptiveSpeed']
Energy Efficiency,"ath(). void TProof::HandleLibIncPath ; (; const char * ; what, . Bool_t ; add, . const char * ; dirs . ). protected . Handle lib, inc search paths modification request. ; Definition at line 8998 of file TProof.cxx. ◆ HandleOutputOptions(). Int_t TProof::HandleOutputOptions ; (; TString & ; opt, . TString & ; target, . Int_t ; action . ). protected . Extract from opt information about output handling settings. ; The understood keywords are: of=<file>, outfile=<file> output file location ds=<dsname>, dataset=<dsname> dataset name ('of' and 'ds' are mutually exclusive,execution stops if both are found) sft[=<opt>], savetofile[=<opt>] control saving to file; For 'mvf', the <opt> integer has the following meaning: <opt> = <how>*10 + <force> <force> = 0 save to file if memory threshold is reached (the memory threshold is set by the cluster admin); in case an output file is defined, the files are merged at the end; 1 save results to file. <how> = 0 save at the end of the query 1 save results after each packet (to reduce the loss in case of crash).; Setting 'ds' automatically sets 'mvf=1'; it is still possible to set 'mvf=11' to save results after each packet.; The separator from the next option is either a ' ' or a ';'; All recognized settings are removed from the input string opt. If action == 0, set up the output file accordingly, if action == 1 clean related output file settings. If the final target file is local then 'target' is set to the final local path when action == 0 and used to retrieve the file with TFile::Cp when action == 1.; Output file settings are in the form `<previous_option>`of=name `<next_option>`; `<previous_option>`outfile=name,...;`<next_option>`; The separator from the next option is either a ' ' or a ';' Called interanally by TProof::Process.; Returns 0 on success, -1 on error. ; Definition at line 4937 of file TProof.cxx. ◆ HandleSubmerger(). void TProof::HandleSubmerger ; (; TMessage * ; mess, . TSlave * ; sl . ). private . Process a message of t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProof.html:109933,reduce,reduce,109933,doc/master/classTProof.html,https://root.cern,https://root.cern/doc/master/classTProof.html,1,['reduce'],['reduce']
Energy Efficiency,"ath::BreitWignerDouble_t BreitWigner(Double_t x, Double_t mean=0, Double_t gamma=1)Calculates a Breit Wigner function with mean and gamma.Definition TMath.cxx:442; TMath::Sqrt2constexpr Double_t Sqrt2()Definition TMath.h:86; TMath::KUncertaintyconstexpr Double_t KUncertainty()Boltzmann's constant uncertainty.Definition TMath.h:261; TMath::Hbarcgsconstexpr Double_t Hbarcgs()Definition TMath.h:218; TMath::LandauDouble_t Landau(Double_t x, Double_t mpv=0, Double_t sigma=1, Bool_t norm=kFALSE)The LANDAU function.Definition TMath.cxx:492; TMath::VoigtDouble_t Voigt(Double_t x, Double_t sigma, Double_t lg, Int_t r=4)Computation of Voigt function (normalised).Definition TMath.cxx:898; TMath::StudentDouble_t Student(Double_t T, Double_t ndf)Computes density function for Student's t- distribution (the probability function (integral of densit...Definition TMath.cxx:2623; TMath::CUncertaintyconstexpr Double_t CUncertainty()Speed of light uncertainty.Definition TMath.h:128; TMath::Qeconstexpr Double_t Qe()Elementary charge in .Definition TMath.h:339; TMath::CeilDouble_t Ceil(Double_t x)Rounds x upward, returning the smallest integral value that is not less than x.Definition TMath.h:668; TMath::PiOver2constexpr Double_t PiOver2()Definition TMath.h:51; TMath::HCcgsconstexpr Double_t HCcgs()Definition TMath.h:240; TMath::MinElementT MinElement(Long64_t n, const T *a)Returns minimum of array a of length n.Definition TMath.h:960; TMath::BetaDistIDouble_t BetaDistI(Double_t x, Double_t p, Double_t q)Computes the cumulative distribution function of the Beta distribution, i.e.Definition TMath.cxx:2090; TMath::NormCrossT NormCross(const T v1[3], const T v2[3], T out[3])Calculates the Normalized Cross Product of two vectors.Definition TMath.h:951; TMath::FiniteInt_t Finite(Double_t x)Check if it is finite with a mask in order to be consistent in presence of fast math.Definition TMath.h:770; TMath::TanHDouble_t TanH(Double_t)Returns the hyperbolic tangent of x.Definition TMath.h:618; TMath",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMath_8h_source.html:62258,charge,charge,62258,doc/master/TMath_8h_source.html,https://root.cern,https://root.cern/doc/master/TMath_8h_source.html,1,['charge'],['charge']
Energy Efficiency,"ath::PiOver4 ();  \( \frac{\pi}{4} \) ;  ; Double_t TMath::Poisson (Double_t x, Double_t par);  Computes the Poisson distribution function for (x,par). ;  ; Double_t TMath::PoissonI (Double_t x, Double_t par);  Computes the Discrete Poisson distribution function for (x,par). ;  ; Double_t TMath::Power (Double_t x, Double_t y);  Returns x raised to the power y. ;  ; Double_t TMath::Power (Double_t x, Int_t y);  Returns x raised to the power y. ;  ; LongDouble_t TMath::Power (Long64_t x, Long64_t y);  Returns x raised to the power y. ;  ; LongDouble_t TMath::Power (LongDouble_t x, Long64_t y);  Returns x raised to the power y. ;  ; LongDouble_t TMath::Power (LongDouble_t x, LongDouble_t y);  Returns x raised to the power y. ;  ; Double_t TMath::Prob (Double_t chi2, Int_t ndf);  Computation of the probability for a certain Chi-squared (chi2) and number of degrees of freedom (ndf). ;  ; constexpr Double_t TMath::Qe ();  Elementary charge in \( C \) . ;  ; constexpr Double_t TMath::QeUncertainty ();  Elementary charge uncertainty. ;  ; void TMath::Quantiles (Int_t n, Int_t nprob, Double_t *x, Double_t *quantiles, Double_t *prob, Bool_t isSorted=kTRUE, Int_t *index=nullptr, Int_t type=7);  Computes sample quantiles, corresponding to the given probabilities. ;  ; Double_t TMath::QuietNaN ();  Returns a quiet NaN as defined by IEEE 754. ;  ; constexpr Double_t TMath::R ();  Universal gas constant ( \( Na K \)) in \( J K^{-1} mol^{-1} \) ;  ; constexpr Double_t TMath::RadToDeg ();  Conversion from radian to degree: \( \frac{180}{\pi} \). ;  ; constexpr Double_t TMath::Rgair ();  Dry Air Gas Constant (R / MWair) in \( J kg^{-1} K^{-1} \) ;  ; template<typename Iterator > ; Double_t TMath::RMS (Iterator first, Iterator last);  Returns the Standard Deviation of an array defined by the iterators. ;  ; template<typename Iterator , typename WeightIterator > ; Double_t TMath::RMS (Iterator first, Iterator last, WeightIterator wfirst);  Returns the weighted Standard Deviation of an a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMath_8h.html:15945,charge,charge,15945,doc/master/TMath_8h.html,https://root.cern,https://root.cern/doc/master/TMath_8h.html,1,['charge'],['charge']
Energy Efficiency,"atic Int_t _nameLength;  . #include <RooBinSamplingPdf.h>. Inheritance diagram for RooBinSamplingPdf:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RooBinSamplingPdf() [1/3]. RooBinSamplingPdf::RooBinSamplingPdf ; (; ). inline . Definition at line 31 of file RooBinSamplingPdf.h. ◆ RooBinSamplingPdf() [2/3]. RooBinSamplingPdf::RooBinSamplingPdf ; (; const char * ; name, . const char * ; title, . RooAbsRealLValue & ; observable, . RooAbsPdf & ; inputPdf, . double ; epsilon = 1.E-4 . ). Construct a new RooBinSamplingPdf. ; Parameters. [in]nameA name to identify this object. ; [in]titleTitle (for e.g. plotting) ; [in]observableObservable to integrate over (the one that is binned). ; [in]inputPdfA PDF whose bins should be sampled with higher precision. ; [in]epsilonRelative precision for the integrator, which is used to sample the bins. Note that ROOT's default is to use an adaptive integrator, which in its first iteration usually reaches relative precision of 1.E-4 or better. Therefore, asking for lower precision rarely has an effect. . Definition at line 113 of file RooBinSamplingPdf.cxx. ◆ RooBinSamplingPdf() [3/3]. RooBinSamplingPdf::RooBinSamplingPdf ; (; const RooBinSamplingPdf & ; other, . const char * ; name = nullptr . ). Copy a RooBinSamplingPdf. ; Parameters. [in]otherPDF to copy. ; [in]nameOptionally rename the copy. . Definition at line 131 of file RooBinSamplingPdf.cxx. Member Function Documentation. ◆ analyticalIntegral(). double RooBinSamplingPdf::analyticalIntegral ; (; Int_t ; code, . const char * ; rangeName = nullptr . ); const. inlineoverridevirtual . Forwards to the PDF's implementation. ; Reimplemented from RooAbsReal.; Definition at line 60 of file RooBinSamplingPdf.h. ◆ analyticalIntegralWN(). double RooBinSamplingPdf::analyticalIntegralWN ; (; Int_t ; code, . const RooArgSet * ; normSet, . const char * ; rangeName . ); const. inlineoverridevirtual . Forwa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooBinSamplingPdf.html:78591,adapt,adaptive,78591,doc/master/classRooBinSamplingPdf.html,https://root.cern,https://root.cern/doc/master/classRooBinSamplingPdf.html,1,['adapt'],['adaptive']
Energy Efficiency,"atic constexpr Version_t TGeoOverlap::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 97 of file TGeoOverlap.h. ◆ Compare(). Int_t TGeoOverlap::Compare ; (; const TObject * ; obj); const. overridevirtual . Method to compare this overlap with another. ; Returns : -1 - this is smaller than OBJ 0 - equal 1 - greater ; Reimplemented from TObject.; Definition at line 99 of file TGeoOverlap.cxx. ◆ DeclFileName(). static const char * TGeoOverlap::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 97 of file TGeoOverlap.h. ◆ DistancetoPrimitive(). Int_t TGeoOverlap::DistancetoPrimitive ; (; Int_t ; px, . Int_t ; py . ). overridevirtual . Distance to primitive for an overlap. ; Reimplemented from TObject.; Definition at line 121 of file TGeoOverlap.cxx. ◆ Draw(). void TGeoOverlap::Draw ; (; Option_t * ; option = """"). overridevirtual . Draw the overlap. ; One daughter will be blue, the other green, extruding points red. ; Reimplemented from TObject.; Definition at line 130 of file TGeoOverlap.cxx. ◆ ExecuteEvent(). void TGeoOverlap::ExecuteEvent ; (; Int_t ; event, . Int_t ; px, . Int_t ; py . ). overridevirtual . Event interception. ; Reimplemented from TObject.; Definition at line 139 of file TGeoOverlap.cxx. ◆ GetFirstMatrix(). TGeoHMatrix * TGeoOverlap::GetFirstMatrix ; (; ); const. inline . Definition at line 67 of file TGeoOverlap.h. ◆ GetFirstVolume(). TGeoVolume * TGeoOverlap::GetFirstVolume ; (; ); const. inline . Definition at line 65 of file TGeoOverlap.h. ◆ GetOverlap(). Double_t TGeoOverlap::GetOverlap ; (; ); const. inline . Definition at line 69 of file TGeoOverlap.h. ◆ GetPolyMarker(). TPolyMarker3D * TGeoOverlap::GetPolyMarker ; (; ); const. inline . Definition at line 64 of file TGeoOverlap.h. ◆ GetSecondMatrix(). TGeoHMatrix * TGeoOverlap::GetSecondMatrix ; (; ); const. inline . Definition at line 68 of file TGeoOverlap.h. ◆ GetSecondVolume(). TGeo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoOverlap.html:19421,green,green,19421,doc/master/classTGeoOverlap.html,https://root.cern,https://root.cern/doc/master/classTGeoOverlap.html,1,['green'],['green']
Energy Efficiency,"atical algorithms as well as on integrating AI methods for data analysis inside the framework. He has also worked on extending and improving the FitPanel interface.; Diego Marcos Segura; Diego worked as technical student on CINT dictionary optimizations.; Eddy Offermann; Eddy joined the ROOT team during a sabbatical to work on making the ROOT matrix package the fastest and most versatile in the industry.; Ilka Antcheva; Ilka has been working from 2002 to 2008 in the ROOT team. She was responsible for the GUI system and designed many high level user interfaces and widgets, like found in many modern graphics applications: ROOT graphics editor (GED) and various object editors, Fit Panel, Style manager, a tool for automatic C++ code generation of any widget and the capability for widgets to save themselves. In addition Ilka took care of the ROOT Users Guide and contributed the chapter ‘Writing a Graphical User Interface’.; Gerardo Ganis; Gerri was a team member for more than ten years; among many other contributions he was in charge of PROOF for many years.; Jan Iwaszkiewicz; Jan was working in the context of a Ph.D. on scheduling and load-balancing of distributed processing in the Parallel ROOT Facility (PROOF).; Leandro Franco; Leo worked a Marie-Curie fellow in the ROOT team from 2005-2008. He worked on a number of widely different topics, from parallel sockets, I/O read-ahead, CINT dictionary, etc.; Maarten Ballintijn; Maarten's initial dab into ROOT was porting it to Linux in 1995. Later he worked on the PROOF system, bringing into production for the RHIC experiments in Brookhaven.; Marek Biskup; Marek worked as technical student on various aspects of PROOF, notably integrating the TChain::Draw() command into PROOF.; Masaharu Goto; Masa is the father of CINT. Without the indefatigable support by Masa we would never have succeeded with the tight integration of CINT in ROOT. Masa is now managing a large division in Agilent and cannot spend as much time on CINT as he ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/previous-developers.html:3901,charge,charge,3901,d/previous-developers.html,https://root.cern,https://root.cern/d/previous-developers.html,1,['charge'],['charge']
Energy Efficiency,"ation = 'relu')) "");; m.AddLine(""model.add(Dense(2, activation = 'sigmoid')) "");; m.AddLine(""model.compile(loss = 'binary_crossentropy', optimizer = Adam(learning_rate = 0.001), weighted_metrics = ['accuracy'])"");; m.AddLine(""model.save('model_cnn.h5')"");; m.AddLine(""model.summary()"");; ; m.SaveSource(""make_cnn_model.py"");; // execute; gSystem->Exec(python_exe + "" make_cnn_model.py"");; ; if (gSystem->AccessPathName(""model_cnn.h5"")) {; Warning(""TMVA_CNN_Classification"", ""Error creating Keras model file - skip using Keras"");; } else {; // book PyKeras method only if Keras model could be created; Info(""TMVA_CNN_Classification"", ""Booking tf.Keras CNN model"");; factory.BookMethod(; &loader, TMVA::Types::kPyKeras, ""PyKeras"",; ""H:!V:VarTransform=None:FilenameModel=model_cnn.h5:tf.keras:""; ""FilenameTrainedModel=trained_model_cnn.h5:NumEpochs=10:BatchSize=100:""; ""GpuOptions=allow_growth=True""); // needed for RTX NVidia card and to avoid TF allocates all GPU memory; }; }; ; if (usePyTorchCNN) {; ; Info(""TMVA_CNN_Classification"", ""Using Convolutional PyTorch Model"");; TString pyTorchFileName = gROOT->GetTutorialDir() + TString(""/tmva/PyTorch_Generate_CNN_Model.py"");; // check that pytorch can be imported and file defining the model and used later when booking the method is; // existing; if (gSystem->Exec(python_exe + "" -c 'import torch'"") || gSystem->AccessPathName(pyTorchFileName)) {; Warning(""TMVA_CNN_Classification"", ""PyTorch is not installed or model building file is not existing - skip using PyTorch"");; } else {; // book PyTorch method only if PyTorch model could be created; Info(""TMVA_CNN_Classification"", ""Booking PyTorch CNN model"");; TString methodOpt = ""H:!V:VarTransform=None:FilenameModel=PyTorchModelCNN.pt:""; ""FilenameTrainedModel=PyTorchTrainedModelCNN.pt:NumEpochs=10:BatchSize=100"";; methodOpt += TString("":UserCode="") + pyTorchFileName;; factory.BookMethod(&loader, TMVA::Types::kPyTorch, ""PyTorch"", methodOpt);; }; }; #endif; ; //// ## Train Methods; ; factory.Train",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html:60277,allocate,allocates,60277,doc/master/TMVA__CNN__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html,1,['allocate'],['allocates']
Energy Efficiency,"ation can be performed, zero should be returned. Second,; double analyticalIntegral(Int_t code); RooAbsReal::analyticalIntegralvirtual double analyticalIntegral(Int_t code, const char *rangeName=nullptr) constImplements the actual analytical integral(s) advertised by getAnalyticalIntegral.Definition RooAbsReal.cxx:394; implements the actual analytical integral(s) advertised by getAnalyticalIntegral(). This function will only be called with codes returned by getAnalyticalIntegral(), except code zero.; The integration range for each dependent to be integrated can be obtained from the dependent's proxy functions min() and max(). Never call these proxy functions for any proxy not known to be a dependent via the integration code. Doing so may be ill-defined, e.g., in case the proxy holds a function, and will trigger an assert. Integrated category dependents should always be summed over all of their states. Direct generation of observables; Distributions for any PDF can be generated with the accept/reject method, but for certain PDFs, more efficient methods may be implemented. To implement direct generation of one or more observables, two functions need to be implemented, similar to those for analytical integrals:; Int_t getGenerator(const RooArgSet& generateVars, RooArgSet& directVars); RooAbsPdf::getGeneratorvirtual Int_t getGenerator(const RooArgSet &directVars, RooArgSet &generateVars, bool staticInitOK=true) constLoad generatedVars with the subset of directVars that we can generate events for, and return a code t...Definition RooAbsPdf.cxx:1522; and void generateEvent(Int_t code); RooAbsPdf::generateEventvirtual void generateEvent(Int_t code)Interface for generation of an event using the algorithm corresponding to the specified code.Definition RooAbsPdf.cxx:1544; The first function advertises observables, for which distributions can be generated, similar to the way analytical integrals are advertised. The second function implements the actual generator for the adverti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsPdf.html:4662,efficient,efficient,4662,doc/master/classRooAbsPdf.html,https://root.cern,https://root.cern/doc/master/classRooAbsPdf.html,1,['efficient'],['efficient']
Energy Efficiency,ation environment; TRootAuth client auth interface; TRootBrowser New ROOT Browser; TRootBrowserLite ROOT native GUI version of browser; TRootCanvas ROOT native GUI version of main window with menubar and drawing area; TRootContextMenu ROOT native GUI context sensitive popup menu; TRootControlBar ROOT native GUI implementation of TControlBar; TRootDialog Native GUI method argument prompt dialog box; TRootEmbeddedCanvas A ROOT TCanvas that can be embedded in a TGFrame; TRootGuiBuilder ROOT GUI Builder; TRootGuiFactory Factory for ROOT GUI components; TRootHelpDialog Dialog to display help text; TRootIOCtor ; TRootSecContext Class providing host specific authentication information; TRotMatrix Rotation Matrix for 3-D geometry objects; TRotation Rotations of TVector3 objects; TRuby Ruby/ROOT interface; TSAXParser SAX Parser; TSPHE SPHE shape; TSPlot class to disentangle signal from background; TSQLColumnInfo Summury information about column from SQL table; TSQLMonitoringWriter Sending monitoring data to a SQL DB; TSQLResult SQL query result; TSQLRow One row of an SQL query result; TSQLServer Connection to SQL server; TSQLStatement SQL statement; TSQLTableInfo Summury information about SQL table; TSVDUnfold Data unfolding using Singular Value Decomposition (hep-ph/9509307) ; TSVG SVG driver; TSecContext Class providing host specific authentication information; TSecContextCleanup Update the remote authentication table; TSelector A utility class for tree and object processing; TSelectorCint A utility class for tree and object processing (interpreted version); TSelectorDraw A specialized TSelector for TTree::Draw; TSelectorEntries A specialized TSelector for TTree::GetEntries(selection); TSelectorList Special TList used in the TSelector; TSelectorScalar Mergable scalar; TSemaphore Counting semaphore class; TSeqCollection Sequenceable collection ABC; TServerSocket This class implements server sockets; TSessionDescription Session description; TSessionFrame Session frame; TSessi,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ClassIndex.html:120464,monitor,monitoring,120464,root/html528/ClassIndex.html,https://root.cern,https://root.cern/root/html528/ClassIndex.html,1,['monitor'],['monitoring']
Energy Efficiency,"ation for the ML writer ;  CTProofMonSenderSQLTProofMonSender implementation for the SQL writers ;  CTProofNodeInfoThe purpose of this class is to provide a complete node description for masters, submasters and workers ;  CTProofNodesPROOF worker node information .  CTProofOutputFileClass to steer the merging of files produced on the workers ;  CTProofOutputListDerivation of TList with an overload of ls() and Print() allowing to filter out some of the variables ;  CTProofPerfAnalysisSet of tools to analyse the performance tree ;  ►CTProofPlayerInternal class steering processing in PROOF ;  CTCleanup;  CTProofPlayerLiteVersion of TProofPlayerRemote merges the functionality needed by clients and masters ;  CTProofPlayerLocal;  CTProofPlayerRemote;  CTProofPlayerSlave;  CTProofPlayerSuperMaster;  CTProofProgressDialog;  CTProofProgressInfo;  CTProofProgressLog;  CTProofProgressMemoryPlot;  CTProofProgressStatusContainer class for processing statistics ;  CTProofQueryResultTQueryResult version adapted to PROOF neeeds ;  CTProofResources;  CTProofResourcesStaticThe purpose of this class is to provide a standard interface to static config files ;  CTProofServClass providing the PROOF server ;  CTProofServLiteVersion of the PROOF worker server for local running ;  CTProofServLogHandler;  CTProofServLogHandlerGuard;  CTProofSuperMasterImplementation of TProof controlling PROOF federated clusters ;  CTProofVectorContainer;  ►CTProtoClassPersistent version of a TClass ;  CTProtoRealData;  CTPServerSocket;  CTPSocket;  CTPwdCtx;  CTPyArg;  CTPyClassGenerator;  CTPyDispatcher;  CTPyMultiGenFunction;  CTPyMultiGradFunction;  CTPyReturn;  CTPySelector;  ►CTPythia6TPythia is an interface class to F77 version of Pythia 6.2 .  CTPythia6CleanerUtility class to manage the TPythia6 instance ;  CTPythia6DecayerThis class implements the TVirtualMCDecayer interface ;  CTPythia8TPythia8 is an interface class to C++ version of Pythia 8.1 ; event generators, written by T.Sjostrand ;  CTPythi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/annotated.html:205085,adapt,adapted,205085,doc/v616/annotated.html,https://root.cern,https://root.cern/doc/v616/annotated.html,1,['adapt'],['adapted']
Energy Efficiency,"ation of class RooAbsReal that binds generic C(++) functions to a RooAbsReal argument thus allowing generic C++ functions to be used as RooFit functions ;  CRooFunctor1DPdfBinding;  CRooFunctorBindingRooCFunction1Binding is a templated implementation of class RooAbsReal that binds generic C(++) functions to a RooAbsReal argument thus allowing generic C++ functions to be used as RooFit functions ;  CRooFunctorPdfBinding;  CRooGammaImplementation of the Gamma PDF for RooFit/RooStats ;  CRooGaussianPlain Gaussian p.d.f ;  CRooGaussKronrodIntegrator1DRooGaussKronrodIntegrator1D implements the Gauss-Kronrod integration algorithm ;  CRooGaussModelClass RooGaussModel implements a RooResolutionModel that models a Gaussian distribution ;  CRooGenContextClass RooGenContext implement a universal generator context for all RooAbsPdf classes that do not have or need a specialized generator context ;  CRooGenericPdfRooGenericPdf is a concrete implementation of a probability density function, which takes a RooArgList of servers and a C++ expression string defining how its value should be calculated from the given list of servers ;  CRooGenFitStudyRooGenFitStudy is an abstract base class for RooStudyManager modules ;  CRooGenFunctionLightweight interface adaptor that exports a RooAbsReal as a ROOT::Math::IGenFunction ;  CRooGenProdProjRooGenProdProj is an auxiliary class for RooProdPdf that calculates a general normalized projection of a product of non-factorizing PDFs, e.g ;  CRooGExpModelClass RooGExpModel is a RooResolutionModel implementation that models a resolution function that is the convolution of a Gaussian with a one-sided exponential ;  CRooGlobalFunc;  CRooGridRooGrid is a utility class for RooMCIntegrator which implements an adaptive multi-dimensional Monte Carlo numerical integration, following the VEGAS algorithm ;  CRooHashTableRooHashTable implements a hash table for TObjects ;  CRooHistA RooHist is a graphical representation of binned data based on the TGraphAsymm",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v610/annotated.html:100626,adapt,adaptor,100626,doc/v610/annotated.html,https://root.cern,https://root.cern/doc/v610/annotated.html,3,['adapt'],['adaptor']
Energy Efficiency,"ation of inverse transformation; Log() << kFATAL << ""Inverse transformation for PCA transformation not yet implemented. Hence, this transformation cannot be applied together with regression. Please contact the authors if necessary."" << Endl;. void CalculatePrincipalComponents(const vector<TMVA::Event*,allocator<TMVA::Event*> >& ); calculate the principal components for the signal and the background data; it uses the MakePrincipal method of ROOT's TPrincipal class. void X2P(vector<Float_t>& , const vector<Float_t>& , Int_t cls) const; Calculate the principal components from the original data vector; x, and return it in p (function extracted from TPrincipal::X2P); It's the users responsibility to make sure that both x and p are; of the right size (i.e., memory must be allocated for p). void P2X(vector<Float_t>& , const vector<Float_t>& , Int_t cls) const; Perform the back-transformation from the principal components; pc, and return x; It's the users responsibility to make sure that both x and pc are; of the right size (i.e., memory must be allocated for p). void WriteTransformationToStream(ostream& ) const; write mean values to stream. void AttachXMLTo(void* parent); create XML description of PCA transformation. void ReadFromXML(void* trfnode); Read the transformation matrices from the xml node. void ReadTransformationFromStream(istream& , const TString& ); Read mean values from input stream. void MakeFunction(ostream& fout, const TString& fncName, Int_t part, UInt_t trCounter, Int_t cls); creates C++ code fragment of the PCA transform for inclusion in standalone C++ class. VariablePCATransform( DataSetInfo& dsi ). » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id: VariablePCATransform.h 39395 2011-05-26 10:05:54Z moneta $ » Last generated: 2011-07-04 15:34; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__VariablePCATransform.html:11331,allocate,allocated,11331,root/html530/TMVA__VariablePCATransform.html,https://root.cern,https://root.cern/root/html530/TMVA__VariablePCATransform.html,1,['allocate'],['allocated']
Energy Efficiency,"ation ; _regularization = EnumRegularization::NONE, . size_t ; _scaleToNumEvents = 0, . MinimizerType ; _eMinimizerType = MinimizerType::fSteepest, . double ; _learningRate = 1e-5, . double ; _momentum = 0.3, . int ; _repetitions = 3, . bool ; _useMultithreading = true . ). inline . c'tor ; Definition at line 901 of file NeuralNet.h. ◆ ~ClassificationSettings(). virtual TMVA::DNN::ClassificationSettings::~ClassificationSettings ; (; ). inlinevirtual . d'tor ; Definition at line 924 of file NeuralNet.h. Member Function Documentation. ◆ endTestCycle(). void TMVA::DNN::ClassificationSettings::endTestCycle ; (; ). virtual . action to be done when the training cycle is ended (e.g. ; update some monitoring output) ; Reimplemented from TMVA::DNN::Settings.; Definition at line 326 of file NeuralNet.cxx. ◆ endTrainCycle(). void TMVA::DNN::ClassificationSettings::endTrainCycle ; (; double ; ). virtual . action to be done when the training cycle is ended (e.g. ; update some monitoring output) ; Reimplemented from TMVA::DNN::Settings.; Definition at line 296 of file NeuralNet.cxx. ◆ setResultComputation(). void TMVA::DNN::ClassificationSettings::setResultComputation ; (; std::string ; _fileNameNetConfig, . std::string ; _fileNameResult, . std::vector< Pattern > * ; _resultPatternContainer . ). preparation for monitoring output ; Definition at line 520 of file NeuralNet.cxx. ◆ setWeightSums(). void TMVA::DNN::ClassificationSettings::setWeightSums ; (; double ; sumOfSigWeights, . double ; sumOfBkgWeights . ). set the weight sums to be scaled to (preparations for monitoring output) ; Definition at line 512 of file NeuralNet.cxx. ◆ startTestCycle(). void TMVA::DNN::ClassificationSettings::startTestCycle ; (; ). virtual . action to be done when the test cycle is started (e.g. ; update some monitoring output) ; Reimplemented from TMVA::DNN::Settings.; Definition at line 316 of file NeuralNet.cxx. ◆ startTrainCycle(). void TMVA::DNN::ClassificationSettings::startTrainCycle ; (; ). virt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1ClassificationSettings.html:7749,monitor,monitoring,7749,doc/master/classTMVA_1_1DNN_1_1ClassificationSettings.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1ClassificationSettings.html,1,['monitor'],['monitoring']
Energy Efficiency,"ative at a point x using an adaptive backward difference algorithm with a step size h. ; The function is evaluated only at points less than x and at x itself. ; Definition at line 69 of file GSLDerivator.cxx. ◆ EvalCentral() [1/2]. double ROOT::Math::GSLDerivator::EvalCentral ; (; const IGenFunction & ; f, . double ; x, . double ; h . ). static . Computes the numerical derivative of a function f at a point x using an adaptive central difference algorithm with a step size h. ; Definition at line 81 of file GSLDerivator.cxx. ◆ EvalCentral() [2/2]. double ROOT::Math::GSLDerivator::EvalCentral ; (; double ; x, . double ; h . ). Computes the numerical derivative at a point x using an adaptive central difference algorithm with a step size h. ; Definition at line 47 of file GSLDerivator.cxx. ◆ EvalForward() [1/2]. double ROOT::Math::GSLDerivator::EvalForward ; (; const IGenFunction & ; f, . double ; x, . double ; h . ). static . Computes the numerical derivative of a function f at a point x using an adaptive forward difference algorithm with a step size h. ; The function is evaluated only at points greater than x and at x itself ; Definition at line 90 of file GSLDerivator.cxx. ◆ EvalForward() [2/2]. double ROOT::Math::GSLDerivator::EvalForward ; (; double ; x, . double ; h . ). Computes the numerical derivative at a point x using an adaptive forward difference algorithm with a step size h. ; The function is evaluated only at points greater than x and at x itself. ; Definition at line 58 of file GSLDerivator.cxx. ◆ Result(). double ROOT::Math::GSLDerivator::Result ; (; ); const. return the result of the last derivative calculation ; Definition at line 109 of file GSLDerivator.cxx. ◆ SetFunction() [1/2]. void ROOT::Math::GSLDerivator::SetFunction ; (; const IGenFunction & ; f). Set the function for calculating the derivatives. ; The function must implement the ROOT::Math::IGenFunction signature ; Definition at line 123 of file GSLDerivator.cxx. ◆ SetFunction() [2/2]. void R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1GSLDerivator.html:4816,adapt,adaptive,4816,doc/master/classROOT_1_1Math_1_1GSLDerivator.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1GSLDerivator.html,1,['adapt'],['adaptive']
Energy Efficiency,"atus bar. Rotation and zooming. Rotation:; When the plot is selected, it can be rotated by pressing and; holding the left mouse button and move the cursor.; Zoom/Unzoom:; Mouse wheel or 'j', 'J', 'k', 'K' keys. Panning; The selected plot can be moved in a pad's area by pressing and; holding the left mouse button and the shift key.; Box cut; Surface, iso, box, TF3 and parametric painters support box cut by; pressing the 'c' or 'C' key when the mouse cursor is in a plot's; area. That will display a transparent box, cutting away part of the; surface (or boxes) in order to show internal part of plot. This box; can be moved inside the plot's area (the full size of the box is; equal to the plot's surrounding box) by selecting one of the box; cut axes and pressing the left mouse button to move it.; Plot specific interactions (dynamic slicing etc.); Currently, all gl-plots support some form of slicing. When back plane; is selected (and if it's highlighted in green) you can press and hold; left mouse button and shift key and move this back plane inside; plot's area, creating the slice. During this ""slicing"" plot becomes; semi-transparent. To remove all slices (and projected curves for; surfaces) double click with left mouse button in a plot's area.; Surface with option ""GLSURF""; The surface profile is displayed on the slicing plane.; The profile projection is drawn on the back plane; by pressing 'p' or 'P' key.; TF3; The contour plot is drawn on the slicing plane. For TF3 the color; scheme can be changed by pressing 's' or 'S'.; Box; The contour plot corresponding to slice plane position is drawn in real time.; Iso; Slicing is similar to ""GLBOX"" option.; Parametric plot; No slicing. Additional keys: 's' or 'S' to change color scheme -; about 20 color schemes supported ('s' for ""scheme""); 'l' or 'L' to; increase number of polygons ('l' for ""level"" of details), 'w' or 'W'; to show outlines ('w' for ""wireframe"").; . Function Members (Methods); public:. THistPainter(); THistPain",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/THistPainter.html:72899,green,green,72899,root/html528/THistPainter.html,https://root.cern,https://root.cern/root/html528/THistPainter.html,4,['green'],['green']
Energy Efficiency,"atus bar. Rotation and zooming. Rotation:; When the plot is selected, it can be rotated by pressing and; holding the left mouse button and move the cursor.; Zoom/Unzoom:; Mouse wheel or 'j', 'J', 'k', 'K' keys. Panning; The selected plot can be moved in a pad's area by pressing and; holding the left mouse button and the shift key.; Box cut; Surface, iso, box, TF3 and parametric painters support box cut by; pressing the 'c' or 'C' key when the mouse cursor is in a plot's; area. That will display a transparent box, cutting away part of the; surface (or boxes) in order to show internal part of plot. This box; can be moved inside the plot's area (the full size of the box is; equal to the plot's surrounding box) by selecting one of the box; cut axes and pressing the left mouse button to move it.; Plot specific interactions (dynamic slicing etc.); Currently, all gl-plots support some form of slicing. When back plane; is selected (and if it's highlighted in green) you can press and hold; left mouse button and shift key and move this back plane inside; plot's area, creating the slice. During this ""slicing"" plot becomes; semi-transparent. To remove all slices (and projected curves for; surfaces) double click with left mouse button in a plot's area.; Surface with option ""GLSURF""; The surface profile is displayed on the slicing plane.; The profile projection is drawn on the back plane; by pressing 'p' or 'P' key.; TF3; The contour plot is drawn on the slicing plane. For TF3 the color; scheme can be changed by pressing 's' or 'S'.; Box; The contour plot corresponding to slice plane position is drawn in real time.; Iso; Slicing is similar to ""GLBOX"" option.; Parametric plot; No slicing. Additional keys: 's' or 'S' to change color scheme -; about 20 color schemes supported ('s' for ""scheme""); 'l' or 'L' to; increase number of polygons ('l' for ""level"" of details), 'w' or 'W'; to show outlines ('w' for ""wireframe"").; . Function Members (Methods); public:. virtual~THistPainter(); v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/THistPainter.html:80115,green,green,80115,root/html602/THistPainter.html,https://root.cern,https://root.cern/root/html602/THistPainter.html,2,['green'],['green']
Energy Efficiency,"ault range [8800..9800] is used; One also can bind HTTP server socket to loopback address, In that case only connection from localhost will be available: WebGui.HttpLoopback: yes; Or one could specify hostname which should be used for binding of server socket WebGui.HttpBind: hostname | ipaddress; To use secured protocol, following parameter should be specified WebGui.UseHttps: yes; WebGui.ServerCert: sertificate_filename.pem; Alternatively, one can specify unix socket to handle requests: WebGui.UnixSocket: /path/to/unix/socket; WebGui.UnixSocketMode: 0700; Typically one used unix sockets together with server mode like root --web=server:/tmp/root.socket and then redirect it via ssh tunnel (e.g. using rootssh) to client node; All incoming requests processed in THttpServer in timer handler with 10 ms timeout. One may decrease value to improve latency or increase value to minimize CPU load WebGui.HttpTimer: 10; To processing incoming http requests and websockets, THttpServer allocate 10 threads One have to increase this number if more simultaneous connections are expected: WebGui.HttpThrds: 10; One also can configure usage of special thread of processing of http server requests WebGui.HttpThrd: no; Extra threads can be used to send data to different clients via websocket (default no) WebGui.SenderThrds: no; If required, one could change websocket timeouts (default is 10000 ms) WebGui.HttpWSTmout: 10000; By default, THttpServer created in restricted mode which only allows websocket handlers and processes only very few other related http requests. For security reasons such mode should be always enabled. Only if it is really necessary to process all other kinds of HTTP requests, one could specify no for following parameter (default yes): WebGui.WSOnly: yes; In some applications one may need to force longpoll websocket emulations from the beginning, for instance when clients connected via proxys. Although JSROOT should automatically fallback to longpoll engine, one can conf",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RWebWindowsManager.html:8608,allocate,allocate,8608,doc/v632/classROOT_1_1RWebWindowsManager.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RWebWindowsManager.html,2,['allocate'],['allocate']
Energy Efficiency,"awing in overrider of PaintGL. Bool_t MakeCurrent(); Make the gl-context current. Bool_t ClearCurrent(); Clear the current gl-context. void SwapBuffers(); Swap buffers. const TGLContext * GetContext() const; Get gl context. const TGLFormat * GetPixelFormat() const; Pixel format. std::pair<void *, void *> GetInnerData() const; Dpy*, XVisualInfo *. void AddContext(TGLContext* ctx); Register gl-context created for this window. void RemoveContext(TGLContext* ctx); Remove context (no real deletion, done by TGLContex dtor). void ExtractViewport(Int_t* vp) const; For camera. Window_t CreateWindow(const TGWindow* parent, const TGLFormat& format, UInt_t width, UInt_t height, pair<void*,void*>& innerData); CreateWidget.; Static function called prior to widget construction,; I've extracted this code from ctors to make WIN32/X11; separation simpler and because of gInterpreter usage.; new, TGLContext can throw; std::bad_alloc and std::runtime_error. Before try block, the only; resource allocated is pointed by fWindowIndex (InitWindow cannot throw).; In try block (and after successful constraction); resources are controlled by std::auto_ptrs and dtor. void SetFormat(); Set pixel format.; Resource - hDC, owned and freed by guard object. void SetEventHandler(TGEventHandler* eh); Set event-handler. All events are passed to this object. Bool_t HandleCrossing(Event_t* ); Handle mouse crossing event. Bool_t HandleButton(Event_t* ev); Delegate call to the owner. Bool_t HandleDoubleClick(Event_t* ev); Delegate call to the owner. Bool_t HandleConfigureNotify(Event_t* ev); Delegate call to the owner. Bool_t HandleFocusChange(Event_t* ); Delegate call to the owner. Bool_t HandleKey(Event_t* ev); Delegate call to the owner. Bool_t HandleMotion(Event_t* ev); Delegate call to the owner. void DoRedraw(); Delegate call to the owner.; if (!gVirtualX->IsCmdThread()) {; gROOT->ProcessLineFast(Form(""((TGLWidget *)0x%lx)->DoRedraw()"", this));; return;; }. TGEventHandler * GetEventHandler() const; { re",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGLWidget.html:20987,allocate,allocated,20987,root/html528/TGLWidget.html,https://root.cern,https://root.cern/root/html528/TGLWidget.html,3,['allocate'],['allocated']
Energy Efficiency,"awing in overrider of PaintGL. Bool_t MakeCurrent(); Make the gl-context current. Bool_t ClearCurrent(); Clear the current gl-context. void SwapBuffers(); Swap buffers. const TGLContext * GetContext() const; Get gl context. const TGLFormat * GetPixelFormat() const; Pixel format. std::pair<void *, void *> GetInnerData() const; Dpy*, XVisualInfo *. void AddContext(TGLContext* ctx); Register gl-context created for this window. void RemoveContext(TGLContext* ctx); Remove context (no real deletion, done by TGLContex dtor). void ExtractViewport(Int_t* vp) const; For camera. Window_t CreateWindow(const TGWindow* parent, const TGLFormat& format, UInt_t width, UInt_t height, pair<void*,void*>& innerData); CreateWidget.; Static function called prior to widget construction,; I've extracted this code from ctors to make WIN32/X11; separation simpler and because of gInterpreter usage.; new, TGLContext can throw; std::bad_alloc and std::runtime_error. Before try block, the only; resource allocated is pointed by fWindowIndex (InitWindow cannot throw).; In try block (and after successful constraction); resources are controlled by std::auto_ptrs and dtor. void SetFormat(); Set pixel format.; Resource - hDC, owned and freed by guard object. void SetEventHandler(TGEventHandler* eh); Set event-handler. All events are passed to this object. Bool_t HandleCrossing(Event_t* ); Handle mouse crossing event. Bool_t HandleButton(Event_t* ev); Delegate call to the owner. Bool_t HandleDoubleClick(Event_t* ev); Delegate call to the owner. Bool_t HandleConfigureNotify(Event_t* ev); Delegate call to the owner. Bool_t HandleFocusChange(Event_t* ); Delegate call to the owner. Bool_t HandleKey(Event_t* ev); Delegate call to the owner. Bool_t HandleMotion(Event_t* ev); Delegate call to the owner. void DoRedraw(); Delegate call to the owner.; if (!gVirtualX->IsCmdThread()) {; gROOT->ProcessLineFast(Form(""((TGLWidget *)0x%lx)->DoRedraw()"", this));; return;; }; R__LOCKGUARD2(gROOTMutex);. TGEventHandler * G",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGLWidget.html:21106,allocate,allocated,21106,root/html534/TGLWidget.html,https://root.cern,https://root.cern/root/html534/TGLWidget.html,3,['allocate'],['allocated']
Energy Efficiency,"axTerms ; (; Int_t ; terms). inline . Definition at line 201 of file TMultiDimFit.h. ◆ SetMinAngle(). void TMultiDimFit::SetMinAngle ; (; Double_t ; ang = 1). Set the min angle (in degrees) between a new candidate function and the subspace spanned by the previously accepted functions. ; See also class description ; Definition at line 2393 of file TMultiDimFit.cxx. ◆ SetMinRelativeError(). void TMultiDimFit::SetMinRelativeError ; (; Double_t ; error). Set the acceptable relative error for when sum of square residuals is considered minimized. ; For a full account, refer to the class description ; Definition at line 2458 of file TMultiDimFit.cxx. ◆ SetPowerLimit(). void TMultiDimFit::SetPowerLimit ; (; Double_t ; limit = 1e-3). Set the user parameter for the function selection. ; The bigger the limit, the more functions are used. The meaning of this variable is defined in the class description ; Definition at line 2433 of file TMultiDimFit.cxx. ◆ SetPowers(). void TMultiDimFit::SetPowers ; (; const Int_t * ; powers, . Int_t ; terms . ). virtual . Define a user function. ; The input array must be of the form (p11, ..., p1N, ... ,pL1, ..., pLN) Where N is the dimension of the data sample, L is the number of terms (given in terms) and the first number, labels the term, the second the variable. More information is given in the class description ; Definition at line 2413 of file TMultiDimFit.cxx. ◆ Streamer(). void TMultiDimFit::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void TMultiDimFit::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 207 of file TMultiDimFit.h. ◆ TestFunction(). Bool_t TMultiDimFit::TestFunction ; (; Double_t ; squareResidual, . Double_t ; dResidur . ). protectedvirtual . PRIVATE METHOD: Test whether the currently considered function contributes to the fit. ; See also class description ; Definition at line 2470 of fil",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMultiDimFit.html:59737,power,powers,59737,doc/master/classTMultiDimFit.html,https://root.cern,https://root.cern/doc/master/classTMultiDimFit.html,1,['power'],['powers']
Energy Efficiency,"axTerms). However, since there's an infinite number of to choose from, the; user is asked to give the maximum power. , of each variable; to be considered in the minimization of ; (TMultiDimFit::SetMaxPowers). One way of obtaining values for the maximum power in variable , is; to perform a regular fit to the dependent quantity , using a; polynomial only in . The maximum power is is then the; power that does not significantly improve the one-dimensional; least-square fit over to [5]. There are still a huge amount of possible choices for ; in fact; there are ; possible; choices. Obviously we need to limit this. To this end, the user is; asked to set a power control limit, ; (TMultiDimFit::SetPowerLimit), and a function; is only accepted if. where is the leading power of variable in function; . (TMultiDimFit::MakeCandidates). So the number of; functions increase with (1, 2 is fine, 5 is way out). Gram-Schmidt Orthogonalisation. To further reduce the number of functions in the final expression,; only those functions that significantly reduce is chosen. What; `significant' means, is chosen by the user, and will be; discussed below (see 2.3). The functions are generally not orthogonal, which means one will; have to evaluate all possible 's over all data-points before; finding the most significant [1]. We can, however, do; better then that. By applying the modified Gram-Schmidt; orthogonalisation algorithm [5] [3] to the; functions , we can evaluate the contribution to the reduction of; from each function in turn, and we may delay the actual inversion; of the curvature-matrix; (TMultiDimFit::MakeGramSchmidt). So we are let to consider an matrix ; , an; element of which is given by.    with. (3). where labels the rows in the training sample and labels; functions of variables, and . That is, is; the term (or function) numbered evaluated at the data point; . We have to normalise ; to for this to; succeed [5]; (TMultiDimFit::MakeNormalized). We then define a; matrix ; of which ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMultiDimFit.html:4689,reduce,reduce,4689,root/html528/TMultiDimFit.html,https://root.cern,https://root.cern/root/html528/TMultiDimFit.html,6,['reduce'],['reduce']
Energy Efficiency,"ay with using:; 744/// ~~~{.cpp}; 745/// MyClass *obj = (MyClass*)key->ReadObj();; 746/// ~~~; 747///; 748/// #### Example2: Usual case (recommended unless performance is critical); 749/// ~~~{.cpp}; 750/// MyClass *obj = dynamic_cast<MyClass*>(key->ReadObj());; 751/// ~~~; 752/// which support also the more complex inheritance like:; 753/// ~~~{.cpp}; 754/// class MyClass : public AnotherClass, public TObject; 755/// ~~~; 756///; 757/// Of course, `dynamic_cast<>` can also be used in the example 1.; 758 ; 759TObject *TKey::ReadObj(); 760{; 761 TClass *cl = TClass::GetClass(fClassName.Data());; 762 if (!cl) {; 763 Error(""ReadObj"", ""Unknown class %s"", fClassName.Data());; 764 return 0;; 765 }; 766 if (!cl->IsTObject()) {; 767 // in principle user should call TKey::ReadObjectAny!; 768 return (TObject*)ReadObjectAny(0);; 769 }; 770 ; 771 TBufferFile bufferRef(TBuffer::kRead, fObjlen+fKeylen);; 772 if (!bufferRef.Buffer()) {; 773 Error(""ReadObj"", ""Cannot allocate buffer: fObjlen = %d"", fObjlen);; 774 return 0;; 775 }; 776 if (GetFile()==0) return 0;; 777 bufferRef.SetParent(GetFile());; 778 bufferRef.SetPidOffset(fPidOffset);; 779 ; 780 std::unique_ptr<char []> compressedBuffer;; 781 auto storeBuffer = fBuffer;; 782 if (fObjlen > fNbytes-fKeylen) {; 783 compressedBuffer.reset(new char[fNbytes]);; 784 fBuffer = compressedBuffer.get();; 785 if( !ReadFile() ) //Read object structure from file; 786 {; 787 fBuffer = 0;; 788 return 0;; 789 }; 790 memcpy(bufferRef.Buffer(),fBuffer,fKeylen);; 791 } else {; 792 fBuffer = bufferRef.Buffer();; 793 if( !ReadFile() ) { //Read object structure from file; 794 ; 795 fBuffer = 0;; 796 return 0;; 797 }; 798 }; 799 fBuffer = storeBuffer;; 800 ; 801 // get version of key; 802 bufferRef.SetBufferOffset(sizeof(fNbytes));; 803 Version_t kvers = bufferRef.ReadVersion();; 804 ; 805 bufferRef.SetBufferOffset(fKeylen);; 806 TObject *tobj = 0;; 807 // Create an instance of this class; 808 ; 809 char *pobj = (char*)cl->New();; 810 if (!pobj) {; 811",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TKey_8cxx_source.html:27776,allocate,allocate,27776,doc/master/TKey_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TKey_8cxx_source.html,1,['allocate'],['allocate']
Energy Efficiency,"ay(fClonesClass);; 5318 }; 5319 fObject = (char*) *pp;; 5320 }; 5321 }; 5322 } else {; 5323 // -- We have been given a zero address, allocate for top-level only.; 5324 if (fStreamerType == TVirtualStreamerInfo::kObject) {; 5325 // -- We are *not* a top-level branch and we are *not* a pointer to a TClonesArray.; 5326 // Case of an embedded TClonesArray.; 5327 Error(""SetAddress"", ""Embedded TClonesArray given a zero address for branch '%s'"", GetName());; 5328 } else {; 5329 // -- We are either a top-level branch or we are a subbranch which is a pointer to a TClonesArray.; 5330 // Streamer type should be -1 (for a top-level branch) or kObject(p|P) here.; 5331 if ((fStreamerType != -1) &&; 5332 (fStreamerType != TVirtualStreamerInfo::kObjectp) &&; 5333 (fStreamerType != TVirtualStreamerInfo::kObjectP)) {; 5334 Error(""SetAddress"", ""TClonesArray with fStreamerType: %d"", fStreamerType);; 5335 } else if (fStreamerType == -1) {; 5336 // -- We are a top-level branch.; 5337 // Idea: Consider making a zero address not allocate.; 5338 SetBit(kDeleteObject);; 5339 fObject = (char*) new TClonesArray(fClonesClass);; 5340 fAddress = (char*) &fObject;; 5341 } else {; 5342 // -- We are a sub-branch which is a pointer to a TClonesArray.; 5343 Error(""SetAddress"", ""Embedded pointer to a TClonesArray given a zero address for branch '%s'"", GetName());; 5344 }; 5345 }; 5346 }; 5347 } else if (fType == 4) {; 5348 // -- We are an STL container master branch.; 5349 //; 5350 // Initialize fCollProxy.; 5351 TVirtualCollectionProxy* proxy = GetCollectionProxy();; 5352 if (fAddress) {; 5353 // -- We have been given a non-zero address, allocate if necessary.; 5354 if ((fStreamerType == TVirtualStreamerInfo::kObject) ||; 5355 (fStreamerType == TVirtualStreamerInfo::kAny) ||; 5356 (fStreamerType == TVirtualStreamerInfo::kSTL)) {; 5357 // We are *not* a top-level branch and we are *not* a pointer to an STL container.; 5358 // Case of an embedded STL container.; 5359 // Note: We test for the kObject and",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBranchElement_8cxx_source.html:197688,allocate,allocate,197688,doc/master/TBranchElement_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html,1,['allocate'],['allocate']
Energy Efficiency,"ay* clones, Int_t i, Int_t j, Int_t k, Int_t eoffset) const; return value of element i in object number j in a TClonesArray and eventually; element k in a sub-array. Double_t GetValueSTL(TVirtualCollectionProxy* cont, Int_t i, Int_t j, Int_t k, Int_t eoffset) const; return value of element i in object number j in a TClonesArray and eventually; element k in a sub-array. Double_t GetValueSTLP(TVirtualCollectionProxy* cont, Int_t i, Int_t j, Int_t k, Int_t eoffset) const; return value of element i in object number j in a TClonesArray and eventually; element k in a sub-array. void InsertArtificialElements(const TObjArray* rules); Insert new members as expressed in the array of TSchemaRule(s). void ls(Option_t* option = """") const; List the TStreamerElement list and also the precomputed tables. void* New(void* obj = 0); An emulated object is created at address obj, if obj is null we; allocate memory for the object. void* NewArray(Long_t nElements, void* ary = 0); An array of emulated objects is created at address ary, if ary is null,; we allocate memory for the array. void DestructorImpl(void* p, Bool_t dtorOnly); Internal part of the destructor.; Destruct each of the datamembers in the same order; as the implicit destructor would. void Destructor(void* p, Bool_t dtorOnly = kFALSE); Emulated destructor for this class.; An emulated object is destroyed at address p.; Destruct each of the datamembers in the same order; as the implicit destructor would. void DeleteArray(void* p, Bool_t dtorOnly = kFALSE); Destroy an array of emulated objects, with optional delete. void PrintValue(const char* name, char* pointer, Int_t i, Int_t len, Int_t lenmax = 1000) const; print value of element i in object at pointer; The function may be called in two ways:; -method1 len < 0; i is assumed to be the TStreamerElement number i in StreamerInfo; -method2 len >= 0; i is the type; address of variable is directly pointer.; len is the number of elements to be printed starting at pointer. void Prin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TStreamerInfo.html:22082,allocate,allocate,22082,root/html528/TStreamerInfo.html,https://root.cern,https://root.cern/root/html528/TStreamerInfo.html,3,['allocate'],['allocate']
Energy Efficiency,"ayTPointSet3D::fIdsUser-provided point identifications; Short_tTEveElement::fImpliedHighlighted!; Short_tTEveElement::fImpliedSelected!; TArrayI*fIntIdsOptional array of integer ideices.; Int_tfIntIdsPerPointNumber of integer indices assigned to each point.; TEveElement::sLTI_tTEveElement::fItems! Set of list-tree-items.; Int_tTPolyMarker3D::fLastPointThe index of the last filled point; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Color_t*TEveElement::fMainColorPtrPointer to main-color variable.; TEveTrans*TEveElement::fMainTransPointer to main transformation matrix.; Char_tTEveElement::fMainTransparencyMain-transparency variable.; Color_tTAttMarker::fMarkerColorMarker color index; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; Int_tTPolyMarker3D::fNNumber of allocated points; TStringTPolyMarker3D::fNameName of polymarker; Int_tTEveElement::fNumChildren!; TStringTPolyMarker3D::fOptionOptions; Bool_tTPointSet3D::fOwnIdsFlag specifying id-objects are owned by the point-set; Float_t*TPolyMarker3D::fP[3*fN] Array of X,Y,Z coordinates; Int_tTEveElement::fParentIgnoreCnt! Counter for parents that are ignored in ref-counting.; TEveElement::List_tTEveElement::fParentsList of parents.; Bool_tTEveElement::fPickable; TEveProjectable::ProjList_tTEveProjectable::fProjectedListreferences to projected instances.; Bool_tTEveElement::fRnrChildrenRender children of this element.; Bool_tTEveElement::fRnrSelfRender this element.; Bool_tTEveElement::fSelected!; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; TRefTEveElement::fSourceExternal object that is represented by this element.; TEvePointSelectorConsumer::ETreeVarType_eTEvePointSelectorConsumer::fSourceCSCoordinate-System of the source tree variables; TStringfTitleTitle/tooltip of the TEvePointSet.; Int_tTEveElement::fTopItemCnt! Counter for top-level list-tree items that preve",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEvePointSet.html:26129,allocate,allocated,26129,root/html602/TEvePointSet.html,https://root.cern,https://root.cern/root/html602/TEvePointSet.html,2,['allocate'],['allocated']
Energy Efficiency,"b) {; 2015 if (!fRealData) BuildRealData();; 2016 ; 2017 b->Add(GetListOfDataMembers(), ""Data Members"");; 2018 b->Add(GetListOfRealData(), ""Real Data Members"");; 2019 b->Add(GetListOfMethods(), ""Methods"");; 2020 b->Add(GetListOfBases(), ""Base Classes"");; 2021 }; 2022}; 2023 ; 2024////////////////////////////////////////////////////////////////////////////////; 2025/// Build a full list of persistent data members.; 2026/// Scans the list of all data members in the class itself and also; 2027/// in all base classes. For each persistent data member, inserts a; 2028/// TRealData object in the list fRealData.; 2029///; 2030 ; 2031void TClass::BuildRealData(void* pointer, Bool_t isTransient); 2032{; 2033 ; 2034 R__LOCKGUARD(gInterpreterMutex);; 2035 ; 2036 // Only do this once.; 2037 if (fRealData) {; 2038 return;; 2039 }; 2040 ; 2041 if (fClassVersion == 0) {; 2042 isTransient = kTRUE;; 2043 }; 2044 ; 2045 // When called via TMapFile (e.g. Update()) make sure that the dictionary; 2046 // gets allocated on the heap and not in the mapped file.; 2047 TMmallocDescTemp setreset;; 2048 ; 2049 // Handle emulated classes and STL containers specially.; 2050 if (!HasInterpreterInfo() || TClassEdit::IsSTLCont(GetName(), 0) || TClassEdit::IsSTLBitset(GetName())) {; 2051 // We are an emulated class or an STL container.; 2052 fRealData = new TList;; 2053 BuildEmulatedRealData("""", 0, this, isTransient);; 2054 return;; 2055 }; 2056 ; 2057 // return early on string; 2058 static TClassRef clRefString(""std::string"");; 2059 if (clRefString == this) {; 2060 return;; 2061 }; 2062 ; 2063 // Complain about stl classes ending up here (unique_ptr etc) - except for; 2064 // pair where we will build .first, .second just fine; 2065 // and those for which the user explicitly requested a dictionary.; 2066 if (!isTransient && GetState() != kHasTClassInit; 2067 && TClassEdit::IsStdClass(GetName()); 2068 && !TClassEdit::IsStdPair(GetName())) {; 2069 Error(""BuildRealData"", ""Inspection for %s not supported",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:76625,allocate,allocated,76625,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['allocate'],['allocated']
Energy Efficiency,"b) {; 2082 if (!fRealData) BuildRealData();; 2083 ; 2084 b->Add(GetListOfDataMembers(), ""Data Members"");; 2085 b->Add(GetListOfRealData(), ""Real Data Members"");; 2086 b->Add(GetListOfMethods(), ""Methods"");; 2087 b->Add(GetListOfBases(), ""Base Classes"");; 2088 }; 2089}; 2090 ; 2091////////////////////////////////////////////////////////////////////////////////; 2092/// Build a full list of persistent data members.; 2093/// Scans the list of all data members in the class itself and also; 2094/// in all base classes. For each persistent data member, inserts a; 2095/// TRealData object in the list fRealData.; 2096///; 2097 ; 2098void TClass::BuildRealData(void* pointer, Bool_t isTransient); 2099{; 2100 ; 2101 R__LOCKGUARD(gInterpreterMutex);; 2102 ; 2103 // Only do this once.; 2104 if (fRealData) {; 2105 return;; 2106 }; 2107 ; 2108 if (fClassVersion == 0) {; 2109 isTransient = kTRUE;; 2110 }; 2111 ; 2112 // When called via TMapFile (e.g. Update()) make sure that the dictionary; 2113 // gets allocated on the heap and not in the mapped file.; 2114 TMmallocDescTemp setreset;; 2115 ; 2116 // Handle emulated classes and STL containers specially.; 2117 if (!HasInterpreterInfo() || TClassEdit::IsSTLCont(GetName(), 0) || TClassEdit::IsSTLBitset(GetName())) {; 2118 // We are an emulated class or an STL container.; 2119 fRealData = new TList;; 2120 BuildEmulatedRealData("""", 0, this, isTransient);; 2121 return;; 2122 }; 2123 ; 2124 // return early on string; 2125 static TClassRef clRefString(""std::string"");; 2126 if (clRefString == this) {; 2127 return;; 2128 }; 2129 ; 2130 // Complain about stl classes ending up here (unique_ptr etc) - except for; 2131 // pair where we will build .first, .second just fine; 2132 // and those for which the user explicitly requested a dictionary.; 2133 if (!isTransient && GetState() != kHasTClassInit; 2134 && TClassEdit::IsStdClass(GetName()); 2135 && !TClassEdit::IsStdPair(GetName())) {; 2136 Error(""BuildRealData"", ""Inspection for %s not supported",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:79376,allocate,allocated,79376,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['allocate'],['allocated']
Energy Efficiency,"b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixT<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> GetMatrix2Array(double* data, Option_t* = """") const; Copy matrix data to array . It is assumed that array is of size >= fNelems. TMatrixTBase<Element> &TMatrixTSparse<Element> SetMatrixArray(Int_t nr_nonzeros, Int_t* irow, Int_t* icol, double* data); Copy nr elements from row/col index and data array to matrix . It is assumed; that arrays are of size >= nr. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndex(Int_t nelem_new); Increase/decrease the number of non-zero elements to nelems_new. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndex(const TMatrixTBase<double>& another); Use non-zero data of matrix source to set the sparse structure. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMatrixTSparse_double_.html:19097,allocate,allocated,19097,root/html528/TMatrixTSparse_double_.html,https://root.cern,https://root.cern/root/html528/TMatrixTSparse_double_.html,1,['allocate'],['allocated']
Energy Efficiency,"b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixT<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> GetMatrix2Array(double* data, Option_t* = """") const; Copy matrix data to array . It is assumed that array is of size >= fNelems. TMatrixTBase<Element> &TMatrixTSparse<Element> SetMatrixArray(Int_t nr_nonzeros, Int_t* irow, Int_t* icol, double* data); Copy nr elements from row/col index and data array to matrix . It is assumed; that arrays are of size >= nr; Note that the input arrays are not passed as const since they will be modified !. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndex(Int_t nelem_new); Increase/decrease the number of non-zero elements to nelems_new. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndex(const TMatrixTBase<double>& another); Use non-zero data of matrix source t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMatrixTSparse_double_.html:19282,allocate,allocated,19282,root/html530/TMatrixTSparse_double_.html,https://root.cern,https://root.cern/root/html530/TMatrixTSparse_double_.html,5,['allocate'],['allocated']
Energy Efficiency,"b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixT<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> GetMatrix2Array(float* data, Option_t* = """") const; Copy matrix data to array . It is assumed that array is of size >= fNelems. TMatrixTBase<Element> &TMatrixTSparse<Element> SetMatrixArray(Int_t nr_nonzeros, Int_t* irow, Int_t* icol, float* data); Copy nr elements from row/col index and data array to matrix . It is assumed; that arrays are of size >= nr. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndex(Int_t nelem_new); Increase/decrease the number of non-zero elements to nelems_new. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndex(const TMatrixTBase<float>& another); Use non-zero data of matrix source to set the sparse structure. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSpars",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMatrixTSparse_float_.html:18880,allocate,allocated,18880,root/html528/TMatrixTSparse_float_.html,https://root.cern,https://root.cern/root/html528/TMatrixTSparse_float_.html,1,['allocate'],['allocated']
Energy Efficiency,"b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixT<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> GetMatrix2Array(float* data, Option_t* = """") const; Copy matrix data to array . It is assumed that array is of size >= fNelems. TMatrixTBase<Element> &TMatrixTSparse<Element> SetMatrixArray(Int_t nr_nonzeros, Int_t* irow, Int_t* icol, float* data); Copy nr elements from row/col index and data array to matrix . It is assumed; that arrays are of size >= nr; Note that the input arrays are not passed as const since they will be modified !. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndex(Int_t nelem_new); Increase/decrease the number of non-zero elements to nelems_new. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndex(const TMatrixTBase<float>& another); Use non-zero data of matrix source to s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMatrixTSparse_float_.html:19065,allocate,allocated,19065,root/html530/TMatrixTSparse_float_.html,https://root.cern,https://root.cern/root/html530/TMatrixTSparse_float_.html,5,['allocate'],['allocated']
Energy Efficiency,"base, TGLVector3* axis) const; const UChar_t*TGLManip::ColorFor(UInt_t widget) const; TGLManip&TGLManip::operator=(const TGLManip&). private:. voidLimitScale(Double_t& factor) const. Data Members; protected:. Bool_tTGLManip::fActive! manipulator is active?; TPointTGLManip::fFirstMouse! first (start) mouse position (in WINDOW coords); TPointTGLManip::fLastMouse! last (latest) mouse position (in WINDOW coords); UInt_tTGLManip::fSelectedWidget! active width (axis) component; TGLPhysicalShape*TGLManip::fShape! manipulated shape. private:. TGLVector3fStartScale! initial scaling factors. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLScaleManip(); Construct scale manipulator not bound to any physical shape. TGLScaleManip(TGLPhysicalShape* shape); Construct scale manipulator bound to TGLPhysicalShape 'shape'. ~TGLScaleManip(); Destory the scale manipulator. void Draw(const TGLCamera& camera) const; Draw scale manipulator - tubes with box heads, in local axes of; attached shape, in red(X), green(Y) and blue(Z), with white center sphere.; If selected widget (mouse over) this is drawn in active colour (yellow). Bool_t HandleButton(const Event_t& event, const TGLCamera& camera); Handle mouse button event over manipulator - returns kTRUE if; redraw required kFALSE otherwise. Bool_t HandleMotion(const Event_t& event, const TGLCamera& camera); Handle mouse motion over manipulator - if active (selected; widget) scale physical along selected widget (axis) of the; manipulator, so it tracks mouse action. Returns kTRUE if redraw; required kFALSE otherwise. void LimitScale(Double_t& factor) const; Clamp scale to sizable values: 1000 - 1/1000; Guards against div by zero problems. TGLScaleManip(). » Author: Richard Maunder 16/09/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id$ » Last generated: 2015-03-13 19:26; This page has been automatically generated. For comments or suggestions regarding the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGLScaleManip.html:2587,green,green,2587,root/html534/TGLScaleManip.html,https://root.cern,https://root.cern/root/html534/TGLScaleManip.html,1,['green'],['green']
Energy Efficiency,"base, TGLVector3* axis) const; const UChar_t*TGLManip::ColorFor(UInt_t widget) const; TGLManip&TGLManip::operator=(const TGLManip&). private:. voidLimitScale(Double_t& factor) const. Data Members; protected:. Bool_tTGLManip::fActive! manipulator is active?; TPointTGLManip::fFirstMouse! first (start) mouse position (in WINDOW coords); TPointTGLManip::fLastMouse! last (latest) mouse position (in WINDOW coords); UInt_tTGLManip::fSelectedWidget! active width (axis) component; TGLPhysicalShape*TGLManip::fShape! manipulated shape. private:. TGLVector3fStartScale! initial scaling factors. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLScaleManip(); Construct scale manipulator not bound to any physical shape. TGLScaleManip(TGLPhysicalShape* shape); Construct scale manipulator bound to TGLPhysicalShape 'shape'. ~TGLScaleManip(); Destory the scale manipulator. void Draw(const TGLCamera& camera) const; Draw scale manipulator - tubes with box heads, in local axes of; attached shape, in red(X), green(Y) and blue(Z), with white center sphere.; If selected widget (mouse over) this is drawn in active colour (yellow). Bool_t HandleButton(const Event_t& event, const TGLCamera& camera); Handle mouse button event over manipulator - returns kTRUE if; redraw required kFALSE otherwise. Bool_t HandleMotion(const Event_t& event, const TGLCamera& camera); Handle mouse motion over manipulator - if active (selected; widget) scale physical along selected widget (axis) of the; manipulator, so it tracks mouse action. Returns kTRUE if redraw; required kFALSE otherwise. void LimitScale(Double_t& factor) const; Clamp scale to sizable values: 1000 - 1/1000; Guards against div by zero problems. TGLScaleManip(). » Author: Richard Maunder 16/09/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLScaleManip.h 30815 2009-10-20 13:49:22Z rdm $ » Last generated: 2010-09-23 20:06; This page has been automatically gen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGLScaleManip.html:2568,green,green,2568,root/html528/TGLScaleManip.html,https://root.cern,https://root.cern/root/html528/TGLScaleManip.html,1,['green'],['green']
Energy Efficiency,"base, TGLVector3* axis) const; const UChar_t*TGLManip::ColorFor(UInt_t widget) const; TGLManip&TGLManip::operator=(const TGLManip&). private:. voidLimitScale(Double_t& factor) const. Data Members; protected:. Bool_tTGLManip::fActive! manipulator is active?; TPointTGLManip::fFirstMouse! first (start) mouse position (in WINDOW coords); TPointTGLManip::fLastMouse! last (latest) mouse position (in WINDOW coords); UInt_tTGLManip::fSelectedWidget! active width (axis) component; TGLPhysicalShape*TGLManip::fShape! manipulated shape. private:. TGLVector3fStartScale! initial scaling factors. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLScaleManip(); Construct scale manipulator not bound to any physical shape. TGLScaleManip(TGLPhysicalShape* shape); Construct scale manipulator bound to TGLPhysicalShape 'shape'. ~TGLScaleManip(); Destory the scale manipulator. void Draw(const TGLCamera& camera) const; Draw scale manipulator - tubes with box heads, in local axes of; attached shape, in red(X), green(Y) and blue(Z), with white center sphere.; If selected widget (mouse over) this is drawn in active colour (yellow). Bool_t HandleButton(const Event_t& event, const TGLCamera& camera); Handle mouse button event over manipulator - returns kTRUE if; redraw required kFALSE otherwise. Bool_t HandleMotion(const Event_t& event, const TGLCamera& camera); Handle mouse motion over manipulator - if active (selected; widget) scale physical along selected widget (axis) of the; manipulator, so it tracks mouse action. Returns kTRUE if redraw; required kFALSE otherwise. void LimitScale(Double_t& factor) const; Clamp scale to sizable values: 1000 - 1/1000; Guards against div by zero problems. TGLScaleManip(). » Author: Richard Maunder 16/09/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLScaleManip.h 30815 2009-10-20 13:49:22Z rdm $ » Last generated: 2011-07-04 15:29; This page has been automatically gen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGLScaleManip.html:2568,green,green,2568,root/html530/TGLScaleManip.html,https://root.cern,https://root.cern/root/html530/TGLScaleManip.html,1,['green'],['green']
Energy Efficiency,"base, TGLVector3* axis) const; const UChar_t*TGLManip::ColorFor(UInt_t widget) const; TGLManip&TGLManip::operator=(const TGLManip&). private:. voidLimitScale(Double_t& factor) const. Data Members; protected:. Bool_tTGLManip::fActive! manipulator is active?; TPointTGLManip::fFirstMouse! first (start) mouse position (in WINDOW coords); TPointTGLManip::fLastMouse! last (latest) mouse position (in WINDOW coords); UInt_tTGLManip::fSelectedWidget! active width (axis) component; TGLPhysicalShape*TGLManip::fShape! manipulated shape. private:. TGLVector3fStartScale! initial scaling factors. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLScaleManip(); Construct scale manipulator not bound to any physical shape. TGLScaleManip(TGLPhysicalShape* shape); Construct scale manipulator bound to TGLPhysicalShape 'shape'. ~TGLScaleManip(); Destory the scale manipulator. void Draw(const TGLCamera& camera) const; Draw scale manipulator - tubes with box heads, in local axes of; attached shape, in red(X), green(Y) and blue(Z), with white center sphere.; If selected widget (mouse over) this is drawn in active colour (yellow). Bool_t HandleButton(const Event_t& event, const TGLCamera& camera); Handle mouse button event over manipulator - returns kTRUE if; redraw required kFALSE otherwise. Bool_t HandleMotion(const Event_t& event, const TGLCamera& camera); Handle mouse motion over manipulator - if active (selected; widget) scale physical along selected widget (axis) of the; manipulator, so it tracks mouse action. Returns kTRUE if redraw; required kFALSE otherwise. void LimitScale(Double_t& factor) const; Clamp scale to sizable values: 1000 - 1/1000; Guards against div by zero problems. TGLScaleManip(). » Author: Richard Maunder 16/09/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLScaleManip.h 30815 2009-10-20 13:49:22Z rdm $ » Last generated: 2011-11-03 20:14; This page has been automatically gen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGLScaleManip.html:2568,green,green,2568,root/html532/TGLScaleManip.html,https://root.cern,https://root.cern/root/html532/TGLScaleManip.html,1,['green'],['green']
Energy Efficiency,"basePDG::~TDatabasePDG ; (; ). override . Cleanup the PDG database. ; Definition at line 85 of file TDatabasePDG.cxx. Member Function Documentation. ◆ AddAntiParticle(). TParticlePDG * TDatabasePDG::AddAntiParticle ; (; const char * ; Name, . Int_t ; PdgCode . ). virtual . assuming particle has already been defined ; Definition at line 193 of file TDatabasePDG.cxx. ◆ AddParticle(). TParticlePDG * TDatabasePDG::AddParticle ; (; const char * ; name, . const char * ; title, . Double_t ; mass, . Bool_t ; stable, . Double_t ; width, . Double_t ; charge, . const char * ; ParticleClass, . Int_t ; PDGcode, . Int_t ; Anti = -1, . Int_t ; TrackingCode = 0 . ). virtual . Particle definition normal constructor. ; If the particle is set to be stable, the decay width parameter does have no meaning and can be set to any value. The parameters granularity, LowerCutOff and HighCutOff are used for the construction of the mean free path look up tables. The granularity will be the number of logwise energy points for which the mean free path will be calculated. ; Definition at line 156 of file TDatabasePDG.cxx. ◆ Browse(). void TDatabasePDG::Browse ; (; TBrowser * ; b). overridevirtual . browse data base ; Reimplemented from TObject.; Definition at line 775 of file TDatabasePDG.cxx. ◆ BuildPdgMap(). void TDatabasePDG::BuildPdgMap ; (; ); const. protected . Build fPdgMap mapping pdg-code to particle. ; Initial size is set so as to be able to hold at least 600 particles: 521 in default table, ALICE adds 54 more. To be revisited after LHC discovers SUSY. ; Definition at line 127 of file TDatabasePDG.cxx. ◆ Class(). static TClass * TDatabasePDG::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TDatabasePDG::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TDatabasePDG::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 83 of file TDatabasePDG.h. ◆ C",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDatabasePDG.html:15587,energy,energy,15587,doc/master/classTDatabasePDG.html,https://root.cern,https://root.cern/doc/master/classTDatabasePDG.html,1,['energy'],['energy']
Energy Efficiency,"be C++ code. ; Definition at line 402 of file TDocParser.cxx. ◆ DeclFileName(). static const char * TDocParser::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 187 of file TDocParser.h. ◆ DecorateKeywords() [1/2]. void TDocParser::DecorateKeywords ; (; std::ostream & ; out, . const char * ; text . ). virtual . Expand keywords in text, writing to out. ; Definition at line 450 of file TDocParser.cxx. ◆ DecorateKeywords() [2/2]. void TDocParser::DecorateKeywords ; (; TString & ; line). virtual . Find keywords in line and create URLs around them. ; Escape characters with a special meaning for HTML. Protect ""Begin_Html""/""End_Html"" pairs, and set the parsing context. Evaluate sequences like a::b->c. Skip regions where directives are active. ; Definition at line 463 of file TDocParser.cxx. ◆ DecrementMethodCount(). void TDocParser::DecrementMethodCount ; (; const char * ; name). reduce method count for method called name, removing it from fMethodCounts once the count reaches 0. ; Definition at line 869 of file TDocParser.cxx. ◆ DeleteDirectiveOutput(). void TDocParser::DeleteDirectiveOutput ; (; ); const. virtual . Delete output generated by prior runs of all known directives; the output file names might have changes. ; Definition at line 884 of file TDocParser.cxx. ◆ ExpandCPPLine(). void TDocParser::ExpandCPPLine ; (; TString & ; line, . Ssiz_t & ; pos . ). protectedvirtual . Expand preprocessor statements. ; Input: line - line containing the CPP statement, pos - position of '#'; NOTE: Looks for the #include statements and creates link to the corresponding file if such file exists ; Definition at line 911 of file TDocParser.cxx. ◆ GetCurrentClass(). TClass * TDocParser::GetCurrentClass ; (; ); const. inline . Definition at line 171 of file TDocParser.h. ◆ GetCurrentModule(). void TDocParser::GetCurrentModule ; (; TString & ; out_module); const. Return the name of module for which sources are currently parse",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDocParser.html:21353,reduce,reduce,21353,doc/master/classTDocParser.html,https://root.cern,https://root.cern/doc/master/classTDocParser.html,1,['reduce'],['reduce']
Energy Efficiency,"be strictly; reshuffled. In this mode events of the protodata may be used more than; once. If ProtoData() is used, the specified existing dataset as a prototype: the new dataset will contain; the same number of events as the prototype (unless otherwise specified), and any prototype variables not in; whatVars will be copied into the new dataset for each generated event and also used to set our PDF parameters.; The user can specify a number of events to generate that will override the default. The result is a; copy of the prototype dataset with only variables in whatVars randomized. Variables in whatVars that; are not in the prototype will be added as new columns to the generated dataset. RooDataSet * generate(RooAbsPdf::GenSpec& ) const; Generate data according to a pre-configured specification created by; RooAbsPdf::prepareMultiGen(). If many identical generation requests; are needed, e.g. in toy MC studies, it is more efficient to use the prepareMultiGen()/generate(); combination than calling the standard generate() multiple times as; initialization overhead is only incurred once. RooDataSet * generate(const RooArgSet& whatVars, Double_t nEvents = 0, Bool_t verbose = kFALSE, Bool_t autoBinned = kTRUE, const char* binnedTag = """", Bool_t expectedData = kFALSE, Bool_t extended = kFALSE) const; Generate a new dataset containing the specified variables with; events sampled from our distribution. Generate the specified; number of events or else try to use expectedEvents() if nEvents <= 0.; Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. RooDataSet * generate(RooAbsGenContext& context, const RooArgSet& whatVars, const RooDataSet* prototype, Double_t nEvents, Bool_t verbose, Bool_t randProtoOrder, Bool_t resampleProto, Bool_t skipInit = kFALSE, Bool_t extended = kFALSE) const; Internal method. RooDataSet * generate(co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsPdf.html:67741,efficient,efficient,67741,root/html534/RooAbsPdf.html,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html,3,['efficient'],['efficient']
Energy Efficiency,"be strictly; reshuffled. In this mode events of the protodata may be used more than; once. If ProtoData() is used, the specified existing dataset as a prototype: the new dataset will contain; the same number of events as the prototype (unless otherwise specified), and any prototype variables not in; whatVars will be copied into the new dataset for each generated event and also used to set our PDF parameters.; The user can specify a number of events to generate that will override the default. The result is a; copy of the prototype dataset with only variables in whatVars randomized. Variables in whatVars that; are not in the prototype will be added as new columns to the generated dataset. RooDataSet * generate(RooAbsPdf::GenSpec& ) const; Generate data according to a pre-configured specification created by; RooAbsPdf::prepareMultiGen(). If many identical generation requests; are needed, e.g. in toy MC studies, it is more efficient to use the prepareMultiGen()/generate(); combination than calling the standard generate() multiple times as; initialization overhead is only incurred once. RooDataSet * generate(const RooArgSet& whatVars, Int_t nEvents = 0, Bool_t verbose = kFALSE) const; Generate a new dataset containing the specified variables with; events sampled from our distribution. Generate the specified; number of events or else try to use expectedEvents() if nEvents <= 0.; Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. RooDataSet * generate(RooAbsGenContext& context, const RooArgSet &whatVars, const RooDataSet *prototype,				Int_t nEvents, Bool_t /*verbose*/, Bool_t randProtoOrder, Bool_t resampleProto); Internal method. RooDataSet * generate(const RooArgSet& whatVars, const RooDataSet& prototype, Int_t nEvents = 0, Bool_t verbose = kFALSE, Bool_t randProtoOrder = kFALSE, Bool_t resampleProto = kFALSE) const; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsPdf.html:59585,efficient,efficient,59585,root/html526/RooAbsPdf.html,https://root.cern,https://root.cern/root/html526/RooAbsPdf.html,1,['efficient'],['efficient']
Energy Efficiency,"be strictly; reshuffled. In this mode events of the protodata may be used more than; once. If ProtoData() is used, the specified existing dataset as a prototype: the new dataset will contain; the same number of events as the prototype (unless otherwise specified), and any prototype variables not in; whatVars will be copied into the new dataset for each generated event and also used to set our PDF parameters.; The user can specify a number of events to generate that will override the default. The result is a; copy of the prototype dataset with only variables in whatVars randomized. Variables in whatVars that; are not in the prototype will be added as new columns to the generated dataset. RooDataSet * generate(RooAbsPdf::GenSpec& ) const; Generate data according to a pre-configured specification created by; RooAbsPdf::prepareMultiGen(). If many identical generation requests; are needed, e.g. in toy MC studies, it is more efficient to use the prepareMultiGen()/generate(); combination than calling the standard generate() multiple times as; initialization overhead is only incurred once. RooDataSet * generate(const RooArgSet& whatVars, Int_t nEvents = 0, Bool_t verbose = kFALSE) const; Generate a new dataset containing the specified variables with; events sampled from our distribution. Generate the specified; number of events or else try to use expectedEvents() if nEvents <= 0.; Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. RooDataSet * generate(RooAbsGenContext& context, const RooArgSet& whatVars, const RooDataSet* prototype, Int_t nEvents, Bool_t verbose, Bool_t randProtoOrder, Bool_t resampleProto) const; Internal method. RooDataSet * generate(const RooArgSet& whatVars, const RooDataSet& prototype, Int_t nEvents = 0, Bool_t verbose = kFALSE, Bool_t randProtoOrder = kFALSE, Bool_t resampleProto = kFALSE) const; G",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsPdf.html:60573,efficient,efficient,60573,root/html528/RooAbsPdf.html,https://root.cern,https://root.cern/root/html528/RooAbsPdf.html,2,['efficient'],['efficient']
Energy Efficiency,"be strictly; reshuffled. In this mode events of the protodata may be used more than; once. If ProtoData() is used, the specified existing dataset as a prototype: the new dataset will contain; the same number of events as the prototype (unless otherwise specified), and any prototype variables not in; whatVars will be copied into the new dataset for each generated event and also used to set our PDF parameters.; The user can specify a number of events to generate that will override the default. The result is a; copy of the prototype dataset with only variables in whatVars randomized. Variables in whatVars that; are not in the prototype will be added as new columns to the generated dataset. RooDataSet * generate(RooAbsPdf::GenSpec& ) const; Generate data according to a pre-configured specification created by; RooAbsPdf::prepareMultiGen(). If many identical generation requests; are needed, e.g. in toy MC studies, it is more efficient to use the prepareMultiGen()/generate(); combination than calling the standard generate() multiple times as; initialization overhead is only incurred once. RooDataSet * generate(const RooArgSet& whatVars, Int_t nEvents = 0, Bool_t verbose = kFALSE, Bool_t autoBinned = kTRUE, const char* binnedTag = """", Bool_t expectedData = kFALSE) const; Generate a new dataset containing the specified variables with; events sampled from our distribution. Generate the specified; number of events or else try to use expectedEvents() if nEvents <= 0.; Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. RooDataSet * generate(RooAbsGenContext& context, const RooArgSet& whatVars, const RooDataSet* prototype, Int_t nEvents, Bool_t verbose, Bool_t randProtoOrder, Bool_t resampleProto, Bool_t skipInit = kFALSE, Bool_t extended = kFALSE) const; Internal method. RooDataSet * generate(const RooArgSet& whatVars, const R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsPdf.html:63963,efficient,efficient,63963,root/html532/RooAbsPdf.html,https://root.cern,https://root.cern/root/html532/RooAbsPdf.html,1,['efficient'],['efficient']
Energy Efficiency,"bers:; find the mapping of data members to otuput list entries in the output list; and apply it. Long64_t Finalize(Bool_t force = kFALSE, Bool_t sync = kFALSE). Long64_t Finalize(TQueryResult* qr); Finalize the results of a query already processed. Bool_t SendSelector(const char* selector_file); Send the selector file(s) to master or worker nodes. void MergeOutput(); Merge objects in output the lists. void Progress(Long64_t total, Long64_t processed); Progress signal. void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti); Progress signal. void Progress(TProofProgressInfo* pi); Progress signal. void Feedback(TList* objs); Feedback signal. void StopProcess(Bool_t abort, Int_t timeout = -1); Stop process after this event. Int_t AddOutputObject(TObject* obj); Incorporate the received object 'obj' into the output list fOutput.; The latter is created if not existing.; This method short cuts 'StoreOutput + MergeOutput' optimizing the memory; consumption.; Returns -1 in case of error, 1 if the object has been merged into another; one (so that its ownership has not been taken and can be deleted), and 0; otherwise. void RedirectOutput(Bool_t on = kTRUE); Control output redirection to TProof::fLogFileW. void AddOutput(TList* out); Incorporate the content of the received output list 'out' into the final; output list fOutput. The latter is created if not existing.; This method short cuts 'StoreOutput + MergeOutput' limiting the memory; consumption. void NotifyMemory(TObject* obj); Printout the memory record after merging object 'obj'; This record is used by the memory monitor. void SetLastMergingMsg(TObject* obj); Set the message to be notified in case of exception. Int_t Incorporate(TObject* obj, TList* out, Bool_t& merged); Incorporate object 'newobj' in the list 'outlist'.; The object is merged with an object of the same name already existing in; the list, or just added.; The boolean merged is ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofPlayerRemote.html:17298,consumption,consumption,17298,root/html528/TProofPlayerRemote.html,https://root.cern,https://root.cern/root/html528/TProofPlayerRemote.html,4,['consumption'],['consumption']
Energy Efficiency,"between updates; Long64_tTVirtualPacketizer::fTotalEntriestotal number of entries to be distributed;; TVirtualPacketizer::EUseEstOptTVirtualPacketizer::fUseEstOptControl usage of estimated values for the progress info; Bool_tTVirtualPacketizer::fValidConstructed properly?; static TVirtualPacketizer::EUseEstOptTVirtualPacketizer::kEstAverage; static TVirtualPacketizer::EUseEstOptTVirtualPacketizer::kEstCurrent; static TVirtualPacketizer::EUseEstOptTVirtualPacketizer::kEstOff. private:. TList*fActivenodes with unfinished files; Float_tfBaseLocalPreferenceindicates how much more likely the nodes will be; Bool_tfCachePacketSynccontrol synchronization of cache and packet sizes; TList*fFileNodesnodes with files; TSortedList*fFilesToProcessGlobal list of files (TFileStat) to be processed; Bool_tfForceLocalif 1 - eliminate the remote processing; Float_tfFractionOfRemoteFilesfraction of TDSetElements that are on non-workers; Double_tfMaxEntriesRatiomax file entries to avg allowed ratio for cache-to-packet sync; Int_tfMaxPerfIdxmaximum of our slaves' performance index; Long_tfMaxSlaveCntmaximum number of workers per filenode (Long_t to avoid; Long64_tfNEventsOnRemLocnumber of events in currently; Int_tfPacketAsAFractionused to calculate the packet size; TList*fPartitionslist of partitions on nodes; Int_tfStrategy0 means the classic and 1 (default) - the adaptive strategy; Int_tfTryReassignControls attempts to reassign packets (0 == no reassignment); TList*fUnAllocatednodes with unallocated files. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPacketizerAdaptive(TDSet* dset, TList* slaves, Long64_t first, Long64_t num, TList* input, TProofProgressStatus* st); Constructor. ~TPacketizerAdaptive(); Destructor. void InitStats(); (re)initialise the statistics; called at the begining or after a worker dies. void RemoveUnAllocNode(TPacketizerAdaptive::TFileNode* ); Remove unallocated node. void RemoveActive(TPacketizerAdaptive::TFileStat* ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TPacketizerAdaptive.html:12359,adapt,adaptive,12359,root/html602/TPacketizerAdaptive.html,https://root.cern,https://root.cern/root/html602/TPacketizerAdaptive.html,2,['adapt'],['adaptive']
Energy Efficiency,"bfolder/obj/root.json.gz; If the access to the server is restricted with htdigest, it is recommended to use the curl program since only curl correctly implements such authentication method. The command will look like:; [shell] curl --user ""accout:password"" http://localhost:8080/Objects/subfolder/obj/root.json --digest -o root.json; 1.7.1 Objects data access in JSON format; Request root.json implemented with TBufferJSON class. TBufferJSON generates such object representation, which could be directly used in JSROOT for drawing. root.json request returns either complete object or just object member like:; [shell] wget http://localhost:8080/Objects/subfolder/obj/fTitle/root.json; The result will be: “title”.; For the root.json request one could specify the ‘compact’ parameter, which allow to reduce the number of spaces and new lines without data lost. This parameter can have values from ‘0’ (no compression) till ‘3’ (no spaces and new lines at all).; Usage of root.json request is about as efficient as binary root.bin request. Comparison of different request methods with TH1 object shown in the table:. Request; Size. root.bin; 1658 bytes. root.bin.gz; 782 bytes. root.json; 7555 bytes. root.json?compact=3; 5381 bytes. root.json.gz?compact=3; 1207 bytes. One should remember that JSON representation always includes names of the data fields which are not present in the binary representation. Even then the size difference is negligible.; root.json used in JSROOT to request objects from THttpServer.; 1.7.2 Generating images out of objects; For the ROOT classes which are implementing Draw method (like TH1 or TGraph) one could produce images with requests: root.png, root.gif, root.jpeg. For example:; wget ""http://localhost:8080/Files/hsimple.root/hpx/root.png?w=500&h=500&opt=lego1"" -O lego1.png; For all such requests one could specify following parameters:. h - image height; w - image width; opt - draw options. 1.7.3 Methods execution; By default THttpServer starts in monitoring",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/HttpServer/HttpServer.html:11693,efficient,efficient,11693,root/html534/guides/HttpServer/HttpServer.html,https://root.cern,https://root.cern/root/html534/guides/HttpServer/HttpServer.html,1,['efficient'],['efficient']
Energy Efficiency,"bin, Double_t w) overrideTHnSparseinlineprotectedvirtual; FillBinBase(Double_t w)THnBaseinlineprotected; FillBuffer(char *&buffer)TNamedvirtual; FillExMap()THnSparseprotected; FindObject(const char *name) constTObjectvirtual; FindObject(const TObject *obj) constTObjectvirtual; fIntegralTHnBaseprotected; fIntegralStatusTHnBaseprotected; Fit(TF1 *f1, Option_t *option="""", Option_t *goption="""")THnBase; fNameTNamedprotected; fNdimensionsTHnBaseprotected; fTitleTNamedprotected; fTsumwTHnBaseprotected; fTsumw2THnBaseprotected; fTsumwxTHnBaseprotected; fTsumwx2THnBaseprotected; fUniqueIDTObjectprivate; GenerateArray() const =0THnSparseprotectedpure virtual; GetAxis(Int_t dim) constTHnBaseinline; GetBin(const Int_t *idx) const overrideTHnSparseinlinevirtual; GetBin(const Double_t *x) const overrideTHnSparseinlinevirtual; GetBin(const char *name[]) const overrideTHnSparseinlinevirtual; GetBin(const Int_t *idx, Bool_t allocate=kTRUE) overrideTHnSparsevirtual; GetBin(const Double_t *x, Bool_t allocate=kTRUE) overrideTHnSparsevirtual; GetBin(const char *name[], Bool_t allocate=kTRUE) overrideTHnSparsevirtual; GetBinCenter(const std::vector< Int_t > &idx) constTHnBase; GetBinContent(const Int_t *idx) constTHnSparseinline; GetBinContent(Long64_t bin, Int_t *idx=nullptr) const overrideTHnSparsevirtual; GetBinError(const Int_t *idx) constTHnBaseinline; GetBinError(Long64_t linidx) constTHnBaseinline; GetBinError2(Long64_t linidx) const overrideTHnSparsevirtual; GetBinIndexForCurrentBin(Bool_t allocate)THnSparseprotected; GetCalculateErrors() constTHnBaseinline; GetChunk(Int_t idx) constTHnSparseinlineprotected; GetChunkSize() constTHnSparseinline; GetCompactCoord() constTHnSparseprotected; GetDrawOption() constTObjectvirtual; GetDtorOnly()TObjectstatic; GetEntries() constTHnBaseinline; GetIconName() constTObjectvirtual; GetListOfAxes()THnBaseinline; GetListOfAxes() constTHnBaseinline; GetListOfFunctions()THnBaseinline; GetName() const overrideTNamedinlinevirtual; GetNbins() const ove",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHnSparse-members.html:4587,allocate,allocate,4587,doc/master/classTHnSparse-members.html,https://root.cern,https://root.cern/doc/master/classTHnSparse-members.html,1,['allocate'],['allocate']
Energy Efficiency,"bit since then but the ideas/code for lazy matrix and; ""nested function"" are 100% his .; You can see him and his code in action at http://okmij.org/ftp; 2. Chris R. Birchenhall,; We adapted his idea of the implementation for the decomposition; classes instead of our messy installation of matrix inversion; His installation of matrix condition number, using an iterative; scheme using the Hage algorithm is worth looking at !; Chris has a nice writeup (matdoc.ps) on his matrix classes at; ftp://ftp.mcc.ac.uk/pub/matclass/; 3. Mark Fischler and Steven Haywood of CLHEP; They did the slave labor of spelling out all sub-determinants; for Cramer inversion of (4x4),(5x5) and (6x6) matrices; The stack storage for small matrices was also taken from them; 4. Roldan Pozo of TNT (http://math.nist.gov/tnt/); He converted the EISPACK routines for the eigen-vector analysis to; C++ . We started with his implementation; 5. Siegmund Brandt (http://siux00.physik.uni-siegen.de/~brandt/datan; We adapted his (very-well) documented SVD routines. How to efficiently use this package. 1. Never return complex objects (matrices or vectors); Danger: For example, when the following snippet:; TMatrixD foo(int n); {; TMatrixD foom(n,n); fill_in(foom); return foom;; }; TMatrixD m = foo(5);; runs, it constructs matrix foo:foom, copies it onto stack as a; return value and destroys foo:foom. Return value (a matrix); from foo() is then copied over to m (via a copy constructor),; and the return value is destroyed. So, the matrix constructor is; called 3 times and the destructor 2 times. For big matrices,; the cost of multiple constructing/copying/destroying of objects; may be very large. *Some* optimized compilers can cut down on 1; copying/destroying, but still it leaves at least two calls to; the constructor. Note, TMatrixDLazy (see below) can construct; TMatrixD m ""inplace"", with only a _single_ call to the; constructor. 2. Use ""two-address instructions""; ""void TMatrixD::operator += (const TMatrixD &B);""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMatrixTBase_double_.html:3259,adapt,adapted,3259,root/html528/TMatrixTBase_double_.html,https://root.cern,https://root.cern/root/html528/TMatrixTBase_double_.html,12,['adapt'],['adapted']
Energy Efficiency,"bject we have a referenced to is deleted, remove the reference. ; Reimplemented from TObject.; Definition at line 2458 of file RooAbsData.cxx. ◆ reduce() [1/5]. RooFit::OwningPtr< RooAbsData > RooAbsData::reduce ; (; const char * ; cut); const. Create a subset of the data set by applying the given cut on the data points. ; The cut expression can refer to any variable in the data set. For cuts involving other variables, such as intermediate formula objects, use the equivalent reduce method specifying the as a RooFormulVar reference. ; Definition at line 472 of file RooAbsData.cxx. ◆ reduce() [2/5]. RooFit::OwningPtr< RooAbsData > RooAbsData::reduce ; (; const RooArgSet & ; varSubset, . const char * ; cut = nullptr . ); const. Create a subset of the data set by applying the given cut on the data points and reducing the dimensions to the specified set. ; The cut expression can refer to any variable in the data set. For cuts involving other variables, such as intermediate formula objects, use the equivalent reduce method specifying the as a RooFormulVar reference. ; Definition at line 500 of file RooAbsData.cxx. ◆ reduce() [3/5]. RooFit::OwningPtr< RooAbsData > RooAbsData::reduce ; (; const RooArgSet & ; varSubset, . const RooFormulaVar & ; cutVar . ); const. Create a subset of the data set by applying the given cut on the data points and reducing the dimensions to the specified set. ; The 'cutVar' formula variable is used to select the subset of data points to be retained in the reduced data collection. ; Definition at line 530 of file RooAbsData.cxx. ◆ reduce() [4/5]. RooFit::OwningPtr< RooAbsData > RooAbsData::reduce ; (; const RooCmdArg & ; arg1, . const RooCmdArg & ; arg2 = {}, . const RooCmdArg & ; arg3 = {}, . const RooCmdArg & ; arg4 = {}, . const RooCmdArg & ; arg5 = {}, . const RooCmdArg & ; arg6 = {}, . const RooCmdArg & ; arg7 = {}, . const RooCmdArg & ; arg8 = {} . ); const. Create a reduced copy of this dataset. ; The caller takes ownership of the returned ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsData.html:62797,reduce,reduce,62797,doc/master/classRooAbsData.html,https://root.cern,https://root.cern/doc/master/classRooAbsData.html,1,['reduce'],['reduce']
Energy Efficiency,"bject); TClassStreamer IO overload. TVirtualCollectionProxy::CreateIterators_t GetFunctionCreateIterators(Bool_t read = kTRUE); See typedef void (*CreateIterators_t)(void *collection, void *&begin_arena, void *&end_arena);; begin_arena and end_arena should contain the location of memory arena of size fgIteratorSize.; If the collection iterator are of that size or less, the iterators will be constructed in place in those location (new with placement); Otherwise the iterators will be allocated via a regular new and their address returned by modifying the value of begin_arena and end_arena. TVirtualCollectionProxy::CopyIterator_t GetFunctionCopyIterator(Bool_t read = kTRUE); See typedef void (*CopyIterator_t)(void *&dest, const void *source);; Copy the iterator source, into dest. dest should contain should contain the location of memory arena of size fgIteratorSize.; If the collection iterator are of that size or less, the iterator will be constructed in place in this location (new with placement); Otherwise the iterator will be allocated via a regular new and its address returned by modifying the value of dest. TVirtualCollectionProxy::Next_t GetFunctionNext(Bool_t read = kTRUE); See typedef void* (*Next_t)(void *iter, void *end);; iter and end should be pointer to respectively an iterator to be incremented and the result of colleciton.end(); 'Next' will increment the iterator 'iter' and return 0 if the iterator reached the end.; If the end is not reached, 'Next' will return the address of the content unless the collection contains pointers in; which case 'Next' will return the value of the pointer. TVirtualCollectionProxy::DeleteIterator_t GetFunctionDeleteIterator(Bool_t read = kTRUE); See typedef void (*DeleteIterator_t)(void *iter);; If the sizeof iterator is greater than fgIteratorArenaSize, call delete on the addresses,; Otherwise just call the iterator's destructor. TVirtualCollectionProxy::DeleteTwoIterators_t GetFunctionDeleteTwoIterators(Bool_t read = kTRUE);",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGenCollectionProxy.html:10495,allocate,allocated,10495,root/html602/TGenCollectionProxy.html,https://root.cern,https://root.cern/root/html602/TGenCollectionProxy.html,2,['allocate'],['allocated']
Energy Efficiency,"bject*));; 407 fSize = newSize;; 408}; 409 ; 410////////////////////////////////////////////////////////////////////////////////; 411/// Find an object in this collection using its name. Requires a sequential; 412/// scan till the object has been found. Returns 0 if object with specified; 413/// name is not found.; 414 ; 415TObject *TObjArray::FindObject(const char *name) const; 416{; 417 R__COLLECTION_READ_LOCKGUARD(ROOT::gCoreMutex);; 418 ; 419 Int_t nobjects = GetAbsLast()+1;; 420 for (Int_t i = 0; i < nobjects; ++i) {; 421 TObject *obj = fCont[i];; 422 if (obj && 0 == strcmp(name, obj->GetName())) return obj;; 423 }; 424 return nullptr;; 425}; 426 ; 427////////////////////////////////////////////////////////////////////////////////; 428/// Find an object in this collection using the object's IsEqual(); 429/// member function. Requires a sequential scan till the object has; 430/// been found. Returns 0 if object is not found.; 431/// Typically this function is overridden by a more efficient version; 432/// in concrete collection classes (e.g. THashTable).; 433 ; 434TObject *TObjArray::FindObject(const TObject *iobj) const; 435{; 436 R__COLLECTION_READ_LOCKGUARD(ROOT::gCoreMutex);; 437 ; 438 Int_t nobjects = GetAbsLast()+1;; 439 for (Int_t i = 0; i < nobjects; ++i) {; 440 TObject *obj = fCont[i];; 441 if (obj && obj->IsEqual(iobj)) return obj;; 442 }; 443 return nullptr;; 444}; 445 ; 446////////////////////////////////////////////////////////////////////////////////; 447/// Stream all objects in the array to or from the I/O buffer.; 448 ; 449void TObjArray::Streamer(TBuffer &b); 450{; 451 UInt_t R__s, R__c;; 452 Int_t nobjects;; 453 if (b.IsReading()) {; 454 Version_t v = b.ReadVersion(&R__s, &R__c);; 455 if (v > 2); 456 TObject::Streamer(b);; 457 if (v > 1); 458 fName.Streamer(b);; 459 ; 460 if (GetEntriesFast() > 0) Clear();; 461 ; 462 b >> nobjects;; 463 b >> fLowerBound;; 464 if (nobjects >= fSize) Expand(nobjects);; 465 fLast = -1;; 466 TObject *obj;; 467 for ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TObjArray_8cxx_source.html:14451,efficient,efficient,14451,doc/master/TObjArray_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TObjArray_8cxx_source.html,1,['efficient'],['efficient']
Energy Efficiency,"bject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. intfFileNumFile descriptor; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; intfMaskEvent interest mask, either bit 1 (read), 2 (write) or both can be set; intfReadyMaskReadiness mask, either bit 1 (read), 2 (write) or both can be set; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileHandler(int fd, int mask); Create a file descriptor event handler. If mask=kRead then we; want to monitor the file for read readiness, if mask=kWrite; then we monitor the file for write readiness, if mask=kRead|kWrite; then we monitor both read and write readiness. Bool_t Notify(); Notify when event occured on descriptor associated with this handler. Bool_t ReadNotify(); Notify when something can be read from the descriptor associated with; this handler. Bool_t WriteNotify(); Notify when something can be written to the descriptor associated with; this handler. Bool_t HasReadInterest(); True if handler is interested in read events. Bool_t HasWriteInterest(); True if handler is interested in write events. void SetInterest(Int_t mask); Set interest mask to 'mask'. void Add(); Add file event handler to system file handler list. void Remove(); Remove file event handler from system file handler list. TFileHandler(); { }. virtual ~TFileHandler(); { Remove(); }. int GetFd() const; { return fFileNum; }. void SetFd(int fd); { fFileNum = fd; }. void ResetReadyMask(); { fReadyMask = 0; }. void SetReadReady(); { fReadyMask |= 0x1; }. void SetWriteReady(); { fRe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFileHandler.html:9750,monitor,monitor,9750,root/html528/TFileHandler.html,https://root.cern,https://root.cern/root/html528/TFileHandler.html,12,['monitor'],['monitor']
Energy Efficiency,"bject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. Int_tfBestBest Edge for division; TReffDaught0Pointer to daughter 1; TReffDaught1Pointer to daughter 2; Short_tfDimDimension of the vector space; Double_tfDriveDriver integral, only for cell build-up; TObject*fElementmay set by the user to save some data in this cell; Double_tfIntegralIntegral over cell (estimate from exploration); TReffParentPointer to parent cell; Int_tfSerialSerial number; Int_tfStatusStatus (active, inactive); Double_tfVolumeCartesian Volume of cell; Double_tfXdivFactor for division. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; PDEFoamCell(); Default constructor for streamer. PDEFoamCell(Int_t ); User constructor allocating single empty Cell. PDEFoamCell(const TMVA::PDEFoamCell& ); Copy constructor. ~PDEFoamCell(); Destructor. void Fill(Int_t , TMVA::PDEFoamCell* , TMVA::PDEFoamCell* , TMVA::PDEFoamCell* ); Fills in certain data into newly allocated cell. void GetHcub(TMVA::PDEFoamVect& , TMVA::PDEFoamVect& ) const; Provides size and position of the cell; These parameter are calculated by analyzing information in all parents; cells up to the root cell. It takes time but saves memory. void GetHSize(TMVA::PDEFoamVect& ) const; Provides size of the cell; Size parameters are calculated by analyzing information in all parents; cells up to the root cell. It takes time but saves memory. void CalcVolume(void); Calculates volume of the cell using size params which are calculated. UInt_t GetDepth(); Get depth of cell in binary tree, where the root cell has depth; 1. UInt_t GetTreeDepth(UInt_t depth = 0); Get depth of cell tree, starting at this cell. void Print(Option_t* option) const; Printout of the cell geometry parameters for the debug purpose. Double_t GetXdiv() const; Geometry. { return fXdiv;}. Int_t GetBest() const; { return fBest;}. void SetBest(Int_t Best); { fBest =Best;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__PDEFoamCell.html:6937,allocate,allocated,6937,root/html530/TMVA__PDEFoamCell.html,https://root.cern,https://root.cern/root/html530/TMVA__PDEFoamCell.html,3,['allocate'],['allocated']
Energy Efficiency,"bject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. Int_tfBestBest Edge for division; TReffDaught0Pointer to daughter 1; TReffDaught1Pointer to daughter 2; Short_tfDimDimension of the vector space; Double_tfDriveDriver integral, only for cell build-up; TObject*fElementmay set by the user to save some data in this cell; Double_tfIntegralIntegral over cell (estimate from exploration); TReffParentPointer to parent cell; Int_tfSerialSerial number; Int_tfStatusStatus (active, inactive); Double_tfVolumeCartesian Volume of cell; Double_tfXdivFactor for division. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; PDEFoamCell(); Default constructor for streamer. PDEFoamCell(Int_t ); User constructor allocating single empty Cell. PDEFoamCell(const TMVA::PDEFoamCell& ); Copy constructor. ~PDEFoamCell(); Destructor. void Fill(Int_t , TMVA::PDEFoamCell* , TMVA::PDEFoamCell* , TMVA::PDEFoamCell* ); Fills in certain data into newly allocated cell. void GetHcub(TMVA::PDEFoamVect& , TMVA::PDEFoamVect& ) const; Provides size and position of the cell; These parameter are calculated by analyzing information in all parents; cells up to the root cell. It takes time but saves memory. void GetHSize(TMVA::PDEFoamVect& ) const; Provides size of the cell; Size parameters are calculated by analyzing information in all parents; cells up to the root cell. It takes time but saves memory. void CalcVolume(void); Calculates volume of the cell using size params which are calculated. UInt_t GetDepth(); Get depth of cell in binary tree, where the root cell has depth; 1. void Print(Option_t* option) const; Printout of the cell geometry parameters for the debug purpose. Double_t GetXdiv() const; Geometry. { return fXdiv;}. Int_t GetBest() const; { return fBest;}. void SetBest(Int_t Best); { fBest =Best;}. void SetXdiv(Double_t Xdiv); { fXdiv =Xdiv;}. Double_t GetVolume() const; { return ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__PDEFoamCell.html:6830,allocate,allocated,6830,root/html528/TMVA__PDEFoamCell.html,https://root.cern,https://root.cern/root/html528/TMVA__PDEFoamCell.html,1,['allocate'],['allocated']
Energy Efficiency,"bjectAlloc(size_t size, void* vp); static voidObjectDealloc(void* vp); static voidObjectDealloc(void* vp, void* ptr); TStorage&operator=(const TStorage&); static voidPrintStatistics(); static void*ReAlloc(void* vp, size_t size); static void*ReAlloc(void* vp, size_t size, size_t oldsize); static char*ReAllocChar(char* vp, size_t size, size_t oldsize); static Int_t*ReAllocInt(Int_t* vp, size_t size, size_t oldsize); static voidRemoveStat(void* p); static voidSetCustomNewDelete(); static voidSetFreeHook(FreeHookFun_t func, void* data); static voidSetMaxBlockSize(size_t size); static voidSetReAllocHooks(ReAllocFun_t func1, ReAllocCFun_t func2); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; private:. static FreeHookFun_tfgFreeHookfunction called on free; static void*fgFreeHookDatadata used by this function; static Bool_tfgHasCustomNewDeletetrue if using ROOT's new/delete; static size_tfgMaxBlockSizelargest block allocated; static ReAllocCFun_tfgReAllocCHookcustom ReAlloc with length check; static ReAllocFun_tfgReAllocHookcustom ReAlloc; static const UInt_tkObjectAllocMemValue. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void EnterStat(size_t size, void* p); Register a memory allocation operation. If desired one can trap an; allocation of a certain size in case one tries to find a memory; leak of that particular size. This function is only called via; the ROOT custom new operators. void RemoveStat(void* p); Register a memory free operation. This function is only called via; the custom ROOT delete operator. void * Alloc(size_t size); Allocate a block of memory, that later can be resized using; TStorage::ReAlloc(). void Dealloc(void* ptr); De-allocate block of memory, that was allocated via TStorage::Alloc(). void * ReAlloc(void* vp, size_t size); Reallocate (i.e. resize) block of memory. Don't use if size is larger; than old",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TStorage.html:2868,allocate,allocated,2868,root/html534/TStorage.html,https://root.cern,https://root.cern/root/html534/TStorage.html,1,['allocate'],['allocated']
Energy Efficiency,"bjects must be of the same class. For the rest this class has the same properties as a TObjArray. The internal data structure of a TClonesArray. The figure above shows the internal data structure of a TClonesArray. The class is specially designed for repetitive data analysis tasks, where in a loop many times the same objects, are created and deleted. The only supported way to add objects to a TClonesArray is via the new with placement method. The different Add() methods of TObjArray and its base classes are not supported.; 16.8.1 The Idea Behind TClonesArray; To reduce the very large number of new and delete calls in large loops like this (O(100000) x O(10000) times new/delete):; TObjArray a(10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000); for (int i = 0; i < ev->Ntracks; i++) { // O(10000); a[i] = new TTrack(x,y,z,...);; ...; }; ...; a.Delete();; }; You better use a TClonesArray which reduces the number of new/delete calls to only O(10000):; TClonesArray a(""TTrack"", 10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000); for (int i = 0; i < ev->Ntracks; i++) { // O(10000); TTrack *track = (Track*)a.ConstructedAt(i);; track->Set(x,y,z,...);; ...; }; ...; a.Clear(); // Or Clear(""C"") if the track objects must be returned (via Track::Clear) to a default state.; }; Considering that a pair of new/delete calls on average cost about 70 ms, O(109) new/deletes will save about 19 hours. For the other collections, see the class reference guide on the web and the test program $ROOTSYS/test/tcollex.cxx.; 16.9 Template Containers and STL; Some people dislike polymorphic containers because they are not truly “type safe”. In the end, the compiler leaves it the user to ensure that the types are correct. This only leaves the other alternative: creating a new class each time a new (container organization) / (contained object) combination is needed. To say the least this could be very tedious. Most people faced with this choice would, for each type of container:; De",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:854906,reduce,reduces,854906,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['reduce'],['reduces']
Energy Efficiency,"ble absTol, double relTol, unsigned int size, int rule). private:. ROOT::Math::IntegratorOneDimIntegratorOneDim(const ROOT::Math::IntegratorOneDim&); ROOT::Math::IntegratorOneDim&operator=(const ROOT::Math::IntegratorOneDim&). Data Members; private:. ROOT::Math::IGenFunction*fFuncpointer to owned function; ROOT::Math::VirtualIntegratorOneDim*fIntegratorpointer to integrator interface class. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void SetFunction( Function & f). double Integral(const ROOT::Math::IGenFunction& f, double a, double b). double Integral(double a, double b). double IntegralCauchy(const ROOT::Math::IGenFunction& f, double a, double b, double c). IntegratorOneDim(ROOT::Math::IntegrationOneDim::Type type = IntegrationOneDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int size = 0, unsigned int rule = 0); constructors. Constructor of one dimensional Integrator, default type is adaptive. @param type integration type (adaptive, non-adaptive, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals; @param rule Gauss-Kronrod integration rule (only for GSL kADAPTIVE type). Possible type values are : kGAUSS (simple Gauss method), kADAPTIVE (from GSL), kADAPTIVESINGULAR (from GSL), kNONADAPTIVE (from GSL); Possible rule values are kGAUS15 (rule = 1), kGAUS21( rule = 2), kGAUS31(rule =3), kGAUS41 (rule=4), kGAUS51 (rule =5), kGAUS61(rule =6); lower rules are indicated for singular functions while higher for smooth functions to get better accuracies. NOTE: When the default values are passed, the values used are taken from the default defined in ROOT::Math::IntegratorOneDimOptions. IntegratorOneDim(const ROOT::Math::IGenFunction& f, ROOT::Math::IntegrationOneDim::Type type = IntegrationOneDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int size = 0, int rule = 0). Constructor of one dimensional Integrator passing a functi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/ROOT__Math__IntegratorOneDim.html:4676,adapt,adaptive,4676,root/html604/ROOT__Math__IntegratorOneDim.html,https://root.cern,https://root.cern/root/html604/ROOT__Math__IntegratorOneDim.html,2,['adapt'],['adaptive']
Energy Efficiency,"ble to fit an; polynomial in to points with ; , but; the polynomial is not likely to fit new data at all; [1]. Therefore, the user is asked to provide an upper; limit, to the number of terms in ; (TMultiDimFit::SetMaxTerms).; ; However, since there's an infinite number of to choose from, the; user is asked to give the maximum power. , of each variable; to be considered in the minimization of ; (TMultiDimFit::SetMaxPowers).; ; One way of obtaining values for the maximum power in variable , is; to perform a regular fit to the dependent quantity , using a; polynomial only in . The maximum power is is then the; power that does not significantly improve the one-dimensional; least-square fit over to [5].; ; There are still a huge amount of possible choices for ; in fact; there are ; possible; choices. Obviously we need to limit this. To this end, the user is; asked to set a power control limit, ; (TMultiDimFit::SetPowerLimit), and a function; is only accepted if; . where is the leading power of variable in function; . (TMultiDimFit::MakeCandidates). So the number of; functions increase with (1, 2 is fine, 5 is way out).; . Gram-Schmidt Orthogonalisation. To further reduce the number of functions in the final expression,; only those functions that significantly reduce is chosen. What; `significant' means, is chosen by the user, and will be; discussed below (see 2.3).; ; The functions are generally not orthogonal, which means one will; have to evaluate all possible 's over all data-points before; finding the most significant [1]. We can, however, do; better then that. By applying the modified Gram-Schmidt; orthogonalisation algorithm [5] [3] to the; functions , we can evaluate the contribution to the reduction of; from each function in turn, and we may delay the actual inversion; of the curvature-matrix; (TMultiDimFit::MakeGramSchmidt).; ; So we are let to consider an matrix ; , an; element of which is given by; .    with. (3). where labels the rows in the training sample a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMultiDimFit.html:4571,power,power,4571,root/html534/TMultiDimFit.html,https://root.cern,https://root.cern/root/html534/TMultiDimFit.html,3,['power'],['power']
Energy Efficiency,"ble, double, double)virtual function to be used for monitoring (callback)Definition NeuralNet.h:781; TMVA::DNN::Settings::plotvoid plot(std::string histoName, std::string options, int pad, EColor color)for monitoringDefinition NeuralNet.h:823; TMVA::DNN::Settings::startTrainCyclevirtual void startTrainCycle()Definition NeuralNet.h:782; TMVA::DNN::Settings::convergenceStepssize_t convergenceSteps() consthow many steps until training is deemed to have convergedDefinition NeuralNet.h:766; TMVA::DNN::Settings::m_factorWeightDecaydouble m_factorWeightDecayDefinition NeuralNet.h:840; TMVA::DNN::Settings::factorWeightDecaydouble factorWeightDecay() constget the weight-decay factorDefinition NeuralNet.h:769; TMVA::DNN::Settings::count_mb_dEsize_t count_mb_dEDefinition NeuralNet.h:845; TMVA::DNN::Settings::m_useMultithreadingbool m_useMultithreadingDefinition NeuralNet.h:863; TMVA::DNN::Settings::count_mb_Esize_t count_mb_EDefinition NeuralNet.h:844; TMVA::DNN::Settings::existsbool exists(std::string histoName)for monitoringDefinition NeuralNet.h:825; TMVA::DNN::Settings::maxConvergenceCountsize_t maxConvergenceCount() constreturns the max convergence count so farDefinition NeuralNet.h:828; TMVA::DNN::Settings::padsvoid pads(int numPads)preparation for monitoringDefinition NeuralNet.h:818; TMVA::DNN::Settings::m_testRepetitionssize_t m_testRepetitionsDefinition NeuralNet.h:839; TMVA::DNN::Settings::fLearningRatedouble fLearningRateDefinition NeuralNet.h:852; TMVA::DNN::Settings::fMomentumdouble fMomentumDefinition NeuralNet.h:853; TMVA::DNN::Settings::batchSizesize_t batchSize() constmini-batch sizeDefinition NeuralNet.h:767; TMVA::DNN::Settings::computeResultvirtual void computeResult(const Net &, std::vector< double > &)callback for monitoring and loggingDefinition NeuralNet.h:809; TMVA::DNN::Settings::fMonitoringstd::shared_ptr< Monitoring > fMonitoringDefinition NeuralNet.h:865; TMVA::DNN::Settings::dropRepetitionssize_t dropRepetitions() constDefinition NeuralNet.h:761; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/NeuralNet_8h_source.html:76580,monitor,monitoringDefinition,76580,doc/master/NeuralNet_8h_source.html,https://root.cern,https://root.cern/doc/master/NeuralNet_8h_source.html,1,['monitor'],['monitoringDefinition']
Energy Efficiency,"ble_t d, Double_t e, Double_t f); set point coefficient number i. void BuildCoeff(); algorithm 600, collected algorithms from acm.; algorithm appeared in acm-trans. math. software, vol.9, no. 2,; jun., 1983, p. 258-259. TSpline5 computes the coefficients of a quintic natural quintic spli; s(x) with knots x(i) interpolating there to given function values:; s(x(i)) = y(i) for i = 1,2, ..., n.; in each interval (x(i),x(i+1)) the spline function s(xx) is a; polynomial of fifth degree:; s(xx) = ((((f(i)*p+e(i))*p+d(i))*p+c(i))*p+b(i))*p+y(i) (*); = ((((-f(i)*q+e(i+1))*q-d(i+1))*q+c(i+1))*q-b(i+1))*q+y(i+1); where p = xx - x(i) and q = x(i+1) - xx.; (note the first subscript in the second expression.); the different polynomials are pieced together so that s(x) and; its derivatives up to s"""" are continuous. input:. n number of data points, (at least three, i.e. n > 2); x(1:n) the strictly increasing or decreasing sequence of; knots. the spacing must be such that the fifth power; of x(i+1) - x(i) can be formed without overflow or; underflow of exponents.; y(1:n) the prescribed function values at the knots. output:. b,c,d,e,f the computed spline coefficients as in (*).; (1:n) specifically; b(i) = s'(x(i)), c(i) = s""(x(i))/2, d(i) = s""'(x(i))/6,; e(i) = s""""(x(i))/24, f(i) = s""""'(x(i))/120.; f(n) is neither used nor altered. the five arrays; b,c,d,e,f must always be distinct. option:. it is possible to specify values for the first and second; derivatives of the spline function at arbitrarily many knots.; this is done by relaxing the requirement that the sequence of; knots be strictly increasing or decreasing. specifically:. if x(j) = x(j+1) then s(x(j)) = y(j) and s'(x(j)) = y(j+1),; if x(j) = x(j+1) = x(j+2) then in addition s""(x(j)) = y(j+2). note that s""""(x) is discontinuous at a double knot and, in; addition, s""'(x) is discontinuous at a triple knot. the; subroutine assigns y(i) to y(i+1) in these cases and also to; y(i+2) at a triple knot. the representation (*) remains; v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSpline5.html:13580,power,power,13580,root/html528/TSpline5.html,https://root.cern,https://root.cern/root/html528/TSpline5.html,6,['power'],['power']
Energy Efficiency,"ble_t themin=0, Double_t themax=180, Double_t phimin=0, Double_t phimax=360)Make in one step a volume pointing to a sphere shape with given medium.Definition TGeoManager.cxx:3186; TGeoManager::SetTopVolumevoid SetTopVolume(TGeoVolume *vol)Set the top volume and corresponding node as starting point of the geometry.Definition TGeoManager.cxx:3655; TGeoManager::SetNsegmentsvoid SetNsegments(Int_t nseg)Set number of segments for approximating circles in drawing.Definition TGeoManager.cxx:3594; TGeoMaterialBase class describing materials.Definition TGeoMaterial.h:34; TGeoMediumMedia are used to store properties related to tracking and which are useful only when using geometry ...Definition TGeoMedium.h:23; TGeoTranslationClass describing translations.Definition TGeoMatrix.h:116; TGeoVolumeTGeoVolume, TGeoVolumeMulti, TGeoVolumeAssembly are the volume classes.Definition TGeoVolume.h:43; TGeoVolume::AddNodevirtual TGeoNode * AddNode(TGeoVolume *vol, Int_t copy_no, TGeoMatrix *mat=nullptr, Option_t *option="""")Add a TGeoNode to the list of nodes.Definition TGeoVolume.cxx:975; TGeoVolume::Drawvoid Draw(Option_t *option="""") overridedraw top volume according to optionDefinition TGeoVolume.cxx:1206; TGeoVolume::SetLineColorvoid SetLineColor(Color_t lcolor) overrideSet the line color.Definition TGeoVolume.cxx:2169; TRandom::Rannorvirtual void Rannor(Float_t &a, Float_t &b)Return 2 numbers distributed following a gaussian with mean=0 and sigma=1.Definition TRandom.cxx:507; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; TMath::SqrtDouble_t Sqrt(Double_t x)Returns the square root of x.Definition TMath.h:662; TMath::PowerLongDouble_t Power(LongDouble_t x, LongDouble_t y)Returns x raised to the power y.Definition TMath.h:721; TMath::Piconstexpr Double_t Pi()Definition TMath.h:37; AuthorOtto Schaile ; Definition in file nucleus.C. tutorialsglnucleus.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:28 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/nucleus_8C.html:4994,power,power,4994,doc/master/nucleus_8C.html,https://root.cern,https://root.cern/doc/master/nucleus_8C.html,1,['power'],['power']
Energy Efficiency,"ble_t& c); Calculates roots of polynomial of 3rd order a*x^3 + b*x^2 + c*x + d, where; a == coef[3], b == coef[2], c == coef[1], d == coef[0]; coef[3] must be different from 0; If the boolean returned by the method is false:; ==> there are 3 real roots a,b,c; If the boolean returned by the method is true:; ==> there is one real root a and 2 complex conjugates roots (b+i*c,b-i*c); Author: Francois-Xavier Gentit. void Quantiles(Int_t n, Int_t nprob, Double_t* x, Double_t* quantiles, Double_t* prob, Bool_t isSorted = kTRUE, Int_t* index = 0, Int_t type = 7); Computes sample quantiles, corresponding to the given probabilities; Parameters:; x -the data sample; n - its size; quantiles - computed quantiles are returned in there; prob - probabilities where to compute quantiles; nprob - size of prob array; isSorted - is the input array x sorted?; NOTE, that when the input is not sorted, an array of integers of size n needs; to be allocated. It can be passed by the user in parameter index,; or, if not passed, it will be allocated inside the function. type - method to compute (from 1 to 9). Following types are provided:; Discontinuous:; type=1 - inverse of the empirical distribution function; type=2 - like type 1, but with averaging at discontinuities; type=3 - SAS definition: nearest even order statistic; Piecwise linear continuous:; In this case, sample quantiles can be obtained by linear interpolation; between the k-th order statistic and p(k).; type=4 - linear interpolation of empirical cdf, p(k)=k/n;; type=5 - a very popular definition, p(k) = (k-0.5)/n;; type=6 - used by Minitab and SPSS, p(k) = k/(n+1);; type=7 - used by S-Plus and R, p(k) = (k-1)/(n-1);; type=8 - resulting sample quantiles are approximately median unbiased; regardless of the distribution of x. p(k) = (k-1/3)/(n+1/3);; type=9 - resulting sample quantiles are approximately unbiased, when; the sample comes from Normal distribution. p(k)=(k-3/8)/(n+1/4);. default type = 7. References:; 1) Hyndman, R.J and F",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMath.html:22496,allocate,allocated,22496,root/html528/TMath.html,https://root.cern,https://root.cern/root/html528/TMath.html,6,['allocate'],['allocated']
Energy Efficiency,"ble_t*TQpSolverBase::fPhi_history[fMaxit] history of values of phi obtained on all iterations to date; Double_t*TQpSolverBase::fPhi_min_history[fMaxit] the i-th entry of this array contains the minimum value of phi; Int_tfPrintlevelparameter in range [0,100] determines verbosity. (Higher value; Double_t*TQpSolverBase::fRnorm_history[fMaxit] history of values of residual norm obtained on all iterations to date; TQpVar*fStep; Double_tfStepFactor0various parameters associated with Gondzio correction; Double_tfStepFactor1; TQpLinSolverBase*TQpSolverBase::fSys; Double_tfTsigexponent in Mehrotra's centering parameter, which is usually. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGondzioSolver(); Default constructor. TGondzioSolver(TQpProbBase* of, TQpDataBase* prob, Int_t verbose = 0); Constructor. TGondzioSolver(const TGondzioSolver& another); Copy constructor. Int_t Solve(TQpDataBase* prob, TQpVar* iterate, TQpResidual* resid); Solve the quadratic programming problem as formulated through prob, store; the final solution in iterate->fX . Monitor the residuals during the iterations; through resid . The status is returned as defined in TQpSolverBase::ETerminationCode . void DefMonitor(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Double_t alpha, Double_t sigma, Int_t i, Double_t mu, Int_t status_code, Int_t level); Print information about the optimization process and monitor the convergence; status of thye algorithm. ~TGondzioSolver(); Deconstructor. TGondzioSolver & operator=(const TGondzioSolver& source); Assignment operator. void Reset_parameters(); {}. » Author: Eddy Offermann May 2004 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/quadp:$Id: TGondzioSolver.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:10; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGondzioSolver.html:9154,monitor,monitor,9154,root/html528/TGondzioSolver.html,https://root.cern,https://root.cern/root/html528/TGondzioSolver.html,1,['monitor'],['monitor']
Energy Efficiency,"ble_t*TQpSolverBase::fPhi_history[fMaxit] history of values of phi obtained on all iterations to date; Double_t*TQpSolverBase::fPhi_min_history[fMaxit] the i-th entry of this array contains the minimum value of phi; Int_tfPrintlevelparameter in range [0,100] determines verbosity. (Higher value; Double_t*TQpSolverBase::fRnorm_history[fMaxit] history of values of residual norm obtained on all iterations to date; TQpVar*fStep; Double_tfStepFactor0various parameters associated with Gondzio correction; Double_tfStepFactor1; TQpLinSolverBase*TQpSolverBase::fSys; Double_tfTsigexponent in Mehrotra's centering parameter, which is usually. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGondzioSolver(); Default constructor. TGondzioSolver(TQpProbBase* of, TQpDataBase* prob, Int_t verbose = 0); Constructor. TGondzioSolver(const TGondzioSolver& another); Copy constructor. Int_t Solve(TQpDataBase* prob, TQpVar* iterate, TQpResidual* resid); Solve the quadratic programming problem as formulated through prob, store; the final solution in iterate->fX . Monitor the residuals during the iterations; through resid . The status is returned as defined in TQpSolverBase::ETerminationCode . void DefMonitor(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Double_t alpha, Double_t sigma, Int_t i, Double_t mu, Int_t status_code, Int_t level); Print information about the optimization process and monitor the convergence; status of thye algorithm. ~TGondzioSolver(); Deconstructor. TGondzioSolver & operator=(const TGondzioSolver& source); Assignment operator. void Reset_parameters(); {}. » Author: Eddy Offermann May 2004 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/quadp:$Id: TGondzioSolver.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-07-04 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGondzioSolver.html:9223,monitor,monitor,9223,root/html530/TGondzioSolver.html,https://root.cern,https://root.cern/root/html530/TGondzioSolver.html,1,['monitor'],['monitor']
Energy Efficiency,"ble_t*TQpSolverBase::fPhi_history[fMaxit] history of values of phi obtained on all iterations to date; Double_t*TQpSolverBase::fPhi_min_history[fMaxit] the i-th entry of this array contains the minimum value of phi; Int_tfPrintlevelparameter in range [0,100] determines verbosity. (Higher value; Double_t*TQpSolverBase::fRnorm_history[fMaxit] history of values of residual norm obtained on all iterations to date; TQpVar*fStep; Double_tfStepFactor0various parameters associated with Gondzio correction; Double_tfStepFactor1; TQpLinSolverBase*TQpSolverBase::fSys; Double_tfTsigexponent in Mehrotra's centering parameter, which is usually. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGondzioSolver(); Default constructor. TGondzioSolver(TQpProbBase* of, TQpDataBase* prob, Int_t verbose = 0); Constructor. TGondzioSolver(const TGondzioSolver& another); Copy constructor. Int_t Solve(TQpDataBase* prob, TQpVar* iterate, TQpResidual* resid); Solve the quadratic programming problem as formulated through prob, store; the final solution in iterate->fX . Monitor the residuals during the iterations; through resid . The status is returned as defined in TQpSolverBase::ETerminationCode . void DefMonitor(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Double_t alpha, Double_t sigma, Int_t i, Double_t mu, Int_t status_code, Int_t level); Print information about the optimization process and monitor the convergence; status of thye algorithm. ~TGondzioSolver(); Deconstructor. TGondzioSolver & operator=(const TGondzioSolver& source); Assignment operator. void Reset_parameters(); {}. » Author: Eddy Offermann May 2004 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/quadp:$Id: TGondzioSolver.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-11-03 20:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGondzioSolver.html:9223,monitor,monitor,9223,root/html532/TGondzioSolver.html,https://root.cern,https://root.cern/root/html532/TGondzioSolver.html,1,['monitor'],['monitor']
Energy Efficiency,"ble_t>& parameters, Double_t currentTemperature); voidGenerateNeighbour(vector<Double_t>& parameters, vector<Double_t>& oldParameters, Double_t currentTemperature); voidGenerateNewTemperature(Double_t& currentTemperature, Int_t Iter); TMVA::MsgLogger&Log() const; voidReWriteParameters(vector<Double_t>& from, vector<Double_t>& to); voidSetDefaultScale(); Bool_tShouldGoIn(Double_t currentFit, Double_t localFit, Double_t currentTemperature). Data Members; public:. enum EKernelTemperature { kSqrt; kIncreasingAdaptive; kDecreasingAdaptive; kLog; kHomo; kSin; kGeo; };. private:. Double_tfAdaptiveSpeedhow fast temperature change in adaptive (in adaptive two variables describe; Double_tfEpsepsilon; TMVA::IFitterTarget&fFitterTargetthe fitter target; Double_tfInitialTemperatureinitial temperature; TMVA::SimulatedAnnealing::EKernelTemperaturefKernelTemperature; TMVA::MsgLogger*fLoggermessage logger; Int_tfMaxCallsmaximum number of minimisation calls; Double_tfMinTemperaturemimimum temperature; Double_tfProgress; TRandom*fRandomrandom generator; const vector<TMVA::Interval*>&fRangesparameter ranges; Double_tfTemperatureAdaptiveStepused to calculate InitialTemperature if fUseDefaultTemperature; Double_tfTemperatureScalehow fast temperature change; Bool_tfUseDefaultScaleif TRUE, SA calculates its own TemperatureScale; Bool_tfUseDefaultTemperatureif TRUE, SA calculates its own InitialTemperature (MinTemperautre). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SimulatedAnnealing(TMVA::IFitterTarget& target, const vector<TMVA::Interval*>& ranges); constructor. void SetOptions(Int_t maxCalls, Double_t initialTemperature, Double_t minTemperature, Double_t eps, TString kernelTemperatureS, Double_t temperatureScale, Double_t adaptiveSpeed, Double_t temperatureAdaptiveStep, Bool_t useDefaultScale, Bool_t useDefaultTemperature); option setter. ~SimulatedAnnealing(); destructor. void FillWithRandomValues(vector<Double_t>& parameters); random star",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__SimulatedAnnealing.html:2096,adapt,adaptive,2096,root/html528/TMVA__SimulatedAnnealing.html,https://root.cern,https://root.cern/root/html528/TMVA__SimulatedAnnealing.html,8,['adapt'],['adaptive']
Energy Efficiency,"ble_tfInitialTemperatureinitial temperature; TMVA::SimulatedAnnealing::EKernelTemperaturefKernelTemperature; TMVA::MsgLogger*fLoggermessage logger; Int_tfMaxCallsmaximum number of minimisation calls; Double_tfMinTemperaturemimimum temperature; Double_tfProgress; TRandom*fRandomrandom generator; const vector<TMVA::Interval*>&fRangesparameter ranges; Double_tfTemperatureAdaptiveStepused to calculate InitialTemperature if fUseDefaultTemperature; Double_tfTemperatureScalehow fast temperature change; Bool_tfUseDefaultScaleif TRUE, SA calculates its own TemperatureScale; Bool_tfUseDefaultTemperatureif TRUE, SA calculates its own InitialTemperature (MinTemperautre). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SimulatedAnnealing(TMVA::IFitterTarget& target, const vector<TMVA::Interval*>& ranges); constructor. void SetOptions(Int_t maxCalls, Double_t initialTemperature, Double_t minTemperature, Double_t eps, TString kernelTemperatureS, Double_t temperatureScale, Double_t adaptiveSpeed, Double_t temperatureAdaptiveStep, Bool_t useDefaultScale, Bool_t useDefaultTemperature); option setter. ~SimulatedAnnealing(); destructor. void FillWithRandomValues(vector<Double_t>& parameters); random starting parameters. void ReWriteParameters(vector<Double_t>& from, vector<Double_t>& to); copy parameters. void GenerateNeighbour(vector<Double_t>& parameters, vector<Double_t>& oldParameters, Double_t currentTemperature); generate adjacent parameters. std::vector<Double_t> GenerateNeighbour(vector<Double_t>& parameters, Double_t currentTemperature); generate adjacent parameters. void GenerateNewTemperature(Double_t& currentTemperature, Int_t Iter); generate new temperature. Bool_t ShouldGoIn(Double_t currentFit, Double_t localFit, Double_t currentTemperature); result checker. void SetDefaultScale(); setting of default scale. Double_t GenerateMaxTemperature(vector<Double_t>& parameters); maximum temperature. Double_t Minimize(vector<Double_t>& para",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__SimulatedAnnealing.html:3242,adapt,adaptiveSpeed,3242,root/html528/TMVA__SimulatedAnnealing.html,https://root.cern,https://root.cern/root/html528/TMVA__SimulatedAnnealing.html,4,['adapt'],['adaptiveSpeed']
Energy Efficiency,"ble_tfXMaxData maximum value; Double_tfXMinData minimum value. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TKDE(); Class destructor. void Instantiate(TKDE::KernelFunction_Ptr kernfunc, UInt_t events, const Double_t* data, const Double_t* weight, Double_t xMin, Double_t xMax, const Option_t* option, Double_t rho); Template's constructor surrogate. void SetOptions(const Option_t* option, Double_t rho); Sets User defined construction options. void SetDrawOptions(const Option_t* option, TString& plotOpt, TString& drawOpt); Sets User defined drawing options. void GetOptions(string optionType, string option); Gets User defined KDE construction options. void AssureOptions(); Sets missing construction options to default ones. void CheckOptions(Bool_t isUserDefinedKernel = kFALSE); Sets User global options. void SetKernelType(TKDE::EKernelType kern); Sets User option for the choice of kernel estimator. void SetIteration(TKDE::EIteration iter); Sets User option for fixed or adaptive iteration. void SetMirror(TKDE::EMirror mir); Sets User option for mirroring the data. void SetBinning(TKDE::EBinning ); Sets User option for binning the weights. void SetNBins(UInt_t nbins); Sets User option for number of bins. void SetUseBinsNEvents(UInt_t nEvents); Sets User option for the minimum number of events for allowing automatic binning. void SetTuneFactor(Double_t rho); Factor which can be used to tune the smoothing.; It is used as multiplicative factor for the fixed and adaptive bandwidth.; A value < 1 will reproduce better the tails but oversmooth the peak; while a factor > 1 will overestimate the tail. void SetRange(Double_t xMin, Double_t xMax); Sets minimum range value and maximum range value. void SetUseBins(); Sets User option for using binned weights. void SetMirror(); Sets the mirroring. void SetData(const Double_t* data, const Double_t* weights); Sets the data events input sample or bin centres for binned option and computes bas",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TKDE.html:13141,adapt,adaptive,13141,root/html604/TKDE.html,https://root.cern,https://root.cern/root/html604/TKDE.html,1,['adapt'],['adaptive']
Energy Efficiency,"branch object with GetObject(). Example:. branch->SetAddress(0);; Event* event = branch->GetObject();; ... Do some work. If addr is not zero, but the pointer addr points at is; zero, then we allocate a branch object and set the passed; pointer to point at the allocated object. The caller; owns the allocated object and is responsible for deleting; it when it is no longer needed. Example:. Event* event = 0;; branch->SetAddress(&event);; ... Do some work.; delete event;; event = 0;. If addr is not zero and the pointer addr points at is; also not zero, then the caller has allocated a branch; object and is asking us to use it. The caller owns it; and must delete it when it is no longer needed. Example:. Event* event = new Event();; branch->SetAddress(&event);; ... Do some work.; delete event;; event = 0;. These rules affect users of TTree::Branch(),; TTree::SetBranchAddress(), and TChain::SetBranchAddress(); as well because those routines call this one. An example of a tree with branches with objects allocated; and owned by us:. TFile* f1 = new TFile(""myfile_original.root"");; TTree* t1 = (TTree*) f->Get(""MyTree"");; TFile* f2 = new TFile(""myfile_copy.root"", ""recreate"");; TTree* t2 = t1->Clone(0);; for (Int_t i = 0; i < 10; ++i) {; t1->GetEntry(i);; t2->Fill();; }; t2->Write(); delete f2;; f2 = 0;; delete f1;; f1 = 0;. An example of a branch with an object allocated by us,; but owned by the caller:. TFile* f = new TFile(""myfile.root"", ""recreate"");; TTree* t = new TTree(""t"", ""A test tree.""); Event* event = 0;; TBranchElement* br = t->Branch(""event."", &event);; for (Int_t i = 0; i < 10; ++i) {; ... Fill event with meaningful data in some way.; t->Fill();; }; t->Write();; delete event;; event = 0;; delete f;; f = 0;. Notice that the only difference between this example; and the following example is that the event pointer; is zero when the branch is created. An example of a branch with an object allocated and; owned by the caller:. TFile* f = new TFile(""myfile.root"", ""recreate""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TBranchElement.html:25063,allocate,allocated,25063,root/html526/TBranchElement.html,https://root.cern,https://root.cern/root/html526/TBranchElement.html,7,['allocate'],['allocated']
Energy Efficiency,"branchname' as if it was a data member; protection against array out-of-bounds errors; ability to use the branch data as an object (when the user code is available). For example with Event.root, if Double_t somePx = fTracks.fPx[2];; double; is executed by one of the method of the skeleton, somePx will updated with the current value of fPx of the 3rd track.; Both macrofilename and the optional cutfilename are expected to be the name of source files which contain at least a free standing function with the signature: x_t macrofilename(); // i.e function with the same name as the file; and y_t cutfilename(); // i.e function with the same name as the file; x_t and y_t needs to be types that can convert respectively to a double and a bool (because the skeleton uses: if (cutfilename()) htemp->Fill(macrofilename());; These two functions are run in a context such that the branch names are available as local variables of the correct (read-only) type.; Note that if you use the same 'variable' twice, it is more efficient to 'cache' the value. For example: Int_t n = fEventNumber; // Read fEventNumber; if (n<10 || n>10) { ... }; nconst Int_t nDefinition legend1.C:16; is more efficient than if (fEventNumber<10 || fEventNumber>10); Also, optionally, the generated selector will also call methods named macrofilename_methodname in each of 6 main selector methods if the method macrofilename_methodname exist (Where macrofilename is stripped of its extension).; Concretely, with the script named h1analysisProxy.C,. The method calls the method (if it exist); Begin -> void h1analysisProxy_Begin(TTree*);; SlaveBegin -> void h1analysisProxy_SlaveBegin(TTree*);; Notify -> bool h1analysisProxy_Notify();; Process -> bool h1analysisProxy_Process(Long64_t);; SlaveTerminate -> void h1analysisProxy_SlaveTerminate();; Terminate -> void h1analysisProxy_Terminate();. If a file name macrofilename.h (or .hh, .hpp, .hxx, .hPP, .hXX) exist it is included before the declaration of the proxy class. This can ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTree.html:177278,efficient,efficient,177278,doc/v632/classTTree.html,https://root.cern,https://root.cern/doc/v632/classTTree.html,2,['efficient'],['efficient']
Energy Efficiency,"bs. ; Parameters. [in]obsObservable to retrieve boundaries for. ; [in]xloBeginning of range. ; [in]xhiEnd of range. . ReturnsThe caller owns the returned std::list. ; Reimplemented in ParamHistFunc, PiecewiseInterpolation, RooLagrangianMorphFunc, RooMomentMorphFunc, RooParamHistFunc, RooAddition, RooAddPdf, RooFormulaVar, RooHistFunc, RooHistPdf, RooProdPdf, RooProduct, RooRealSumFunc, RooRealSumPdf, RooBinSamplingPdf, RooBinWidthFunction, RooLinearCombination, RooWrapperPdf, and PdfWrapper.; Definition at line 3560 of file RooAbsReal.cxx. ◆ bindVars(). RooFit::OwningPtr< RooAbsFunc > RooAbsReal::bindVars ; (; const RooArgSet & ; vars, . const RooArgSet * ; nset = nullptr, . bool ; clipInvalid = false . ); const. Create an interface adaptor f(vars) that binds us to the specified variables (in arbitrary order). ; For example, calling bindVars({x1,x3}) on an object F(x1,x2,x3,x4) returns an object f(x1,x3) that is evaluated using the current values of x2 and x4. The caller takes ownership of the returned adaptor. ; Definition at line 2980 of file RooAbsReal.cxx. ◆ buildCallToAnalyticIntegral(). std::string RooAbsReal::buildCallToAnalyticIntegral ; (; Int_t ; code, . const char * ; rangeName, . RooFit::Detail::CodeSquashContext & ; ctx . ); const. virtual . This function defines the analytical integral translation for the class. ; Parameters. [in]codeThe code that decides the integrands. ; [in]rangeNameName of the normalization range. ; [in]ctxAn object to manage auxiliary information for code-squashing. ReturnsThe representative code string of the integral for the given object. ; Reimplemented in RooLognormal, RooPoisson, RooHistFunc, RooHistPdf, RooBernstein, RooBifurGauss, RooCBShape, RooChebychev, RooExponential, RooGamma, RooGaussian, RooLandau, RooPolynomial, RooUniform, RooEfficiency, and RooPolyVar.; Definition at line 4425 of file RooAbsReal.cxx. ◆ chi2FitTo() [1/4]. RooFit::OwningPtr< RooFitResult > RooAbsReal::chi2FitTo ; (; RooDataHist & ; data, . const Roo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsReal.html:66669,adapt,adaptor,66669,doc/master/classRooAbsReal.html,https://root.cern,https://root.cern/doc/master/classRooAbsReal.html,1,['adapt'],['adaptor']
Energy Efficiency,"bs. ; Parameters. [in]obsObservable to retrieve boundaries for. ; [in]xloBeginning of range. ; [in]xhiEnd of range. . ReturnsThe caller owns the returned std::list. ; Reimplemented in ParamHistFunc, PiecewiseInterpolation, RooLagrangianMorphFunc, RooMomentMorphFunc, RooParamHistFunc, RooAddition, RooAddPdf, RooFormulaVar, RooHistFunc, RooHistPdf, RooProdPdf, RooProduct, RooRealSumFunc, RooRealSumPdf, RooBinSamplingPdf, RooBinWidthFunction, RooLinearCombination, RooWrapperPdf, and PdfWrapper.; Definition at line 3640 of file RooAbsReal.cxx. ◆ bindVars(). RooFit::OwningPtr< RooAbsFunc > RooAbsReal::bindVars ; (; const RooArgSet & ; vars, . const RooArgSet * ; nset = nullptr, . bool ; clipInvalid = false . ); const. Create an interface adaptor f(vars) that binds us to the specified variables (in arbitrary order). ; For example, calling bindVars({x1,x3}) on an object F(x1,x2,x3,x4) returns an object f(x1,x3) that is evaluated using the current values of x2 and x4. The caller takes ownership of the returned adaptor. ; Definition at line 3065 of file RooAbsReal.cxx. ◆ buildCallToAnalyticIntegral(). std::string RooAbsReal::buildCallToAnalyticIntegral ; (; Int_t ; code, . const char * ; rangeName, . RooFit::Detail::CodeSquashContext & ; ctx . ); const. virtual . This function defines the analytical integral translation for the class. ; Parameters. [in]codeThe code that decides the integrands. ; [in]rangeNameName of the normalization range. ; [in]ctxAn object to manage auxiliary information for code-squashing. ReturnsThe representative code string of the integral for the given object. ; Reimplemented in RooLognormal, RooPoisson, RooHistFunc, RooHistPdf, RooBernstein, RooBifurGauss, RooCBShape, RooChebychev, RooExponential, RooGamma, RooGaussian, RooLandau, RooPolynomial, RooUniform, RooEfficiency, and RooPolyVar.; Definition at line 4501 of file RooAbsReal.cxx. ◆ chi2FitTo() [1/4]. RooFit::OwningPtr< RooFitResult > RooAbsReal::chi2FitTo ; (; RooDataHist & ; data, . const Roo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAbsReal.html:67937,adapt,adaptor,67937,doc/v632/classRooAbsReal.html,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html,1,['adapt'],['adaptor']
Energy Efficiency,"bsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooEffProd(const char* name, const char* title, RooAbsPdf& pdf, RooAbsReal& efficiency); Constructor of a a production of p.d.f inPdf with efficiency; function inEff. RooEffProd(const RooEffProd& other, const char* name = 0); Copy constructor. ~RooEffProd(); Destructor. Double_t getVal(const RooArgSet* set = 0) const; Return p.d.f. value normalized over given set of observables. Double_t evaluate() const; Calculate and return 'raw' unnormalized value of p.d.f. RooAbsGenContext* genContext(const RooArgSet& vars, const RooDataSet* prototype, const RooArgSet* auxProto, Bool_t verbose) const; Return specialized generator context for RooEffProds that implements generation; in a more efficient way than can be done for generic correlated products. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& numVars, const RooArgSet* normSet, const char* rangeName = 0) const; Return internal integration capabilities of the p.d.f. Given a set 'allVars' for which; integration is requested, returned the largest subset for which internal (analytical); integration is implemented (in argument analVars). The return value is a unique integer; code that identifies the integration configuration (integrated observables and range name). This implementation in RooEffProd catches all integrals without normalization and reroutes them; through a custom integration routine that properly accounts for the use of normalized p.d.f.; in the evaluate() expression, which breaks the default RooAbsPdf normalization handling. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooEffProd.html:40534,efficient,efficient,40534,root/html526/RooEffProd.html,https://root.cern,https://root.cern/root/html526/RooEffProd.html,3,['efficient'],['efficient']
Energy Efficiency,"bsData::Print(Option_t* options = 0) const; virtual voidRooPrintable::printAddress(ostream& os) const; virtual voidRooPrintable::printArgs(ostream& os) const; virtual voidRooAbsData::printClassName(ostream& os) const; virtual voidRooPrintable::printExtras(ostream& os) const; virtual voidRooAbsData::printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; virtual voidRooAbsData::printName(ostream& os) const; virtual voidRooPrintable::printStream(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidRooAbsData::printTitle(ostream& os) const; virtual voidRooPrintable::printTree(ostream& os, TString indent = """") const; virtual voidRooPrintable::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); RooAbsData*RooAbsData::reduce(const char* cut); RooAbsData*RooAbsData::reduce(const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const char* cut = 0); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(RooCmdArg arg1, RooCmdArg arg2 = RooCmdArg(), RooCmdArg arg3 = RooCmdArg(), RooCmdArg arg4 = RooCmdArg(), RooCmdArg arg5 = RooCmdArg(), RooCmdArg arg6 = RooCmdArg(), RooCmdArg arg7 = RooCmdArg(), RooCmdArg arg8 = RooCmdArg()); virtual voidRooAbsData::reset(); voidTObject::ResetBit(UInt_t f); RooRealVar*RooAbsData::rmsVar(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidRooAbsData::setDirtyProp(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual void",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooTreeData.html:8228,reduce,reduce,8228,root/html526/RooTreeData.html,https://root.cern,https://root.cern/root/html526/RooTreeData.html,2,['reduce'],['reduce']
Energy Efficiency,"bsData::Print(Option_t* options = 0) const; virtual voidRooPrintable::printAddress(ostream& os) const; virtual voidRooPrintable::printArgs(ostream& os) const; virtual voidRooAbsData::printClassName(ostream& os) const; virtual voidRooPrintable::printExtras(ostream& os) const; virtual voidRooAbsData::printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; virtual voidRooAbsData::printName(ostream& os) const; virtual voidRooPrintable::printStream(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidRooAbsData::printTitle(ostream& os) const; virtual voidRooPrintable::printTree(ostream& os, TString indent = """") const; virtual voidRooPrintable::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); RooAbsData*RooAbsData::reduce(const char* cut); RooAbsData*RooAbsData::reduce(const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const char* cut = 0); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); static Bool_tRooAbsData::releaseVars(RooAbsData*); virtual voidRooAbsData::reset(); voidTObject::ResetBit(UInt_t f); RooRealVar*RooAbsData::rmsVar(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidRooAbsData::setDirtyProp(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t*",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooTreeData.html:8547,reduce,reduce,8547,root/html530/RooTreeData.html,https://root.cern,https://root.cern/root/html530/RooTreeData.html,1,['reduce'],['reduce']
Energy Efficiency,"bsData::Print(Option_t* options = 0) const; virtual voidRooPrintable::printAddress(ostream& os) const; virtual voidRooPrintable::printArgs(ostream& os) const; virtual voidRooAbsData::printClassName(ostream& os) const; virtual voidRooPrintable::printExtras(ostream& os) const; virtual voidRooAbsData::printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; virtual voidRooAbsData::printName(ostream& os) const; virtual voidRooPrintable::printStream(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidRooAbsData::printTitle(ostream& os) const; virtual voidRooPrintable::printTree(ostream& os, TString indent = """") const; virtual voidRooPrintable::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); RooAbsData*RooAbsData::reduce(const char* cut); RooAbsData*RooAbsData::reduce(const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const char* cut = 0); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); static Bool_tRooAbsData::releaseVars(RooAbsData*); virtual voidRooAbsData::reset(); voidTObject::ResetBit(UInt_t f); voidRooAbsData::resetBuffers(); RooRealVar*RooAbsData::rmsVar(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; RooTreeData(); RooTreeData(const RooTreeData&); RooTreeData(RooTreeData&&); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UI",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooTreeData.html:8784,reduce,reduce,8784,root/html602/RooTreeData.html,https://root.cern,https://root.cern/root/html602/RooTreeData.html,2,['reduce'],['reduce']
Energy Efficiency,"bsData::Print(Option_t* options = 0) const; virtual voidRooPrintable::printAddress(ostream& os) const; virtual voidRooPrintable::printArgs(ostream& os) const; virtual voidRooAbsData::printClassName(ostream& os) const; virtual voidRooPrintable::printExtras(ostream& os) const; virtual voidRooAbsData::printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; virtual voidRooAbsData::printName(ostream& os) const; virtual voidRooPrintable::printStream(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidRooAbsData::printTitle(ostream& os) const; virtual voidRooPrintable::printTree(ostream& os, TString indent = """") const; virtual voidRooPrintable::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); RooAbsData*RooAbsData::reduce(const char* cut); RooAbsData*RooAbsData::reduce(const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const char* cut = 0); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); static Bool_tRooAbsData::releaseVars(RooAbsData*); virtual voidRooAbsData::reset(); voidTObject::ResetBit(UInt_t f); voidRooAbsData::resetBuffers(); RooRealVar*RooAbsData::rmsVar(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsData::setDefaultStorageType(RooAbsData",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooTreeData.html:8767,reduce,reduce,8767,root/html534/RooTreeData.html,https://root.cern,https://root.cern/root/html534/RooTreeData.html,1,['reduce'],['reduce']
Energy Efficiency,"bsData::Print(Option_t* options = 0) const; virtual voidRooPrintable::printAddress(ostream& os) const; virtual voidRooPrintable::printArgs(ostream& os) const; virtual voidRooAbsData::printClassName(ostream& os) const; virtual voidRooPrintable::printExtras(ostream& os) const; virtual voidRooAbsData::printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; virtual voidRooAbsData::printName(ostream& os) const; virtual voidRooPrintable::printStream(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidRooAbsData::printTitle(ostream& os) const; virtual voidRooPrintable::printTree(ostream& os, TString indent = """") const; virtual voidRooPrintable::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); RooAbsData*RooAbsData::reduce(const char* cut); RooAbsData*RooAbsData::reduce(const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const char* cut = 0); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); static Bool_tRooAbsData::releaseVars(RooAbsData*); virtual voidRooAbsData::reset(); voidTObject::ResetBit(UInt_t f); voidRooAbsData::resetBuffers(); RooRealVar*RooAbsData::rmsVar(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidRooAbsData::setDirtyProp(Bool_t flag); virtual void",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooTreeData.html:8643,reduce,reduce,8643,root/html532/RooTreeData.html,https://root.cern,https://root.cern/root/html532/RooTreeData.html,1,['reduce'],['reduce']
Energy Efficiency,"bsReal.cxx:3346; RooAbsReal::forceNumIntvirtual void forceNumInt(bool flag=true)Definition RooAbsReal.h:169; RooAbsReal::getIntegratorConfigconst RooNumIntConfig * getIntegratorConfig() constReturn the numeric integration configuration used for this object.Definition RooAbsReal.cxx:3309; RooAddPdfEfficient implementation of a sum of PDFs of the form.Definition RooAddPdf.h:33; RooArgSetRooArgSet is a container object that can hold multiple RooAbsArg objects.Definition RooArgSet.h:24; RooExponentialExponential PDF.Definition RooExponential.h:22; RooGaussianPlain Gaussian p.d.f.Definition RooGaussian.h:24; RooMsgService::instancestatic RooMsgService & instance()Return reference to singleton instance.Definition RooMsgService.cxx:345; RooMsgService::getStreamStreamConfig & getStream(Int_t id)Definition RooMsgService.h:161; RooNumIntConfigHolds the configuration parameters of the various numeric integrators used by RooRealIntegral.Definition RooNumIntConfig.h:25; RooPowerSumRooPowerSum implements a power law PDF of the form.Definition RooPowerSum.h:20; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; RooRealVar::setBinsvoid setBins(Int_t nBins, const char *name=nullptr)Create a uniform binning under name 'name' for this variable.Definition RooRealVar.cxx:396; RooFit::RooConstRooConstVar & RooConst(double val)Definition RooGlobalFunc.cxx:1131; RooFit::NormSetRooCmdArg NormSet(Args_t &&... argsOrArgSet)Definition RooGlobalFunc.h:371; RooFit::IntegrateBinsRooCmdArg IntegrateBins(double precision)Integrate the PDF over bins.Definition RooGlobalFunc.cxx:507; RooFit::OffsetRooCmdArg Offset(std::string const &mode)Definition RooGlobalFunc.cxx:756; RooFit::SaveRooCmdArg Save(bool flag=true)Definition RooGlobalFunc.cxx:649; RooFit::SumW2ErrorRooCmdArg SumW2Error(bool flag)Definition RooGlobalFunc.cxx:733; RooFit::PrintLevelRooCmdArg PrintLevel(Int_t code)Definition RooGlobalFunc.cxx:657; RooFit::RangeRooCmdArg Range(const char *rangeName, bool ad",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf614__binned__fit__problems_8C.html:11361,power,power,11361,doc/master/rf614__binned__fit__problems_8C.html,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8C.html,1,['power'],['power']
Energy Efficiency,"bservables, normalized by the histograms contents. Interpolation; is applied if the RooHistPdf is configured to do that. Double_t totVolume() const; Return the total volume spanned by the observables of the RooHistPdf. Int_t getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; Determine integration scenario. If no interpolation is used,; RooHistPdf can perform all integrals over its dependents; analytically via partial or complete summation of the input; histogram. If interpolation is used on the integral over; all histogram observables is supported. Double_t analyticalIntegral(Int_t code, const char* rangeName = 0) const; Return integral identified by 'code'. The actual integration; is deferred to RooDataHist::sum() which implements partial; or complete summation over the histograms contents. list<Double_t>* plotSamplingHint(RooAbsRealLValue& obs, Double_t xlo, Double_t xhi) const; Return sampling hint for making curves of (projections) of this function; as the recursive division strategy of RooCurve cannot deal efficiently; with the vertical lines that occur in a non-interpolated histogram. Int_t getMaxVal(const RooArgSet& vars) const; Only handle case of maximum in all variables. Double_t maxVal(Int_t code) const. Bool_t importWorkspaceHook(RooWorkspace& ws); Check if our datahist is already in the workspace. TObject* clone(const char* newname) const; { return new RooHistPdf(*this,newname); }. RooDataHist& dataHist(); Return RooDataHist that is represented. const RooDataHist& dataHist() const; Return RooDataHist that is represented. void setInterpolationOrder(Int_t order); Set histogram interpolation order. Int_t getInterpolationOrder() const; Return histogram interpolation order. void setCdfBoundaries(Bool_t flag); Set use of special boundary conditions for c.d.f.s. Bool_t getCdfBoundaries() const; If true, special boundary conditions for c.d.f.s are used. void setUnitNorm(Bool_t flag); Declare contents to have unit nor",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooHistPdf.html:43530,efficient,efficiently,43530,root/html528/RooHistPdf.html,https://root.cern,https://root.cern/root/html528/RooHistPdf.html,1,['efficient'],['efficiently']
Energy Efficiency,"bservables, normalized by the histograms contents. Interpolation; is applied if the RooHistPdf is configured to do that. Double_t totVolume() const; Return the total volume spanned by the observables of the RooHistPdf. Int_t getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; Determine integration scenario. If no interpolation is used,; RooHistPdf can perform all integrals over its dependents; analytically via partial or complete summation of the input; histogram. If interpolation is used on the integral over; all histogram observables is supported. Double_t analyticalIntegral(Int_t code, const char* rangeName = 0) const; Return integral identified by 'code'. The actual integration; is deferred to RooDataHist::sum() which implements partial; or complete summation over the histograms contents. list<Double_t>* plotSamplingHint(RooAbsRealLValue& obs, Double_t xlo, Double_t xhi) const; Return sampling hint for making curves of (projections) of this function; as the recursive division strategy of RooCurve cannot deal efficiently; with the vertical lines that occur in a non-interpolated histogram. Int_t getMaxVal(const RooArgSet& vars) const; Only handle case of maximum in all variables. Double_t maxVal(Int_t code) const. Bool_t importWorkspaceHook(RooWorkspace& ws); Check if our datahist is already in the workspace. void Streamer(TBuffer& b); Stream an object of class RooHistPdf. TObject* clone(const char* newname) const; { return new RooHistPdf(*this,newname); }. RooDataHist& dataHist(); Return RooDataHist that is represented. const RooDataHist& dataHist() const; Return RooDataHist that is represented. void setInterpolationOrder(Int_t order); Set histogram interpolation order. Int_t getInterpolationOrder() const; Return histogram interpolation order. void setCdfBoundaries(Bool_t flag); Set use of special boundary conditions for c.d.f.s. Bool_t getCdfBoundaries() const; If true, special boundary conditions for c.d.f.s are used.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooHistPdf.html:43746,efficient,efficiently,43746,root/html530/RooHistPdf.html,https://root.cern,https://root.cern/root/html530/RooHistPdf.html,1,['efficient'],['efficiently']
Energy Efficiency,"bservables, normalized by the histograms contents. Interpolation; is applied if the RooHistPdf is configured to do that. Double_t totVolume() const; Return the total volume spanned by the observables of the RooHistPdf. Int_t getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; Determine integration scenario. If no interpolation is used,; RooHistPdf can perform all integrals over its dependents; analytically via partial or complete summation of the input; histogram. If interpolation is used on the integral over; all histogram observables is supported. Double_t analyticalIntegral(Int_t code, const char* rangeName = 0) const; Return integral identified by 'code'. The actual integration; is deferred to RooDataHist::sum() which implements partial; or complete summation over the histograms contents. list<Double_t>* plotSamplingHint(RooAbsRealLValue& obs, Double_t xlo, Double_t xhi) const; Return sampling hint for making curves of (projections) of this function; as the recursive division strategy of RooCurve cannot deal efficiently; with the vertical lines that occur in a non-interpolated histogram. Int_t getMaxVal(const RooArgSet& vars) const; Only handle case of maximum in all variables. Double_t maxVal(Int_t code) const. TObject* clone(const char* newname) const; { return new RooHistPdf(*this,newname); }. RooDataHist& dataHist(); Return RooDataHist that is represented. const RooDataHist& dataHist(); Return RooDataHist that is represented. void setInterpolationOrder(Int_t order); Set histogram interpolation order. Int_t getInterpolationOrder() const; Return histogram interpolation order. void setCdfBoundaries(Bool_t flag); Set use of special boundary conditions for c.d.f.s. Bool_t getCdfBoundaries() const; If true, special boundary conditions for c.d.f.s are used. void setUnitNorm(Bool_t flag); Declare contents to have unit normalization. Bool_t haveUnitNorm() const; Return true if contents is declared to be unit normalized. Boo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooHistPdf.html:42695,efficient,efficiently,42695,root/html526/RooHistPdf.html,https://root.cern,https://root.cern/root/html526/RooHistPdf.html,1,['efficient'],['efficiently']
Energy Efficiency,"bservables, normalized by the histograms contents. Interpolation; is applied if the RooHistPdf is configured to do that. Double_t totVolume() const; Return the total volume spanned by the observables of the RooHistPdf. Int_t getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; Determine integration scenario. If no interpolation is used,; RooHistPdf can perform all integrals over its dependents; analytically via partial or complete summation of the input; histogram. If interpolation is used on the integral over; all histogram observables is supported. Double_t analyticalIntegral(Int_t code, const char* rangeName = 0) const; Return integral identified by 'code'. The actual integration; is deferred to RooDataHist::sum() which implements partial; or complete summation over the histograms contents. list<Double_t>* plotSamplingHint(RooAbsRealLValue& obs, Double_t xlo, Double_t xhi) const; Return sampling hint for making curves of (projections) of this function; as the recursive division strategy of RooCurve cannot deal efficiently; with the vertical lines that occur in a non-interpolated histogram. std::list<Double_t>* binBoundaries(RooAbsRealLValue& , Double_t , Double_t ) const; Return sampling hint for making curves of (projections) of this function; as the recursive division strategy of RooCurve cannot deal efficiently; with the vertical lines that occur in a non-interpolated histogram. Int_t getMaxVal(const RooArgSet& vars) const; Only handle case of maximum in all variables. Double_t maxVal(Int_t code) const. Bool_t areIdentical(const RooDataHist& dh1, const RooDataHist& dh2). Bool_t importWorkspaceHook(RooWorkspace& ws); Check if our datahist is already in the workspace. void Streamer(TBuffer& ); Stream an object of class RooHistPdf. TObject* clone(const char* newname) const; { return new RooHistPdf(*this,newname); }. RooDataHist& dataHist(); Return RooDataHist that is represented. const RooDataHist& dataHist() const; Retu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooHistPdf.html:46548,efficient,efficiently,46548,root/html534/RooHistPdf.html,https://root.cern,https://root.cern/root/html534/RooHistPdf.html,3,['efficient'],['efficiently']
Energy Efficiency,"bservables, normalized by the histograms contents. Interpolation; is applied if the RooHistPdf is configured to do that. Double_t totVolume() const; Return the total volume spanned by the observables of the RooHistPdf. Int_t getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; Determine integration scenario. If no interpolation is used,; RooHistPdf can perform all integrals over its dependents; analytically via partial or complete summation of the input; histogram. If interpolation is used on the integral over; all histogram observables is supported. Double_t analyticalIntegral(Int_t code, const char* rangeName = 0) const; Return integral identified by 'code'. The actual integration; is deferred to RooDataHist::sum() which implements partial; or complete summation over the histograms contents. list<Double_t>* plotSamplingHint(RooAbsRealLValue& obs, Double_t xlo, Double_t xhi) const; Return sampling hint for making curves of (projections) of this function; as the recursive division strategy of RooCurve cannot deal efficiently; with the vertical lines that occur in a non-interpolated histogram. std::list<Double_t>* binBoundaries(RooAbsRealLValue& , Double_t , Double_t ) const; Return sampling hint for making curves of (projections) of this function; as the recursive division strategy of RooCurve cannot deal efficiently; with the vertical lines that occur in a non-interpolated histogram. Int_t getMaxVal(const RooArgSet& vars) const; Only handle case of maximum in all variables. Double_t maxVal(Int_t code) const. Bool_t importWorkspaceHook(RooWorkspace& ws); Check if our datahist is already in the workspace. void Streamer(TBuffer& b); Stream an object of class RooHistPdf. TObject* clone(const char* newname) const; { return new RooHistPdf(*this,newname); }. RooDataHist& dataHist(); Return RooDataHist that is represented. const RooDataHist& dataHist() const; Return RooDataHist that is represented. void setInterpolationOrder(Int_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooHistPdf.html:44977,efficient,efficiently,44977,root/html532/RooHistPdf.html,https://root.cern,https://root.cern/root/html532/RooHistPdf.html,1,['efficient'],['efficiently']
Energy Efficiency,"buffers with TSQLStatement::StoreResult(); method. Information about selected fields (columns); can be obtained with GetNumFields() and GetFieldName() methods.; To recieve data for next result row, NextResultRow() method should be called.; Value from each column can be taken with the GetInt(), GetDouble(),; GetString() and other methods. There are no strict limitation which method should be used; to get column values. GetString() can be used as generic method,; which should always return correct result, but also convertion between most; basic data types are supported. For instance, if column contains integer; values, GetInt(), GetLong64(), GetDouble() and GetString() methods can be used.; If column has float point format, GetDouble() and GetString() methods can; be used without loss of precision while GetInt() or GetLong64() will return; integer part of the value. One also can test, if value is NULL with IsNull(); method. Buffer length, specified for statement in TSQLServer::Statement() call,; will also be used to allocate buffers for column values. Usage of these; buffers is transparent for users and does not limit number of rows,; which can be accessed with one statement. Example of select query:. stmt = serv->Statement(""SELECT * FROM TESTTABLE"", 100);; // process statement; if (stmt->Process()) {; // store result of statement in buffer; stmt->StoreResult();. // display info about selected field; cout << ""NumFields = "" << stmt->GetNumFields() << endl;; for (int n=0;n<stmt->GetNumFields();n++); cout << ""Field "" << n << "" = "" << stmt->GetFieldName(n) << endl;. // extract rows one after another; while (stmt->NextResultRow()) {; Double_t id1 = stmt->GetDouble(0);; UInt_t id2 = stmt->GetUInt(1);; const char* name1 = stmt->GetString(2);; const char* name2 = stmt->GetString(3);; cout << id1 << "" - "" << id2 << "" "" << name1 << "" "" << name2 << endl;; }; }. 4. Working with date/time parameters. Current implementation supports date, time, date&time and timestamp; data (all ti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSQLStatement.html:6013,allocate,allocate,6013,root/html528/TSQLStatement.html,https://root.cern,https://root.cern/root/html528/TSQLStatement.html,3,['allocate'],['allocate']
Energy Efficiency,"bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. THnSparseArrayChunk*THnSparse::AddChunk(); voidTHnBase::AddInternal(const THnBase* h, Double_t c, Bool_t rebinned); Bool_tTHnBase::CheckConsistency(const THnBase* h, const char* tag) const; THnBase*THnBase::CloneEmpty(const char* name, const char* title, const TObjArray* axes, Bool_t keepTargetAxis) const; TH1*THnBase::CreateHist(const char* name, const char* title, const TObjArray* axes, Bool_t keepTargetAxis) const; static THnBase*THnBase::CreateHnAny(const char* name, const char* title, const TH1* h1, Bool_t sparse, Int_t chunkSize = 1024 * 16); static THnBase*THnBase::CreateHnAny(const char* name, const char* title, const THnBase* hn, Bool_t sparse, Int_t chunkSize = 1024 * 16); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual voidTHnSparse::FillBin(Long64_t bin, Double_t w); voidTHnBase::FillBinBase(Double_t w); voidTHnSparse::FillExMap(); Long64_tTHnSparse::GetBinIndexForCurrentBin(Bool_t allocate); THnSparseArrayChunk*THnSparse::GetChunk(Int_t idx) const; THnSparseCompactBinCoord*THnSparse::GetCompactCoord() const; voidTHnBase::Init(const char* name, const char* title, const TObjArray* axes, Bool_t keepTargetAxis, Int_t chunkSize = 1024 * 16); virtual voidTHnSparse::InitStorage(Int_t* nbins, Int_t chunkSize); voidTObject::MakeZombie(); Bool_tTHnBase::PrintBin(Long64_t idx, Int_t* coord, Option_t* options) const; TObject*THnBase::ProjectionAny(Int_t ndim, const Int_t* dim, Bool_t wantNDim, Option_t* option = """") const; THnBase*THnBase::RebinBase(Int_t group) const; THnBase*THnBase::RebinBase(const Int_t* group) const; virtual voidTHnSparse::Reserve(Long64_t nbins); voidTHnBase::ResetBase(Option_t* option = """"); voidTHnBase::UpdateXStat(const Double_t* x, Double_t w = 1.). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/THnSparseT_TArrayC_.html:10452,allocate,allocate,10452,root/html602/THnSparseT_TArrayC_.html,https://root.cern,https://root.cern/root/html602/THnSparseT_TArrayC_.html,12,['allocate'],['allocate']
Energy Efficiency,"build a volume with same name, shape and mediumDefinition TGeoVolume.cxx:1928; TGeoVolume::ReplayCreationvoid ReplayCreation(const TGeoVolume *other)Recreate the content of the other volume without pointer copying.Definition TGeoVolume.cxx:1292; TGeoVolume::WeightDouble_t Weight(Double_t precision=0.01, Option_t *option=""va"")Estimate the weight of a volume (in kg) with SIGMA(M)/M better than PRECISION.Definition TGeoVolume.cxx:2501; TGeoVolume::fNumberInt_t fNumberoption - if anyDefinition TGeoVolume.h:55; TGeoVolume::CreateThreadDatavirtual void CreateThreadData(Int_t nthreads)Definition TGeoVolume.cxx:435; TGeoVolume::GetByteCountvirtual Int_t GetByteCount() constget the total size in bytes for this volumeDefinition TGeoVolume.cxx:2204; TGeoVolume::AddNodevirtual TGeoNode * AddNode(TGeoVolume *vol, Int_t copy_no, TGeoMatrix *mat=nullptr, Option_t *option="""")Add a TGeoNode to the list of nodes.Definition TGeoVolume.cxx:975; TGeoVolume::OptimizeVoxelsBool_t OptimizeVoxels()Perform an extensive sampling to find which type of voxelization is most efficient.Definition TGeoVolume.cxx:1247; TGeoVolume::Browsevoid Browse(TBrowser *b) overrideHow to browse a volume.Definition TGeoVolume.cxx:535; TGeoVolume::SetCurrentPointvoid SetCurrentPoint(Double_t x, Double_t y, Double_t z)Set the current tracking point.Definition TGeoVolume.cxx:2059; TGeoVolume::Paintvoid Paint(Option_t *option="""") overridepaint volumeDefinition TGeoVolume.cxx:1267; TGeoVolume::SetVisOnlyvoid SetVisOnly(Bool_t flag=kTRUE) overrideSet visibility for leaves.Definition TGeoVolume.cxx:2393; TGeoVolume::fGeoManagerTGeoManager * fGeoManagerDefinition TGeoVolume.h:51; TGeoVolume::LegoPlotTH2F * LegoPlot(Int_t ntheta=20, Double_t themin=0., Double_t themax=180., Int_t nphi=60, Double_t phimin=0., Double_t phimax=360., Double_t rmin=0., Double_t rmax=9999999, Option_t *option="""")Generate a lego plot fot the top volume, according to option.Definition TGeoVolume.cxx:1332; TGeoVolume::Drawvoid Draw(Option_t *optio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoVolume_8cxx_source.html:143452,efficient,efficient,143452,doc/master/TGeoVolume_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoVolume_8cxx_source.html,1,['efficient'],['efficient']
Energy Efficiency,"bytes and should be ok for most cases.; You can specify a larger value (e.g. 256000) if your Tree is not split; and each entry is large (Megabytes); A small value for bufsize is optimum if you intend to access; the entries in the Tree randomly and your Tree is in split mode. TBranch* BranchRef(); Build the optional branch supporting the TRefTable.; This branch will keep all the information to find the branches; containing referenced objects. At each Tree::Fill, the branch numbers containing the; referenced objects are saved to the TBranchRef basket.; When the Tree header is saved (via TTree::Write), the branch; is saved keeping the information with the pointers to the branches; having referenced objects. TBranch* Bronch(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 99); Create a new TTree BranchElement. WARNING about this new function. This function is designed to replace the function TTree::Branch above.; This function is far more powerful than the Branch function.; It supports the full C++, including STL and has the same behaviour; in split or non-split mode. classname does not have to derive from TObject.; The function is based on the new TStreamerInfo. Build a TBranchElement for an object of class classname. addr is the address of a pointer to an object of class classname.; The class dictionary must be available (ClassDef in class header). Note: See the comments in TBranchElement::SetAddress() for a more; detailed discussion of the meaning of the addr parameter. This option requires access to the library where the corresponding class; is defined. Accessing one single data member in the object implies; reading the full object. By default the branch buffers are stored in the same file as the Tree.; use TBranch::SetFile to specify a different file. IMPORTANT NOTE about branch names; In case two or more master branches contain subbranches with; identical names, one must add a ""."" (dot) character at the end; of the m",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTree.html:52223,power,powerful,52223,root/html532/TTree.html,https://root.cern,https://root.cern/root/html532/TTree.html,1,['power'],['powerful']
Energy Efficiency,"c Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofProgressMemoryPlot(TProofProgressDialog* d, Int_t w = 700, Int_t h = 300); Main constructor. ~TProofProgressMemoryPlot(); Destructor. TGListBox* BuildLogList(TGFrame* parent); Build the list of workers. For this, extract the logs and take the names; of TProofLogElements. void Clear(Option_t* = 0); Clear the canvases. void DoPlot(); Draw the plot from the logs. TGraph * DoAveragePlot(Int_t& max_el, Int_t& min_el); Create the average plots. Int_t ParseLine(TString l, Long64_t& v, Long64_t& r, Long64_t& e); Extract from line 'l' the virtual memory 'v', the resident memory 'r' and the; number of events 'e'.; The line is assumed to be in the form; ""... Memory 130868 virtual 31540 ... event 5550""; The fields are only filled if >= 0 .; Return 0 on success, -1 if any of the values coudl not be filled (the output; fields are not touched in such a case). TGraph * DoWorkerPlot(TProofLogElem* ple); Make a memory consumption graph for a worker. TGraph * DoMasterPlot(TProofLogElem* ple); a master or submaster log; display without meaningful labels for now. void Select(Int_t id); actions of select all/clear all button. TGraph* DoAveragePlotOld(Int_t& max_el, Int_t& min_el). » Author: Anna Kreshuk 18/07/2008 » Copyright (C) 1995-2003, Rene Brun and Fons Rademakers. *; » Last changed: root/sessionviewer:$Id: TProofProgressMemoryPlot.h 28564 2009-05-12 11:00:21Z ganis $ » Last generated: 2010-09-23 20:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofProgressMemoryPlot.html:23457,consumption,consumption,23457,root/html528/TProofProgressMemoryPlot.html,https://root.cern,https://root.cern/root/html528/TProofProgressMemoryPlot.html,1,['consumption'],['consumption']
Energy Efficiency,"c Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofProgressMemoryPlot(TProofProgressDialog* d, Int_t w = 700, Int_t h = 300); Main constructor. ~TProofProgressMemoryPlot(); Destructor. TGListBox* BuildLogList(TGFrame* parent); Build the list of workers. For this, extract the logs and take the names; of TProofLogElements. void Clear(Option_t* = 0); Clear the canvases. void DoPlot(); Draw the plot from the logs. TGraph * DoAveragePlot(Int_t& max_el, Int_t& min_el); Create the average plots. Int_t ParseLine(TString l, Long64_t& v, Long64_t& r, Long64_t& e); Extract from line 'l' the virtual memory 'v', the resident memory 'r' and the; number of events 'e'.; The line is assumed to be in the form; ""... Memory 130868 virtual 31540 ... event 5550""; The fields are only filled if >= 0 .; Return 0 on success, -1 if any of the values coudl not be filled (the output; fields are not touched in such a case). TGraph * DoWorkerPlot(TProofLogElem* ple); Make a memory consumption graph for a worker. TGraph * DoMasterPlot(TProofLogElem* ple); a master or submaster log; display without meaningful labels for now. void Select(Int_t id); actions of select all/clear all button. TGraph* DoAveragePlotOld(Int_t& max_el, Int_t& min_el). » Author: Anna Kreshuk 18/07/2008 » Copyright (C) 1995-2003, Rene Brun and Fons Rademakers. *; » Last changed: root/sessionviewer:$Id: TProofProgressMemoryPlot.h 28564 2009-05-12 11:00:21Z ganis $ » Last generated: 2011-07-04 15:36; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TProofProgressMemoryPlot.html:23610,consumption,consumption,23610,root/html530/TProofProgressMemoryPlot.html,https://root.cern,https://root.cern/root/html530/TProofProgressMemoryPlot.html,1,['consumption'],['consumption']
Energy Efficiency,"c Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofProgressMemoryPlot(TProofProgressDialog* d, Int_t w = 700, Int_t h = 300); Main constructor. ~TProofProgressMemoryPlot(); Destructor. TGListBox* BuildLogList(TGFrame* parent); Build the list of workers. For this, extract the logs and take the names; of TProofLogElements. void Clear(Option_t* = 0); Clear the canvases. void DoPlot(); Draw the plot from the logs. TGraph * DoAveragePlot(Int_t& max_el, Int_t& min_el); Create the average plots. Int_t ParseLine(TString l, Long64_t& v, Long64_t& r, Long64_t& e); Extract from line 'l' the virtual memory 'v', the resident memory 'r' and the; number of events 'e'.; The line is assumed to be in the form; ""... Memory 130868 virtual 31540 ... event 5550""; The fields are only filled if >= 0 .; Return 0 on success, -1 if any of the values coudl not be filled (the output; fields are not touched in such a case). TGraph * DoWorkerPlot(TProofLogElem* ple); Make a memory consumption graph for a worker. TGraph * DoMasterPlot(TProofLogElem* ple); a master or submaster log; display without meaningful labels for now. void Select(Int_t id); actions of select all/clear all button. TGraph* DoAveragePlotOld(Int_t& max_el, Int_t& min_el). » Author: Anna Kreshuk 18/07/2008 » Copyright (C) 1995-2003, Rene Brun and Fons Rademakers. *; » Last changed: root/sessionviewer:$Id: TProofProgressMemoryPlot.h 28564 2009-05-12 11:00:21Z ganis $ » Last generated: 2011-12-02 14:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TProofProgressMemoryPlot.html:23610,consumption,consumption,23610,root/html532/TProofProgressMemoryPlot.html,https://root.cern,https://root.cern/root/html532/TProofProgressMemoryPlot.html,1,['consumption'],['consumption']
Energy Efficiency,"c TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TMonitor::EInterestkRead; static TObject::(anonymous)TObject::kSingleKey; static TMonitor::EInterestkWrite; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. private:. TList*fActivelist of sockets to monitor; TList*fDeActivelist of (temporary) disabled sockets; Bool_tfInterruptflags an interrupt to Select; Bool_tfMainLooptrue if monitoring sockets within the main event loop; TSocket*fReadysocket which is ready to be read or written. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMonitor(Bool_t mainloop = kTRUE); Create a monitor object. If mainloop is true the monitoring will be; done in the main event loop. TMonitor(const TMonitor& m); Copy constructor. ~TMonitor(); Cleanup the monitor object. Does not delete sockets being monitored. void Add(TSocket* sock, Int_t interest = kRead); Add socket to the monitor's active list. If interest=kRead then we; want to monitor the socket for read readiness, if interest=kWrite; then we monitor the socket for write readiness, if interest=kRead|kWrite; then we monitor both read and write readiness. void SetInterest(TSocket* sock, Int_t interest = kRead); Set interest mask for socket sock to interest. If the socket is not; in the active list move it or add it there.; If interest=kRead then we want to mo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMonitor.html:10307,monitor,monitor,10307,root/html602/TMonitor.html,https://root.cern,https://root.cern/root/html602/TMonitor.html,4,['monitor'],"['monitor', 'monitoring']"
Energy Efficiency,"c(fWindows);; 328 ; 329 if (!fColors) return;; 330 Long64_t key, value;; 331 TExMapIter it(fColors);; 332 while (it.Next(key, value)) {; 333 XColor_t *col = (XColor_t *) (Long_t)value;; 334 delete col;; 335 }; 336 delete fColors;; 337}; 338 ; 339////////////////////////////////////////////////////////////////////////////////; 340/// Initialize X11 system. Returns kFALSE in case of failure.; 341 ; 342Bool_t TGX11::Init(void *display); 343{; 344 if (OpenDisplay(display) == -1) return kFALSE;; 345 return kTRUE;; 346}; 347 ; 348////////////////////////////////////////////////////////////////////////////////; 349/// Allocate color in colormap. If we are on an <= 8 plane machine; 350/// we will use XAllocColor. If we are on a >= 15 (15, 16 or 24) plane; 351/// true color machine we will calculate the pixel value using:; 352/// for 15 and 16 bit true colors have 6 bits precision per color however; 353/// only the 5 most significant bits are used in the color index.; 354/// Except for 16 bits where green uses all 6 bits. I.e.:; 355/// ~~~ {.cpp}; 356/// 15 bits = rrrrrgggggbbbbb; 357/// 16 bits = rrrrrggggggbbbbb; 358/// ~~~; 359/// for 24 bits each r, g and b are represented by 8 bits.; 360///; 361/// Since all colors are set with a max of 65535 (16 bits) per r, g, b; 362/// we just right shift them by 10, 11 and 10 bits for 16 planes, and; 363/// (10, 10, 10 for 15 planes) and by 8 bits for 24 planes.; 364/// Returns kFALSE in case color allocation failed.; 365 ; 366Bool_t TGX11::AllocColor(Colormap cmap, RXColor *color); 367{; 368 if (fRedDiv == -1) {; 369 if (XAllocColor((Display*)fDisplay, cmap, color)); 370 return kTRUE;; 371 } else {; 372 color->pixel = (color->red >> fRedDiv) << fRedShift |; 373 (color->green >> fGreenDiv) << fGreenShift |; 374 (color->blue >> fBlueDiv) << fBlueShift;; 375 return kTRUE;; 376 }; 377 return kFALSE;; 378}; 379 ; 380////////////////////////////////////////////////////////////////////////////////; 381/// Returns the current RGB value for",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGX11_8cxx_source.html:11265,green,green,11265,doc/master/TGX11_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html,1,['green'],['green']
Energy Efficiency,"cal derivative of a function f at a point x using an adaptive central difference algorithm with a step size h. ; Definition at line 114 of file Derivator.cxx. ◆ EvalCentral() [2/2]. double ROOT::Math::Derivator::EvalCentral ; (; double ; x, . double ; h = 1E-8 . ); const. Computes the numerical derivative at a point x using an adaptive central difference algorithm with a step size h. ; Definition at line 97 of file Derivator.cxx. ◆ EvalForward() [1/2]. double ROOT::Math::Derivator::EvalForward ; (; const IGenFunction & ; f, . double ; x, . double ; h = 1E-8 . ). static . Computes the numerical derivative of a function f at a point x using an adaptive forward difference algorithm with a step size h. ; The function is evaluated only at points greater than x and at x itself ; Definition at line 118 of file Derivator.cxx. ◆ EvalForward() [2/2]. double ROOT::Math::Derivator::EvalForward ; (; double ; x, . double ; h = 1E-8 . ); const. Computes the numerical derivative at a point x using an adaptive forward difference algorithm with a step size h. ; The function is evaluated only at points greater than x and at x itself. ; Definition at line 101 of file Derivator.cxx. ◆ operator=(). Derivator & ROOT::Math::Derivator::operator= ; (; const Derivator & ; rhs). private . Definition at line 76 of file Derivator.cxx. ◆ Result(). double ROOT::Math::Derivator::Result ; (; ); const. return the result of the last derivative calculation ; Definition at line 152 of file Derivator.cxx. ◆ SetFunction() [1/2]. void ROOT::Math::Derivator::SetFunction ; (; const GSLFuncPointer & ; f, . void * ; p = nullptr . ). Set the function f for evaluating the derivative using a GSL function pointer type. ; Parameters. f: free function pointer of the GSL required type ; p: pointer to the object carrying the function state (for example the function object itself) . Definition at line 88 of file Derivator.cxx. ◆ SetFunction() [2/2]. void ROOT::Math::Derivator::SetFunction ; (; const IGenFunction & ; f)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1Derivator.html:9386,adapt,adaptive,9386,doc/master/classROOT_1_1Math_1_1Derivator.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1Derivator.html,1,['adapt'],['adaptive']
Energy Efficiency,"calar Et () const;  return the transverse energy ;  ; Scalar Et2 () const;  return the transverse energy squared ;  ; Scalar Eta () const;  pseudorapidity ;  ; Scalar eta () const;  ; Scalar Gamma () const;  Return Gamma scalar value. ;  ; template<class IT > ; void GetCoordinates (IT begin) const;  get internal data into 4 Scalars at *begin ;  ; template<class IT > ; void GetCoordinates (IT begin, IT end) const;  get internal data into 4 Scalars at *begin to *end ;  ; void GetCoordinates (Scalar &a, Scalar &b, Scalar &c, Scalar &d) const;  get internal data into 4 Scalar numbers ;  ; void GetCoordinates (Scalar dest[]) const;  get internal data into an array of 4 Scalar numbers ;  ; bool isLightlike (Scalar tolerance=100 *std::numeric_limits< Scalar >::epsilon()) const;  Determine if momentum-energy can represent a massless particle. ;  ; bool isSpacelike () const;  Determine if momentum-energy is spacelike, and represents a tachyon. ;  ; bool isTimelike () const;  Determine if momentum-energy can represent a physical massive particle. ;  ; Scalar M () const;  return magnitude (mass) using the (-,-,-,+) metric. ;  ; Scalar M2 () const;  return magnitude (mass) squared M2 = T**2 - X**2 - Y**2 - Z**2 (we use -,-,-,+ metric) ;  ; Scalar mag () const;  ; Scalar mag2 () const;  ; Scalar mass () const;  ; Scalar mass2 () const;  ; Scalar Mt () const;  return the transverse mass ;  ; Scalar mt () const;  ; Scalar Mt2 () const;  return the transverse mass squared ;  ; Scalar mt2 () const;  ; bool operator!= (const LorentzVector &rhs) const;  ; LorentzVector operator* (const Scalar &a) const;  product of a LorentzVector by a scalar quantity ;  ; LorentzVector & operator*= (Scalar a);  multiplication by a scalar quantity v *= a ;  ; LorentzVector operator+ () const;  ; template<class OtherLorentzVector > ; LorentzVector operator+ (const OtherLorentzVector &v2) const;  addition of two LorentzVectors (v3 = v1 + v2) Enable the addition with any other LorentzVector ;  ; template",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1LorentzVector.html:4900,energy,energy,4900,doc/master/classROOT_1_1Math_1_1LorentzVector.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1LorentzVector.html,1,['energy'],['energy']
Energy Efficiency,"calculate the error bars for each bin of a RooHist object. More...;  ; class  RooHistFunc;  A real-valued function sampled from a multidimensional histogram. More...;  ; class  RooHistPdf;  A propability density function sampled from a multidimensional histogram. More...;  ; class  RooImproperIntegrator1D;  Special numeric integrator that can handle integrals over open domains. More...;  ; class  RooInvTransform;  Lightweight function binding that returns the inverse of an input function binding. More...;  ; class  RooLinkedList;  Collection class for internal use, storing a collection of RooAbsArg pointers in a doubly linked list. More...;  ; class  RooLinkedListElem;  Link element for the RooLinkedList class. More...;  ; class  RooLinTransBinning;  Special binning implementation for RooLinearVar that transforms the binning of the RooLinearVar input variable in the same way that RooLinearVar does. More...;  ; class  RooMCIntegrator;  Implements an adaptive multi-dimensional Monte Carlo numerical integration, following the VEGAS algorithm originally described in G. More...;  ; class  RooMCStudy;  Helper class to facilitate Monte Carlo studies such as 'goodness-of-fit' studies, that involve fitting a PDF to multiple toy Monte Carlo sets. More...;  ; class  RooMinimizer;  Wrapper class around ROOT::Math::Minimizer that provides a seamless interface between the minimizer functionality and the native RooFit interface. More...;  ; class  RooMoment;  ; class  RooMsgService;  Singleton class that organizes messages generated in RooFit. More...;  ; class  RooMultiCategory;  Connects several RooAbsCategory objects into a single category. More...;  ; class  RooMultiVarGaussian;  Multivariate Gaussian p.d.f. More...;  ; class  RooNameReg;  Registry for const char* names. More...;  ; class  RooNLLVar;  Implements a -log(likelihood) calculation from a dataset and a PDF. More...;  ; class  RooNormSetCache;  Class RooNormSet cache manage the bookkeeping of multiple instances of se",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Roofitcore.html:12563,adapt,adaptive,12563,doc/master/group__Roofitcore.html,https://root.cern,https://root.cern/doc/master/group__Roofitcore.html,1,['adapt'],['adaptive']
Energy Efficiency,"call; 87 ; 88The following methods are provided to generate random numbers distributed according to some basic distributions:; 89 ; 90- Exp(Double_t tau); 91- Integer(UInt_t imax); 92- Gaus(Double_t mean, Double_t sigma); 93- Rndm(); 94- Uniform(Double_t); 95- Landau(Double_t mean, Double_t sigma); 96- Poisson(Double_t mean); 97- Binomial(Int_t ntot, Double_t prob); 98 ; 99Random numbers distributed according to 1-d, 2-d or 3-d distributions contained in TF1, TF2 or TF3 objects can also be; 100generated. For example, to get a random number distributed following abs(sin(x)/x)*sqrt(x) you can do : \code{.cpp} TF1; 101*f1 = new TF1(""f1"",""abs(sin(x)/x)*sqrt(x)"",0,10); double r = f1->GetRandom(); \endcode or you can use the UNURAN; 102package. You need in this case to initialize UNURAN to the function you would like to generate. \code{.cpp} TUnuran u;; 103 u.Init(TUnuranDistrCont(f1));; 104 double r = u.Sample();; 105\endcode; 106 ; 107The techniques of using directly a TF1,2 or 3 function is powerful and; 108can be used to generate numbers in the defined range of the function.; 109Getting a number from a TF1,2,3 function is also quite fast.; 110UNURAN is a powerful and flexible tool which contains various methods for; 111generate random numbers for continuous distributions of one and multi-dimension.; 112It requires some set-up (initialization) phase and can be very fast when the distribution; 113parameters are not changed for every call.; 114 ; 115The following table shows some timings (in nanosecond/call); 116for basic functions, TF1 functions and using UNURAN obtained running; 117the tutorial math/testrandom.C; 118Numbers have been obtained on an Intel Xeon Quad-core Harpertown (E5410) 2.33 GHz running; 119Linux SLC4 64 bit and compiled with gcc 3.4; 120 ; 121~~~~; 122Distribution nanoseconds/call; 123 TRandom TRandom1 TRandom2 TRandom3; 124Rndm.............. 5.000 105.000 7.000 10.000; 125RndmArray......... 4.000 104.000 6.000 9.000; 126Gaus.............. 36.000 180.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TRandom_8cxx_source.html:7148,power,powerful,7148,doc/master/TRandom_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TRandom_8cxx_source.html,1,['power'],['powerful']
Energy Efficiency,"calling for; every invocation TInterpreter::Execute(...). TMethodCall(const TMethodCall& org); Copy ctor. TMethodCall & operator=(const TMethodCall& rhs); Assignement operator. ~TMethodCall(); TMethodCall dtor. TObject * Clone(const char* newname = """") const; Return an exact copy of this object. void Init(TClass* cl, const char* method, const char* params); Initialize the method invocation environment. Necessary input; information: the class, method name and the parameter string; of the form ""\""aap\"", 3, 4.35"".; To execute the method call TMethodCall::Execute(object,...).; This two step method is much more efficient than calling for; every invocation TInterpreter::Execute(...). void Init(const char* function, const char* params); Initialize the function invocation environment. Necessary input; information: the function name and the parameter string of; the form ""\""aap\"", 3, 4.35"".; To execute the method call TMethodCall::Execute(...).; This two step method is much more efficient than calling for; every invocation TInterpreter::Execute(...). void InitImplementation(const char* methodname, const char* params, const char* proto, TClass* cl, const ClassInfo_t* cinfo); This function implements Init and InitWithPrototype. void InitWithPrototype(TClass* cl, const char* method, const char* proto); Initialize the method invocation environment. Necessary input; information: the class, method name and the prototype string of; the form: ""char*,int,float"".; To execute the method call TMethodCall::Execute(object,...).; This two step method is much more efficient than calling for; every invocation TInterpreter::Execute(...). void InitWithPrototype(const char* function, const char* proto); Initialize the function invocation environment. Necessary input; information: the function name and the prototype string of; the form: ""char*,int,float"".; To execute the method call TMethodCall::Execute(...).; This two step method is much more efficient than calling for; every invocation TInterpr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMethodCall.html:9192,efficient,efficient,9192,root/html528/TMethodCall.html,https://root.cern,https://root.cern/root/html528/TMethodCall.html,4,['efficient'],['efficient']
Energy Efficiency,"cally deduced. ; TThe type of the column to apply the reduction to. Automatically deduced. . Parameters. [in]fA callable with signature T(T,T) ; [in]columnNameThe column to be reduced. If omitted, the first default column is used instead. ; [in]redIdentityThe reduced object of each thread is initialized to this value. . Returnsthe reduced quantity wrapped in a RResultPtr. Example usage:; auto sumOfIntColWithOffset = d.Reduce([](int x, int y) { return x + y; }, ""intCol"", 42);; See the description of the first Reduce overload for more information. ; Definition at line 1711 of file RInterface.hxx. ◆ Reduce() [2/2]. template<typename Proxied , typename DataSource = void> . template<typename F , typename T = typename TTraits::CallableTraits<F>::ret_type> . RResultPtr< T > ROOT::RDF::RInterface< Proxied, DataSource >::Reduce ; (; F ; f, . std::string_view ; columnName = """" . ). inline . Execute a user-defined reduce operation on the values of a column. ; Template Parameters. FThe type of the reduce callable. Automatically deduced. ; TThe type of the column to apply the reduction to. Automatically deduced. . Parameters. [in]fA callable with signature T(T,T) ; [in]columnNameThe column to be reduced. If omitted, the first default column is used instead. . Returnsthe reduced quantity wrapped in a ROOT::RDF:RResultPtr.; A reduction takes two values of a column and merges them into one (e.g. by summing them, taking the maximum, etc). This action performs the specified reduction operation on all processed column values, returning a single value of the same type. The callable f must satisfy the general requirements of a processing function besides having signature T(T,T) where T is the type of column columnName.; The returned reduced value of each thread (e.g. the initial value of a sum) is initialized to a default-constructed T object. This is commonly expected to be the neutral/identity element for the specific reduction operation f (e.g. 0 for a sum, 1 for a product). If a def",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html:120435,reduce,reduce,120435,doc/master/classROOT_1_1RDF_1_1RInterface.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html,1,['reduce'],['reduce']
Energy Efficiency,"case 102:; 3496 {; 3497 Double_t red[9] = { 18./255., 29./255., 44./255., 72./255., 116./255., 158./255., 184./255., 208./255., 221./255.};; 3498 Double_t green[9] = { 27./255., 46./255., 71./255., 105./255., 146./255., 177./255., 189./255., 190./255., 183./255.};; 3499 Double_t blue[9] = { 39./255., 55./255., 80./255., 108./255., 130./255., 133./255., 124./255., 100./255., 76./255.};; 3500 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3501 }; 3502 break;; 3503 ; 3504 // Sunset; 3505 case 103:; 3506 {; 3507 Double_t red[9] = { 0./255., 48./255., 119./255., 173./255., 212./255., 224./255., 228./255., 228./255., 245./255.};; 3508 Double_t green[9] = { 0./255., 13./255., 30./255., 47./255., 79./255., 127./255., 167./255., 205./255., 245./255.};; 3509 Double_t blue[9] = { 0./255., 68./255., 75./255., 43./255., 16./255., 22./255., 55./255., 128./255., 245./255.};; 3510 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3511 }; 3512 break;; 3513 ; 3514 // Temperature Map; 3515 case 104:; 3516 {; 3517 Double_t red[9] = { 34./255., 70./255., 129./255., 187./255., 225./255., 226./255., 216./255., 193./255., 179./255.};; 3518 Double_t green[9] = { 48./255., 91./255., 147./255., 194./255., 226./255., 229./255., 196./255., 110./255., 12./255.};; 3519 Double_t blue[9] = { 234./255., 212./255., 216./255., 224./255., 206./255., 110./255., 53./255., 40./255., 29./255.};; 3520 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3521 }; 3522 break;; 3523 ; 3524 // Thermometer; 3525 case 105:; 3526 {; 3527 Double_t red[9] = { 30./255., 55./255., 103./255., 147./255., 174./255., 203./255., 188./255., 151./255., 105./255.};; 3528 Double_t green[9] = { 0./255., 65./255., 138./255., 182./255., 187./255., 175./255., 121./255., 53./255., 9./255.};; 3529 Double_t blue[9] = { 191./255., 202./255., 212./255., 208./255., 171./255., 140./255., 97./255., 57./255., 30./255.};; 3530 Idx = TColor::CreateGrad",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TColor_8cxx_source.html:139131,green,green,139131,doc/master/TColor_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html,1,['green'],['green']
Energy Efficiency,"case 74:; 3216 {; 3217 Double_t red[9] = { 76./255., 120./255., 156./255., 183./255., 197./255., 180./255., 162./255., 154./255., 140./255.};; 3218 Double_t green[9] = { 34./255., 35./255., 42./255., 69./255., 102./255., 137./255., 164./255., 188./255., 197./255.};; 3219 Double_t blue[9] = { 64./255., 69./255., 78./255., 105./255., 142./255., 177./255., 205./255., 217./255., 198./255.};; 3220 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3221 }; 3222 break;; 3223 ; 3224 // Cherry; 3225 case 75:; 3226 {; 3227 Double_t red[9] = { 37./255., 102./255., 157./255., 188./255., 196./255., 214./255., 223./255., 235./255., 251./255.};; 3228 Double_t green[9] = { 37./255., 29./255., 25./255., 37./255., 67./255., 91./255., 132./255., 185./255., 251./255.};; 3229 Double_t blue[9] = { 37./255., 32./255., 33./255., 45./255., 66./255., 98./255., 137./255., 187./255., 251./255.};; 3230 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3231 }; 3232 break;; 3233 ; 3234 // Coffee; 3235 case 76:; 3236 {; 3237 Double_t red[9] = { 79./255., 100./255., 119./255., 137./255., 153./255., 172./255., 192./255., 205./255., 250./255.};; 3238 Double_t green[9] = { 63./255., 79./255., 93./255., 103./255., 115./255., 135./255., 167./255., 196./255., 250./255.};; 3239 Double_t blue[9] = { 51./255., 59./255., 66./255., 61./255., 62./255., 70./255., 110./255., 160./255., 250./255.};; 3240 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3241 }; 3242 break;; 3243 ; 3244 // Dark Rain Bow; 3245 case 77:; 3246 {; 3247 Double_t red[9] = { 43./255., 44./255., 50./255., 66./255., 125./255., 172./255., 178./255., 155./255., 157./255.};; 3248 Double_t green[9] = { 63./255., 63./255., 85./255., 101./255., 138./255., 163./255., 122./255., 51./255., 39./255.};; 3249 Double_t blue[9] = { 121./255., 101./255., 58./255., 44./255., 47./255., 55./255., 57./255., 44./255., 43./255.};; 3250 Idx = TColor::CreateGradientColorTa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TColor_8cxx_source.html:124469,green,green,124469,doc/master/TColor_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html,1,['green'],['green']
Energy Efficiency,"case 80:; 3276 {; 3277 Double_t red[9] = { 243./255., 222./255., 201./255., 185./255., 165./255., 158./255., 166./255., 187./255., 219./255.};; 3278 Double_t green[9] = { 94./255., 108./255., 132./255., 135./255., 125./255., 96./255., 68./255., 51./255., 61./255.};; 3279 Double_t blue[9] = { 7./255., 9./255., 12./255., 19./255., 45./255., 89./255., 118./255., 146./255., 118./255.};; 3280 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3281 }; 3282 break;; 3283 ; 3284 // Fuchsia; 3285 case 81:; 3286 {; 3287 Double_t red[9] = { 19./255., 44./255., 74./255., 105./255., 137./255., 166./255., 194./255., 206./255., 220./255.};; 3288 Double_t green[9] = { 19./255., 28./255., 40./255., 55./255., 82./255., 110./255., 159./255., 181./255., 220./255.};; 3289 Double_t blue[9] = { 19./255., 42./255., 68./255., 96./255., 129./255., 157./255., 188./255., 203./255., 220./255.};; 3290 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3291 }; 3292 break;; 3293 ; 3294 // Grey Yellow; 3295 case 82:; 3296 {; 3297 Double_t red[9] = { 33./255., 44./255., 70./255., 99./255., 140./255., 165./255., 199./255., 211./255., 216./255.};; 3298 Double_t green[9] = { 38./255., 50./255., 76./255., 105./255., 140./255., 165./255., 191./255., 189./255., 167./255.};; 3299 Double_t blue[9] = { 55./255., 67./255., 97./255., 124./255., 140./255., 166./255., 163./255., 129./255., 52./255.};; 3300 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3301 }; 3302 break;; 3303 ; 3304 // Green Brown Terrain; 3305 case 83:; 3306 {; 3307 Double_t red[9] = { 0./255., 33./255., 73./255., 124./255., 136./255., 152./255., 159./255., 171./255., 223./255.};; 3308 Double_t green[9] = { 0./255., 43./255., 92./255., 124./255., 134./255., 126./255., 121./255., 144./255., 223./255.};; 3309 Double_t blue[9] = { 0./255., 43./255., 68./255., 76./255., 73./255., 64./255., 72./255., 114./255., 223./255.};; 3310 Idx = TColor::CreateGradien",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TColor_8cxx_source.html:127597,green,green,127597,doc/master/TColor_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html,1,['green'],['green']
Energy Efficiency,"case a delimiter is specified, the format ""%lg %lg %lg"" will read X,Y,EX. ~TGraphErrors(); TGraphErrors default destructor. void Apply(TF1* f); apply function to all the data points; y = f(x,y). The error is calculated as ey=(f(x,y+ey)-f(x,y-ey))/2; This is the same as error(fy) = df/dy * ey for small errors. For generic functions the symmetric errors might become non-symmetric; and are averaged here. Use TGraphAsymmErrors if desired. error on x doesn't change; function suggested/implemented by Miroslav Helbich <helbich@mail.desy.de>. Int_t CalculateScanfFields(const char* fmt); Calculate scan fields. void ComputeRange(Double_t& xmin, Double_t& ymin, Double_t& xmax, Double_t& ymax) const; Compute range. void CopyAndRelease(Double_t** newarrays, Int_t ibegin, Int_t iend, Int_t obegin); Copy and release. Bool_t CopyPoints(Double_t** arrays, Int_t ibegin, Int_t iend, Int_t obegin); Copy errors from fEX and fEY to arrays[0] and arrays[1]; or to fX and fY. Copy points. Bool_t CtorAllocate(); Constructor allocate.; Note: This function should be called only from the constructor; since it does not delete previously existing arrays. Bool_t DoMerge(const TGraph* g); protected function to perform the merge operation of a graph with errors. void FillZero(Int_t begin, Int_t end, Bool_t from_ctor = kTRUE); Set zero values for point arrays in the range [begin, end]. Double_t GetErrorX(Int_t bin) const; This function is called by GraphFitChisquare.; It returns the error along X at point i. Double_t GetErrorY(Int_t bin) const; This function is called by GraphFitChisquare.; It returns the error along Y at point i. Double_t GetErrorXhigh(Int_t bin) const; This function is called by GraphFitChisquare.; It returns the error along X at point i. Double_t GetErrorXlow(Int_t bin) const; This function is called by GraphFitChisquare.; It returns the error along X at point i. Double_t GetErrorYhigh(Int_t bin) const; This function is called by GraphFitChisquare.; It returns the error along X at ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGraphErrors.html:18402,allocate,allocate,18402,root/html534/TGraphErrors.html,https://root.cern,https://root.cern/root/html534/TGraphErrors.html,3,['allocate'],['allocate']
Energy Efficiency,"cation), the object can be; added (and constructed when needed) using ConstructedAt which only; calls the constructor once per slot. TClonesArray a(""TTrack"", 10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000) events; for (int i = 0; i < ev->Ntracks; i++) { // O(10000) tracks; TTrack *track = (TTrack*)a.ConstructedAt(i);; track->Set(x,y,z,....);. }. a.Clear(); // or a.Clear(""C"");; }. Note: the only supported way to add objects to a TClonesArray is; via the new with placement method or the ConstructedAt method.; The other Add() methods ofTObjArray and its base classes are not; allowed. Considering that a new/delete costs about 70 mus on a 300 MHz HP,; O(10^9) new/deletes will save about 19 hours. NOTE 1. C/C++ offers the possibility of allocating and deleting memory.; Forgetting to delete allocated memory is a programming error called a; ""memory leak"", i.e. the memory of your process grows and eventually; your program crashes. Even if you *always* delete the allocated; memory, the recovered space may not be efficiently reused. The; process knows that there are portions of free memory, but when you; allocate it again, a fresh piece of memory is grabbed. Your program; is free from semantic errors, but the total memory of your process; still grows, because your program's memory is full of ""holes"" which; reduce the efficiency of memory access; this is called ""memory; fragmentation"". Moreover new / delete are expensive operations in; terms of CPU time. Without entering into technical details, TClonesArray allows you to; ""reuse"" the same portion of memory for new/delete avoiding memory; fragmentation and memory growth and improving the performance by; orders of magnitude. Every time the memory of the TClonesArray has; to be reused, the Clear() method is used. To provide its benefits,; each TClonesArray must be allocated *once* per process and disposed; of (deleted) *only when not needed any more*. So a job should see *only one* deletion for each TClonesArray,; wh",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TClonesArray.html:2281,allocate,allocated,2281,root/html532/TClonesArray.html,https://root.cern,https://root.cern/root/html532/TClonesArray.html,8,"['allocate', 'efficient']","['allocated', 'efficiently']"
Energy Efficiency,"ccurately; calculated from UT1. If fSec and fNanoSec are in UTC (which they are by; default), the optional argument UT1Offset can be supplied (in; milliseconds). If UT1Offset is not supplied, conversion has maximum error; of 1s. If offset is supplied error can be reduced to us level. Values for; UT1Offset can be found in IERS Bulletin B:; ftp://ftp.iers.org/products/eop/bulletinb/format_2009; The conversion to sidereal time used here is given by; Aoki et. al. Astron. Astrophys. 105, 359-362 (1982); http://adsabs.harvard.edu/abs/1982A%26A...105..359A. Double_t AsGAST(Double_t UT1Offset = 0) const; Return Greenwich apparant sidereal time (GAST) in hour-angle. Return; value will always be between 0 and 24 (hours). Sidereal time is most; accurately calculated from UT1. If fSec and fNanoSec are in UTC (which; they are by default), the optional argument UT1Offset can be supplied (in; milliseconds). If UT1Offset is not supplied, conversion has maximum error; of 1s. If offset is supplied error can be reduced to us level. Values for; UT1Offset can be found in IERS Bulletin B:; ftp://ftp.iers.org/products/eop/bulletinb/format_2009; Equation of the equinoxes is given by USNO:; http://aa.usno.navy.mil/faq/docs/GAST.php. Double_t AsLMST(Double_t Longitude, Double_t UT1Offset = 0) const; Return local mean sidereal time (LMST) in hour-angle, given a longitude; in degrees. Return value will always be between 0 and 24 (hours).; Sidereal time is most accurately calculated from UT1. If fSec and; fNanoSec are in UTC (which they are by default), the optional argument; UT1Offset can be supplied (in milliseconds). If UT1Offset is not; supplied, conversion has maximum error of 1s. If offset is supplied error; can be reduced to us level. Values for UT1Offset can be found in IERS; Bulletin B: ftp://ftp.iers.org/products/eop/bulletinb/format_2009. Double_t AsLAST(Double_t Longitude, Double_t UT1Offset = 0) const; Return local apparant sidereal time (LAST) in hour-angle, given a; longitude in ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTimeStamp.html:6231,reduce,reduced,6231,root/html534/TTimeStamp.html,https://root.cern,https://root.cern/root/html534/TTimeStamp.html,2,['reduce'],['reduced']
Energy Efficiency,"ce (see IsDigit()),; i.e. ""123456"", ""123 456"" and ""1 2 3 4 56"" are all valid; integer strings whose Atoll() value is 123456. Double_t Atof() const; Return floating-point value contained in string.; Examples of valid strings are:; 64320; 64 320; 6 4 3 2 0; 6.4320 6,4320; 6.43e20 6.43E20 6,43e20; 6.43e-20 6.43E-20 6,43e-20. TString Itoa(Int_t value, Int_t base); Converts an Int_t to a TString with respect to the base specified (2-36).; Thus it is an enhanced version of sprintf (adapted from versions 0.4 of; http://www.jb.man.ac.uk/~slowe/cpp/itoa.html).; Usage: the following statement produce the same output, namely ""1111""; cout << TString::Itoa(15,2) ;; cout << TString::Itoa(0xF,2) ; /// 0x prefix to handle hex; cout << TString::Itoa(017,2) ; /// 0 prefix to handle oct; In case of error returns the ""!"" string. TString UItoa(UInt_t value, Int_t base); Converts a UInt_t (twice the range of an Int_t) to a TString with respect; to the base specified (2-36). Thus it is an enhanced version of sprintf; (adapted from versions 0.4 of http://www.jb.man.ac.uk/~slowe/cpp/itoa.html).; In case of error returns the ""!"" string. TString LLtoa(Long64_t value, Int_t base); Converts a Long64_t to a TString with respect to the base specified (2-36).; Thus it is an enhanced version of sprintf (adapted from versions 0.4 of; http://www.jb.man.ac.uk/~slowe/cpp/itoa.html).; In case of error returns the ""!"" string. TString ULLtoa(ULong64_t value, Int_t base); Converts a ULong64_t (twice the range of an Long64_t) to a TString with; respect to the base specified (2-36). Thus it is an enhanced version of; sprintf (adapted from versions 0.4 of http://www.jb.man.ac.uk/~slowe/cpp/itoa.html).; In case of error returns the ""!"" string. TString BaseConvert(const TString& s_in, Int_t base_in, Int_t base_out); Converts string from base base_in to base base_out. Supported bases; are 2-36. At most 64 bit data can be converted. Bool_t EndsWith(const char* pat, TString::ECaseCompare cmp = kExact) const; Return",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TString.html:18567,adapt,adapted,18567,root/html534/TString.html,https://root.cern,https://root.cern/root/html534/TString.html,1,['adapt'],['adapted']
Energy Efficiency,"ce for new Math classes and functions.; ROOT::Math::adkTestStatvoid adkTestStat(double *adk, const std::vector< std::vector< double > > &samples, const std::vector< double > &zstar)Definition GoFTest.cxx:546; ROOT::Math::getCountint getCount(double z, const double *dat, int n)Definition GoFTest.cxx:520; ROOT::Math::getSumint getSum(const int *x, int n)Definition GoFTest.cxx:534; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; TMath::KolmogorovTestDouble_t KolmogorovTest(Int_t na, const Double_t *a, Int_t nb, const Double_t *b, Option_t *option)Statistical test whether two one-dimensional sets of points are compatible with coming from the same ...Definition TMath.cxx:805; TMath::LogDouble_t Log(Double_t x)Returns the natural logarithm of x.Definition TMath.h:756; TMath::SqrtDouble_t Sqrt(Double_t x)Returns the square root of x.Definition TMath.h:662; TMath::PowerLongDouble_t Power(LongDouble_t x, LongDouble_t y)Returns x raised to the power y.Definition TMath.h:721; TMath::KolmogorovProbDouble_t KolmogorovProb(Double_t z)Calculates the Kolmogorov distribution function,.Definition TMath.cxx:679; TMath::Sortvoid Sort(Index n, const Element *a, Index *index, Bool_t down=kTRUE)Sort the n elements of the array a of generic templated type Element.Definition TMathBase.h:431; TMath::AbsShort_t Abs(Short_t d)Returns the absolute value of parameter Short_t d.Definition TMathBase.h:123; ROOT::Math::CDFWrapperDefinition GoFTest.cxx:40; ROOT::Math::CDFWrapper::CDFWrapperCDFWrapper(const IGenFunction &cdf, Double_t xmin=0, Double_t xmax=-1)Definition GoFTest.cxx:50; ROOT::Math::CDFWrapper::DoEvalDouble_t DoEval(Double_t x) const overrideimplementation of the evaluation function. Must be implemented by derived classesDefinition GoFTest.cxx:65; ROOT::Math::CDFWrapper::CloneIGenFunction * Clone() const overrideClone a function.Definition GoFTest.cxx:71; ROOT::Math::CDFWrapper::fCDFconst IGen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/GoFTest_8cxx_source.html:46944,power,power,46944,doc/master/GoFTest_8cxx_source.html,https://root.cern,https://root.cern/doc/master/GoFTest_8cxx_source.html,1,['power'],['power']
Energy Efficiency,"ce per slot. TClonesArray a(""TTrack"", 10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000) events; for (int i = 0; i < ev->Ntracks; i++) { // O(10000) tracks; TTrack *track = (TTrack*)a.ConstructedAt(i);; track->Set(x,y,z,....);; ...; ...; }; ...; a.Clear(); // or a.Clear(""C"");; }; Note: the only supported way to add objects to a TClonesArray is via the new with placement method or the ConstructedAt method. The other Add() methods ofTObjArray and its base classes are not allowed.; Considering that a new/delete costs about 70 mus on a 300 MHz HP, O(10^9) new/deletes will save about 19 hours. NOTE 1; C/C++ offers the possibility of allocating and deleting memory. Forgetting to delete allocated memory is a programming error called a ""memory leak"", i.e. the memory of your process grows and eventually your program crashes. Even if you always delete the allocated memory, the recovered space may not be efficiently reused. The process knows that there are portions of free memory, but when you allocate it again, a fresh piece of memory is grabbed. Your program is free from semantic errors, but the total memory of your process still grows, because your program's memory is full of ""holes"" which reduce the efficiency of memory access; this is called ""memory; fragmentation"". Moreover new / delete are expensive operations in terms of CPU time.; Without entering into technical details, TClonesArray allows you to ""reuse"" the same portion of memory for new/delete avoiding memory fragmentation and memory growth and improving the performance by orders of magnitude. Every time the memory of the TClonesArray has to be reused, the Clear() method is used. To provide its benefits, each TClonesArray must be allocated once per process and disposed of (deleted) only when not needed any more.; So a job should see only one deletion for each TClonesArray, which should be Clear()ed during the job several times. Deleting a TClonesArray is a double waste. Not only you do not avoid memory f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClonesArray.html:2734,allocate,allocate,2734,doc/master/classTClonesArray.html,https://root.cern,https://root.cern/doc/master/classTClonesArray.html,1,['allocate'],['allocate']
Energy Efficiency,"ce. ;  ; Float_t TMath::Normalize (Float_t v[3]);  Normalize a vector v in place. ;  ; template<typename T > ; T TMath::NormCross (const T v1[3], const T v2[3], T out[3]);  Calculates the Normalized Cross Product of two vectors. ;  ; Double_t TMath::NormQuantile (Double_t p);  Computes quantiles for standard normal distribution N(0, 1) at probability p. ;  ; Bool_t TMath::Permute (Int_t n, Int_t *a);  Simple recursive algorithm to find the permutations of n natural numbers, not necessarily all distinct adapted from CERNLIB routine PERMU. ;  ; constexpr Double_t TMath::Pi ();  \( \pi\) ;  ; constexpr Double_t TMath::PiOver2 ();  \( \frac{\pi}{2} \) ;  ; constexpr Double_t TMath::PiOver4 ();  \( \frac{\pi}{4} \) ;  ; Double_t TMath::Poisson (Double_t x, Double_t par);  Computes the Poisson distribution function for (x,par). ;  ; Double_t TMath::PoissonI (Double_t x, Double_t par);  Computes the Discrete Poisson distribution function for (x,par). ;  ; Double_t TMath::Power (Double_t x, Double_t y);  Returns x raised to the power y. ;  ; Double_t TMath::Power (Double_t x, Int_t y);  Returns x raised to the power y. ;  ; LongDouble_t TMath::Power (Long64_t x, Long64_t y);  Returns x raised to the power y. ;  ; LongDouble_t TMath::Power (LongDouble_t x, Long64_t y);  Returns x raised to the power y. ;  ; LongDouble_t TMath::Power (LongDouble_t x, LongDouble_t y);  Returns x raised to the power y. ;  ; Double_t TMath::Prob (Double_t chi2, Int_t ndf);  Computation of the probability for a certain Chi-squared (chi2) and number of degrees of freedom (ndf). ;  ; constexpr Double_t TMath::Qe ();  Elementary charge in \( C \) . ;  ; constexpr Double_t TMath::QeUncertainty ();  Elementary charge uncertainty. ;  ; void TMath::Quantiles (Int_t n, Int_t nprob, Double_t *x, Double_t *quantiles, Double_t *prob, Bool_t isSorted=kTRUE, Int_t *index=nullptr, Int_t type=7);  Computes sample quantiles, corresponding to the given probabilities. ;  ; Double_t TMath::QuietNaN ();  Returns a qu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMath_8h.html:15277,power,power,15277,doc/master/TMath_8h.html,https://root.cern,https://root.cern/doc/master/TMath_8h.html,1,['power'],['power']
Energy Efficiency,"ceSampler is an extension of the ToyMCSampler for Importance Sampling ;  CToyMCPayload;  CToyMCSamplerToyMCSampler is an implementation of the TestStatSampler interface ;  CToyMCStudyToyMCStudy is an implementation of RooAbsStudy for toy Monte Carlo sampling ;  CUniformProposalUniformProposal is a concrete implementation of the ProposalFunction interface for use with a Markov Chain Monte Carlo algorithm ;  CUpperLimitMCSModuleThis class allow to compute in the ToyMcStudy framework the ProfileLikelihood upper limit for each toy-MC sample generated ;  ►NROOTNamespace for new ROOT classes and functions ;  ►NDetail;  ►NRDF;  ►NCustomColExtraArgs;  CNone;  CSlot;  CSlotAndEntry;  CRCustomColumn;  CRCustomColumnBase;  CRFilter;  CRFilterBase;  CRJittedCustomColumnA wrapper around a concrete RCustomColumn, which forwards all calls to it RJittedCustomColumn is a placeholder that is put in the collection of custom columns in place of a RCustomColumn that will be just-in-time compiled ;  CRJittedFilterA wrapper around a concrete RFilter, which forwards all calls to it RJittedFilter is the type of the node returned by jitted Filter calls: the concrete filter can be created and set at a later time, from jitted code ;  ►CRLoopManagerThe head node of a RDF computation graph ;  CTCallback;  CTOneTimeCallback;  CRNodeBaseBase class for non-leaf nodes of the computational graph ;  CRRange;  CRRangeBase;  ►NVecOps;  ►CRAdoptAllocatorRAdoptAllocator can provide a view on already allocated memory ;  Crebind;  ►CRAdoptAllocator< bool >;  Crebind;  C__integer_sequence;  C__make;  C__make< 0 >;  C__make< 1 >;  C__make< 2 >;  C__make< 3 >;  C__make< 4 >;  C__make< 5 >;  C__make< 6 >;  C__make< 7 >;  C__parity;  ►C__parity< 0 >;  C__pmake;  ►C__parity< 1 >;  C__pmake;  ►C__parity< 2 >;  C__pmake;  ►C__parity< 3 >;  C__pmake;  ►C__parity< 4 >;  C__pmake;  ►C__parity< 5 >;  C__pmake;  ►C__parity< 6 >;  C__pmake;  ►C__parity< 7 >;  C__pmake;  C__repeat;  C__repeat< __integer_sequence< _Tp, _Np.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/annotated.html:14646,allocate,allocated,14646,doc/v616/annotated.html,https://root.cern,https://root.cern/doc/v616/annotated.html,1,['allocate'],['allocated']
Energy Efficiency,"ceSteps); 241 , m_batchSize (_batchSize); 242 , m_testRepetitions (_testRepetitions); 243 , m_factorWeightDecay (_factorWeightDecay); 244 , count_E (0); 245 , count_dE (0); 246 , count_mb_E (0); 247 , count_mb_dE (0); 248 , m_regularization (eRegularization); 249 , fLearningRate (_learningRate); 250 , fMomentum (_momentum); 251 , fRepetitions (_repetitions); 252 , fMinimizerType (_eMinimizerType); 253 , m_convergenceCount (0); 254 , m_maxConvergenceCount (0); 255 , m_minError (1e10); 256 , m_useMultithreading (_useMultithreading); 257 , fMonitoring (NULL); 258 {; 259 }; 260 ; 261 Settings::~Settings () ; 262 {; 263 }; 264 ; 265 ; 266 ; 267 ; 268 ; 269 ; 270 ; 271 ; 272 ; 273 ; 274 ; 275 ; 276 ; 277 ; 278 /** \brief action to be done when the training cycle is started (e.g. update some monitoring output); 279 *; 280 */; 281 void ClassificationSettings::startTrainCycle () ; 282 {; 283 if (fMonitoring); 284 {; 285 create (""ROC"", 100, 0, 1, 100, 0, 1);; 286 create (""Significance"", 100, 0, 1, 100, 0, 3);; 287 create (""OutputSig"", 100, 0, 1);; 288 create (""OutputBkg"", 100, 0, 1);; 289 fMonitoring->ProcessEvents ();; 290 }; 291 }; 292 ; 293 /** \brief action to be done when the training cycle is ended (e.g. update some monitoring output); 294 *; 295 */; 296 void ClassificationSettings::endTrainCycle (double /*error*/) ; 297 {; 298 if (fMonitoring) fMonitoring->ProcessEvents ();; 299 }; 300 ; 301 /** \brief action to be done after the computation of a test sample (e.g. update some monitoring output); 302 *; 303 */; 304 void ClassificationSettings::testSample (double /*error*/, double output, double target, double weight); 305 {; 306 ; 307 m_output.push_back (output);; 308 m_targets.push_back (target);; 309 m_weights.push_back (weight);; 310 }; 311 ; 312 ; 313 /** \brief action to be done when the test cycle is started (e.g. update some monitoring output); 314 *; 315 */; 316 void ClassificationSettings::startTestCycle () ; 317 {; 318 m_output.clear ();; 319 m_targets.clear (",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/NeuralNet_8cxx_source.html:10943,monitor,monitoring,10943,doc/master/NeuralNet_8cxx_source.html,https://root.cern,https://root.cern/doc/master/NeuralNet_8cxx_source.html,1,['monitor'],['monitoring']
Energy Efficiency,"cementVector2D & operator+= (const DisplacementVector2D< OtherCoords, Tag > &v);  Self Addition with a displacement vector. ;  ; DisplacementVector2D operator- () const;  Negative of the vector. ;  ; template<class OtherCoords > ; DisplacementVector2D & operator-= (const DisplacementVector2D< OtherCoords, Tag > &v);  Self Difference with a displacement vector. ;  ; DisplacementVector2D operator/ (Scalar a) const;  Division of a vector with a real number. ;  ; DisplacementVector2D & operator/= (Scalar a);  divide this vector by a scalar quantity ;  ; template<class OtherCoords > ; DisplacementVector2D & operator= (const DisplacementVector2D< OtherCoords, Tag > &v);  Assignment operator from a displacement vector of arbitrary type. ;  ; template<class ForeignVector > ; DisplacementVector2D & operator= (const ForeignVector &v);  Assignment from a foreign 2D vector type, for example, Hep2Vector Precondition: v must implement methods x() and y() ;  ; template<class OtherCoords > ; DisplacementVector2D & operator= (const PositionVector2D< OtherCoords, Tag > &rhs);  Assignment operator from a position vector (not necessarily efficient unless one or the other is Cartesian) ;  ; bool operator== (const DisplacementVector2D &rhs) const;  Exact equality. ;  ; Scalar Phi () const;  Polar phi, converting if necessary from internal coordinate system. ;  ; Scalar phi () const;  ; Scalar R () const;  Polar R, converting if necessary from internal coordinate system. ;  ; Scalar r () const;  ; void Rotate (Scalar angle);  Rotate by an angle. ;  ; DisplacementVector2D< CoordSystem, Tag > & SetCoordinates (Scalar a, Scalar b);  Set internal data based on 2 Scalar numbers. ;  ; DisplacementVector2D< CoordSystem, Tag > & SetPhi (Scalar ang);  Change Phi - Polar2D coordinates. ;  ; DisplacementVector2D< CoordSystem, Tag > & SetR (Scalar a);  Change R - Polar2D coordinates only. ;  ; DisplacementVector2D< CoordSystem, Tag > & SetX (Scalar a);  Change X - Cartesian2D coordinates only. ;  ; Di",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1DisplacementVector2D.html:4360,efficient,efficient,4360,doc/master/classROOT_1_1Math_1_1DisplacementVector2D.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1DisplacementVector2D.html,1,['efficient'],['efficient']
Energy Efficiency,"cess the options specified by the user. void InitMonitorNtuple(); initialize the monitoring ntuple. void Init(); default initialization. void InitEventSample( void ); write all Events from the Tree into a vector of Events, that are; more easily manipulated.; This method should never be called without existing trainingTree, as it; the vector of events from the ROOT training tree. void Train( void ). void TrainTMVARuleFit( void ); training of rules using TMVA implementation. void TrainJFRuleFit( void ); training of rules using Jerome Friedmans implementation. const TMVA::Ranking* CreateRanking(); computes ranking of input variables. void AddWeightsXMLTo(void* parent) const; add the rules to XML node. void ReadWeightsFromStream(istream& istr); read rules from an std::istream. void ReadWeightsFromXML(void* wghtnode); read rules from XML node. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); returns MVA value for given event. void WriteMonitoringHistosToFile( void ); write special monitoring histograms to file (here ntuple). void MakeClassSpecific(ostream& , const TString& ) const; write specific classifier response. void MakeClassRuleCuts(ostream& ) const; print out the rule cuts. void MakeClassLinear(ostream& ) const; print out the linear terms. void GetHelpMessage() const; get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". Bool_t UseBoost() const; { return fUseBoost; }. RuleFit* GetRuleFitPtr(); accessors. { return &fRuleFit; }. const RuleFit* GetRuleFitConstPtr() const; { return &fRuleFit; }. TDirectory* GetMethodBaseDir() const; { return BaseDir(); }. const std::vector<TMVA::Event*>& GetTrainingEvents() const; { return fEventSample; }. const std::vector<TMVA::DecisionTree*>& GetForest() const; { return fForest; }. Int_t GetNTrees() const; { return fNTrees; }. Double_t GetTreeEveFrac() const; { return fTreeEveFrac; }. const SeparationBase* GetSeparationBaseConst() const; { return fSe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__MethodRuleFit.html:22748,monitor,monitoring,22748,root/html534/TMVA__MethodRuleFit.html,https://root.cern,https://root.cern/root/html534/TMVA__MethodRuleFit.html,1,['monitor'],['monitoring']
Energy Efficiency,"cess the options specified by the user. void InitMonitorNtuple(); initialize the monitoring ntuple. void Init(); default initialization. void InitEventSample( void ); write all Events from the Tree into a vector of Events, that are; more easily manipulated.; This method should never be called without existing trainingTree, as it; the vector of events from the ROOT training tree. void Train( void ). void TrainTMVARuleFit( void ); training of rules using TMVA implementation. void TrainJFRuleFit( void ); training of rules using Jerome Friedmans implementation. const TMVA::Ranking* CreateRanking(); computes ranking of input variables. void AddWeightsXMLTo(void* parent) const; add the rules to XML node. void ReadWeightsFromStream(istream& istr); read rules from an std::istream. void ReadWeightsFromXML(void* wghtnode); read rules from XML node. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); returns MVA value for given event. void WriteMonitoringHistosToFile( void ); write special monitoring histograms to file (here ntuple). void MakeClassSpecific(ostream& , const TString& ) const; write specific classifier response. void MakeClassRuleCuts(ostream& ) const; print out the rule cuts. void MakeClassLinear(ostream& ) const; print out the linear terms. void GetHelpMessage() const; get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". MethodRuleFit(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = """", TDirectory* theTargetDir = 0). Bool_t UseBoost() const; { return fUseBoost; }. RuleFit* GetRuleFitPtr(); accessors. { return &fRuleFit; }. const RuleFit* GetRuleFitConstPtr() const; { return &fRuleFit; }. TDirectory* GetMethodBaseDir() const; { return BaseDir(); }. const std::vector<TMVA::Event*>& GetTrainingEvents() const; { return fEventSample; }. const std::vector<TMVA::DecisionTree*>& GetForest() const; { return fForest; }. Int_t GetNTrees",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__MethodRuleFit.html:23901,monitor,monitoring,23901,root/html602/TMVA__MethodRuleFit.html,https://root.cern,https://root.cern/root/html602/TMVA__MethodRuleFit.html,2,['monitor'],['monitoring']
Energy Efficiency,"cess)) {; 3308 continue;; 3309 }; 3310 if (undo) {; 3311 TBranch* br = tree->GetBranch(branch->GetName());; 3312 tree->ResetBranchAddress(br);; 3313 } else {; 3314 char* addr = branch->GetAddress();; 3315 if (!addr) {; 3316 if (branch->IsA() == TBranch::Class()) {; 3317 // If the branch was created using a leaflist, the branch itself may not have; 3318 // an address but the leaf might already.; 3319 TLeaf *firstleaf = (TLeaf*)branch->GetListOfLeaves()->At(0);; 3320 if (!firstleaf || firstleaf->GetValuePointer()) {; 3321 // Either there is no leaf (and thus no point in copying the address); 3322 // or the leaf has an address but we can not copy it via the branche; 3323 // this will be copied via the next loop (over the leaf).; 3324 continue;; 3325 }; 3326 }; 3327 // Note: This may cause an object to be allocated.; 3328 branch->SetAddress(nullptr);; 3329 addr = branch->GetAddress();; 3330 }; 3331 TBranch* br = tree->GetBranch(branch->GetFullName());; 3332 if (br) {; 3333 if (br->GetMakeClass() != branch->GetMakeClass()); 3334 br->SetMakeClass(branch->GetMakeClass());; 3335 br->SetAddress(addr);; 3336 // The copy does not own any object allocated by SetAddress().; 3337 if (br->InheritsFrom(TBranchElement::Class())) {; 3338 ((TBranchElement*) br)->ResetDeleteObject();; 3339 }; 3340 } else {; 3341 Warning(""CopyAddresses"", ""Could not find branch named '%s' in tree named '%s'"", branch->GetName(), tree->GetName());; 3342 }; 3343 }; 3344 }; 3345 ; 3346 // Copy branch addresses starting from leaves.; 3347 TObjArray* tleaves = tree->GetListOfLeaves();; 3348 Int_t ntleaves = tleaves->GetEntriesFast();; 3349 std::set<TLeaf*> updatedLeafCount;; 3350 for (Int_t i = 0; i < ntleaves; ++i) {; 3351 TLeaf* tleaf = (TLeaf*) tleaves->UncheckedAt(i);; 3352 TBranch* tbranch = tleaf->GetBranch();; 3353 TBranch* branch = GetBranch(tbranch->GetName());; 3354 if (!branch) {; 3355 continue;; 3356 }; 3357 TLeaf* leaf = branch->GetLeaf(tleaf->GetName());; 3358 if (!leaf) {; 3359 continue;; 3360 };",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:132124,allocate,allocated,132124,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['allocate'],['allocated']
Energy Efficiency,"ch matrix object . If this is an; issue recompile with a new appropriate value (>=0) for kSizeMax. Sparse matrices are also stored in row-wise fashion but additional; row/column information is stored, see TMatrixTSparse source for; additional details . Another way to assign and store matrix data is through Use; see for instance stressLinear.cxx file . Unless otherwise specified, matrix and vector indices always start; with 0, spanning up to the specified limit-1. However, there are; constructors to which one can specify aribtrary lower and upper; bounds, e.g. TMatrixD m(1,10,1,5) defines a matrix that ranges; from 1..10, 1..5 (a(1,1)..a(10,5)). The present package provides all facilities to completely AVOID; returning matrices. Use ""TMatrixD A(TMatrixD::kTransposed,B);""; and other fancy constructors as much as possible. If one really needs; to return a matrix, return a TMatrixTLazy object instead. The; conversion is completely transparent to the end user, e.g.; ""TMatrixT m = THaarMatrixT(5);"" and _is_ efficient. Since TMatrixT et al. are fully integrated in ROOT, they of course; can be stored in a ROOT database. For usage examples see $ROOTSYS/test/stressLinear.cxx. Acknowledgements. 1. Oleg E. Kiselyov; First implementations were based on the his code . We have diverged; quite a bit since then but the ideas/code for lazy matrix and; ""nested function"" are 100% his .; You can see him and his code in action at http://okmij.org/ftp; 2. Chris R. Birchenhall,; We adapted his idea of the implementation for the decomposition; classes instead of our messy installation of matrix inversion; His installation of matrix condition number, using an iterative; scheme using the Hage algorithm is worth looking at !; Chris has a nice writeup (matdoc.ps) on his matrix classes at; ftp://ftp.mcc.ac.uk/pub/matclass/; 3. Mark Fischler and Steven Haywood of CLHEP; They did the slave labor of spelling out all sub-determinants; for Cramer inversion of (4x4),(5x5) and (6x6) matrices; The stack ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMatrixTBase_double_.html:1988,efficient,efficient,1988,root/html528/TMatrixTBase_double_.html,https://root.cern,https://root.cern/root/html528/TMatrixTBase_double_.html,12,['efficient'],['efficient']
Energy Efficiency,"ch, data member branch, or top-level branch.; which do have a branch count and are not a counter. void ReadLeavesMemberCounter(TBuffer& b); -- Read leaves into i/o buffers for this branch.; For split-class branch, base class branch, data member branch, or top-level branch.; which do not have a branch count and are a counter. void ReadLeavesCustomStreamer(TBuffer& b); -- Read leaves into i/o buffers for this branch.; Non TObject, Non collection classes with a custom streamer. void FillLeavesImpl(TBuffer& b); -- Unconfiguration Fill Leave function. void ReleaseObject(); -- Delete any object we may have allocated on a previous call to SetAddress. void Reset(Option_t* option = """"); Reset a Branch. Existing i/o buffers are deleted.; Entries, max and min are reset. void ResetAfterMerge(TFileMergeInfo* ); Reset a Branch after a Merge operation (drop data but keep customizations). void ResetAddress(); Set branch address to zero and free all allocated memory. void ResetDeleteObject(); -- Release ownership of any allocated objects. Note: This interface was added so that clone trees could; be told they do not own the allocated objects. void SetAddress(void* addobj); -- Point this branch at an object. For a sub-branch, addr is a pointer to the branch object. For a top-level branch the meaning of addr is as follows:. If addr is zero, then we allocate a branch object; internally and the branch is the owner of the allocated; object, not the caller. However the caller may obtain; a pointer to the branch object with GetObject(). Example:. branch->SetAddress(0);; Event* event = branch->GetObject();; ... Do some work. If addr is not zero, but the pointer addr points at is; zero, then we allocate a branch object and set the passed; pointer to point at the allocated object. The caller; owns the allocated object and is responsible for deleting; it when it is no longer needed. Example:. Event* event = 0;; branch->SetAddress(&event);; ... Do some work.; delete event;; event = 0;. If addr is",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TBranchElement.html:30723,allocate,allocated,30723,root/html532/TBranchElement.html,https://root.cern,https://root.cern/root/html532/TBranchElement.html,4,['allocate'],['allocated']
Energy Efficiency,char * TMVA::OptimizeConfigParameters::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 100 of file OptimizeConfigParameters.h. ◆ EstimatorFunction(). Double_t TMVA::OptimizeConfigParameters::EstimatorFunction ; (; std::vector< Double_t > & ; pars). privatevirtual . return the estimator (from current FOM) for the fitting interface ; Implements TMVA::IFitterTarget.; Definition at line 307 of file OptimizeConfigParameters.cxx. ◆ GetBkgEffAtSigEff(). Double_t TMVA::OptimizeConfigParameters::GetBkgEffAtSigEff ; (; Double_t ; sigEff = 0.5). private . calculate the background efficiency for a given signal efficiency ; adapted by marc-.nosp@m.oliv.nosp@m.ier.b.nosp@m.ettl.nosp@m.er@ce.nosp@m.rn.c.nosp@m.h ; Definition at line 546 of file OptimizeConfigParameters.cxx. ◆ GetBkgRejAtSigEff(). Double_t TMVA::OptimizeConfigParameters::GetBkgRejAtSigEff ; (; Double_t ; sigEff = 0.5). private . calculate the background rejection for a given signal efficiency ; adapted by marc-.nosp@m.oliv.nosp@m.ier.b.nosp@m.ettl.nosp@m.er@ce.nosp@m.rn.c.nosp@m.h ; Definition at line 583 of file OptimizeConfigParameters.cxx. ◆ GetFOM(). Double_t TMVA::OptimizeConfigParameters::GetFOM ; (; ). private . Return the Figure of Merit (FOM) used in the parameter optimization process. ; Definition at line 350 of file OptimizeConfigParameters.cxx. ◆ GetMethod(). MethodBase * TMVA::OptimizeConfigParameters::GetMethod ; (; ). inlineprivate . Definition at line 72 of file OptimizeConfigParameters.h. ◆ GetMVADists(). void TMVA::OptimizeConfigParameters::GetMVADists ; (; ). private . fill the private histograms with the mva distributions for sig/bkg ; Definition at line 393 of file OptimizeConfigParameters.cxx. ◆ GetROCIntegral(). Double_t TMVA::OptimizeConfigParameters::GetROCIntegral ; (; ). private . calculate the area (integral) under the ROC curve as a overall quality measure of the classification ; making pdfs out of the MVA-output distribut,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1OptimizeConfigParameters.html:6649,adapt,adapted,6649,doc/master/classTMVA_1_1OptimizeConfigParameters.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1OptimizeConfigParameters.html,1,['adapt'],['adapted']
Energy Efficiency,"char *name) const;  set one parameter to a specific value ;  ; std::vector< std::string > getSamples () const;  return the vector of sample names, used to build the morph func ;  ; RooAbsReal * getSampleWeight (const char *name);  retrieve the weight (prefactor) of a sample with the given name ;  ; double getScale ();  get energy scale of the EFT expansion ;  ; RooProduct * getSumElement (const char *name) const;  return the RooProduct that is the element of the RooRealSumPdfi corresponding to the given sample name ;  ; bool hasParameter (const char *paramname) const;  check if a parameter of the given name is contained in the list of known parameters ;  ; void insert (RooWorkspace *ws);  ; TClass * IsA () const override;  ; bool isBinnedDistribution (const RooArgSet &obs) const override;  check if this PDF is a binned distribution in the given observable ;  ; bool isCouplingUsed (const char *couplname);  check if there is any morphing power provided for the given coupling morphing power is provided as soon as any two samples provide different, non-zero values for this coupling ;  ; bool isParameterConstant (const char *paramname) const;  return true if the parameter with the given name is set constant, false otherwise ;  ; bool isParameterUsed (const char *paramname) const;  check if there is any morphing power provided for the given parameter morphing power is provided as soon as any two samples provide different, non-zero values for this parameter ;  ; int nParameters () const;  return the number of parameters in this morphing function ;  ; int nPolynomials () const;  return the number of samples in this morphing function ;  ; int nSamples () const;  ; std::list< double > * plotSamplingHint (RooAbsRealLValue &, double, double) const override;  retrieve the sample Hint ;  ; void printCouplings () const;  print a set of couplings ;  ; void printEvaluation () const;  print the contributing samples and their respective weights ;  ; void printFlags () const;  print th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooLagrangianMorphFunc.html:9322,power,power,9322,doc/master/classRooLagrangianMorphFunc.html,https://root.cern,https://root.cern/doc/master/classRooLagrangianMorphFunc.html,1,['power'],['power']
Energy Efficiency,"char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static TVirtualPerfStats *& CurrentPerfStats ();  Return the current ROOT perf stats if any. ;  ; static const char * DeclFileName ();  ; static const char * EventType (EEventType type);  Return the name of the event type. ;  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Private Member Functions;  TPerfStats (TList *input, TList *output);  Max resident memory used by this process. ;  ; void SetFile (TFile *) override;  ; void WriteQueryLog ();  Send to the connected monitoring servers information related to this query. ;  . Private Attributes; Long64_t fBytesRead;  histogram of cpu time spent processing packets ;  ; TH2D * fCpuTimeHist;  histogram of real time spent processing packets ;  ; TString fDataSet;  Monitoring engines. ;  ; Int_t fDataSetLen;  Dataset string. ;  ; Int_t fDataSetSize;  Maximum size of the dataset string fDataSet. ;  ; Bool_t fDoHist;  number of active slaves ;  ; Bool_t fDoQuota;  Full tracing in workers. ;  ; Bool_t fDoSlaveTrace;  Trace processing rate in master. ;  ; Bool_t fDoTrace;  Fill histos. ;  ; Bool_t fDoTraceRate;  Trace details in master. ;  ; TDSet * fDSet;  ; TH1D * fEventsHist;  histogram of packets being processed per slave ;  ; TH2D * fLatencyHist;  histogram of slaves per file serving node ;  ; Bool_t fMonitorPerPacket;  Save stats on SQL server for quota management. ;  ; TObjArray fMonSenders;  Whether to send the full entry per each packet. ;  ; TH1D * fNodeHist;  histogram of events p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPerfStats.html:11899,monitor,monitoring,11899,doc/master/classTPerfStats.html,https://root.cern,https://root.cern/doc/master/classTPerfStats.html,1,['monitor'],['monitoring']
Energy Efficiency,"char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. TXMLDocument&operator=(const TXMLDocument&); TXMLDocument(const TXMLDocument&). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. TXMLNode*fRootNodethe root node; _xmlDoc*fXMLDoclibxml xml doc. Class Charts. Inheritance Chart:. TObject. ←; TXMLDocument. Function documentation; TXMLDocument(_xmlDoc* doc); TXMLDocument constructor. ~TXMLDocument(); TXMLDocument destructor.; Free the global variables that may; have been allocated by the parser. TXMLNode * GetRootNode() const; Returns the root element node. const char * Version() const; Returns the XML version string or 0 in case there is no document set. const char * Encoding() const; Returns external initial encoding, if any or 0 in case there is no; document set. const char * URL() const; Returns the URI for the document or 0 in case there is no document set. TXMLDocument(const TXMLDocument& ). TXMLDocument& operator=(const TXMLDocument& ). » Author: Jose Lo 12/4/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/xmlparser:$Id$ » Last generated: 2015-06-02 16:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TXMLDocument.html:6151,allocate,allocated,6151,root/html604/TXMLDocument.html,https://root.cern,https://root.cern/root/html604/TXMLDocument.html,1,['allocate'],['allocated']
Energy Efficiency,"char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. TXMLDocument&operator=(const TXMLDocument&); TXMLDocument(const TXMLDocument&). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. TXMLNode*fRootNodethe root node; _xmlDoc*fXMLDoclibxml xml doc. Class Charts. Inheritance Chart:. TObject. ←; TXMLDocument. Function documentation; TXMLDocument(_xmlDoc* doc); TXMLDocument constructor. ~TXMLDocument(); TXMLDocument destructor.; Free the global variables that may; have been allocated by the parser. TXMLNode * GetRootNode() const; Returns the root element node. const char * Version() const; Returns the XML version string or 0 in case there is no document set. const char * Encoding() const; Returns external initial encoding, if any or 0 in case there is no; document set. const char * URL() const; Returns the URI for the document or 0 in case there is no document set. TXMLDocument(const TXMLDocument& ). TXMLDocument& operator=(const TXMLDocument& ). » Author: Jose Lo 12/4/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/xmlparser:$Id$ » Last generated: 2015-06-30 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TXMLDocument.html:6151,allocate,allocated,6151,root/html602/TXMLDocument.html,https://root.cern,https://root.cern/root/html602/TXMLDocument.html,1,['allocate'],['allocated']
Energy Efficiency,"char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. TGeoHelix(const TGeoHelix&); TGeoHelix&operator=(const TGeoHelix&). Data Members; public:. enum EGeoHelixTypes { kHelixNeedUpdate; kHelixStraigth; kHelixCircle; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. Double_tfB[3]normalized direction for magnetic field; Double_tfCcurvature in XY plane; Double_tfDir[3]direction after a step; Double_tfDirInit[3]normalized initial direction; TGeoHMatrix*fMatrixtransformation of local helix frame to MARS ; Double_tfPhiphi angle; Double_tfPoint[3]point after a step; Double_tfPointInit[3]initial point; Int_tfQright/left-handed (+/- 1) - ""charge""; Double_tfSZ step of the helix / 2*PI; Double_tfStepcurrent step. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoHelix(); Dummy constructor. TGeoHelix(Double_t curvature, Double_t step, Int_t charge = 1); Normal constructor. ~TGeoHelix(); Destructor. Double_t ComputeSafeStep(Double_t epsil = 1E-6) const; Compute safe linear step that can be made such that the error; between linear-helix extrapolation is less than EPSIL. void InitPoint(Double_t x0, Double_t y0, Double_t z0); Initialize coordinates of a point on the helix. void InitPoint(Double_t* point); Set initial point on the helix. void InitDirection(Double_t dirx, Double_t diry, Double_t dirz, Bool_t is_normalized = kTRUE); Initialize particle direction (tangent on the helix in initial point). void InitDirection(Double_t* dir, Bo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoHelix.html:7457,charge,charge,7457,root/html534/TGeoHelix.html,https://root.cern,https://root.cern/root/html534/TGeoHelix.html,1,['charge'],['charge']
Energy Efficiency,"ches = GetListOfBranches();; 3304 Int_t nbranches = branches->GetEntriesFast();; 3305 for (Int_t i = 0; i < nbranches; ++i) {; 3306 TBranch* branch = (TBranch*) branches->UncheckedAt(i);; 3307 if (branch->TestBit(kDoNotProcess)) {; 3308 continue;; 3309 }; 3310 if (undo) {; 3311 TBranch* br = tree->GetBranch(branch->GetName());; 3312 tree->ResetBranchAddress(br);; 3313 } else {; 3314 char* addr = branch->GetAddress();; 3315 if (!addr) {; 3316 if (branch->IsA() == TBranch::Class()) {; 3317 // If the branch was created using a leaflist, the branch itself may not have; 3318 // an address but the leaf might already.; 3319 TLeaf *firstleaf = (TLeaf*)branch->GetListOfLeaves()->At(0);; 3320 if (!firstleaf || firstleaf->GetValuePointer()) {; 3321 // Either there is no leaf (and thus no point in copying the address); 3322 // or the leaf has an address but we can not copy it via the branche; 3323 // this will be copied via the next loop (over the leaf).; 3324 continue;; 3325 }; 3326 }; 3327 // Note: This may cause an object to be allocated.; 3328 branch->SetAddress(nullptr);; 3329 addr = branch->GetAddress();; 3330 }; 3331 TBranch* br = tree->GetBranch(branch->GetFullName());; 3332 if (br) {; 3333 if (br->GetMakeClass() != branch->GetMakeClass()); 3334 br->SetMakeClass(branch->GetMakeClass());; 3335 br->SetAddress(addr);; 3336 // The copy does not own any object allocated by SetAddress().; 3337 if (br->InheritsFrom(TBranchElement::Class())) {; 3338 ((TBranchElement*) br)->ResetDeleteObject();; 3339 }; 3340 } else {; 3341 Warning(""CopyAddresses"", ""Could not find branch named '%s' in tree named '%s'"", branch->GetName(), tree->GetName());; 3342 }; 3343 }; 3344 }; 3345 ; 3346 // Copy branch addresses starting from leaves.; 3347 TObjArray* tleaves = tree->GetListOfLeaves();; 3348 Int_t ntleaves = tleaves->GetEntriesFast();; 3349 std::set<TLeaf*> updatedLeafCount;; 3350 for (Int_t i = 0; i < ntleaves; ++i) {; 3351 TLeaf* tleaf = (TLeaf*) tleaves->UncheckedAt(i);; 3352 TBranch* tbranc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:131785,allocate,allocated,131785,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['allocate'],['allocated']
Energy Efficiency,"chname' as if it was a data member; * protection against array out-of-bounds errors; * ability to use the branch data as an object (when the user code is available). For example with Event.root, if; Double_t somePx = fTracks.fPx[2];; is executed by one of the method of the skeleton,; somePx will updated with the current value of fPx of the 3rd track. Both macrofilename and the optional cutfilename are expected to be; the name of source files which contain at least a free standing; function with the signature:; x_t macrofilename(); // i.e function with the same name as the file; and; y_t cutfilename(); // i.e function with the same name as the file. x_t and y_t needs to be types that can convert respectively to a double; and a bool (because the skeleton uses:; if (cutfilename()) htemp->Fill(macrofilename());. These two functions are run in a context such that the branch names are; available as local variables of the correct (read-only) type. Note that if you use the same 'variable' twice, it is more efficient; to 'cache' the value. For example; Int_t n = fEventNumber; // Read fEventNumber; if (n<10 || n>10) { ... }; is more efficient than; if (fEventNumber<10 || fEventNumber>10). Also, optionally, the generated selector will also call methods named; macrofilename_methodname in each of 6 main selector methods if the method; macrofilename_methodname exist (Where macrofilename is stripped of its; extension). Concretely, with the script named h1analysisProxy.C,. The method calls the method (if it exist); Begin -> void h1analysisProxy_Begin(TTree*);; SlaveBegin -> void h1analysisProxy_SlaveBegin(TTree*);; Notify -> Bool_t h1analysisProxy_Notify();; Process -> Bool_t h1analysisProxy_Process(Long64_t);; SlaveTerminate -> void h1analysisProxy_SlaveTerminate();; Terminate -> void h1analysisProxy_Terminate();. If a file name macrofilename.h (or .hh, .hpp, .hxx, .hPP, .hXX) exist; it is included before the declaration of the proxy class. This can; be used in particular to insur",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTree.html:100985,efficient,efficient,100985,root/html528/TTree.html,https://root.cern,https://root.cern/root/html528/TTree.html,6,['efficient'],['efficient']
Energy Efficiency,"ciated directory; RooAbsDataStore*RooAbsData::_dstoreData storage implementation; TIterator*RooAbsData::_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; map<std::string,RooAbsData*>RooAbsData::_ownedComponentsOwned external components; static char*_poolBegin! Start of memory pool; static char*_poolCur! Next free slot in memory pool; static char*_poolEnd! End of memory pool ; RooArgSetRooAbsData::_varsDimensions of this data set; RooArgSet_varsNoWgtVars without weight variable ; RooRealVar*_wgtVarPointer to weight variable (if set) ; static RooAbsData::StorageTypeRooAbsData::defaultStorageType; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void cleanup(); Clear memoery pool on exit to avoid reported memory leaks. void* operator new(size_t bytes); Overloaded new operator guarantees that all RooDataSets allocated with new; have a unique address, a property that is exploited in several places; in roofit to quickly index contents on normalization set pointers.; The memory pool only allocates space for the class itself. The elements; stored in the set are stored outside the pool. void operator delete(void* ptr); Memory is owned by pool, we need to do nothing to release it. RooDataSet(); Default constructor for persistence. RooDataSet(const char* name, const char* title, const RooArgSet& vars, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); Construct an unbinned dataset from a RooArgSet defining the dimensions of the data space. Optionally, data; can be imported at the time of construction. This constructor takes the following optional arguments. Import(TTree*) -- Import contents of given T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooDataSet.html:18198,allocate,allocated,18198,root/html534/RooDataSet.html,https://root.cern,https://root.cern/root/html534/RooDataSet.html,1,['allocate'],['allocated']
Energy Efficiency,"ciated with each node ;  CRooListProxyRooListProxy is the concrete proxy for RooArgList objects ;  CRooLognormalRooFit Lognormal PDF ;  CRooMapCatEntry;  ►CRooMappedCategory;  CEntry;  CRooMath;  CRooMathCoreReg;  CRooMathMoreReg;  CRooMCIntegratorRooMCIntegrator implements an adaptive multi-dimensional Monte Carlo numerical integration, following the VEGAS algorithm originally described in G ;  CRooMCStudyRooMCStudy is a help class to facilitate Monte Carlo studies such as 'goodness-of-fit' studies, that involve fitting a PDF to multiple toy Monte Carlo sets generated from the same PDF or another PDF ;  CRooMinimizerRooMinimizer is a wrapper class around ROOT::Fit:Fitter that provides a seamless interface between the minimizer functionality and the native RooFit interface ;  CRooMinimizerFcn;  CRooMinuitRooMinuit is a wrapper class around TFitter/TMinuit that provides a seamless interface between the MINUIT functionality and the native RooFit interface ;  CRooMomentRooMoment represents the first, second, or third order derivative of any RooAbsReal as calculated (numerically) by the MathCore Richardson derivator class ;  ►CRooMomentMorph;  CCacheElem;  CRooMPSentinelRooMPSentinel is a singleton class that keeps track of all parellel execution processes for goodness-of-fit calculations ;  ►CRooMsgServiceSingleton class that organizes informational, debugging, warning and errors messages generated by the RooFit core code ;  CStreamConfig;  CRooMultiBinomialRooMultiBinomial is an efficiency function which makes all combinations of efficiencies given as input different efficiency functions for different categories ;  CRooMultiCategoryRooMultiCategory consolidates several RooAbsCategory objects into a single category ;  CRooMultiCatIterRooMultiCatIter iterators over all state permutations of a list of categories ;  CRooMultiGenFunctionLightweight interface adaptor that exports a RooAbsReal as a ROOT::Math::IMultiGenFunction ;  ►CRooMultiVarGaussianMultivariate Gaussian p.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v610/annotated.html:105597,adapt,adaptor,105597,doc/v610/annotated.html,https://root.cern,https://root.cern/doc/v610/annotated.html,1,['adapt'],['adaptor']
Energy Efficiency,"ckPoint(const Float_t* p); voidTAttBBox::BBoxCheckPoint(Float_t x, Float_t y, Float_t z); voidTAttBBox::BBoxClear(); voidTAttBBox::BBoxInit(Float_t infinity = 1e6); voidTAttBBox::BBoxZero(Float_t epsilon = 0, Float_t x = 0, Float_t y = 0, Float_t z = 0); voidCopyIds(const TPointSet3D& t); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Float_t*TAttBBox::fBBox! Dynamic Float_t[6] X(min,max), Y(min,max), Z(min,max); TRefArrayfIdsUser-provided point identifications; Int_tTPolyMarker3D::fLastPointThe index of the last filled point; Color_tTAttMarker::fMarkerColorMarker color index; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; Int_tTPolyMarker3D::fNNumber of allocated points; TStringTPolyMarker3D::fNameName of polymarker; TStringTPolyMarker3D::fOptionOptions; Bool_tfOwnIdsFlag specifying id-objects are owned by the point-set; Float_t*TPolyMarker3D::fP[3*fN] Array of X,Y,Z coordinates. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPointSet3D(const TPointSet3D& t); Copy constructor. ~TPointSet3D(); Destructor. void CopyIds(const TPointSet3D& t); Copy id objects from point-set 't'. TPointSet3D& operator=(const TPointSet3D& t); Assignement operator. void ComputeBBox(); Compute the bounding box of this points set. void SetPointId(TObject* id); Set id of last point.; Use this method if you also use TPolyMarker3D::SetNextPoint(). void SetPointId(Int_t n, TObject* id); Set id of point n. void ClearIds(); Clears the id-array. If ids are owned the TObjects are deleted. void PointSelected(Int_t n); This virtual method is called from TPoin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TPointSet3D.html:8875,allocate,allocated,8875,root/html534/TPointSet3D.html,https://root.cern,https://root.cern/root/html534/TPointSet3D.html,1,['allocate'],['allocated']
Energy Efficiency,"ckground component only.; # The VisualizeError() option can generally applied to _any_ kind of; # plot (components, asymmetries, etc..); model.plotOn(frame, VisualizeError=(r, 1), FillColor=""kOrange"", Components=""bkg""); model.plotOn(; frame,; VisualizeError=(r, 1, False),; DrawOption=""L"",; LineWidth=2,; LineColor=""r"",; Components=""bkg"",; LineStyle=""--"",; ); ; # Overlay central value; model.plotOn(frame); model.plotOn(frame, Components=""bkg"", LineStyle=""--""); d.plotOn(frame); frame.SetMinimum(0); ; # Visualize partial fit error; # ------------------------------------------------------; ; # Make plot frame; frame2 = x.frame(Bins=40, Title=""Visualization of 2-sigma partial error from (m,m2)""); ; # Visualize partial error. For partial error visualization the covariance matrix is first reduced as follows; # ___ -1; # Vred = V22 = V11 - V12 * V22 * V21; #; # Where V11,V12,V21, represent a block decomposition of the covariance matrix into observables that; # are propagated (labeled by index '1') and that are not propagated (labeled by index '2'), V22bar; # is the Shur complement of V22, as shown above; #; # (Note that Vred is _not_ a simple sub-matrix of V); ; # Propagate partial error due to shape parameters (m,m2) using linear and; # sampling method; model.plotOn(frame2, VisualizeError=(r, {m, m2}, 2), FillColor=""c""); model.plotOn(frame2, Components=""bkg"", VisualizeError=(r, {m, m2}, 2), FillColor=""c""); ; model.plotOn(frame2); model.plotOn(frame2, Components=""bkg"", LineStyle=""--""); frame2.SetMinimum(0); ; # Make plot frame; frame3 = x.frame(Bins=40, Title=""Visualization of 2-sigma partial error from (s,s2)""); ; # Propagate partial error due to yield parameter using linear and sampling; # method; model.plotOn(frame3, VisualizeError=(r, {s, s2}, 2), FillColor=""g""); model.plotOn(frame3, Components=""bkg"", VisualizeError=(r, {fsig}, 2), FillColor=""g""); ; model.plotOn(frame3); model.plotOn(frame3, Components=""bkg"", LineStyle=""--""); frame3.SetMinimum(0); ; # Make plot frame; fr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf610__visualerror_8py.html:3760,reduce,reduced,3760,doc/master/rf610__visualerror_8py.html,https://root.cern,https://root.cern/doc/master/rf610__visualerror_8py.html,1,['reduce'],['reduced']
Energy Efficiency,"clFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Member Functions; Double_t ApplyKernelFunction (Double_t normalized_distance);  from the normalized euclidean distance calculate the distance for a certain kernel ;  ; Double_t CKernelEstimate (const Event &, std::vector< const BinarySearchTreeNode * > &, Volume &);  normalization factors so we can work with radius 1 hyperspheres ;  ; const Ranking * CreateRanking ();  ; BinarySearchTree * GetBinaryTree (void) const;  ; void GetHelpMessage () const;  get help message text ;  ; Double_t GetNormalizedDistance (const TMVA::Event &base_event, const BinarySearchTreeNode &sample_event, Double_t *dim_normalization);  We use Euclidian metric here. Might not be best or most efficient. ;  ; Double_t KernelNormalization (Double_t pdf);  Calculating the normalization factor only once (might need a reset at some point. ;  ; Double_t LanczosFilter (Int_t level, Double_t x);  Lanczos Filter. ;  ; void MakeClassSpecific (std::ostream &, const TString &) const;  write specific classifier response ;  ; Double_t NormSinc (Double_t x);  NormSinc. ;  ; void RKernelEstimate (const Event &, std::vector< const BinarySearchTreeNode * > &, Volume &, std::vector< Float_t > *pdfSum);  normalization factors so we can work with radius 1 hyperspheres ;  ;  Protected Member Functions inherited from TMVA::MethodBase; virtual std::vector< Double_t > GetDataMvaValues (DataSet *data=nullptr, Long64_t firstEvt=0, Long64_t lastEvt=-1, Bool_t logProgress=false);  get all the MVA values for the events of the given Data type ;  ; const TString & GetInternalVarName (Int_t ivar) const;  ; virtual std::vector< Double_t > GetMvaValues (Long64_t firstEvt=0, Long64_t lastEvt=-1, Bool_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodPDERS.html:25781,efficient,efficient,25781,doc/master/classTMVA_1_1MethodPDERS.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodPDERS.html,1,['efficient'],['efficient']
Energy Efficiency,"class  RNTupleIndex;  Builds an index on one or several fields of an RNTuple so it can be joined onto other RNTuples. More...;  ; struct  RNTupleMergeData;  ; struct  RNTupleMergeOptions;  ; class  RNTupleMerger;  Given a set of RPageSources merge them into an RPageSink, optionally changing their compression. More...;  ; class  RNTupleModelChangeset;  The incremental changes to a RNTupleModel More...;  ; class  RNTupleSerializer;  A helper class for serializing and deserialization of the RNTuple binary format. More...;  ; class  RNTupleWriteOptionsManip;  ; class  ROnDiskPage;  A page as being stored on disk, that is packed and compressed. More...;  ; class  ROnDiskPageMap;  A memory region that contains packed and compressed pages. More...;  ; class  ROnDiskPageMapHeap;  An ROnDiskPageMap that is used for an fMemory allocated as an array of unsigned char. More...;  ; class  RPage;  A page is a slice of a column that is mapped into memory. More...;  ; class  RPageAllocator;  Abstract interface to allocate and release pages. More...;  ; class  RPageAllocatorHeap;  Uses standard C++ memory allocation for the column data pages. More...;  ; class  RPageNullSink;  Dummy sink that discards all pages. More...;  ; class  RPagePersistentSink;  Base class for a sink with a physical storage backend. More...;  ; class  RPagePool;  A thread-safe cache of pages loaded from the page source. More...;  ; class  RPageRef;  Reference to a page stored in the page pool. More...;  ; class  RPageSink;  Abstract interface to write data into an ntuple. More...;  ; class  RPageSinkBuf;  Wrapper sink that coalesces cluster column page writes. More...;  ; class  RPageSinkDaos;  Storage provider that writes ntuple pages to into a DAOS container. More...;  ; class  RPageSinkFile;  Storage provider that write ntuple pages into a file. More...;  ; class  RPageSource;  Abstract interface to read data from an ntuple. More...;  ; class  RPageSourceDaos;  Storage provider that reads ntuple pages from ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1Experimental_1_1Internal.html:7827,allocate,allocate,7827,doc/master/namespaceROOT_1_1Experimental_1_1Internal.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1Experimental_1_1Internal.html,1,['allocate'],['allocate']
Energy Efficiency,"class.; The class must have a default constructor. For meaning of; defConstructor, see TClass::IsCallingNew(). If quiet is true, do no issue a message via Error on case; of problems, just return 0. The constructor actually called here can be customized by; using the rootcint pragma:; #pragma link C++ ioctortype UserClass;; For example, with this pragma and a class named MyClass,; this method will called the first of the following 3; constructors which exists and is public:; MyClass(UserClass*);; MyClass(TRootIOCtor*);; MyClass(); // Or a constructor with all its arguments defaulted. When more than one pragma ioctortype is used, the first seen as priority; For example with:; #pragma link C++ ioctortype UserClass1;; #pragma link C++ ioctortype UserClass2;; We look in the following order:; MyClass(UserClass1*);; MyClass(UserClass2*);; MyClass(TRootIOCtor*);; MyClass(); // Or a constructor with all its arguments defaulted. void * New(void* arena, TClass::ENewType defConstructor = kClassNew) const; Return a pointer to a newly allocated object of this class.; The class must have a default constructor. For meaning of; defConstructor, see TClass::IsCallingNew(). void * NewArray(Long_t nElements, TClass::ENewType defConstructor = kClassNew) const; Return a pointer to a newly allocated array of objects; of this class.; The class must have a default constructor. For meaning of; defConstructor, see TClass::IsCallingNew(). void * NewArray(Long_t nElements, void* arena, TClass::ENewType defConstructor = kClassNew) const; Return a pointer to a newly allocated object of this class.; The class must have a default constructor. For meaning of; defConstructor, see TClass::IsCallingNew(). void Destructor(void* obj, Bool_t dtorOnly = kFALSE); Explicitly call destructor for object. void DeleteArray(void* ary, Bool_t dtorOnly = kFALSE); Explicitly call operator delete[] for an array. void SetCanSplit(Int_t splitmode); Set the splitability of this class:; -1: Use the default calculation; 0:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TClass.html:49821,allocate,allocated,49821,root/html602/TClass.html,https://root.cern,https://root.cern/root/html602/TClass.html,2,['allocate'],['allocated']
Energy Efficiency,"cle name; mcType VMC Particle type; mass mass [GeV]; charge charge [eplus]; lifetime time of life [s]; pType particle type as in Geant4; width width [GeV]; iSpin spin; iParity parity; iConjugation conjugation; iIsospin isospin; iIsospinZ isospin - #rd component; gParity gParity; lepton lepton number; baryon baryon number; stable stability; shortlived is shorlived?; subType particle subType as in Geant4; antiEncoding anti encoding; magMoment magnetic moment; excitation excitation energy [GeV]. Bool_t DefineIon(const char* name, Int_t Z, Int_t A, Int_t Q, Double_t excEnergy, Double_t mass = 0.); Set a user defined particle; Function is ignored if particle with specified pdg; already exists and error report is printed.; pdg PDG encoding; name particle name; mcType VMC Particle type; mass mass [GeV]; charge charge [eplus]; lifetime time of life [s]; pType particle type as in Geant4; width width [GeV]; iSpin spin; iParity parity; iConjugation conjugation; iIsospin isospin; iIsospinZ isospin - #rd component; gParity gParity; lepton lepton number; baryon baryon number; stable stability; shortlived is shorlived?; subType particle subType as in Geant4; antiEncoding anti encoding; magMoment magnetic moment; excitation excitation energy [GeV]; Set a user defined ion.; name ion name; Z atomic number; A atomic mass; Q charge [eplus}; excitation excitation energy [GeV]; mass mass [GeV] (if not specified by user, approximative; mass is calculated). Double_t Xsec(char* , Double_t , Int_t , Int_t ); Set a user phase space decay for a particle; pdg particle PDG encoding; bratios the array with branching ratios (in %); mode[6][3] the array with daughters particles PDG codes for each; decay channel; Calculate X-sections; (Geant3 only). Int_t IdFromPDG(Int_t pdg) const. particle table usage. Return MC specific code from a PDG and pseudo ENDF code (pdg). Int_t PDGFromId(Int_t id) const; Return PDG code and pseudo ENDF code from MC specific code (id). TString ParticleName(Int_t pdg) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualMC.html:29147,charge,charge,29147,root/html528/TVirtualMC.html,https://root.cern,https://root.cern/root/html528/TVirtualMC.html,3,"['charge', 'energy']","['charge', 'energy']"
Energy Efficiency,"cle name; mcType VMC Particle type; mass mass [GeV]; charge charge [eplus]; lifetime time of life [s]; pType particle type as in Geant4; width width [GeV]; iSpin spin; iParity parity; iConjugation conjugation; iIsospin isospin; iIsospinZ isospin - #rd component; gParity gParity; lepton lepton number; baryon baryon number; stable stability; shortlived is shorlived?; subType particle subType as in Geant4; antiEncoding anti encoding; magMoment magnetic moment; excitation excitation energy [GeV]. Bool_t DefineIon(const char* name, Int_t Z, Int_t A, Int_t Q, Double_t excEnergy, Double_t mass = 0.); Set a user defined particle; Function is ignored if particle with specified pdg; already exists and error report is printed.; pdg PDG encoding; name particle name; mcType VMC Particle type; mass mass [GeV]; charge charge [eplus]; lifetime time of life [s]; pType particle type as in Geant4; width width [GeV]; iSpin spin; iParity parity; iConjugation conjugation; iIsospin isospin; iIsospinZ isospin - #rd component; gParity gParity; lepton lepton number; baryon baryon number; stable stability; shortlived is shorlived?; subType particle subType as in Geant4; antiEncoding anti encoding; magMoment magnetic moment; excitation excitation energy [GeV]; Set a user defined ion.; name ion name; Z atomic number; A atomic mass; Q charge [eplus}; excitation excitation energy [GeV]; mass mass [GeV] (if not specified by user, approximative; mass is calculated). Double_t Xsec(char* , Double_t , Int_t , Int_t ); Set a user phase space decay for a particle; pdg particle PDG encoding; bratios the array with branching ratios (in %); mode[6][3] the array with daughters particles PDG codes for each; decay channel; Calculate X-sections; (Geant3 only); Deprecated. Int_t IdFromPDG(Int_t pdg) const. particle table usage. Return MC specific code from a PDG and pseudo ENDF code (pdg). Int_t PDGFromId(Int_t id) const; Return PDG code and pseudo ENDF code from MC specific code (id). TString ParticleName(Int_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TVirtualMC.html:28816,charge,charge,28816,root/html530/TVirtualMC.html,https://root.cern,https://root.cern/root/html530/TVirtualMC.html,15,"['charge', 'energy']","['charge', 'energy']"
Energy Efficiency,"cle; static properties. Return the PDG of the particle transported. Double_t TrackCharge() const; Return the charge of the track currently transported. Double_t TrackMass() const; Return the mass of the track currently transported. Double_t Etot() const; Return the total energy of the current track. Bool_t IsNewTrack() const. get methods - track status. Return true when the track performs the first step. Bool_t IsTrackInside() const; Return true if the track is not at the boundary of the current volume. Bool_t IsTrackEntering() const; Return true if this is the first step of the track in the current volume. Bool_t IsTrackExiting() const; Return true if this is the last step of the track in the current volume. Bool_t IsTrackOut() const; Return true if the track is out of the setup. Bool_t IsTrackDisappeared() const; Return true if the current particle has disappeared; either because it decayed or because it underwent; an inelastic collision. Bool_t IsTrackStop() const; Return true if the track energy has fallen below the threshold. Bool_t IsTrackAlive() const; Return true if the current particle is alive and will continue to be; transported. Int_t NSecondaries() const. get methods - secondaries. Return the number of secondary particles generated in the current step. void GetSecondary(Int_t isec, Int_t& particleId, TLorentzVector& position, TLorentzVector& momentum); Return the parameters of the secondary track number isec produced; in the current step. Int_t StepProcesses(TArrayI& proc) const; Return the VMC code of the process that has produced the secondary; particles in the current step; Return the array of the VMC code of the processes active in the current; step. Bool_t SecondariesAreOrdered() const; Return the information about the transport order needed by the stack. void Gdopt(const char* , const char* ). Geant3 specific methods; !!! to be removed with move to TGeo. Set/modify the drawing options.; Deprecated - G3 only. void SetClipBox(const char* , Double_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualMC.html:35494,energy,energy,35494,root/html528/TVirtualMC.html,https://root.cern,https://root.cern/root/html528/TVirtualMC.html,1,['energy'],['energy']
Energy Efficiency,"cle; static properties. Return the PDG of the particle transported. Double_t TrackCharge() const; Return the charge of the track currently transported. Double_t TrackMass() const; Return the mass of the track currently transported. Double_t Etot() const; Return the total energy of the current track. Bool_t IsNewTrack() const. get methods - track status. Return true when the track performs the first step. Bool_t IsTrackInside() const; Return true if the track is not at the boundary of the current volume. Bool_t IsTrackEntering() const; Return true if this is the first step of the track in the current volume. Bool_t IsTrackExiting() const; Return true if this is the last step of the track in the current volume. Bool_t IsTrackOut() const; Return true if the track is out of the setup. Bool_t IsTrackDisappeared() const; Return true if the current particle has disappeared; either because it decayed or because it underwent; an inelastic collision. Bool_t IsTrackStop() const; Return true if the track energy has fallen below the threshold. Bool_t IsTrackAlive() const; Return true if the current particle is alive and will continue to be; transported. Int_t NSecondaries() const. get methods - secondaries. Return the number of secondary particles generated in the current step. void GetSecondary(Int_t isec, Int_t& particleId, TLorentzVector& position, TLorentzVector& momentum); Return the parameters of the secondary track number isec produced; in the current step. Int_t StepProcesses(TArrayI& proc) const; Return the VMC code of the process that has produced the secondary; particles in the current step; Return the array of the VMC code of the processes active in the current; step. Bool_t SecondariesAreOrdered() const; Return the information about the transport order needed by the stack. void Init(). Control methods. Initialize MC. void BuildPhysics(); Initialize MC physics. void ProcessEvent(); Process one event; Deprecated. Bool_t ProcessRun(Int_t nevent); Process one run and re",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TVirtualMC.html:35175,energy,energy,35175,root/html530/TVirtualMC.html,https://root.cern,https://root.cern/root/html530/TVirtualMC.html,5,['energy'],['energy']
Energy Efficiency,"clone (identical) objects. Memory for the objects; stored in the array is allocated only once in the lifetime of the; clones array. All objects must be of the same class. For the rest; this class has the same properties as TObjArray. To reduce the very large number of new and delete calls in large; loops like this (O(100000) x O(10000) times new/delete):. TObjArray a(10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000) events; for (int i = 0; i < ev->Ntracks; i++) { // O(10000) tracks; a[i] = new TTrack(x,y,z,...);. }. a.Delete();; }. One better uses a TClonesArray which reduces the number of; new/delete calls to only O(10000):. TClonesArray a(""TTrack"", 10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000) events; for (int i = 0; i < ev->Ntracks; i++) { // O(10000) tracks; new(a[i]) TTrack(x,y,z,...);. }. a.Delete(); // or a.Clear() or a.Clear(""C""); }. To reduce the number of call to the constructor (especially useful; if the user class requires memory allocation), the object can be; added (and constructed when needed) using ConstructedAt which only; calls the constructor once per slot. TClonesArray a(""TTrack"", 10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000) events; for (int i = 0; i < ev->Ntracks; i++) { // O(10000) tracks; TTrack *track = (TTrack*)a.ConstructedAt(i);; track->Set(x,y,z,....);. }. a.Clear(); // or a.Clear(""C"");; }. Note: the only supported way to add objects to a TClonesArray is; via the new with placement method or the ConstructedAt method.; The other Add() methods ofTObjArray and its base classes are not; allowed. Considering that a new/delete costs about 70 mus on a 300 MHz HP,; O(10^9) new/deletes will save about 19 hours. NOTE 1. C/C++ offers the possibility of allocating and deleting memory.; Forgetting to delete allocated memory is a programming error called a; ""memory leak"", i.e. the memory of your process grows and eventually; your program crashes. Even if you *always* delete the allocated; memory, the recovere",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TClonesArray.html:1196,reduce,reduce,1196,root/html532/TClonesArray.html,https://root.cern,https://root.cern/root/html532/TClonesArray.html,4,['reduce'],['reduce']
Energy Efficiency,"clude <TMatrixTSparse.h>. Inheritance diagram for TMatrixTSparse< Element >:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Enumeration Documentation. ◆ EMatrixCreatorsOp1. template<class Element > . enum TMatrixTSparse::EMatrixCreatorsOp1. EnumeratorkZero ; kUnit ; kTransposed ; kAtA . Definition at line 80 of file TMatrixTSparse.h. ◆ EMatrixCreatorsOp2. template<class Element > . enum TMatrixTSparse::EMatrixCreatorsOp2. EnumeratorkMult ; kMultTranspose ; kPlus ; kMinus . Definition at line 81 of file TMatrixTSparse.h. Constructor & Destructor Documentation. ◆ TMatrixTSparse() [1/11]. template<class Element > . TMatrixTSparse< Element >::TMatrixTSparse ; (; ). inline . Definition at line 83 of file TMatrixTSparse.h. ◆ TMatrixTSparse() [2/11]. template<class Element > . TMatrixTSparse< Element >::TMatrixTSparse ; (; Int_t ; nrows, . Int_t ; ncols . ). Space is allocated for row/column indices and data, but the sparse structure information has still to be set ! ; Definition at line 107 of file TMatrixTSparse.cxx. ◆ TMatrixTSparse() [3/11]. template<class Element > . TMatrixTSparse< Element >::TMatrixTSparse ; (; Int_t ; row_lwb, . Int_t ; row_upb, . Int_t ; col_lwb, . Int_t ; col_upb, . Int_t ; nr_nonzeros = 0 . ). Space is allocated for row/column indices and data, but the sparse structure information has still to be set ! ; Definition at line 117 of file TMatrixTSparse.cxx. ◆ TMatrixTSparse() [4/11]. template<class Element > . TMatrixTSparse< Element >::TMatrixTSparse ; (; Int_t ; row_lwb, . Int_t ; row_upb, . Int_t ; col_lwb, . Int_t ; col_upb, . Int_t ; nr, . Int_t * ; row, . Int_t * ; col, . Element * ; data . ). Space is allocated for row/column indices and data. ; Sparse row/column index structure together with data is coming from the arrays, row, col and data, resp. Here row, col and data are arrays of length nr (number of nonzero elements), i.e. the matrix is stored in COO (coordinate) format. Note tha",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMatrixTSparse.html:28985,allocate,allocated,28985,doc/master/classTMatrixTSparse.html,https://root.cern,https://root.cern/doc/master/classTMatrixTSparse.html,1,['allocate'],['allocated']
Energy Efficiency,"color index cid. ;  ; void * GetGC (Int_t which) const;  Return desired Graphics Context (""which"" maps directly on gGCList[]). ;  ; void QueryColors (Colormap cmap, RXColor *colors, Int_t ncolors);  Returns the current RGB value for the pixel in the XColor structure. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Attributes inherited from TGX11; ULong_t fBlackPixel;  Value of black pixel in colormap. ;  ; Int_t fBlueDiv;  Blue value divider. ;  ; Int_t fBlueShift;  Bits to left shift blue. ;  ; Float_t fCharacterUpX;  Character Up vector along X. ;  ; Float_t fCharacterUpY;  Character Up vector along Y. ;  ; Colormap fColormap;  Default colormap, 0 if b/w. ;  ; Int_t fDepth;  Number of color planes. ;  ; void * fDisplay;  Pointer to display. ;  ; Int_t fGreenDiv;  Green value divider. ;  ; Int_t fGreenShift;  Bits to left shift green. ;  ; Bool_t fHasTTFonts;  True when TrueType fonts are used. ;  ; Bool_t fHasXft;  True when XftFonts are used. ;  ; Int_t fRedDiv;  Red value divider, -1 if no TrueColor visual. ;  ; Int_t fRedShift;  Bits to left shift red, -1 if no TrueColor visual. ;  ; Drawable fRootWin;  Root window used as parent of all windows. ;  ; Int_t fScreenNumber;  Screen number. ;  ; Int_t fTextAlign;  Text alignment (set in SetTextAlign) ;  ; Int_t fTextAlignH;  Text Alignment Horizontal. ;  ; Int_t fTextAlignV;  Text Alignment Vertical. ;  ; Float_t fTextMagnitude;  Text Magnitude. ;  ; Drawable fVisRootWin;  Root window with fVisual to be used to create GC's and XImages. ;  ; RVisual * fVisual;  Pointer to visual used by all windows. ;  ; ULong_t fWhitePixel;  Value of white pixel in colormap. ;  ;  Protected Attributes inherited from TVirtualX; EDrawMode fDrawMode;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Protected Attributes inhe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGX11TTF.html:49322,green,green,49322,doc/master/classTGX11TTF.html,https://root.cern,https://root.cern/doc/master/classTGX11TTF.html,1,['green'],['green']
Energy Efficiency,"color nodes; TStructViewerGUI*fGUIPointer to GUI class; TObjArrayfLevelArrayArray with pointers to nodes on each level; TExMapfLevelMembersCountContains number of objects on each level; TExMapfLevelSizeContains total size in bytes of a level; void*fPointerMain pointer to represented object; TClass*fPointerClassTClass of a main pointer; TExMapfPointersMap of pointer to avoid circulation; TStructNode*fTopNodeMaster node for fPointer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TStructViewer(void* ptr = NULL, const char* clname = NULL); Default constructor. An argument ""ptr"" is a main pointer of type ""clname"", which should be shown in the viewer. ~TStructViewer(); Destructor. Clean all object after closing the viewer. void AddNode(TStructNode* node, ULong_t size); Find list with nodes on specified level and add node to this list and increment list of sizes and list of members. void CountMembers(TClass* cl, TStructNode* parent, void* pointer); Count allocated memory, increase member counters, find child nodes. void Draw(Option_t* option = """"); Draw object if there is valid pointer. TCanvas* GetCanvas(); Returns canvas used to keep TGeoVolumes. TGMainFrame* GetFrame(); Returns pointer to main window. void* GetPointer() const; Return main pointer. TExMap GetLevelMembersCount() const; Returns TExMap with pairs <level number, number of objects>. TExMap GetLevelSize() const; Returns TExMap with pairs <level number, size of level in bytes>. Bool_t GetLinksVisibility() const; Get visibility of links between objects. void Prepare(); Create top node and find all member nodes. void Reset(); Deleting nodes, maps and array. void SetColor(TString name, Int_t color); Sets color for the class ""name"" to color ""color"". void SetLinksVisibility(Bool_t val); ISets links visibility. void SetPointer(void* ptr, const char* clname = NULL); Set main pointer of class ""clname"". TColor GetColor(const char* typeName); Returns color associated with type ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TStructViewer.html:7868,allocate,allocated,7868,root/html530/TStructViewer.html,https://root.cern,https://root.cern/root/html530/TStructViewer.html,3,['allocate'],['allocated']
Energy Efficiency,"color number; in colors[N], etc. If the maximum cell content is greater than; ncolors, all cell contents are scaled to ncolors.; If ncolors <= 0, a default palette (see below) of 50 colors is; defined. This palette is recommended for pads, labels ...; If ncolors == 1 && colors == 0, a pretty palette with a violet to; red spectrum is created. It is recommended you use this palette when drawing; legos, surfaces or contours.; If ncolors > 50 and colors=0, the DeepSea palette is used.; (see TColor::CreateGradientColorTable for more details); If ncolors > 0 && colors == 0, the default palette is used; with a maximum of ncolors.; The default palette defines:. index 0 to 9 : shades of grey; index 10 to 19 : shades of brown; index 20 to 29 : shades of blue; index 30 to 39 : shades of red; index 40 to 49 : basic colors. The color numbers specified in the palette can be viewed by selecting; the item ""colors"" in the ""VIEW"" menu of the canvas tool bar.; The red, green, and blue components of a color can be changed thanks to; TColor::SetRGB().; Drawing a sub-range of a 2D histogram; the [cutg] option; Using a TCutG object, it is possible to draw a sub-range of a 2D; histogram. One must create a graphical cut (mouse or C++) and specify the name; of the cut between [] in the Draw() option.; For example, with a TCutG named ""cutg"", one can call:. myhist->Draw(""surf1 [cutg]"");. To invert the cut, it is enough to put a ""-"" in front of its name:. myhist->Draw(""surf1 [-cutg]"");. It is possible to apply several cuts ("","" means logical AND):. myhist->Draw(""surf1 [cutg1,cutg2]"");. Picture; Source. #include ""TF2.h""; #include ""TH2.h""; #include ""TCutG.h""; #include ""TMath.h"". //+ Fitting a 2-D histogram (a variant); // This tutorial illustrates :; // - how to create a 2-d function; // - fill a 2-d histogram randomly from this function; // - fit the histogram; // - display the fitted function on top of the histogram (lego-plot); // using a surface plot in a sub-range of the histogram.; //; // T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/THistPainter.html:60258,green,green,60258,root/html528/THistPainter.html,https://root.cern,https://root.cern/root/html528/THistPainter.html,3,['green'],['green']
Energy Efficiency,"colors; 58 */; 59 ; 60 colors = (Color *) calloc(28+4, sizeof (Color));; 61 if(!colors) {; 62 puts (""Unable to allocate memory for colors !"");; 63 ret = 0;; 64 }; 65 else {; 66 colors[ 0].red = 92; colors[ 0].green = 92; colors[0].blue = 92;; 67 colors[ 1].red = 122; colors[ 1].green = 122; colors[1].blue = 122;; 68 colors[ 2].red = 184; colors[ 2].green = 184; colors[2].blue = 184;; 69 colors[ 3].red = 215; colors[ 3].green = 215; colors[3].blue = 215;; 70 colors[ 4].red = 138; colors[ 4].green = 15; colors[4].blue = 15;; 71 colors[ 5].red = 184; colors[ 5].green = 20; colors[5].blue = 20;; 72 colors[ 6].red = 235; colors[ 6].green = 71; colors[6].blue = 71;; 73 colors[ 7].red = 240; colors[ 7].green = 117; colors[7].blue = 117;; 74 colors[ 8].red = 15; colors[ 8].green = 138; colors[8].blue = 15;; 75 colors[ 9].red = 20; colors[ 9].green = 184; colors[9].blue = 20;; 76 colors[10].red = 71; colors[10].green = 235; colors[10].blue = 71;; 77 colors[11].red = 117; colors[11].green = 240; colors[11].blue = 117;; 78 colors[12].red = 15; colors[12].green = 15; colors[12].blue = 138;; 79 colors[13].red = 20; colors[13].green = 20; colors[13].blue = 184;; 80 colors[14].red = 71; colors[14].green = 71; colors[14].blue = 235;; 81 colors[15].red = 117; colors[15].green = 117; colors[15].blue = 240;; 82 colors[16].red = 138; colors[16].green = 138; colors[16].blue = 15;; 83 colors[17].red = 184; colors[17].green = 184; colors[17].blue = 20;; 84 colors[18].red = 235; colors[18].green = 235; colors[18].blue = 71;; 85 colors[19].red = 240; colors[19].green = 240; colors[19].blue = 117;; 86 colors[20].red = 138; colors[20].green = 15; colors[20].blue = 138;; 87 colors[21].red = 184; colors[21].green = 20; colors[21].blue = 184;; 88 colors[22].red = 235; colors[22].green = 71; colors[22].blue = 235;; 89 colors[23].red = 240; colors[23].green = 117; colors[23].blue = 240;; 90 colors[24].red = 15; colors[24].green = 138; colors[24].blue = 138;; 91 colors[25].red = 20; colors[25].gree",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/X3DBuffer_8c_source.html:2472,green,green,2472,doc/master/X3DBuffer_8c_source.html,https://root.cern,https://root.cern/doc/master/X3DBuffer_8c_source.html,1,['green'],['green']
Energy Efficiency,"colors[27].red = 117; colors[27].green = 240; colors[27].blue = 240;; 94 }; 95 ; 96 ; 97 /*; 98 * Allocate memory for segments; 99 */; 100 ; 101 if (gSize3D.numSegs) {; 102 segs = (segment *) calloc (gSize3D.numSegs, sizeof (segment));; 103 if (!segs) {; 104 puts (""Unable to allocate memory for segments !"");; 105 ret = 0;; 106 }; 107 }; 108 ; 109 ; 110 /*; 111 * Allocate memory for polygons; 112 */; 113 ; 114 if (gSize3D.numPolys) {; 115 polys = (polygon *) calloc(gSize3D.numPolys, sizeof (polygon));; 116 if (!polys) {; 117 puts (""Unable to allocate memory for polygons !"");; 118 ret = 0;; 119 }; 120 }; 121 ; 122 /*; 123 * In case of error, free allocated memory; 124 */; 125 ; 126 ; 127 if (!ret) {; 128 if (points) free (points);; 129 if (colors) free (colors);; 130 if (segs) free (segs);; 131 if (polys) free (polys);; 132 ; 133 points = NULL;; 134 colors = NULL;; 135 segs = NULL;; 136 polys = NULL;; 137 }; 138 ; 139 return (ret);; 140}; 141 ; 142void FillX3DBuffer (X3DBuffer *buff); 143{; 144/******************************************************************************; 145 Read points, Read segments & Read polygons; 146******************************************************************************/; 147 ; 148 ; 149 int n, i, j, p, q, c;; 150 int oldNumOfPoints, oldNumOfSegments;; 151 ; 152 if (buff) {; 153 ; 154 oldNumOfPoints = currPoint;; 155 oldNumOfSegments = currSeg;; 156 ; 157 /*; 158 * Read points; 159 */; 160 ; 161 for (i = 0; i < buff->numPoints; i++, currPoint++) {; 162 points[currPoint].x = buff->points[3*i ];; 163 points[currPoint].y = buff->points[3*i+1];; 164 points[currPoint].z = buff->points[3*i+2];; 165 }; 166 ; 167 ; 168 /*; 169 * Read segments; 170 */; 171 ; 172 for (i = 0; i < buff->numSegs; i++, currSeg++) {; 173 c = buff->segs[3*i];; 174 p = oldNumOfPoints + buff->segs[3*i+1];; 175 q = oldNumOfPoints + buff->segs[3*i+2];; 176 ; 177 segs[currSeg].color = &(colors[c]);; 178 segs[currSeg].P = &(points[p]);; 179 segs[currSeg].Q = &(points[q]);; 180",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/X3DBuffer_8c_source.html:4139,allocate,allocate,4139,doc/master/X3DBuffer_8c_source.html,https://root.cern,https://root.cern/doc/master/X3DBuffer_8c_source.html,2,['allocate'],"['allocate', 'allocated']"
Energy Efficiency,"colors[6].blue = 71;; 73 colors[ 7].red = 240; colors[ 7].green = 117; colors[7].blue = 117;; 74 colors[ 8].red = 15; colors[ 8].green = 138; colors[8].blue = 15;; 75 colors[ 9].red = 20; colors[ 9].green = 184; colors[9].blue = 20;; 76 colors[10].red = 71; colors[10].green = 235; colors[10].blue = 71;; 77 colors[11].red = 117; colors[11].green = 240; colors[11].blue = 117;; 78 colors[12].red = 15; colors[12].green = 15; colors[12].blue = 138;; 79 colors[13].red = 20; colors[13].green = 20; colors[13].blue = 184;; 80 colors[14].red = 71; colors[14].green = 71; colors[14].blue = 235;; 81 colors[15].red = 117; colors[15].green = 117; colors[15].blue = 240;; 82 colors[16].red = 138; colors[16].green = 138; colors[16].blue = 15;; 83 colors[17].red = 184; colors[17].green = 184; colors[17].blue = 20;; 84 colors[18].red = 235; colors[18].green = 235; colors[18].blue = 71;; 85 colors[19].red = 240; colors[19].green = 240; colors[19].blue = 117;; 86 colors[20].red = 138; colors[20].green = 15; colors[20].blue = 138;; 87 colors[21].red = 184; colors[21].green = 20; colors[21].blue = 184;; 88 colors[22].red = 235; colors[22].green = 71; colors[22].blue = 235;; 89 colors[23].red = 240; colors[23].green = 117; colors[23].blue = 240;; 90 colors[24].red = 15; colors[24].green = 138; colors[24].blue = 138;; 91 colors[25].red = 20; colors[25].green = 184; colors[25].blue = 184;; 92 colors[26].red = 71; colors[26].green = 235; colors[26].blue = 235;; 93 colors[27].red = 117; colors[27].green = 240; colors[27].blue = 240;; 94 }; 95 ; 96 ; 97 /*; 98 * Allocate memory for segments; 99 */; 100 ; 101 if (gSize3D.numSegs) {; 102 segs = (segment *) calloc (gSize3D.numSegs, sizeof (segment));; 103 if (!segs) {; 104 puts (""Unable to allocate memory for segments !"");; 105 ret = 0;; 106 }; 107 }; 108 ; 109 ; 110 /*; 111 * Allocate memory for polygons; 112 */; 113 ; 114 if (gSize3D.numPolys) {; 115 polys = (polygon *) calloc(gSize3D.numPolys, sizeof (polygon));; 116 if (!polys) {; 117 puts (""Una",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/X3DBuffer_8c_source.html:3120,green,green,3120,doc/master/X3DBuffer_8c_source.html,https://root.cern,https://root.cern/doc/master/X3DBuffer_8c_source.html,1,['green'],['green']
Energy Efficiency,"conf); ; # Point RDataFrame calls to the Spark specific RDataFrame; RDataFrame = ROOT.RDF.Experimental.Distributed.Spark.RDataFrame; ; # The Spark RDataFrame constructor accepts an optional ""sparkcontext"" parameter; # and it will distribute the application to the connected cluster; df = RDataFrame(""mytree"", ""myfile.root"", sparkcontext = sc); If an instance of SparkContext is not provided, the default behaviour is to create one in the background for you. Connecting to a Dask cluster; Similarly, you can connect to a Dask cluster by creating your own connection object which internally operates with one of the cluster schedulers supported by Dask (more information in the Dask distributed docs):; import ROOT; from dask.distributed import Client; ; # Point RDataFrame calls to the Dask specific RDataFrame; RDataFrame = ROOT.RDF.Experimental.Distributed.Dask.RDataFrame; ; # In a Python script the Dask client needs to be initalized in a context; # Jupyter notebooks / Python session don't need this; if __name__ == ""__main__"":; # With an already setup cluster that exposes a Dask scheduler endpoint; client = Client(""dask_scheduler.domain.com:8786""); ; # The Dask RDataFrame constructor accepts the Dask Client object as an optional argument; df = RDataFrame(""mytree"",""myfile.root"", daskclient=client); # Proceed as usual; df.Define(""x"",""someoperation"").Histo1D((""name"", ""title"", 10, 0, 10), ""x""); If an instance of distributed.Client is not provided to the RDataFrame object, it will be created for you and it will run the computations in the local machine using all cores available. Choosing the number of distributed tasks; A distributed RDataFrame has internal logic to define in how many chunks the input dataset will be split before sending tasks to the distributed backend. Each task reads and processes one of said chunks. The logic is backend-dependent, but generically tries to infer how many cores are available in the cluster through the connection object. The number of tasks will b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html:37914,schedul,scheduler,37914,doc/v632/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html,2,['schedul'],['scheduler']
Energy Efficiency,"const ColumnNames_t &branches,; 343 std::shared_ptr<RNodeBase> *upcastNodeOnHeap, bool isSingleColumn);; 344 ; 345std::string JitBuildAction(const ColumnNames_t &bl, std::shared_ptr<RDFDetail::RNodeBase> *prevNode,; 346 const std::type_info &art, const std::type_info &at, void *rOnHeap, TTree *tree,; 347 const unsigned int nSlots, const RColumnRegister &colRegister, RDataSource *ds,; 348 std::weak_ptr<RJittedAction> *jittedActionOnHeap, const bool vector2RVec = true);; 349 ; 350// Allocate a weak_ptr on the heap, return a pointer to it. The user is responsible for deleting this weak_ptr.; 351// This function is meant to be used by RInterface's methods that book code for jitting.; 352// The problem it solves is that we generate code to be lazily jitted with the addresses of certain objects in them,; 353// and we need to check those objects are still alive when the generated code is finally jitted and executed.; 354// So we pass addresses to weak_ptrs allocated on the heap to the jitted code, which is then responsible for; 355// the deletion of the weak_ptr object.; 356template <typename T>; 357std::weak_ptr<T> *MakeWeakOnHeap(const std::shared_ptr<T> &shPtr); 358{; 359 return new std::weak_ptr<T>(shPtr);; 360}; 361 ; 362// Same as MakeWeakOnHeap, but create a shared_ptr that makes sure the object is definitely kept alive.; 363template <typename T>; 364std::shared_ptr<T> *MakeSharedOnHeap(const std::shared_ptr<T> &shPtr); 365{; 366 return new std::shared_ptr<T>(shPtr);; 367}; 368 ; 369bool AtLeastOneEmptyString(const std::vector<std::string_view> strings);; 370 ; 371/// Take a shared_ptr<AnyNodeType> and return a shared_ptr<RNodeBase>.; 372/// This works for RLoopManager nodes as well as filters and ranges.; 373std::shared_ptr<RNodeBase> UpcastNode(std::shared_ptr<RNodeBase> ptr);; 374 ; 375ColumnNames_t GetValidatedColumnNames(RLoopManager &lm, const unsigned int nColumns, const ColumnNames_t &columns,; 376 const RColumnRegister &validDefines, RDataSource *ds);; 377 ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/InterfaceUtils_8hxx_source.html:15954,allocate,allocated,15954,doc/master/InterfaceUtils_8hxx_source.html,https://root.cern,https://root.cern/doc/master/InterfaceUtils_8hxx_source.html,1,['allocate'],['allocated']
Energy Efficiency,"const Option_t* option = """"); Draws either the KDE functions or its errors; Possible options:; """" (default) - draw just the kde; ""same"" draw on top of existing pad; ""Errors"" draw a TGraphErrors with the point and errors; ""confidenceinterval"" draw KDE + conf interval functions (default is 95%); ""confidenceinterval@0.90"" draw KDE + conf interval functions at 90%; Extra options can be passed in opt for drawing the TF1 or the TGraph. NOTE: The functions GetDrawnFunction(), GetDrawnUpperFunction(), GetDrawnLowerFunction(); and GetGraphWithErrors() return the corresponding drawn objects (which are maneged by the TKDE); They can be used to changes style, color, etc... void DrawErrors(TString& drawOpt); Draws a TGraphErrors for the KDE errors. TGraphErrors* GetGraphWithErrors(UInt_t npx = 100, Double_t xMin = 1., Double_t xMax = 0.). void DrawConfidenceInterval(TString& drawOpt, double cl = 0.94999999999999996); Draws the KDE and its confidence interval. Double_t GetFixedWeight() const; Returns the bandwidth for the non adaptive KDE. const Double_t * GetAdaptiveWeights() const; Returns the bandwidths for the adaptive KDE. UInt_t Index(Double_t x) const; Returns the indices (bins) for the binned weights. Double_t UpperConfidenceInterval(const Double_t* x, const Double_t* p) const; Returns the pointwise upper estimated density. Double_t LowerConfidenceInterval(const Double_t* x, const Double_t* p) const; Returns the pointwise lower estimated density. Double_t GetBias(Double_t x) const; Returns the pointwise approximate estimated density bias. Double_t GetError(Double_t x) const; Returns the pointwise sigma of estimated density. void CheckKernelValidity(); Checks if kernel has unit integral, mu = 0 and positive finite sigma conditions. Double_t ComputeKernelL2Norm() const; Computes the kernel's L2 norm. Double_t ComputeKernelSigma2() const; Computes the kernel's sigma squared. Double_t ComputeKernelMu() const; Computes the kernel's mu. Double_t ComputeKernelIntegral() const; Co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TKDE.html:17196,adapt,adaptive,17196,root/html602/TKDE.html,https://root.cern,https://root.cern/root/html602/TKDE.html,2,['adapt'],['adaptive']
Energy Efficiency,"const RNTupleWriter &) = delete;; 100 RNTupleWriter &operator=(const RNTupleWriter &) = delete;; 101 ~RNTupleWriter();; 102 ; 103 /// The simplest user interface if the default entry that comes with the ntuple model is used.; 104 /// \return The number of uncompressed bytes written.; 105 std::size_t Fill() { return fFillContext.Fill(fFillContext.fModel->GetDefaultEntry()); }; 106 /// Multiple entries can have been instantiated from the ntuple model. This method will perform; 107 /// a light check whether the entry comes from the ntuple's own model.; 108 /// \return The number of uncompressed bytes written.; 109 std::size_t Fill(REntry &entry) { return fFillContext.Fill(entry); }; 110 /// Fill an entry into this ntuple, but don't commit the cluster. The calling code must pass an RNTupleFillStatus; 111 /// and check RNTupleFillStatus::ShouldFlushCluster.; 112 void FillNoFlush(REntry &entry, RNTupleFillStatus &status) { fFillContext.FillNoFlush(entry, status); }; 113 /// Flush column data, preparing for CommitCluster or to reduce memory usage. This will trigger compression of pages,; 114 /// but not actually write to storage (unless buffered writing is turned off).; 115 void FlushColumns() { fFillContext.FlushColumns(); }; 116 /// Flush so far filled entries to storage; 117 void FlushCluster() { fFillContext.FlushCluster(); }; 118 /// Ensure that the data from the so far seen Fill calls has been written to storage; 119 void CommitCluster(bool commitClusterGroup = false); 120 {; 121 fFillContext.FlushCluster();; 122 if (commitClusterGroup); 123 CommitClusterGroup();; 124 }; 125 ; 126 std::unique_ptr<REntry> CreateEntry() { return fFillContext.CreateEntry(); }; 127 ; 128 /// Return the entry number that was last flushed in a cluster.; 129 NTupleSize_t GetLastFlushed() const { return fFillContext.GetLastFlushed(); }; 130 /// Return the entry number that was last committed in a cluster.; 131 NTupleSize_t GetLastCommitted() const { return fFillContext.GetLastFlushed(); }; 1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RNTupleWriter_8hxx_source.html:5501,reduce,reduce,5501,doc/master/RNTupleWriter_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RNTupleWriter_8hxx_source.html,1,['reduce'],['reduce']
Energy Efficiency,"const RooAbsReal& offset, const char* unit = """"); Constructor with RooAbsRealLValue variable and RooAbsReal slope and offset. RooLinearVar(const RooLinearVar& other, const char* name = 0); Copy constructor. ~RooLinearVar(); Destructor. Double_t evaluate() const; Calculate current value of this object. void setVal(Double_t value); Assign given value to linear transformation: sets input variable to (value-offset)/slope; If slope is zerom an error message is printed and no assignment is made. Bool_t isJacobianOK(const RooArgSet& depList) const; Returns true if Jacobian term associated with current; expression tree is indeed constant. Double_t jacobian() const; Return value of Jacobian associated with the transformation. Bool_t readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Read object contents from stream. void writeToStream(ostream& os, Bool_t compact) const; Write object contents to stream. RooAbsBinning& getBinning(const char* name = 0, Bool_t verbose = kTRUE, Bool_t createOnTheFly = kFALSE); Retrieve binning of this linear transformation. A RooLinearVar does not have its own; binnings but uses linearly transformed binnings of teh input variable. If a given; binning exists on the input variable, it will also exists on this linear transformation; and a binning adaptor object is created on the fly. const RooAbsBinning& getBinning(const char* name = 0, Bool_t verbose = kTRUE, Bool_t createOnTheFly = kFALSE) const; Const version of getBinning(). Bool_t hasBinning(const char* name) const; Returns true if binning with given name exists.If a given binning; exists on the input variable, it will also exists on this linear; transformation. TObject* clone(const char* newname) const; { return new RooLinearVar(*this,newname); }. » Last changed: Mon Jul 4 15:23:14 2011 » Last generated: 2011-07-04 15:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooLinearVar.html:39589,adapt,adaptor,39589,root/html530/RooLinearVar.html,https://root.cern,https://root.cern/root/html530/RooLinearVar.html,1,['adapt'],['adaptor']
Energy Efficiency,"const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={}) const;  ; virtual RooPlot * plotOn (RooPlot *frame, const RooLinkedList &cmdList) const;  Plot dataset on specified frame. ;  ; void Print (Option_t *options=nullptr) const override;  This method must be overridden when a class wants to print itself. ;  ; void printClassName (std::ostream &os) const override;  Print class name of dataset. ;  ; void printName (std::ostream &os) const override;  Print name of dataset. ;  ; void printTitle (std::ostream &os) const override;  Print title of dataset. ;  ; void RecursiveRemove (TObject *obj) override;  If one of the TObject we have a referenced to is deleted, remove the reference. ;  ; RooFit::OwningPtr< RooAbsData > reduce (const char *cut) const;  Create a subset of the data set by applying the given cut on the data points. ;  ; RooFit::OwningPtr< RooAbsData > reduce (const RooArgSet &varSubset, const char *cut=nullptr) const;  Create a subset of the data set by applying the given cut on the data points and reducing the dimensions to the specified set. ;  ; RooFit::OwningPtr< RooAbsData > reduce (const RooArgSet &varSubset, const RooFormulaVar &cutVar) const;  Create a subset of the data set by applying the given cut on the data points and reducing the dimensions to the specified set. ;  ; RooFit::OwningPtr< RooAbsData > reduce (const RooCmdArg &arg1, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={}) const;  Create a reduced copy of this dataset. ;  ; RooFit::OwningPtr< RooAbsData > reduce (const RooFormulaVar &cutVar) const;  Create a subset of the data set by applying the given cut on the data points. ;  ; virtual void reset ();  ; void resetBuffers ();  ; RooRealVar * rmsVar (const RooRealVar &var, const char *cutSpec=nullptr, const char *cutRange=nullptr) const;  Create a RooRealVar co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooDataSet.html:15308,reduce,reduce,15308,doc/master/classRooDataSet.html,https://root.cern,https://root.cern/doc/master/classRooDataSet.html,1,['reduce'],['reduce']
Energy Efficiency,"const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; virtual voidTObject::Pop(); virtual voidPrint(Option_t* options = 0) const; virtual voidRooPrintable::printAddress(ostream& os) const; virtual voidRooPrintable::printArgs(ostream& os) const; virtual voidprintClassName(ostream& os) const; virtual voidRooPrintable::printExtras(ostream& os) const; virtual voidprintMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; virtual voidprintName(ostream& os) const; virtual voidRooPrintable::printStream(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidprintTitle(ostream& os) const; virtual voidRooPrintable::printTree(ostream& os, TString indent = """") const; virtual voidRooPrintable::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); RooAbsData*reduce(const char* cut); RooAbsData*reduce(const RooFormulaVar& cutVar); RooAbsData*reduce(const RooArgSet& varSubset, const char* cut = 0); RooAbsData*reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); RooAbsData*reduce(RooCmdArg arg1, RooCmdArg arg2 = RooCmdArg(), RooCmdArg arg3 = RooCmdArg(), RooCmdArg arg4 = RooCmdArg(), RooCmdArg arg5 = RooCmdArg(), RooCmdArg arg6 = RooCmdArg(), RooCmdArg arg7 = RooCmdArg(), RooCmdArg arg8 = RooCmdArg()); virtual voidreset(); voidTObject::ResetBit(UInt_t f); RooRealVar*rmsVar(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidsetDirtyProp(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsData.html:7861,reduce,reduce,7861,root/html526/RooAbsData.html,https://root.cern,https://root.cern/root/html526/RooAbsData.html,1,['reduce'],['reduce']
Energy Efficiency,"const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; virtual voidTObject::Pop(); virtual voidPrint(Option_t* options = 0) const; virtual voidRooPrintable::printAddress(ostream& os) const; virtual voidRooPrintable::printArgs(ostream& os) const; virtual voidprintClassName(ostream& os) const; virtual voidRooPrintable::printExtras(ostream& os) const; virtual voidprintMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; virtual voidprintName(ostream& os) const; virtual voidRooPrintable::printStream(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidprintTitle(ostream& os) const; virtual voidRooPrintable::printTree(ostream& os, TString indent = """") const; virtual voidRooPrintable::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); RooAbsData*reduce(const char* cut); RooAbsData*reduce(const RooFormulaVar& cutVar); RooAbsData*reduce(const RooArgSet& varSubset, const char* cut = 0); RooAbsData*reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); RooAbsData*reduce(const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); static Bool_treleaseVars(RooAbsData*); virtual voidreset(); voidTObject::ResetBit(UInt_t f); RooRealVar*rmsVar(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidsetDirtyProp(Bool_t flag); virtual voidTObject::SetDrawOpti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooAbsData.html:8132,reduce,reduce,8132,root/html530/RooAbsData.html,https://root.cern,https://root.cern/root/html530/RooAbsData.html,1,['reduce'],['reduce']
Energy Efficiency,"const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; virtual voidTObject::Pop(); virtual voidPrint(Option_t* options = 0) const; virtual voidRooPrintable::printAddress(ostream& os) const; virtual voidRooPrintable::printArgs(ostream& os) const; virtual voidprintClassName(ostream& os) const; virtual voidRooPrintable::printExtras(ostream& os) const; virtual voidprintMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; virtual voidprintName(ostream& os) const; virtual voidRooPrintable::printStream(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidprintTitle(ostream& os) const; virtual voidRooPrintable::printTree(ostream& os, TString indent = """") const; virtual voidRooPrintable::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); RooAbsData*reduce(const char* cut); RooAbsData*reduce(const RooFormulaVar& cutVar); RooAbsData*reduce(const RooArgSet& varSubset, const char* cut = 0); RooAbsData*reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); RooAbsData*reduce(const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); static Bool_treleaseVars(RooAbsData*); virtual voidreset(); voidTObject::ResetBit(UInt_t f); voidresetBuffers(); RooRealVar*rmsVar(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; RooAbsData(); RooAbsData(const RooAbsData& other, const char* newname = 0); RooAbsData(const char* name, const char* title, const RooArgSet& vars, RooAbsDataStore* store = 0); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsData.html:8259,reduce,reduce,8259,root/html602/RooAbsData.html,https://root.cern,https://root.cern/root/html602/RooAbsData.html,2,['reduce'],['reduce']
Energy Efficiency,"const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; virtual voidTObject::Pop(); virtual voidPrint(Option_t* options = 0) const; virtual voidRooPrintable::printAddress(ostream& os) const; virtual voidRooPrintable::printArgs(ostream& os) const; virtual voidprintClassName(ostream& os) const; virtual voidRooPrintable::printExtras(ostream& os) const; virtual voidprintMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; virtual voidprintName(ostream& os) const; virtual voidRooPrintable::printStream(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidprintTitle(ostream& os) const; virtual voidRooPrintable::printTree(ostream& os, TString indent = """") const; virtual voidRooPrintable::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); RooAbsData*reduce(const char* cut); RooAbsData*reduce(const RooFormulaVar& cutVar); RooAbsData*reduce(const RooArgSet& varSubset, const char* cut = 0); RooAbsData*reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); RooAbsData*reduce(const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); static Bool_treleaseVars(RooAbsData*); virtual voidreset(); voidTObject::ResetBit(UInt_t f); voidresetBuffers(); RooRealVar*rmsVar(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidsetDefaultStorageType(RooAbsData",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsData.html:8204,reduce,reduce,8204,root/html532/RooAbsData.html,https://root.cern,https://root.cern/root/html532/RooAbsData.html,2,['reduce'],['reduce']
Energy Efficiency,"const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; virtual voidTObject::Pop(); virtual voidPrint(Option_t* options = 0) const; virtual voidRooPrintable::printAddress(ostream& os) const; virtual voidRooPrintable::printArgs(ostream& os) const; virtual voidprintClassName(ostream& os) const; virtual voidRooPrintable::printExtras(ostream& os) const; virtual voidprintMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; virtual voidprintName(ostream& os) const; virtual voidRooPrintable::printStream(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidprintTitle(ostream& os) const; virtual voidRooPrintable::printTree(ostream& os, TString indent = """") const; virtual voidRooPrintable::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); RooAbsData*reduce(const char* cut); RooAbsData*reduce(const RooFormulaVar& cutVar); RooAbsData*reduce(const RooArgSet& varSubset, const char* cut = 0); RooAbsData*reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); RooAbsData*reduce(const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); virtual voidreset(); voidTObject::ResetBit(UInt_t f); RooRealVar*rmsVar(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidsetDirtyProp(Bool_t flag); virtual voidTObject::SetDrawOption(Optio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsData.html:7861,reduce,reduce,7861,root/html528/RooAbsData.html,https://root.cern,https://root.cern/root/html528/RooAbsData.html,1,['reduce'],['reduce']
Energy Efficiency,"const TMVA::Event* Transform(const TMVA::Event*const , Int_t cls) const; apply the principal component analysis. const TMVA::Event* InverseTransform(const TMVA::Event*const , Int_t cls) const; apply the principal component analysis; TODO: implementation of inverse transformation; Log() << kFATAL << ""Inverse transformation for PCA transformation not yet implemented. Hence, this transformation cannot be applied together with regression. Please contact the authors if necessary."" << Endl;. void CalculatePrincipalComponents(const vector<TMVA::Event*>& ); calculate the principal components for the signal and the background data; it uses the MakePrincipal method of ROOT's TPrincipal class. void X2P(vector<Float_t>& , const vector<Float_t>& , Int_t cls) const; Calculate the principal components from the original data vector; x, and return it in p (function extracted from TPrincipal::X2P); It's the users responsibility to make sure that both x and p are; of the right size (i.e., memory must be allocated for p). void P2X(vector<Float_t>& , const vector<Float_t>& , Int_t cls) const; Perform the back-transformation from the principal components; pc, and return x; It's the users responsibility to make sure that both x and pc are; of the right size (i.e., memory must be allocated for p). void WriteTransformationToStream(ostream& ) const; write mean values to stream. void AttachXMLTo(void* parent); create XML description of PCA transformation. void ReadFromXML(void* trfnode); Read the transformation matrices from the xml node. void ReadTransformationFromStream(istream& , const TString& ); Read mean values from input stream. void MakeFunction(ostream& fout, const TString& fncName, Int_t part, UInt_t trCounter, Int_t cls); creates C++ code fragment of the PCA transform for inclusion in standalone C++ class. VariablePCATransform( DataSetInfo& dsi ). » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-0",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TMVA__VariablePCATransform.html:11722,allocate,allocated,11722,root/html604/TMVA__VariablePCATransform.html,https://root.cern,https://root.cern/root/html604/TMVA__VariablePCATransform.html,1,['allocate'],['allocated']
Energy Efficiency,"const TMVA::Event* Transform(const TMVA::Event*const , Int_t cls) const; apply the principal component analysis. const TMVA::Event* InverseTransform(const TMVA::Event*const , Int_t cls) const; apply the principal component analysis; TODO: implementation of inverse transformation; Log() << kFATAL << ""Inverse transformation for PCA transformation not yet implemented. Hence, this transformation cannot be applied together with regression. Please contact the authors if necessary."" << Endl;. void CalculatePrincipalComponents(const vector<TMVA::Event*>& ); calculate the principal components for the signal and the background data; it uses the MakePrincipal method of ROOT's TPrincipal class. void X2P(vector<Float_t>& , const vector<Float_t>& , Int_t cls) const; Calculate the principal components from the original data vector; x, and return it in p (function extracted from TPrincipal::X2P); It's the users responsibility to make sure that both x and p are; of the right size (i.e., memory must be allocated for p). void P2X(vector<Float_t>& , const vector<Float_t>& , Int_t cls) const; Perform the back-transformation from the principal components; pc, and return x; It's the users responsibility to make sure that both x and pc are; of the right size (i.e., memory must be allocated for p). void WriteTransformationToStream(ostream& ) const; write mean values to stream. void AttachXMLTo(void* parent); create XML description of PCA transformation. void ReadFromXML(void* trfnode); Read the transformation matrices from the xml node. void ReadTransformationFromStream(istream& , const TString& ); Read mean values from input stream. void MakeFunction(ostream& fout, const TString& fncName, Int_t part, UInt_t trCounter, Int_t cls); creates C++ code fragment of the PCA transform for inclusion in standalone C++ class. VariablePCATransform( DataSetInfo& dsi ). » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-3",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__VariablePCATransform.html:11714,allocate,allocated,11714,root/html602/TMVA__VariablePCATransform.html,https://root.cern,https://root.cern/root/html602/TMVA__VariablePCATransform.html,1,['allocate'],['allocated']
Energy Efficiency,"const char * TString::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TString::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 473 of file TString.h. ◆ Clear(). void TString::Clear ; (; ). Clear string without changing its capacity. ; Definition at line 1235 of file TString.cxx. ◆ Clobber(). Ssiz_t TString::Clobber ; (; Ssiz_t ; nc). protected . Clear string and make sure it has a capacity of nc. ; WarningIf nc > MaxSize(), then Fatal() is raised, and only MaxSize() elements are allocated if Fatal does not abort ; ReturnsResulting allocated capacity (after clamping, if needed) ; Definition at line 1246 of file TString.cxx. ◆ Clone(). void TString::Clone ; (; Ssiz_t ; tot). private . Make self a distinct copy with capacity of at least tot, where tot cannot be smaller than the current length. ; Preserve previous contents. WarningIf tot > MaxSize(), then Fatal() is raised and only MaxSize() elements are allocated ; Definition at line 1279 of file TString.cxx. ◆ CompareTo() [1/2]. int TString::CompareTo ; (; const char * ; cs2, . ECaseCompare ; cmp = kExact . ); const. Compare a string to char *cs2. ; Returns returns zero if the two strings are identical, otherwise returns the difference between the first two differing bytes (treated as unsigned char values, so that ‘\200’ is greater than ‘\0’, for example). Zero-length strings are always identical. ; Definition at line 457 of file TString.cxx. ◆ CompareTo() [2/2]. int TString::CompareTo ; (; const TString & ; str, . ECaseCompare ; cmp = kExact . ); const. Compare a string to another string. ; Returns returns zero if the two strings are identical, otherwise returns the difference between the first two differing bytes (treated as unsigned char values, so that ‘\200’ is greater than ‘\0’, for example). Zero-length strings are always identical. ; Definition at line 487 of file TString.cxx. ◆ Contains() [1/4]. Bool_t TString",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTString.html:25829,allocate,allocated,25829,doc/v632/classTString.html,https://root.cern,https://root.cern/doc/v632/classTString.html,2,['allocate'],['allocated']
Energy Efficiency,"const char * ; name); const. Return the TList corresponding to object's name based hash value. ; One can iterate this list ""manually"" to find, e.g. objects with the same name. ; Definition at line 268 of file THashTable.cxx. ◆ GetListForObject() [2/2]. const TList * THashTable::GetListForObject ; (; const TObject * ; obj); const. Return the TList corresponding to object's hash value. ; One can iterate this list ""manually"" to find, e.g. identical objects. ; Definition at line 282 of file THashTable.cxx. ◆ GetObjectRef(). TObject ** THashTable::GetObjectRef ; (; const TObject * ; obj); const. overridevirtual . Return address of pointer to obj. ; Implements TCollection.; Definition at line 296 of file THashTable.cxx. ◆ GetRehashLevel(). Int_t THashTable::GetRehashLevel ; (; ); const. inline . Definition at line 72 of file THashTable.h. ◆ GetSize(). Int_t THashTable::GetSize ; (; ); const. inlineoverridevirtual . Return the capacity of the collection, i.e. ; the current total amount of space that has been allocated so far. Same as Capacity. Use GetEntries to get the number of elements currently in the collection. ; Reimplemented from TCollection.; Definition at line 73 of file THashTable.h. ◆ IsA(). TClass * THashTable::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TCollection.; Definition at line 82 of file THashTable.h. ◆ MakeIterator(). TIterator * THashTable::MakeIterator ; (; Bool_t ; dir = kIterForward); const. overridevirtual . Returns a hash table iterator. ; Implements TCollection.; Definition at line 311 of file THashTable.cxx. ◆ operator=(). THashTable & THashTable::operator= ; (; const THashTable & ; ). privatedelete . ◆ Print() [1/5]. void TCollection::Print ; (; Option_t * ; option, . const char * ; wildcard, . Int_t ; recurse = 1 . ); const. virtual . Print the collection header and its elements that match the wildcard. ; If recurse is non-zero, descend into printing of collection-entries with recu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHashTable.html:22606,allocate,allocated,22606,doc/master/classTHashTable.html,https://root.cern,https://root.cern/doc/master/classTHashTable.html,1,['allocate'],['allocated']
Energy Efficiency,"const char* cutSpec = 0, const char* cutRange = 0) const; { return moment(var,1,0,cutSpec,cutRange) ; }. Double_t sigma(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; { return sqrt(moment(var,2,cutSpec,cutRange)) ; }. Double_t skewness(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; { return standMoment(var,3,cutSpec,cutRange) ; }. Double_t kurtosis(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; { return standMoment(var,4,cutSpec,cutRange) ; }. Double_t covariance(RooRealVar& x, RooRealVar& y, const char* cutSpec = 0, const char* cutRange = 0) const; { return corrcov(x,y,cutSpec,cutRange,kFALSE) ; }. Double_t correlation(RooRealVar& x, RooRealVar& y, const char* cutSpec = 0, const char* cutRange = 0) const; { return corrcov(x,y,cutSpec,cutRange,kTRUE) ; }. TMatrixDSym* covarianceMatrix(const char* cutSpec = 0, const char* cutRange = 0) const; { return covarianceMatrix(*get(),cutSpec,cutRange) ; }. TMatrixDSym* correlationMatrix(const char* cutSpec = 0, const char* cutRange = 0) const; { return correlationMatrix(*get(),cutSpec,cutRange) ; }. TMatrixDSym* covarianceMatrix(const RooArgList& vars, const char* cutSpec = 0, const char* cutRange = 0) const; { return corrcovMatrix(vars,cutSpec,cutRange,kFALSE) ; }. TMatrixDSym* correlationMatrix(const RooArgList& vars, const char* cutSpec = 0, const char* cutRange = 0) const; { return corrcovMatrix(vars,cutSpec,cutRange,kTRUE) ; }. RooAbsData* cacheClone(const RooAbsArg* newCacheOwner, const RooArgSet* newCacheVars, const char* newName = 0). RooAbsData* reduceEng(const RooArgSet& varSubset, const RooFormulaVar* cutVar, const char* cutRange = 0, Int_t nStart = 0, Int_t nStop = 2000000000, Bool_t copyCache = kTRUE). » Last changed: Mon Oct 11 11:18:50 2010 » Last generated: 2010-10-11 11:18; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsData.html:37471,reduce,reduceEng,37471,root/html528/RooAbsData.html,https://root.cern,https://root.cern/root/html528/RooAbsData.html,1,['reduce'],['reduceEng']
Energy Efficiency,"const; virtual voidRooPrintable::printExtras(ostream& os) const; virtual voidprintMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; virtual voidRooAbsData::printName(ostream& os) const; virtual voidRooPrintable::printStream(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidRooAbsData::printTitle(ostream& os) const; virtual voidRooPrintable::printTree(ostream& os, TString indent = """") const; virtual voidprintValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); static RooDataSet*read(const char* filename, const RooArgList& variables, const char* opts = """", const char* commonPath = """", const char* indexCatName = 0); virtual voidTObject::RecursiveRemove(TObject* obj); RooAbsData*RooAbsData::reduce(const char* cut); RooAbsData*RooAbsData::reduce(const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const char* cut = 0); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(RooCmdArg arg1, RooCmdArg arg2 = RooCmdArg(), RooCmdArg arg3 = RooCmdArg(), RooCmdArg arg4 = RooCmdArg(), RooCmdArg arg5 = RooCmdArg(), RooCmdArg arg6 = RooCmdArg(), RooCmdArg arg7 = RooCmdArg(), RooCmdArg arg8 = RooCmdArg()); virtual voidRooAbsData::reset(); voidTObject::ResetBit(UInt_t f); RooRealVar*RooAbsData::rmsVar(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidRooAbsData::setDirtyProp(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetName(const char* name); virtual voidSetNameTitle(const char* name, const char",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooDataSet.html:9995,reduce,reduce,9995,root/html526/RooDataSet.html,https://root.cern,https://root.cern/root/html526/RooDataSet.html,1,['reduce'],['reduce']
Energy Efficiency,"const; virtual voidRooPrintable::printExtras(ostream& os) const; virtual voidprintMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; virtual voidRooAbsData::printName(ostream& os) const; virtual voidRooPrintable::printStream(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidRooAbsData::printTitle(ostream& os) const; virtual voidRooPrintable::printTree(ostream& os, TString indent = """") const; virtual voidprintValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); static RooDataSet*read(const char* filename, const RooArgList& variables, const char* opts = """", const char* commonPath = """", const char* indexCatName = 0); virtual voidTObject::RecursiveRemove(TObject* obj); RooAbsData*RooAbsData::reduce(const char* cut); RooAbsData*RooAbsData::reduce(const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const char* cut = 0); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); static Bool_tRooAbsData::releaseVars(RooAbsData*); virtual voidRooAbsData::reset(); voidTObject::ResetBit(UInt_t f); RooRealVar*RooAbsData::rmsVar(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidRooAbsData::setDirtyProp(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetN",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooDataSet.html:10248,reduce,reduce,10248,root/html530/RooDataSet.html,https://root.cern,https://root.cern/root/html530/RooDataSet.html,1,['reduce'],['reduce']
Energy Efficiency,"const; virtual voidRooPrintable::printExtras(ostream& os) const; virtual voidprintMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; virtual voidRooAbsData::printName(ostream& os) const; virtual voidRooPrintable::printStream(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidRooAbsData::printTitle(ostream& os) const; virtual voidRooPrintable::printTree(ostream& os, TString indent = """") const; virtual voidprintValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); static RooDataSet*read(const char* filename, const RooArgList& variables, const char* opts = """", const char* commonPath = """", const char* indexCatName = 0); virtual voidTObject::RecursiveRemove(TObject* obj); RooAbsData*RooAbsData::reduce(const char* cut); RooAbsData*RooAbsData::reduce(const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const char* cut = 0); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); static Bool_tRooAbsData::releaseVars(RooAbsData*); virtual voidRooAbsData::reset(); voidTObject::ResetBit(UInt_t f); voidRooAbsData::resetBuffers(); RooRealVar*RooAbsData::rmsVar(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; RooDataSet(); RooDataSet(const RooDataSet& other, const char* newname = 0); RooDataSet(const char* name, const char* title, const RooArgSet& vars, const char* wgtVarName = 0); RooDataSet(const char* name, const char* title, RooDataSet* data, const RooArgSet& vars, const char* cuts = 0, const char* wgtVarName = 0); RooDataSet(const char* name, const char* title, RooDataS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooDataSet.html:9323,reduce,reduce,9323,root/html602/RooDataSet.html,https://root.cern,https://root.cern/root/html602/RooDataSet.html,2,['reduce'],['reduce']
Energy Efficiency,"const; virtual voidRooPrintable::printExtras(ostream& os) const; virtual voidprintMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; virtual voidRooAbsData::printName(ostream& os) const; virtual voidRooPrintable::printStream(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidRooAbsData::printTitle(ostream& os) const; virtual voidRooPrintable::printTree(ostream& os, TString indent = """") const; virtual voidprintValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); static RooDataSet*read(const char* filename, const RooArgList& variables, const char* opts = """", const char* commonPath = """", const char* indexCatName = 0); virtual voidTObject::RecursiveRemove(TObject* obj); RooAbsData*RooAbsData::reduce(const char* cut); RooAbsData*RooAbsData::reduce(const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const char* cut = 0); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); static Bool_tRooAbsData::releaseVars(RooAbsData*); virtual voidRooAbsData::reset(); voidTObject::ResetBit(UInt_t f); voidRooAbsData::resetBuffers(); RooRealVar*RooAbsData::rmsVar(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsData::setDefaultStorageType(RooAbsData::StorageType s); voidRooAbsData::setDirtyProp(Bool_t flag); virtual voidTObject",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooDataSet.html:10439,reduce,reduce,10439,root/html534/RooDataSet.html,https://root.cern,https://root.cern/root/html534/RooDataSet.html,1,['reduce'],['reduce']
Energy Efficiency,"const; virtual voidRooPrintable::printExtras(ostream& os) const; virtual voidprintMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; virtual voidRooAbsData::printName(ostream& os) const; virtual voidRooPrintable::printStream(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidRooAbsData::printTitle(ostream& os) const; virtual voidRooPrintable::printTree(ostream& os, TString indent = """") const; virtual voidprintValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); static RooDataSet*read(const char* filename, const RooArgList& variables, const char* opts = """", const char* commonPath = """", const char* indexCatName = 0); virtual voidTObject::RecursiveRemove(TObject* obj); RooAbsData*RooAbsData::reduce(const char* cut); RooAbsData*RooAbsData::reduce(const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const char* cut = 0); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); static Bool_tRooAbsData::releaseVars(RooAbsData*); virtual voidRooAbsData::reset(); voidTObject::ResetBit(UInt_t f); voidRooAbsData::resetBuffers(); RooRealVar*RooAbsData::rmsVar(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidRooAbsData::setDirtyProp(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooDataSet.html:10344,reduce,reduce,10344,root/html532/RooDataSet.html,https://root.cern,https://root.cern/root/html532/RooDataSet.html,1,['reduce'],['reduce']
Energy Efficiency,"const; virtual voidRooPrintable::printExtras(ostream& os) const; virtual voidprintMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; virtual voidRooAbsData::printName(ostream& os) const; virtual voidRooPrintable::printStream(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidRooAbsData::printTitle(ostream& os) const; virtual voidRooPrintable::printTree(ostream& os, TString indent = """") const; virtual voidprintValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); static RooDataSet*read(const char* filename, const RooArgList& variables, const char* opts = """", const char* commonPath = """", const char* indexCatName = 0); virtual voidTObject::RecursiveRemove(TObject* obj); RooAbsData*RooAbsData::reduce(const char* cut); RooAbsData*RooAbsData::reduce(const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const char* cut = 0); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); virtual voidRooAbsData::reset(); voidTObject::ResetBit(UInt_t f); RooRealVar*RooAbsData::rmsVar(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidRooAbsData::setDirtyProp(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetName(const char* name",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooDataSet.html:10051,reduce,reduce,10051,root/html528/RooDataSet.html,https://root.cern,https://root.cern/root/html528/RooDataSet.html,1,['reduce'],['reduce']
Energy Efficiency,"const; voidGradient(const double* x, double* g) const; ROOT::Math::IGradientOneDimIGradientOneDim(); ROOT::Math::IGradientOneDimIGradientOneDim(const ROOT::Math::IGradientOneDim&); ROOT::Math::IGradientOneDim&operator=(const ROOT::Math::IGradientOneDim&). private:. virtual doubleDoDerivative(double x) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Gradient(const double* x, double* g) const. Evaluate all the vector of function derivatives (gradient) at a point x.; Derived classes must re-implement if it is more efficient than evaluting one at a time. double Derivative(const double * x, unsigned int icoord = 0). Return the partial derivative with respect to the passed coordinate. return DoDerivative(x, icoord). void FdF(const double* x, double& f, double* df) const. Optimized method to evaluate at the same time the function value and derivative at a point x.; Often both value and derivatives are needed and it is often more efficient to compute them at the same time.; Derived class should implement this method if performances play an important role and if it is faster to; evaluate value and derivative at the same time. virtual ~IGradientOneDim(); virtual destructor. {}. double Derivative(double x) const. Return the derivative of the function at a point x; Use the private method DoDerivative. void FdF(double x, double& f, double& df) const. Optimized method to evaluate at the same time the function value and derivative at a point x.; Often both value and derivatives are needed and it is often more efficient to compute them at the same time.; Derived class should implement this method if performances play an important role and if it is faster to; evaluate value and derivative at the same time. » Last changed: root/mathcore:$Id$ » Last generated: 2015-06-30 14:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__IGradientOneDim.html:2861,efficient,efficient,2861,root/html602/ROOT__Math__IGradientOneDim.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__IGradientOneDim.html,1,['efficient'],['efficient']
Energy Efficiency,"const; voidGradient(const double* x, double* g) const; ROOT::Math::IGradientOneDimIGradientOneDim(); ROOT::Math::IGradientOneDimIGradientOneDim(const ROOT::Math::IGradientOneDim&); ROOT::Math::IGradientOneDim&operator=(const ROOT::Math::IGradientOneDim&). private:. virtual doubleDoDerivative(double x) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Gradient(const double* x, double* g) const. Evaluate all the vector of function derivatives (gradient) at a point x.; Derived classes must re-implement if it is more efficient than evaluting one at a time. double Derivative(const double * x, unsigned int icoord = 0). Return the partial derivative with respect to the passed coordinate. return DoDerivative(x, icoord). void FdF(const double* x, double& f, double* df) const. Optimized method to evaluate at the same time the function value and derivative at a point x.; Often both value and derivatives are needed and it is often more efficient to compute them at the same time.; Derived class should implement this method if performances play an important role and if it is faster to; evaluate value and derivative at the same time. virtual ~IGradientOneDim(); virtual destructor. {}. double Derivative(double x) const. Return the derivative of the function at a point x; Use the private method DoDerivative. void FdF(double x, double& f, double& df) const. Optimized method to evaluate at the same time the function value and derivative at a point x.; Often both value and derivatives are needed and it is often more efficient to compute them at the same time.; Derived class should implement this method if performances play an important role and if it is faster to; evaluate value and derivative at the same time. » Last changed: root/mathcore:$Id$ » Last generated: 2015-09-08 17:34; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/ROOT__Math__IGradientOneDim.html:2861,efficient,efficient,2861,root/html604/ROOT__Math__IGradientOneDim.html,https://root.cern,https://root.cern/root/html604/ROOT__Math__IGradientOneDim.html,1,['efficient'],['efficient']
Energy Efficiency,"const;  ; bool exists (std::string histoName);  for monitoring ;  ; double factorWeightDecay () const;  get the weight-decay factor ;  ; virtual bool hasConverged (double testError);  has this training converged already? ;  ; double learningRate () const;  get the learning rate ;  ; size_t maxConvergenceCount () const;  returns the max convergence count so far ;  ; size_t minError () const;  returns the smallest error so far ;  ; MinimizerType minimizerType () const;  which minimizer shall be used (e.g. SGD) ;  ; double momentum () const;  get the momentum (e.g. for SGD) ;  ; void pads (int numPads);  preparation for monitoring ;  ; void plot (std::string histoName, std::string options, int pad, EColor color);  for monitoring ;  ; EnumRegularization regularization () const;  some regularization of the DNN is turned on? ;  ; int repetitions () const;  how many steps have to be gone until the batch is changed ;  ; template<typename Iterator > ; void setDropOut (Iterator begin, Iterator end, size_t _dropRepetitions);  set the drop-out configuration (layer-wise) ;  ; void setMonitoring (std::shared_ptr< Monitoring > ptrMonitoring);  prepared for monitoring ;  ; virtual void setProgressLimits (double minProgress=0, double maxProgress=100);  ; virtual void startTraining ();  ; size_t testRepetitions () const;  how often is the test data tested ;  ; bool useMultithreading () const;  is multithreading turned on? ;  . Public Attributes; std::vector< double > m_ams;  ; double m_cutValue;  ; std::string m_fileNameNetConfig;  ; std::string m_fileNameResult;  ; std::vector< double > m_input;  ; std::vector< double > m_output;  ; std::vector< Pattern > * m_pResultPatternContainer;  ; size_t m_scaleToNumEvents;  ; std::vector< double > m_significances;  ; double m_sumOfBkgWeights;  ; double m_sumOfSigWeights;  ; std::vector< double > m_targets;  ; std::vector< double > m_weights;  ;  Public Attributes inherited from TMVA::DNN::Settings; size_t count_dE;  ; size_t count_E;  ; size_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1ClassificationSettings.html:4043,monitor,monitoring,4043,doc/master/classTMVA_1_1DNN_1_1ClassificationSettings.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1ClassificationSettings.html,3,['monitor'],['monitoring']
Energy Efficiency,"constexpr Int_t ncolors = 100;; 296 constexpr Float_t lmin = 0.25;; 297 constexpr Float_t lmax = 0.75;; 298 static IntMap_t colmap;; 299 Int_t color = base;; 300 // Search color in the map; 301 auto it = colmap.find(base);; 302 if (it != colmap.end()); 303 return (it->second + light * (ncolors - 1));; 304 // Get color pointer if stored; 305 TColor *col_base = gROOT->GetColor(base);; 306 if (!col_base) {; 307 // If color not defined, use gray palette; 308 it = colmap.find(kBlack);; 309 if (it != colmap.end()); 310 return (it->second + light * (ncolors - 1));; 311 col_base = gROOT->GetColor(kBlack);; 312 color = 1;; 313 }; 314 // Create a color palette for col_base; 315 Float_t r = 0., g = 0., b = 0., h = 0., l = 0., s = 0.;; 316 Double_t red[2], green[2], blue[2];; 317 Double_t stop[] = {0., 1.0};; 318 ; 319 if (col_base); 320 col_base->GetRGB(r, g, b);; 321 TColor::RGB2HLS(r, g, b, h, l, s);; 322 TColor::HLS2RGB(h, lmin, s, r, g, b);; 323 red[0] = r;; 324 green[0] = g;; 325 blue[0] = b;; 326 TColor::HLS2RGB(h, lmax, s, r, g, b);; 327 red[1] = r;; 328 green[1] = g;; 329 blue[1] = b;; 330 Int_t color_map_idx = TColor::CreateGradientColorTable(2, stop, red, green, blue, ncolors, 1., kFALSE);; 331 colmap[color] = color_map_idx;; 332 return (color_map_idx + light * (ncolors - 1));; 333}; 334 ; 335////////////////////////////////////////////////////////////////////////////////; 336/// Get currently drawn volume.; 337 ; 338TGeoVolume *TGeoPainter::GetDrawnVolume() const; 339{; 340 if (!gPad); 341 return nullptr;; 342 return fTopVolume;; 343}; 344 ; 345////////////////////////////////////////////////////////////////////////////////; 346/// Compute the closest distance of approach from point px,py to a volume.; 347 ; 348Int_t TGeoPainter::DistanceToPrimitiveVol(TGeoVolume *volume, Int_t px, Int_t py); 349{; 350 const Int_t big = 9999;; 351 const Int_t inaxis = 7;; 352 const Int_t maxdist = 5;; 353 ; 354 if (fTopVolume != volume); 355 fTopVolume = volume;; 356 TView *view = gP",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoPainter_8cxx_source.html:10952,green,green,10952,doc/master/TGeoPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoPainter_8cxx_source.html,3,['green'],['green']
Energy Efficiency,"construct from a generic linear algebra vector of at least size 3; 112 implementing operator [].; 113 \par v LAVector; 114 \par index0 index where coordinates starts (typically zero); 115 It works for all Coordinates types,; 116 ( x= v[index0] for Cartesian and r=v[index0] for Polar ); 117 */; 118 template <class LAVector>; 119 constexpr DisplacementVector3D(const LAVector & v, size_t index0 ) {; 120 fCoordinates = CoordSystem ( v[index0], v[index0+1], v[index0+2] );; 121 }; 122#endif; 123 ; 124 // compiler-generated copy ctor and dtor are fine.; 125 ; 126 // ------ assignment ------; 127 ; 128 /**; 129 Assignment operator from a displacement vector of arbitrary type; 130 */; 131 template <class OtherCoords>; 132 DisplacementVector3D & operator=; 133 ( const DisplacementVector3D<OtherCoords, Tag> & v) {; 134 fCoordinates = v.Coordinates();; 135 return *this;; 136 }; 137 ; 138 /**; 139 Assignment operator from a position vector; 140 (not necessarily efficient unless one or the other is Cartesian); 141 */; 142 template <class OtherCoords>; 143 DisplacementVector3D & operator=; 144 ( const PositionVector3D<OtherCoords,Tag> & rhs) {; 145 SetXYZ(rhs.x(), rhs.y(), rhs.z());; 146 return *this;; 147 }; 148 ; 149 ; 150 /**; 151 Assignment from a foreign 3D vector type, for example, Hep3Vector; 152 Precondition: v must implement methods x(), y() and z(); 153 */; 154 template <class ForeignVector>; 155 DisplacementVector3D & operator= ( const ForeignVector & v) {; 156 SetXYZ( v.x(), v.y(), v.z() );; 157 return *this;; 158 }; 159 ; 160 ; 161#ifdef LATER; 162 /**; 163 assign from a generic linear algebra vector of at least size 3; 164 implementing operator []. This could be also a C array; 165 \par v LAVector; 166 \par index0 index where coordinates starts (typically zero); 167 It works for all Coordinates types,; 168 ( x= v[index0] for Cartesian and r=v[index0] for Polar ); 169 */; 170 template <class LAVector>; 171 DisplacementVector3D & assignFrom(const LAVector & v, size_t i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/GenVector_2DisplacementVector3D_8h_source.html:4694,efficient,efficient,4694,doc/master/GenVector_2DisplacementVector3D_8h_source.html,https://root.cern,https://root.cern/doc/master/GenVector_2DisplacementVector3D_8h_source.html,1,['efficient'],['efficient']
Energy Efficiency,"coord; 96 ; 97 if (xmin >= xmax) return; // no op in case of bad values; 98 ; 99 // case the coordinate is larger than the current allocated vector size; 100 if (icoord >= fRanges.size() ) {; 101 RangeSet rx(1);; 102 rx[0] = std::make_pair(xmin, xmax);; 103 fRanges.resize(icoord+1);; 104 fRanges[icoord] = rx;; 105 return;; 106 }; 107 RangeSet & rs = fRanges[icoord];; 108 // case the vector of the ranges is empty in the given coordinate; 109 if ( rs.empty()) {; 110 rs.push_back(std::make_pair(xmin,xmax) );; 111 return;; 112 }; 113 // case of an already existing range; 114 // need to establish a policy (use OR or AND ); 115 ; 116 CleanRangeSet(icoord,xmin,xmax);; 117 // add the new one; 118 rs.push_back(std::make_pair(xmin,xmax) );; 119 // sort range in increasing values of xmax; 120 std::sort( rs.begin(), rs.end() , lessRange);; 121 ; 122}; 123 ; 124void DataRange::SetRange(unsigned int icoord , double xmin, double xmax ) {; 125 // set a new range [xmin,xmax] for the new coordinate icoord; 126 ; 127 if (xmin >= xmax) return; // no op in case of bad values; 128 ; 129 // case the coordinate is larger than the current allocated vector size; 130 if (icoord >= fRanges.size() ) {; 131 fRanges.resize(icoord+1);; 132 RangeSet rs(1);; 133 rs[0] = std::make_pair(xmin, xmax);; 134 fRanges[icoord] = rs;; 135 return;; 136 }; 137 // add range; 138 RangeSet & rs = fRanges[icoord];; 139 // deleting existing ones if (exists); 140 if (rs.size() > 1) MATH_WARN_MSG(""DataRange::SetRange"",""remove existing range and keep only the set one"");; 141 rs.resize(1);; 142 rs[0] = std::make_pair(xmin, xmax);; 143 return;; 144}; 145 ; 146bool DataRange::IsInside(double x, unsigned int icoord ) const {; 147 // check if a point is in range; 148 ; 149 if (Size(icoord) == 0) return true; // no range existing (is like -inf, +inf); 150 const RangeSet & ranges = fRanges[icoord];; 151 for (RangeSet::const_iterator itr = ranges.begin(); itr != ranges.end(); ++itr) {; 152 if ( x < (*itr).first ) return false;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/DataRange_8cxx_source.html:4038,allocate,allocated,4038,doc/master/DataRange_8cxx_source.html,https://root.cern,https://root.cern/doc/master/DataRange_8cxx_source.html,1,['allocate'],['allocated']
Energy Efficiency,"copyCache, const char* wgtVarName = 0); Protected constructor for internal use only. RooArgSet addWgtVar(const RooArgSet& origVars, const RooAbsArg* wgtVar); Helper function for constructor that adds optional weight variable to construct; total set of observables. RooAbsData* cacheClone(const RooAbsArg* newCacheOwner, const RooArgSet* newCacheVars, const char* newName = 0); Return a clone of this dataset containing only the cached variables. RooAbsData* emptyClone(const char* newName = 0, const char* newTitle = 0, const RooArgSet* vars = 0, const char* wgtVarName = 0) const; Return an empty clone of this dataset. If vars is not null, only the variables in vars; are added to the definition of the empty clone. void initialize(const char* wgtVarName); Initialize the dataset. If wgtVarName is not null, interpret the observable; with that name as event weight. RooAbsData* reduceEng(const RooArgSet& varSubset, const RooFormulaVar* cutVar, const char* cutRange = 0, Int_t nStart = 0, Int_t nStop = 2000000000, Bool_t copyCache = kTRUE); Implementation of RooAbsData virtual method that drives the RooAbsData::reduce() methods. ~RooDataSet(); Destructor. RooDataHist* binnedClone(const char* newName = 0, const char* newTitle = 0) const; Return binned clone of this dataset. Double_t weight() const; Return event weight of current event. Double_t weightSquared() const; Return event weight of current event. void weightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = SumW2) const. Double_t weightError(RooAbsData::ErrorType etype = SumW2) const. const RooArgSet* get(Int_t index) const; Return RooArgSet with coordinates of event 'index'. Double_t sumEntries() const. Double_t sumEntries(const char* cutSpec, const char* cutRange = 0) const; Return the sum of weights in all entries matching cutSpec (if specified); and in named range cutRange (if specified). Bool_t isWeighted() const; Return true if dataset contains weighted events. Bool_t isNonPoissonWeighted() const; Retur",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooDataSet.html:26161,reduce,reduceEng,26161,root/html534/RooDataSet.html,https://root.cern,https://root.cern/root/html534/RooDataSet.html,6,['reduce'],"['reduce', 'reduceEng']"
Energy Efficiency,"corder GUI class of the event recorder.; TGRectMap Rectangle used in TMap; TGRectangle Rectangle object; TGRedirectOutputGuard Exception safe output redirection; TGRegion Describes a region; TGRegionWithId Region with id, tooltip text and popup menu; TGResourcePool Graphics resource pool; TGRowLayout Row layout manager; TGScrollBar Scrollbar widget; TGScrollBarElement Scrollbar element (head, tail, slider); TGSearchDialog Text search dialog used by TGTextEdit widget; TGSearchType ; TGSelectBox TreeView dialog widget; TGSelectedPicture Selected looking picture; TGShapedFrame Shaped composite frame; TGShutter Shutter widget; TGShutterItem Shutter widget item; TGSimpleTable A simple table that owns it's interface.; TGSimpleTableInterface Interface to data in a 2D array of Double_t; TGSlider Slider widget abstract base class; TGSpeedo Base class for analog meter widget; TGSplitButton a split button widget; TGSplitFrame Splittable composite frame; TGSplitTool Split frame tool utility; TGSplitter A frame splitter abstract base class; TGStatusBar Status bar widget; TGString Graphics string; TGTRA GTRA shape; TGTab Tab widget; TGTabElement Little tab on tab widget; TGTabLayout Layout manager for TGTab widget; TGTable A table used to visualize data from diffent sources.; TGTableCell A single cell in a TGTable.; TGTableFrame A frame used internally by TGTable.; TGTableHeader Header for use in TGTable.; TGTableHeaderFrame A frame used internally by TGTable.; TGTableLayout Table layout manager; TGTableLayoutHints Class describing GUI table layout hints; TGText Text used by TGTextEdit; TGTextBuffer Text buffer used by widgets like TGTextEntry, etc.; TGTextButton A text button widget; TGTextEdit Text edit widget; TGTextEditor Simple text editor using TGTextEdit widget; TGTextEntry The TGTextEntry widget is a simple line editor for inputting text; TGTextLBEntry Text listbox entry; TGTextLayout Keep track of string measurement information.; TGTextLine Line in TGText; TGTextView Non-",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html524/ClassIndex.html:78413,meter,meter,78413,root/html524/ClassIndex.html,https://root.cern,https://root.cern/root/html524/ClassIndex.html,6,['meter'],['meter']
Energy Efficiency,"counter. void ReadLeavesMemberCounter(TBuffer& b); -- Read leaves into i/o buffers for this branch.; For split-class branch, base class branch, data member branch, or top-level branch.; which do not have a branch count and are a counter. void ReadLeavesCustomStreamer(TBuffer& b); -- Read leaves into i/o buffers for this branch.; Non TObject, Non collection classes with a custom streamer. void FillLeavesImpl(TBuffer& b); -- Unconfiguration Fill Leave function. void ReleaseObject(); -- Delete any object we may have allocated on a previous call to SetAddress. void Reset(Option_t* option = """"); Reset a Branch. Existing i/o buffers are deleted.; Entries, max and min are reset. void ResetAfterMerge(TFileMergeInfo* ); Reset a Branch after a Merge operation (drop data but keep customizations). void ResetAddress(); Set branch address to zero and free all allocated memory. void ResetDeleteObject(); -- Release ownership of any allocated objects. Note: This interface was added so that clone trees could; be told they do not own the allocated objects. void SetAddress(void* addobj); -- Point this branch at an object. For a sub-branch, addr is a pointer to the branch object. For a top-level branch the meaning of addr is as follows:. If addr is zero, then we allocate a branch object; internally and the branch is the owner of the allocated; object, not the caller. However the caller may obtain; a pointer to the branch object with GetObject(). Example:. branch->SetAddress(0);; Event* event = branch->GetObject();; ... Do some work. If addr is not zero, but the pointer addr points at is; zero, then we allocate a branch object and set the passed; pointer to point at the allocated object. The caller; owns the allocated object and is responsible for deleting; it when it is no longer needed. Example:. Event* event = 0;; branch->SetAddress(&event);; ... Do some work.; delete event;; event = 0;. If addr is not zero and the pointer addr points at is; also not zero, then the caller has allocated",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TBranchElement.html:30828,allocate,allocated,30828,root/html532/TBranchElement.html,https://root.cern,https://root.cern/root/html532/TBranchElement.html,4,['allocate'],['allocated']
Energy Efficiency,"cout << endl;; ; // Get with an argument loads a specific data point in row and returns; // a pointer to row argset. get() always returns the same pointer, unless; // an invalid row number is specified. In that case a null ptr is returned; d.get(900)->Print(""v"");; cout << endl;; ; // R e d u c i n g , A p p e n d i n g a n d M e r g i n g; // -------------------------------------------------------------; ; // The reduce() function returns a new dataset which is a subset of the original; cout << endl << "">> d1 has only columns x,c"" << endl;; std::unique_ptr<RooAbsData> d1{d.reduce({x, c})};; d1->Print(""v"");; ; cout << endl << "">> d2 has only column y"" << endl;; std::unique_ptr<RooAbsData> d2{d.reduce({y})};; d2->Print(""v"");; ; cout << endl << "">> d3 has only the points with y>5.17"" << endl;; std::unique_ptr<RooAbsData> d3{d.reduce(""y>5.17"")};; d3->Print(""v"");; ; cout << endl << "">> d4 has only columns x,c for data points with y>5.17"" << endl;; std::unique_ptr<RooAbsData> d4{d.reduce({x, c}, ""y>5.17"")};; d4->Print(""v"");; ; // The merge() function adds two data set column-wise; cout << endl << "">> merge d2(y) with d1(x,c) to form d1(x,c,y)"" << endl;; static_cast<RooDataSet&>(*d1).merge(&static_cast<RooDataSet&>(*d2));; d1->Print(""v"");; ; // The append() function adds two datasets row-wise; cout << endl << "">> append data points of d3 to d1"" << endl;; static_cast<RooDataSet&>(*d1).append(static_cast<RooDataSet&>(*d3));; d1->Print(""v"");; ; // O p e r a t i o n s o n b i n n e d d a t a s e t s; // ---------------------------------------------------------; ; // A binned dataset can be constructed empty, from an unbinned dataset, or; // from a ROOT native histogram (TH1,2,3); ; cout << "">> construct dh (binned) from d(unbinned) but only take the x and y dimensions,"" << endl; << "">> the category 'c' will be projected in the filling process"" << endl;; ; // The binning of real variables (like x,y) is done using their fit range; // 'get/setRange()' and number of specified fit ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf402__datahandling_8C.html:2984,reduce,reduce,2984,doc/master/rf402__datahandling_8C.html,https://root.cern,https://root.cern/doc/master/rf402__datahandling_8C.html,1,['reduce'],['reduce']
Energy Efficiency,"cribing a Vavilov distribution. ; The probability density function of the Vavilov distribution as function of Landau's parameter is given by: ; \[ p(\lambda_L; \kappa, \beta^2) =; \frac{1}{2 \pi i}\int_{c-i\infty}^{c+i\infty} \phi(s) e^{\lambda_L s} ds\]. where \(\phi(s) = e^{C} e^{\psi(s)}\) with \( C = \kappa (1+\beta^2 \gamma )\) and \(\psi(s)= s \ln \kappa + (s+\beta^2 \kappa); \cdot \left ( \int \limits_{0}^{1}; \frac{1 - e^{\frac{-st}{\kappa}}}{t} \,d t- \gamma \right ); - \kappa \, e^{\frac{-s}{\kappa}}\). \( \gamma = 0.5772156649\dots\) is Euler's constant.; For the class VavilovFast, Pdf returns the Vavilov distribution as function of Landau's parameter \(\lambda_L = \lambda_V/\kappa - \ln \kappa\), which is the convention used in the CERNLIB routines, and in the tables by S.M. Seltzer and M.J. Berger: Energy loss stragglin of protons and mesons: Tabulation of the Vavilov distribution, pp 187-203 in: National Research Council (U.S.), Committee on Nuclear Science: Studies in penetration of charged particles in matter, Nat. Akad. Sci. Publication 1133, Nucl. Sci. Series Report No. 39, Washington (Nat. Akad. Sci.) 1964, 388 pp. Available from Google books; Therefore, for small values of \(\kappa < 0.01\), pdf approaches the Landau distribution.; For values \(\kappa > 10\), the Gauss approximation should be used with \(\mu\) and \(\sigma\) given by Vavilov::mean(kappa, beta2) and sqrt(Vavilov::variance(kappa, beta2).; For values \(\kappa > 10\), the Gauss approximation should be used with \(\mu\) and \(\sigma\) given by Vavilov::mean(kappa, beta2) and sqrt(Vavilov::variance(kappa, beta2).; The original Vavilov pdf is obtained by v.Pdf(lambdaV/kappa-log(kappa))/kappa.; For detailed description see A. Rotondi and P. Montagna, Fast calculation of Vavilov distribution, Nucl. Instr. and Meth. B47 (1990) 215-224, which has been implemented in CERNLIB (G115).; The class stores coefficients needed to calculate \(p(\lambda; \kappa, \beta^2)\) for fixed values of \(\kapp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1VavilovFast.html:1409,charge,charged,1409,doc/master/classROOT_1_1Math_1_1VavilovFast.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1VavilovFast.html,1,['charge'],['charged']
Energy Efficiency,"ct () const;  Return kTRUE is the class inherits from TObject. ;  ; Bool_t IsVersioned () const;  ; void ls (Option_t *opt="""") const override;  The ls function lists the contents of a class on stdout. ;  ; void MakeCustomMenuList ();  Makes a customizable version of the popup menu list, i.e. ;  ; Bool_t MatchLegacyCheckSum (UInt_t checksum) const;  Return true if the checksum passed as argument is one of the checksum value produced by the older checksum calculation algorithm. ;  ; void Move (void *arenaFrom, void *arenaTo) const;  Register the fact that an object was moved from the memory location 'arenaFrom' to the memory location 'arenaTo'. ;  ; void * New (ENewType defConstructor=kClassNew, Bool_t quiet=kFALSE) const;  Return a pointer to a newly allocated object of this class. ;  ; void * New (void *arena, ENewType defConstructor=kClassNew) const;  Return a pointer to a newly allocated object of this class. ;  ; void * NewArray (Long_t nElements, ENewType defConstructor=kClassNew) const;  Return a pointer to a newly allocated array of objects of this class. ;  ; void * NewArray (Long_t nElements, void *arena, ENewType defConstructor=kClassNew) const;  Return a pointer to a newly allocated object of this class. ;  ; ObjectPtr NewObject (ENewType defConstructor=kClassNew, Bool_t quiet=kFALSE) const;  ; ObjectPtr NewObject (void *arena, ENewType defConstructor=kClassNew) const;  Return a pointer to a newly allocated object of this class. ;  ; ObjectPtr NewObjectArray (Long_t nElements, ENewType defConstructor=kClassNew) const;  Return a pointer to a newly allocated array of objects of this class. ;  ; ObjectPtr NewObjectArray (Long_t nElements, void *arena, ENewType defConstructor=kClassNew) const;  Return a pointer to a newly allocated object of this class. ;  ; virtual void PostLoadCheck ();  Do the initialization that can only be done after the CINT dictionary has been fully populated and can not be delayed efficiently. ;  ; Long_t Property () const override;  Re",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTClass.html:20302,allocate,allocated,20302,doc/v632/classTClass.html,https://root.cern,https://root.cern/doc/v632/classTClass.html,3,['allocate'],['allocated']
Energy Efficiency,"ct base classes. Bool_t IsFolder() const; -- Return kTRUE if more than one leaf, kFALSE otherwise. Bool_t IsMissingCollection() const; -- Detect a collection written using a zero pointer in old versions of root.; In versions of ROOT older than 4.00/03, if a collection (TClonesArray; or STL container) was split but the pointer to the collection was zeroed; out, nothing was saved. Hence there is no __easy__ way to detect the; case. In newer versions, a zero is written so that a 'missing' collection; appears to be an empty collection. void Print(Option_t* option = """") const; Print branch parameters. void PrintValue(Int_t i) const; -- Prints values of leaves. void ReadLeaves(TBuffer& b); -- Read leaves into i/o buffers for this branch. void ReleaseObject(); -- Delete any object we may have allocated on a previous call to SetAddress. void Reset(Option_t* option = """"); -- Reset a Branch. Existing i/o buffers are deleted.; Entries, max and min are reset. void ResetAddress(); Set branch address to zero and free all allocated memory. void ResetDeleteObject(); -- Release ownership of any allocated objects. Note: This interface was added so that clone trees could; be told they do not own the allocated objects. void SetAddress(void* addobj); -- Point this branch at an object. For a sub-branch, addr is a pointer to the branch object. For a top-level branch the meaning of addr is as follows:. If addr is zero, then we allocate a branch object; internally and the branch is the owner of the allocated; object, not the caller. However the caller may obtain; a pointer to the branch object with GetObject(). Example:. branch->SetAddress(0);; Event* event = branch->GetObject();; ... Do some work. If addr is not zero, but the pointer addr points at is; zero, then we allocate a branch object and set the passed; pointer to point at the allocated object. The caller; owns the allocated object and is responsible for deleting; it when it is no longer needed. Example:. Event* event = 0;; branch->S",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TBranchElement.html:23493,allocate,allocated,23493,root/html526/TBranchElement.html,https://root.cern,https://root.cern/root/html526/TBranchElement.html,1,['allocate'],['allocated']
Energy Efficiency,"ct model should be less than the value chi2.; 630///; 631/// The returned probability corresponds to 1-P(a,x),; 632/// which denotes the probability that an observed Chi-squared exceeds; 633/// the value chi2 by chance, even for a correct model.; 634///; 635/// \author NvE 14-nov-1998 UU-SAP Utrecht; 636 ; 637Double_t TMath::Prob(Double_t chi2,Int_t ndf); 638{; 639 if (ndf <= 0) return 0; // Set CL to zero in case ndf<=0; 640 ; 641 if (chi2 <= 0) {; 642 if (chi2 < 0) return 0;; 643 else return 1;; 644 }; 645 ; 646 return ::ROOT::Math::chisquared_cdf_c(chi2,ndf);; 647}; 648 ; 649////////////////////////////////////////////////////////////////////////////////; 650/// Calculates the Kolmogorov distribution function,; 651///; 652/// \f[; 653/// P(z) = 2 \sum_{j=1}^{\infty} (-1)^{j-1} e^{-2 j^2 z^2}; 654/// \f]; 655///; 656/// which gives the probability that Kolmogorov's test statistic will exceed; 657/// the value z assuming the null hypothesis. This gives a very powerful; 658/// test for comparing two one-dimensional distributions.; 659/// see, for example, Eadie et al, ""statistical Methods in Experimental; 660/// Physics', pp 269-270).; 661///; 662/// This function returns the confidence level for the null hypothesis, where:; 663/// - \f$ z = dn \sqrt{n} \f$, and; 664/// - \f$ dn \f$ is the maximum deviation between a hypothetical distribution; 665/// function and an experimental distribution with; 666/// - \f$ n \f$ events; 667///; 668/// NOTE: To compare two experimental distributions with m and n events,; 669/// use \f$ z = \sqrt{m n/(m+n)) dn} \f$; 670///; 671/// Accuracy: The function is far too accurate for any imaginable application.; 672/// Probabilities less than \f$ 10^{-15} \f$ are returned as zero.; 673/// However, remember that the formula is only valid for ""large"" n.; 674///; 675/// Theta function inversion formula is used for z <= 1; 676///; 677/// This function was translated by Rene Brun from PROBKL in CERNLIB.; 678 ; 679Double_t TMath::KolmogorovProb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMath_8cxx_source.html:20905,power,powerful,20905,doc/master/TMath_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html,1,['power'],['powerful']
Energy Efficiency,"ct named name is inside this pad or in pads inside this pad.Definition TPad.cxx:2700; TPolyMarkerA PolyMarker is defined by an array on N points in a 2-D space.Definition TPolyMarker.h:31; TSpectrumFitAdvanced 1-dimensional spectra fitting functions.Definition TSpectrumFit.h:18; TSpectrumFit::SetPeakParametersvoid SetPeakParameters(Double_t sigma, Bool_t fixSigma, const Double_t *positionInit, const Bool_t *fixPosition, const Double_t *ampInit, const Bool_t *fixAmp)This function sets the following fitting parameters of peaks:Definition TSpectrumFit.cxx:2658; TSpectrumFit::FitAwmivoid FitAwmi(Double_t *source)This function fits the source spectrum.Definition TSpectrumFit.cxx:822; TSpectrumFit::TSpectrumFitTSpectrumFit(void)Default constructor.Definition TSpectrumFit.cxx:37; TSpectrumFit::GetAmplitudesDouble_t * GetAmplitudes() constDefinition TSpectrumFit.h:116; TSpectrumFit::SetFitParametersvoid SetFitParameters(Int_t xmin, Int_t xmax, Int_t numberIterations, Double_t alpha, Int_t statisticType, Int_t alphaOptim, Int_t power, Int_t fitTaylor)This function sets the following fitting parameters:Definition TSpectrumFit.cxx:2610; TSpectrumFit::kFitTaylorOrderFirst@ kFitTaylorOrderFirstDefinition TSpectrumFit.h:82; TSpectrumFit::kFitAlphaHalving@ kFitAlphaHalvingDefinition TSpectrumFit.h:74; TSpectrumFit::kFitOptimChiCounts@ kFitOptimChiCountsDefinition TSpectrumFit.h:71; TSpectrumFit::kFitPower2@ kFitPower2Definition TSpectrumFit.h:76; TSpectrumFit::GetPositionsDouble_t * GetPositions() constDefinition TSpectrumFit.h:122; TSpectrumAdvanced Spectra Processing.Definition TSpectrum.h:18; TSpectrum::SearchHighResInt_t SearchHighRes(Double_t *source, Double_t *destVector, Int_t ssize, Double_t sigma, Double_t threshold, bool backgroundRemove, Int_t deconIterations, bool markov, Int_t averWindow)One-dimensional high-resolution peak search function.Definition TSpectrum.cxx:2119; TSpectrum::GetPositionXDouble_t * GetPositionX() constDefinition TSpectrum.h:58; bool; double; int. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSpectrumFit.html:37743,power,power,37743,doc/master/classTSpectrumFit.html,https://root.cern,https://root.cern/doc/master/classTSpectrumFit.html,1,['power'],['power']
Energy Efficiency,"ct of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual const Event * Transform (const Event *const, Int_t cls) const;  identity transform returns same event ;  ; void WriteTransformationToStream (std::ostream &) const;  ;  Public Member Functions inherited from TMVA::VariableTransformBase;  VariableTransformBase (DataSetInfo &dsi, Types::EVariableTransform tf, const TString &trfName);  standard constructor ;  ; virtual ~VariableTransformBase (void);  ; virtual void CountVariableTypes (UInt_t &nvars, UInt_t &ntgts, UInt_t &nspcts) const;  count variables, targets and spectators ;  ; virtual Bool_t GetInput (const Event *event, std::vector< Float_t > &input, std::vector< Char_t > &mask, Bool_t backTransform=kFALSE) const;  select the values from the event ;  ; virtual const char * GetName () const;  Returns name of object. ;  ; TString GetShortName () const;  ; virtual std::vector< TString > * GetTransformationStrings (Int_t cls) const;  TODO --> adapt to variable,target,spectator selection default transformation output --> only indicate that transformation occurred. ;  ; Types::EVariableTransform GetVariableTransform () const;  ; Bool_t IsCreated () const;  ; Bool_t IsEnabled () const;  ; Bool_t IsNormalised () const;  ; MsgLogger & Log () const;  ; virtual void PrintTransformation (std::ostream &);  ; virtual void SelectInput (const TString &inputVariables, Bool_t putIntoVariables=kFALSE);  select the variables/targets/spectators which serve as input to the transformation ;  ; void SetEnabled (Bool_t e);  ; void SetNormalise (Bool_t n);  ; virtual void SetOutput (Event *event, std::vector< Float_t > &output, std::vector< Char_t > &mask, const Event *oldEvent=nullptr, Bool_t backTransform=kFALSE) const;  select the values from the event ;  ; void SetOutputDataSetInfo (DataSetInfo *outputDsi);  ; void SetTMVAVersion (TMVAVersion_t v);  ; void SetUseSignalTransform (Bool_t e=kTRUE);  ; const std::vector< TMVA::VariableInfo > &",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1VariableIdentityTransform.html:2428,adapt,adapt,2428,doc/master/classTMVA_1_1VariableIdentityTransform.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1VariableIdentityTransform.html,1,['adapt'],['adapt']
Energy Efficiency,"ct*fObjectX!pointer to an object corresponding to X; TObject*fObjectY!pointer to an object corresponding to Y; TStringTNamed::fTitleobject title; TStringfVarXX variable; TStringfVarYY variable; Double_t*TGraph::fX[fNpoints] array of X points; Double_t*TGraph::fY[fNpoints] array of Y points. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TCutG(); TCutG default constructor. TCutG(const TCutG& cutg); TCutG copy constructor. TCutG(const char* name, Int_t n); TCutG normal constructor. TCutG(const char* name, Int_t n, const Float_t* x, const Float_t* y); TCutG normal constructor. TCutG(const char* name, Int_t n, const Double_t* x, const Double_t* y); TCutG normal constructor. ~TCutG(); TCutG destructor. TCutG & operator=(const TCutG& ); Assignment operator. Double_t Area() const; Compute the area inside this TCutG; The algorithm uses Stoke's theorem over the border of the closed polygon.; Just as a reminder: Stoke's theorem reduces a surface integral; to a line integral over the border of the surface integral. void Center(Double_t& cx, Double_t& cy) const; Compute the center x,y of this TCutG; The algorithm uses Stoke's theorem over the border of the closed polygon.; Just as a reminder: Stoke's theorem reduces a surface integral; to a line integral over the border of the surface integral. Double_t IntegralHist(TH2* h, Option_t* option = """") const; Compute the integral of 2-d histogram h for all bins inside the cut; if option ""width"" is specified, the integral is the sum of; the bin contents multiplied by the bin width in x and in y. void SavePrimitive(ostream& out, Option_t* option = """"); Save primitive as a C++ statement(s) on output stream out. void SetObjectX(TObject* obj); Set the X object (and delete the previous one if any). void SetObjectY(TObject* obj); Set the Y object (and delete the previous one if any). void SetVarX(const char* varx); Set X variable. void SetVarY(const char* vary); Set Y variable. void Streamer(TBuffe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TCutG.html:17109,reduce,reduces,17109,root/html534/TCutG.html,https://root.cern,https://root.cern/root/html534/TCutG.html,3,['reduce'],['reduces']
Energy Efficiency,"ct::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TGeoHelix::EGeoHelixTypeskHelixCircle; static TGeoHelix::EGeoHelixTypeskHelixNeedUpdate; static TGeoHelix::EGeoHelixTypeskHelixStraigth; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. Double_tfB[3]normalized direction for magnetic field; Double_tfCcurvature in XY plane; Double_tfDir[3]direction after a step; Double_tfDirInit[3]normalized initial direction; TGeoHMatrix*fMatrixtransformation of local helix frame to MARS; Double_tfPhiphi angle; Double_tfPoint[3]point after a step; Double_tfPointInit[3]initial point; Int_tfQright/left-handed (+/- 1) - ""charge""; Double_tfSZ step of the helix / 2*PI; Double_tfStepcurrent step. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoHelix(); Dummy constructor. TGeoHelix(Double_t curvature, Double_t step, Int_t charge = 1); Normal constructor. ~TGeoHelix(); Destructor. Double_t ComputeSafeStep(Double_t epsil = 9.9999999999999995E-7) const; Compute safe linear step that can be made such that the error; between linear-helix extrapolation is less than EPSIL. void InitPoint(Double_t x0, Double_t y0, Double_t z0); Initialize coordinates of a point on the helix. void InitPoint(Double_t* point); Set initial point on the helix. void InitDirection(Double_t dirx, Double_t diry, Double_t dirz, Bool_t is_normalized = kTRUE); Initialize particle direction (tangent on the helix in initial point). void InitDirection(D",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoHelix.html:8004,charge,charge,8004,root/html602/TGeoHelix.html,https://root.cern,https://root.cern/root/html602/TGeoHelix.html,2,['charge'],['charge']
Energy Efficiency,"ct::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); TPolyMarker3D&operator=(const TPolyMarker3D&). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Int_tfLastPointThe index of the last filled point; Color_tTAttMarker::fMarkerColorMarker color index; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; Int_tfNNumber of allocated points; TStringfNameName of polymarker; TStringfOptionOptions; Float_t*fP[3*fN] Array of X,Y,Z coordinates. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPolyMarker3D(); 3-D polymarker default constructor. TPolyMarker3D(Int_t n, Marker_t marker = 1, Option_t* option = """"); 3-D polymarker normal constructor with initialization to 0. TPolyMarker3D(Int_t n, Float_t* p, Marker_t marker = 1, Option_t* option = """"); 3-D polymarker constructor. Polymarker is initialized with p. TPolyMarker3D(Int_t n, Double_t* p, Marker_t marker = 1, Option_t* option = """"); 3-D polymarker constructor. Polymarker is initialized with p; (cast to float). TPolyMarker3D& operator=(const TPolyMarker3D& ); assignement operator. ~TPolyMarker3D(); 3-D polymarker destructor. TPolyMarker3D(const TPolyMarker3D& p); 3-D polymarker copy ctor. void Copy(TObject& polymarker) const; Copy polymarker to polymarker obj. Int_t Dis",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TPolyMarker3D.html:7736,allocate,allocated,7736,root/html534/TPolyMarker3D.html,https://root.cern,https://root.cern/root/html534/TPolyMarker3D.html,1,['allocate'],['allocated']
Energy Efficiency,"ct::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum EGeoHelixTypes { kHelixNeedUpdate; kHelixStraigth; kHelixCircle; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. Double_tfB[3]normalized direction for magnetic field; Double_tfCcurvature in XY plane; Double_tfDir[3]direction after a step; Double_tfDirInit[3]normalized initial direction; TGeoHMatrix*fMatrixtransformation of local helix frame to MARS ; Double_tfPhiphi angle; Double_tfPoint[3]point after a step; Double_tfPointInit[3]initial point; Int_tfQright/left-handed (+/- 1) - ""charge""; Double_tfSZ step of the helix / 2*PI; Double_tfStepcurrent step. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoHelix(); Dummy constructor. TGeoHelix(Double_t curvature, Double_t step, Int_t charge = 1); Normal constructor. ~TGeoHelix(); Destructor. Double_t ComputeSafeStep(Double_t epsil = 1E-6) const; Compute safe linear step that can be made such that the error; between linear-helix extrapolation is less than EPSIL. void InitPoint(Double_t x0, Double_t y0, Double_t z0); Initialize coordinates of a point on the helix. void InitPoint(Double_t* point); Set initial point on the helix. void InitDirection(Double_t dirx, Double_t diry, Double_t dirz, Bool_t is_normalized = kTRUE); Initialize particle direction (tangent on the helix in initial point). void InitDirection(Double_t* dir, Bo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoHelix.html:7359,charge,charge,7359,root/html528/TGeoHelix.html,https://root.cern,https://root.cern/root/html528/TGeoHelix.html,3,['charge'],['charge']
Energy Efficiency,"ct::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. static voidDiagProd(const TVectorD& diag, Double_t tol, Double_t& d1, Double_t& d2); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual const TMatrixDBase&GetDecompMatrix() const; Int_tHager(Double_t& est, Int_t iter = 5); voidTObject::MakeZombie(); voidResetStatus(). Data Members; public:. enum EMatrixDecompStat { kInit; kPatternSet; kValuesSet; kMatrixSet; kDecomposed; kDetermined; kCondition; kSingular; };; enum { kWorkMax; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Int_tfColLwbColumn lower bound of decomposed matrix; Double_tfConditionmatrix condition number; Double_tfDet1determinant mantissa; Double_tfDet2determinant exponent for powers of 2; Int_tfRowLwbRow lower bound of decomposed matrix; Double_tfTolsqrt(epsilon); epsilon is smallest number number so that 1+epsilon > 1. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Int_t Hager(Double_t& est, Int_t iter = 5). void DiagProd(const TVectorD& diag, Double_t tol, Double_t& d1, Double_t& d2). Double_t Condition(); Matrix condition number. Bool_t MultiSolve(TMatrixD& B); Solve set of equations with RHS in columns of B. void Det(Double_t& d1, Double_t& d2); Matrix determinant det = d1*TMath::Power(2.,d2). void Print(Option_t* opt = """") const; Print class members. TDecompBase & operator=(const TDecompBase& source); Assignment operator. Double_t SetTol(Double_t newTol). void ResetStatus(); { for (Int_t i = 14; i < 22; i++) ResetBit(BIT(i)); }. const TMatrixDBase & GetDecompMatrix() const. virtual ~TDecompBase(); {}. Double_t GetTol() const; { return fTol; }. Double_t GetDet1() const; { return fDet1; }. Double_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TDecompBase.html:10040,power,powers,10040,root/html528/TDecompBase.html,https://root.cern,https://root.cern/root/html528/TDecompBase.html,4,['power'],['powers']
Energy Efficiency,"ct::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMatrixDSparsefAoriginal matrix; needed for the iterative solving procedure; Double_tfCntl[6]float control numbers; TArrayIfColFact; Int_tTDecompBase::fColLwbColumn lower bound of decomposed matrix; Double_tTDecompBase::fConditionmatrix condition number; Double_tTDecompBase::fDet1determinant mantissa; Double_tTDecompBase::fDet2determinant exponent for powers of 2; TArrayDfFactsize of fFact array; may be increased during the numerical factorization; Double_tfIPessimismamounts by which to increase allocated factorization space when; Int_tfIcntl[31]integer control numbers; TArrayIfIkeeppivot sequence and temporary storage information; Int_tfInfo[21]array used for communication between programs; TArrayIfIw; TArrayIfIw1; TArrayIfIw2; Int_tfMaxfrt; Int_tfNnonZeros; Int_tfNrows; Int_tfNsteps; Double_tfPrecisionprecision we demand from the linear system solver. If it isn't; Double_tfRPessimisminadequate space is detected. fIPessimism is for array ""fIw"",; TArrayIfRowFact; Int_tTDecompBase::fRowLwbRow lower bound of decomposed matrix; Double_tTDecompBase::fTolsqrt(epsilon); epsilon is smallest number number so that 1+epsilon > 1; Int_tfVerbose; TArrayDfWtemporary storage for the factorization; static TDecompBase::EMatrixDecompStatTDecompBase::kCondition; static TDecompBase::EMatrixDecompStatTDecompBase::kDecomposed; static TDecompBase::EMatrixDecompStatTDecompBase::kDetermined; static TDecompBase::EMatrixDecompStatTDec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TDecompSparse.html:10488,power,powers,10488,root/html602/TDecompSparse.html,https://root.cern,https://root.cern/root/html602/TDecompSparse.html,4,"['allocate', 'power']","['allocated', 'powers']"
Energy Efficiency,"ct::kZombie. protected:. Bool_tRooAbsCollection::_allRRVAll contents are RRV; RooLinkedListRooAbsCollection::_listActual object store; TStringRooAbsCollection::_nameOur name.; static Int_tRooPrintable::_nameLength; Bool_tRooAbsCollection::_ownContFlag to identify a list that owns its contents.; static char*_poolBegin! Start of memory pool; static char*_poolCur! Next free slot in memory pool; static char*_poolEnd! End of memory pool; TNamed*RooAbsCollection::_structureTag! Structure tag; TNamed*RooAbsCollection::_typedStructureTag! Typed structure tag. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void cleanup(); Clear memoery pool on exit to avoid reported memory leaks. void* operator new(size_t bytes); Overloaded new operator guarantees that all RooArgSets allocated with new; have a unique address, a property that is exploited in several places; in roofit to quickly index contents on normalization set pointers.; The memory pool only allocates space for the class itself. The elements; stored in the set are stored outside the pool. void* operator new(size_t bytes, void* ptr); Overloaded new operator with placement does not guarante that all; RooArgSets allocated with new have a unique address, but uses the global; operator. void operator delete(void* ptr); Memory is owned by pool, we need to do nothing to release it. RooArgSet(); Default constructor. RooArgSet(const RooArgList& list); Constructor from a RooArgList. If the list contains multiple; objects with the same name, only the first is store in the set.; Warning messages will be printed for dropped items. RooArgSet(const RooArgList& list, const RooAbsArg* var1); Constructor from a RooArgList. If the list contains multiple; objects with the same name, only the first is store in the set.; Warning messages will be printed for dropped items. RooArgSet(const char* name); Empty set constructor. RooArgSet(const RooArgSet& set1, const RooArgSet& set2, const char* name = """"); ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooArgSet.html:15872,allocate,allocates,15872,root/html602/RooArgSet.html,https://root.cern,https://root.cern/root/html602/RooArgSet.html,2,['allocate'],['allocates']
Energy Efficiency,"ctDealloc(void* vp); static voidObjectDealloc(void* vp, void* ptr); TStorage&operator=(const TStorage&); static voidPrintStatistics(); static void*ReAlloc(void* vp, size_t size); static void*ReAlloc(void* vp, size_t size, size_t oldsize); static char*ReAllocChar(char* vp, size_t size, size_t oldsize); static Int_t*ReAllocInt(Int_t* vp, size_t size, size_t oldsize); static voidRemoveStat(void* p); static voidSetCustomNewDelete(); static voidSetFreeHook(FreeHookFun_t func, void* data); static voidSetMaxBlockSize(size_t size); static voidSetReAllocHooks(ReAllocFun_t func1, ReAllocCFun_t func2); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TStorage(); TStorage(const TStorage&). Data Members; private:. static FreeHookFun_tfgFreeHookfunction called on free; static void*fgFreeHookDatadata used by this function; static Bool_tfgHasCustomNewDeletetrue if using ROOT's new/delete; static size_tfgMaxBlockSizelargest block allocated; static ReAllocCFun_tfgReAllocCHookcustom ReAlloc with length check; static ReAllocFun_tfgReAllocHookcustom ReAlloc; static const UInt_tkObjectAllocMemValue. Class Charts. Inheritance Chart:. TStorage. Function documentation; void EnterStat(size_t size, void* p); Register a memory allocation operation. If desired one can trap an; allocation of a certain size in case one tries to find a memory; leak of that particular size. This function is only called via; the ROOT custom new operators. void RemoveStat(void* p); Register a memory free operation. This function is only called via; the custom ROOT delete operator. void * Alloc(size_t size); Allocate a block of memory, that later can be resized using; TStorage::ReAlloc(). void Dealloc(void* ptr); De-allocate block of memory, that was allocated via TStorage::Alloc(). void * ReAlloc(void* vp, size_t size); Reallocate (i.e. resize) block of memory. Don't use if size is larger; than old size, use ReAlloc(void",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TStorage.html:2903,allocate,allocated,2903,root/html602/TStorage.html,https://root.cern,https://root.cern/root/html602/TStorage.html,2,['allocate'],['allocated']
Energy Efficiency,"ctPtr NewObject () const;  Construct a new container object and return its address. ;  ; virtual TClass::ObjectPtr NewObject (void *arena) const;  Construct a new container object at the address given by arena ;  ; virtual TClass::ObjectPtr NewObjectArray (Int_t nElements) const;  Construct an array of nElements container objects and return the base address of the array. ;  ; virtual TClass::ObjectPtr NewObjectArray (Int_t nElements, void *arena) const;  Construct an array of nElements container objects at the address given by arena ;  ; char * operator[] (UInt_t idx) const;  Return the address of the value at index idx ;  . Protected Types; typedef void(TGenCollectionStreamer::* ReadBuffer_t) (TBuffer &b, void *obj, const TClass *onFileClass);  ;  Protected Types inherited from TGenCollectionProxy; typedef void *(* ArrIterfunc_t) (void *from, size_t size);  ; typedef void *(* Collectfunc_t) (void *from, void *to);  ; typedef ROOT::Detail::TCollectionProxyInfo::Environ< char[64]> Env_t;  ; typedef ROOT::Detail::TCollectionProxyInfo::EnvironBase EnvironBase_t;  ; typedef void *(* Feedfunc_t) (void *from, void *to, size_t size);  ; typedef std::vector< EnvironBase_t * > Proxies_t;  ; typedef void(* Sizing_t) (void *obj, size_t size);  ; typedef std::vector< TStaging * > Staged_t;  Collection of pre-allocated staged array for associative containers. ;  . Protected Member Functions; template<typename From , typename To > ; void ConvertBufferVectorPrimitives (TBuffer &b, void *obj, Int_t nElements);  ; template<typename To > ; void ConvertBufferVectorPrimitivesDouble32 (TBuffer &b, void *obj, Int_t nElements);  ; template<typename To > ; void ConvertBufferVectorPrimitivesFloat16 (TBuffer &b, void *obj, Int_t nElements);  ; template<typename To > ; void DispatchConvertBufferVectorPrimitives (TBuffer &b, void *obj, Int_t nElements, const TVirtualCollectionProxy *onfileProxy);  ; void ReadBufferDefault (TBuffer &b, void *obj, const TClass *onFileClass);  ; void ReadBufferGe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGenCollectionStreamer.html:7785,allocate,allocated,7785,doc/master/classTGenCollectionStreamer.html,https://root.cern,https://root.cern/doc/master/classTGenCollectionStreamer.html,1,['allocate'],['allocated']
Energy Efficiency,"ction documentation; TMemStatMng(); Default constructor. void Init(); Initialize MemStat manager - used only by instance method. TMemStatMng* GetInstance(); GetInstance - a static function; Initialize a singleton of MemStat manager. void Close(); Close - a static function; This method stops the manager,; flashes all the buffered data and closes the output tree. ~TMemStatMng(); if an instance is destructed - the hooks are reseted to old hooks. void SetBufferSize(Int_t buffersize); Set the maximum number of alloc/free calls to be buffered.; if the alloc and free are in the buffer, the corresponding entries; are not saved tio the Tree, reducing considerably the Tree output size. void SetMaxCalls(Int_t maxcalls); Set the maximum number of new/delete registered in the output Tree. void Enable(); Enable memory hooks. void Disable(); Disble memory hooks. void MacAllocHook(void* ptr, size_t size); AllocHook - a static function; a special memory hook for Mac OS X memory zones.; Triggered when memory is allocated. void MacFreeHook(void* ptr); AllocHook - a static function; a special memory hook for Mac OS X memory zones.; Triggered when memory is deallocated. void * AllocHook(size_t size, const void* ); AllocHook - a static function; A glibc memory allocation hook. void FreeHook(void* ptr, const void* ); FreeHook - a static function; A glibc memory deallocation hook. Int_t generateBTID(UChar_t* CRCdigest, Int_t stackEntries, void** stackPointers); An internal function, which returns a bitid for a corresponding CRC digest; cache variables. void AddPointer(void* ptr, Int_t size); Add pointer to table.; This method is called every time when any of the hooks are triggered.; The memory de-/allocation information will is recorded. void FillTree(); loop on all entries in the buffer and fill the output Tree; entries with alloc and free in the buffer are eliminated. TMemStatMng(). void SetUseGNUBuiltinBacktrace(Bool_t newVal); stack data members. » Author: Anar Manafov (A.Manafov@gsi.d",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/Memstat__TMemStatMng.html:8544,allocate,allocated,8544,root/html602/Memstat__TMemStatMng.html,https://root.cern,https://root.cern/root/html602/Memstat__TMemStatMng.html,2,['allocate'],['allocated']
Energy Efficiency,"ction members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Fit::BinData. class ROOT::Fit::BinData: public ROOT::Fit::FitData. Class describing the binned data sets :; vectors of x coordinates, y values and optionally error on y values and error on coordinates; The dimension of the coordinate is free; There are 4 different options:; - only coordinates and values (for binned likelihood fits) : kNoError; - coordinate, values and error on values (for normal least square fits) : kValueError; - coordinate, values, error on values and coordinates (for effective least square fits) : kCoordError; - corrdinate, values, error on coordinates and asymmettric error on valyes : kAsymError. In addition there is the option to construct Bindata copying the data in (using the DataVector class); or using pointer to external data (DataWrapper) class.; In general is found to be more efficient to copy the data.; In case of really large data sets for limiting memory consumption then the other option can be used; Specialized constructor exists for data up to 3 dimensions. When the data are copying in the number of points can be set later (or re-set) using Initialize and; the data are inserted one by one using the Add method.; It is mandatory to set the size before using the Add method. @ingroup FitData. Function Members (Methods); public:. virtual~BinData(); voidAdd(double x, double y); voidAdd(const double* x, double val); voidAdd(double x, double y, double ey); voidAdd(const double* x, double val, double eval); voidAdd(double x, double y, double ex, double ey); voidAdd(const double* x, double val, const double* ex, double eval); voidAdd(double x, double y, double ex, double eyl, double eyh); voidAdd(const double* x, double val, const double* ex, double elval, double ehval); voidAddBinUpEdge(const double* xup); ROOT::Fit::BinDataBinData(const ROOT::Fit::BinData&); ROOT::Fit::BinDataBinData(unsigned int maxpoints = 0, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Fit__BinData.html:1135,consumption,consumption,1135,root/html528/ROOT__Fit__BinData.html,https://root.cern,https://root.cern/root/html528/ROOT__Fit__BinData.html,6,['consumption'],['consumption']
Energy Efficiency,"ction members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Fit::BinData. class ROOT::Fit::BinData: public ROOT::Fit::FitData. Class describing the binned data sets :; vectors of x coordinates, y values and optionally error on y values and error on coordinates; The dimension of the coordinate is free; There are 4 different options:; - only coordinates and values (for binned likelihood fits) : kNoError; - coordinate, values and error on values (for normal least square fits) : kValueError; - coordinate, values, error on values and coordinates (for effective least square fits) : kCoordError; - corrdinate, values, error on coordinates and asymmettric error on valyes : kAsymError. In addition there is the option to construct Bindata copying the data in (using the DataVector class); or using pointer to external data (DataWrapper) class.; In general is found to be more efficient to copy the data.; In case of really large data sets for limiting memory consumption then the other option can be used; Specialized constructor exists for data up to 3 dimensions. When the data are copying in the number of points can be set later (or re-set) using Initialize and; the data are inserted one by one using the Add method.; It is mandatory to set the size before using the Add method. @ingroup FitData. Function Members (Methods); public:. virtual~BinData(); voidAdd(double x, double y); voidAdd(const double* x, double val); voidAdd(double x, double y, double ey); voidAdd(const double* x, double val, double eval); voidAdd(double x, double y, double ex, double ey); voidAdd(const double* x, double val, const double* ex, double eval); voidAdd(double x, double y, double ex, double eyl, double eyh); voidAddBinUpEdge(const double* binwidth); ROOT::Fit::BinDataBinData(const ROOT::Fit::BinData&); ROOT::Fit::BinDataBinData(unsigned int maxpoints = 0, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError); ROOT::Fit::BinDataBinData(const ROOT::Fit::DataOptions& opt, u",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Fit__BinData.html:1135,consumption,consumption,1135,root/html526/ROOT__Fit__BinData.html,https://root.cern,https://root.cern/root/html526/ROOT__Fit__BinData.html,1,['consumption'],['consumption']
Energy Efficiency,"ction of , if the angle; ; between ; and ; is smaller than; an upper limit , defined by the user; (TMultiDimFit::SetMaxAngle); ; However, the method automatically readjusts the value of this angle; while fitting is in progress, in order to make the selection criteria; less and less difficult to be fulfilled. The result is that the; functions contributing most to the reduction of are chosen first; (TMultiDimFit::TestFunction).; ; In case isn't defined, an alternative method of; performing this second test is used: The ; function; ; is accepted if (refer also to equation (13)); . (14). where is the sum of the first residuals from the; functions previously accepted; and is the total number; of functions allowed in the final expression of the fit (defined by; user).; ; >From this we see, that by restricting -- the number of; terms in the final model -- the fit is more difficult to perform,; since the above selection criteria is more limiting.; ; The more coefficients we evaluate, the more the sum of squares of; residuals will be reduced. We can evaluate before inverting; ; as shown below.; . Coefficients and Coefficient Errors. Having found a parameterization, that is the 's and , that; minimizes , we still need to determine the coefficients; . However, it's a feature of how we choose the significant; functions, that the evaluation of the 's becomes trivial; [5]. To derive ; , we first note that; equation (4) can be written as; . (15). where; . (16). Consequently, ; is an upper triangle matrix, which can be; readily inverted. So we now evaluate; . (17). The model ; can therefore be written as; . The original model ; is therefore identical with; this if; . (18). The reason we use ; rather then; ; is to save storage, since; ; can be stored in the same matrix as; . (TMultiDimFit::MakeCoefficients). The errors in; the coefficients is calculated by inverting the curvature matrix; of the non-orthogonal functions [1]; (TMultiDimFit::MakeCoefficientErrors).; . Considerations; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMultiDimFit.html:8827,reduce,reduced,8827,root/html534/TMultiDimFit.html,https://root.cern,https://root.cern/root/html534/TMultiDimFit.html,3,['reduce'],['reduced']
Energy Efficiency,"ction structure from a C++ function iterator and size and number of residuals; 78 template<class FuncVector>; 79 void SetFunction(const FuncVector & f, unsigned int nres, unsigned int npar ) {; 80 const void * p = &f;; 81 assert (p != 0);; 82 fFunc.f = &GSLMultiFitFunctionAdapter<FuncVector >::F;; 83 fFunc.df = &GSLMultiFitFunctionAdapter<FuncVector >::Df;; 84 fFunc.fdf = &GSLMultiFitFunctionAdapter<FuncVector >::FDf;; 85 fFunc.n = nres;; 86 fFunc.p = npar;; 87 fFunc.params = const_cast<void *>(p);; 88 }; 89 ; 90 gsl_multifit_function_fdf * GetFunc() { return &fFunc; }; 91 ; 92 ; 93 private:; 94 ; 95 gsl_multifit_function_fdf fFunc;; 96 ; 97};; 98 ; 99 ; 100 ; 101} // namespace Math; 102} // namespace ROOT; 103 ; 104#endif /* ROOT_Math_GSLMultiMinFunctionWrapper */; GSLMultiFitFunctionAdapter.h; f#define f(i)Definition RSha256.hxx:104; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; ROOT::Math::GSLMultiFitFunctionAdapterClass for adapting a C++ functor class to C function pointers used by GSL MultiFit Algorithm The temp...Definition GSLMultiFitFunctionAdapter.h:69; ROOT::Math::GSLMultiFitFunctionWrapperwrapper to a multi-dim function withtout derivatives for multi-dimensional minimization algorithmDefinition GSLMultiFitFunctionWrapper.h:58; ROOT::Math::GSLMultiFitFunctionWrapper::SetFunctionvoid SetFunction(const FuncVector &f, unsigned int nres, unsigned int npar)Fill gsl function structure from a C++ function iterator and size and number of residuals.Definition GSLMultiFitFunctionWrapper.h:79; ROOT::Math::GSLMultiFitFunctionWrapper::GetFuncgsl_multifit_function_fdf * GetFunc()Definition GSLMultiFitFunctionWrapper.h:90; ROOT::Math::GSLMultiFitFunctionWrapper::GSLMultiFitFunctionWrapperGSLMultiFitFunctionWrapper()Definition GSLMultiFitFunctionWrapper.h:62; ROOT::Math::GSLMultiFitFunctionWrapper::fFuncgsl_multifit_function_fdf fFuncDefinition GSLMultiFitFunctionWrapper.h:95; double; MathNamespace for new Math classes and function",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/GSLMultiFitFunctionWrapper_8h_source.html:3536,adapt,adapting,3536,doc/master/GSLMultiFitFunctionWrapper_8h_source.html,https://root.cern,https://root.cern/doc/master/GSLMultiFitFunctionWrapper_8h_source.html,1,['adapt'],['adapting']
Energy Efficiency,"ction transforms the; source spectrum according to the given input parameters. Transformed data are; written into dest spectrum. Before the Transform function is called the class; must be created by constructor and the type of the transform as well as some; other parameters must be set using a set of setter functions:;  ; Member variables of; TSpectrumTransform2 class:; fSource-pointer; to the matrix of source spectrum. Its lengths should be equal to the �fSizex,; fSizey� parameters except for inverse FOURIER, FOUR-WALSH, FOUR-HAAR; transforms. These need �2*fSizex*fSizey� length to supply real and imaginary; coefficients. ������������������; fDest-pointer; to the matrix of destination spectrum. Its lengths should be equal to the; �fSizex, fSizey� parameters except for inverse FOURIER, FOUR-WALSH, FOUR-HAAR; transforms. These need �2*fSizex*fSizey� length to store real and imaginary; coefficients. ; ������� fSizeX,fSizeY-basic; lengths of the source and dest spectra. They should; be power �; �����; of 2.; fType-type of transform; ����������� Classic transforms:; ����������������������� kTransformHaar. ����������������������� kTransformWalsh. ����������������������� kTransformCos. ����������������������� kTransformSin. ����������������������� kTransformFourier. ����������������������� kTransformHartley. ����������� Mixed transforms:; ����������������������� kTransformFourierWalsh. ����������������������� kTransformFourierHaar. ����������������������� kTransformWalshHaar. ����������������������� kTransformCosWalsh. ����������������������� kTransformCosHaar. ����������������������� kTransformSinWalsh. ����������������������� kTransformSinHaar. fDirection-direction-transform; direction (forward, inverse); ����������������������� kTransformForward. ����������������������� kTransformInverse. fDegree-applies; only for mixed transforms [2], [3], [4]. ; ����������������; �Allowed range� . ; References:; [1] C.V. Hampton, B. Lian, Wm. C.; McHarris: Fast-Fourier-transform spec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSpectrum2Transform.html:15112,power,power,15112,root/html528/TSpectrum2Transform.html,https://root.cern,https://root.cern/root/html528/TSpectrum2Transform.html,6,['power'],['power']
Energy Efficiency,"ctionTypevirtual Int_t GetCollectionType() const =0Return the type of the proxied collection (see enumeration TClassEdit::ESTLType); TVirtualCollectionProxy::GetFunctionNextvirtual Next_t GetFunctionNext(Bool_t read=kTRUE)=0Return a pointer to a function that can advance an iterator (see Next_t).; TVirtualCollectionProxy::GetFunctionDeleteTwoIteratorsvirtual DeleteTwoIterators_t GetFunctionDeleteTwoIterators(Bool_t read=kTRUE)=0; TVirtualCollectionProxy::Sizevirtual UInt_t Size() const =0Return the current number of elements in the container.; TVirtualCollectionProxy::DeleteTwoIterators_tvoid(* DeleteTwoIterators_t)(void *begin, void *end)Definition TVirtualCollectionProxy.h:245; TVirtualCollectionProxy::DeleteIterator_tvoid(* DeleteIterator_t)(void *iter)If the size of the iterator is greater than fgIteratorArenaSize, call delete on the addresses; otherw...Definition TVirtualCollectionProxy.h:244; TVirtualCollectionProxy::fgIteratorArenaSizestatic const Int_t fgIteratorArenaSizeThe size of a small buffer that can be allocated on the stack to store iterator-specific information.Definition TVirtualCollectionProxy.h:207; TVirtualCollectionProxy::GetFunctionCreateIteratorsvirtual CreateIterators_t GetFunctionCreateIterators(Bool_t read=kTRUE)=0Return a pointer to a function that can create an iterator pair, where each iterator points to the be...; TVirtualCollectionProxy::Allocatevirtual void * Allocate(UInt_t n, Bool_t forceDelete)=0Allocates space for storing at least n elements.; TVirtualCollectionProxy::GetConversionReadMemberWiseActionsvirtual TStreamerInfoActions::TActionSequence * GetConversionReadMemberWiseActions(TClass *oldClass, Int_t version)=0; TVirtualCollectionProxy::GetFunctionDeleteIteratorvirtual DeleteIterator_t GetFunctionDeleteIterator(Bool_t read=kTRUE)=0Return a pointer to a function that can delete an iterator (pair) (see DeleteIterator_t).; TVirtualCollectionProxy::GetFunctionCopyIteratorvirtual CopyIterator_t GetFunctionCopyIterator(Bool_t rea",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html:246493,allocate,allocated,246493,doc/master/TStreamerInfoActions_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html,1,['allocate'],['allocated']
Energy Efficiency,"ctions inherited from RooAbsReal;  RooAbsReal ();  coverity[UNINIT_CTOR] Default constructor ;  ;  RooAbsReal (const char *name, const char *title, const char *unit="""");  Constructor with unit label. ;  ;  RooAbsReal (const char *name, const char *title, double minVal, double maxVal, const char *unit="""");  Constructor with plot range and unit label. ;  ;  RooAbsReal (const RooAbsReal &other, const char *name=nullptr);  Copy constructor. ;  ;  ~RooAbsReal () override;  Destructor. ;  ; virtual double analyticalIntegral (Int_t code, const char *rangeName=nullptr) const;  Implements the actual analytical integral(s) advertised by getAnalyticalIntegral. ;  ; TF1 * asTF (const RooArgList &obs, const RooArgList &pars=RooArgList(), const RooArgSet &nset=RooArgSet()) const;  Return a ROOT TF1,2,3 object bound to this RooAbsReal with given definition of observables and parameters. ;  ; RooFit::OwningPtr< RooAbsFunc > bindVars (const RooArgSet &vars, const RooArgSet *nset=nullptr, bool clipInvalid=false) const;  Create an interface adaptor f(vars) that binds us to the specified variables (in arbitrary order). ;  ; virtual std::string buildCallToAnalyticIntegral (Int_t code, const char *rangeName, RooFit::Detail::CodeSquashContext &ctx) const;  This function defines the analytical integral translation for the class. ;  ; virtual RooFit::OwningPtr< RooFitResult > chi2FitTo (RooDataHist &data, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={});  Perform a \( \chi^2 \) fit to given histogram. ;  ; virtual RooFit::OwningPtr< RooFitResult > chi2FitTo (RooDataHist &data, const RooLinkedList &cmdList);  Calls RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList) and returns fit result. ;  ; virtual RooFit::OwningPtr< RooFitResult > chi2FitTo (RooDataSet &xydata, const RooCmdArg &arg1={}, const RooCmdArg &arg2={},",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAddPdf.html:17925,adapt,adaptor,17925,doc/v632/classRooAddPdf.html,https://root.cern,https://root.cern/doc/v632/classRooAddPdf.html,12,['adapt'],['adaptor']
Energy Efficiency,"ctions |; Private Attributes |; List of all members ; TGeoHelix Class ReferenceThe Geometry Package » Shapes. ; Class representing a helix curve. ; A helix is a curve defined by the following equations:; x = (1/c) * COS(q*phi); y = (1/c) * SIN(q*phi); z = s * alfa; c#define c(i)Definition RSha256.hxx:101; qfloat * qDefinition THbookFile.cxx:89; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; where:; c = 1/Rxy - curvature in XY plane; phi - phi angle; S = 2*PI*s - vertical separation between helix loops; q = +/- 1 - (+)=left-handed, (-)=right-handed; PI#define PIDefinition SpecFuncMathCore.cxx:23; angleOption_t Option_t TPoint TPoint angleDefinition TGWin32VirtualXProxy.cxx:68; In particular, a helix describes the trajectory of a charged particle in magnetic field. In such case, the helix is right-handed for negative particle charge. To define a helix, one must define:; the curvature - positive defined; the Z step made after one full turn of the helix; the particle charge sign; the initial particle position and direction (force normalization to unit); the magnetic field direction. A helix provides:; propagation to a given Z position (in global frame) Double_t *point = TGeoHelix::PropagateToZ(Double_t z);; propagation to an arbitrary plane, returning also the new point; propagation in a geometry until the next crossed surface; computation of the total track length along a helix . Definition at line 19 of file TGeoHelix.h. Public Types; enum  EGeoHelixTypes { kHelixNeedUpdate = (1ULL << ( 16 )); , kHelixStraight = (1ULL << ( 17 )); , kHelixCircle = (1ULL << ( 18 )); };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoHelix.html:1243,charge,charge,1243,doc/master/classTGeoHelix.html,https://root.cern,https://root.cern/doc/master/classTGeoHelix.html,1,['charge'],['charge']
Energy Efficiency,"ctions |; Protected Member Functions |; Protected Attributes |; Private Types |; Private Member Functions |; Private Attributes |; List of all members ; TGWin32 Class ReferenceGraphics » Graphics' Backends » Win32 backend. ; This class is the basic interface to the Win32 graphics system. ; It is an implementation of the abstract TVirtualX class.; This code was initially developed in the context of HIGZ and PAW by Olivier Couet (package X11INT). ; Definition at line 64 of file TGWin32.h. Public Member Functions;  TGWin32 ();  Default constructor. ;  ;  TGWin32 (const char *name, const char *title);  Normal Constructor. ;  ; virtual ~TGWin32 ();  destructor. ;  ; Int_t AddPixmap (ULongptr_t pix, UInt_t w, UInt_t h) override;  register pixmap created by TGWin32GLManager ;  ; Int_t AddWindow (ULongptr_t qwid, UInt_t w, UInt_t h) override;  Register a window created by Qt as a ROOT window (like InitWindow()). ;  ; Bool_t AllocColor (Colormap_t cmap, ColorStruct_t &color) override;  Find and allocate a color cell according to the color values specified in the ColorStruct_t. ;  ; void Bell (Int_t percent) override;  Sets the sound bell. Percent is loudness from -100% to 100%. ;  ; void ChangeActivePointerGrab (Window_t, UInt_t, Cursor_t) override;  Changes the active cursor of the specified window. ;  ; void ChangeGC (GContext_t gc, GCValues_t *gval) override;  Change entries in an existing graphics context, gc, by values from gval. ;  ; void ChangeProperties (Window_t id, Atom_t property, Atom_t type, Int_t format, UChar_t *data, Int_t len) override;  Put data into Clipboard. ;  ; void ChangeProperty (Window_t id, Atom_t property, Atom_t type, UChar_t *data, Int_t len) override;  This function alters the property for the specified window and causes the X server to generate a PropertyNotify event on that window. ;  ; void ChangeWindowAttributes (Window_t id, SetWindowAttributes_t *attr) override;  Change window attributes. ;  ; Bool_t CheckEvent (Window_t id, EGEventType ty",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGWin32.html:1189,allocate,allocate,1189,doc/master/classTGWin32.html,https://root.cern,https://root.cern/doc/master/classTGWin32.html,1,['allocate'],['allocate']
Energy Efficiency,"ctly via; dynamic_cast<TMonaLisaWriter*>(gMonitoringWriter)->GetApMon(). Additions/modifications by Fabrizio Furano 10/04/2008; - The implementation of TFile throughput and info sending was; just sending 'regular' samples about the activity of the single TFile; instance that happened to trigger an activity in the right moment.; - Now TMonaLisaWriter keeps internally track of every activity; and regularly sends summaries valid for all the files which had; activity in the last time interval.; - Additionally, it's now finalized the infrastructure able to measure; and keep track of the file Open latency. A packet is sent for each; successful Open, sending the measures of the latencies for the; various phases of the open. Currently exploited fully by TAlienFile; and TXNetFile. Easy to report from other TFiles too.; - Now, the hook for the Close() func triggers sending of a packet; containing various information about the performance related to that; file only.; - Added support also for performance monitoring when writing. Function Members (Methods); public:. TMonaLisaWriter(const char* monserver, const char* montag, const char* monid = 0, const char* monsubid = 0, const char* option = """"); virtual~TMonaLisaWriter(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtua",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMonaLisaWriter.html:1951,monitor,monitoring,1951,root/html530/TMonaLisaWriter.html,https://root.cern,https://root.cern/root/html530/TMonaLisaWriter.html,2,['monitor'],['monitoring']
Energy Efficiency,"ctorDataStore.h. ◆ realfStoreList(). std::vector< RealFullVector * > & RooVectorDataStore::realfStoreList ; (; ). inline . Definition at line 541 of file RooVectorDataStore.h. ◆ realStoreList(). std::vector< RealVector * > & RooVectorDataStore::realStoreList ; (; ). inline . Definition at line 540 of file RooVectorDataStore.h. ◆ recalculateCache(). void RooVectorDataStore::recalculateCache ; (; const RooArgSet * ; projectedArgs, . Int_t ; firstEvent, . Int_t ; lastEvent, . Int_t ; stepSize, . bool ; skipZeroWeights . ). overridevirtual . Reimplemented from RooAbsDataStore.; Definition at line 924 of file RooVectorDataStore.cxx. ◆ recomputeSumWeight(). void RooVectorDataStore::recomputeSumWeight ; (; ). Trigger a recomputation of the cached weight sums. ; Meant for use by RooFit dataset converter functions such as the NumPy converter functions implemented as pythonizations. ; Definition at line 1338 of file RooVectorDataStore.cxx. ◆ reduce(). std::unique_ptr< RooAbsDataStore > RooVectorDataStore::reduce ; (; RooStringView ; name, . RooStringView ; title, . const RooArgSet & ; vars, . const RooFormulaVar * ; cutVar, . const char * ; cutRange, . std::size_t ; nStart, . std::size_t ; nStop . ). overridevirtual . Implements RooAbsDataStore.; Definition at line 249 of file RooVectorDataStore.cxx. ◆ reserve(). void RooVectorDataStore::reserve ; (; Int_t ; nEvt). private . Definition at line 703 of file RooVectorDataStore.cxx. ◆ reset(). void RooVectorDataStore::reset ; (; ). overridevirtual . Implements RooAbsDataStore.; Definition at line 738 of file RooVectorDataStore.cxx. ◆ resetBuffers(). void RooVectorDataStore::resetBuffers ; (; ). overridevirtual . Implements RooAbsDataStore.; Definition at line 1055 of file RooVectorDataStore.cxx. ◆ resetCache(). void RooVectorDataStore::resetCache ; (; ). overridevirtual . Implements RooAbsDataStore.; Definition at line 1015 of file RooVectorDataStore.cxx. ◆ row(). const RooArgSet & RooVectorDataStore::row ; (; ). inline . Definiti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooVectorDataStore.html:34891,reduce,reduce,34891,doc/master/classRooVectorDataStore.html,https://root.cern,https://root.cern/doc/master/classRooVectorDataStore.html,1,['reduce'],['reduce']
Energy Efficiency,"ctory containing packages and user libs; TProofLockPath*fPackageLockpackage dir locker; TVirtualProofPlayer*fPlayeractual player; TStringfPrefixPrefix identifying the node; TProof*fProofPROOF talking to slave servers; Int_tfProtocolprotocol version number; TQueryResultManager*fQMgrQuery-result manager; TMutex*fQMtxTo protect async msg queue; TStringfQueryDirdirectory containing query results and status; TProofLockPath*fQueryLockquery dir locker; Int_tfQuerySeqNumsequential number of the current or last query; TList*fQueuedMsglist of messages waiting to be processed; Float_tfRealTimereal time spent executing commands; Bool_tfRealTimeLogTRUE if log messages should be send back in real-time; TReaperTimer*fReaperTimerTimer used to control children state; TStopwatchfSaveOutputmeasures time spent saving the partial result; Bool_tfSendLogToMasterOn workers, controls logs sending to master; TStringfServiceservice we are running, either ""proofserv"" or ""proofslave""; TStringfSessionDirdirectory containing session dependent files; TStringfSessionTagtag for the server session; TShutdownTimer*fShutdownTimerTimer used to shutdown out-of-control sessions; TSocket*fSocketsocket connection to client; TStringfTopSessionTagtag for the global session; Int_tfTotSessionsTotal number of PROOF sessions on the cluster; TStringfUseruser as which we run; TList*fWaitingQuerieslist of TProofQueryResult waiting to be processed; TStringfWorkDirdirectory containing all proof related info; static FILE*fgErrorHandlerFileFile where to log; static Int_tfgLogToSysLog>0 sent to syslog too; static Float_tfgMemHWMThreshold fraction of max for warning and finer monitoring; static Float_tfgMemStopFraction of max for stop processing; static Int_tfgRecursiveKeep track of recursive inputs during processing; static Long_tfgResMemMaxHard limit on the resident memory checked; static TStringfgSysLogEntitylogging entity (<user>:<group>); static TStringfgSysLogServicename of the syslog service (eg: proofm-0, proofw-0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofServ.html:21721,monitor,monitoring,21721,root/html602/TProofServ.html,https://root.cern,https://root.cern/root/html602/TProofServ.html,2,['monitor'],['monitoring']
Energy Efficiency,"ctory. friend class TCollectionProxyFactory. friend . Definition at line 34 of file TGenCollectionProxy.h. Member Data Documentation. ◆ fClear. Method TGenCollectionProxy::fClear. protected . Method cache for container accessors: clear container. ; Definition at line 301 of file TGenCollectionProxy.h. ◆ fCollect. Collectfunc_t TGenCollectionProxy::fCollect. protected . Method to collect objects from container. ; Definition at line 309 of file TGenCollectionProxy.h. ◆ fConstruct. ArrIterfunc_t TGenCollectionProxy::fConstruct. protected . Container accessors: block construct. ; Definition at line 306 of file TGenCollectionProxy.h. ◆ fConversionReadMemberWise. std::map<std::string, TObjArray*>* TGenCollectionProxy::fConversionReadMemberWise. mutableprotected . Array of bundle of TStreamerInfoActions to stream out (read) derived from another class. ; Definition at line 292 of file TGenCollectionProxy.h. ◆ fCreateEnv. Method0 TGenCollectionProxy::fCreateEnv. protected . Method to allocate an Environment holder. ; Definition at line 310 of file TGenCollectionProxy.h. ◆ fDestruct. Sizing_t TGenCollectionProxy::fDestruct. protected . Container accessors: block destruct. ; Definition at line 307 of file TGenCollectionProxy.h. ◆ fEnv. EnvironBase_t* TGenCollectionProxy::fEnv. protected . Address of the currently proxied object. ; Definition at line 314 of file TGenCollectionProxy.h. ◆ fFeed. Feedfunc_t TGenCollectionProxy::fFeed. protected . Container accessors: block feed. ; Definition at line 308 of file TGenCollectionProxy.h. ◆ fFirst. Method TGenCollectionProxy::fFirst. protected . Container accessors: generic iteration: first. ; Definition at line 304 of file TGenCollectionProxy.h. ◆ fFunctionCopyIterator. CopyIterator_t TGenCollectionProxy::fFunctionCopyIterator. protected . Definition at line 325 of file TGenCollectionProxy.h. ◆ fFunctionCreateIterators. CreateIterators_t TGenCollectionProxy::fFunctionCreateIterators. protected . Definition at line 324 of file TGenColl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGenCollectionProxy.html:27920,allocate,allocate,27920,doc/master/classTGenCollectionProxy.html,https://root.cern,https://root.cern/doc/master/classTGenCollectionProxy.html,1,['allocate'],['allocate']
Energy Efficiency,"cts that can be inserted into RooPlots and take advantage of its internal normalization and axis range adjustment features ;  CRooPoissonPoisson pdf ;  CRooPolynomialRooPolynomial implements a polynomial p.d.f of the form ; \[ f(x) = \sum_{i} a_{i} * x^i \]. By default coefficient a_0 is chosen to be 1, as polynomial probability density functions have one degree of freedome less than polynomial functions due to the normalization condition ;  CRooPolyVarClass RooPolyVar is a RooAbsReal implementing a polynomial in terms of a list of RooAbsReal coefficients ; \[f(x) = \sum_{i} a_{i}x \]. Class RooPolyvar implements analytical integrals of all polynomials it can define ;  CRooPrintableRooPlotable is a 'mix-in' base class that define the standard RooFit plotting and printing methods ;  CRooProdGenContextRooProdGenContext is an efficient implementation of the generator context specific for RooProdPdf PDFs ;  ►CRooProdPdfRooProdPdf is an efficient implementation of a product of PDFs of the form ;  CCacheElem;  ►CRooProductRooProduct a RooAbsReal implementation that represent the product of a given set of other RooAbsReal objects ;  CCacheElem;  CRooProfileLLClass RooProfileLL implements the profile likelihood estimator for a given likelihood and set of parameters of interest ;  ►CRooProjectedPdfClass RooProjectedPdf is a RooAbsPdf implementation that represent a projection of a given input p.d.f and the object returned by RooAbsPdf::createProjection ;  CCacheElem;  CRooProofDriverSelector;  CRooPullVarClass RooPullVar represents the pull of measurement w.r.t to true value using the measurement value and its error ;  CRooQuasiRandomGeneratorThis class generates the quasi-random (aka ""low discrepancy"") sequence for dimensions up to 12 using the Niederreiter base 2 algorithm described in Bratley, Fox, Niederreiter, ACM Trans ;  ►CRooRandomThis class provides a static interface for generating random numbers ;  CGuard;  ►CRooRandomizeParamMCSModuleRooRandomizeParamMCSModule is ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/annotated.html:100229,efficient,efficient,100229,doc/v608/annotated.html,https://root.cern,https://root.cern/doc/v608/annotated.html,2,['efficient'],['efficient']
Energy Efficiency,"cts, which only potentially could be displayed in the browser. In case of 10 objects it does not matter, but for 1000 or 100000 objects this will be a major performance penalty. With such big amount of data one will never achieve higher update rate.; The second problem is I/O. To read the first object from the ROOT file, one need to perform several (about 5) file-reading operations via http protocol. There is no http file locking mechanism (at least not for standard web servers), therefore there is no guarantee that the file content is not changed/replaced between consequent read operations. Therefore, one should expect frequent I/O failures while trying to monitor data from ROOT binary files. There is a workaround for the problem - one could load the file completely and exclude many partial I/O operations by this. To achieve this with JSROOT, one should add “+” sign at the end of the file name. Of course, it only could work for small files.; If somebody still wants to use monitoring of data from ROOT files, could try link like:. https://root.cern/js/latest/?nobrowser&file=../files/hsimple.root+&item=hpx;1&monitoring=2000. In this particular case, the histogram is not changing.; 1.11 JSROOT API; JSROOT can be used in arbitrary HTML pages to display data, produced with or without ROOT-based applications.; Many different examples of JSROOT API usage can be found on JSROOT API examples page.; 1.11.1 Import JSROOT functionality; Major JSROOT functions are located in main.mjs module and can be imported like:; <script type='module'>; import { openFile, draw } from 'https://root.cern/js/latest/modules/main.mjs';; let filename = ""https://root.cern/js/files/hsimple.root"";; let file = await openFile(filename);; let obj = await file.readObject(""hpxpy;1"");; await draw(""drawing"", obj, ""colz"");; </script>; Here the default location https://root.cern/js/latest/ is specified. One always can install JSROOT on private web server. When JSROOT is used with THttpServer, the address look",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:22341,monitor,monitoring,22341,root/htmldoc/guides/JSROOT/JSROOT.html,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html,1,['monitor'],['monitoring']
Energy Efficiency,"cts. ; Definition at line 4814 of file TBranchElement.cxx. ◆ ResetInitInfo(). void TBranchElement::ResetInitInfo ; (; bool ; recurse). virtual . Reset offset and StreamerInfo information from this branch. ; Parameters. [in]recurseWhen true call ResetInitInfo on all subbranches. . Definition at line 4831 of file TBranchElement.cxx. ◆ SetActionSequence(). void TBranchElement::SetActionSequence ; (; TClass * ; originalClass, . TStreamerInfo * ; localInfo, . TStreamerInfoActions::TActionSequence::SequenceGetter_t ; create, . TStreamerInfoActions::TActionSequence *& ; actionSequence . ). protected . Set the sequence of actions needed to read the data out of the buffer. ; Definition at line 5628 of file TBranchElement.cxx. ◆ SetAddress(). void TBranchElement::SetAddress ; (; void * ; addr). overridevirtual . Point this branch at an object. ; For a sub-branch, addr is a pointer to the branch object.; For a top-level branch the meaning of addr is as follows:; If addr is zero, then we allocate a branch object internally and the branch is the owner of the allocated object, not the caller. However the caller may obtain a pointer to the branch object with GetObject(). The pointer is reset to zero (nullptr) when the relevant branch object is destroyed.; Example: branch->SetAddress(0);; Event* event = branch->GetObject();; ... Do some work.; EventDefinition collection_proxies.C:172; If addr is not zero, but the pointer addr points at is zero, then we allocate a branch object and set the passed pointer to point at the allocated object. The caller owns the allocated object and is responsible for deleting it when it is no longer needed.; Example: Event* event = 0;; branch->SetAddress(&event);; ... Do some work.; delete event;; event = 0;; If addr is not zero and the pointer addr points at is also not zero, then the caller has allocated a branch object and is asking us to use it. The caller owns it and must delete it when it is no longer needed.; Example: Event* event = new Event();;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBranchElement.html:66407,allocate,allocate,66407,doc/master/classTBranchElement.html,https://root.cern,https://root.cern/doc/master/classTBranchElement.html,2,['allocate'],"['allocate', 'allocated']"
Energy Efficiency,"culation ; Definition at line 111 of file GSLDerivator.cxx. ◆ EvalBackward() [1/2]. double ROOT::Math::GSLDerivator::EvalBackward ; (; const IGenFunction & ; f, . double ; x, . double ; h . ). static . Computes the numerical derivative of a function f at a point x using an adaptive backward difference algorithm with a step size h. ; The function is evaluated only at points less than x and at x itself ; Definition at line 99 of file GSLDerivator.cxx. ◆ EvalBackward() [2/2]. double ROOT::Math::GSLDerivator::EvalBackward ; (; double ; x, . double ; h . ). Computes the numerical derivative at a point x using an adaptive backward difference algorithm with a step size h. ; The function is evaluated only at points less than x and at x itself. ; Definition at line 69 of file GSLDerivator.cxx. ◆ EvalCentral() [1/2]. double ROOT::Math::GSLDerivator::EvalCentral ; (; const IGenFunction & ; f, . double ; x, . double ; h . ). static . Computes the numerical derivative of a function f at a point x using an adaptive central difference algorithm with a step size h. ; Definition at line 81 of file GSLDerivator.cxx. ◆ EvalCentral() [2/2]. double ROOT::Math::GSLDerivator::EvalCentral ; (; double ; x, . double ; h . ). Computes the numerical derivative at a point x using an adaptive central difference algorithm with a step size h. ; Definition at line 47 of file GSLDerivator.cxx. ◆ EvalForward() [1/2]. double ROOT::Math::GSLDerivator::EvalForward ; (; const IGenFunction & ; f, . double ; x, . double ; h . ). static . Computes the numerical derivative of a function f at a point x using an adaptive forward difference algorithm with a step size h. ; The function is evaluated only at points greater than x and at x itself ; Definition at line 90 of file GSLDerivator.cxx. ◆ EvalForward() [2/2]. double ROOT::Math::GSLDerivator::EvalForward ; (; double ; x, . double ; h . ). Computes the numerical derivative at a point x using an adaptive forward difference algorithm with a step size h. ; The ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1GSLDerivator.html:4229,adapt,adaptive,4229,doc/master/classROOT_1_1Math_1_1GSLDerivator.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1GSLDerivator.html,1,['adapt'],['adaptive']
Energy Efficiency,"cutRange = 0) const; { return moment(var,1,0,cutSpec,cutRange) ; }. Double_t sigma(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; { return sqrt(moment(var,2,cutSpec,cutRange)) ; }. Double_t skewness(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; { return standMoment(var,3,cutSpec,cutRange) ; }. Double_t kurtosis(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; { return standMoment(var,4,cutSpec,cutRange) ; }. Double_t covariance(RooRealVar& x, RooRealVar& y, const char* cutSpec = 0, const char* cutRange = 0) const; { return corrcov(x,y,cutSpec,cutRange,kFALSE) ; }. Double_t correlation(RooRealVar& x, RooRealVar& y, const char* cutSpec = 0, const char* cutRange = 0) const; { return corrcov(x,y,cutSpec,cutRange,kTRUE) ; }. TMatrixDSym* covarianceMatrix(const char* cutSpec = 0, const char* cutRange = 0) const; { return covarianceMatrix(*get(),cutSpec,cutRange) ; }. TMatrixDSym* correlationMatrix(const char* cutSpec = 0, const char* cutRange = 0) const; { return correlationMatrix(*get(),cutSpec,cutRange) ; }. TMatrixDSym* covarianceMatrix(const RooArgList& vars, const char* cutSpec = 0, const char* cutRange = 0) const; { return corrcovMatrix(vars,cutSpec,cutRange,kFALSE) ; }. TMatrixDSym* correlationMatrix(const RooArgList& vars, const char* cutSpec = 0, const char* cutRange = 0) const; { return corrcovMatrix(vars,cutSpec,cutRange,kTRUE) ; }. StorageType getDefaultStorageType(). RooAbsData* cacheClone(const RooAbsArg* newCacheOwner, const RooArgSet* newCacheVars, const char* newName = 0). RooAbsData* reduceEng(const RooArgSet& varSubset, const RooFormulaVar* cutVar, const char* cutRange = 0, Int_t nStart = 0, Int_t nStop = 2000000000, Bool_t copyCache = kTRUE). » Last changed: Tue Jun 30 14:30:05 2015 » Last generated: 2015-06-30 14:30; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsData.html:40724,reduce,reduceEng,40724,root/html602/RooAbsData.html,https://root.cern,https://root.cern/root/html602/RooAbsData.html,1,['reduce'],['reduceEng']
Energy Efficiency,"cxx. ◆ processAliasExpression(). string RooFactoryWSTool::processAliasExpression ; (; const char * ; arg). protected . Parse token. ; Definition at line 1185 of file RooFactoryWSTool.cxx. ◆ processCompositeExpression(). std::string RooFactoryWSTool::processCompositeExpression ; (; const char * ; token). protected . Process a single composite expression. . e.g. A=RooGaussian::g[x,m,s] --> A=g; e.g. f[0,1]*RooGaussiang[x,m,s] --> f*g; e.g. RooGaussian::g(x,y,s)|x --> g|x; e.g. $MetaArg(RooGaussian::g[x,m,s],blah) --> $MetaArg(g,blah) . Definition at line 909 of file RooFactoryWSTool.cxx. ◆ processCreateArg(). string RooFactoryWSTool::processCreateArg ; (; std::string & ; func, . std::vector< std::string > & ; args . ). protected . Glue function between high-level syntax and low-level factory call to createArg: Process a parsed call to create a pdf named func ; The func arg is interpreted as ClassName::ObjectName and the arglist is passed verbatim to createArg. The received arglist is expected to be fully reduced (i.e. all inline object creations must have been compiled) ; Definition at line 1337 of file RooFactoryWSTool.cxx. ◆ processCreateVar(). string RooFactoryWSTool::processCreateVar ; (; std::string & ; func, . std::vector< std::string > & ; args . ). protected . Glue function between high-level syntax and low-level factory call to createVariable: Process a parsed call to create a variable named func ; If initial token is non-numeric, a RooCategory will be created, and the args are interpreted as either state names or name=id assignments. Otherwise a RooRealvar is created and the arg list is interpreted as follows:; If list has two args, these are interpreted as xmin,xmax; If list has three args, these are interpreted as xinit,xmin,xmax; If list has one arg, this is interpreted as xinit and the variable is set as constant . Definition at line 1267 of file RooFactoryWSTool.cxx. ◆ processExpression(). std::string RooFactoryWSTool::processExpression ; (; const char *",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooFactoryWSTool.html:38871,reduce,reduced,38871,doc/master/classRooFactoryWSTool.html,https://root.cern,https://root.cern/doc/master/classRooFactoryWSTool.html,1,['reduce'],['reduced']
Energy Efficiency,"cycles = 5000, n_layers = 4. * note that the number of hidden layers in the NN is:; n_hidden_layers = n_layers - 2. * since there is one input and one output layer. The number of; nodes (neurons) is predefined to be:; n_nodes[i] = nvars + 1 - i (where i=1..n_layers). with nvars being the number of variables used in the NN. Hence, the default case is: n_neurons(layer 1 (input)) : nvars; n_neurons(layer 2 (hidden)): nvars-1; n_neurons(layer 3 (hidden)): nvars-1; n_neurons(layer 4 (out)) : 2. This artificial neural network usually needs a relatively large; number of cycles to converge (8000 and more). Overtraining can; be efficienctly tested by comparing the signal and background; output of the NN for the events that were used for training and; an independent data sample (with equal properties). If the separation; performance is significantly better for the training sample, the; NN interprets statistical effects, and is hence overtrained. In; this case, the number of cycles should be reduced, or the size; of the training sample increased. MethodCFMlpANN(TMVA::DataSetInfo& theData, const TString& theWeightFile, TDirectory* theTargetDir = NULL); constructor from weight file. Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t ); CFMlpANN can handle classification with 2 classes. void DeclareOptions(); define the options (their key words) that can be set in the option string; know options: NCycles=xx :the number of training cycles; HiddenLayser=""N-1,N-2"" :the specification of the hidden layers. void ProcessOptions(); decode the options in the option string. void Init( void ); default initialisation called by all constructors. ~MethodCFMlpANN( void ); destructor. void Train( void ); training of the Clement-Ferrand NN classifier. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); returns CFMlpANN output (normalised within [0,1]). Double_t EvalANN(vector<Double_t>& , Bool_t& isOK); evaluates NN value as function of input variabl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MethodCFMlpANN.html:21654,reduce,reduced,21654,root/html528/TMVA__MethodCFMlpANN.html,https://root.cern,https://root.cern/root/html528/TMVA__MethodCFMlpANN.html,4,['reduce'],['reduced']
Energy Efficiency,"cycles = 5000, n_layers = 4. * note that the number of hidden layers in the NN is:; n_hidden_layers = n_layers - 2. * since there is one input and one output layer. The number of; nodes (neurons) is predefined to be:; n_nodes[i] = nvars + 1 - i (where i=1..n_layers). with nvars being the number of variables used in the NN. Hence, the default case is: n_neurons(layer 1 (input)) : nvars; n_neurons(layer 2 (hidden)): nvars-1; n_neurons(layer 3 (hidden)): nvars-1; n_neurons(layer 4 (out)) : 2. This artificial neural network usually needs a relatively large; number of cycles to converge (8000 and more). Overtraining can; be efficienctly tested by comparing the signal and background; output of the NN for the events that were used for training and; an independent data sample (with equal properties). If the separation; performance is significantly better for the training sample, the; NN interprets statistical effects, and is hence overtrained. In; this case, the number of cycles should be reduced, or the size; of the training sample increased. MethodCFMlpANN(TMVA::DataSetInfo& theData, const TString& theWeightFile, TDirectory* theTargetDir = __null); constructor from weight file. Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t ); CFMlpANN can handle classification with 2 classes. void DeclareOptions(); define the options (their key words) that can be set in the option string; know options: NCycles=xx :the number of training cycles; HiddenLayser=""N-1,N-2"" :the specification of the hidden layers. void ProcessOptions(); decode the options in the option string. void Init( void ); default initialisation called by all constructors. ~MethodCFMlpANN( void ); destructor. void Train( void ); training of the Clement-Ferrand NN classifier. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); returns CFMlpANN output (normalised within [0,1]). Double_t EvalANN(vector<Double_t>& , Bool_t& isOK); evaluates NN value as function of input varia",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__MethodCFMlpANN.html:23626,reduce,reduced,23626,root/html602/TMVA__MethodCFMlpANN.html,https://root.cern,https://root.cern/root/html602/TMVA__MethodCFMlpANN.html,2,['reduce'],['reduced']
Energy Efficiency,"d = 0) const; virtual voidFdF(const double* x, double& f, double* df) const; virtual voidGradient(const double* x, double* grad) const; ROOT::Math::IBaseFunctionMultiDimROOT::Math::IBaseFunctionMultiDim::IBaseFunctionMultiDim(); ROOT::Math::IBaseFunctionMultiDimROOT::Math::IBaseFunctionMultiDim::IBaseFunctionMultiDim(const ROOT::Math::IBaseFunctionMultiDim&); ROOT::Math::IGradientFunctionMultiDimIGradientFunctionMultiDim(); ROOT::Math::IGradientFunctionMultiDimIGradientFunctionMultiDim(const ROOT::Math::IGradientFunctionMultiDim&); ROOT::Math::IGradientMultiDimROOT::Math::IGradientMultiDim::IGradientMultiDim(); ROOT::Math::IGradientMultiDimROOT::Math::IGradientMultiDim::IGradientMultiDim(const ROOT::Math::IGradientMultiDim&); virtual unsigned intROOT::Math::IBaseFunctionMultiDim::NDim() const; doubleROOT::Math::IBaseFunctionMultiDim::operator()(const double* x) const; ROOT::Math::IGradientFunctionMultiDim&operator=(const ROOT::Math::IGradientFunctionMultiDim&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Gradient(const double* x, double* grad) const. Evaluate all the vector of function derivatives (gradient) at a point x.; Derived classes must re-implement if it is more efficient than evaluting one at a time. void FdF(const double* x, double& f, double* df) const. Optimized method to evaluate at the same time the function value and derivative at a point x.; Often both value and derivatives are needed and it is often more efficient to compute them at the same time.; Derived class should implement this method if performances play an important role and if it is faster to; evaluate value and derivative at the same time. virtual ~IGradientFunctionMultiDim(). Virtual Destructor (no operations). {}. » Last changed: root/mathcore:$Id$ » Last generated: 2015-06-30 14:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__IGradientFunctionMultiDim.html:2643,efficient,efficient,2643,root/html602/ROOT__Math__IGradientFunctionMultiDim.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__IGradientFunctionMultiDim.html,2,['efficient'],['efficient']
Energy Efficiency,"d = 0) const; virtual voidFdF(const double* x, double& f, double* df) const; virtual voidGradient(const double* x, double* grad) const; ROOT::Math::IBaseFunctionMultiDimROOT::Math::IBaseFunctionMultiDim::IBaseFunctionMultiDim(); ROOT::Math::IBaseFunctionMultiDimROOT::Math::IBaseFunctionMultiDim::IBaseFunctionMultiDim(const ROOT::Math::IBaseFunctionMultiDim&); ROOT::Math::IGradientFunctionMultiDimIGradientFunctionMultiDim(); ROOT::Math::IGradientFunctionMultiDimIGradientFunctionMultiDim(const ROOT::Math::IGradientFunctionMultiDim&); ROOT::Math::IGradientMultiDimROOT::Math::IGradientMultiDim::IGradientMultiDim(); ROOT::Math::IGradientMultiDimROOT::Math::IGradientMultiDim::IGradientMultiDim(const ROOT::Math::IGradientMultiDim&); virtual unsigned intROOT::Math::IBaseFunctionMultiDim::NDim() const; doubleROOT::Math::IBaseFunctionMultiDim::operator()(const double* x) const; ROOT::Math::IGradientFunctionMultiDim&operator=(const ROOT::Math::IGradientFunctionMultiDim&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Gradient(const double* x, double* grad) const. Evaluate all the vector of function derivatives (gradient) at a point x.; Derived classes must re-implement if it is more efficient than evaluting one at a time. void FdF(const double* x, double& f, double* df) const. Optimized method to evaluate at the same time the function value and derivative at a point x.; Often both value and derivatives are needed and it is often more efficient to compute them at the same time.; Derived class should implement this method if performances play an important role and if it is faster to; evaluate value and derivative at the same time. virtual ~IGradientFunctionMultiDim(). Virtual Destructor (no operations). {}. » Last changed: root/mathcore:$Id$ » Last generated: 2015-09-08 17:34; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/ROOT__Math__IGradientFunctionMultiDim.html:2643,efficient,efficient,2643,root/html604/ROOT__Math__IGradientFunctionMultiDim.html,https://root.cern,https://root.cern/root/html604/ROOT__Math__IGradientFunctionMultiDim.html,2,['efficient'],['efficient']
Energy Efficiency,"d = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Public Attributes inherited from TArrayD; Double_t * fArray;  ;  Public Attributes inherited from TArray; Int_t fN;  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Static Protected Member Functions inherited from TH3; static TH1D * DoProject1D (const TH3 &h, const char *name, const char *title, const TAxis *projX, bool computeErrors, bool originalRange, bool useUF, bool useOF);  static methdod performing the projection to 1D histogram ;  ; static TH2D * DoProject2D (const TH3 &h, const char *name, const char *title, const TAxis *projX, const TAxis *projY, bool computeErrors, bool originalRange, bool useUF, bool useOF);  static methdod performing the projection to 2D histogram ;  ;  Static Protected Member Functions inherited from TH1; static Int_t AutoP2GetBins (Int_t n);  Auxiliary function to get the next power of 2 integer value larger then n. ;  ; static Double_t AutoP2GetPower2 (Double_t x, Bool_t next=kTRUE);  Auxiliary function to get the power of 2 next (larger) or previous (smaller) a given x. ;  ; static bool CheckAxisLimits (const TAxis *a1, const TAxis *a2);  Check that the axis limits of the histograms are the same. ;  ; static bool CheckBinLabels (const TAxis *a1, const TAxis *a2);  Check that axis have same labels. ;  ; static bool CheckBinLimits (const TAxis *a1, const TAxis *a2);  Check bin limits. ;  ; static int CheckConsistency (const TH1 *h1, const TH1 *h2);  ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH3D.html:57462,power,power,57462,doc/master/classTH3D.html,https://root.cern,https://root.cern/doc/master/classTH3D.html,2,['power'],['power']
Energy Efficiency,"d SetAddress(void *add)Set address of this branch.Definition TBranch.cxx:2682; TCanvasThe Canvas class.Definition TCanvas.h:23; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TH1::Fitvirtual TFitResultPtr Fit(const char *formula, Option_t *option="""", Option_t *goption="""", Double_t xmin=0, Double_t xmax=0)Fit histogram with function fname.Definition TH1.cxx:3898; TH1::Fillvirtual Int_t Fill(Double_t x)Increment bin with abscissa X by 1.Definition TH1.cxx:3344; TRandom::Gausvirtual Double_t Gaus(Double_t mean=0, Double_t sigma=1)Samples a random number from the standard Normal (Gaussian) Distribution with the given mean and sigm...Definition TRandom.cxx:275; TRandom::RndmDouble_t Rndm() overrideMachine independent random number generator.Definition TRandom.cxx:559; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; TTree::GetBranchvirtual TBranch * GetBranch(const char *name)Return pointer to the branch with the given name in this tree or its friends.Definition TTree.cxx:5294; TTree::Drawvoid Draw(Option_t *opt) overrideDefault Draw method for all objects.Definition TTree.h:431; TTree::GetEntriesvirtual Long64_t GetEntries() constDefinition TTree.h:463; TTree::ResetBranchAddressesvirtual void ResetBranchAddresses()Tell all of our branches to drop their current objects and allocate new ones.Definition TTree.cxx:8075; c1return c1Definition legend1.C:41; f1TF1 * f1Definition legend1.C:11; TMath::SqrtDouble_t Sqrt(Double_t x)Returns the square root of x.Definition TMath.h:662; TMath::AbsShort_t Abs(Short_t d)Returns the absolute value of parameter Short_t d.Definition TMathBase.h:123; lTLine lDefinition textangle.C:4; AuthorRene Brun ; Definition in file tree2.C. tutorialstreetree2.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tree2_8C.html:8330,allocate,allocate,8330,doc/master/tree2_8C.html,https://root.cern,https://root.cern/doc/master/tree2_8C.html,1,['allocate'],['allocate']
Energy Efficiency,"d SwapPoints(Int_t pos1, Int_t pos2)Swap points.Definition TGraph.cxx:2583; TGraph::Drawvoid Draw(Option_t *chopt="""") overrideDraw this graph with its current attributes.Definition TGraph.cxx:831; TGraph::GetXaxisTAxis * GetXaxis() constGet x axis of the graph.Definition TGraph.cxx:1566; TGraph::GetEditableBool_t GetEditable() constReturn kTRUE if kNotEditable bit is not set, kFALSE otherwise.Definition TGraph.cxx:2292; TGraph::GetEXhighvirtual Double_t * GetEXhigh() constDefinition TGraph.h:143; TGraph::GetCorrelationFactorvirtual Double_t GetCorrelationFactor() constReturn graph correlation factor.Definition TGraph.cxx:1296; TGraph::FillZerovirtual void FillZero(Int_t begin, Int_t end, Bool_t from_ctor=kTRUE)Set zero values for point arrays in the range [begin, end) Should be redefined in descendant classes.Definition TGraph.cxx:1102; TGraph::GetEYhighvirtual Double_t * GetEYhigh() constDefinition TGraph.h:145; TGraph::ExpandAndCopyDouble_t ** ExpandAndCopy(Int_t size, Int_t iend)if size > fMaxSize allocate new arrays of 2*size points and copy iend first points.Definition TGraph.cxx:1089; TGraph::Expandvirtual void Expand(Int_t newsize)If array sizes <= newsize, expand storage to 2*newsize.Definition TGraph.cxx:1065; TGraph::GetMeanvirtual Double_t GetMean(Int_t axis=1) constReturn mean value of X (axis=1) or Y (axis=2)Definition TGraph.cxx:1324; TGraph::fXDouble_t * fX[fNpoints] array of X pointsDefinition TGraph.h:47; TGraph::PaintStatsvirtual void PaintStats(TF1 *fit)Draw the stats.Definition TGraph.cxx:2004; TGraph::GetYaxisTAxis * GetYaxis() constGet y axis of the graph.Definition TGraph.cxx:1575; TGraph::FindObjectTObject * FindObject(const char *name) const overrideSearch object named name in the list of functions.Definition TGraph.cxx:1111; TGraph::SetStatsvirtual void SetStats(Bool_t stats=kTRUE)Set statistics option on/off.Definition TGraph.cxx:2431; TGraph::GetHistogramvirtual TH1F * GetHistogram() constReturns a pointer to the histogram used to draw th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraph_8cxx_source.html:123631,allocate,allocate,123631,doc/master/TGraph_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html,1,['allocate'],['allocate']
Energy Efficiency,"d TGeoMixture::DefineElement(Int_t iel, Int_t z, Int_t natoms);; or:; void AddElement(TGeoMaterial* mat, Double_t weight);; void AddElement(TGeoElement* elem, Double_t weight);; void AddElement(TGeoElement* elem, Int_t natoms);; void AddElement(Double_t a, Double_t z, Double_t weight). iel: index of the element[0,nel-1]; a and z: the atomic mass and charge; weight: proportion by mass of the elements; natoms: number of atoms of the element in the molecule making the mixture. The radiation length is automatically computed when all elements are defined. Since tracking MC provide several other ways to create materials/mixtures, the materials classes are likely to evolve as the interfaces to these engines are being developed. Generally in the process of tracking material properties are not enough and more specific media properties have to be defined. These highly depend on the MC performing tracking and sometimes allow the definition of different media properties (e.g. energy or range cuts) for the same material.; 18.2.2 Radionuclides; A new class TGeoElementRN was introduced in this version to provide support for radioactive nuclides and their decays. A database of 3162 radionuclides can be loaded on demand via the table of elements (TGeoElementTable class). One can make then materials/mixtures based on these radionuclides and use them in a geometry; root[] TGeoManager *geom = new TGeoManager(""geom"",""radionuclides"");; root[] TGeoElementTable *table = geom->GetElementTable();; root[] TGeoElementRN *c14 = table->GetElementRN(14,6); // A,Z; root[] c14->Print();; 6-C-014 ENDF=60140; A=14; Z=6; Iso=0; Level=0[MeV]; Dmass=3.0199[MeV];; Hlife=1.81e+11[s] J/P=0+; Abund=0; Htox=5.8e-10; Itox=5.8e-10; Stat=0; Decay modes:; BetaMinus Diso: 0 BR: 100.000% Qval: 0.1565; One can make materials or mixtures from radionuclides:; root[] TGeoMaterial *mat = new TGeoMaterial(""C14"", c14, 2.0);; The following properties of radionuclides can be currently accessed via getters in the TGeoElement",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:891207,energy,energy,891207,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['energy'],['energy']
Energy Efficiency,"d TStructNode::SetMembers ; (; TList * ; list). Sets list of dauther nodes to ""list"". ; Definition at line 392 of file TStructNode.cxx. ◆ SetMembersCount(). void TStructNode::SetMembersCount ; (; ULong_t ; count). Sets number of members to ""number"". ; Definition at line 400 of file TStructNode.cxx. ◆ SetNodeType(). void TStructNode::SetNodeType ; (; ENodeType ; type). Sets type of node to ""type"". ; Definition at line 408 of file TStructNode.cxx. ◆ SetPointer(). void TStructNode::SetPointer ; (; void * ; pointer). Sets main pointer to ""pointer"". ; Definition at line 416 of file TStructNode.cxx. ◆ SetScaleBy(). void TStructNode::SetScaleBy ; (; EScalingType ; type). static . Sets scaling by to ""type"". ; Definition at line 424 of file TStructNode.cxx. ◆ SetSize(). void TStructNode::SetSize ; (; ULong_t ; size). Sets size of node to ""size"". ; Definition at line 432 of file TStructNode.cxx. ◆ SetTotalSize(). void TStructNode::SetTotalSize ; (; ULong_t ; size). Sets total size of allocated memory in bytes to value ""size"". ; Definition at line 440 of file TStructNode.cxx. ◆ SetVisible(). void TStructNode::SetVisible ; (; bool ; visible). Sets visibility of node to ""visible"". ; Definition at line 448 of file TStructNode.cxx. ◆ SetWidth(). void TStructNode::SetWidth ; (; Float_t ; w). Sets width of outlining box to ""w"". ; Definition at line 456 of file TStructNode.cxx. ◆ SetX(). void TStructNode::SetX ; (; Float_t ; x). Sets X coordinate to ""x"". ; Definition at line 464 of file TStructNode.cxx. ◆ SetY(). void TStructNode::SetY ; (; Float_t ; y). Sets Y coordinate to ""y"". ; Definition at line 472 of file TStructNode.cxx. ◆ Streamer(). void TStructNode::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void TStructNode::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 108 of file TStructNode.h. Member Data Documentation. ◆ fAllMembersCount. ULong_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTStructNode.html:22640,allocate,allocated,22640,doc/master/classTStructNode.html,https://root.cern,https://root.cern/doc/master/classTStructNode.html,1,['allocate'],['allocated']
Energy Efficiency,"d an object in this collection using its name. Requires a sequential; 309/// scan till the object has been found. Returns 0 if object with specified; 310/// name is not found.; 311 ; 312TObject *TCollection::FindObject(const char *name) const; 313{; 314 TIter next(this);; 315 TObject *obj;; 316 ; 317 while ((obj = next())); 318 if (!strcmp(name, obj->GetName())) return obj;; 319 return nullptr;; 320}; 321 ; 322////////////////////////////////////////////////////////////////////////////////; 323/// Find an object in this collection by name.; 324 ; 325TObject *TCollection::operator()(const char *name) const; 326{; 327 return FindObject(name);; 328}; 329 ; 330////////////////////////////////////////////////////////////////////////////////; 331/// Find an object in this collection using the object's IsEqual(); 332/// member function. Requires a sequential scan till the object has; 333/// been found. Returns 0 if object is not found.; 334/// Typically this function is overridden by a more efficient version; 335/// in concrete collection classes (e.g. THashTable).; 336 ; 337TObject *TCollection::FindObject(const TObject *obj) const; 338{; 339 TIter next(this);; 340 TObject *ob;; 341 ; 342 while ((ob = next())); 343 if (ob->IsEqual(obj)) return ob;; 344 return nullptr;; 345}; 346 ; 347////////////////////////////////////////////////////////////////////////////////; 348/// Return name of this collection.; 349/// if no name, return the collection class name.; 350 ; 351const char *TCollection::GetName() const; 352{; 353 if (fName.Length() > 0) return fName.Data();; 354 return ClassName();; 355}; 356 ; 357////////////////////////////////////////////////////////////////////////////////; 358/// Increase the collection's capacity by delta slots.; 359 ; 360Int_t TCollection::GrowBy(Int_t delta) const; 361{; 362 if (delta < 0) {; 363 Error(""GrowBy"", ""delta < 0"");; 364 delta = Capacity();; 365 }; 366 return Capacity() + TMath::Range(2, kMaxInt - Capacity(), delta);; 367}; 368 ; 369//",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCollection_8cxx_source.html:11743,efficient,efficient,11743,doc/master/TCollection_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCollection_8cxx_source.html,1,['efficient'],['efficient']
Energy Efficiency,"d as an input for the expression. An exception is thrown in case the column to re-define does not already exist.; See DefineSlotEntry() for more information. ; Definition at line 598 of file RInterface.hxx. ◆ Reduce() [1/2]. template<typename Proxied , typename DataSource = void> . template<typename F , typename T = typename TTraits::CallableTraits<F>::ret_type> . RResultPtr< T > ROOT::RDF::RInterface< Proxied, DataSource >::Reduce ; (; F ; f, . std::string_view ; columnName, . const T & ; redIdentity . ). inline . Execute a user-defined reduce operation on the values of a column. ; Template Parameters. FThe type of the reduce callable. Automatically deduced. ; TThe type of the column to apply the reduction to. Automatically deduced. . Parameters. [in]fA callable with signature T(T,T) ; [in]columnNameThe column to be reduced. If omitted, the first default column is used instead. ; [in]redIdentityThe reduced object of each thread is initialized to this value. . Returnsthe reduced quantity wrapped in a RResultPtr. Example usage:; auto sumOfIntColWithOffset = d.Reduce([](int x, int y) { return x + y; }, ""intCol"", 42);; See the description of the first Reduce overload for more information. ; Definition at line 1711 of file RInterface.hxx. ◆ Reduce() [2/2]. template<typename Proxied , typename DataSource = void> . template<typename F , typename T = typename TTraits::CallableTraits<F>::ret_type> . RResultPtr< T > ROOT::RDF::RInterface< Proxied, DataSource >::Reduce ; (; F ; f, . std::string_view ; columnName = """" . ). inline . Execute a user-defined reduce operation on the values of a column. ; Template Parameters. FThe type of the reduce callable. Automatically deduced. ; TThe type of the column to apply the reduction to. Automatically deduced. . Parameters. [in]fA callable with signature T(T,T) ; [in]columnNameThe column to be reduced. If omitted, the first default column is used instead. . Returnsthe reduced quantity wrapped in a ROOT::RDF:RResultPtr.; A reduction takes",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html:119767,reduce,reduced,119767,doc/master/classROOT_1_1RDF_1_1RInterface.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html,1,['reduce'],['reduced']
Energy Efficiency,"d as non-staged; I, nostagedcheck: do not check the actual stage status on selected files. 'process' field:; N, noaction: do nothing on the selected files; P, fullproc: open the selected files and extract the meta information; L, locateonly: only locate the selected files; S, stageonly: issue a stage request for the selected files not yet staged. 'auxilliary' field; V, verbose: notify the actions. Returns 0 on success, -1 if any failure occurs. Int_t ScanDataSet(const char* uri, UInt_t option = kReopen|kDebug); Scans the dataset indicated by <uri> and returns the number of missing files.; Returns -1 if any failure occurs.; For more details, see documentation of; ScanDataSet(TFileCollection *dataset, const char *option). void GetQuota(const char* group, const char* user, const char* dsName, TFileCollection* dataset). Gets quota information from this dataset. void ShowQuota(const char* opt); Display quota information. void PrintUsedSpace(). Prints the quota. void MonitorUsedSpace(TVirtualMonitoringWriter* monitoring). Log info to the monitoring server. Long64_t GetGroupUsed(const char* group). Returns the used space of that group. Long64_t GetGroupQuota(const char* group). returns the quota a group is allowed to have. void UpdateUsedSpace(); updates the used space maps. Int_t RegisterDataSet(const char* uri, TFileCollection* dataSet, const char* opt); Register a dataset, perfoming quota checkings, if needed.; Returns 0 on success, -1 on failure. Int_t NotifyUpdate(const char* group = 0, const char* user = 0, const char* dspath = 0, Long_t mtime = 0, const char* checksum = 0); Save into the <datasetdir>/dataset.list file the name of the last updated; or created or modified dataset; Returns 0 on success, -1 on error. Int_t ClearCache(const char* uri); Clear cached information matching uri. Int_t ShowCache(const char* uri); Show cached information matching uri. TString CreateUri(const char* dsGroup = 0, const char* dsUser = 0, const char* dsName = 0, const char* dsTree = ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TDataSetManager.html:13387,monitor,monitoring,13387,root/html528/TDataSetManager.html,https://root.cern,https://root.cern/root/html528/TDataSetManager.html,3,['monitor'],['monitoring']
Energy Efficiency,"d buffer is created to hold the compressed buffer.; Reservation of the corresponding space in the file by looking in the TFree list of free blocks of the file.; The buffer is written to the file. Bufsize can be given to force a given buffer size to write this object. By default, the buffersize will be taken from the average buffer size of all objects written to the current file so far.; If a name is specified, it will be the name of the key. If name is not given, the name of the key will be the name as returned by GetName().; The option can be a combination of: kSingleKey, kOverwrite or kWriteDelete Using the kOverwrite option a previous key with the same name is overwritten. The previous key is deleted before writing the new object. Using the kWriteDelete option a previous key with the same name is deleted only after the new object has been written. This option is safer than kOverwrite but it is slower. NOTE: Neither kOverwrite nor kWriteDelete reduces the size of a TFile– the space is simply freed up to be overwritten; in the case of a TTree, it is more complicated. If one opens a TTree, appends some entries, then writes it out, the behaviour is effectively the same. If, however, one creates a new TTree and writes it out in this way, only the metadata is replaced, effectively making the old data invisible without deleting it. TTree::Delete() can be used to mark all disk space occupied by a TTree as free before overwriting its metadata this way. The kSingleKey option is only used by TCollection::Write() to write a container with a single key instead of each object in the container with its own key.; An object is read from the file into memory via TKey::Read() or via TObject::Read().; The function returns the total number of bytes written to the file. It returns 0 if the object cannot be written. ; Reimplemented from TObject.; Definition at line 69 of file TBuffer.h. ◆ Write() [2/2]. Int_t TBuffer::Write ; (; const char * ; name, . Int_t ; option, . Int_t ; bufsize .",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBuffer.html:58869,reduce,reduces,58869,doc/master/classTBuffer.html,https://root.cern,https://root.cern/doc/master/classTBuffer.html,1,['reduce'],['reduces']
Energy Efficiency,"d buffer is created to hold the compressed buffer.; Reservation of the corresponding space in the file by looking in the TFree list of free blocks of the file.; The buffer is written to the file. Bufsize can be given to force a given buffer size to write this object. By default, the buffersize will be taken from the average buffer size of all objects written to the current file so far.; If a name is specified, it will be the name of the key. If name is not given, the name of the key will be the name as returned by GetName().; The option can be a combination of: kSingleKey, kOverwrite or kWriteDelete Using the kOverwrite option a previous key with the same name is overwritten. The previous key is deleted before writing the new object. Using the kWriteDelete option a previous key with the same name is deleted only after the new object has been written. This option is safer than kOverwrite but it is slower. NOTE: Neither kOverwrite nor kWriteDelete reduces the size of a TFile– the space is simply freed up to be overwritten; in the case of a TTree, it is more complicated. If one opens a TTree, appends some entries, then writes it out, the behaviour is effectively the same. If, however, one creates a new TTree and writes it out in this way, only the metadata is replaced, effectively making the old data invisible without deleting it. TTree::Delete() can be used to mark all disk space occupied by a TTree as free before overwriting its metadata this way. The kSingleKey option is only used by TCollection::Write() to write a container with a single key instead of each object in the container with its own key.; An object is read from the file into memory via TKey::Read() or via TObject::Read().; The function returns the total number of bytes written to the file. It returns 0 if the object cannot be written. ; Reimplemented from TObject.; Reimplemented in TSQLFile, TXMLFile, TFile, TParallelMergingFile, and TDirectoryFile.; Definition at line 265 of file TDirectory.h. ◆ Write() ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTDirectory.html:52333,reduce,reduces,52333,doc/v632/classTDirectory.html,https://root.cern,https://root.cern/doc/v632/classTDirectory.html,2,['reduce'],['reduces']
Energy Efficiency,"d buffer is created to hold the compressed buffer.; Reservation of the corresponding space in the file by looking in the TFree list of free blocks of the file.; The buffer is written to the file. Bufsize can be given to force a given buffer size to write this object. By default, the buffersize will be taken from the average buffer size of all objects written to the current file so far.; If a name is specified, it will be the name of the key. If name is not given, the name of the key will be the name as returned by GetName().; The option can be a combination of: kSingleKey, kOverwrite or kWriteDelete Using the kOverwrite option a previous key with the same name is overwritten. The previous key is deleted before writing the new object. Using the kWriteDelete option a previous key with the same name is deleted only after the new object has been written. This option is safer than kOverwrite but it is slower. NOTE: Neither kOverwrite nor kWriteDelete reduces the size of a TFile– the space is simply freed up to be overwritten; in the case of a TTree, it is more complicated. If one opens a TTree, appends some entries, then writes it out, the behaviour is effectively the same. If, however, one creates a new TTree and writes it out in this way, only the metadata is replaced, effectively making the old data invisible without deleting it. TTree::Delete() can be used to mark all disk space occupied by a TTree as free before overwriting its metadata this way. The kSingleKey option is only used by TCollection::Write() to write a container with a single key instead of each object in the container with its own key.; An object is read from the file into memory via TKey::Read() or via TObject::Read().; The function returns the total number of bytes written to the file. It returns 0 if the object cannot be written. ; Reimplemented in TSQLFile, TXMLFile, TDirectory, TBuffer, TFile, TParallelMergingFile, TDirectoryFile, TCollection, TMap, and TTree.; Definition at line 858 of file TObjec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTObject.html:119167,reduce,reduces,119167,doc/v632/classTObject.html,https://root.cern,https://root.cern/doc/v632/classTObject.html,1,['reduce'],['reduces']
Energy Efficiency,"d buffer is created to hold the compressed buffer.; Reservation of the corresponding space in the file by looking in the TFree list of free blocks of the file.; The buffer is written to the file. Bufsize can be given to force a given buffer size to write this object. By default, the buffersize will be taken from the average buffer size of all objects written to the current file so far.; If a name is specified, it will be the name of the key. If name is not given, the name of the key will be the name as returned by GetName().; The option can be a combination of: kSingleKey, kOverwrite or kWriteDelete Using the kOverwrite option a previous key with the same name is overwritten. The previous key is deleted before writing the new object. Using the kWriteDelete option a previous key with the same name is deleted only after the new object has been written. This option is safer than kOverwrite but it is slower. NOTE: Neither kOverwrite nor kWriteDelete reduces the size of a TFile– the space is simply freed up to be overwritten; in the case of a TTree, it is more complicated. If one opens a TTree, appends some entries, then writes it out, the behaviour is effectively the same. If, however, one creates a new TTree and writes it out in this way, only the metadata is replaced, effectively making the old data invisible without deleting it. TTree::Delete() can be used to mark all disk space occupied by a TTree as free before overwriting its metadata this way. The kSingleKey option is only used by TCollection::Write() to write a container with a single key instead of each object in the container with its own key.; An object is read from the file into memory via TKey::Read() or via TObject::Read().; The function returns the total number of bytes written to the file. It returns 0 if the object cannot be written. ; Reimplemented in TSQLFile, TXMLFile, TDirectory, TBuffer, TFile, TParallelMergingFile, TDirectoryFile, TCollection, TMap, and TTree.; Definition at line 864 of file TObjec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTObject.html:118168,reduce,reduces,118168,doc/master/classTObject.html,https://root.cern,https://root.cern/doc/master/classTObject.html,1,['reduce'],['reduces']
Energy Efficiency,"d called by atexit handler installed by RooSentinel; to delete all global heap objects when the program is terminated. RooMinuit(RooAbsReal& function); Construct MINUIT interface to given function. Function can be anything,; but is typically a -log(likelihood) implemented by RooNLLVar or a chi^2; (implemented by RooChi2Var). Other frequent use cases are a RooAddition; of a RooNLLVar plus a penalty or constraint term. This class propagates; all RooFit information (floating parameters, their values and errors); to MINUIT before each MINUIT call and propagates all MINUIT information; back to the RooFit object at the end of each call (updated parameter; values, their (asymmetric errors) etc. The default MINUIT error level; for HESSE and MINOS error analysis is taken from the defaultErrorLevel(); value of the input function. ~RooMinuit(); Destructor. void setStrategy(Int_t strat); Change MINUIT strategy to istrat. Accepted codes; are 0,1,2 and represent MINUIT strategies for dealing; most efficiently with fast FCNs (0), expensive FCNs (2); and 'intermediate' FCNs (1). void setErrorLevel(Double_t level); Set the level for MINUIT error analysis to the given; value. This function overrides the default value; that is taken in the RooMinuit constructor from; the defaultErrorLevel() method of the input function. void setEps(Double_t eps); Change MINUIT epsilon. RooFitResult* fit(const char* options); Parse traditional RooAbsPdf::fitTo driver options. s - Run Hesse first to estimate initial step size; m - Run Migrad only; h - Run Hesse to estimate errors; v - Verbose mode; l - Log parameters after each Minuit steps to file; t - Activate profile timer; r - Save fit result; 0 - Run Migrad with strategy 0. Int_t migrad(); Execute MIGRAD. Changes in parameter values; and calculated errors are automatically; propagated back the RooRealVars representing; the floating parameters in the MINUIT operation. Int_t hesse(); Execute HESSE. Changes in parameter values; and calculated errors ar",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooMinuit.html:8946,efficient,efficiently,8946,root/html526/RooMinuit.html,https://root.cern,https://root.cern/root/html526/RooMinuit.html,4,['efficient'],['efficiently']
Energy Efficiency,"d called by atexit handler installed by RooSentinel; to delete all global heap objects when the program is terminated. RooMinuit(RooAbsReal& function); Construct MINUIT interface to given function. Function can be anything,; but is typically a -log(likelihood) implemented by RooNLLVar or a chi^2; (implemented by RooChi2Var). Other frequent use cases are a RooAddition; of a RooNLLVar plus a penalty or constraint term. This class propagates; all RooFit information (floating parameters, their values and errors); to MINUIT before each MINUIT call and propagates all MINUIT information; back to the RooFit object at the end of each call (updated parameter; values, their (asymmetric errors) etc. The default MINUIT error level; for HESSE and MINOS error analysis is taken from the defaultErrorLevel(); value of the input function. ~RooMinuit(); Destructor. void setStrategy(Int_t strat); Change MINUIT strategy to istrat. Accepted codes; are 0,1,2 and represent MINUIT strategies for dealing; most efficiently with fast FCNs (0), expensive FCNs (2); and 'intermediate' FCNs (1). void setErrorLevel(Double_t level); Set the level for MINUIT error analysis to the given; value. This function overrides the default value; that is taken in the RooMinuit constructor from; the defaultErrorLevel() method of the input function. void setEps(Double_t eps); Change MINUIT epsilon. void setOffsetting(Bool_t flag); Enable internal likelihood offsetting for enhanced numeric precision. RooFitResult* fit(const char* options); Parse traditional RooAbsPdf::fitTo driver options. s - Run Hesse first to estimate initial step size; m - Run Migrad only; h - Run Hesse to estimate errors; v - Verbose mode; l - Log parameters after each Minuit steps to file; t - Activate profile timer; r - Save fit result; 0 - Run Migrad with strategy 0. Int_t migrad(); Execute MIGRAD. Changes in parameter values; and calculated errors are automatically; propagated back the RooRealVars representing; the floating parameters in th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooMinuit.html:9326,efficient,efficiently,9326,root/html534/RooMinuit.html,https://root.cern,https://root.cern/root/html534/RooMinuit.html,3,['efficient'],['efficiently']
Energy Efficiency,"d flush.Definition TTree.h:159; TTree::fDirectoryTDirectory * fDirectory! Pointer to directory holding this treeDefinition TTree.h:121; TTree::kNeedEnableDecomposedObj@ kNeedEnableDecomposedObjDefinition TTree.h:244; TTree::kClassMismatch@ kClassMismatchDefinition TTree.h:237; TTree::kVoidPtr@ kVoidPtrDefinition TTree.h:242; TTree::kMatchConversionCollection@ kMatchConversionCollectionDefinition TTree.h:240; TTree::kMissingCompiledCollectionProxy@ kMissingCompiledCollectionProxyDefinition TTree.h:235; TTree::kMismatch@ kMismatchDefinition TTree.h:236; TTree::kMatchConversion@ kMatchConversionDefinition TTree.h:239; TTree::kInternalError@ kInternalErrorDefinition TTree.h:234; TTree::kMatch@ kMatchDefinition TTree.h:238; TTree::kMissingBranch@ kMissingBranchDefinition TTree.h:233; TTree::kMakeClass@ kMakeClassDefinition TTree.h:241; TTree::fgBranchStylestatic Int_t fgBranchStyleOld/New branch style.Definition TTree.h:154; TTree::ResetBranchAddressesvirtual void ResetBranchAddresses()Tell all of our branches to drop their current objects and allocate new ones.Definition TTree.cxx:8075; TTree::fNfillInt_t fNfill! Local for EntryLoopDefinition TTree.h:110; TTree::SetNamevoid SetName(const char *name) overrideChange the name of this tree.Definition TTree.cxx:9205; TTree::RegisterExternalFriendvirtual void RegisterExternalFriend(TFriendElement *)Record a TFriendElement that we need to warn when the chain switches to a new file (typically this is...Definition TTree.cxx:7957; TTree::fIndexTArrayI fIndexIndex of sorted values.Definition TTree.h:128; TTree::SetCacheSizevirtual Int_t SetCacheSize(Long64_t cachesize=-1)Set maximum size of the file cache .Definition TTree.cxx:8683; TTree::AddClonevoid AddClone(TTree *)Add a cloned tree to our list of trees to be notified whenever we change our branch addresses or when...Definition TTree.cxx:1219; TTree::CheckBranchAddressTypevirtual Int_t CheckBranchAddressType(TBranch *branch, TClass *ptrClass, EDataType datatype, bool ptr)Check",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:464304,allocate,allocate,464304,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['allocate'],['allocate']
Energy Efficiency,"d from ROOT::Fit::FitData; static constexpr unsigned VectorPadding (const unsigned);  If VecCore is not defined, there is no vectorization available and the SIMD vector size will always be one. ;  ;  Protected Attributes inherited from ROOT::Fit::FitData; unsigned int fDim;  ; unsigned int fMaxPoints;  ; unsigned int fNPoints;  ; bool fWrapped;  . #include <Fit/BinData.h>. Inheritance diagram for ROOT::Fit::BinData:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Enumeration Documentation. ◆ ErrorType. enum ROOT::Fit::BinData::ErrorType. EnumeratorkNoError ; kValueError ; kCoordError ; kAsymError . Definition at line 56 of file BinData.h. Constructor & Destructor Documentation. ◆ BinData() [1/7]. ROOT::Fit::BinData::BinData ; (; unsigned int ; maxpoints = 0, . unsigned int ; dim = 1, . ErrorType ; err = kValueError . ). explicit . constructor from dimension of point and max number of points (to pre-allocate vector) Give a zero value and then use Initialize later one if the size is not known ; Definition at line 24 of file BinData.cxx. ◆ BinData() [2/7]. ROOT::Fit::BinData::BinData ; (; const DataOptions & ; opt, . unsigned int ; maxpoints = 0, . unsigned int ; dim = 1, . ErrorType ; err = kValueError . ). explicit . constructor from option and default range ; Definition at line 40 of file BinData.cxx. ◆ BinData() [3/7]. ROOT::Fit::BinData::BinData ; (; const DataOptions & ; opt, . const DataRange & ; range, . unsigned int ; maxpoints = 0, . unsigned int ; dim = 1, . ErrorType ; err = kValueError . ). constructor from options and range default is 1D and value errors ; constructor from options and range efault is 1D and value errors ; Definition at line 56 of file BinData.cxx. ◆ BinData() [4/7]. ROOT::Fit::BinData::BinData ; (; unsigned int ; n, . const double * ; dataX, . const double * ; val, . const double * ; ex, . const double * ; eval . ). constructors using external data ; constructor from external data fo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Fit_1_1BinData.html:14882,allocate,allocate,14882,doc/master/classROOT_1_1Fit_1_1BinData.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Fit_1_1BinData.html,1,['allocate'],['allocate']
Energy Efficiency,"d here. However,; if the order is kept small (< 6?) any inefficiency is negligible for; in-memory sorting. Knuth points out that balanced trees are actually; preferable for memory sorting. I'm not sure that I believe this, but; it's interesting. Also, deleting elements from balanced binary trees, being; beyond the scope of Knuth's book (p. 465), is beyond my scope. B-trees; are good enough. A B-tree is declared to be of a certain ORDER (3 by default). This number; determines the number of keys contained in any interior node of the tree.; Each interior node will contain ORDER keys, and therefore ORDER+1 pointers; to sub-trees. The keys are numbered and indexed 1 to ORDER while the; pointers are numbered and indexed 0 to ORDER. The 0th ptr points to the; sub-tree of all elements that are less than key[1]. Ptr[1] points to the; sub-tree that contains all the elements greater than key[1] and less than; key[2]. etc. The array of pointers and keys is allocated as ORDER+1; pairs of keys and nodes, meaning that one key field (key[0]) is not used; and therefore wasted. Given that the number of interior nodes is; small, that this waste allows fewer cases of special code, and that it; is useful in certain of the methods, it was felt to be a worthwhile waste. The size of the exterior nodes (leaf nodes) does not need to be related to; the size of the interior nodes at all. Since leaf nodes contain only; keys, they may be as large or small as we like independent of the size; of the interior nodes. For no particular reason other than it seems like; a good idea, we will allocate 2*(ORDER+1) keys in each leaf node, and they; will be numbered and indexed from 0 to 2*ORDER+1. It does have the advantage; of keeping the size of the leaf and interior arrays the same, so that if we; find allocation and de-allocation of these arrays expensive, we can modify; their allocation to use a garbage ring, or something. Both of these numbers will be run-time constants associated with each tree; (ea",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TBtree.html:3813,allocate,allocated,3813,root/html526/TBtree.html,https://root.cern,https://root.cern/root/html526/TBtree.html,7,['allocate'],['allocated']
Energy Efficiency,"d histogram will be Asymmetry_nameOfh1-nameOfh2. code proposed by Jason Seely (seely@mit.edu) and adapted by R.Brun. clone the histograms so top and bottom will have the; correct dimensions:; Sumw2 just makes sure the errors will be computed properly; when we form sums and ratios below. Int_t GetDefaultBufferSize(); static function; return the default buffer size for automatic histograms; the parameter fgBufferSize may be changed via SetDefaultBufferSize. Bool_t GetDefaultSumw2(); static function; return kTRUE if TH1::Sumw2 must be called when creating new histograms.; see TH1::SetDefaultSumw2. Double_t GetEntries() const; return the current number of entries. Double_t GetEffectiveEntries() const; number of effective entries of the histogram,; neff = (Sum of weights )^2 / (Sum of weight^2 ); In case of an unweighted histogram this number is equivalent to the; number of entries of the histogram.; For a weighted histogram, this number corresponds to the hypotetical number of unweighted entries; a histogram would need to have the same statistical power as this weighted histogram.; Note: The underflow/overflow are included if one has set the TH1::StatOverFlows flag; and if the statistics has been computed at filling time.; If a range is set in the histogram the number is computed from the given range. char * GetObjectInfo(Int_t px, Int_t py) const; Redefines TObject::GetObjectInfo.; Displays the histogram info (bin number, contents, integral up to bin; corresponding to cursor position px,py. TVirtualHistPainter * GetPainter(Option_t* option = """"); return pointer to painter; if painter does not exist, it is created. Int_t GetQuantiles(Int_t nprobSum, Double_t* q, const Double_t* probSum = 0); Compute Quantiles for this histogram; Quantile x_q of a probability distribution Function F is defined as. F(x_q) = q with 0 <= q <= 1. For instance the median x_0.5 of a distribution is defined as that value; of the random variable for which the distribution function equals 0.5:. F",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TH1.html:92043,power,power,92043,root/html602/TH1.html,https://root.cern,https://root.cern/root/html602/TH1.html,2,['power'],['power']
Energy Efficiency,"d in the current medium. void TrackPosition(TLorentzVector& position) const. get methods; tracking particle; dynamic properties. Return the current position in the master reference frame of the; track being transported. void TrackPosition(Double_t& x, Double_t& y, Double_t& z) const; Return the current position in the master reference frame of the; track being transported. void TrackMomentum(TLorentzVector& momentum) const; Return the direction and the momentum (GeV/c) of the track; currently being transported. void TrackMomentum(Double_t& px, Double_t& py, Double_t& pz, Double_t& etot) const; Return the direction and the momentum (GeV/c) of the track; currently being transported. Double_t TrackStep() const; Return the length in centimeters of the current step (in cm). Double_t TrackLength() const; Return the length of the current track from its origin (in cm). Double_t TrackTime() const; Return the current time of flight of the track being transported. Double_t Edep() const; Return the energy lost in the current step. Int_t TrackPid() const. get methods; tracking particle; static properties. Return the PDG of the particle transported. Double_t TrackCharge() const; Return the charge of the track currently transported. Double_t TrackMass() const; Return the mass of the track currently transported. Double_t Etot() const; Return the total energy of the current track. Bool_t IsNewTrack() const. get methods - track status. Return true when the track performs the first step. Bool_t IsTrackInside() const; Return true if the track is not at the boundary of the current volume. Bool_t IsTrackEntering() const; Return true if this is the first step of the track in the current volume. Bool_t IsTrackExiting() const; Return true if this is the last step of the track in the current volume. Bool_t IsTrackOut() const; Return true if the track is out of the setup. Bool_t IsTrackDisappeared() const; Return true if the current particle has disappeared; either because it decayed or becaus",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualMC.html:34402,energy,energy,34402,root/html528/TVirtualMC.html,https://root.cern,https://root.cern/root/html528/TVirtualMC.html,6,['energy'],['energy']
Energy Efficiency,"d or MonteCarlo Integration (GSLMCIntegrator).; 48The basic classes ROOT::Math::IntegratorOneDim provides a common interface for the one-dimensional methods while the class; 49ROOT::Math::IntegratorMultiDim provides the interface for the multi-dimensional ones.; 50The methods can be configured (e.g setting the default method with its default parameters) using the ROOT::Math::IntegratorOneDimOptions and; 51ROOT::Math::IntegratorMultiDimOptions classes.; 52 ; 53@ingroup NumAlgo; 54 ; 55*/; 56 ; 57 ; 58 ; 59namespace ROOT {; 60namespace Math {; 61 ; 62 ; 63 ; 64 ; 65//____________________________________________________________________________________________; 66/**; 67 ; 68User Class for performing numerical integration of a function in one dimension.; 69It uses the plug-in manager to load advanced numerical integration algorithms from GSL, which reimplements the; 70algorithms used in the QUADPACK, a numerical integration package written in Fortran.; 71 ; 72Various types of adaptive and non-adaptive integration are supported. These include; 73integration over infinite and semi-infinite ranges and singular integrals.; 74 ; 75The integration type is selected using the Integration::type enumeration; 76in the class constructor.; 77The default type is adaptive integration with singularity; 78(ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; 79In the case of ADAPTIVE type, the integration rule can also be specified via the; 80Integration::GKRule. The default rule is 31 points.; 81 ; 82In the case of integration over infinite and semi-infinite ranges, the type used is always; 83ADAPTIVESINGULAR applying a transformation from the original interval into (0,1).; 84 ; 85The ADAPTIVESINGULAR type is the most sophisticated type. When performances are; 86important, it is then recommended to use the NONADAPTIVE type in case of smooth functions or; 87 ADAPTIVE with a lower Gauss-Kronrod rule.; 88 ; 89For detailed description on",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Integrator_8h_source.html:2373,adapt,adaptive,2373,doc/master/Integrator_8h_source.html,https://root.cern,https://root.cern/doc/master/Integrator_8h_source.html,2,['adapt'],['adaptive']
Energy Efficiency,"d the difference with the meaning of nbits; -in case of [-1,1,nbits], nbits is the total number of bits used to make; the conversion from a double to an integer; -in case of [0,0,nbits], nbits is the number of bits used for the mantissa. see example of use of the Double32_t data type in tutorial double32.C. /*; ; */. Int_t ReadArray(Bool_t*& b); Read array of bools from the I/O buffer. Returns the number of; bools read. If argument is a 0 pointer then space will be; allocated for the array. Int_t ReadArray(Char_t*& c); Read array of characters from the I/O buffer. Returns the number of; characters read. If argument is a 0 pointer then space will be; allocated for the array. Int_t ReadArray(Short_t*& h); Read array of shorts from the I/O buffer. Returns the number of shorts; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Int_t*& i); Read array of ints from the I/O buffer. Returns the number of ints; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Long_t*& l); Read array of longs from the I/O buffer. Returns the number of longs; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Long64_t*& l); Read array of long longs from the I/O buffer. Returns the number of; long longs read. If argument is a 0 pointer then space will be; allocated for the array. Int_t ReadArray(Float_t*& f); Read array of floats from the I/O buffer. Returns the number of floats; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Double_t*& d); Read array of doubles from the I/O buffer. Returns the number of doubles; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArrayFloat16(Float_t*& f, TStreamerElement* ele = 0); Read array of floats (written as truncated float) from the I/O buffer.; Returns the number of floats read.; If argument is a 0 pointer then space will be allocated for th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TBufferFile.html:27314,allocate,allocated,27314,root/html528/TBufferFile.html,https://root.cern,https://root.cern/root/html528/TBufferFile.html,6,['allocate'],['allocated']
Energy Efficiency,"d the eigenvalues and vectors of the tridiagonal matrix. . Definition at line 884 of file TPrincipal.cxx. ◆ MakeRealCode(). void TPrincipal::MakeRealCode ; (; const char * ; filename, . const char * ; classname, . Option_t * ; option = """" . ). protected . This is the method that actually generates the code for the transformations to and from feature space and pattern space It's called by TPrincipal::MakeCode and TPrincipal::MakeMethods. ; The options are: NONE so far ; Definition at line 906 of file TPrincipal.cxx. ◆ operator=(). TPrincipal & TPrincipal::operator= ; (; const TPrincipal & ; pr). protected . Assignment operator. ; Definition at line 337 of file TPrincipal.cxx. ◆ P2X(). void TPrincipal::P2X ; (; const Double_t * ; p, . Double_t * ; x, . Int_t ; nTest . ). virtual . Calculate x as a function of nTest of the most significant principal components p, and return it in x. ; It's the users responsibility to make sure that both x and p are of the right size (i.e., memory must be allocated for x). ; Definition at line 1074 of file TPrincipal.cxx. ◆ Print(). void TPrincipal::Print ; (; Option_t * ; opt = ""MSE""); const. overridevirtual . Print the statistics Options are. . M Print mean values of original data; S Print sigma values of original data; E Print eigenvalues of covariance matrix; V Print eigenvectors of covariance matrix Default is MSE . Reimplemented from TNamed.; Definition at line 1094 of file TPrincipal.cxx. ◆ Streamer(). void TPrincipal::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TNamed. ◆ StreamerNVirtual(). void TPrincipal::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 79 of file TPrincipal.h. ◆ SumOfSquareResiduals(). void TPrincipal::SumOfSquareResiduals ; (; const Double_t * ; x, . Double_t * ; s . ). virtual . Calculates the sum of the square residuals, that is. . \[; E_N = \sum_{i=0}^{P-1} \left(x_i - x^\prime_i\right)^2; \]. where \",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPrincipal.html:31134,allocate,allocated,31134,doc/master/classTPrincipal.html,https://root.cern,https://root.cern/doc/master/classTPrincipal.html,1,['allocate'],['allocated']
Energy Efficiency,"d to have converged ; Definition at line 766 of file NeuralNet.h. ◆ create() [1/2]. void TMVA::DNN::Settings::create ; (; std::string ; histoName, . int ; bins, . double ; min, . double ; max . ). inline . for monitoring ; Definition at line 819 of file NeuralNet.h. ◆ create() [2/2]. void TMVA::DNN::Settings::create ; (; std::string ; histoName, . int ; bins, . double ; min, . double ; max, . int ; bins2, . double ; min2, . double ; max2 . ). inline . for monitoring ; Definition at line 820 of file NeuralNet.h. ◆ cycle(). virtual void TMVA::DNN::Settings::cycle ; (; double ; progress, . TString ; text . ). inlinevirtual . Parameters. textadvance on the progress bar; progressthe new value; texta label . Definition at line 799 of file NeuralNet.h. ◆ drawSample(). virtual void TMVA::DNN::Settings::drawSample ; (; const std::vector< double > & ; , . const std::vector< double > & ; , . const std::vector< double > & ; , . double ;  . ). inlinevirtual . callback for monitoring and logging ; Definition at line 807 of file NeuralNet.h. ◆ dropFractions(). const std::vector< double > & TMVA::DNN::Settings::dropFractions ; (; ); const. inline . Definition at line 762 of file NeuralNet.h. ◆ dropRepetitions(). size_t TMVA::DNN::Settings::dropRepetitions ; (; ); const. inline . Definition at line 761 of file NeuralNet.h. ◆ endTestCycle(). virtual void TMVA::DNN::Settings::endTestCycle ; (; ). inlinevirtual . callback for monitoring and loggging ; Reimplemented in TMVA::DNN::ClassificationSettings.; Definition at line 805 of file NeuralNet.h. ◆ endTrainCycle(). virtual void TMVA::DNN::Settings::endTrainCycle ; (; double ; ). inlinevirtual . callback for monitoring and logging ; Reimplemented in TMVA::DNN::ClassificationSettings.; Definition at line 788 of file NeuralNet.h. ◆ exists(). bool TMVA::DNN::Settings::exists ; (; std::string ; histoName). inline . for monitoring ; Definition at line 825 of file NeuralNet.h. ◆ factorWeightDecay(). double TMVA::DNN::Settings::factorWeightDec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1Settings.html:7670,monitor,monitoring,7670,doc/master/classTMVA_1_1DNN_1_1Settings.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1Settings.html,1,['monitor'],['monitoring']
Energy Efficiency,"d to re-define completly the class. {}. virtual ~GSLSimAnFunc(); virtual distructor (no operations). { }. GSLSimAnFunc & FastCopy(const ROOT::Math::GSLSimAnFunc& f). fast copy method called by GSL simuated annealing internally; copy only the things which have been changed; must be re-implemented by derived classes if needed. GSLSimAnFunc * Clone() const. clone method. Needs to be re-implemented by the derived classes for deep copying. return new GSLSimAnFunc(const ROOT::Math::GSLSimAnFunc& ). double Energy() const. evaluate the energy ( objective function value); re-implement by derived classes if needed to be modified. void Step(const ROOT::Math::GSLRandomEngine& r, double maxstep). change the x[i] value using a random value urndm generated between [0,1]; up to a maximum value maxstep; re-implement by derived classes if needed to be modified. double Distance(const ROOT::Math::GSLSimAnFunc& func) const. calculate the distance (metric) between this one and another configuration; Presently a cartesian metric is used.; re-implement by derived classes if needed to be modified. void Print(). print the position in the standard output ostream; GSL prints in addition n iteration, n function calls, temperature and energy; re-implement by derived classes if necessary. void SetX(const double* x). change the x values (used by sim annealing to take a step). void SetX(unsigned int i, double x). unsigned int NDim() const; { return fX.size(); }. double X(unsigned int i) const; { return fX[i]; }. const std::vector<double> & X() const; { return fX; }. double Scale(unsigned int i) const; { return fScale[i]; }. » Author: L. Moneta Thu Jan 25 11:13:48 2007 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathmore:$Id: GSLSimAnnealing.h 21553 2007-12-21 10:55:46Z moneta $ » Last generated: 2009-12-07 13:43; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__GSLSimAnFunc.html:3523,energy,energy,3523,root/html526/ROOT__Math__GSLSimAnFunc.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__GSLSimAnFunc.html,1,['energy'],['energy']
Energy Efficiency,"d to re-define completly the class. {}. virtual ~GSLSimAnFunc(); virtual distructor (no operations). { }. GSLSimAnFunc & FastCopy(const ROOT::Math::GSLSimAnFunc& f). fast copy method called by GSL simuated annealing internally; copy only the things which have been changed; must be re-implemented by derived classes if needed. GSLSimAnFunc * Clone() const. clone method. Needs to be re-implemented by the derived classes for deep copying. return new GSLSimAnFunc(const ROOT::Math::GSLSimAnFunc& ). double Energy() const. evaluate the energy ( objective function value); re-implement by derived classes if needed to be modified. void Step(const ROOT::Math::GSLRandomEngine& r, double maxstep). change the x[i] value using a random value urndm generated between [0,1]; up to a maximum value maxstep; re-implement by derived classes if needed to be modified. double Distance(const ROOT::Math::GSLSimAnFunc& func) const. calculate the distance (metric) between this one and another configuration; Presently a cartesian metric is used.; re-implement by derived classes if needed to be modified. void Print(). print the position in the standard output ostream; GSL prints in addition n iteration, n function calls, temperature and energy; re-implement by derived classes if necessary. void SetX(const double* x). change the x values (used by sim annealing to take a step). void SetX(unsigned int i, double x). unsigned int NDim() const; { return fX.size(); }. double X(unsigned int i) const; { return fX[i]; }. const std::vector<double> & X() const; { return fX; }. double Scale(unsigned int i) const; { return fScale[i]; }. » Author: L. Moneta Thu Jan 25 11:13:48 2007 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathmore:$Id: GSLSimAnnealing.h 21553 2007-12-21 10:55:46Z moneta $ » Last generated: 2010-09-23 19:56; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__GSLSimAnFunc.html:3523,energy,energy,3523,root/html528/ROOT__Math__GSLSimAnFunc.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__GSLSimAnFunc.html,1,['energy'],['energy']
Energy Efficiency,"d to re-define completly the class. {}. virtual ~GSLSimAnFunc(); virtual distructor (no operations). { }. GSLSimAnFunc & FastCopy(const ROOT::Math::GSLSimAnFunc& f). fast copy method called by GSL simuated annealing internally; copy only the things which have been changed; must be re-implemented by derived classes if needed. GSLSimAnFunc * Clone() const. clone method. Needs to be re-implemented by the derived classes for deep copying. return new GSLSimAnFunc(const ROOT::Math::GSLSimAnFunc& ). double Energy() const. evaluate the energy ( objective function value); re-implement by derived classes if needed to be modified. void Step(const ROOT::Math::GSLRandomEngine& r, double maxstep). change the x[i] value using a random value urndm generated between [0,1]; up to a maximum value maxstep; re-implement by derived classes if needed to be modified. double Distance(const ROOT::Math::GSLSimAnFunc& func) const. calculate the distance (metric) between this one and another configuration; Presently a cartesian metric is used.; re-implement by derived classes if needed to be modified. void Print(). print the position in the standard output ostream; GSL prints in addition n iteration, n function calls, temperature and energy; re-implement by derived classes if necessary. void SetX(const double* x). change the x values (used by sim annealing to take a step). void SetX(unsigned int i, double x). unsigned int NDim() const; { return fX.size(); }. double X(unsigned int i) const; { return fX[i]; }. const std::vector<double> & X() const; { return fX; }. double Scale(unsigned int i) const; { return fScale[i]; }. » Author: L. Moneta Thu Jan 25 11:13:48 2007 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathmore:$Id: GSLSimAnnealing.h 21553 2007-12-21 10:55:46Z moneta $ » Last generated: 2011-07-04 15:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ROOT__Math__GSLSimAnFunc.html:3525,energy,energy,3525,root/html530/ROOT__Math__GSLSimAnFunc.html,https://root.cern,https://root.cern/root/html530/ROOT__Math__GSLSimAnFunc.html,1,['energy'],['energy']
Energy Efficiency,"d to re-define completly the class. {}. virtual ~GSLSimAnFunc(); virtual distructor (no operations). { }. GSLSimAnFunc & FastCopy(const ROOT::Math::GSLSimAnFunc& f). fast copy method called by GSL simuated annealing internally; copy only the things which have been changed; must be re-implemented by derived classes if needed. GSLSimAnFunc * Clone() const. clone method. Needs to be re-implemented by the derived classes for deep copying. return new GSLSimAnFunc(const ROOT::Math::GSLSimAnFunc& ). double Energy() const. evaluate the energy ( objective function value); re-implement by derived classes if needed to be modified. void Step(const ROOT::Math::GSLRandomEngine& r, double maxstep). change the x[i] value using a random value urndm generated between [0,1]; up to a maximum value maxstep; re-implement by derived classes if needed to be modified. double Distance(const ROOT::Math::GSLSimAnFunc& func) const. calculate the distance (metric) between this one and another configuration; Presently a cartesian metric is used.; re-implement by derived classes if needed to be modified. void Print(). print the position in the standard output ostream; GSL prints in addition n iteration, n function calls, temperature and energy; re-implement by derived classes if necessary. void SetX(const double* x). change the x values (used by sim annealing to take a step). void SetX(unsigned int i, double x). unsigned int NDim() const; { return fX.size(); }. double X(unsigned int i) const; { return fX[i]; }. const std::vector<double> & X() const; { return fX; }. double Scale(unsigned int i) const; { return fScale[i]; }. » Author: L. Moneta Thu Jan 25 11:13:48 2007 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathmore:$Id: GSLSimAnnealing.h 21553 2007-12-21 10:55:46Z moneta $ » Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ROOT__Math__GSLSimAnFunc.html:3525,energy,energy,3525,root/html532/ROOT__Math__GSLSimAnFunc.html,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLSimAnFunc.html,1,['energy'],['energy']
Energy Efficiency,"d using get().; Since RooDataSet saves every event, it allows for fits with highest precision. With a large amount of data, however, it could be beneficial to represent them in binned form, i.e., RooDataHist. Binning the data will incur a loss of information, though. RooDataHist on the other hand may suffer from the curse of dimensionality if a high-dimensional problem with a lot of bins on each axis is tackled. Inspecting a dataset; Inspect a dataset using Print() with the ""verbose"" option: dataset->Print(""V"");; dataset->get(0)->Print(""V"");; dataset->get(1)->Print(""V"");; ... Plotting data.; See RooAbsData::plotOn(). Storage strategy; There are two storage backends:; RooVectorDataStore (default): std::vectors in memory. They are fast, but they cannot be serialised if the dataset exceeds a size of 1 Gb; RooTreeDataStore: Uses a TTree, which can be file backed if a file is opened before creating the dataset. This significantly reduces the memory pressure, as the baskets of the tree can be written to a file, and only the basket that's currently being read stays in RAM.; Enable tree-backed storage similar to this: TFile outputFile(""filename.root"", ""RECREATE"");; RooAbsData::setDefaultStorageType(RooAbsData::Tree);; RooDataSet mydata(...);; RooAbsData::setDefaultStorageTypestatic void setDefaultStorageType(StorageType s)Definition RooAbsData.cxx:130; RooAbsData::Tree@ TreeDefinition RooAbsData.h:278; RooDataSetContainer class to hold unbinned data.Definition RooDataSet.h:33; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53. Or convert an existing memory-backed data storage: RooDataSet mydata(...);; ; TFile outputFile(""filename.root"", ""RECREATE"");; mydata.convertToTreeStore();. For the inverse conversion, see RooAbsData::convertToVectorStore(). Creating a dataset using RDataFrame; See alsoRooAbsDataHelper, rf408_RDataFrameToRooFit.C. Uniquely identifying RooDataSet objects; WarningBefore v6.28",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooDataSet.html:1563,reduce,reduces,1563,doc/master/classRooDataSet.html,https://root.cern,https://root.cern/doc/master/classRooDataSet.html,1,['reduce'],['reduces']
Energy Efficiency,"d when. Optionally, the user may impose a functional expression by specifying; the powers of each variable in specified functions ; (TMultiDimFit::SetPowers). In that case, only the; coefficients is calculated by the class. Limiting the Number of Terms. As always when dealing with fits, there's a real chance of; over fitting. As is well-known, it's always possible to fit an; polynomial in to points with ; , but; the polynomial is not likely to fit new data at all; [1]. Therefore, the user is asked to provide an upper; limit, to the number of terms in ; (TMultiDimFit::SetMaxTerms). However, since there's an infinite number of to choose from, the; user is asked to give the maximum power. , of each variable; to be considered in the minimization of ; (TMultiDimFit::SetMaxPowers). One way of obtaining values for the maximum power in variable , is; to perform a regular fit to the dependent quantity , using a; polynomial only in . The maximum power is is then the; power that does not significantly improve the one-dimensional; least-square fit over to [5]. There are still a huge amount of possible choices for ; in fact; there are ; possible; choices. Obviously we need to limit this. To this end, the user is; asked to set a power control limit, ; (TMultiDimFit::SetPowerLimit), and a function; is only accepted if. where is the leading power of variable in function; . (TMultiDimFit::MakeCandidates). So the number of; functions increase with (1, 2 is fine, 5 is way out). Gram-Schmidt Orthogonalisation. To further reduce the number of functions in the final expression,; only those functions that significantly reduce is chosen. What; `significant' means, is chosen by the user, and will be; discussed below (see 2.3). The functions are generally not orthogonal, which means one will; have to evaluate all possible 's over all data-points before; finding the most significant [1]. We can, however, do; better then that. By applying the modified Gram-Schmidt; orthogonalisation algorithm [",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMultiDimFit.html:4112,power,power,4112,root/html528/TMultiDimFit.html,https://root.cern,https://root.cern/root/html528/TMultiDimFit.html,6,['power'],['power']
Energy Efficiency,"d*,void*,size_t);; 511 void* (*fCollectFunc)(void*,void*);; 512 void* (*fCreateEnv)();; 513 ; 514 // Set of function of direct iteration of the collections.; 515 void (*fCreateIterators)(void *collection, void **begin_arena, void **end_arena, TVirtualCollectionProxy *proxy);; 516 // begin_arena and end_arena should contain the location of memory arena of size fgIteratorSize.; 517 // If the collection iterator are of that size or less, the iterators will be constructed in place in those location (new with placement); 518 // Otherwise the iterators will be allocated via a regular new and their address returned by modifying the value of begin_arena and end_arena.; 519 ; 520 void* (*fCopyIterator)(void *dest, const void *source);; 521 // Copy the iterator source, into dest. dest should contain should contain the location of memory arena of size fgIteratorSize.; 522 // If the collection iterator are of that size or less, the iterator will be constructed in place in this location (new with placement); 523 // Otherwise the iterator will be allocated via a regular new and its address returned by modifying the value of dest.; 524 ; 525 void* (*fNext)(void *iter, const void *end);; 526 // iter and end should be pointer to respectively an iterator to be incremented and the result of colleciton.end(); 527 // 'Next' will increment the iterator 'iter' and return 0 if the iterator reached the end.; 528 // If the end is not reached, 'Next' will return the address of the content unless the collection contains pointers in; 529 // which case 'Next' will return the value of the pointer.; 530 ; 531 void (*fDeleteSingleIterator)(void *iter);; 532 void (*fDeleteTwoIterators)(void *begin, void *end);; 533 // If the sizeof iterator is greater than fgIteratorArenaSize, call delete on the addresses,; 534 // Otherwise just call the iterator's destructor.; 535 ; 536 public:; 537 TCollectionProxyInfo(const std::type_info& info,; 538 size_t iter_size,; 539 size_t value_diff,; 540 int value_offset,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCollectionProxyInfo_8h_source.html:17425,allocate,allocated,17425,doc/master/TCollectionProxyInfo_8h_source.html,https://root.cern,https://root.cern/doc/master/TCollectionProxyInfo_8h_source.html,1,['allocate'],['allocated']
Energy Efficiency,"d*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TSpectrumFit&operator=(const TSpectrumFit&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidSetBackgroundParameters(Double_t a0Init, Bool_t fixA0, Double_t a1Init, Bool_t fixA1, Double_t a2Init, Bool_t fixA2); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetFitParameters(Int_t xmin, Int_t xmax, Int_t numberIterations, Double_t alpha, Int_t statisticType, Int_t alphaOptim, Int_t power, Int_t fitTaylor); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidSetPeakParameters(Double_t sigma, Bool_t fixSigma, const Double_t* positionInit, const Bool_t* fixPosition, const Double_t* ampInit, const Bool_t* fixAmp); voidSetTailParameters(Double_t tInit, Bool_t fixT, Double_t bInit, Bool_t fixB, Double_t sInit, Bool_t fixS); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TSpectrumFit(); TSpectrumFit(Int_t numberPeaks); TSpectrumFit(const TSpectrumFit&); virtual",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSpectrumFit.html:5562,power,power,5562,root/html602/TSpectrumFit.html,https://root.cern,https://root.cern/root/html602/TSpectrumFit.html,2,['power'],['power']
Energy Efficiency,"d*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TSpectrumFit&operator=(const TSpectrumFit&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidSetBackgroundParameters(Double_t a0Init, Bool_t fixA0, Double_t a1Init, Bool_t fixA1, Double_t a2Init, Bool_t fixA2); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetFitParameters(Int_t xmin, Int_t xmax, Int_t numberIterations, Double_t alpha, Int_t statisticType, Int_t alphaOptim, Int_t power, Int_t fitTaylor); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidSetPeakParameters(Double_t sigma, Bool_t fixSigma, const Float_t* positionInit, const Bool_t* fixPosition, const Float_t* ampInit, const Bool_t* fixAmp); voidSetTailParameters(Double_t tInit, Bool_t fixT, Double_t bInit, Bool_t fixB, Double_t sInit, Bool_t fixS); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TSpectrumFit.html:5644,power,power,5644,root/html530/TSpectrumFit.html,https://root.cern,https://root.cern/root/html530/TSpectrumFit.html,2,['power'],['power']
Energy Efficiency,"d*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TSpectrumFit&operator=(const TSpectrumFit&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidSetBackgroundParameters(Double_t a0Init, Bool_t fixA0, Double_t a1Init, Bool_t fixA1, Double_t a2Init, Bool_t fixA2); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetFitParameters(Int_t xmin, Int_t xmax, Int_t numberIterations, Double_t alpha, Int_t statisticType, Int_t alphaOptim, Int_t power, Int_t fitTaylor); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidSetPeakParameters(Double_t sigma, Bool_t fixSigma, const Float_t* positionInit, const Bool_t* fixPosition, const Float_t* ampInit, const Bool_t* fixAmp); voidSetTailParameters(Double_t tInit, Bool_t fixT, Double_t bInit, Bool_t fixB, Double_t sInit, Bool_t fixS); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector&); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TSpectrumFit.html:5644,power,power,5644,root/html534/TSpectrumFit.html,https://root.cern,https://root.cern/root/html534/TSpectrumFit.html,1,['power'],['power']
Energy Efficiency,"d, const char *text) constReturn text ascent and descent for string text.Definition TText.cxx:525; TText::SetNDCvirtual void SetNDC(Bool_t isNDC=kTRUE)Set NDC mode on if isNDC = kTRUE, off otherwise.Definition TText.cxx:823; TText::GetControlBoxvirtual void GetControlBox(Int_t x, Int_t y, Double_t theta, Int_t cBoxX[4], Int_t cBoxY[4])Return the text control box.Definition TText.cxx:424; TVirtualPSTVirtualPS is an abstract interface to Postscript, PDF, SVG.Definition TVirtualPS.h:30; TVirtualPS::Textvirtual void Text(Double_t x, Double_t y, const char *string)=0; bool; double; int; unsigned int; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; TMath::NintInt_t Nint(T x)Round to nearest integer. Rounds half integers to the nearest even integer.Definition TMath.h:693; TMath::MaxShort_t Max(Short_t a, Short_t b)Returns the largest of a and b.Definition TMathBase.h:250; TMath::ExpDouble_t Exp(Double_t x)Returns the base-e exponential function of x, which is e raised to the power x.Definition TMath.h:709; TMath::LogDouble_t Log(Double_t x)Returns the natural logarithm of x.Definition TMath.h:756; TMath::MinShort_t Min(Short_t a, Short_t b)Returns the smallest of a and b.Definition TMathBase.h:198; TMath::CosDouble_t Cos(Double_t)Returns the cosine of an angle of x radians.Definition TMath.h:594; TMath::Piconstexpr Double_t Pi()Definition TMath.h:37; TMath::SinDouble_t Sin(Double_t)Returns the sine of an angle of x radians.Definition TMath.h:588; TMath::AbsShort_t Abs(Short_t d)Returns the absolute value of parameter Short_t d.Definition TMathBase.h:123; TLatex::TextSpec_tTLatex helper struct holding the attributes of a piece of text.Definition TLatex.h:24; TLatex::TextSpec_t::fFontInt_t fFontDefinition TLatex.h:26; TLatex::TextSpec_t::fSizeDouble_t fSizeDefinition TLatex.h:25; TLatex::TextSpec_t::fAngleDouble_t fAngleDefinition TLatex.h:25; TLatex::TextSpec_t::fColorInt_t fColorDefinition TLatex.h:26; mT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TLatex_8cxx_source.html:115118,power,power,115118,doc/master/TLatex_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TLatex_8cxx_source.html,1,['power'],['power']
Energy Efficiency,"d.; status code: 0. Normal exit. . At least minpts and at most maxpts calls to the function were performed.; maxpts is too small for the specified accuracy eps. The result and relerr contain the values obtainable for the specified value of maxpts.; size is too small for the specified number MAXPTS of function evaluations.; n<2 or n>15. Method:; An integration rule of degree seven is used together with a certain strategy of subdivision. For a more detailed description of the method see References. Notes:; 1..Multi-dimensional integration is time-consuming. For each rectangular subregion, the routine requires function evaluations. Careful programming of the integrand might result in substantial saving of time. 2..Numerical integration usually works best for smooth functions. Some analysis or suitable transformations of the integral prior to numerical work may contribute to numerical efficiency. References:. A.C. Genz and A.A. Malik, Remarks on algorithm 006: An adaptive algorithm for numerical integration over an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302.; A. van Doren and L. de Ridder, An adaptive algorithm for numerical integration over an n-dimensional cube, J.Comput. Appl. Math. 2 (1976) 207-217. . Definition at line 84 of file AdaptiveIntegratorMultiDim.h. Public Member Functions;  AdaptiveIntegratorMultiDim (const IMultiGenFunction &f, double absTol=0.0, double relTol=1E-9, unsigned int maxcall=100000, unsigned int size=0);  Construct with a reference to the integrand function and given optionally tolerance (absolute and relative), maximum number of function evaluation (maxpts) and size of the working array. ;  ;  AdaptiveIntegratorMultiDim (double absTol=0.0, double relTol=1E-9, unsigned int maxpts=100000, unsigned int size=0);  Construct given optionally tolerance (absolute and relative), maximum number of function evaluation (maxpts) and size of the working array. ;  ;  ~AdaptiveIntegratorMultiDim () override;  destructor (no o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1AdaptiveIntegratorMultiDim.html:2543,adapt,adaptive,2543,doc/master/classROOT_1_1Math_1_1AdaptiveIntegratorMultiDim.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1AdaptiveIntegratorMultiDim.html,1,['adapt'],['adaptive']
Energy Efficiency,"d2); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual const TMatrixDBase&GetDecompMatrix() const; Int_tTDecompBase::Hager(Double_t& est, Int_t iter = 5); voidTObject::MakeZombie(); voidTDecompBase::ResetStatus(). Data Members; public:. enum TDecompBase::EMatrixDecompStat { kInit; kPatternSet; kValuesSet; kMatrixSet; kDecomposed; kDetermined; kCondition; kSingular; };; enum TDecompBase::[unnamed] { kWorkMax; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Int_tTDecompBase::fColLwbColumn lower bound of decomposed matrix; Double_tTDecompBase::fConditionmatrix condition number; Double_tTDecompBase::fDet1determinant mantissa; Double_tTDecompBase::fDet2determinant exponent for powers of 2; Int_t*fIpiv[fNIpiv] row permutation index; Int_tfNIpivsize of row permutation index; Int_tTDecompBase::fRowLwbRow lower bound of decomposed matrix; Double_tTDecompBase::fTolsqrt(epsilon); epsilon is smallest number number so that 1+epsilon > 1; TMatrixDfUdecomposed matrix so that a = u d u^T. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TDecompBK(); Default constructor. TDecompBK(Int_t nrows); Constructor for (nrows x nrows) symmetric matrix. TDecompBK(Int_t row_lwb, Int_t row_upb); Constructor for ([row_lwb..row_upb] x [row_lwb..row_upb]) symmetric matrix. TDecompBK(const TMatrixDSym& m, Double_t tol = 0.0); Constructor for symmetric matrix A. TDecompBK(const TDecompBK& another); Copy constructor. Bool_t Decompose(); Matrix A is decomposed in components U and D so that A = U*D*U^T; If the decomposition succeeds, bit kDecomposed is set , otherwise kSingular. void SetMatrix(const TMatrixDSym& a); Set the matrix to be decomposed, decomposition status is reset. Bool_t Sol",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TDecompBK.html:8133,power,powers,8133,root/html528/TDecompBK.html,https://root.cern,https://root.cern/root/html528/TDecompBK.html,4,['power'],['powers']
Energy Efficiency,"dArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; virtual voidTObject::Pop(); virtual voidRooAbsData::Print(Option_t* options = 0) const; virtual voidRooPrintable::printAddress(ostream& os) const; virtual voidRooPrintable::printArgs(ostream& os) const; virtual voidRooAbsData::printClassName(ostream& os) const; virtual voidRooPrintable::printExtras(ostream& os) const; virtual voidRooAbsData::printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; virtual voidRooAbsData::printName(ostream& os) const; virtual voidRooPrintable::printStream(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidRooAbsData::printTitle(ostream& os) const; virtual voidRooPrintable::printTree(ostream& os, TString indent = """") const; virtual voidRooPrintable::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); RooAbsData*RooAbsData::reduce(const char* cut); RooAbsData*RooAbsData::reduce(const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const char* cut = 0); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(RooCmdArg arg1, RooCmdArg arg2 = RooCmdArg(), RooCmdArg arg3 = RooCmdArg(), RooCmdArg arg4 = RooCmdArg(), RooCmdArg arg5 = RooCmdArg(), RooCmdArg arg6 = RooCmdArg(), RooCmdArg arg7 = RooCmdArg(), RooCmdArg arg8 = RooCmdArg()); virtual voidRooAbsData::reset(); voidTObject::ResetBit(UInt_t f); RooRealVar*RooAbsData::rmsVar(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidRooAbsData::setDirtyProp(Bool_t flag); virtual void",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooTreeData.html:8120,reduce,reduce,8120,root/html526/RooTreeData.html,https://root.cern,https://root.cern/root/html526/RooTreeData.html,2,['reduce'],['reduce']
Energy Efficiency,"dArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; virtual voidTObject::Pop(); virtual voidRooAbsData::Print(Option_t* options = 0) const; virtual voidRooPrintable::printAddress(ostream& os) const; virtual voidRooPrintable::printArgs(ostream& os) const; virtual voidRooAbsData::printClassName(ostream& os) const; virtual voidRooPrintable::printExtras(ostream& os) const; virtual voidRooAbsData::printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; virtual voidRooAbsData::printName(ostream& os) const; virtual voidRooPrintable::printStream(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidRooAbsData::printTitle(ostream& os) const; virtual voidRooPrintable::printTree(ostream& os, TString indent = """") const; virtual voidRooPrintable::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); RooAbsData*RooAbsData::reduce(const char* cut); RooAbsData*RooAbsData::reduce(const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const char* cut = 0); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); static Bool_tRooAbsData::releaseVars(RooAbsData*); virtual voidRooAbsData::reset(); voidTObject::ResetBit(UInt_t f); RooRealVar*RooAbsData::rmsVar(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UI",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooTreeData.html:8439,reduce,reduce,8439,root/html530/RooTreeData.html,https://root.cern,https://root.cern/root/html530/RooTreeData.html,1,['reduce'],['reduce']
Energy Efficiency,"dArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; virtual voidTObject::Pop(); virtual voidRooAbsData::Print(Option_t* options = 0) const; virtual voidRooPrintable::printAddress(ostream& os) const; virtual voidRooPrintable::printArgs(ostream& os) const; virtual voidRooAbsData::printClassName(ostream& os) const; virtual voidRooPrintable::printExtras(ostream& os) const; virtual voidRooAbsData::printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; virtual voidRooAbsData::printName(ostream& os) const; virtual voidRooPrintable::printStream(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidRooAbsData::printTitle(ostream& os) const; virtual voidRooPrintable::printTree(ostream& os, TString indent = """") const; virtual voidRooPrintable::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); RooAbsData*RooAbsData::reduce(const char* cut); RooAbsData*RooAbsData::reduce(const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const char* cut = 0); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); static Bool_tRooAbsData::releaseVars(RooAbsData*); virtual voidRooAbsData::reset(); voidTObject::ResetBit(UInt_t f); voidRooAbsData::resetBuffers(); RooRealVar*RooAbsData::rmsVar(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; RooTreeData(); RooTreeData(const RooTreeData&); RooTreeData(RooTreeData&&); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObjec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooTreeData.html:8676,reduce,reduce,8676,root/html602/RooTreeData.html,https://root.cern,https://root.cern/root/html602/RooTreeData.html,2,['reduce'],['reduce']
Energy Efficiency,"dArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; virtual voidTObject::Pop(); virtual voidRooAbsData::Print(Option_t* options = 0) const; virtual voidRooPrintable::printAddress(ostream& os) const; virtual voidRooPrintable::printArgs(ostream& os) const; virtual voidRooAbsData::printClassName(ostream& os) const; virtual voidRooPrintable::printExtras(ostream& os) const; virtual voidRooAbsData::printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; virtual voidRooAbsData::printName(ostream& os) const; virtual voidRooPrintable::printStream(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidRooAbsData::printTitle(ostream& os) const; virtual voidRooPrintable::printTree(ostream& os, TString indent = """") const; virtual voidRooPrintable::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); RooAbsData*RooAbsData::reduce(const char* cut); RooAbsData*RooAbsData::reduce(const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const char* cut = 0); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); static Bool_tRooAbsData::releaseVars(RooAbsData*); virtual voidRooAbsData::reset(); voidTObject::ResetBit(UInt_t f); voidRooAbsData::resetBuffers(); RooRealVar*RooAbsData::rmsVar(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(U",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooTreeData.html:8535,reduce,reduce,8535,root/html532/RooTreeData.html,https://root.cern,https://root.cern/root/html532/RooTreeData.html,2,['reduce'],['reduce']
Energy Efficiency,"dObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. RooLinkedListRooAbsCollection::_listActual object store; TStringRooAbsCollection::_nameOur name.; static Int_tRooPrintable::_nameLength; Bool_tRooAbsCollection::_ownContFlag to identify a list that owns its contents.; static char*_poolBegin! Start of memory pool; static char*_poolCur! Next free slot in memory pool; static char*_poolEnd! End of memory pool . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void cleanup(); Clear memoery pool on exit to avoid reported memory leaks. void* operator new(size_t bytes); Overloaded new operator guarantees that all RooArgSets allocated with new; have a unique address, a property that is exploited in several places; in roofit to quickly index contents on normalization set pointers.; The memory pool only allocates space for the class itself. The elements; stored in the set are stored outside the pool. void operator delete(void* ptr); Memory is owned by pool, we need to do nothing to release it. RooArgSet(); Default constructor. RooArgSet(const RooArgList& list); Constructor from a RooArgList. If the list contains multiple; objects with the same name, only the first is store in the set.; Warning messages will be printed for dropped items. RooArgSet(const RooArgList& list, const RooAbsArg* var1); Constructor from a RooArgList. If the list contains multiple; objects with the same name, only the first is store in the set.; Warning messages will be printed for dropped items. RooArgSet(const char *name); Empty set constructor. RooArgSet(const RooArgSet& set1, const RooArgSet& set2, const char *name); Construct a set from two existing sets. RooArgSe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooArgSet.html:13866,allocate,allocated,13866,root/html526/RooArgSet.html,https://root.cern,https://root.cern/root/html526/RooArgSet.html,1,['allocate'],['allocated']
Energy Efficiency,"dObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. RooLinkedListRooAbsCollection::_listActual object store; TStringRooAbsCollection::_nameOur name.; static Int_tRooPrintable::_nameLength; Bool_tRooAbsCollection::_ownContFlag to identify a list that owns its contents.; static char*_poolBegin! Start of memory pool; static char*_poolCur! Next free slot in memory pool; static char*_poolEnd! End of memory pool . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void cleanup(); Clear memoery pool on exit to avoid reported memory leaks. void* operator new(size_t bytes); Overloaded new operator guarantees that all RooArgSets allocated with new; have a unique address, a property that is exploited in several places; in roofit to quickly index contents on normalization set pointers.; The memory pool only allocates space for the class itself. The elements; stored in the set are stored outside the pool. void operator delete(void* ptr); Memory is owned by pool, we need to do nothing to release it. RooArgSet(); Default constructor. RooArgSet(const RooArgList& list); Constructor from a RooArgList. If the list contains multiple; objects with the same name, only the first is store in the set.; Warning messages will be printed for dropped items. RooArgSet(const RooArgList& list, const RooAbsArg* var1); Constructor from a RooArgList. If the list contains multiple; objects with the same name, only the first is store in the set.; Warning messages will be printed for dropped items. RooArgSet(const char* name); Empty set constructor. RooArgSet(const RooArgSet& set1, const RooArgSet& set2, const char* name = """"); Construct a set from two existing sets. Roo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooArgSet.html:13892,allocate,allocated,13892,root/html528/RooArgSet.html,https://root.cern,https://root.cern/root/html528/RooArgSet.html,2,['allocate'],['allocated']
Energy Efficiency,"dParameters (Double_t &a0, Double_t &a0Err, Double_t &a1, Double_t &a1Err, Double_t &a2, Double_t &a2Err);  This function gets the background parameters and their errors. ;  ; Double_t GetChi () const;  ; Double_t * GetPositions () const;  ; Double_t * GetPositionsErrors () const;  ; void GetSigma (Double_t &sigma, Double_t &sigmaErr);  This function gets the sigma parameter and its error. ;  ; void GetTailParameters (Double_t &t, Double_t &tErr, Double_t &b, Double_t &bErr, Double_t &s, Double_t &sErr);  This function gets the tail parameters and their errors. ;  ; TClass * IsA () const override;  ; void SetBackgroundParameters (Double_t a0Init, Bool_t fixA0, Double_t a1Init, Bool_t fixA1, Double_t a2Init, Bool_t fixA2);  This function sets the following fitting parameters of background: ;  ; void SetFitParameters (Int_t xmin, Int_t xmax, Int_t numberIterations, Double_t alpha, Int_t statisticType, Int_t alphaOptim, Int_t power, Int_t fitTaylor);  This function sets the following fitting parameters: ;  ; void SetPeakParameters (Double_t sigma, Bool_t fixSigma, const Double_t *positionInit, const Bool_t *fixPosition, const Double_t *ampInit, const Bool_t *fixAmp);  This function sets the following fitting parameters of peaks: ;  ; void SetTailParameters (Double_t tInit, Bool_t fixT, Double_t bInit, Bool_t fixB, Double_t sInit, Bool_t fixS);  This function sets the following fitting parameters of tails of peaks. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  M",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSpectrumFit.html:4125,power,power,4125,doc/master/classTSpectrumFit.html,https://root.cern,https://root.cern/doc/master/classTSpectrumFit.html,1,['power'],['power']
Energy Efficiency,"dTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoHelix&operator=(const TGeoHelix&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidResetStep(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidSetCharge(Int_t charge); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetField(Double_t bx, Double_t by, Double_t bz, Bool_t is_normalized = kTRUE); voidSetHelixStep(Double_t hstep); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); voidSetXYcurvature(Double_t curvature); virtual voidShowMembers(TMemberInspector& insp); voidStep(Double_t step); Double_tStepToPlane(Double_t* point, Double_t* norm); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; voidUpdateHelix(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t opti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoHelix.html:5452,charge,charge,5452,root/html528/TGeoHelix.html,https://root.cern,https://root.cern/root/html528/TGeoHelix.html,1,['charge'],['charge']
Energy Efficiency,"d[9] = { 0./255., 45./255., 99./255., 156./255., 212./255., 230./255., 237./255., 234./255., 242./255.};; 3008 Double_t green[9] = { 0./255., 0./255., 0./255., 45./255., 101./255., 168./255., 238./255., 238./255., 243./255.};; 3009 Double_t blue[9] = { 0./255., 1./255., 1./255., 3./255., 9./255., 8./255., 11./255., 95./255., 230./255.};; 3010 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3011 }; 3012 break;; 3013 ; 3014 // Two-color hue (dark blue through neutral gray to bright yellow); 3015 case 54:; 3016 {; 3017 Double_t red[9] = { 0./255., 22./255., 44./255., 68./255., 93./255., 124./255., 160./255., 192./255., 237./255.};; 3018 Double_t green[9] = { 0./255., 16./255., 41./255., 67./255., 93./255., 125./255., 162./255., 194./255., 241./255.};; 3019 Double_t blue[9] = { 97./255., 100./255., 99./255., 99./255., 93./255., 68./255., 44./255., 26./255., 74./255.};; 3020 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3021 }; 3022 break;; 3023 ; 3024 // Rain Bow; 3025 case 55:; 3026 {; 3027 Double_t red[9] = { 0./255., 5./255., 15./255., 35./255., 102./255., 196./255., 208./255., 199./255., 110./255.};; 3028 Double_t green[9] = { 0./255., 48./255., 124./255., 192./255., 206./255., 226./255., 97./255., 16./255., 0./255.};; 3029 Double_t blue[9] = { 99./255., 142./255., 198./255., 201./255., 90./255., 22./255., 13./255., 8./255., 2./255.};; 3030 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3031 }; 3032 break;; 3033 ; 3034 // Inverted Dark Body Radiator; 3035 case 56:; 3036 {; 3037 Double_t red[9] = { 242./255., 234./255., 237./255., 230./255., 212./255., 156./255., 99./255., 45./255., 0./255.};; 3038 Double_t green[9] = { 243./255., 238./255., 238./255., 168./255., 101./255., 45./255., 0./255., 0./255., 0./255.};; 3039 Double_t blue[9] = { 230./255., 95./255., 11./255., 8./255., 9./255., 3./255., 1./255., 1./255., 0./255.};; 3040 Idx = TColor::CreateGradientColorTable(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TColor_8cxx_source.html:113621,green,green,113621,doc/master/TColor_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html,1,['green'],['green']
Energy Efficiency,"daptive backward difference algorithm with a step size h. ; The function is evaluated only at points less than x and at x itself ; Definition at line 99 of file GSLDerivator.cxx. ◆ EvalBackward() [2/2]. double ROOT::Math::GSLDerivator::EvalBackward ; (; double ; x, . double ; h . ). Computes the numerical derivative at a point x using an adaptive backward difference algorithm with a step size h. ; The function is evaluated only at points less than x and at x itself. ; Definition at line 69 of file GSLDerivator.cxx. ◆ EvalCentral() [1/2]. double ROOT::Math::GSLDerivator::EvalCentral ; (; const IGenFunction & ; f, . double ; x, . double ; h . ). static . Computes the numerical derivative of a function f at a point x using an adaptive central difference algorithm with a step size h. ; Definition at line 81 of file GSLDerivator.cxx. ◆ EvalCentral() [2/2]. double ROOT::Math::GSLDerivator::EvalCentral ; (; double ; x, . double ; h . ). Computes the numerical derivative at a point x using an adaptive central difference algorithm with a step size h. ; Definition at line 47 of file GSLDerivator.cxx. ◆ EvalForward() [1/2]. double ROOT::Math::GSLDerivator::EvalForward ; (; const IGenFunction & ; f, . double ; x, . double ; h . ). static . Computes the numerical derivative of a function f at a point x using an adaptive forward difference algorithm with a step size h. ; The function is evaluated only at points greater than x and at x itself ; Definition at line 90 of file GSLDerivator.cxx. ◆ EvalForward() [2/2]. double ROOT::Math::GSLDerivator::EvalForward ; (; double ; x, . double ; h . ). Computes the numerical derivative at a point x using an adaptive forward difference algorithm with a step size h. ; The function is evaluated only at points greater than x and at x itself. ; Definition at line 58 of file GSLDerivator.cxx. ◆ Result(). double ROOT::Math::GSLDerivator::Result ; (; ); const. return the result of the last derivative calculation ; Definition at line 109 of file GSL",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1GSLDerivator.html:4496,adapt,adaptive,4496,doc/master/classROOT_1_1Math_1_1GSLDerivator.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1GSLDerivator.html,1,['adapt'],['adaptive']
Energy Efficiency,"daptiveGaussKronrodIntegrator1D. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAdaptiveGaussKronrodIntegrator1D. class RooAdaptiveGaussKronrodIntegrator1D: public RooAbsIntegrator. RooAdaptiveGaussKronrodIntegrator1D implements the Gauss-Kronrod integration algorithm.; An adaptive Gaussian quadrature method for numerical integration in; which error is estimation based on evaluation at special points; known as ""Kronrod points."" By suitably picking these points,; abscissas from previous iterations can be reused as part of the new; set of points, whereas usual Gaussian quadrature would require; recomputation of all abscissas at each iteration.; This class automatically handles (-inf,+inf) integrals by dividing; the integration in three regions (-inf,-1), (-1,1), (1,inf) and; calculating the 1st and 3rd term using a x -> 1/x coordinate; transformation; This class embeds the adaptive Gauss-Kronrod integrator from the; GNU Scientific Library version 1.5 and applies a chosen rule ( 10-,; 21-, 31-, 41, 51- or 61-point). The integration domain is; subdivided and recursively integrated until the required precision; is reached.; For integrands with integrable singulaties the Wynn epsilon rule; can be selected to speed up the converges of these integrals; . Function Members (Methods); public:. RooAdaptiveGaussKronrodIntegrator1D(); RooAdaptiveGaussKronrodIntegrator1D(const RooAdaptiveGaussKronrodIntegrator1D&); RooAdaptiveGaussKronrodIntegrator1D(const RooAbsFunc& function, const RooNumIntConfig& config); RooAdaptiveGaussKronrodIntegrator1D(const RooAbsFunc& function, Double_t xmin, Double_t xmax, const RooNumIntConfig& config); virtual~RooAdaptiveGaussKronrodIntegrator1D(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); vi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAdaptiveGaussKronrodIntegrator1D.html:1085,adapt,adaptive,1085,root/html526/RooAdaptiveGaussKronrodIntegrator1D.html,https://root.cern,https://root.cern/root/html526/RooAdaptiveGaussKronrodIntegrator1D.html,5,['adapt'],['adaptive']
Energy Efficiency,"daptiveGaussKronrodIntegrator1D. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAdaptiveGaussKronrodIntegrator1D. class RooAdaptiveGaussKronrodIntegrator1D: public RooAbsIntegrator. RooAdaptiveGaussKronrodIntegrator1D implements the Gauss-Kronrod integration algorithm.; An adaptive Gaussian quadrature method for numerical integration in; which error is estimation based on evaluation at special points; known as ""Kronrod points."" By suitably picking these points,; abscissas from previous iterations can be reused as part of the new; set of points, whereas usual Gaussian quadrature would require; recomputation of all abscissas at each iteration.; This class automatically handles (-inf,+inf) integrals by dividing; the integration in three regions (-inf,-1), (-1,1), (1,inf) and; calculating the 1st and 3rd term using a x -> 1/x coordinate; transformation; This class embeds the adaptive Gauss-Kronrod integrator from the; GNU Scientific Library version 1.5 and applies a chosen rule ( 10-,; 21-, 31-, 41, 51- or 61-point). The integration domain is; subdivided and recursively integrated until the required precision; is reached.; For integrands with integrable singulaties the Wynn epsilon rule; can be selected to speed up the converges of these integrals; . Function Members (Methods); public:. virtual~RooAdaptiveGaussKronrodIntegrator1D(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); Double_tRooAbsIntegrator::calculate(const Double_t* yvec = 0); virtual Bool_tcanIntegrate1D() const; virtual Bool_tcanIntegrate2D() const; virtual Bool_tcanIntegrateND() const; virtual Bool_tcanIntegrateOpenEnded() const; virtual Bool_tcheckLimits() const; static TClass*Class(); virtual const char*TOb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAdaptiveGaussKronrodIntegrator1D.html:1085,adapt,adaptive,1085,root/html602/RooAdaptiveGaussKronrodIntegrator1D.html,https://root.cern,https://root.cern/root/html602/RooAdaptiveGaussKronrodIntegrator1D.html,2,['adapt'],['adaptive']
Energy Efficiency,"data objects. ; If the file exists the object in the file are added to those in the fInputData list. If the file path is null, a default file will be created at the moment of sending the processing request with the content of the fInputData list. See also SendInputDataFile. ; Definition at line 9585 of file TProof.cxx. ◆ SetLogLevel(). void TProof::SetLogLevel ; (; Int_t ; level, . UInt_t ; mask = TProofDebug::kAll . ). Set server logging level. ; Definition at line 7079 of file TProof.cxx. ◆ SetManager(). void TProof::SetManager ; (; TProofMgr * ; mgr). Set manager and schedule its destruction after this for clean operations. ; Definition at line 1301 of file TProof.cxx. ◆ SetMaxDrawQueries(). void TProof::SetMaxDrawQueries ; (; Int_t ; max). Set max number of draw queries whose results are saved. ; Definition at line 2115 of file TProof.cxx. ◆ SetMonitor(). void TProof::SetMonitor ; (; TMonitor * ; mon = 0, . Bool_t ; on = kTRUE . ). private . Activate (on == TRUE) or deactivate (on == FALSE) all sockets monitored by 'mon'. ; Definition at line 2408 of file TProof.cxx. ◆ SetParallel(). Int_t TProof::SetParallel ; (; Int_t ; nodes = -1, . Bool_t ; random = kFALSE . ). Tell PROOF how many slaves to use in parallel. ; Returns the number of parallel slaves. Returns -1 in case of error. ; Definition at line 7140 of file TProof.cxx. ◆ SetParallelSilent(). Int_t TProof::SetParallelSilent ; (; Int_t ; nodes, . Bool_t ; random = kFALSE . ). private . Tell PROOF how many slaves to use in parallel. ; If random is TRUE a random selection is done (if nodes is less than the available nodes). Returns the number of parallel slaves. Returns -1 in case of error. ; Definition at line 7112 of file TProof.cxx. ◆ SetParameter() [1/5]. void TProof::SetParameter ; (; const char * ; par, . const char * ; value . ). Set input list parameter. ; If the parameter is already set it will be set to the new value. ; Definition at line 9822 of file TProof.cxx. ◆ SetParameter() [2/5]. void TProof::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProof.html:144473,monitor,monitored,144473,doc/master/classTProof.html,https://root.cern,https://root.cern/doc/master/classTProof.html,1,['monitor'],['monitored']
Energy Efficiency,"data()Return number of available instances in the formula.Definition TTreeFormula.cxx:4485; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; TTree::SetBranchStatusvirtual void SetBranchStatus(const char *bname, bool status=true, UInt_t *found=nullptr)Set branch status to Process or DoNotProcess.Definition TTree.cxx:8534; TTree::GetEntryvirtual Int_t GetEntry(Long64_t entry, Int_t getall=0)Read all branches of entry and return total number of bytes read.Definition TTree.cxx:5638; TTree::GetCurrentFileTFile * GetCurrentFile() constReturn pointer to the current file.Definition TTree.cxx:5479; TTree::GetDirectoryTDirectory * GetDirectory() constDefinition TTree.h:462; TTree::GetEntriesvirtual Long64_t GetEntries() constDefinition TTree.h:463; TTree::GetTreevirtual TTree * GetTree() constDefinition TTree.h:557; TTree::LoadTreevirtual Long64_t LoadTree(Long64_t entry)Set current entry.Definition TTree.cxx:6473; TTree::ResetBranchAddressesvirtual void ResetBranchAddresses()Tell all of our branches to drop their current objects and allocate new ones.Definition TTree.cxx:8075; TVectorT< Double_t >; bool; double; int; unsigned int; TMVAcreate variable transformationsDefinition GeneticMinimizer.h:22; TMVA::LargestCommonDividerInt_t LargestCommonDivider(Int_t a, Int_t b)Definition DataSetFactory.cxx:80; TMVA::EndlMsgLogger & Endl(MsgLogger &ml)Definition MsgLogger.h:148; TMath::IsNaNBool_t IsNaN(Double_t x)Definition TMath.h:892; TMath::MaxShort_t Max(Short_t a, Short_t b)Returns the largest of a and b.Definition TMathBase.h:250; TMath::FiniteInt_t Finite(Double_t x)Check if it is finite with a mask in order to be consistent in presence of fast math.Definition TMath.h:770; TMath::AbsShort_t Abs(Short_t d)Returns the absolute value of parameter Short_t d.Definition TMathBase.h:123; v@ vDefinition rootcling_impl.cxx:3699; whatstatic const char * whatDefinition stlLoader.cc:5; vecDefinition civetweb.c:1855; Types.h. tmvatmvasrcDataSetFactory.cxx. ROOT master - Refe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/DataSetFactory_8cxx_source.html:95934,allocate,allocate,95934,doc/master/DataSetFactory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/DataSetFactory_8cxx_source.html,1,['allocate'],['allocate']
Energy Efficiency,"data, its size should be sizex*sizey except for direct FOURIER, FOUR-WALSh, FOUR-HAAR. These need sizex*2*sizey length to store real and imaginary coefficients; sizex,sizey: basic dimensions of the source and dest spectra; type: type of transform. TRANSFORM2_HAAR; TRANSFORM2_WALSH; TRANSFORM2_COS; TRANSFORM2_SIN; TRANSFORM2_FOURIER; TRANSFORM2_HARTLEY; TRANSFORM2_FOURIER_WALSH; TRANSFORM2_FOURIER_HAAR; TRANSFORM2_WALSH_HAAR; TRANSFORM2_COS_WALSH; TRANSFORM2_COS_HAAR; TRANSFORM2_SIN_WALSH; TRANSFORM2_SIN_HAAR. direction: transform direction (forward, inverse); degree: applies only for mixed transforms. An example of the 2-dimensional Cosine transform of data from Figure 5.6 is given in Figure 6.7. One can notice that the data are concentrated again around the beginning of the coordinate system. This allows to apply filtration, enhancement and compression techniques in the transform domain. 2-dimensional Cosine transform of data from Figure 5.6. In some cases, when the spectrum is smooth, the cosine transforms are very efficient. In Figures 6.8, 6.9 we show original spectrum and transformed coefficients using Cosine transform, respectively. Original spectrum. Transformed coefficients using Cosine transform. Similarly to 1-dimensional case we have also implemented the functions for zonal filtration, Gauss filtration and enhancement. The zonal filtration function using classic transforms has the form of; char *Filter2Zonal(const float **source,; float **dest,; int sizex,; int sizey,; int type,; int degree,; int xmin,; int xmax,; int ymin,; int ymax,; float filter_coeff);; This function transforms the source spectrum. The calling program should fill in the input parameters. Then it sets transformed coefficients in the given region to the given filter_coeff and transforms it back. Filtered data are written into the dest spectrum.; Function parameters:. source: pointer to the matrix of source spectrum, its size should be sizex*sizey; dest: pointer to the matrix of destinat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html:63686,efficient,efficient,63686,root/htmldoc/guides/spectrum/Spectrum.html,https://root.cern,https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html,1,['efficient'],['efficient']
Energy Efficiency,"dd one dim data with no error in the coordinate (x) in this case store the inverse of the error in the value (y) ; Definition at line 428 of file BinData.cxx. ◆ AddBinUpEdge(). void ROOT::Fit::BinData::AddBinUpEdge ; (; const double * ; xup). add the bin width data, a pointer to an array with the bin upper edge information. ; This is needed when fitting with integral options The information is added for the previously inserted point. BinData::Add must be called before; This is needed when fitting with integral or Bin volume normalization options The information is added for the previously inserted point. BinData::Add must be called before ; Definition at line 613 of file BinData.cxx. ◆ Append(). void ROOT::Fit::BinData::Append ; (; unsigned int ; newPoints, . unsigned int ; dim = 1, . ErrorType ; err = kValueError . ). Equivalent to Initialize() ; preallocate a data set with given size , dimension and error type (to get the full point size) If the data set already exists and it is having the compatible point size space for the new points is created in the data sets, while if not compatible the old data are erased and new space of new size is allocated.; (i.e if exists initialize is equivalent to a resize( NPoints() + maxpoints) ; Definition at line 320 of file BinData.cxx. ◆ BinUpEdge(). const double * ROOT::Fit::BinData::BinUpEdge ; (; unsigned int ; ipoint); const. inline . return an array containing the upper edge of the bin for coordinate i In case of empty bin they could be merged in a single larger bin Return a NULL pointer if the bin width is not stored ; Definition at line 519 of file BinData.h. ◆ ComputeSums(). void ROOT::Fit::BinData::ComputeSums ; (; ). protected . Definition at line 814 of file BinData.cxx. ◆ CoordErrors(). const double * ROOT::Fit::BinData::CoordErrors ; (; unsigned int ; ipoint); const. inline . Return a pointer to the errors in the coordinates for the given fit point. ; Definition at line 412 of file BinData.h. ◆ Error(). double ROOT:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Fit_1_1BinData.html:20049,allocate,allocated,20049,doc/master/classROOT_1_1Fit_1_1BinData.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Fit_1_1BinData.html,1,['allocate'],['allocated']
Energy Efficiency,"ddress of) a shared pointer to the struct holding the actual thread local gDirectory pointer and the atomic_flag for its lock. ;  . #include <TMemFile.h>. Inheritance diagram for TMemFile:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Typedef Documentation. ◆ ExternalDataPtr_t. using TMemFile::ExternalDataPtr_t = std::shared_ptr<const std::vector<char> >. Definition at line 21 of file TMemFile.h. Member Enumeration Documentation. ◆ EMode. enum class TMemFile::EMode. strongprotected . EnumeratorkCreate ; kRecreate ; kUpdate ; kRead . Definition at line 75 of file TMemFile.h. Constructor & Destructor Documentation. ◆ TMemFile() [1/6]. TMemFile::TMemFile ; (; const char * ; path, . Option_t * ; option = """", . const char * ; ftitle = """", . Int_t ; compress = ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, . Long64_t ; defBlockSize = 0LL . ). Usual Constructor. ; The defBlockSize parameter defines the size of the blocks of memory allocated when expanding the underlying TMemFileBuffer. If the value 0 is passed, the default block size, fgDefaultBlockSize, is adopted. See the TFile constructor for details. ; Definition at line 162 of file TMemFile.cxx. ◆ TMemFile() [2/6]. TMemFile::TMemFile ; (; const char * ; name, . char * ; buffer, . Long64_t ; size, . Option_t * ; option = """", . const char * ; ftitle = """", . Int_t ; compress = ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, . Long64_t ; defBlockSize = 0LL . ). Usual Constructor. See the TFile constructor for details. Copy data from buffer. ; Definition at line 170 of file TMemFile.cxx. ◆ TMemFile() [3/6]. TMemFile::TMemFile ; (; const char * ; name, . ExternalDataPtr_t ; data . ). Constructor to create a TMemFile re-using external storage. ; Definition at line 133 of file TMemFile.cxx. ◆ TMemFile() [4/6]. TMemFile::TMemFile ; (; const char * ; name, . const ZeroCopyView_t & ; datarange . ). Constructor to create a TMemFile re-using external ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTMemFile.html:44374,allocate,allocated,44374,doc/v632/classTMemFile.html,https://root.cern,https://root.cern/doc/v632/classTMemFile.html,2,['allocate'],['allocated']
