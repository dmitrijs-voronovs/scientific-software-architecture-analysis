quality_attribute,sentence,source,author,repo,version,id,keyword,matched_word,match_idx,filename,wiki,url,total_similar,target_keywords,target_matched_words
Performance,"n the file. ;  ; virtual void Map ();  ; virtual void Map (Option_t *opt);  List the contents of a file sequentially. ;  ; virtual Bool_t Matches (const char *name);  Return kTRUE if 'url' matches the coordinates of this file. ;  ; virtual Bool_t MustFlush () const;  ; void Paint (Option_t *option="""") override;  Paint all objects in the file. ;  ; void Print (Option_t *option="""") const override;  Print all objects in the file. ;  ; virtual void ReadFree ();  Read the FREE linked list. ;  ; virtual TProcessID * ReadProcessID (UShort_t pidf);  The TProcessID with number pidf is read from this file. ;  ; virtual void ReadStreamerInfo ();  Read the list of StreamerInfo from this file. ;  ; virtual Int_t Recover ();  Attempt to recover file if not correctly closed. ;  ; virtual Int_t ReOpen (Option_t *mode);  Reopen a file with a different access mode. ;  ; virtual void ResetErrno () const;  Method resetting the errno. ;  ; virtual void SetCacheRead (TFileCacheRead *cache, TObject *tree=nullptr, ECacheAction action=kDisconnect);  Set a pointer to the read cache. ;  ; virtual void SetCacheWrite (TFileCacheWrite *cache);  Set a pointer to the write cache. ;  ; virtual void SetCompressionAlgorithm (Int_t algorithm=ROOT::RCompressionSetting::EAlgorithm::kUseGlobal);  See comments for function SetCompressionSettings. ;  ; virtual void SetCompressionLevel (Int_t level=ROOT::RCompressionSetting::ELevel::kUseMin);  See comments for function SetCompressionSettings. ;  ; virtual void SetCompressionSettings (Int_t settings=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault);  Used to specify the compression level and algorithm. ;  ; virtual void SetEND (Long64_t last);  ; virtual void SetOffset (Long64_t offset, ERelativeTo pos=kBeg);  Set position from where to start reading. ;  ; virtual void SetOption (Option_t *option="">"");  ; virtual void SetReadCalls (Int_t readcalls=0);  ; virtual void ShowStreamerInfo ();  Show the StreamerInfo of all classes written to this file. ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDavixFile.html:6658,cache,cache,6658,doc/master/classTDavixFile.html,https://root.cern,https://root.cern/doc/master/classTDavixFile.html,2,['cache'],['cache']
Performance,"n the number of bytes written;. TBasket* GetBasket(Int_t basket); Return pointer to basket basketnumber in this Branch. Long64_t GetBasketSeek(Int_t basket) const; Return address of basket in the file. TList* GetBrowsables(); Returns (and, if 0, creates) browsable objects for this branch; See TVirtualBranchBrowsable::FillListOfBrowsables. const char * GetClassName() const; Return the name of the user class whose content is stored in this branch,; if any. If this branch was created using the 'leaflist' technique, this; function returns an empty string. const char* GetIconName() const; Return icon name depending on type of branch. Int_t GetEntry(Long64_t entry = 0, Int_t getall = 0); Read all leaves of entry and return total number of bytes read. The input argument ""entry"" is the entry number in the current tree.; In case of a TChain, the entry number in the current Tree must be found; before calling this function. For example:. TChain* chain = ...;; Long64_t localEntry = chain->LoadTree(entry);; branch->GetEntry(localEntry);. The function returns the number of bytes read from the input buffer.; If entry does not exist, the function returns 0.; If an I/O error occurs, the function returns -1. See IMPORTANT REMARKS in TTree::GetEntry. Int_t GetEntryExport(Long64_t entry, Int_t getall, TClonesArray* list, Int_t n); Read all leaves of an entry and export buffers to real objects in a TClonesArray list. Returns total number of bytes read. Int_t GetExpectedType(TClass*& clptr, EDataType& type); Fill expectedClass and expectedType with information on the data type of the; object/values contained in this branch (and thus the type of pointers; expected to be passed to Set[Branch]Address; return 0 in case of success and > 0 in case of failure. TFile* GetFile(Int_t mode = 0); Return pointer to the file where branch buffers reside, returns 0; in case branch buffers reside in the same file as tree header.; If mode is 1 the branch buffer file is recreated. TBasket* GetFreshBasket()",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TBranch.html:18949,Load,LoadTree,18949,root/html532/TBranch.html,https://root.cern,https://root.cern/root/html532/TBranch.html,4,['Load'],['LoadTree']
Performance,"n the same container volume, then positioning the container itself. However, there are many practical cases when defining such a container is not straightforward or even possible without generating overlaps with the rest of the geometry. There are few ways out of this:. Defining the container for the structure as “overlapping” (see also "" Overlapping Volumes ""); Representing the container as a composite shape - the Boolean union of all components (see also "" Composite Shapes ""); Using an assembly volume - this will be described in the following. The first two approaches have the disadvantage of penalizing the navigation performance with a factor increasing more than linear of the number of components in the structure. The best solution is the third one because it uses all volume-related navigation optimizations. The class TGeoVolumeAssembly represents an assembly volume. Its shape is represented by TGeoShapeAssembly class that is the union of all components. It uses volume voxelization to perform navigation tasks.; An assembly volume creates a hierarchical level and it geometrically insulates the structure from the rest (as a normal volume). Physically, a point that is INSIDE a TGeoShapeAssembly is always inside one of the components, so a TGeoVolumeAssembly does not need to have a medium. Due to the self-containment of assemblies, they are very practical to use when a container is hard to define due to possible overlaps during positioning. For instance, it is very easy creating honeycomb structures. A very useful example for creating and using assemblies can be found at: http://root.cern.ch/root/html/examples/assembly.C.html.; Creation of an assembly is very easy: one has just to create a TGeoVolumeAssembly object and position the components inside as for any volume:; TGeoVolume *vol = new TGeoVolumeAssembly(name);; vol->AddNode(vdaughter1, cpy1, matrix1);; vol->AddNode(vdaughter2, cpy2, matrix2);; Note that components cannot be declared as “overlapping” and that a ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:959428,perform,perform,959428,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['perform'],['perform']
Performance,"n the testing data and adds the output to the Results in the corresponi...Definition Factory.cxx:1271; TMVA::Factory::TrainAllMethodsForClassificationvoid TrainAllMethodsForClassification(void)Definition Factory.h:115; TMVA::Factory::fVerboseBool_t fVerbose! verbose modeDefinition Factory.h:213; TMVA::Factory::EvaluateAllMethodsvoid EvaluateAllMethods(void)Iterates over all MVAs that have been booked, and calls their evaluation methods.Definition Factory.cxx:1376; TMVA::Factory::EvaluateImportanceRandomTH1F * EvaluateImportanceRandom(DataLoader *loader, UInt_t nseeds, Types::EMVA theMethod, TString methodTitle, const char *theOption="""")Definition Factory.cxx:2473; TMVA::Factory::GetImportanceTH1F * GetImportance(const int nbits, std::vector< Double_t > importances, std::vector< TString > varNames)Definition Factory.cxx:2591; TMVA::Factory::fROCBool_t fROC! enable to calculate ROC valuesDefinition Factory.h:216; TMVA::Factory::EvaluateAllVariablesvoid EvaluateAllVariables(DataLoader *loader, TString options="""")Iterates over all MVA input variables and evaluates them.Definition Factory.cxx:1360; TMVA::Factory::RootBaseDirTDirectory * RootBaseDir()Definition Factory.h:149; TMVA::Factory::fVerboseLevelTString fVerboseLevel! verbosity level, controls granularity of loggingDefinition Factory.h:214; TMVA::Factory::GetROCCurveAsMultiGraphTMultiGraph * GetROCCurveAsMultiGraph(DataLoader *loader, UInt_t iClass, Types::ETreeType type=Types::kTesting)Generate a collection of graphs, for all methods for a given class.Definition Factory.cxx:988; TMVA::Factory::EvaluateImportanceTH1F * EvaluateImportance(DataLoader *loader, VIType vitype, Types::EMVA theMethod, TString methodTitle, const char *theOption="""")Evaluate Variable Importance.Definition Factory.cxx:2217; TMVA::Factory::OptimizeAllMethodsForRegressionvoid OptimizeAllMethodsForRegression(TString fomType=""ROCIntegral"", TString fitType=""FitGA"")Definition Factory.h:111; TMVA::Factory::GetROCIntegralDouble_t GetROCIntegral(Data",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva_2tmva_2inc_2TMVA_2Factory_8h_source.html:14518,load,loader,14518,doc/master/tmva_2tmva_2inc_2TMVA_2Factory_8h_source.html,https://root.cern,https://root.cern/doc/master/tmva_2tmva_2inc_2TMVA_2Factory_8h_source.html,1,['load'],['loader']
Performance,"n value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; Bool_t_nlo; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_tRooResolutionModel::_ownBasisFlag indicating ownership of _basis ; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInter",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooGExpModel.html:42239,cache,cache,42239,root/html530/RooGExpModel.html,https://root.cern,https://root.cern/root/html530/RooGExpModel.html,1,['cache'],['cache']
Performance,n which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManager_cacheMgrThe cache manager; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; TIterator*_compCIter! do not persist; RooSetProxy_compCSet; TIterator*_compRIter! do not persist; RooSetProxy_compRSet; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Bool_tRooAbsReal::_selectComp! Component selection flag for ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooProduct.html:30667,cache,cache,30667,root/html526/RooProduct.html,https://root.cern,https://root.cern/root/html526/RooProduct.html,2,['cache'],['cache']
Performance,n which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManager_cacheMgrThe cache manager; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; TIterator*_compCIter! do not persist; RooSetProxy_compCSet; TIterator*_compRIter! do not persist; RooSetProxy_compRSet; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed by,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooProduct.html:31357,cache,cache,31357,root/html530/RooProduct.html,https://root.cern,https://root.cern/root/html530/RooProduct.html,1,['cache'],['cache']
Performance,"n width of bin); -2D : bc,e,xc,xw,yc,yw; -3D : bc,e,xc,xw,yc,yw,zc,zw. void FitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e,xc (bin content, error, x of center of bin); -2D : bc,e,xc,yc; -3D : bc,e,xc,yc,zc. void FitLikelihoodI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e,xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e,xc,xw,yc,yw; -3D : bc,e,xc,xw,yc,yw,zc,zw. TFumili(Int_t maxpar = 25); TF1 *fTFNF1; //Pointer to theoretical function; void (*fFCN) (Int_t &, Double_t *, Double_t &f, Double_t *, Int_t);; //wrapper function to calculate functional value, gradients and Z-matrix; Double_t (*fTFN)(Double_t *, Double_t *, Double_t*); // Wrapper function for TFN. Double_t* GetPL0() const; { return fPL0;}. Double_t* GetZ() const; { return fZ;}. void SetParNumber(Int_t ParNum); { fNpar = ParNum;}. » Last changed: root/fumili:$Id: TFumili.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFumili.html:24384,cache,cache,24384,root/html528/TFumili.html,https://root.cern,https://root.cern/root/html528/TFumili.html,1,['cache'],['cache']
Performance,"n width of bin); -2D : bc,e,xc,xw,yc,yw; -3D : bc,e,xc,xw,yc,yw,zc,zw. void FitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e,xc (bin content, error, x of center of bin); -2D : bc,e,xc,yc; -3D : bc,e,xc,yc,zc. void FitLikelihoodI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e,xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e,xc,xw,yc,yw; -3D : bc,e,xc,xw,yc,yw,zc,zw. TFumili(Int_t maxpar = 25); TF1 *fTFNF1; //Pointer to theoretical function; void (*fFCN) (Int_t &, Double_t *, Double_t &f, Double_t *, Int_t);; //wrapper function to calculate functional value, gradients and Z-matrix; Double_t (*fTFN)(Double_t *, Double_t *, Double_t*); // Wrapper function for TFN. Double_t* GetPL0() const; { return fPL0;}. Double_t* GetZ() const; { return fZ;}. void SetParNumber(Int_t ParNum); { fNpar = ParNum;}. » Last changed: root/fumili:$Id: TFumili.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-07-04 15:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TFumili.html:24453,cache,cache,24453,root/html530/TFumili.html,https://root.cern,https://root.cern/root/html530/TFumili.html,1,['cache'],['cache']
Performance,"n't want to inject the; 2023 // declarations into the interpreter, except for those we really need for; 2024 // I/O; see rootcling.cxx after the call to TCling__GetInterpreter().; 2025 if (fromRootCling) return;; 2026 ; 2027 // When we cannot provide a module for the library we should enable header; 2028 // parsing. This 'mixed' mode ensures gradual migration to modules.; 2029 llvm::SaveAndRestore<bool> SaveHeaderParsing(fHeaderParsingOnDemand);; 2030 fHeaderParsingOnDemand = !hasCxxModule;; 2031 ; 2032 // Treat Aclic Libs in a special way. Do not delay the parsing.; 2033 bool hasHeaderParsingOnDemand = fHeaderParsingOnDemand;; 2034 bool isACLiC = strstr(modulename, ""_ACLiC_dict"") != nullptr;; 2035 if (hasHeaderParsingOnDemand && isACLiC) {; 2036 if (gDebug>1); 2037 Info(""TCling::RegisterModule"",; 2038 ""Header parsing on demand is active but this is an Aclic library. Disabling it for this library."");; 2039 hasHeaderParsingOnDemand = false;; 2040 }; 2041 ; 2042 ; 2043 // Make sure we relookup symbols that were search for before we loaded; 2044 // their autoparse information. We could be more subtil and remove only; 2045 // the failed one or only the one in this module, but for now this is; 2046 // better than nothing.; 2047 fLookedUpClasses.clear();; 2048 ; 2049 // Make sure we do not set off AutoLoading or autoparsing during the; 2050 // module registration!; 2051 SuspendAutoLoadingRAII autoLoadOff(this);; 2052 ; 2053 for (const char** inclPath = includePaths; *inclPath; ++inclPath) {; 2054 TCling::AddIncludePath(*inclPath);; 2055 }; 2056 cling::Transaction* T = nullptr;; 2057 // Put the template decls and the number of arguments to skip in the TNormalizedCtxt; 2058 for (auto& fwdDeclArgToSkipPair : fwdDeclsArgToSkip){; 2059 const std::string& fwdDecl = fwdDeclArgToSkipPair.first;; 2060 const int nArgsToSkip = fwdDeclArgToSkipPair.second;; 2061 auto compRes = fInterpreter->declare(fwdDecl.c_str(), &T);; 2062 assert(cling::Interpreter::kSuccess == compRes &&; 2063 ""A",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:77890,load,loaded,77890,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['load'],['loaded']
Performance,"n(), you may alter the outcome of the fit. Only in cases where such a modification of fit behaviour is intentional,; this function should be used. RooArgSet* addColumns(const RooArgList& varList); Utility function to add multiple columns in one call; See addColumn() for details. RooAbsDataStore* merge(const RooArgSet& allvars, list<RooAbsDataStore*> dstoreList); Merge columns of supplied data set(s) with this data set. All; data sets must have equal number of entries. In case of; duplicate columns the column of the last dataset in the list; prevails. void append(RooAbsDataStore& other). Double_t sumEntries() const. Int_t numEntries() const. void reset(). void cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0); Cache given RooAbsArgs with this tree: The tree is; given direct write access of the args internal cache; the args values is pre-calculated for all data points; in this data collection. Upon a get() call, the; internal cache of 'newVar' will be loaded with the; precalculated value and it's dirty flag will be cleared. void setArgStatus(const RooArgSet& set, Bool_t active); Activate or deactivate the branch status of the TTree branch associated; with the given set of dataset observables. void resetCache(); Remove tree with values of cached observables; and clear list of cached observables. void attachBuffers(const RooArgSet& extObs). void resetBuffers(). void restoreAlternateBuffers(). void checkInit() const. Stat_t GetEntries() const; Interface function to TTree::GetEntries. void Reset(Option_t* option = 0); Interface function to TTree::Reset. Int_t Fill(); Interface function to TTree::Fill. Int_t GetEntry(Int_t entry = 0, Int_t getall = 0); Interface function to TTree::GetEntry. void Draw(Option_t* option = """"). void Streamer(TBuffer& b); Stream an object of class RooTreeDataStore. RooAbsDataStore* clone(const char* newname = 0) const; { return new RooTreeDataStore(*this,newname) ; }. RooAbsDataStore* clone(const RooArgSet& vars, co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooTreeDataStore.html:17225,cache,cache,17225,root/html532/RooTreeDataStore.html,https://root.cern,https://root.cern/root/html532/RooTreeDataStore.html,4,"['cache', 'load']","['cache', 'loaded']"
Performance,"n(). static constexpr Version_t RooAbsHiddenReal::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 67 of file RooAbsHiddenReal.h. ◆ DeclFileName(). static const char * RooAbsHiddenReal::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 67 of file RooAbsHiddenReal.h. ◆ dummyBlindState(). RooAbsCategory & RooAbsHiddenReal::dummyBlindState ; (; ); const. protected . Return reference to internal dummy RooCategory implementation blinding state switch. ; Definition at line 120 of file RooAbsHiddenReal.cxx. ◆ getHiddenVal(). double RooAbsHiddenReal::getHiddenVal ; (; const RooArgSet * ; nset = nullptr); const. inline . Definition at line 47 of file RooAbsHiddenReal.h. ◆ getValV(). double RooAbsHiddenReal::getValV ; (; const RooArgSet * ; nset = nullptr); const. inlineoverrideprotectedvirtual . Return value of object. ; If the cache is clean, return the cached value, otherwise recalculate on the fly and refill the cache ; Reimplemented from RooAbsReal.; Definition at line 57 of file RooAbsHiddenReal.h. ◆ IsA(). TClass * RooAbsHiddenReal::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Reimplemented in RooUnblindCPAsymVar, RooUnblindOffset, RooUnblindPrecision, and RooUnblindUniform.; Definition at line 67 of file RooAbsHiddenReal.h. ◆ isHidden(). bool RooAbsHiddenReal::isHidden ; (; ); const. inline . Definition at line 42 of file RooAbsHiddenReal.h. ◆ printValue(). void RooAbsHiddenReal::printValue ; (; std::ostream & ; stream); const. overridevirtual . Special version of printValue that doesn't reveal the objects value. ; Reimplemented from RooPrintable.; Definition at line 78 of file RooAbsHiddenReal.cxx. ◆ readFromStream(). bool RooAbsHiddenReal::readFromStream ; (; std::istream & ; is, . bool ; compact, . bool ; verbose = false . ). overridevirtual . Special version of readFromStream that disallo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsHiddenReal.html:63048,cache,cache,63048,doc/master/classRooAbsHiddenReal.html,https://root.cern,https://root.cern/doc/master/classRooAbsHiddenReal.html,3,['cache'],"['cache', 'cached']"
Performance,"n(); Management of selection state and ownership of selected cell list; is done in TEveCaloData. This is a reason selection is forwared to it. TEveElement* ForwardEdit(); Management of selection state and ownership of selected cell list; is done in TEveCaloData. We still want GUI editor to disply; concrete calo-viz object. void SetDataSliceThreshold(Int_t slice, Float_t val); Set threshold for given slice. Color_t GetDataSliceColor(Int_t slice) const; Get slice color from data. void SetDataSliceColor(Int_t slice, Color_t col); Set slice color in data. void SetEta(Float_t l, Float_t u); Set eta range. void SetPlotEt(Bool_t x); Set E/Et plot. Float_t GetMaxVal() const. void SetPhiWithRng(Float_t x, Float_t r); Set phi range. Float_t GetTransitionTheta() const; Get transition angle between barrel and end-cap cells. Float_t GetTransitionEta() const; Get transition eta between barrel and end-cap cells. void SetData(TEveCaloData* d); Set calorimeter event data. void DataChanged(); Update setting and cache on data changed.; Called from TEvecaloData::BroadcastDataChange(). Bool_t AssertCellIdCache() const; Assert cell id cache is ok.; Returns true if the cache has been updated. Bool_t CellInEtaPhiRng(TEveCaloData::CellData_t& ) const; Returns true if given cell is in the ceta phi range. void AssignCaloVizParameters(TEveCaloViz* cv); Assign paramteres from given model. void SetPalette(TEveRGBAPalette* p); Set TEveRGBAPalette object pointer. Float_t GetValToHeight() const; Get transformation factor from E/Et to height. TEveRGBAPalette* AssertPalette(); Make sure the TEveRGBAPalette pointer is not null.; If it is not set, a new one is instantiated and the range is set; to current min/max signal values. void Paint(Option_t* option = """"); Paint this object. Only direct rendering is supported. TClass* ProjectedClass(const TEveProjection* p) const; Virtual from TEveProjectable, returns TEveCalo2D class. void SetupColorHeight(Float_t value, Int_t slice, Float_t& height) const; Set ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEveCaloViz.html:23209,cache,cache,23209,root/html528/TEveCaloViz.html,https://root.cern,https://root.cern/root/html528/TEveCaloViz.html,4,['cache'],['cache']
Performance,"n(); Static function returning the total number of bytes written to all files.; Does not take into account what might still be in the write caches. Int_t GetFileReadCalls(); Static function returning the total number of read calls from all files. Int_t GetReadaheadSize(); Static function returning the readahead buffer size. void SetReadaheadSize(Int_t bufsize = 256000); { fgReadaheadSize = bytes; }. void SetFileBytesRead(Long64_t bytes = 0); { fgBytesRead = bytes; }. void SetFileBytesWritten(Long64_t bytes = 0); { fgBytesWrite = bytes; }. void SetFileReadCalls(Int_t readcalls = 0); { fgReadCalls = readcalls; }. Long64_t GetFileCounter(); { return fgFileCounter; }. void IncrementFileCounter(); { fgFileCounter++; }. Bool_t SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); Sets the directory where to locally stage/cache remote files.; If the directory is not writable by us return kFALSE. const char * GetCacheFileDir(); Get the directory where to locally stage/cache remote files. Bool_t ShrinkCacheFileDir(Long64_t shrinkSize, Long_t cleanupInteval = 0); We try to shrink the cache to the desired size.; With the clenupinterval you can specify the minimum amount of time after; the previous cleanup before the cleanup operation is repeated in; the cache directory. UInt_t SetOpenTimeout(UInt_t timeout); Sets open timeout time (in ms). Returns previous timeout value. UInt_t GetOpenTimeout(); Returns open timeout (in ms). Bool_t SetOnlyStaged(Bool_t onlystaged); Sets only staged flag. Returns previous value of flag.; When true we check before opening the file if it is staged, if not,; the open fails. Bool_t GetOnlyStaged(); Returns staged only flag. Bool_t Matches(const char* name); Return kTRUE if 'url' matches the coordinates of this file.; The check is implementation dependent and may need to be overload; by each TFile implememtation relying on this check.; The default implementation checks the file name only. const TUr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFile.html:49875,cache,cache,49875,root/html528/TFile.html,https://root.cern,https://root.cern/root/html528/TFile.html,10,['cache'],['cache']
Performance,"n);; 211 SetMaximum(xmax);; 212 return;; 213 }; 214 Int_t bin1 = theAxis->FindFixBin(xmin);; 215 Int_t bin2 = theAxis->FindFixBin(xmax);; 216 theAxis->SetRange(bin1, bin2);; 217}; 218 ; 219 ; 220////////////////////////////////////////////////////////////////////////////////; 221/// Set axis labels color.; 222///; 223/// axis specifies which axis (""x"",""y"",""z""), default = ""x""; 224/// if axis=""xyz"" set all 3 axes; 225 ; 226void TH1::SetLabelColor(Color_t color, Option_t *axis); 227{; 228 TString opt = axis;; 229 opt.ToLower();; 230 ; 231 if (opt.Contains(""x"")) fXaxis.SetLabelColor(color);; 232 if (opt.Contains(""y"")) fYaxis.SetLabelColor(color);; 233 if (opt.Contains(""z"")) fZaxis.SetLabelColor(color);; 234}; 235 ; 236 ; 237////////////////////////////////////////////////////////////////////////////////; 238/// Set font number used to draw axis labels.; 239///; 240/// font : Text font code = 10*fontnumber + precision; 241/// Font numbers must be between 1 and 14; 242/// precision = 1 fast hardware fonts (steps in the size); 243/// precision = 2 scalable and rotatable hardware fonts; 244///; 245/// The default font number is 62.; 246/// axis specifies which axis (""x"",""y"",""z""), default = ""x""; 247/// if axis=""xyz"" set all 3 axes; 248 ; 249void TH1::SetLabelFont(Style_t font, Option_t *axis); 250{; 251 TString opt = axis;; 252 opt.ToLower();; 253 ; 254 if (opt.Contains(""x"")) fXaxis.SetLabelFont(font);; 255 if (opt.Contains(""y"")) fYaxis.SetLabelFont(font);; 256 if (opt.Contains(""z"")) fZaxis.SetLabelFont(font);; 257}; 258 ; 259 ; 260////////////////////////////////////////////////////////////////////////////////; 261/// Set offset between axis and axis' labels.; 262///; 263/// The offset is expressed as a percent of the pad height.; 264/// axis specifies which axis (""x"",""y"",""z""), default = ""x""; 265/// if axis=""xyz"" set all 3 axes; 266 ; 267void TH1::SetLabelOffset(Float_t offset, Option_t *axis); 268{; 269 TString opt = axis;; 270 opt.ToLower();; 271 ; 272 if (opt.Contains(""x""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Haxis_8cxx_source.html:7585,scalab,scalable,7585,doc/master/Haxis_8cxx_source.html,https://root.cern,https://root.cern/doc/master/Haxis_8cxx_source.html,1,['scalab'],['scalable']
Performance,"n, . Option_t * ; option = """", . Long64_t ; nentries = kMaxEntries, . Long64_t ; firstentry = 0 . ). virtual . Draw expression varexp for specified entries. ; Returns-1 in case of error or number of selected events in case of success.; This function accepts TCut objects as arguments. Useful to use the string operator +; Example:; ntuple.Draw(""x"",cut1+cut2+cut3);. Reimplemented in TChain, and TProofChain.; Definition at line 3855 of file TTree.cxx. ◆ Draw() [3/3]. void TTree::Draw ; (; Option_t * ; option). inlineoverridevirtual . Default Draw method for all objects. ; Reimplemented from TObject.; Definition at line 431 of file TTree.h. ◆ DropBaskets(). void TTree::DropBaskets ; (; ). virtual . Remove some baskets from memory. ; Definition at line 4518 of file TTree.cxx. ◆ DropBranchFromCache() [1/2]. Int_t TTree::DropBranchFromCache ; (; const char * ; bname, . bool ; subbranches = false . ). virtual . Remove the branch with name 'bname' from the Tree cache. ; If bname=""*"" all branches are removed from the cache. if subbranches is true all the branches of the subbranches are also removed from the cache.; Returns:; 0 branch dropped or not in cache; -1 on error . Definition at line 1142 of file TTree.cxx. ◆ DropBranchFromCache() [2/2]. Int_t TTree::DropBranchFromCache ; (; TBranch * ; b, . bool ; subbranches = false . ). virtual . Remove the branch b from the Tree cache. ; if subbranches is true all the branches of the subbranches are also removed from the cache.; Returns:; 0 branch dropped or not in cache; -1 on error . Definition at line 1181 of file TTree.cxx. ◆ DropBuffers(). void TTree::DropBuffers ; (; Int_t ; nbytes). virtual . Drop branch buffers to accommodate nbytes below MaxVirtualsize. ; Definition at line 4531 of file TTree.cxx. ◆ EnableCache(). bool TTree::EnableCache ; (; ). Enable the TTreeCache unless explicitly disabled for this TTree by a prior call to SetCacheSize(0). ; If the environment variable ROOT_TTREECACHE_SIZE or the rootrc config TTreeCach",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTree.html:137335,cache,cache,137335,doc/v632/classTTree.html,https://root.cern,https://root.cern/doc/v632/classTTree.html,2,['cache'],['cache']
Performance,"n, objects that are referenced by such a pointer have an additional field in the base TObject. See Format of the DATA for a TObject object. A description of how these pointers work is given under the Pointers to persistent objects heading below. ""application"" layer record types; These are either user defined record types, or record types supplied by ROOT that are not needed by ROOTIO. The format of such an object that uses the default streamer is shown in Format of a class object in DATA. Data compression; The user can set the data compression level for new or modified data records when creating or opening a file. When an existing file is opened for update, the compression level selected need not match that used previously. The compression level of existing records is not modified unless the record itself is modified.; There are ten compression levels, 0-9, ranging from 0 (no compression) to 9 (maximum compression), with level 1 being the default. The level chosen is a tradeoff between disk space and compression performance. The decompression speed is independent of level. Currently, in release 3.2.6, level 2 is not used. If level 2 is selected, level 1 is used with no notification to the user.; The chosen compression level is not applied to the entire file. The following portions of the file are not compressed, regardless of the compression level selected:. the file header; the KeysList data record; the FreeSegments data record; any data record (outside of a TTree) where the uncompressed size of the data portion is 256 bytes or less.; the key portion of any data record. Furthermore, the data portion of the StreamerInfo data record is always compressed at level 1 (if over 256 bytes uncompressed), regardless of the compression level selected (even if no compression is selected).; The compression algorithm used is an in memory ZIP compression written for the DELPHI collaboration at CERN. Its author is E. Chernyaev (IHEP/Protvino). The source code is internal to ROOTIO.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rootio.html:5580,perform,performance,5580,doc/master/rootio.html,https://root.cern,https://root.cern/doc/master/rootio.html,1,['perform'],['performance']
Performance,"n-time shapes)building the cache manager,; voxelizing all volumes, counting the total number of physical nodes and; registring the manager class to the browser. void ClearOverlaps(); Clear the list of overlaps. void ClearShape(const TGeoShape* shape); Remove a shape from the list of shapes. void CleanGarbage(); Clean temporary volumes and shapes from garbage collection. void CdNode(Int_t nodeid); Change current path to point to the node having this id.; Node id has to be in range : 0 to fNNodes-1 (no check for performance reasons). Int_t GetCurrentNodeId() const; Get the unique ID of the current node. void CdTop(); Make top level node the current node. Updates the cache accordingly.; Determine the overlapping state of current node. void CdUp(); Go one level up in geometry. Updates cache accordingly.; Determine the overlapping state of current node. void CdDown(Int_t index); Make a daughter of current node current. Can be called only with a valid; daughter index (no check). Updates cache accordingly. void CdNext(); Do a cd to the node found next by FindNextBoundary. Bool_t cd(const char* path = """"); Browse the tree of nodes starting from fTopNode according to pathname.; Changes the path accordingly. Bool_t CheckPath(const char* path) const; Check if a geometry path is valid without changing the state of the current navigator. void ConvertReflections(); Convert all reflections in geometry to normal rotations + reflected shapes. Int_t CountNodes(const TGeoVolume* vol = 0, Int_t nlevels = 10000, Int_t option = 0); Count the total number of nodes starting from a volume, nlevels down. void DefaultAngles(); Set default angles for a given view. void DrawCurrentPoint(Int_t color = 2); Draw current point in the same view. void AnimateTracks(Double_t tmin = 0, Double_t tmax = 5E-8, Int_t nframes = 200, Option_t* option = ""/*""); Draw animation of tracks. void DrawTracks(Option_t* option = """"); Draw tracks over the geometry, according to option. By default, only; primaries are dr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoManager.html:44637,cache,cache,44637,root/html528/TGeoManager.html,https://root.cern,https://root.cern/root/html528/TGeoManager.html,4,['cache'],['cache']
Performance,"n-time shapes)building the cache manager,; voxelizing all volumes, counting the total number of physical nodes and; registring the manager class to the browser. void ClearOverlaps(); Clear the list of overlaps. void ClearShape(const TGeoShape* shape); Remove a shape from the list of shapes. void CleanGarbage(); Clean temporary volumes and shapes from garbage collection. void CdNode(Int_t nodeid); Change current path to point to the node having this id.; Node id has to be in range : 0 to fNNodes-1 (no check for performance reasons). Int_t GetCurrentNodeId() const; Get the unique ID of the current node. void CdTop(); Make top level node the current node. Updates the cache accordingly.; Determine the overlapping state of current node. void CdUp(); Go one level up in geometry. Updates cache accordingly.; Determine the overlapping state of current node. void CdDown(Int_t index); Make a daughter of current node current. Can be called only with a valid; daughter index (no check). Updates cache accordingly. void CdNext(); Do a cd to the node found next by FindNextBoundary. Bool_t cd(const char* path = """"); Browse the tree of nodes starting from fTopNode according to pathname.; Changes the path accordingly. Bool_t CheckPath(const char* path) const; Check if a geometry path is valid without changing the state of the current navigator. void ConvertReflections(); Convert all reflections in geometry to normal rotations + reflected shapes. void CountLevels(); Count maximum number of nodes per volume, maximum depth and maximum; number of xtru vertices. Int_t CountNodes(const TGeoVolume* vol = 0, Int_t nlevels = 10000, Int_t option = 0); Count the total number of nodes starting from a volume, nlevels down. void DefaultAngles(); Set default angles for a given view. void DrawCurrentPoint(Int_t color = 2); Draw current point in the same view. void AnimateTracks(Double_t tmin = 0, Double_t tmax = 4.9999999999999998E-8, Int_t nframes = 200, Option_t* option = ""/*""); Draw animation of tra",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoManager.html:47460,cache,cache,47460,root/html602/TGeoManager.html,https://root.cern,https://root.cern/root/html602/TGeoManager.html,4,['cache'],['cache']
Performance,"n-time shapes)building the cache manager,; voxelizing all volumes, counting the total number of physical nodes and; registring the manager class to the browser. void ClearOverlaps(); Clear the list of overlaps. void ClearShape(const TGeoShape* shape); Remove a shape from the list of shapes. void CleanGarbage(); Clean temporary volumes and shapes from garbage collection. void CdNode(Int_t nodeid); Change current path to point to the node having this id.; Node id has to be in range : 0 to fNNodes-1 (no check for performance reasons). Int_t GetCurrentNodeId() const; Get the unique ID of the current node. void CdTop(); Make top level node the current node. Updates the cache accordingly.; Determine the overlapping state of current node. void CdUp(); Go one level up in geometry. Updates cache accordingly.; Determine the overlapping state of current node. void CdDown(Int_t index); Make a daughter of current node current. Can be called only with a valid; daughter index (no check). Updates cache accordingly. void CdNext(); Do a cd to the node found next by FindNextBoundary. Bool_t cd(const char* path = """"); Browse the tree of nodes starting from fTopNode according to pathname.; Changes the path accordingly. Bool_t CheckPath(const char* path) const; Check if a geometry path is valid without changing the state of the current navigator. void ConvertReflections(); Convert all reflections in geometry to normal rotations + reflected shapes. void CountLevels(); Count maximum number of nodes per volume, maximum depth and maximum; number of xtru vertices. Int_t CountNodes(const TGeoVolume* vol = 0, Int_t nlevels = 10000, Int_t option = 0); Count the total number of nodes starting from a volume, nlevels down. void DefaultAngles(); Set default angles for a given view. void DrawCurrentPoint(Int_t color = 2); Draw current point in the same view. void AnimateTracks(Double_t tmin = 0, Double_t tmax = 5E-8, Int_t nframes = 200, Option_t* option = ""/*""); Draw animation of tracks. void DrawTra",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoManager.html:46983,cache,cache,46983,root/html534/TGeoManager.html,https://root.cern,https://root.cern/root/html534/TGeoManager.html,2,['cache'],['cache']
Performance,"n. ; . Function Members (Methods); public:. RooObjCacheManager(const RooObjCacheManager& other, RooAbsArg* owner = 0); RooObjCacheManager(RooAbsArg* owner = 0, Int_t maxSize = 10, Bool_t clearCacheOnServerRedirect = kTRUE); virtual~RooObjCacheManager(); Int_tRooCacheManager<RooAbsCacheElement>::cacheSize() const; static TClass*Class(); virtual voidfindConstantNodes(const RooArgSet&, RooArgSet&, RooLinkedList&); RooAbsCacheElement*RooCacheManager<RooAbsCacheElement>::getObj(const RooArgSet* nset, Int_t* sterileIndex = 0, const TNamed* isetRangeName = 0); RooAbsCacheElement*RooCacheManager<RooAbsCacheElement>::getObj(const RooArgSet* nset, const RooArgSet* iset, Int_t* sterileIdx = 0, const TNamed* isetRangeName = 0); RooAbsCacheElement*RooCacheManager<RooAbsCacheElement>::getObjByIndex(Int_t index) const; virtual voidinsertObjectHook(RooAbsCacheElement&); virtual TClass*IsA() const; Int_tRooCacheManager<RooAbsCacheElement>::lastIndex() const; const RooNameSet*RooCacheManager<RooAbsCacheElement>::nameSet1ByIndex(Int_t index) const; const RooNameSet*RooCacheManager<RooAbsCacheElement>::nameSet2ByIndex(Int_t index) const; RooObjCacheManager&operator=(const RooObjCacheManager&); virtual voidoperModeHook(); virtual voidoptimizeCacheMode(const RooArgSet&, RooArgSet&, RooLinkedList&); virtual voidprintCompactTreeHook(ostream&, const char*); virtual Bool_tredirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooCacheManager<RooAbsCacheElement>::reset(); Int_tRooCacheManager<RooAbsCacheElement>::setObj(const RooArgSet* nset, RooAbsCacheElement* obj, const TNamed* isetRangeName = 0); Int_tRooCacheManager<RooAbsCacheElement>::setObj(const RooArgSet* nset, const RooArgSet* iset, RooAbsCacheElement* obj, const TNamed* isetRangeName = 0); virtual voidShowMembers(TMemberInspector& insp, char* parent); voidRooCacheManager<RooAbsCacheElement>::sterilize(); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; protected:. Bool_t_clearOnRe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooObjCacheManager.html:1167,cache,cacheSize,1167,root/html526/RooObjCacheManager.html,https://root.cern,https://root.cern/root/html526/RooObjCacheManager.html,1,['cache'],['cacheSize']
Performance,"n. ;  ; std::atomic< size_t > fContextPeg {0};  thread local gDirectory pointing to this object. ;  ; std::vector< SharedGDirectory_t > fGDirectories;  ; TList * fList {nullptr};  ; TObject * fMother {nullptr};  ; TString fPathBuffer;  ; std::atomic_flag fSpinLock;  Counter delaying the TDirectory destructor from finishing. ;  ; TUUID fUUID;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Static Protected Attributes; static Long64_t fgMaxFullCacheSize = 500000000;  ; static TUrl fgProxy;  size of the cached content ;  ;  Static Protected Attributes inherited from TFile; static TList * fgAsyncOpenRequests = nullptr;  ; static std::atomic< Long64_t > fgBytesRead {0};  Number of bytes read by all TFile objects. ;  ; static std::atomic< Long64_t > fgBytesWrite {0};  Number of bytes written by all TFile objects. ;  ; static TString fgCacheFileDir;  Directory where to locally stage files. ;  ; static Bool_t fgCacheFileDisconnected = kTRUE;  Indicates, we trust in the files in the cache dir without stat on the cached file. ;  ; static Bool_t fgCacheFileForce = kFALSE;  Indicates, to force all READ to CACHEREAD. ;  ; static std::atomic< Long64_t > fgFileCounter {0};  Counter for all opened files. ;  ; static Bool_t fgOnlyStaged = kFALSE;  Before the file is opened, it is checked, that the file is staged, if not, the open fails. ;  ; static UInt_t fgOpenTimeout = TFile::kEternalTimeout;  Timeout for open operations in ms - 0 corresponds to blocking i/o. ;  ; static Int_t fgReadaheadSize = 256000;  Readahead buffer size. ;  ; static std::atomic< Int_t > fgReadCalls {0};  Number of bytes read from all TFile objects. ;  ; static Bool_t fgReadInfo = kTRUE;  if true (default) ReadStreamerInfo is called when opening a file ;  ; static ROOT::Internal::RConcurrentHashColl fgTsSIHashes;  !TS Set of hashes built from read streamer infos ;  ;  Static Protected Attributes inherited from TDirectory; static Bool_t fgAddDirectory = kTRUE;  MSVC doesn't ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTWebFile.html:39847,cache,cache,39847,doc/master/classTWebFile.html,https://root.cern,https://root.cern/doc/master/classTWebFile.html,2,['cache'],"['cache', 'cached']"
Performance,"n. Int_t RedirectOutput(const char* name, const char* mode = ""a"", RedirectHandle_t* h = 0); Redirect standard output (stdout, stderr) to the specified file.; If the file argument is 0 the output is set again to stderr, stdout.; The second argument specifies whether the output should be added to the; file (""a"", default) or the file be truncated before (""w"").; This function saves internally the current state into a static structure.; The call can be made reentrant by specifying the opaque structure pointed; by 'h', which is filled with the relevant information. The handle 'h'; obtained on the first call must then be used in any subsequent call,; included ShowOutput, to display the redirected output.; Returns 0 on success, -1 in case of error. Func_t DynFindSymbol(const char* module, const char* entry); dynamic linking of module. int Load(const char* module, const char* entry = """", Bool_t system = kFALSE); Load a shared library. Returns 0 on successful loading, 1 in; case lib was already loaded and -1 in case lib does not exist; or in case of error. void Unload(const char* module); Unload a shared library. void ListSymbols(const char* module, const char* re = """"); List symbols in a shared library. void ListLibraries(const char* regexp = """"); List all loaded shared libraries. const char * GetLinkedLibraries(); Get list of shared libraries loaded at the start of the executable.; Returns 0 in case list cannot be obtained or in case of error. TTime Now(); Get current time in milliseconds since 0:00 Jan 1 1995. Bool_t DispatchTimers(Bool_t mode); Handle and dispatch timers. If mode = kTRUE dispatch synchronous; timers else a-synchronous timers. void AddTimer(TTimer* ti); Add timer to list of system timers. TTimer * RemoveTimer(TTimer* ti); Remove timer from list of system timers. void ResetTimer(TTimer* ti); Reset a-sync timer. TInetAddress GetHostByName(const char* server); Get Internet Protocol (IP) address of host. Returns an TInetAddress; object. To see if the hostname l",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TUnixSystem.html:31569,load,loading,31569,root/html528/TUnixSystem.html,https://root.cern,https://root.cern/root/html528/TUnixSystem.html,20,['load'],"['loaded', 'loading']"
Performance,"n. Set the class version for the 'class' represented by; this TClass object. See the public interface:; ROOT::ResetClassVersion; defined in TClassTable.cxx. Note on class version numbers:; If no class number has been specified, TClass::GetVersion will return -1; The Class Version 0 request the whole object to be transient; The Class Version 1, unless specified via ClassDef indicates that the; I/O should use the TClass checksum to distinguish the layout of the class. TVirtualStreamerInfo* DetermineCurrentStreamerInfo(); Determine and set pointer to current TVirtualStreamerInfo. void SetCurrentStreamerInfo(TVirtualStreamerInfo* info); Set pointer to current TVirtualStreamerInfo. Int_t Size() const; Return size of object of this class. TClass * Load(TBuffer& b); Load class description from I/O buffer and return class object. TClass * LoadClass(const char* requestedname, Bool_t silent); Helper function used by TClass::GetClass().; This function attempts to load the dictionary for 'classname'; either from the TClassTable or from the list of generator.; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members). The 'requestedname' is expected to be already normalized. TClass * LoadClassDefault(const char* requestedname, Bool_t silent); Helper function used by TClass::GetClass().; This function attempts to load the dictionary for 'classname' from; the TClassTable or the autoloader.; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members). The 'requestedname' is expected to be already normalized. TClass * LoadClassCustom(const char* requestedname, Bool_t silent); Helper function used by TClass::GetClass().; This function attempts to load the dictionary for 'classname'; from the list of generator.; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are use",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TClass.html:51855,load,load,51855,root/html602/TClass.html,https://root.cern,https://root.cern/root/html602/TClass.html,4,['load'],['load']
Performance,"n.; 3270 ; 3271 cl = GetIdMap()->Find(typeinfo.name());; 3272 ; 3273 if (cl) {; 3274 if (cl->IsLoaded()) return cl;; 3275 //we may pass here in case of a dummy class created by TVirtualStreamerInfo; 3276 load = kTRUE;; 3277 } else {; 3278 // Note we might need support for typedefs and simple types!; 3279 ; 3280 // TDataType *objType = GetType(name, load);; 3281 //if (objType) {; 3282 // const char *typdfName = objType->GetTypeName();; 3283 // if (typdfName && strcmp(typdfName, name)) {; 3284 // cl = GetClass(typdfName, load);; 3285 // return cl;; 3286 // }; 3287 // }; 3288 }; 3289 ; 3290 if (!load) return nullptr;; 3291 ; 3292 DictFuncPtr_t dict = TClassTable::GetDict(typeinfo);; 3293 if (dict) {; 3294 cl = (dict)();; 3295 if (cl) cl->PostLoadCheck();; 3296 return cl;; 3297 }; 3298 if (cl) return cl;; 3299 ; 3300 TIter next(gROOT->GetListOfClassGenerators());; 3301 TClassGenerator *gen;; 3302 while( (gen = (TClassGenerator*) next()) ) {; 3303 cl = gen->GetClass(typeinfo,load);; 3304 if (cl) {; 3305 cl->PostLoadCheck();; 3306 return cl;; 3307 }; 3308 }; 3309 ; 3310 // try AutoLoading the typeinfo; 3311 int autoload_old = gCling->SetClassAutoLoading(1);; 3312 if (!autoload_old) {; 3313 // Re-disable, we just meant to test; 3314 gCling->SetClassAutoLoading(0);; 3315 }; 3316 if (autoload_old && gInterpreter->AutoLoad(typeinfo,kTRUE)) {; 3317 // Disable autoload to avoid potential infinite recursion; 3318 TInterpreter::SuspendAutoLoadingRAII autoloadOff(gInterpreter);; 3319 cl = GetClass(typeinfo, load, hint_pair_offset, hint_pair_size);; 3320 if (cl) {; 3321 return cl;; 3322 }; 3323 }; 3324 ; 3325 if (hint_pair_offset) {; 3326 int err = 0;; 3327 char* demangled_name = TClassEdit::DemangleTypeIdName(typeinfo, err);; 3328 if (!err) {; 3329 cl = TClass::GetClass(demangled_name, load, kTRUE, hint_pair_offset, hint_pair_size);; 3330 free(demangled_name);; 3331 if (cl); 3332 return cl;; 3333 }; 3334 }; 3335 ; 3336 // last attempt. Look in the interpreter list of all (compiled+",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:125015,load,load,125015,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,7,['load'],['load']
Performance,"n.; 3337 ; 3338 cl = GetIdMap()->Find(typeinfo.name());; 3339 ; 3340 if (cl) {; 3341 if (cl->IsLoaded()) return cl;; 3342 //we may pass here in case of a dummy class created by TVirtualStreamerInfo; 3343 load = kTRUE;; 3344 } else {; 3345 // Note we might need support for typedefs and simple types!; 3346 ; 3347 // TDataType *objType = GetType(name, load);; 3348 //if (objType) {; 3349 // const char *typdfName = objType->GetTypeName();; 3350 // if (typdfName && strcmp(typdfName, name)) {; 3351 // cl = GetClass(typdfName, load);; 3352 // return cl;; 3353 // }; 3354 // }; 3355 }; 3356 ; 3357 if (!load) return nullptr;; 3358 ; 3359 DictFuncPtr_t dict = TClassTable::GetDict(typeinfo);; 3360 if (dict) {; 3361 cl = (dict)();; 3362 if (cl) cl->PostLoadCheck();; 3363 return cl;; 3364 }; 3365 if (cl) return cl;; 3366 ; 3367 TIter next(gROOT->GetListOfClassGenerators());; 3368 TClassGenerator *gen;; 3369 while( (gen = (TClassGenerator*) next()) ) {; 3370 cl = gen->GetClass(typeinfo,load);; 3371 if (cl) {; 3372 cl->PostLoadCheck();; 3373 return cl;; 3374 }; 3375 }; 3376 ; 3377 // try AutoLoading the typeinfo; 3378 int autoload_old = gCling->SetClassAutoLoading(1);; 3379 if (!autoload_old) {; 3380 // Re-disable, we just meant to test; 3381 gCling->SetClassAutoLoading(0);; 3382 }; 3383 if (autoload_old && gInterpreter->AutoLoad(typeinfo,kTRUE)) {; 3384 // Disable autoload to avoid potential infinite recursion; 3385 TInterpreter::SuspendAutoLoadingRAII autoloadOff(gInterpreter);; 3386 cl = GetClass(typeinfo, load, hint_pair_offset, hint_pair_size);; 3387 if (cl) {; 3388 return cl;; 3389 }; 3390 }; 3391 ; 3392 if (hint_pair_offset) {; 3393 int err = 0;; 3394 char* demangled_name = TClassEdit::DemangleTypeIdName(typeinfo, err);; 3395 if (!err) {; 3396 cl = TClass::GetClass(demangled_name, load, kTRUE, hint_pair_offset, hint_pair_size);; 3397 free(demangled_name);; 3398 if (cl); 3399 return cl;; 3400 }; 3401 }; 3402 ; 3403 // last attempt. Look in the interpreter list of all (compiled+",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:127766,load,load,127766,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,7,['load'],['load']
Performance,"n.ch/files/"" + inputFileName; ; ; if ROOT.gSystem.AccessPathName(inputFileName):; ROOT.Info(""TMVA_Higgs_Classification"", ""Download Higgs_data.root file""); TFile.SetCacheFileDir("".""); inputFile = TFile.Open(inputFileLink, ""CACHEREAD""); if inputFile is None:; raise FileNotFoundError(""Input file cannot be downloaded - exit""); else:; # file exists; inputFile = TFile.Open(inputFileName); ; ; # --- Register the training and test trees; signalTree = inputFile.Get(""sig_tree""); backgroundTree = inputFile.Get(""bkg_tree""); signalTree.Print(); ; ## Declare DataLoader(s); ; # The next step is to declare the DataLoader class that deals with input variables; # Define the input variables that shall be used for the MVA training; # note that you may also use variable expressions, which can be parsed by TTree::Draw( ""expression"" )]; loader = TMVA.DataLoader(""dataset""); ; loader.AddVariable(""m_jj""); loader.AddVariable(""m_jjj""); loader.AddVariable(""m_lv""); loader.AddVariable(""m_jlv""); loader.AddVariable(""m_bb""); loader.AddVariable(""m_wbb""); loader.AddVariable(""m_wwbb""); ; # We set now the input data trees in the TMVA DataLoader class; # global event weights per tree (see below for setting event-wise weights); signalWeight = 1.0; backgroundWeight = 1.0; # You can add an arbitrary number of signal or background trees; loader.AddSignalTree(signalTree, signalWeight); loader.AddBackgroundTree(backgroundTree, backgroundWeight); ; # Set individual event weights (the variables must exist in the original TTree); # for signal : factory->SetSignalWeightExpression (""weight1*weight2"");; # for background: factory->SetBackgroundWeightExpression(""weight1*weight2"");; # loader->SetBackgroundWeightExpression( ""weight"" );; ; ; # Apply additional cuts on the signal and background samples (can be different); mycuts = ROOT.TCut("""") # for example: TCut mycuts = ""abs(var1)<0.5 && abs(var2-0.5)<1"";; mycutb = ROOT.TCut("""") # for example: TCut mycutb = ""abs(var1)<0.5"";; ; # Tell the factory how to use the training",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__Higgs__Classification_8py.html:59482,load,loader,59482,doc/master/TMVA__Higgs__Classification_8py.html,https://root.cern,https://root.cern/doc/master/TMVA__Higgs__Classification_8py.html,1,['load'],['loader']
Performance,"n.cxx. Member Function Documentation. ◆ Class(). static TClass * TMVA::Experimental::Classification::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TMVA::Experimental::Classification::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TMVA::Experimental::Classification::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 202 of file Classification.h. ◆ CopyFrom(). void TMVA::Experimental::Classification::CopyFrom ; (; TDirectory * ; src, . TFile * ; file . ). protected . Definition at line 1093 of file Classification.cxx. ◆ DeclFileName(). static const char * TMVA::Experimental::Classification::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 202 of file Classification.h. ◆ Evaluate(). void TMVA::Experimental::Classification::Evaluate ; (; ). virtual . Method to perform Train/Test over all ml method booked. ; If the option Jobs > 1 can do it in parallel with MultiProc. ; Implements TMVA::Envelope.; Definition at line 248 of file Classification.cxx. ◆ GetMethod(). TMVA::MethodBase * TMVA::Experimental::Classification::GetMethod ; (; TString ; methodname, . TString ; methodtitle . ). Return a TMVA::MethodBase object. ; if method is not booked then return a null pointer. Parameters. methodnamename of the method. ; methodtitlemethod title. . ReturnsTMVA::MethodBase object ; Definition at line 386 of file Classification.cxx. ◆ GetMethodOptions(). TString TMVA::Experimental::Classification::GetMethodOptions ; (; TString ; methodname, . TString ; methodtitle . ). protected . return the options for the booked method. ; Parameters. methodnamename of the method. ; methodtitlemethod title. . Returnsstring the with options for the ml method. ; Definition at line 234 of file Classification.cxx. ◆ GetResults() [1/2]. std::vector< TMVA::Experimental::ClassificationResult > &",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1Experimental_1_1Classification.html:21747,perform,perform,21747,doc/master/classTMVA_1_1Experimental_1_1Classification.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1Experimental_1_1Classification.html,1,['perform'],['perform']
Performance,"n.cxx. ◆ evaluate(). double RooPoisson::evaluate ; (; ); const. overrideprotectedvirtual . Implementation in terms of the TMath::Poisson() function. ; Implements RooAbsReal.; Definition at line 56 of file RooPoisson.cxx. ◆ generateEvent(). void RooPoisson::generateEvent ; (; Int_t ; code). overridevirtual . Implement internal generator using TRandom::Poisson. ; Reimplemented from RooAbsPdf.; Definition at line 133 of file RooPoisson.cxx. ◆ getAnalyticalIntegral(). Int_t RooPoisson::getAnalyticalIntegral ; (; RooArgSet & ; allVars, . RooArgSet & ; analVars, . const char * ; rangeName = nullptr . ); const. overridevirtual . Interface function getAnalyticalIntergral advertises the analytical integrals that are supported. ; 'integSet' is the set of dependents for which integration is requested. The function should copy the subset of dependents it can analytically integrate to anaIntSet and return a unique identification code for this integration configuration. If no integration can be performed, zero should be returned. ; Reimplemented from RooAbsReal.; Definition at line 87 of file RooPoisson.cxx. ◆ getGenerator(). Int_t RooPoisson::getGenerator ; (; const RooArgSet & ; directVars, . RooArgSet & ; generateVars, . bool ; staticInitOK = true . ); const. overridevirtual . Advertise internal generator in x. ; Reimplemented from RooAbsPdf.; Definition at line 124 of file RooPoisson.cxx. ◆ getMean(). RooAbsReal const & RooPoisson::getMean ; (; ); const. inline . Get the mean parameter. ; Definition at line 46 of file RooPoisson.h. ◆ getNoRounding(). bool RooPoisson::getNoRounding ; (; ); const. inline . Definition at line 37 of file RooPoisson.h. ◆ getX(). RooAbsReal const & RooPoisson::getX ; (; ); const. inline . Get the x variable. ; Definition at line 43 of file RooPoisson.h. ◆ IsA(). TClass * RooPoisson::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from RooAbsPdf.; Definition at line 63 of file RooPoisson.h. ◆ protect",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooPoisson.html:77630,perform,performed,77630,doc/master/classRooPoisson.html,https://root.cern,https://root.cern/doc/master/classRooPoisson.html,1,['perform'],['performed']
Performance,"n.h. ◆ operator()() [1/2]. template<class T > . T ROOT::Math::IParametricGradFunctionMultiDimTempl< T >::operator() ; (; const T * ; x); const. inline . Definition at line 248 of file IParamFunction.h. ◆ operator()() [2/2]. template<class T > . T ROOT::Math::IParametricGradFunctionMultiDimTempl< T >::operator() ; (; const T * ; x, . const double * ; p . ); const. inline . Definition at line 243 of file IParamFunction.h. ◆ ParameterDerivative() [1/2]. template<class T > . T ROOT::Math::IParametricGradFunctionMultiDimTempl< T >::ParameterDerivative ; (; const T * ; x, . const double * ; p, . unsigned int ; ipar = 0 . ); const. inline . Evaluate the partial derivative w.r.t a parameter ipar from values and parameters. ; Definition at line 283 of file IParamFunction.h. ◆ ParameterDerivative() [2/2]. template<class T > . T ROOT::Math::IParametricGradFunctionMultiDimTempl< T >::ParameterDerivative ; (; const T * ; x, . unsigned int ; ipar = 0 . ); const. inline . Evaluate partial derivative using cached parameter values. ; Definition at line 295 of file IParamFunction.h. ◆ ParameterG2(). template<class T > . virtual bool ROOT::Math::IParametricGradFunctionMultiDimTempl< T >::ParameterG2 ; (; const T * ; , . const double * ; , . T * ;  . ); const. inlinevirtual . Evaluate all the second derivatives (diagonal ones) of the function with respect to the parameters at a point x. ; g2 is a vector of dimension npar ; Reimplemented in ROOT::Math::WrappedMultiTF1Templ< T >.; Definition at line 278 of file IParamFunction.h. ◆ ParameterGradient() [1/2]. template<class T > . virtual void ROOT::Math::IParametricGradFunctionMultiDimTempl< T >::ParameterGradient ; (; const T * ; x, . const double * ; p, . T * ; grad . ); const. inlinevirtual . Evaluate the all the derivatives (gradient vector) of the function with respect to the parameters at a point x. ; It is optional to be implemented by the derived classes for better efficiency ; Reimplemented in ROOT::Math::WrappedMultiTF1Templ< T >.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1IParametricGradFunctionMultiDimTempl.html:8253,cache,cached,8253,doc/master/classROOT_1_1Math_1_1IParametricGradFunctionMultiDimTempl.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1IParametricGradFunctionMultiDimTempl.html,1,['cache'],['cached']
Performance,"n::kCSPLINE);  Constructs an interpolator class from vector of data points \( (x_i, y_i )\) and with Interpolation::Type type. ;  ;  Interpolator (Interpolator &&)=delete;  ;  Interpolator (unsigned int ndata=0, Interpolation::Type type=Interpolation::kCSPLINE);  Constructs an interpolator class from number of data points and with Interpolation::Type type. ;  ; virtual ~Interpolator ();  ; double Deriv (double x) const;  Return the derivative of the interpolated function at point x. ;  ; double Deriv2 (double x) const;  Return the second derivative of the interpolated function at point x. ;  ; double Eval (double x) const;  Return the interpolated value at point x. ;  ; double Integ (double a, double b) const;  Return the Integral of the interpolated function over the range [a,b]. ;  ; Interpolator & operator= (const Interpolator &)=delete;  ; Interpolator & operator= (Interpolator &&)=delete;  ; bool SetData (const std::vector< double > &x, const std::vector< double > &y);  Set the data vector ( x[] and y[] ) To be efficient, the size of the data must be the same of the value used in the constructor (ndata) If this is not the case a new re-initialization is performed with the new data size. ;  ; bool SetData (unsigned int ndata, const double *x, const double *y);  Set the data vector ( x[] and y[] ) To be efficient, the size of the data must be the same of the value used when constructing the class (ndata) If this is not the case a new re-initialization is performed with the new data size. ;  ; std::string Type () const;  Return the type of interpolation method. ;  ; std::string TypeGet () const;  . Private Attributes; GSLInterpolator * fInterp;  . #include <Math/Interpolator.h>; Constructor & Destructor Documentation. ◆ Interpolator() [1/4]. ROOT::Math::Interpolator::Interpolator ; (; unsigned int ; ndata = 0, . Interpolation::Type ; type = Interpolation::kCSPLINE . ). Constructs an interpolator class from number of data points and with Interpolation::Type type. ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1Interpolator.html:2290,perform,performed,2290,doc/master/classROOT_1_1Math_1_1Interpolator.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1Interpolator.html,1,['perform'],['performed']
Performance,"n; Long_t*TQCommand::fUndoArgsundo values; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TQUndoManager(); Constructor. ~TQUndoManager(); Destructor. void ls(Option_t* option = """") const; Lists all commands in stack. void PrintCollectionEntry(TObject* entry, Option_t* option, Int_t recurse) const; Print collection entry. void SetLogging(Bool_t on = kTRUE); Start logging. Delete all previous log records; Note: logging is not implemented yet. void Add(TObject* obj, Option_t* opt); Add command to the stack of commands.; Command's redo action will be executed. option string can contain the following substrings:; ""merge"" - input command will be merged; ""compress"" - input command will be compressed. void CurrentChanged(TQCommand* c); emit signal. void Undo(Option_t* option = """"); Performs undo action. Move cursor position backward in history stack. void Redo(Option_t* option = """"); Performs redo action. Move cursor position forward in history stack. Bool_t CanRedo() const; Returns kTRUE if redo action is possible. Bool_t CanUndo() const; Returns kTRUE if undo action is possible. Bool_t IsLogging() const; Returns kTRUE if logging is ON. TQCommand * GetCurrent() const; Returns the last executed command. TQCommand * GetCursor() const; Returns a command correspondent to the current cursor position in stack. void SetLimit(UInt_t limit); Returns a maximum number of commands which could be located in stack. UInt_t GetLimit() const; Returns a maximum number of commands which could be located in stack. void Add(TObject* obj, Option_t* opt). » Author: Valeriy Onuchin 04/27/2004 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-03-14 16:48; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TQUndoManager.html:19480,Perform,Performs,19480,root/html534/TQUndoManager.html,https://root.cern,https://root.cern/root/html534/TQUndoManager.html,1,['Perform'],['Performs']
Performance,"nBinsnumber of bins to scan, if = -1 no scan is done (default); RooArgSetfNuisanceParameters; RooArgSetfPOI; RooAbsPdf*fPdf; ROOT::Math::IBaseFunctionOneDim*fPosteriorFunctionfunction representing the posterior; RooAbsPdf*fPosteriorPdfnormalized (on the poi) posterior pdf ; RooAbsPdf*fPriorPOI; RooAbsPdf*fProductPdfinternal pointer to model * prior; doublefSizesize used for getting the interval; Double_tfUpperupper interval bound; Bool_tfValidInterval. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BayesianCalculator(); default constructor. BayesianCalculator( /* const char* name, const char* title, */ RooAbsData& data, RooAbsPdf& pdf,						 const RooArgSet& POI,						 RooAbsPdf& priorPOI,						 const RooArgSet* nuisanceParameters ); TNamed( TString(name), TString(title) ),; constructor. BayesianCalculator(RooAbsData& data, RooStats::ModelConfig& model); constructor from Model Config. ~BayesianCalculator(); destructor. void ClearAll() const; clear cached pdf objects. void SetModel(const RooStats::ModelConfig& model); set the model. RooAbsReal* GetPosteriorFunction() const; build and return the posterior function (not normalized) as a RooAbsReal; the posterior is obtained from the product of the likelihood function and the; prior pdf which is then intergated in the nuisance parameters (if existing).; A prior function for the nuisance can be specified either in the prior pdf object; or in the model itself. If no prior nuisance is specified, but prior parameters are then; the integration is performed assuming a flat prior for the nuisance parameters. RooAbsPdf* GetPosteriorPdf() const; build and return the posterior pdf (i.e posterior function normalized to all range of poi; NOTE: user must delete the returned object. RooPlot* GetPosteriorPlot(bool norm = false, double precision = 0.01) const; return a RooPlot with the posterior and the credibility region. void SetIntegrationType(const char* type). SimpleInterval* GetInterval(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooStats__BayesianCalculator.html:8361,cache,cached,8361,root/html528/RooStats__BayesianCalculator.html,https://root.cern,https://root.cern/root/html528/RooStats__BayesianCalculator.html,1,['cache'],['cached']
Performance,"nByte processing rate running avg vs query time; Float_tfMaxTimeMax time for this query (slowest worker); Float_tfMergeTimeBegin of merging time for this query; TH1F*fPacketsPacket distribution per worker; Bool_tfSaveResultWhether to save the results of a run; TTree*fTreeThe performance tree; TStringfTreeNameThe name of the performance tree; TSortedListfWrksInfoSorted list of workers info; static Bool_tfgDebugGlobal verbosity on/off. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofPerfAnalysis(const char* perffile, const char* title = """", const char* treename = ""PROOF_PerfStats""); Constructor: open the file and attach to the tree. TProofPerfAnalysis(TTree* tree, const char* title = """"); Constructor: open the file and attach to the tree. ~TProofPerfAnalysis(); Destructor: detach the tree and close the file. TString GetCanvasTitle(const char* t); If defined, add '- <this title>' to the canvas title 't'. void LoadTree(TDirectory* dir); Load tree fTreeName from directory 'dir'. If not found, look for the; first TTree in the directory (and sub-directories) with the name containing; fTreeName.; The tree pointer is saved in fTree. void FileDist(Bool_t writedet = kFALSE); Analyse the file distribution. If writedet, underling details are; written out to a text file. void GetWrkFileList(TList* wl, TList* sl); Fill file info. Int_t CompareOrd(const char* ord1, const char* ord2); Return -1 if ord1 comes before ord2, 0 i they are equal,; 1 if ord1 comes after ord2. void FillFileDist(TH1F* hf, TH1F* hb, TH2F* hx, Bool_t wdet = kFALSE); Fill file info. void FillFileDistOneSrv(TH1F* hx, Bool_t wdet = kFALSE); Fill file info when there is only one file server. void WorkerActivity(); Measure the worker activity. void PrintWrkInfo(Int_t showlast = 10); Print information for all or the slowest showlast workers.; Use showlast < 0 to print all. void PrintWrkInfo(const char* wrk); Print information for worker 'wn' (ordinal) or on the machin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TProofPerfAnalysis.html:9449,Load,LoadTree,9449,root/html604/TProofPerfAnalysis.html,https://root.cern,https://root.cern/root/html604/TProofPerfAnalysis.html,2,['Load'],"['Load', 'LoadTree']"
Performance,"nCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static RooPrintable::StyleOptionRooPrintable::kSingleLine; static RooPrintable::StyleOptionRooPrintable::kStandard; static RooPrintable::ContentsOptionRooPrintable::kTitle; static RooPrintable::StyleOptionRooPrintable::kTreeStructure; static RooPrintable::ContentsOptionRooPrintable::kValue; static RooPrintable::StyleOptionRooPrintable::kVerbose; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TIterator*RooAbsData::_cacheIter! Iterator over cached variables; RooArgSetRooAbsData::_cachedVars! External variables cached with this data set; TDirectory*RooDirItem::_dir! Associated directory; RooAbsDataStore*RooAbsData::_dstoreData storage implementation; TIterator*RooAbsData::_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; map<string,RooAbsData*>RooAbsData::_ownedComponentsOwned external components; static char*_poolBegin! Start of memory pool; static char*_poolCur! Next free slot in memory pool; static char*_poolEnd! End of memory pool; RooArgSetRooAbsData::_varsDimensions of this data set; RooArgSet_varsNoWgtVars without weight variable; RooRealVar*_wgtVarPointer to weight variable (if set); static RooAbsData::StorageTypeRooAbsData::defaultStorageType; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void cleanup(); Clear memoery pool on exit to avoid reported memory leaks. void* operator new(size_t bytes); Overloaded new operator guarantees that all RooDataSets allocated with new; have a unique address, a property that is exploited in several places; in roofit to quickly index contents on normalization set pointers.; The memory pool only allocates space for the class itself. The elements; stored in the set are stored outside the pool. void operator delete(vo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooDataSet.html:18372,cache,cached,18372,root/html602/RooDataSet.html,https://root.cern,https://root.cern/root/html602/RooDataSet.html,8,['cache'],['cached']
Performance,"nCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TEveCaloLego::E2DMode_ekValColor; static TEveCaloLego::E2DMode_ekValSize; static TEveCaloLego::E2DMode_ekValSizeOutline; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TEveCaloLego::E2DMode_ef2DMode; Bool_tTEveCaloViz::fAutoRangeset eta phi limits on DataChanged(); Bool_tfAutoRebin; Float_t*TAttBBox::fBBox! Dynamic Float_t[6] X(min,max), Y(min,max), Z(min,max); Float_tTEveCaloViz::fBarrelRadiusbarrel raidus in cm; TEveCaloLego::EBoxMode_efBoxModeadditional scale info; UChar_tTEveElement::fCSCBits; Bool_tTEveElement::fCanEditMainColorAllow editing of main color.; Bool_tTEveElement::fCanEditMainTransAllow editing of main transformation.; Bool_tTEveElement::fCanEditMainTransparencyAllow editing of main transparency.; Bool_tTEveCaloViz::fCellIdCacheOKdata cell ids cache state; TEveCaloData::vCellId_tfCellList; Int_tfCellPixelFontSize; UChar_tTEveElement::fChangeBits!; TEveElement::List_tTEveElement::fChildrenList of children.; TEveCompound*TEveElement::fCompoundCompound this object belongs to.; TEveCaloData*TEveCaloViz::fDataevent data reference; Int_tTEveElement::fDenyDestroy! Deny-destroy count.; Bool_tTEveElement::fDestroyOnZeroRefCntAuto-destruct when ref-count reaches zero.; Char_tTEveElement::fDestructing!; Bool_tfDrawHPlane; Int_tfDrawNumberCellPixels; Float_tTEveCaloViz::fEndCapPosBbackward end cap z coordinate in cm (should be < 0); Float_tTEveCaloViz::fEndCapPosFforward end cap z coordinate in cm; Double_tTEveCaloViz::fEtaMax; Double_tTEveCaloViz::fEtaMin; Float_tfFixedHeightValIn2DMode1% of whole height; Color_tfFontColor; Color_tfGridColor; Float_tfHPlaneVal; Bool_tfHasFixedHeightIn2DMode; Bool_tTEveElement::fHighlighted!; Short_tTEveElement::fImpliedHighlighted!; Short_tTEveElement::fImpliedSelected!; TEveElement::sLTI_tTEveElement::fItems! Set of list-tree-items.; Color_t*TEveElement::fMa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEveCaloLego.html:22867,cache,cache,22867,root/html602/TEveCaloLego.html,https://root.cern,https://root.cern/root/html602/TEveCaloLego.html,4,['cache'],['cache']
Performance,"nCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Bool_tTList::fAscending! sorting order (when calling Sort() or for TSortedList); TObjLink*TList::fCache! cache to speedup sequential calling of Before() and After() functions; TObjLink*TList::fFirst! pointer to first entry in linked list; TObjLink*TList::fLast! pointer to last entry in linked list; TStringTCollection::fNamename of the collection; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted; THashTable*THashList::fTableHashtable used for quick lookup of objects; static TCollection::(anonymous)TCollection::kIsOwner. private:. TClass*fClass! Context of this list. Not owned.; TExMap*fIds! Map from DeclId_t to TEnum*; Bool_tfIsLoaded! Mark whether Load was executed.; ULong64_tfLastLoadMarker! Represent interpreter state when we last did a full load.; THashList*fUnloaded! Holder of TEnum for unloaded Enums. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TListOfEnums(TClass* cl = 0); Constructor. ~TListOfEnums(); Destructor. void MapObject(TObject* obj); Add pair<id, object> to the map of functions and their ids. void AddFirst(TObject* obj); Add object at the beginning of the list. void AddFirst(TObject* obj, Option_t* opt); Add object at the beginning of the list and also store option.; Storing an option is useful when one wants to change the behaviour; of an object a little without having to create a complete new; copy of the object. This feature is used, for example, by the Draw(); method. It allows the same object to be drawn in different ways. void AddLast(TObject* obj); Add object at the end of the list. void AddLast(TObject* obj, Option_t* opt); Add object at the end of the list and also store option.; Storing an option is useful when one w",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TListOfEnums.html:11429,load,load,11429,root/html602/TListOfEnums.html,https://root.cern,https://root.cern/root/html602/TListOfEnums.html,4,['load'],['load']
Performance,"nCoefList, Bool_t recursiveFractions); Generic constructor from list of PDFs and list of coefficients.; Each pdf list element (i) is paired with coefficient list element (i).; The number of coefficients must be either equal to the number of PDFs,; in which case extended MLL fitting is enabled, or be one less. All PDFs must inherit from RooAbsPdf. All coefficients must inherit from RooAbsReal. If the recursiveFraction flag is true, the coefficients are interpreted as recursive; coefficients as explained in the class description. RooAddPdf(const char* name, const char* title, const RooArgList& pdfList); Generic constructor from list of extended PDFs. There are no coefficients as the expected; number of events from each components determine the relative weight of the PDFs. All PDFs must inherit from RooAbsPdf. RooAddPdf(const RooAddPdf& other, const char* name); Copy constructor. ~RooAddPdf(); Destructor. void fixCoefNormalization(const RooArgSet& refCoefNorm); By default the interpretation of the fraction coefficients is; performed in the contextual choice of observables. This makes the; shape of the p.d.f explicitly dependent on the choice of; observables. This method instructs RooAddPdf to freeze the; interpretation of the coefficients to be done in the given set of; observables. If frozen, fractions are automatically transformed; from the reference normalization set to the contextual normalization; set by ratios of integrals. void fixCoefRange(const char* rangeName); By default the interpretation of the fraction coefficients is; performed in the default range. This make the shape of a RooAddPdf; explicitly dependent on the range of the observables. To allow; a range independent definition of the fraction this function; instructs RooAddPdf to freeze its interpretation in the given; named range. If the current normalization range is different; from the reference range, the appropriate fraction coefficients; are automically calculation from the reference fractions usin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAddPdf.html:43180,perform,performed,43180,root/html526/RooAddPdf.html,https://root.cern,https://root.cern/root/html526/RooAddPdf.html,1,['perform'],['performed']
Performance,"nDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. Long64_tfBytesRead!track bytes read of main file; TH2D*fCpuTimeHist!histogram of cpu time spent processing packets; TStringfDataSet!Dataset string; Int_tfDataSetLen!Maximum size of the dataset string fDataSet ; Int_tfDataSetSize!# of files in the dataset ; Bool_tfDoHist!Fill histos; Bool_tfDoQuota!Save stats on SQL server for quota management; Bool_tfDoSlaveTrace!Full tracing in workers; Bool_tfDoTrace!Trace details in master; Bool_tfDoTraceRate!Trace processing rate in master; TH1D*fEventsHist!histogram of events processed per slave; TH2D*fLatencyHist!histogram of latency due to packet requests; Int_tfMonitorInfo!Controls what information to monitor ; Bool_tfMonitorPerPacket!Whether to send the full entry per each packet ; TObjArrayfMonitoringWriters!Monitoring engines; TH1D*fNodeHist!histogram of slaves per file serving node; Long64_tfNumEvents!total number of events to be processed; TList*fOutput!Saved pointer to the output list ; TH1D*fPacketsHist!histogram of packets processed per slave; TPerfEvent*fPerfEvent!TPerfEvent used to fill tree; TH2D*fProcTimeHist!histogram of real time spent processing packets; Int_tfSlaves!number of active slaves; Long64_tfTotBytesRead!total bytes read on all slaves; Double_tfTotCpuTime!total cpu time of all slaves; Long64_tfTotEvents!total number of events processed; TTree*fTrace!TTree with trace events; TTimeStampfTzero!start time of this run; static Long_tfgResMemMax! Max resident memory used by this process; static Long_tfgVirtMemMax! Max virtual memory used by this process. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPerfStats(TList* input, TList* output); Normal constructor. void SimpleEvent(TVirtualPerfStats::EEventType type); Simple event. void Packe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TPerfStats.html:7036,latency,latency,7036,root/html530/TPerfStats.html,https://root.cern,https://root.cern/root/html530/TPerfStats.html,1,['latency'],['latency']
Performance,"nEntry(TObject* entry, Option_t* option, Int_t recurse) const; virtual voidPrintCollectionHeader(Option_t* option) const. private:. TQConnection&operator=(const TQConnection&). Data Members; public:. enum TCollection::[unnamed] { kIsOwner; kInitCapacity; kInitHashTableCapacity; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_tTList::fAscending! sorting order (when calling Sort() or for TSortedList); TObjLink*TList::fCache! cache to speedup sequential calling of Before() and After() functions; TStringfClassNameclass name of the receiver; TObjLink*TList::fFirst! pointer to first entry in linked list; TObjLink*TList::fLast! pointer to last entry in linked list; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; TStringTCollection::fNamename of the collection; void*fReceiverptr to object to which slot is applied; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Int_tTCollection::fSizenumber of elements in collection; TQSlot*fSlotslot-method calling interface; Bool_tTSeqCollection::fSortedtrue if collection has been sorted; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TQConnection(); Default constructor. TQConnection(TClass* cl, void* receiver, const char* method_name); TQConnection ctor.; cl != 0 - connection to object == receiver of class == cl; and method == method_name; cl == 0 - connection to function with name == method_name. TQConnection(const char* class_name, void* receiver, const char* method_name); TQConnection ctor.; Creates connection to method of class specified by name,; it could be interpreted class",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TQConnection.html:13495,cache,cache,13495,root/html534/TQConnection.html,https://root.cern,https://root.cern/root/html534/TQConnection.html,2,['cache'],['cache']
Performance,"nLevel . ). ◆ CreateClass() [1/2]. TClass * ROOT::CreateClass ; (; const char * ; cname, . Version_t ; id, . const char * ; dfil, . const char * ; ifil, . Int_t ; dl, . Int_t ; il . ). Global function called by a class' static Dictionary() method (see the ClassDef macro). ; Definition at line 5951 of file TClass.cxx. ◆ CreateClass() [2/2]. TClass * ROOT::CreateClass ; (; const char * ; cname, . Version_t ; id, . const std::type_info & ; info, . TVirtualIsAProxy * ; isa, . const char * ; dfil, . const char * ; ifil, . Int_t ; dl, . Int_t ; il . ). Global function called by a class' static Dictionary() method (see the ClassDef macro). ; Definition at line 5936 of file TClass.cxx. ◆ DisableImplicitMT(). void ROOT::DisableImplicitMT ; (; ). Disables the implicit multi-threading in ROOT (see EnableImplicitMT). ; Definition at line 556 of file TROOT.cxx. ◆ EnableImplicitMT(). void ROOT::EnableImplicitMT ; (; UInt_t ; numthreads = 0). Enable ROOT's implicit multi-threading for all objects and methods that provide an internal parallelisation mechanism. ; Parameters. [in]numthreadsNumber of threads to use. If not specified or set to zero, the number of threads is automatically decided by the implementation. Any other value is used as a hint. ROOT must be built with the compilation flag imt=ON for this feature to be available. The following objects and methods automatically take advantage of multi-threading if a call to EnableImplicitMT has been made before usage:. RDataFrame internally runs the event-loop by parallelizing over clusters of entries; TTree::GetEntry reads multiple branches in parallel; TTree::FlushBaskets writes multiple baskets to disk in parallel; TTreeCacheUnzip decompresses the baskets contained in a TTreeCache in parallel; THx::Fit performs in parallel the evaluation of the objective function over the data; TMVA::DNN trains the deep neural networks in parallel; TMVA::BDT trains the classifier in parallel and multiclass BDTs are evaluated in parallel. Enable",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT.html:31221,multi-thread,multi-threading,31221,doc/master/namespaceROOT.html,https://root.cern,https://root.cern/doc/master/namespaceROOT.html,1,['multi-thread'],['multi-threading']
Performance,"nMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; const RooArgSet*_projDepsPointer to set with projected observables; TListRooAbsArg::_proxyListlist of proxies; string_rangeNameName of range in which to calculate test statistic; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; Int_t_simCountTotal number of component p.d.f.s in RooSimultaneous (if any); RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; Bool_t_splitRangeSplit rangeName in RooSimultaneous index labels if true; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; Bool_t_verboseVerbose messaging if true; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. RooAbsTestStatistic**_gofArray! Array of sub-contexts representing part of the combined test statistic; RooAbsTestStatistic::GOFOpMode_gofOpModeOperation mode of test statistic instance ; Bool_t_init! Is object initialized ; RooRealMPFE**_mpfeArray! Array of parallel execution frond ends; Bool_t_mpinterlUse interleaving strategy rather than N-wise split for partioning of dataset for multiprocessor-split; Int_t_nCPUNumber of processors to use in parallel calculation mode; Int_t_nEventsTotal number of events in test statistic calculation; Int_t_nGofNumber of sub",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsTestStatistic.html:33963,cache,cache,33963,root/html526/RooAbsTestStatistic.html,https://root.cern,https://root.cern/root/html526/RooAbsTestStatistic.html,1,['cache'],['cache']
Performance,"nProxy::Initialize(Bool_t silent) const; virtual TGenCollectionProxy*TEmulatedCollectionProxy::InitializeEx(Bool_t silent); voidTEmulatedCollectionProxy::ReadItems(int nElements, TBuffer& b); voidReadMap(int nElements, TBuffer& b); voidTEmulatedCollectionProxy::Shrink(UInt_t nCurr, UInt_t left, Bool_t force); voidTEmulatedCollectionProxy::WriteItems(int nElements, TBuffer& b); voidWriteMap(int nElements, TBuffer& b). Data Members; public:. enum TGenCollectionProxy::[unnamed] { kBIT_ISSTRING; kBIT_ISTSTRING; kBOOL_t; };; enum TVirtualCollectionProxy::EProperty { kIsInitialized; kIsAssociative; kIsEmulated; kNeedDelete; };. public:. static const Int_tTVirtualCollectionProxy::fgIteratorArenaSizegreater than sizeof(void*) + sizeof(UInt_t). protected:. TClassRefTVirtualCollectionProxy::fClass; TGenCollectionProxy::MethodTGenCollectionProxy::fClearMethod cache for container accessors: clear container; TGenCollectionProxy::MethodTGenCollectionProxy::fCollectMethod to collect objects from container; void*TGenCollectionProxy::fConstructContainer accessors: block construct; map<std::string,TObjArray*>*TGenCollectionProxy::fConversionReadMemberWiseArray of bundle of TStreamerInfoActions to stream out (read) derived from another class.; TGenCollectionProxy::Method0TGenCollectionProxy::fCreateEnvMethod to allocate an Environment holder.; void*TGenCollectionProxy::fDestructContainer accessors: block destruct; ROOT::TCollectionProxyInfo::EnvironBase*TGenCollectionProxy::fEnvAddress of the currently proxied object; void*TGenCollectionProxy::fFeedContainer accessors: block feed; TGenCollectionProxy::MethodTGenCollectionProxy::fFirstContainer accessors: generic iteration: first; void*TGenCollectionProxy::fFunctionCreateIterators; void*TGenCollectionProxy::fFunctionDeleteTwoIterators; TGenCollectionProxy::Value*TGenCollectionProxy::fKeyDescriptor of the key_type; stringTGenCollectionProxy::fNameName of the class being proxied.; TGenCollectionProxy::MethodTGenCollectionProxy::fNextCont",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEmulatedMapProxy.html:4569,cache,cache,4569,root/html532/TEmulatedMapProxy.html,https://root.cern,https://root.cern/root/html532/TEmulatedMapProxy.html,2,['cache'],['cache']
Performance,"nSetting::EAlgorithm::EValues algorithm, int compressionLevel);  ; int CompressionSettings (ROOT::ECompressionAlgorithm algorithm, int compressionLevel);  Deprecated name, do not use: ;  ; TClass * CreateClass (const char *cname, Version_t id, const char *dfil, const char *ifil, Int_t dl, Int_t il);  Global function called by a class' static Dictionary() method (see the ClassDef macro). ;  ; TClass * CreateClass (const char *cname, Version_t id, const std::type_info &info, TVirtualIsAProxy *isa, const char *dfil, const char *ifil, Int_t dl, Int_t il);  Global function called by a class' static Dictionary() method (see the ClassDef macro). ;  ; void DisableImplicitMT ();  Disables the implicit multi-threading in ROOT (see EnableImplicitMT). ;  ; void EnableImplicitMT (UInt_t numthreads=0);  Enable ROOT's implicit multi-threading for all objects and methods that provide an internal parallelisation mechanism. ;  ; void EnableThreadSafety ();  Enable support for multi-threading within the ROOT code in particular, enables the global mutex to make ROOT thread safe/aware. ;  ; static std::string::size_type FindEndSymbol (std::string &command);  ; template<typename T > ; EFromHumanReadableSize FromHumanReadableSize (ROOT::Internal::TStringView str, T &value);  ; template<typename T > ; EFromHumanReadableSize FromHumanReadableSize (std::string_view str, T &value);  Convert strings like the following into byte counts 5MB, 5 MB, 5M, 3.7GB, 123b, 456kB, 3.7GiB, 5MiB with some amount of forgiveness baked into the parsing. ;  ; template<typename T > ; TClass * GetClass (const T *);  ; template<typename T > ; TClass * GetClass (const T **);  ; template<typename T > ; TClass * GetClass (const T *const *);  ; template<typename T > ; TClass * GetClass (T *);  ; template<typename T > ; TClass * GetClass (T **);  ; std::vector< std::unique_ptr< TClassRec > > & GetDelayedAddClass ();  ; std::vector< std::pair< const char *, const char * > > & GetDelayedAddClassAlternate ();  ; TString &",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v628/namespaceROOT.html:9265,multi-thread,multi-threading,9265,doc/v628/namespaceROOT.html,https://root.cern,https://root.cern/doc/v628/namespaceROOT.html,2,['multi-thread'],['multi-threading']
Performance,"nSetting::EAlgorithm::EValues algorithm, int compressionLevel);  ; int CompressionSettings (ROOT::ECompressionAlgorithm algorithm, int compressionLevel);  Deprecated name, do not use: ;  ; TClass * CreateClass (const char *cname, Version_t id, const char *dfil, const char *ifil, Int_t dl, Int_t il);  Global function called by a class' static Dictionary() method (see the ClassDef macro). ;  ; TClass * CreateClass (const char *cname, Version_t id, const std::type_info &info, TVirtualIsAProxy *isa, const char *dfil, const char *ifil, Int_t dl, Int_t il);  Global function called by a class' static Dictionary() method (see the ClassDef macro). ;  ; void DisableImplicitMT ();  Disables the implicit multi-threading in ROOT (see EnableImplicitMT). ;  ; void EnableImplicitMT (UInt_t numthreads=0);  Enable ROOT's implicit multi-threading for all objects and methods that provide an internal parallelisation mechanism. ;  ; void EnableThreadSafety ();  Enable support for multi-threading within the ROOT code in particular, enables the global mutex to make ROOT thread safe/aware. ;  ; static std::string::size_type FindEndSymbol (std::string &command);  ; template<typename T > ; EFromHumanReadableSize FromHumanReadableSize (std::string_view str, T &value);  Convert strings like the following into byte counts 5MB, 5 MB, 5M, 3.7GB, 123b, 456kB, 3.7GiB, 5MiB with some amount of forgiveness baked into the parsing. ;  ; template<typename T > ; TClass * GetClass (const T *);  ; template<typename T > ; TClass * GetClass (const T **);  ; template<typename T > ; TClass * GetClass (const T *const *);  ; template<typename T > ; TClass * GetClass (T *);  ; template<typename T > ; TClass * GetClass (T **);  ; std::vector< std::unique_ptr< TClassRec > > & GetDelayedAddClass ();  ; std::vector< std::pair< const char *, const char * > > & GetDelayedAddClassAlternate ();  ; TString & GetMacroPath ();  ; TROOT * GetROOT ();  ; void GetRuleIncludes (std::list< std::string > &result);  Get the list of",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/namespaceROOT.html:13919,multi-thread,multi-threading,13919,doc/v632/namespaceROOT.html,https://root.cern,https://root.cern/doc/v632/namespaceROOT.html,1,['multi-thread'],['multi-threading']
Performance,"nTGLViewer::fPushAction; TGLRedrawTimer*TGLViewer::fRedrawTimer! timer for triggering redraws; Bool_tTGLViewer::fReferenceOn! reference marker on?; TGLVertex3TGLViewer::fReferencePos! reference position; Bool_tTGLViewer::fResetCamerasOnNextUpdatereposition camera on next update; Bool_tTGLViewer::fResetCamerasOnUpdatereposition camera on each update; Bool_tTGLViewerBase::fResetSceneInfosOnRenderRequest rebuild of view-specific scene data.; TGLRnrCtx*TGLViewerBase::fRnrCtx; TGLViewerBase::SceneInfoList_tTGLViewerBase::fScenesRegistered scenes.; TGLSelectRecordTGLViewer::fSecSelRec! select record from last secondary select (should go to context); TGLSelectRecordTGLViewer::fSelRec! select record from last select (should go to context); TGLManipSet*TGLViewer::fSelectedPShapeRef!; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Bool_tTGLViewer::fSmartRefresh! cache logicals during scene rebuilds; Bool_tTGLViewer::fSmoothLines! smooth line edge rendering; Bool_tTGLViewer::fSmoothPoints! smooth point edge rendering; Bool_tTGLViewer::fStereo! use stereo rendering; Float_tTGLViewer::fStereoEyeOffsetFac!; Float_tTGLViewer::fStereoFrustumAsymFac!; Bool_tTGLViewer::fStereoQuadBuf! draw quad buffer or left/right stereo in left/right half of window; Float_tTGLViewer::fStereoZeroParallax! position of zero-parallax plane: 0 - near clipping plane, 1 - far clipping plane; Short_tTGLViewerBase::fStyleViewer-style for rendering.; TGLRectTGLViewer::fViewport! viewport - drawn area; TGLViewerBase::SceneInfoVec_tTGLViewerBase::fVisScenesVisible scenes.; Float_tTGLViewerBase::fWFLineWOptional override of scene wire-frame line-width; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static TGLColorSetTGLViewer::fgDefaultColorSet! a shared, default color-set; static Bool_tTGLViewer::fgUseDefaultColorSetForNewViewers! name says it all. private:. Int_tfBorder; TGCompositeFrame*fFrame. Class Charts. Inheritance; Inherited Members; Includes;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGLEmbeddedViewer.html:25235,cache,cache,25235,root/html604/TGLEmbeddedViewer.html,https://root.cern,https://root.cern/root/html604/TGLEmbeddedViewer.html,2,['cache'],['cache']
Performance,"nTGLViewer::fPushAction; TGLRedrawTimer*TGLViewer::fRedrawTimer! timer for triggering redraws; Bool_tTGLViewer::fReferenceOn! reference marker on?; TGLVertex3TGLViewer::fReferencePos! reference position; Bool_tTGLViewer::fResetCamerasOnNextUpdatereposition camera on next update; Bool_tTGLViewer::fResetCamerasOnUpdatereposition camera on each update; Bool_tTGLViewerBase::fResetSceneInfosOnRenderRequest rebuild of view-specific scene data.; TGLRnrCtx*TGLViewerBase::fRnrCtx; TGLViewerBase::SceneInfoList_tTGLViewerBase::fScenesRegistered scenes.; TGLSelectRecordTGLViewer::fSecSelRec! select record from last secondary select (should go to context); TGLSelectRecordTGLViewer::fSelRec! select record from last select (should go to context); TGLManipSet*TGLViewer::fSelectedPShapeRef!; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Bool_tTGLViewer::fSmartRefresh! cache logicals during scene rebuilds; Bool_tTGLViewer::fSmoothLines! smooth line edge rendering; Bool_tTGLViewer::fSmoothPoints! smooth point edge rendering; Bool_tTGLViewer::fStereo! use stereo rendering; Float_tTGLViewer::fStereoEyeOffsetFac!; Float_tTGLViewer::fStereoFrustumAsymFac!; Bool_tTGLViewer::fStereoQuadBuf! draw quad buffer or left/right stereo in left/right half of window; Float_tTGLViewer::fStereoZeroParallax! position of zero-parallax plane: 0 - near clipping plane, 1 - far clipping plane; Short_tTGLViewerBase::fStyleViewer-style for rendering.; TGLRectTGLViewer::fViewport! viewport - drawn area; TGLViewerBase::SceneInfoVec_tTGLViewerBase::fVisScenesVisible scenes.; Float_tTGLViewerBase::fWFLineWOptional override of scene wire-frame line-width; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static TGLColorSetTGLViewer::fgDefaultColorSet! a shared, default color-set; static Bool_tTGLViewer::fgUseDefaultColorSetForNewViewers! name says it all. private:. TGPopupMenu*fCameraMenu; Bool_tfDeleteMenuBar; TStringfDirName; TGPopupMenu*fFileMenu; TGPopup",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGLSAViewer.html:26611,cache,cache,26611,root/html604/TGLSAViewer.html,https://root.cern,https://root.cern/root/html604/TGLSAViewer.html,2,['cache'],['cache']
Performance,"n[fNseek] Length of buffers to be prefetched; Int_t*TFileCacheRead::fSeekPos[fNseek] Position of sorted blocks in fBuffer; Int_tTFileCacheRead::fSeekSizeAllocated size of fSeek; Long64_t*TFileCacheRead::fSeekSort[fNseek] Position on file of buffers to be prefetched (sorted); Int_t*TFileCacheRead::fSeekSortLen[fNseek] Length of buffers to be prefetched (sorted); TTree*fTree! pointer to the current Tree; static Int_tfgLearnEntriesnumber of entries used for learning mode. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTreeCache(); Default Constructor. TTreeCache(TTree* tree, Int_t buffersize = 0); Constructor. ~TTreeCache(); destructor. (in general called by the TFile destructor). void AddBranch(TBranch* b, Bool_t subgbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. void AddBranch(const char* branch, Bool_t subbranches = kFALSE); Add a branch to the list of branches to be stored in the cache; this is to be used by user (thats why we pass the name of the branch).; It works in exactly the same way as TTree::SetBranchStatus so you; probably want to look over ther for details about the use of bname; with regular expressions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped. void DropBranch(TBranch* b, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. void DropBranch(const char* branch, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this is to be used by user (thats why we pass the name of the branch).; It works in exactly the same way as TTree::SetBranchStatus so you; probably want to look over ther for details about the use of bname; with regular expresions.; The branches are tak",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTreeCache.html:21656,cache,cache,21656,root/html534/TTreeCache.html,https://root.cern,https://root.cern/root/html534/TTreeCache.html,2,['cache'],['cache']
Performance,"n], &fEXlow[ibegin], n);; 1040 memmove(&arrays[1][obegin], &fEXhigh[ibegin], n);; 1041 memmove(&arrays[2][obegin], &fEYlow[ibegin], n);; 1042 memmove(&arrays[3][obegin], &fEYhigh[ibegin], n);; 1043 } else {; 1044 memmove(&fEXlow[obegin], &fEXlow[ibegin], n);; 1045 memmove(&fEXhigh[obegin], &fEXhigh[ibegin], n);; 1046 memmove(&fEYlow[obegin], &fEYlow[ibegin], n);; 1047 memmove(&fEYhigh[obegin], &fEYhigh[ibegin], n);; 1048 }; 1049 return kTRUE;; 1050 } else {; 1051 return kFALSE;; 1052 }; 1053}; 1054 ; 1055 ; 1056////////////////////////////////////////////////////////////////////////////////; 1057/// Should be called from ctors after `fNpoints` has been set.; 1058/// Note: This function should be called only from the constructor; 1059/// since it does not delete previously existing arrays; 1060 ; 1061Bool_t TGraphAsymmErrors::CtorAllocate(); 1062{; 1063 if (!fNpoints) {; 1064 fEXlow = fEYlow = fEXhigh = fEYhigh = nullptr;; 1065 return kFALSE;; 1066 }; 1067 fEXlow = new Double_t[fMaxSize];; 1068 fEYlow = new Double_t[fMaxSize];; 1069 fEXhigh = new Double_t[fMaxSize];; 1070 fEYhigh = new Double_t[fMaxSize];; 1071 return kTRUE;; 1072}; 1073 ; 1074////////////////////////////////////////////////////////////////////////////////; 1075/// Protected function to perform the merge operation of a graph with asymmetric errors.; 1076 ; 1077Bool_t TGraphAsymmErrors::DoMerge(const TGraph *g); 1078{; 1079 if (g->GetN() == 0) return kFALSE;; 1080 ; 1081 Double_t * exl = g->GetEXlow();; 1082 Double_t * exh = g->GetEXhigh();; 1083 Double_t * eyl = g->GetEYlow();; 1084 Double_t * eyh = g->GetEYhigh();; 1085 if (exl == nullptr || exh == nullptr || eyl == nullptr || eyh == nullptr) {; 1086 if (g->IsA() != TGraph::Class() ); 1087 Warning(""DoMerge"",""Merging a %s is not compatible with a TGraphAsymmErrors - errors will be ignored"",g->IsA()->GetName());; 1088 return TGraph::DoMerge(g);; 1089 }; 1090 for (Int_t i = 0 ; i < g->GetN(); i++) {; 1091 Int_t ipoint = GetN();; 1092 Double_t x = g->Ge",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html:37280,perform,perform,37280,doc/master/TGraphAsymmErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html,1,['perform'],['perform']
Performance,"n_20 = 0.999962 +/- 0.0369391 (limited); p_ph_bkg_gamma_bin_21 = 0.998374 +/- 0.0370495 (limited); p_ph_bkg_gamma_bin_22 = 0.998427 +/- 0.0380223 (limited); p_ph_bkg_gamma_bin_23 = 0.984048 +/- 0.0361184 (limited); p_ph_bkg_gamma_bin_24 = 1.02675 +/- 0.0373117 (limited); p_ph_bkg_gamma_bin_3 = 1.00565 +/- 0.0386186 (limited); p_ph_bkg_gamma_bin_4 = 0.990685 +/- 0.0377676 (limited); p_ph_bkg_gamma_bin_5 = 0.992405 +/- 0.0376505 (limited); p_ph_bkg_gamma_bin_6 = 1.01052 +/- 0.038689 (limited); p_ph_bkg_gamma_bin_7 = 0.99731 +/- 0.0359322 (limited); p_ph_bkg_gamma_bin_8 = 0.980392 +/- 0.0362349 (limited); p_ph_bkg_gamma_bin_9 = 1.00987 +/- 0.0372551 (limited); p_ph_sig_gamma_bin_11 = 1.09457 +/- 0.29733 (limited); p_ph_sig_gamma_bin_12 = 1.07037 +/- 0.213545 (limited); p_ph_sig_gamma_bin_13 = 0.890724 +/- 0.195929 (limited); p_ph_sig_gamma_bin_14 = 0.947374 +/- 0.309135 (limited); p_ph_sig_gamma_bin_15 = 1.14132 +/- 0.81204 (limited); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Minimization -- p.d.f. provides expected number of events, including extended term in likelihood.; [#1] INFO:Minimization -- Including the following constraint terms in minimization: (hc_sigbkg); [#1] INFO:Minimization -- The global observables are not defined , normalize constraints with respect to the parameters (Abkg,Asig,p_ph_sig2_gamma_bin_0,p_ph_sig2_gamma_bin_1,p_ph_sig2_gamma_bin_10,p_ph_sig2_gamma_bin_11,p_ph_sig2_gamma_bin_12,p_ph_sig2_gamma_bin_13,p_ph_sig2_gamma_bin_14,p_ph_sig2_gamma_bin_15,p_ph_sig2_gamma_bin_16,p_ph_sig2_gamma_bin_17,p_ph_sig2_gamma_bin_18,p_ph_sig2_gamma_bin_19,p_ph_sig2_gamma_bin_2,p_ph_sig2_gamma_bin_20,p_ph_sig2_gamma_bin_21,p_ph_sig2_gamma_bin_22,p_ph_sig2_gamma_bin_23,p_ph_sig2_gamma_bin_24,p_ph_sig2_gamma_bin_3,p_ph_sig2_gamma_bin_4,p_ph_sig2_gamma_bin_5,p_ph_sig2_gamma_bin_6,p_ph_sig2_gamma_bin_7,p_ph_sig2_gamma_bin_8,p_ph_sig2_gamma_bin_9); [#1] INFO:Fitting -- RooAbsPdf::fitTo(model2) fixing ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf709__BarlowBeeston_8C.html:18678,optimiz,optimization,18678,doc/master/rf709__BarlowBeeston_8C.html,https://root.cern,https://root.cern/doc/master/rf709__BarlowBeeston_8C.html,2,['optimiz'],['optimization']
Performance,"n_Code=262657);  re-create a new tree (decision tree or search tree) from XML ;  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TMVA::BinaryTree; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  . Private Member Functions; Double_t SamplePurity (EventList eventSample);  calculates the purity S/(S+B) of a given event sample ;  . Private Attributes; Types::EAnalysisType fAnalysisType;  kClassification(=0=false) or kRegression(=1=true) ;  ; DataSetInfo * fDataSetInfo;  ; UInt_t fMaxDepth;  max depth ;  ; Double_t fMinLinCorrForFisher;  the minimum linear correlation between two variables demanded for use in fisher criterium in node splitting ;  ; Double_t fMinNodeSize;  min fraction of training events in node ;  ; Double_t fMinSepGain;  min number of separation gain to perform node splitting ;  ; Double_t fMinSize;  min number of events in node ;  ; TRandom3 * fMyTrandom;  random number generator for randomised trees ;  ; Int_t fNCuts;  number of grid point in variable cut scans ;  ; Int_t fNNodesBeforePruning;  remember this one (in case of pruning, it allows to monitor the before/after ;  ; Double_t fNodePurityLimit;  purity limit to decide whether a node is signal ;  ; UInt_t fNvars;  number of variables used to separate S and B ;  ; EPruneMethod fPruneMethod;  method used for pruning ;  ; Double_t fPruneStrength;  a parameter to set the ""amount"" of pruning..needs to be adjusted ;  ; Bool_t fRandomisedTree;  choose at each node splitting a random set of variables ;  ; RegressionVariance * fRegType;  the separation criteria used in Regression ;  ; SeparationBase * fSepType;  the separation criteria ;  ; UInt_t fSigClass;  class which is treated as signal when building the tree ;  ; Int_t fTreeID;  just an ID number given to the tree.. makes debugging easier as tree knows who he is. ;  ; Bool_t fUseExclusiveVars;  individual ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DecisionTree.html:10535,perform,perform,10535,doc/master/classTMVA_1_1DecisionTree.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DecisionTree.html,1,['perform'],['perform']
Performance,"n_t *option, TObjArray *arr)Definition TH2.cxx:814; TH2::QuantilesXTH1D * QuantilesX(Double_t prob=0.5, const char *name=""_qx"") constCompute the X distribution of quantiles in the other variable Y name is the name of the returned hist...Definition TH2.cxx:2505; TH2::SetShowProjectionYvirtual void SetShowProjectionY(Int_t nbins=1)When the mouse is moved in a pad containing a 2-d view of this histogram a second canvas shows the pr...Definition TH2.cxx:2650; TH2::FillRandomvoid FillRandom(const char *fname, Int_t ntimes=5000, TRandom *rng=nullptr) overrideFill histogram following distribution in function fname.Definition TH2.cxx:714; TH2::IsATClass * IsA() const overrideDefinition TH2.h:133; TH2::Resetvoid Reset(Option_t *option="""") overrideReset this histogram: contents, errors, etc.Definition TH2.cxx:2600; TH2::fScalefactorDouble_t fScalefactorScale factor.Definition TH2.h:33; TH2::DoProjectionvirtual TH1D * DoProjection(bool onX, const char *name, Int_t firstbin, Int_t lastbin, Option_t *option) constInternal (protected) method for performing projection on the X or Y axis called by ProjectionX or Pro...Definition TH2.cxx:2169; TH2::RebinXTH2 * RebinX(Int_t ngroup=2, const char *newname="""") overrideRebin only the X axis see Rebin2D.Definition TH2.cxx:1642; TH2::fTsumwy2Double_t fTsumwy2Total Sum of weight*Y*Y.Definition TH2.h:35; TH2::GetRandom2virtual void GetRandom2(Double_t &x, Double_t &y, TRandom *rng=nullptr)Return 2 random numbers along axis x and y distributed according to the cell-contents of this 2-D his...Definition TH2.cxx:1200; TH2::GetCovariancevirtual Double_t GetCovariance(Int_t axis1=1, Int_t axis2=2) constReturn covariance between axis1 and axis2.Definition TH2.cxx:1163; TH2::GetBinInt_t GetBin(Int_t binx, Int_t biny, Int_t binz=0) const overrideReturn Global bin number corresponding to binx,y,z.Definition TH2.cxx:1086; TH2::ProjectionXTH1D * ProjectionX(const char *name=""_px"", Int_t firstybin=0, Int_t lastybin=-1, Option_t *option="""") constProject a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH2_8cxx_source.html:189720,perform,performing,189720,doc/master/TH2_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html,1,['perform'],['performing']
Performance,"n_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0)MENU ; virtual Bool_tSetAlias(const char* aliasName, const char* aliasFormula); virtual voidSetAutoFlush(Long64_t autof = 30000000); virtual voidSetAutoSave(Long64_t autos = 300000000); virtual voidSetBasketSize(const char* bname, Int_t buffsize = 16000); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); Int_tSetBranchAddress(const char* bname, void** add, TBranch** ptr = 0); virtual Int_tSetBranchAddress(const char* bname, void* add, TClass* realClass, EDataType datatype, Bool_t isptr); virtual Int_tSetBranchAddress(const char* bname, void* add, TBranch** ptr, TClass* realClass, EDataType datatype, Bool_t isptr); virtual voidSetBranchStatus(const char* bname, Bool_t status = 1, UInt_t* found = 0); static voidSetBranchStyle(Int_t style = 1); virtual voidSetCacheEntryRange(Long64_t first, Long64_t last); virtual voidSetCacheLearnEntries(Int_t n = 10); virtual voidSetCacheSize(Long64_t cachesize = -1); virtual voidSetChainOffset(Long64_t offset = 0); virtual voidSetCircular(Long64_t maxEntries); virtual voidSetDebug(Int_t level = 1, Long64_t min = 0, Long64_t max = 9999999)MENU ; virtual voidSetDefaultEntryOffsetLen(Int_t newdefault, Bool_t updateExisting = kFALSE); virtual voidSetDirectory(TDirectory* dir); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual Long64_tSetEntries(Long64_t n = -1); virtual voidSetEntryList(TEntryList* list, Option_t* opt = """"); virtual voidSetEstimate(Long64_t nentries = 10000); virtual voidSetEventList(TEventList* list); virtual voidSetFileNumber(Int_t number = 0); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidTAttLine::SetLineAttributes()MENU ; virtual voidTAttLine::SetLineColor(Color_t lcolor); virtual voidTAttLine::SetLineStyle(Style_t lstyle); virtual voidTA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TTree.html:25212,cache,cachesize,25212,root/html530/TTree.html,https://root.cern,https://root.cern/root/html530/TTree.html,3,['cache'],['cachesize']
Performance,"nableImplicitMT (UInt_t numthreads=0);  Enable ROOT's implicit multi-threading for all objects and methods that provide an internal parallelisation mechanism. More...;  ; void EnableThreadSafety ();  Enables the global mutex to make ROOT thread safe/aware. More...;  ; static std::string::size_type FindEndSymbol (std::string &command);  ; template<typename T > ; EFromHumanReadableSize FromHumanReadableSize (ROOT::Internal::TStringView str, T &value);  ; template<typename T > ; EFromHumanReadableSize FromHumanReadableSize (std::string_view str, T &value);  Convert strings like the following into byte counts 5MB, 5 MB, 5M, 3.7GB, 123b, 456kB, 3.7GiB, 5MiB with some amount of forgiveness baked into the parsing. More...;  ; template<typename T > ; TClass * GetClass (const T *);  ; template<typename T > ; TClass * GetClass (const T **);  ; template<typename T > ; TClass * GetClass (const T *const *);  ; template<typename T > ; TClass * GetClass (T *);  ; template<typename T > ; TClass * GetClass (T **);  ; std::vector< std::unique_ptr< TClassRec > > & GetDelayedAddClass ();  ; std::vector< std::pair< const char *, const char * > > & GetDelayedAddClassAlternate ();  ; UInt_t GetImplicitMTPoolSize ();  Returns the size of the pool used for implicit multi-threading. More...;  ; TString & GetMacroPath ();  ; TROOT * GetROOT ();  ; void GetRuleIncludes (std::list< std::string > &result);  Get the list of includes specified in the shema rules. More...;  ; UInt_t GetThreadPoolSize ();  Returns the size of ROOT's thread pool. More...;  ; bool HasValidDataMembers (SchemaRuleMap_t &rule, MembersTypeMap_t &members, std::string &error_string);  Check if given rule contains references to valid data members. More...;  ; Bool_t IsImplicitMTEnabled ();  Returns true if the implicit multi-threading in ROOT is enabled. More...;  ; template<class T > ; TSeq< T > MakeSeq (T begin, T end, T step=1);  ; template<class T > ; TSeq< T > MakeSeq (T end);  ; bool ParseRule (std::string command, ROOT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v622/namespaceROOT.html:8751,multi-thread,multi-threading,8751,doc/v622/namespaceROOT.html,https://root.cern,https://root.cern/doc/v622/namespaceROOT.html,1,['multi-thread'],['multi-threading']
Performance,"nableImplicitMT (UInt_t numthreads=0);  Enable ROOT's implicit multi-threading for all objects and methods that provide an internal parallelisation mechanism. More...;  ; void EnableThreadSafety ();  Enables the global mutex to make ROOT thread safe/aware. More...;  ; static std::string::size_type FindEndSymbol (std::string &command);  ; template<typename T > ; EFromHumanReadableSize FromHumanReadableSize (ROOT::Internal::TStringView str, T &value);  ; template<typename T > ; EFromHumanReadableSize FromHumanReadableSize (std::string_view str, T &value);  Convert strings like the following into byte counts 5MB, 5 MB, 5M, 3.7GB, 123b, 456kB, 3.7GiB, 5MiB with some amount of forgiveness baked into the parsing. More...;  ; template<typename T > ; TClass * GetClass (const T *);  ; template<typename T > ; TClass * GetClass (const T **);  ; template<typename T > ; TClass * GetClass (const T *const *);  ; template<typename T > ; TClass * GetClass (T *);  ; template<typename T > ; TClass * GetClass (T **);  ; std::vector< std::unique_ptr< TClassRec > > & GetDelayedAddClass ();  ; std::vector< std::pair< const char *, const char * > > & GetDelayedAddClassAlternate ();  ; UInt_t GetImplicitMTPoolSize ();  Returns the size of the pool used for implicit multi-threading. More...;  ; TString & GetMacroPath ();  ; TROOT * GetROOT ();  ; void GetRuleIncludes (std::list< std::string > &result);  Get the list of includes specified in the shema rules. More...;  ; bool HasValidDataMembers (SchemaRuleMap_t &rule, MembersTypeMap_t &members, std::string &error_string);  Check if given rule contains references to valid data members. More...;  ; Bool_t IsImplicitMTEnabled ();  Returns true if the implicit multi-threading in ROOT is enabled. More...;  ; template<class T > ; TSeq< T > MakeSeq (T begin, T end, T step=1);  ; template<class T > ; TSeq< T > MakeSeq (T end);  ; bool ParseRule (std::string command, ROOT::Internal::MembersMap_t &result, std::string &error_string);  Parse the schema ru",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v618/namespaceROOT.html:8477,multi-thread,multi-threading,8477,doc/v618/namespaceROOT.html,https://root.cern,https://root.cern/doc/v618/namespaceROOT.html,2,['multi-thread'],['multi-threading']
Performance,"nagerRooAbsPdf::_normMgrThe cache manager; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction2Ref<double,int,int>funcFunction pointer reference; RooRealProxyxArgument reference; RooRealProxyyArgument reference.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooCFunction2PdfBinding_double_int_int_.html:38847,cache,cache,38847,root/html526/RooCFunction2PdfBinding_double_int_int_.html,https://root.cern,https://root.cern/root/html526/RooCFunction2PdfBinding_double_int_int_.html,2,['cache'],['cache']
Performance,"nagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; RooListProxy_x; Double_t_z; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooMultiVarGaussian.html:43545,cache,cache,43545,root/html534/RooMultiVarGaussian.html,https://root.cern,https://root.cern/root/html534/RooMultiVarGaussian.html,2,['cache'],['cache']
Performance,"nal generator; # is used and an accept/reject sampling on the efficiency is applied.; data = modelEff.generate({t}, 10000); ; # Fit pdf. The normalization integral is calculated numerically.; modelEff.fitTo(data, PrintLevel=-1); ; # Plot generated data and overlay fitted pdf; frame3 = t.frame(Title=""Fitted pdf with efficiency""); data.plotOn(frame3); modelEff.plotOn(frame3); ; c = ROOT.TCanvas(""rf703_effpdfprod"", ""rf703_effpdfprod"", 1200, 400); c.Divide(3); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); frame1.GetYaxis().SetTitleOffset(1.4); frame1.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0.15); frame2.GetYaxis().SetTitleOffset(1.6); frame2.Draw(); c.cd(3); ROOT.gPad.SetLeftMargin(0.15); frame3.GetYaxis().SetTitleOffset(1.6); frame3.Draw(); ; c.SaveAs(""rf703_effpdfprod.png""); [#1] INFO:NumericIntegration -- RooRealIntegral::init(modelEff_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Fitting -- RooAbsPdf::fitTo(modelEff_over_modelEff_Int[t]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_modelEff_over_modelEff_Int[t]_modelEffData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(modelEff_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(modelEff_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C++ version) ; Definition in file rf703_effpdfprod.py. tutorialsroofitrf703_effpdfprod.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf703__effpdfprod_8py.html:2898,optimiz,optimization,2898,doc/master/rf703__effpdfprod_8py.html,https://root.cern,https://root.cern/doc/master/rf703__effpdfprod_8py.html,2,['optimiz'],['optimization']
Performance,"nal with single parameter. ;  ; template<typename... T> ; void EmitVA (const char *signal_name, Int_t, const T &... params);  Emit a signal with a varying number of arguments. ;  ; TList * GetListOfClassSignals () const;  Returns pointer to list of signals of this class. ;  ; TList * GetListOfConnections () const;  ; TList * GetListOfSignals () const;  ; virtual Bool_t HasConnection (const char *signal_name) const;  Return true if there is any object connected to this signal. ;  ; virtual void HighPriority (const char *signal_name, const char *slot_name=nullptr);  ; virtual void LowPriority (const char *signal_name, const char *slot_name=nullptr);  ; virtual void Message (const char *msg);  ; virtual Int_t NumberOfConnections () const;  Return number of connections for this object. ;  ; virtual Int_t NumberOfSignals () const;  Return number of signals for this object. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  . Static Public Member Functions; static void LoadLib ();  Dummy static function, used to load plugin. ;  ;  Static Public Member Functions inherited from TGCompositeFrame; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TGFrame; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static const TGGC & GetBckgndGC ();  Get background color graphics context. ;  ; static const TGGC & GetBlackGC ();  Get black graphics context. ;  ; static Pixel_t GetBlackPixel ();  Get black pixel value. ;  ; static Pixel_t GetDefaultFrameBackground ();  Get default frame background. ;  ; static Pixel_t GetDefaultSelectedBackground ();  Get default selected frame background. ;  ; static const TGGC & GetHilightGC ();  Get highlight color graphics context. ;  ; static const TGGC & GetShadowGC ();  Get shado",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoManagerEditor.html:27112,load,load,27112,doc/master/classTGeoManagerEditor.html,https://root.cern,https://root.cern/doc/master/classTGeoManagerEditor.html,1,['load'],['load']
Performance,"nal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); Int_tEnablePackage(const char* package, Bool_t notOnClient = kFALSE, TList* workers = 0); Int_tEnablePackage(const char* package, const char* loadopts, Bool_t notOnClient = kFALSE, TList* workers = 0); Int_tEnablePackage(const char* package, TList* loadopts, Bool_t notOnClient = kFALSE, TList* workers = 0); virtual voidTObject::Error(const char* method, const char* msgfmt) const; Int_tExec(const char* cmd, Bool_t plusMaster = kFALSE); Int_tExec(const char* cmd, const char* ord, Bool_t logtomacro = kFALSE); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual Bool_tExistsDataSet(const char* dataset); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidFeedback(TList* objs)SIGNAL ; virtual voidTNamed::FillBuffer(char*& buffer); Long64_tFinalize(Int_t query = -1, Bool_t force = kFALSE); Long64_tFinalize(const char* queryref, Bool_t force = kFALSE); TList*FindDataSets(const char* searchString, const char* optStr = """"); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProof.html:5732,load,loadopts,5732,root/html602/TProof.html,https://root.cern,https://root.cern/root/html602/TProof.html,4,['load'],['loadopts']
Performance,"nal[Place holder for Mutex Lock] Provide the interpreter with a way to acquire a lock used to protect cr...Definition TCling.cxx:7536; TCling::SetErrorMessagesBool_t SetErrorMessages(Bool_t enable=kTRUE) finalIf error messages are disabled, the interpreter should suppress its failures and warning messages fro...Definition TCling.cxx:7356; TCling::CallFunc_FactoryMethodMethodInfo_t * CallFunc_FactoryMethod(CallFunc_t *func) const finalDefinition TCling.cxx:7924; TCling::IsUnsignedIntegerTypebool IsUnsignedIntegerType(const void *QualTypePtr) constDefinition TCling.cxx:9563; TCling::TypedefInfo_FactoryCopyTypedefInfo_t * TypedefInfo_FactoryCopy(TypedefInfo_t *tinfo) const finalDefinition TCling.cxx:9465; TCling::GetFunctionOverloadsvoid GetFunctionOverloads(ClassInfo_t *cl, const char *funcname, std::vector< DeclId_t > &res) const finalInsert overloads of name in cl to res.Definition TCling.cxx:5048; TCling::UnRegisterTClassUpdatevoid UnRegisterTClassUpdate(const TClass *oldcl) finalIf the dictionary is loaded, we can remove the class from the list (otherwise the class might be load...Definition TCling.cxx:2393; TCling::MethodArgInfo_TypeNormalizedNamestd::string MethodArgInfo_TypeNormalizedName(MethodArgInfo_t *marginfo) const finalDefinition TCling.cxx:9320; TCling::GetEnumDeclId_t GetEnum(TClass *cl, const char *name) const finalReturn pointer to cling Decl of global/static variable that is located at the address given by addr.Definition TCling.cxx:4832; TCling::MethodArgInfo_PropertyLong_t MethodArgInfo_Property(MethodArgInfo_t *marginfo) const finalDefinition TCling.cxx:9288; TCling::TypedefInfo_Sizeint TypedefInfo_Size(TypedefInfo_t *tinfo) const finalDefinition TCling.cxx:9506; TCling::CallFunc_ExecWithArgsAndReturnvoid CallFunc_ExecWithArgsAndReturn(CallFunc_t *func, void *address, const void *args[]=nullptr, int nargs=0, void *ret=nullptr) const finalDefinition TCling.cxx:7874; TCling::GetInterpreterTypeNamevoid GetInterpreterTypeName(const char *name, std::s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:435344,load,loaded,435344,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,4,['load'],"['load', 'loaded']"
Performance,"nals; TList*TProof::fSlaveslist of all slave servers as in config file; TList*TProof::fTerminatedSlaveInfoslist of unique infos of terminated slaves; TStringTNamed::fTitleobject title; Long64_tTProof::fTotalBytesnumber of bytes to be analyzed; TUrlTProof::fUrlUrl of the master; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static TSemaphore*TProof::fgSemaphoresemaphore to control no of parallel startup threads. private:. TStringfCacheDirDirectory containing cache of user files; TProofLockPath*fCacheLockCache dir locker; TStringfDataSetDirDirectory containing info about known data sets; TDataSetManager*fDataSetManagerDataset manager; TDataSetManagerFile*fDataSetStgRepoDataset manager for staging requests; Int_tfDynamicStartupNMaxDyn Startup simulation: max number of workers; Int_tfDynamicStartupStepDyn Startup simulation: increment at each call; Bool_tfForkStartupStartup N-1 workers forking the first worker; Int_tfNWorkersNumber of workers; TQueryResultManager*fQMgrQuery-result manager; TStringfQueryDirDirectory containing query results and status; TProofLockPath*fQueryLockQuery dir locker; TPMERegexp*fReInvalidRegular expression matching invalid dataset URIs; TStringfSandboxPROOF sandbox root dir; TStringfSelectionInternal variable to pass drawing options; TServerSocket*fServSockServer socket to accept call backs; TStringfSockPathUNIX socket path for communication with workers; TStringfVarExpInternal variable to pass drawing options; static Int_tfgWrksMaxMax number of workers. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofLite(const char* masterurl, const char* conffile = kPROOF_ConfFile, const char* confdir = kPROOF_ConfDir, Int_t loglevel = 0, const char* alias = 0, TProofMgr* mgr = 0); Create a PROOF environment. Starting PROOF involves either connecting; to a master server, which in turn will start a set of slave servers, or; directly starting as master server (if master = """"",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofLite.html:26681,cache,cache,26681,root/html534/TProofLite.html,https://root.cern,https://root.cern/root/html534/TProofLite.html,2,['cache'],['cache']
Performance,"nalysis may require multiple separate RDataFrame computation graphs to produce all desired results. This poses the challenge that the; 933event loops of each computation graph can be parallelized, but the different loops run sequentially, one after the other.; 934On many-core architectures it might be desirable to run different event loops concurrently to improve resource usage.; 935ROOT::RDF::RunGraphs() allows running multiple RDataFrame event loops concurrently:; 936~~~{.cpp}; 937ROOT::EnableImplicitMT();; 938ROOT::RDataFrame df1(""tree1"", ""f1.root"");; 939ROOT::RDataFrame df2(""tree2"", ""f2.root"");; 940auto histo1 = df1.Histo1D(""x"");; 941auto histo2 = df2.Histo1D(""y"");; 942 ; 943// just accessing result pointers, the event loops of separate RDataFrames run one after the other; 944histo1->Draw(); // runs first multi-thread event loop; 945histo2->Draw(); // runs second multi-thread event loop; 946 ; 947// alternatively, with ROOT::RDF::RunGraphs, event loops for separate computation graphs can run concurrently; 948ROOT::RDF::RunGraphs({histo1, histo2});; 949histo1->Draw(); // results can then be used as usual; 950~~~; 951 ; 952### Performance considerations; 953 ; 954To obtain the maximum performance out of RDataFrame, make sure to avoid just-in-time compiled versions of transformations and actions if at all possible.; 955For instance, `Filter(""x > 0"")` requires just-in-time compilation of the corresponding C++ logic, while the equivalent `Filter([](float x) { return x > 0.; }, {""x""})` does not.; 956Similarly, `Histo1D(""x"")` requires just-in-time compilation after the type of `x` is retrieved from the dataset, while `Histo1D<float>(""x"")` does not; the latter spelling; 957should be preferred for performance-critical applications.; 958 ; 959Python applications cannot easily specify template parameters or pass C++ callables to RDataFrame.; 960See [Efficient analysis in Python](#python) for possible ways to speed up hot paths in this case.; 961 ; 962Just-in-time compilatio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RDataFrame_8cxx_source.html:54243,multi-thread,multi-thread,54243,doc/v632/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/RDataFrame_8cxx_source.html,4,"['concurren', 'multi-thread', 'perform']","['concurrently', 'multi-thread', 'performance']"
Performance,"nalysis may require multiple separate RDataFrame computation graphs to produce all desired results. This poses the challenge that the; 973event loops of each computation graph can be parallelized, but the different loops run sequentially, one after the other.; 974On many-core architectures it might be desirable to run different event loops concurrently to improve resource usage.; 975ROOT::RDF::RunGraphs() allows running multiple RDataFrame event loops concurrently:; 976~~~{.cpp}; 977ROOT::EnableImplicitMT();; 978ROOT::RDataFrame df1(""tree1"", ""f1.root"");; 979ROOT::RDataFrame df2(""tree2"", ""f2.root"");; 980auto histo1 = df1.Histo1D(""x"");; 981auto histo2 = df2.Histo1D(""y"");; 982 ; 983// just accessing result pointers, the event loops of separate RDataFrames run one after the other; 984histo1->Draw(); // runs first multi-thread event loop; 985histo2->Draw(); // runs second multi-thread event loop; 986 ; 987// alternatively, with ROOT::RDF::RunGraphs, event loops for separate computation graphs can run concurrently; 988ROOT::RDF::RunGraphs({histo1, histo2});; 989histo1->Draw(); // results can then be used as usual; 990~~~; 991 ; 992### Performance considerations; 993 ; 994To obtain the maximum performance out of RDataFrame, make sure to avoid just-in-time compiled versions of transformations and actions if at all possible.; 995For instance, `Filter(""x > 0"")` requires just-in-time compilation of the corresponding C++ logic, while the equivalent `Filter([](float x) { return x > 0.; }, {""x""})` does not.; 996Similarly, `Histo1D(""x"")` requires just-in-time compilation after the type of `x` is retrieved from the dataset, while `Histo1D<float>(""x"")` does not; the latter spelling; 997should be preferred for performance-critical applications.; 998 ; 999Python applications cannot easily specify template parameters or pass C++ callables to RDataFrame.; 1000See [Efficient analysis in Python](#python) for possible ways to speed up hot paths in this case.; 1001 ; 1002Just-in-time compila",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDataFrame_8cxx_source.html:55883,multi-thread,multi-thread,55883,doc/master/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RDataFrame_8cxx_source.html,4,"['concurren', 'multi-thread', 'perform']","['concurrently', 'multi-thread', 'performance']"
Performance,"nalysis. Double_t ComputeIntegral(); Compute integral (cumulative sum of bins); The result stored in fIntegral is used by the GetRandom functions.; This function is automatically called by GetRandom when the fIntegral; array does not exist or when the number of entries in the histogram; has changed since the previous call to GetRandom.; The resulting integral is normalized to 1. Double_t * GetIntegral(); Return a pointer to the array of bins integral.; if the pointer fIntegral is null, TH1::ComputeIntegral is called; The array dimension is the number of bins in the histograms; including underflow and overflow (fNCells); the last value integral[fNCells] is set to the number of entries of; the histogram. void Copy(TObject& hnew) const; -*-*-*-*-*Copy this histogram structure to newth1*-*-*-*-*-*-*-*-*-*-*-*. Note that this function does not copy the list of associated functions.; Use TObject::Clone to make a full copy of an histogram. void DirectoryAutoAdd(TDirectory* ); Perform the automatic addition of the histogram to the given directory. Note this function is called in place when the semantic requires; this object to be added to a directory (I.e. when being read from; a TKey or being Cloned). Int_t DistancetoPrimitive(Int_t px, Int_t py); -*-*-*-*-*-*-*-*-*Compute distance from point px,py to a line*-*-*-*-*-*. Compute the closest distance of approach from point px,py to elements; of an histogram.; The distance is computed in pixels units. Algorithm:; Currently, this simple model computes the distance from the mouse; to the histogram contour only. -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*. void Divide(TF1* f1, Double_t c1 = 1); Performs the operation: this = this/(c1*f1); if errors are defined (see TH1::Sumw2), errors are also recalculated. Only bins inside the function range are recomputed.; IMPORTANT NOTE: If you intend to use the errors of this histogram later; you should call Sumw2 before making this operation.; This is particularly",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TH1.html:58297,Perform,Perform,58297,root/html532/TH1.html,https://root.cern,https://root.cern/root/html532/TH1.html,1,['Perform'],['Perform']
Performance,"name = 0); Copy constructor. Initializes in clean state so that upon eval; this instance will create its own server processes. ~RooRealMPFE(); Destructor. void initVars(); Initialize list of variables of front-end argument 'arg'. void initialize(); Initialize the remote process and message passing; pipes between current process and remote process. void serverLoop(); Server loop of remote processes. This function will return; only when an incoming TERMINATE message is received. void calculate() const; Client-side function that instructs server process to start; asynchronuous (re)calculation of function value. This function; returns immediately. The calculated value can be retrieved; using getVal(). Double_t getVal(const RooArgSet* nset = 0) const; If value needs recalculation and calculation has not beed started; with a call to calculate() start it now. This function blocks; until remote process has finished calculation and returns; remote value. Double_t evaluate() const; Send message to server process to retrieve output value; If error were logged use logEvalError() on remote side; transfer those errors to the local eval error queue. void standby(); Terminate remote server process and return front-end class; to standby mode. Calls to calculate() or evaluate() after; this call will automatically recreated the server process. void constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); Intercept call to optimize constant term in test statistics; and forward it to object on server side. void setVerbose(Bool_t clientFlag = kTRUE, Bool_t serverFlag = kTRUE); Control verbose messaging related to inter process communication; on both client and server side. TObject* clone(const char* newname) const; { return new RooRealMPFE(*this,newname); }. » Last changed: Mon Jul 4 15:23:51 2011 » Last generated: 2011-07-04 15:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooRealMPFE.html:36112,queue,queue,36112,root/html530/RooRealMPFE.html,https://root.cern,https://root.cern/root/html530/RooRealMPFE.html,2,"['optimiz', 'queue']","['optimize', 'queue']"
Performance,"name = 0); Copy constructor. Initializes in clean state so that upon eval; this instance will create its own server processes. ~RooRealMPFE(); Destructor. void initVars(); Initialize list of variables of front-end argument 'arg'. void initialize(); Initialize the remote process and message passing; pipes between current process and remote process. void serverLoop(); Server loop of remote processes. This function will return; only when an incoming TERMINATE message is received. void calculate() const; Client-side function that instructs server process to start; asynchronuous (re)calculation of function value. This function; returns immediately. The calculated value can be retrieved; using getVal(). Double_t getVal(const RooArgSet* nset = 0) const; If value needs recalculation and calculation has not beed started; with a call to calculate() start it now. This function blocks; until remote process has finished calculation and returns; remote value. Double_t evaluate() const; Send message to server process to retrieve output value; If error were logged use logEvalError() on remote side; transfer those errors to the local eval error queue. void standby(); Terminate remote server process and return front-end class; to standby mode. Calls to calculate() or evaluate() after; this call will automatically recreated the server process. void constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); Intercept call to optimize constant term in test statistics; and forward it to object on server side. void setVerbose(Bool_t clientFlag = kTRUE, Bool_t serverFlag = kTRUE); Control verbose messaging related to inter process communication; on both client and server side. TObject* clone(const char* newname) const; { return new RooRealMPFE(*this,newname); }. » Last changed: Tue Dec 8 17:03:19 2009 » Last generated: 2009-12-08 17:03; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooRealMPFE.html:35332,queue,queue,35332,root/html526/RooRealMPFE.html,https://root.cern,https://root.cern/root/html526/RooRealMPFE.html,2,"['optimiz', 'queue']","['optimize', 'queue']"
Performance,"name = 0); Load a file into the editor. If fname is 0, a TGFileDialog will popup. void SaveFile(const char* fname); Save the edited text in the file ""fname"". Bool_t SaveFileAs(); Save the edited text in a file selected with TGFileDialog.; Shouldn't we create a backup file?. Int_t IsSaved(); Check if file has to be saved in case of modifications. void PrintText(); Open the print dialog and send current buffer to printer. void CloseWindow(); Close TGTextEditor window. Bool_t HandleKey(Event_t* event); Keyboard event handler. void ClearText(); Clear text edit widget. void Search(Bool_t ret); Invokes search dialog, or just search previous string if again is true. void Goto(); Invokes goto dialog, and go to the specified line. void CompileMacro(); Save the edited text in a temporary macro, then compile it. void ExecuteMacro(); Save the edited text in a temporary macro, execute it, and then delete; the temporary file. void InterruptMacro(); Interrupt execution of a macro. void About(); Display ROOT splash screen. Bool_t HandleTimer(TTimer* t); Handle timer event. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Handle menu and other command generated by the user. Bool_t LoadBuffer(const char* buf); { return fTextEdit->LoadBuffer(buf); }. void DataChanged(); { fTextChanged = kTRUE; }. void SetText(TGText* text); { fTextEdit->SetText(text); }. void AddText(TGText* text); { fTextEdit->AddText(text); }. void AddLine(const char* string); { fTextEdit->AddLine(string); }. void AddLineFast(const char* string); { fTextEdit->AddLineFast(string); }. TGText * GetText() const; { return fTextEdit->GetText(); }. » Author: Bertrand Bellenot 20/06/06 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TGTextEditor.h 23115 2008-04-10 13:35:37Z rdm $ » Last generated: 2011-12-02 14:27; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGTextEditor.html:28928,Load,LoadBuffer,28928,root/html532/TGTextEditor.html,https://root.cern,https://root.cern/root/html532/TGTextEditor.html,2,['Load'],['LoadBuffer']
Performance,"name = 0); Load a file into the editor. If fname is 0, a TGFileDialog will popup. void SaveFile(const char* fname); Save the edited text in the file ""fname"". Bool_t SaveFileAs(); Save the edited text in a file selected with TGFileDialog.; Shouldn't we create a backup file?. Int_t IsSaved(); Check if file has to be saved in case of modifications. void PrintText(); Open the print dialog and send current buffer to printer. void CloseWindow(); Close TGTextEditor window. Bool_t HandleKey(Event_t* event); Keyboard event handler. void ClearText(); Clear text edit widget. void Search(Bool_t ret); Invokes search dialog, or just search previous string if again is true. void Goto(); Invokes goto dialog, and go to the specified line. void CompileMacro(); Save the edited text in a temporary macro, then compile it. void ExecuteMacro(); Save the edited text in a temporary macro, execute it, and then delete; the temporary file. void InterruptMacro(); Interrupt execution of a macro. void About(); Display ROOT splash screen. Bool_t HandleTimer(TTimer* t); Handle timer event. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Handle menu and other command generated by the user. TGTextEditor(const char* filename = 0, const TGWindow* p = 0, UInt_t w = 900, UInt_t h = 600). Bool_t LoadBuffer(const char* buf); { return fTextEdit->LoadBuffer(buf); }. void SetText(TGText* text); { fTextEdit->SetText(text); }. void AddText(TGText* text); { fTextEdit->AddText(text); }. void AddLine(const char* string); { fTextEdit->AddLine(string); }. void AddLineFast(const char* string); { fTextEdit->AddLineFast(string); }. TGText * GetText() const; { return fTextEdit->GetText(); }. » Author: Bertrand Bellenot 20/06/06 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ » Last generated: 2015-06-02 15:57; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGTextEditor.html:30024,Load,LoadBuffer,30024,root/html604/TGTextEditor.html,https://root.cern,https://root.cern/root/html604/TGTextEditor.html,2,['Load'],['LoadBuffer']
Performance,"name = 0); Load a file into the editor. If fname is 0, a TGFileDialog will popup. void SaveFile(const char* fname); Save the edited text in the file ""fname"". Bool_t SaveFileAs(); Save the edited text in a file selected with TGFileDialog.; Shouldn't we create a backup file?. Int_t IsSaved(); Check if file has to be saved in case of modifications. void PrintText(); Open the print dialog and send current buffer to printer. void CloseWindow(); Close TGTextEditor window. Bool_t HandleKey(Event_t* event); Keyboard event handler. void ClearText(); Clear text edit widget. void Search(Bool_t ret); Invokes search dialog, or just search previous string if again is true. void Goto(); Invokes goto dialog, and go to the specified line. void CompileMacro(); Save the edited text in a temporary macro, then compile it. void ExecuteMacro(); Save the edited text in a temporary macro, execute it, and then delete; the temporary file. void InterruptMacro(); Interrupt execution of a macro. void About(); Display ROOT splash screen. Bool_t HandleTimer(TTimer* t); Handle timer event. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Handle menu and other command generated by the user. TGTextEditor(const char* filename = 0, const TGWindow* p = 0, UInt_t w = 900, UInt_t h = 600). Bool_t LoadBuffer(const char* buf); { return fTextEdit->LoadBuffer(buf); }. void SetText(TGText* text); { fTextEdit->SetText(text); }. void AddText(TGText* text); { fTextEdit->AddText(text); }. void AddLine(const char* string); { fTextEdit->AddLine(string); }. void AddLineFast(const char* string); { fTextEdit->AddLineFast(string); }. TGText * GetText() const; { return fTextEdit->GetText(); }. » Author: Bertrand Bellenot 20/06/06 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ » Last generated: 2015-06-30 14:58; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGTextEditor.html:30024,Load,LoadBuffer,30024,root/html602/TGTextEditor.html,https://root.cern,https://root.cern/root/html602/TGTextEditor.html,2,['Load'],['LoadBuffer']
Performance,"name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. TStreamerInfoActions::TStreamerInfoAction_tfAction; TStreamerInfoActions::TConfiguration*fConfiguration; TStreamerInfoActions::TStreamerInfoLoopAction_tfLoopAction; TStreamerInfoActions::TStreamerInfoVecPtrLoopAction_tfVecPtrLoopAction. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void PrintDebug(TBuffer& buffer, void* object) const. TConfiguredAction(); {}. TConfiguredAction(const TStreamerInfoActions::TConfiguredAction& rval); Technically this is a move constructor ... TConfiguredAction(TStreamerInfoActions::TStreamerInfoLoopAction_t action, TStreamerInfoActions::TConfiguration* conf); Usual constructor. ~TConfiguredAction(); Usual destructor.; Idea: the configuration ownership might be moved to a single list so that; we can shared them between the optimized and non-optimized list of actions. Int_t operator()(TBuffer& buffer, void* object) const. Int_t operator()(TBuffer& buffer, void* start_collection, const void* end_collection) const. Int_t operator()(TBuffer& buffer, void* start_collection, const void* end_collection, const TStreamerInfoActions::TLoopConfiguration* loopconf) const. » Author: Philippe Canal 05/2010 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/io:$Id: TStreamerInfoActions.h 36169 2010-10-07 16:06:18Z pcanal $ » Last generated: 2010-10-07 22:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TStreamerInfoActions__TConfiguredAction.html:6555,optimiz,optimized,6555,root/html528/TStreamerInfoActions__TConfiguredAction.html,https://root.cern,https://root.cern/root/html528/TStreamerInfoActions__TConfiguredAction.html,2,['optimiz'],['optimized']
Performance,"name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. TStreamerInfoActions::TStreamerInfoAction_tfAction; TStreamerInfoActions::TConfiguration*fConfiguration; TStreamerInfoActions::TStreamerInfoLoopAction_tfLoopAction; TStreamerInfoActions::TStreamerInfoVecPtrLoopAction_tfVecPtrLoopAction. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void PrintDebug(TBuffer& buffer, void* object) const. TConfiguredAction(); {}. TConfiguredAction(const TStreamerInfoActions::TConfiguredAction& rval); Technically this is a move constructor ... TConfiguredAction(TStreamerInfoActions::TStreamerInfoLoopAction_t action, TStreamerInfoActions::TConfiguration* conf); Usual constructor. ~TConfiguredAction(); Usual destructor.; Idea: the configuration ownership might be moved to a single list so that; we can shared them between the optimized and non-optimized list of actions. Int_t operator()(TBuffer& buffer, void* object) const. Int_t operator()(TBuffer& buffer, void* start_collection, const void* end_collection) const. Int_t operator()(TBuffer& buffer, void* start_collection, const void* end_collection, const TStreamerInfoActions::TLoopConfiguration* loopconf) const. » Author: Philippe Canal 05/2010 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/io:$Id: TStreamerInfoActions.h 36169 2010-10-07 16:06:18Z pcanal $ » Last generated: 2011-07-04 15:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TStreamerInfoActions__TConfiguredAction.html:6626,optimiz,optimized,6626,root/html530/TStreamerInfoActions__TConfiguredAction.html,https://root.cern,https://root.cern/root/html530/TStreamerInfoActions__TConfiguredAction.html,2,['optimiz'],['optimized']
Performance,"name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. TStreamerInfoActions::TStreamerInfoAction_tfAction; TStreamerInfoActions::TConfiguration*fConfiguration; TStreamerInfoActions::TStreamerInfoLoopAction_tfLoopAction; TStreamerInfoActions::TStreamerInfoVecPtrLoopAction_tfVecPtrLoopAction. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void PrintDebug(TBuffer& buffer, void* object) const. TConfiguredAction(); {}. TConfiguredAction(const TStreamerInfoActions::TConfiguredAction& rval); Technically this is a move constructor ... TConfiguredAction(TStreamerInfoActions::TStreamerInfoLoopAction_t action, TStreamerInfoActions::TConfiguration* conf); Usual constructor. ~TConfiguredAction(); Usual destructor.; Idea: the configuration ownership might be moved to a single list so that; we can shared them between the optimized and non-optimized list of actions. Int_t operator()(TBuffer& buffer, void* object) const. Int_t operator()(TBuffer& buffer, void* start_collection, const void* end_collection) const. Int_t operator()(TBuffer& buffer, void* start_collection, const void* end_collection, const TStreamerInfoActions::TLoopConfiguration* loopconf) const. » Author: Philippe Canal 05/2010 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/io:$Id: TStreamerInfoActions.h 40872 2011-09-13 21:33:33Z pcanal $ » Last generated: 2011-11-03 20:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TStreamerInfoActions__TConfiguredAction.html:6626,optimiz,optimized,6626,root/html532/TStreamerInfoActions__TConfiguredAction.html,https://root.cern,https://root.cern/root/html532/TStreamerInfoActions__TConfiguredAction.html,4,['optimiz'],['optimized']
Performance,"name DataSource = void> . RInterface< RLoopManager > ROOT::RDF::RInterface< Proxied, DataSource >::Cache ; (; std::initializer_list< std::string > ; columnList). inline . Save selected columns in memory. ; Parameters. [in]columnListcolumns to be cached in memory. . Returnsa RDataFrame that wraps the cached dataset.; See the previous overloads for more information. ; Definition at line 1546 of file RInterface.hxx. ◆ Cache() [4/4]. template<typename Proxied , typename DataSource = void> . RInterface< RLoopManager > ROOT::RDF::RInterface< Proxied, DataSource >::Cache ; (; std::string_view ; columnNameRegexp = """"). inline . Save selected columns in memory. ; Parameters. [in]columnNameRegexpThe regular expression to match the column names to be selected. The presence of a '^' and a '$' at the end of the string is implicitly assumed if they are not specified. The dialect supported is PCRE via the TPRegexp class. An empty string signals the selection of all columns. . Returnsa RDataFrame that wraps the cached dataset.; The existing columns are matched against the regular expression. If the string provided is empty, all columns are selected. See the previous overloads for more information. ; Definition at line 1520 of file RInterface.hxx. ◆ CacheImpl(). template<typename Proxied , typename DataSource = void> . template<typename... ColTypes, std::size_t... S> . RInterface< RLoopManager > ROOT::RDF::RInterface< Proxied, DataSource >::CacheImpl ; (; const ColumnNames_t & ; columnList, . std::index_sequence< S... > ;  . ). inlineprivate . Implementation of cache. ; Definition at line 3200 of file RInterface.hxx. ◆ CallCreateActionWithoutColsIfPossible() [1/2]. template<typename Proxied , typename DataSource = void> . template<typename Helper , typename ActionResultType , typename... Others> . RResultPtr< ActionResultType > ROOT::RDF::RInterface< Proxied, DataSource >::CallCreateActionWithoutColsIfPossible ; (; const std::shared_ptr< ActionResultType > & ; , . const std::shared_p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html:44879,cache,cached,44879,doc/master/classROOT_1_1RDF_1_1RInterface.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html,1,['cache'],['cached']
Performance,"name DeepNet_t = TDeepNet<Architecture_t, Layer_t>> . std::vector<std::vector<Matrix_t> > TMVA::DNN::TRMSProp< Architecture_t, Layer_t, DeepNet_t >::fPastSquaredBiasGradients. protected . The sum of the square of the past bias gradients associated with the deep net. ; Definition at line 57 of file RMSProp.h. ◆ fPastSquaredWeightGradients. template<typename Architecture_t , typename Layer_t = VGeneralLayer<Architecture_t>, typename DeepNet_t = TDeepNet<Architecture_t, Layer_t>> . std::vector<std::vector<Matrix_t> > TMVA::DNN::TRMSProp< Architecture_t, Layer_t, DeepNet_t >::fPastSquaredWeightGradients. protected . The sum of the square of the past weight gradients associated with the deep net. ; Definition at line 55 of file RMSProp.h. ◆ fRho. template<typename Architecture_t , typename Layer_t = VGeneralLayer<Architecture_t>, typename DeepNet_t = TDeepNet<Architecture_t, Layer_t>> . Scalar_t TMVA::DNN::TRMSProp< Architecture_t, Layer_t, DeepNet_t >::fRho. protected . The Rho constant used by the optimizer. ; Definition at line 52 of file RMSProp.h. ◆ fWeightUpdates. template<typename Architecture_t , typename Layer_t = VGeneralLayer<Architecture_t>, typename DeepNet_t = TDeepNet<Architecture_t, Layer_t>> . std::vector<std::vector<Matrix_t> > TMVA::DNN::TRMSProp< Architecture_t, Layer_t, DeepNet_t >::fWeightUpdates. protected . The accumulation of the past Weights for performing updates. ; Definition at line 59 of file RMSProp.h. ◆ fWorkBiasTensor1. template<typename Architecture_t , typename Layer_t = VGeneralLayer<Architecture_t>, typename DeepNet_t = TDeepNet<Architecture_t, Layer_t>> . std::vector<std::vector<Matrix_t> > TMVA::DNN::TRMSProp< Architecture_t, Layer_t, DeepNet_t >::fWorkBiasTensor1. protected . working tensor used to keep a temporary copy of bias or bias gradients ; Definition at line 64 of file RMSProp.h. ◆ fWorkBiasTensor2. template<typename Architecture_t , typename Layer_t = VGeneralLayer<Architecture_t>, typename DeepNet_t = TDeepNet<Architectur",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TRMSProp.html:12952,optimiz,optimizer,12952,doc/master/classTMVA_1_1DNN_1_1TRMSProp.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TRMSProp.html,1,['optimiz'],['optimizer']
Performance,"name for RooArgSet that specifies a particular hypothesis; TStringTNamed::fTitleobject title; stringfWSNamename of the WS. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void GuessObsAndNuisance(const RooAbsData& data); Makes sensible guesses of observables, parameters of interest; and nuisance parameters. Defaults:; observables: determined from data,; global observables = explicit obs - obs from data; parameters of interest: empty,; nuisance parameters: all parameters except parameters of interest. We use NULL to mean not set, so we don't want to fill; with empty RooArgSets. void Print(Option_t* option = """") const; print contents. void SetWS(RooWorkspace& ws); set a workspace that owns all the necessary components for the analysis. RooWorkspace * GetWS() const; get from TRef. void SetSnapshot(const RooArgSet& set); save snaphot in the workspace; and use values passed with the set. const RooArgSet * GetSnapshot() const; Load the snapshot from ws and return the corresponding set with the snapshot values.; User must delete returned RooArgSet. void LoadSnapshot() const; load the snapshot from ws if it exists. void DefineSetInWS(const char* name, const RooArgSet& set); helper functions to avoid code duplication. void ImportPdfInWS(const RooAbsPdf& pdf); internal function to import Pdf in WS. void ImportDataInWS(RooAbsData& data); internal function to import data in WS. ModelConfig(RooWorkspace* ws = 0). ModelConfig(const char* name, RooWorkspace* ws = 0). ModelConfig(const char* name, const char* title, RooWorkspace* ws = 0). ModelConfig * Clone(const char* name = """") const; clone. void SetWorkspace(RooWorkspace& ws); alias for SetWS(...). { SetWS(ws); }. void SetProtoData(RooAbsData& data); Set the proto DataSet, add to the the workspace if not already there. SetProtoData(const char* name). void SetPdf(const RooAbsPdf& pdf); Set the Pdf, add to the the workspace if not already there. SetPdf(const char* name). void SetPriorPdf",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooStats__ModelConfig.html:8855,Load,Load,8855,root/html532/RooStats__ModelConfig.html,https://root.cern,https://root.cern/root/html532/RooStats__ModelConfig.html,1,['Load'],['Load']
Performance,"name for a particle having a given pdg. ;  ; void SetPhiRange (Double_t phimin=0., Double_t phimax=360.);  Set cut phi range. ;  ; void SetRTmode (Int_t mode);  Change raytracing mode. ;  ; void SetStartSafe (Bool_t flag=kTRUE);  ; void SetStep (Double_t step);  ; void SetTminTmax (Double_t tmin=0, Double_t tmax=999);  Set time cut interval for drawing tracks. ;  ; void SetTopVisible (Bool_t vis=kTRUE);  make top volume visible on screen ;  ; void SetTopVolume (TGeoVolume *vol);  Set the top volume and corresponding node as starting point of the geometry. ;  ; void SetUseParallelWorldNav (Bool_t flag);  Activate/deactivate usage of parallel world navigation. ;  ; void SetUserPaintVolume (TGeoVolume *vol);  ; void SetVisDensity (Double_t dens=0.01);  Set density threshold. ;  ; void SetVisibility (TObject *obj, Bool_t vis);  Set visibility for a volume. ;  ; void SetVisLevel (Int_t level=3);  set default level down to which visualization is performed ;  ; void SetVisOption (Int_t option=0);  set drawing mode : ;  ; void SetVolumeAttribute (const char *name, const char *att, Int_t val);  Set volume attributes in G3 style. ;  ; virtual ULong_t SizeOf (const TGeoNode *node, Option_t *option);  computes the total size in bytes of the branch starting with node. ;  ; void SortOverlaps ();  Sort overlaps by decreasing overlap distance. Extrusions comes first. ;  ; TGeoNode * Step (Bool_t is_geom=kTRUE, Bool_t cross=kTRUE);  Make a rectilinear step of length fStep from current point (fPoint) on current direction (fDirection). ;  ; void Streamer (TBuffer &) override;  Stream an object of class TGeoManager. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void Test (Int_t npoints=1000000, Option_t *option="""");  Check time of finding ""Where am I"" for n points. ;  ; void TestOverlaps (const char *path="""");  Geometry overlap checker based on sampling. ;  ; void TopToMaster (const Double_t *top, Double_t *master) const;  Convert coordinates from top volume fram",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoManager.html:49089,perform,performed,49089,doc/master/classTGeoManager.html,https://root.cern,https://root.cern/doc/master/classTGeoManager.html,1,['perform'],['performed']
Performance,"name of object. ;  ; virtual void printExtras (std::ostream &os) const;  Interface to print extras of object. ;  ; virtual void printStream (std::ostream &os, Int_t contents, StyleOption style, TString indent="""") const;  Print description of object on ostream, printing contents set by contents integer, which is interpreted as an OR of 'enum ContentsOptions' values and in the style given by 'enum StyleOption'. ;  ; virtual void printTree (std::ostream &os, TString indent="""") const;  Interface for tree structure printing of object. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from RooDirItem;  RooDirItem ();  ;  RooDirItem (const RooDirItem &);  ; virtual ~RooDirItem ();  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static RooFitResult * lastMinuitFit (const RooArgList &varList=RooArgList());  Import the results of the last fit performed by gMinuit, interpreting the fit parameters as the given varList of parameters. ;  ; static RooFitResult * prefitResult (const RooArgList &paramList);  Import the results of the last fit performed by gMinuit, interpreting the fit parameters as the given varList of parameters. ;  ;  Static Public Member Functions inherited from TNamed; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set d",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooFitResult.html:16266,perform,performed,16266,doc/master/classRooFitResult.html,https://root.cern,https://root.cern/doc/master/classRooFitResult.html,1,['perform'],['performed']
Performance,"name of the defined column. ; [in]expressionFunction, lambda expression, functor class or any other callable object producing the defined value. Returns the value that will be assigned to the defined column. ; [in]columnsNames of the columns/branches in input to the producer function (excluding the slot number). . Returnsthe first node of the computation graph for which the new quantity is defined.; This alternative implementation of Define is meant as a helper to evaluate new column values in a thread-safe manner. The expression must be a callable of signature R(unsigned int, T1, T2, ...) where T1, T2... are the types of the columns that the expression takes as input. The first parameter is reserved for an unsigned integer representing a ""slot number"". RDataFrame guarantees that different threads will invoke the expression with different slot numbers - slot numbers will range from zero to ROOT::GetThreadPoolSize()-1.; The following two calls are equivalent, although DefineSlot is slightly more performant: int function(unsigned int, double, double);; df.Define(""x"", function, {""rdfslot_"", ""column1"", ""column2""}); df.DefineSlot(""x"", function, {""column1"", ""column2""}); See Define() for more information. ; Definition at line 470 of file RInterface.hxx. ◆ DefineSlotEntry(). template<typename Proxied , typename DataSource = void> . template<typename F > . RInterface< Proxied, DS_t > ROOT::RDF::RInterface< Proxied, DataSource >::DefineSlotEntry ; (; std::string_view ; name, . F ; expression, . const ColumnNames_t & ; columns = {} . ). inline . Define a new column with a value dependent on the processing slot and the current entry. ; Parameters. [in]nameThe name of the defined column. ; [in]expressionFunction, lambda expression, functor class or any other callable object producing the defined value. Returns the value that will be assigned to the defined column. ; [in]columnsNames of the columns/branches in input to the producer function (excluding slot and entry). . Returnsthe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html:59079,perform,performant,59079,doc/master/classROOT_1_1RDF_1_1RInterface.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html,1,['perform'],['performant']
Performance,"name) constTClass; GetDeclFileLine() constTClassinline; GetDeclFileName() constTClass; GetDeclIdMap()TClassprivatestatic; GetDelete() constTClass; GetDeleteArray() constTClass; GetDestructor() constTClass; GetDict(const char *cname)TClassstatic; GetDict(const std::type_info &info)TClassstatic; GetDictionary(const char *name)TDictionarystatic; GetDictionary(const std::type_info &typeinfo)TDictionarystatic; GetDirectoryAutoAdd() constTClass; GetDrawOption() constTObjectvirtual; GetDtorOnly()TObjectstatic; GetFunctionTemplate(const char *name)TClass; GetHeapInstanceCount() constTClassinline; GetIconName() constTObjectvirtual; GetIdMap()TClassprivatestatic; GetImplFileLine() constTClassinline; GetImplFileName() constTClassinline; GetInstanceCount() constTClassinline; GetIsAProxy() constTClass; GetLastReadInfo() constTClassinline; GetListOfAllPublicDataMembers(Bool_t load=kTRUE)TClass; GetListOfAllPublicMethods(Bool_t load=kTRUE)TClass; GetListOfBases()TClass; GetListOfDataMembers(Bool_t load=kTRUE)TClass; GetListOfEnums(Bool_t load=kTRUE)TClass; GetListOfFunctionTemplates(Bool_t load=kTRUE)TClass; GetListOfMethodOverloads(const char *name) constTClass; GetListOfMethods(Bool_t load=kTRUE)TClass; GetListOfRealData() constTClassinline; GetListOfUsingDataMembers(Bool_t load=kTRUE)TClass; GetMenuItems(TList *listitems)TClass; GetMenuList() constTClass; GetMerge() constTClass; GetMethod(const char *method, const char *params, Bool_t objectIsConst=kFALSE)TClass; GetMethodAllAny(const char *method)TClass; GetMethodAny(const char *method)TClass; GetMethodList()TClassprivate; GetMethodWithPrototype(const char *method, const char *proto, Bool_t objectIsConst=kFALSE, ROOT::EFunctionMatchMode mode=ROOT::kConversionMatch)TClass; GetMissingDictionaries(THashTable &result, bool recurse=false)TClass; GetMissingDictionariesForBaseClasses(TCollection &result, TCollection &visited, bool recurse)TClassprotected; GetMissingDictionariesForMembers(TCollection &result, TCollection &visited, bool",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClass-members.html:9429,load,load,9429,doc/master/classTClass-members.html,https://root.cern,https://root.cern/doc/master/classTClass-members.html,1,['load'],['load']
Performance,"name);; selector->CallSomeFunction(..);; mytree.Process(selector,..);; filenameOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char filenameDefinition TGWin32VirtualXProxy.cxx:232; TSelector::Processvirtual bool Process(Long64_t)The Process() function is called for each entry in the tree (or possibly keyed object in the case of ...Definition TSelector.cxx:360; TSelector::GetSelectorstatic TSelector * GetSelector(const char *filename)The code in filename is loaded (interpreted or compiled, see below), filename must contain a valid cl...Definition TSelector.cxx:142; ; NOTE 2; One should not call this function twice with the same selector file in the same script. If this is required, proceed as indicated in NOTE1, by getting a pointer to the corresponding TSelector,eg . workaround 1; void stubs1() {; TSelector *selector = TSelector::GetSelector(""h1test.C"");; TFile *f1 = new TFile(""stubs_nood_le1.root"");; TTree *h1 = (TTree*)f1->Get(""h1"");; h1->Process(selector);; TFile *f2 = new TFile(""stubs_nood_le1_coarse.root"");; TTree *h2 = (TTree*)f2->Get(""h1"");; h2->Process(selector);; }; TDirectoryFile::GetTObject * Get(const char *namecycle) overrideReturn pointer to object identified by namecycle.Definition TDirectoryFile.cxx:937; TSelectorA TSelector object is used by the TTree::Draw, TTree::Scan, TTree::Process to navigate in a TTree and...Definition TSelector.h:31; h1TH1F * h1Definition legend1.C:5; f1TF1 * f1Definition legend1.C:1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreePlayer.html:41776,load,loaded,41776,doc/master/classTTreePlayer.html,https://root.cern,https://root.cern/doc/master/classTTreePlayer.html,1,['load'],['loaded']
Performance,"name);; selector->CallSomeFunction(..);; mytree.Process(selector,..);; filenameOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char filenameDefinition TGWin32VirtualXProxy.cxx:232; TSelector::Processvirtual bool Process(Long64_t)The Process() function is called for each entry in the tree (or possibly keyed object in the case of ...Definition TSelector.cxx:360; TSelector::GetSelectorstatic TSelector * GetSelector(const char *filename)The code in filename is loaded (interpreted or compiled, see below), filename must contain a valid cl...Definition TSelector.cxx:142; ; NOTE2; One should not call this function twice with the same selector file in the same script. If this is required, proceed as indicated in NOTE1, by getting a pointer to the corresponding TSelector,eg. Workaround 1; void stubs1() {; TSelector *selector = TSelector::GetSelector(""h1test.C"");; TFile *f1 = new TFile(""stubs_nood_le1.root"");; TTree *h1 = (TTree*)f1->Get(""h1"");; h1->Process(selector);; TFile *f2 = new TFile(""stubs_nood_le1_coarse.root"");; TTree *h2 = (TTree*)f2->Get(""h1"");; h2->Process(selector);; }; TDirectoryFile::GetTObject * Get(const char *namecycle) overrideReturn pointer to object identified by namecycle.Definition TDirectoryFile.cxx:937; TSelectorA TSelector object is used by the TTree::Draw, TTree::Scan, TTree::Process to navigate in a TTree and...Definition TSelector.h:31; h1TH1F * h1Definition legend1.C:5; f1TF1 * f1Definition legend1.C:11;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTree.html:189626,load,loaded,189626,doc/v632/classTTree.html,https://root.cern,https://root.cern/doc/v632/classTTree.html,2,['load'],['loaded']
Performance,"name, const char* proto = 0, Bool_t load = kFALSE); virtual const char*TObject::GetIconName() const; TInterpreter*GetInterpreter() const; virtual TKey*TDirectory::GetKey(const char*, Short_t = 9999) const; virtual TList*TDirectory::GetList() const; TList*GetListOfBrowsables() const; TSeqCollection*GetListOfBrowsers() const; TSeqCollection*GetListOfCanvases() const; TCollection*GetListOfClasses() const; TCollection*GetListOfClassGenerators() const; TSeqCollection*GetListOfCleanups() const; TSeqCollection*GetListOfClosedObjects() const; TSeqCollection*GetListOfColors() const; TSeqCollection*GetListOfDataSets() const; TCollection*GetListOfEnums(Bool_t load = kFALSE); TSeqCollection*GetListOfFiles() const; TCollection*GetListOfFunctionOverloads(const char* name) const; TCollection*GetListOfFunctions() const; TCollection*GetListOfFunctionTemplates(); TSeqCollection*GetListOfGeometries() const; TCollection*GetListOfGlobalFunctions(Bool_t load = kFALSE); TCollection*GetListOfGlobals(Bool_t load = kFALSE); virtual TList*TDirectory::GetListOfKeys() const; TSeqCollection*GetListOfMappedFiles() const; TSeqCollection*GetListOfMessageHandlers() const; TSeqCollection*GetListOfProofs() const; TSeqCollection*GetListOfSecContexts() const; TSeqCollection*GetListOfSockets() const; TSeqCollection*GetListOfSpecials() const; TSeqCollection*GetListOfStreamerInfo() const; TSeqCollection*GetListOfStyles() const; TSeqCollection*GetListOfTasks() const; TCollection*GetListOfTypes(Bool_t load = kFALSE); static const char*GetMacroPath(); virtual TObject*TDirectory::GetMother() const; virtual TDirectory*TDirectory::GetMotherDir() const; virtual const char*TNamed::GetName() const; virtual Int_tTDirectory::GetNbytesKeys() const; Int_tGetNclasses() const; virtual Int_tTDirectory::GetNkeys() const; Int_tGetNtypes() const; virtual void*TDirectory::GetObjectChecked(const char* namecycle, const char* classname); virtual void*TDirectory::GetObjectChecked(const char* namecycle, const TClass* cl); virtual c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TROOT.html:7371,load,load,7371,root/html602/TROOT.html,https://root.cern,https://root.cern/root/html602/TROOT.html,4,['load'],['load']
Performance,"name, const char* title); RooCategory(const RooCategory& other, const char* name = 0); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidRooAbsCategoryLValue::setBin(Int_t ibin, const char* rangeName = 0); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); voidRooAbsCategoryLValue::setConstant(Bool_t value = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); virtual Bool_tsetIndex(Int_t index, Bool_t printError = kTRUE); virtual Bool_tsetLabel(const char* label, Bool_t printError = kTRUE); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidsetRange(const char* rangeName, const char* stateNameList); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCategory.html:15743,cache,cache,15743,root/html602/RooCategory.html,https://root.cern,https://root.cern/root/html602/RooCategory.html,4,['cache'],['cache']
Performance,"name, const char* title, const RooArgList& sumSet, Bool_t takeOwnerShip = kFALSE). RooAddition(const char* name, const char* title, const RooArgList& sumSet1, const RooArgList& sumSet2, Bool_t takeOwnerShip = kFALSE). RooAddition(const RooAddition& other, const char* name = 0). ~RooAddition(). Double_t evaluate() const; Calculate and return current value of self. Double_t defaultErrorLevel() const; Return the default error level for MINUIT error analysis; If the addition contains one or more RooNLLVars and; no RooChi2Vars, return the defaultErrorLevel() of; RooNLLVar. If the addition contains one ore more RooChi2Vars; and no RooNLLVars, return the defaultErrorLevel() of; RooChi2Var. If the addition contains neither or both; issue a warning message and return a value of 1. void enableOffsetting(Bool_t ). Bool_t setData(RooAbsData& data, Bool_t cloneData = kTRUE). void printMetaArgs(ostream& os) const. Int_t getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& numVars, const char* rangeName = 0) const. Double_t analyticalIntegral(Int_t code, const char* rangeName = 0) const; Calculate integral internally from appropriate integral cache. std::list<Double_t>* binBoundaries(RooAbsRealLValue& , Double_t , Double_t ) const. Bool_t isBinnedDistribution(const RooArgSet& obs) const; If all components that depend on obs are binned that so is the product. std::list<Double_t>* plotSamplingHint(RooAbsRealLValue& , Double_t , Double_t ) const. TObject* clone(const char* newname) const; { return new RooAddition(*this, newname); }. const RooArgList& list1() const; { return _set ; }. const RooArgList& list() const; { return _set ; }. Bool_t forceAnalyticalInt(const RooAbsArg& ) const; Force RooRealIntegral to offer all observables for internal integration. » Last changed: Tue Jun 2 15:27:46 2015 » Last generated: 2015-06-02 15:27; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooAddition.html:38718,cache,cache,38718,root/html604/RooAddition.html,https://root.cern,https://root.cern/root/html604/RooAddition.html,2,['cache'],['cache']
Performance,"name; TObjArray*fMembersMembers in this archive. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TArchiveFile(const char* archive, const char* member, TFile* file); Specify the archive name and member name. The member can be a decimal; number which allows to access the n-th sub-file. This method is; normally only called via TFile. ~TArchiveFile(); Dtor. Long64_t GetMemberFilePosition() const; Return position in archive of current member. Int_t GetNumberOfMembers() const; Returns number of members in archive. Int_t SetMember(const char* member); Explicitely make the specified member the current member.; Returns -1 in case of error, 0 otherwise. Int_t SetMember(Int_t idx); Explicitely make the member with the specified index the current member.; Returns -1 in case of error, 0 otherwise. TArchiveFile * Open(const char* url, TFile* file); Return proper archive file handler depending on passed url.; The handler is loaded via the plugin manager and is triggered by; the extension of the archive file. In case no handler is found 0; is returned. The file argument is used to access the archive.; The archive should be specified as url with the member name as the; anchor, e.g. ""root://pcsalo.cern.ch/alice/event_1.zip#tpc.root"",; where tpc.root is the file in the archive to be opened.; Alternatively the sub-file can be specified via its index number,; e.g. ""root://pcsalo.cern.ch/alice/event_1.zip#3"".; This function is normally only called via TFile::Open(). Bool_t ParseUrl(const char* url, TString& archive, TString& member, TString& type); Try to determine if url contains an anchor specifying an archive member.; Returns kFALSE in case of an error. TArchiveFile(const TArchiveFile& ). TArchiveFile& operator=(const TArchiveFile& ). TArchiveFile(); { }. Int_t OpenArchive(). Int_t SetCurrentMember(). TArchiveMember * GetMember() const; { return fCurMember; }. TObjArray * GetMembers() const; { return fMembers; }. const char * GetArchiveName()",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TArchiveFile.html:7596,load,loaded,7596,root/html602/TArchiveFile.html,https://root.cern,https://root.cern/root/html602/TArchiveFile.html,4,['load'],['loaded']
Performance,"nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_tRooResolutionModel::_ownBasisFlag indicating ownership of _basis ; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooArgSet_ownedComps! Owned components; TIterator*_pdfIter! Iterator over PDF list; RooListProxy_pdfListList of component PDFs; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooObjCacheManager_projCacheMgrManager of cache with coefficient projections and transformations; Bool_t_projectCoefsIf true coefficients need to be projected for use in evaluate(); TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; RooSetProxy_refCoefNorm! Reference observable set for coefficient interpretation; TNamed*_refCoefRangeName! Reference range name for coefficient interpreation; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooArgList*_snormList! List of supplemental normalization factors; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAddModel.html:41372,cache,cache,41372,root/html528/RooAddModel.html,https://root.cern,https://root.cern/root/html528/RooAddModel.html,1,['cache'],['cache']
Performance,nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_tRooResolutionModel::_ownBasisFlag indicating ownership of _basis ; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooArgSet_ownedComps! Owned components; TIterator*_pdfIter! Iterator over PDF list; RooListProxy_pdfListList of component PDFs; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooObjCacheManager_projCacheMgrManager of cache with coefficient projections and transformations; Bool_t_projectCoefsIf true coefficients need to be projected for use in evaluate(); TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; RooSetProxy_refCoefNorm! Reference observable set for coefficient interpretation; TNamed*_refCoefRangeName! Reference range name for coefficient interpreation; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooArgList*_snormList! List of supplemental normalization factors; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfig,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooAddModel.html:41649,cache,cache,41649,root/html530/RooAddModel.html,https://root.cern,https://root.cern/root/html530/RooAddModel.html,1,['cache'],['cache']
Performance,nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_tRooResolutionModel::_ownBasisFlag indicating ownership of _basis ; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooArgSet_ownedComps! Owned components; TIterator*_pdfIter! Iterator over PDF list; RooListProxy_pdfListList of component PDFs; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooObjCacheManager_projCacheMgrManager of cache with coefficient projections and transformations; Bool_t_projectCoefsIf true coefficients need to be projected for use in evaluate(); TRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; RooSetProxy_refCoefNorm! Reference observable set for coefficient interpretation; TNamed*_refCoefRangeName! Reference range name for coefficient interpreation; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooArgList*_snormList! List of supplemental normalization factors; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorCo,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAddModel.html:42052,cache,cache,42052,root/html532/RooAddModel.html,https://root.cern,https://root.cern/root/html532/RooAddModel.html,1,['cache'],['cache']
Performance,"named 'cutRange' ; Definition at line 860 of file RooAbsData.cxx. ◆ namePtr(). const TNamed * RooAbsData::namePtr ; (; ); const. inline . De-duplicated pointer to this object's name. ; This can be used for fast name comparisons. like if (namePtr() == other.namePtr()). NoteTNamed::GetName() will return a pointer that's different for each object, but namePtr() always points to a unique instance. ; Definition at line 297 of file RooAbsData.h. ◆ numEntries(). Int_t RooAbsData::numEntries ; (; ); const. virtual . Return number of entries in dataset, i.e., count unweighted entries. ; Definition at line 323 of file RooAbsData.cxx. ◆ operator=(). RooAbsData & RooAbsData::operator= ; (; const RooAbsData & ; other). Definition at line 255 of file RooAbsData.cxx. ◆ optimizeReadingWithCaching(). void RooAbsData::optimizeReadingWithCaching ; (; RooAbsArg & ; arg, . const RooArgSet & ; cacheList, . const RooArgSet & ; keepObsList . ). protectedvirtual . Prepare dataset for use with cached constant terms listed in 'cacheList' of expression 'arg'. ; Deactivate tree branches for any dataset observable that is either not used at all, or is used exclusively by cached branch nodes. ; Definition at line 2262 of file RooAbsData.cxx. ◆ plotAsymOn(). RooPlot * RooAbsData::plotAsymOn ; (; RooPlot * ; frame, . const RooAbsCategoryLValue & ; asymCat, . PlotOpt ; o . ); const. protectedvirtual . Create and fill a histogram with the asymmetry N[+] - N[-] / ( N[+] + N[-] ), where N(+/-) is the number of data points with asymCat=+1 and asymCat=-1 as function of the frames variable. ; The asymmetry category 'asymCat' must have exactly 2 (or 3) states defined with index values +1,-1 (and 0); The plot range and the number of plot bins is determined by the parameters of the plot variable of the frame (RooAbsReal::setPlotRange(), RooAbsReal::setPlotBins()); The optional cut string expression can be used to select the events to be plotted. The cut specification may refer to any variable contained in th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsData.html:52818,cache,cached,52818,doc/master/classRooAbsData.html,https://root.cern,https://root.cern/doc/master/classRooAbsData.html,2,['cache'],"['cacheList', 'cached']"
Performance,"named; RooAbsArg::OperMode_operModeDirty state propagation mode; RooArgSet*_ownedComponents! Set of owned component; Bool_t_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArray_proxyListlist of proxies; RooRefCountList_serverListlist of server objects; Bool_t_shapeDirtyFlag set if value needs recalculating because input shapes modified; map<std::string,std::string>_stringAttribString attributes; Bool_t_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_t_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t inhibitDirty() const; { return _inhibitDirty && !_localNoInhibitDirty; }. ~RooAbsArg(); Destructor. void setDirtyInhibit(Bool_t flag); Control global dirty inhibit mode. When set to true no value or shape dirty; flags are propagated and cache is always considered to be dirty. void verboseDirty(Bool_t flag); Activate verbose messaging related to dirty flag propagation. Bool_t isCloneOf(const RooAbsArg& other) const; Check if this object was created as a clone of 'other'. void setAttribute(const Text_t* name, Bool_t value = kTRUE); Set (default) or clear a named boolean attribute of this object. Bool_t getAttribute(const Text_t* name) const; Check if a named attribute is set. By default, all attributes are unset. void setStringAttribute(const Text_t* key, const Text_t* value); Associate string 'value' to this object under key 'key'. const Text_t* getStringAttribute(const Text_t* key) const; Get string attribute mapped under key 'key'. Returns null pointer; if no attribute exists under that key. void setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); Set (default) or clear a named boolean attribute of this object. Bool_t getTransientAttribute(const Text_t* name) const; Check if a named attribu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsArg.html:19330,cache,cache,19330,root/html534/RooAbsArg.html,https://root.cern,https://root.cern/root/html534/RooAbsArg.html,2,['cache'],['cache']
Performance,"names for each element in the path, first element either ""/"" or ""."" If returned array empty - it is error. ;  ; std::shared_ptr< Browsable::RElement > GetElement (const std::string &str);  Returns element with path, specified as string. ;  ; std::shared_ptr< Browsable::RElement > GetElementFromTop (const Browsable::RElementPath_t &path);  Returns element with path, specified as Browsable::RElementPath_t. ;  ; std::shared_ptr< Browsable::RElement > GetSubElement (const Browsable::RElementPath_t &path);  Returns sub-element starting from top, using cached data. ;  ; const Browsable::RElementPath_t & GetWorkingPath () const;  ; std::string ProcessRequest (const RBrowserRequest &request);  Process browser request, returns string with JSON of RBrowserReply data. ;  ; bool RemoveFromCache (const Browsable::RElementPath_t &path);  Remove path (and all sub-paths) from cache Returns true if any element was removed. ;  ; bool RemoveFromCache (void *obj);  Remove object from cache If nullptr specified - removes no-longer-valid elements Returns true if any element was removed. ;  ; void SetTopElement (std::shared_ptr< Browsable::RElement > elem);  set top element for browsing ;  ; void SetWorkingPath (const Browsable::RElementPath_t &path);  set working directory relative to top element ;  . Private Member Functions; bool ProcessBrowserRequest (const RBrowserRequest &request, RBrowserReply &reply);  Process browser request. ;  ; void ResetLastRequestData (bool with_element);  Reset all data correspondent to last request. ;  . Private Attributes; std::vector< std::pair< Browsable::RElementPath_t, std::shared_ptr< Browsable::RElement > > > fCache;  ! already requested elements ;  ; std::unique_ptr< TObject > fCleanupHandle;  ! cleanup handle for RecursiveRemove ;  ; bool fLastAllChilds {false};  ! if all chlds were extracted ;  ; std::shared_ptr< Browsable::RElement > fLastElement;  ! last element used in request ;  ; std::vector< std::unique_ptr< Browsable::RItem > > fLastItems;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RBrowserData.html:1861,cache,cache,1861,doc/v632/classROOT_1_1RBrowserData.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RBrowserData.html,2,['cache'],['cache']
Performance,"napsesarray of pointers to synapses, no structural data; boolTMVA::MethodANNBase::fUseRegulatorzjh; TRandom3*TMVA::MethodANNBase::frgenrandom number generator for various uses. private:. TMVA::MethodMLP::EBPTrainingModefBPModebackprop learning mode (sequential or batch); Int_tfBatchSizebatch size, only matters if in batch learning mode; TStringfBpModeSbackprop learning mode option string (sequential or batch); boolfCalculateErrorscompute inverse hessian matrix at the end of the training; Double_tfDecayRatedecay rate for above learning rate; Bool_tfEpochMoncreate and fill epoch-wise monitoring histograms (makes outputfile big!); Double_tfGA_SC_factorGA settings: SC_factor; Int_tfGA_SC_rateGA settings: SC_rate; Int_tfGA_SC_stepsGA settings: SC_steps; Int_tfGA_nstepsGA settings: number of steps; Int_tfGA_preCalcGA settings: number of pre-calc steps; Double_tfLastAlphaline search variable; Double_tfLearnRatelearning rate for synapse weight adjustments; Double_tfPriorzjh; vector<Double_t>fPriorDevzjh; Int_tfResetStepreset time (how often we clear hessian matrix); Float_tfSamplingEpochfraction of epochs where sampling is used; Float_tfSamplingFractionfraction of events which is sampled for training; Bool_tfSamplingTestingThe testing sample is sampled; Bool_tfSamplingTrainingThe training sample is sampled; Float_tfSamplingWeightchanging factor for event weights when sampling is turned on; Double_tfTauline search variable; Int_tfTestRatetest for overtraining performed at each #th epochs; TStringfTrainMethodStraining method option param; TMVA::MethodMLP::ETrainingMethodfTrainingMethodmethod of training, BP or GA; Int_tfUpdateLimitzjh; boolfUseRegulatorzjh; static const Bool_tfgPRINT_BATCHdebug flags; static const Int_tfgPRINT_ESTIMATOR_INCdebug flags; static const Bool_tfgPRINT_SEQdebug flags. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodMLP(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MethodMLP.html:21311,perform,performed,21311,root/html528/TMVA__MethodMLP.html,https://root.cern,https://root.cern/root/html528/TMVA__MethodMLP.html,1,['perform'],['performed']
Performance,"nary of drawables and callback functions: ; 868For more control, you can create a dictionary where keys are plots and values are corresponding (optional) callback functions. For example:; 869 ; 870~~~{.py}; 871plot_callback_dict = {; 872 graph: set_marker,; 873 h_exp: fit_exp,; 874 tprofile_2d: None; 875}; 876 ; 877LiveVisualize(plot_callback_dict); 878~~~; 879 ; 880- Passing a Dictionary of drawables and callback functions with a global callback function: ; 881You can also combine a dictionary of plots and callbacks with a global callback function:; 882 ; 883~~~{.py}; 884LiveVisualize(plot_callback_dict, write_to_tfile); 885~~~; 886 ; 887\note The allowed operations to pass to LiveVisualize are:; 888 - Histo1D(), Histo2D(), Histo3D(); 889 - Graph(); 890 - Profile1D(), Profile2D(); 891 ; 892\warning The Live Visualization feature is only supported for the Dask backend.; 893 ; 894\anchor parallel-execution; 895## Performance tips and parallel execution; 896As pointed out before in this document, RDataFrame can transparently perform multi-threaded event loops to speed up; 897the execution of its actions. Users have to call ROOT::EnableImplicitMT() *before* constructing the RDataFrame; 898object to indicate that it should take advantage of a pool of worker threads. **Each worker thread processes a distinct; 899subset of entries**, and their partial results are merged before returning the final values to the user.; 900There are no guarantees on the order in which threads will process the batches of entries.; 901In particular, note that this means that, for multi-thread event loops, there is no; 902guarantee on the order in which Snapshot() will _write_ entries: they could be scrambled with respect to the input dataset. The values of the special `rdfentry_` column will also not correspond to the entry numbers in the input dataset (e.g. TChain) in multi-thread runs.; 903 ; 904\warning By default, RDataFrame will use as many threads as the hardware supports, using up **all",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RDataFrame_8cxx_source.html:50148,perform,perform,50148,doc/v632/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/RDataFrame_8cxx_source.html,2,"['multi-thread', 'perform']","['multi-threaded', 'perform']"
Performance,"nary of drawables and callback functions: ; 908For more control, you can create a dictionary where keys are plots and values are corresponding (optional) callback functions. For example:; 909 ; 910~~~{.py}; 911plot_callback_dict = {; 912 graph: set_marker,; 913 h_exp: fit_exp,; 914 tprofile_2d: None; 915}; 916 ; 917LiveVisualize(plot_callback_dict); 918~~~; 919 ; 920- Passing a Dictionary of drawables and callback functions with a global callback function: ; 921You can also combine a dictionary of plots and callbacks with a global callback function:; 922 ; 923~~~{.py}; 924LiveVisualize(plot_callback_dict, write_to_tfile); 925~~~; 926 ; 927\note The allowed operations to pass to LiveVisualize are:; 928 - Histo1D(), Histo2D(), Histo3D(); 929 - Graph(); 930 - Profile1D(), Profile2D(); 931 ; 932\warning The Live Visualization feature is only supported for the Dask backend.; 933 ; 934\anchor parallel-execution; 935## Performance tips and parallel execution; 936As pointed out before in this document, RDataFrame can transparently perform multi-threaded event loops to speed up; 937the execution of its actions. Users have to call ROOT::EnableImplicitMT() *before* constructing the RDataFrame; 938object to indicate that it should take advantage of a pool of worker threads. **Each worker thread processes a distinct; 939subset of entries**, and their partial results are merged before returning the final values to the user.; 940There are no guarantees on the order in which threads will process the batches of entries.; 941In particular, note that this means that, for multi-thread event loops, there is no; 942guarantee on the order in which Snapshot() will _write_ entries: they could be scrambled with respect to the input dataset. The values of the special `rdfentry_` column will also not correspond to the entry numbers in the input dataset (e.g. TChain) in multi-thread runs.; 943 ; 944\warning By default, RDataFrame will use as many threads as the hardware supports, using up **all",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDataFrame_8cxx_source.html:51788,perform,perform,51788,doc/master/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RDataFrame_8cxx_source.html,2,"['multi-thread', 'perform']","['multi-threaded', 'perform']"
Performance,"nary*TDictionary::GetDictionary(const type_info& typeinfo); ROOT::DirAutoAdd_tTClass::GetDirectoryAutoAdd() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TFunctionTemplate*TClass::GetFunctionTemplate(const char* name); UInt_tTClass::GetHeapInstanceCount() const; virtual const char*TObject::GetIconName() const; Short_tTClass::GetImplFileLine() const; const char*TClass::GetImplFileName() const; UInt_tTClass::GetInstanceCount() const; TVirtualIsAProxy*TClass::GetIsAProxy() const; TVirtualStreamerInfo*TClass::GetLastReadInfo() const; TList*TClass::GetListOfAllPublicDataMembers(Bool_t load = kTRUE); const TList*TClass::GetListOfAllPublicMethods(Bool_t load = kTRUE); TList*TClass::GetListOfBases(); TList*TQObject::GetListOfClassSignals() const; TList*TQObject::GetListOfConnections() const; TList*TClass::GetListOfDataMembers(Bool_t load = kTRUE); TList*TClass::GetListOfEnums(Bool_t load = kTRUE); TList*TClass::GetListOfFunctionTemplates(Bool_t load = kTRUE); TCollection*TClass::GetListOfMethodOverloads(const char* name) const; TList*TClass::GetListOfMethods(Bool_t load = kTRUE); TList*TClass::GetListOfRealData() const; TList*TQObject::GetListOfSignals() const; voidTClass::GetMenuItems(TList* listitems); TList*TClass::GetMenuList() const; ROOT::MergeFunc_tTClass::GetMerge() const; TMethod*TClass::GetMethod(const char* method, const char* params, Bool_t objectIsConst = kFALSE); TMethod*TClass::GetMethodAllAny(const char* method); TMethod*TClass::GetMethodAny(const char* method); TMethod*TClass::GetMethodWithPrototype(const char* method, const char* proto, Bool_t objectIsConst = kFALSE, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch); voidTClass::GetMissingDictionaries(THashTable& result, bool recurse = false); virtual const char*TNamed::GetName() const; Int_tTClass::GetNdata(); ROOT::NewFunc_tTClass::GetNew() const; ROOT::NewArrFunc_tTClass::GetNewArray() const; Int_tTClass::GetNmethods(); virtual char*TObject::GetObjectI",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TQClass.html:10110,load,load,10110,root/html602/TQClass.html,https://root.cern,https://root.cern/root/html602/TQClass.html,4,['load'],['load']
Performance,"nary::CreateAttributeMap(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TDictAttributeMap*TDictionary::GetAttributeMap() const; TClass*GetClassPointer(Bool_t load = kTRUE); Int_tGetDelta() const; static TDictionary*TDictionary::GetDictionary(const char* name); static TDictionary*TDictionary::GetDictionary(const type_info& typeinfo); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsE",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TBaseClass.html:2102,load,load,2102,root/html534/TBaseClass.html,https://root.cern,https://root.cern/root/html534/TBaseClass.html,2,['load'],['load']
Performance,"nary::CreateAttributeMap(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TDictAttributeMap*TDictionary::GetAttributeMap() const; TClass*GetClassPointer(Bool_t load = kTRUE); Int_tGetDelta(); static TDictionary*TDictionary::GetDictionary(const char* name); static TDictionary*TDictionary::GetDictionary(const type_info& typeinfo); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TBaseClass.html:2048,load,load,2048,root/html602/TBaseClass.html,https://root.cern,https://root.cern/root/html602/TBaseClass.html,4,['load'],['load']
Performance,"natoms);; void AddElement(Double_t a, Double_t z, Double_t weight). iel: index of the element[0,nel-1]; a and z: the atomic mass and charge; weight: proportion by mass of the elements; natoms: number of atoms of the element in the molecule making the mixture. The radiation length is automatically computed when all elements are defined. Since tracking MC provide several other ways to create materials/mixtures, the materials classes are likely to evolve as the interfaces to these engines are being developed. Generally in the process of tracking material properties are not enough and more specific media properties have to be defined. These highly depend on the MC performing tracking and sometimes allow the definition of different media properties (e.g. energy or range cuts) for the same material.; 18.2.2 Radionuclides; A new class TGeoElementRN was introduced in this version to provide support for radioactive nuclides and their decays. A database of 3162 radionuclides can be loaded on demand via the table of elements (TGeoElementTable class). One can make then materials/mixtures based on these radionuclides and use them in a geometry; root[] TGeoManager *geom = new TGeoManager(""geom"",""radionuclides"");; root[] TGeoElementTable *table = geom->GetElementTable();; root[] TGeoElementRN *c14 = table->GetElementRN(14,6); // A,Z; root[] c14->Print();; 6-C-014 ENDF=60140; A=14; Z=6; Iso=0; Level=0[MeV]; Dmass=3.0199[MeV];; Hlife=1.81e+11[s] J/P=0+; Abund=0; Htox=5.8e-10; Itox=5.8e-10; Stat=0; Decay modes:; BetaMinus Diso: 0 BR: 100.000% Qval: 0.1565; One can make materials or mixtures from radionuclides:; root[] TGeoMaterial *mat = new TGeoMaterial(""C14"", c14, 2.0);; The following properties of radionuclides can be currently accessed via getters in the TGeoElementRN class:; Atomic number and charge (from the base class TGeoElement). Isomeric number (ISO); ENDF code - following the convention: ENDF=10000*Z+100*A+ISO; Isomeric energy level [MeV]; Mass excess [MeV]; Half life [s]; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:891434,load,loaded,891434,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['load'],['loaded']
Performance,"nator components ; RooSetProxy_compSetNSet proxy for numerator components ; RooArgSet*_compSetOwnedDOwner of denominator components; RooArgSet*_compSetOwnedNOwner of numerator components ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; Bool_t_haveDDo we have a denominator term?; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; RooListProxy_intListMaster integrals representing numerator and denominator; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooGenProdProj.html:31508,cache,cache,31508,root/html526/RooGenProdProj.html,https://root.cern,https://root.cern/root/html526/RooGenProdProj.html,2,['cache'],['cache']
Performance,nator components ; RooSetProxy_compSetNSet proxy for numerator components ; RooArgSet*_compSetOwnedDOwner of denominator components; RooArgSet*_compSetOwnedNOwner of numerator components ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; Bool_t_haveDDo we have a denominator term?; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; RooListProxy_intListMaster integrals representing numerator and denominator; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration spec,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooGenProdProj.html:32254,cache,cache,32254,root/html530/RooGenProdProj.html,https://root.cern,https://root.cern/root/html530/RooGenProdProj.html,1,['cache'],['cache']
Performance,nator components ; RooSetProxy_compSetNSet proxy for numerator components ; RooArgSet*_compSetOwnedDOwner of denominator components; RooArgSet*_compSetOwnedNOwner of numerator components ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; Bool_t_haveDDo we have a denominator term?; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; RooListProxy_intListMaster integrals representing numerator and denominator; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooGenProdProj.html:32629,cache,cache,32629,root/html532/RooGenProdProj.html,https://root.cern,https://root.cern/root/html532/RooGenProdProj.html,2,['cache'],['cache']
Performance,"nc();; 1981 Int_t nd = hfit->GetDimension();; 1982 Int_t j;; 1983 Double_t *zik = GetZ();; 1984 Double_t *pl0 = GetPL0();; 1985 ; 1986 Double_t *df=new Double_t[npar];; 1987 ; 1988 npar = f1->GetNpar();; 1989 SetParNumber(npar);; 1990 if(flag == 9) {delete [] df; return;}; 1991 if (flag == 2) for (j=0;j<npar;j++) dersum[j] = gin[j] = 0;; 1992 f1->InitArgs(x,u);; 1993 f = 0;; 1994 ; 1995 Int_t npfit = 0;; 1996 Double_t *cache = fCache;; 1997 for (Int_t i=0;i<fNpoints;i++) {; 1998 if (nd > 2) x[2] = cache[4];; 1999 if (nd > 1) x[1] = cache[3];; 2000 x[0] = cache[2];; 2001 cu = cache[0];; 2002 TF1::RejectPoint(kFALSE);; 2003 if (nd < 2) {; 2004 fu = f1->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3])/cache[3];; 2005 } else if (nd < 3) {; 2006 fu = ((TF2*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5])/(cache[3]*cache[5]);; 2007 } else {; 2008 fu = ((TF3*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5],cache[6] - 0.5*cache[7],cache[6] + 0.5*cache[7])/(cache[3]*cache[5]*cache[7]);; 2009 }; 2010 if (TF1::RejectedPoint()) {cache += fPointSize; continue;}; 2011 if (flag == 2) {; 2012 for (j=0;j<npar;j++) {; 2013 dersum[j] += 1; //should be the derivative; 2014 //grad[j] += dersum[j]*(fu-cu)/eu; dersum[j] = 0;; 2015 }; 2016 }; 2017 if (fu < 1.e-9) fu = 1.e-9;; 2018 icu = Int_t(cu);; 2019 fsub = -fu +icu*TMath::Log(fu);; 2020 fobs = GetSumLog(icu);; 2021 fsub -= fobs;; 2022 Derivatives(df,x);; 2023 int n=0;; 2024 // Here we need gradients of Log likelihood function; 2025 //; 2026 for (j=0;j<npar;j++) {; 2027 if (pl0[j]>0){; 2028 df[n] = df[j]*(icu/fu-1);; 2029 gin[j] -= df[n];; 2030 n++;; 2031 }; 2032 }; 2033 Int_t l = 0;; 2034 // Z-matrix here - production of first derivatives; 2035 // of log-likelihood function; 2036 for (j=0;j<n;j++); 2037 for (Int_t k=0;k<=j;k++); 2038 zik[l++] += df[j]*df[k];; 2039 ; 2040 f -= fsub;; 2041 npfit++;; 2042 c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFumili_8cxx_source.html:58369,cache,cache,58369,doc/master/TFumili_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html,2,['cache'],['cache']
Performance,"nc, const RooArgSet& genVars, const RooNumGenConfig& config, Bool_t verbose = kFALSE, const RooAbsReal* maxFuncVal = 0); Initialize an accept-reject generator for the specified distribution function,; which must be non-negative but does not need to be normalized over the; variables to be generated, genVars. The function and its dependents are; cloned and so will not be disturbed during the generation process. ~RooAcceptReject(); Destructor. const RooArgSet * generateEvent(UInt_t remaining, Double_t& resampleRatio); Return a pointer to a generated event. The caller does not own the event and it; will be overwritten by a subsequent call. The input parameter 'remaining' should; contain your best guess at the total number of subsequent events you will request. const RooArgSet * nextAcceptedEvent(); Scan through events in the cache which have not been used yet,; looking for the first accepted one which is added to the specified; container. Return a pointer to the accepted event, or else zero; if we use up the cache before we accept an event. The caller does; not own the event and it will be overwritten by a subsequent call. void addEventToCache(); Add a trial event to our cache and update our estimates; of the function maximum value and integral. Double_t getFuncMax(); Empirically determine maximum value of function by taking a large number; of samples. The actual number depends on the number of dimensions in which; the sampling occurs. RooAcceptReject(); coverity[UNINIT_CTOR]. RooAcceptReject(const RooAbsReal& func, const RooArgSet& genVars, const RooNumGenConfig& config, Bool_t verbose = kFALSE, const RooAbsReal* maxFuncVal = 0). RooAbsNumGenerator* clone(const RooAbsReal& func, const RooArgSet& genVars, const RooArgSet& , const RooNumGenConfig& config, Bool_t verbose = kFALSE, const RooAbsReal* maxFuncVal = 0) const. Bool_t canSampleConditional() const; Advertisement of capabilities. { return kTRUE ; }. Bool_t canSampleCategories() const; { return kTRUE ; }. » Last ch",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooAcceptReject.html:10525,cache,cache,10525,root/html530/RooAcceptReject.html,https://root.cern,https://root.cern/root/html530/RooAcceptReject.html,8,['cache'],['cache']
Performance,"nc, const RooArgSet& genVars, const RooNumGenConfig& config, Bool_t verbose = kFALSE, const RooAbsReal* maxFuncVal = 0); Initialize an accept-reject generator for the specified distribution function,; which must be non-negative but does not need to be normalized over the; variables to be generated, genVars. The function and its dependents are; cloned and so will not be disturbed during the generation process. ~RooAcceptReject(); Destructor. const RooArgSet * generateEvent(UInt_t remaining, Double_t& resampleRatio); Return a pointer to a generated event. The caller does not own the event and it; will be overwritten by a subsequent call. The input parameter 'remaining' should; contain your best guess at the total number of subsequent events you will request. const RooArgSet * nextAcceptedEvent(); Scan through events in the cache which have not been used yet,; looking for the first accepted one which is added to the specified; container. Return a pointer to the accepted event, or else zero; if we use up the cache before we accept an event. The caller does; not own the event and it will be overwritten by a subsequent call. void addEventToCache(); Add a trial event to our cache and update our estimates; of the function maximum value and integral. Double_t getFuncMax(); Empirically determine maximum value of function by taking a large number; of samples. The actual number depends on the number of dimensions in which; the sampling occurs. RooAcceptReject(); {}. RooAcceptReject(const RooAbsReal& func, const RooArgSet& genVars, const RooNumGenConfig& config, Bool_t verbose = kFALSE, const RooAbsReal* maxFuncVal = 0). RooAbsNumGenerator* clone(const RooAbsReal& func, const RooArgSet& genVars, const RooArgSet& , const RooNumGenConfig& config, Bool_t verbose = kFALSE, const RooAbsReal* maxFuncVal = 0) const. Bool_t canSampleConditional() const; Advertisement of capabilities. { return kTRUE ; }. Bool_t canSampleCategories() const; { return kTRUE ; }. » Last changed: Mon Dec 7 13",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAcceptReject.html:10470,cache,cache,10470,root/html526/RooAcceptReject.html,https://root.cern,https://root.cern/root/html526/RooAcceptReject.html,1,['cache'],['cache']
Performance,"nc, const RooArgSet& genVars, const RooNumGenConfig& config, Bool_t verbose = kFALSE, const RooAbsReal* maxFuncVal = 0); Initialize an accept-reject generator for the specified distribution function,; which must be non-negative but does not need to be normalized over the; variables to be generated, genVars. The function and its dependents are; cloned and so will not be disturbed during the generation process. ~RooAcceptReject(); Destructor. const RooArgSet * generateEvent(UInt_t remaining, Double_t& resampleRatio); Return a pointer to a generated event. The caller does not own the event and it; will be overwritten by a subsequent call. The input parameter 'remaining' should; contain your best guess at the total number of subsequent events you will request. const RooArgSet * nextAcceptedEvent(); Scan through events in the cache which have not been used yet,; looking for the first accepted one which is added to the specified; container. Return a pointer to the accepted event, or else zero; if we use up the cache before we accept an event. The caller does; not own the event and it will be overwritten by a subsequent call. void addEventToCache(); Add a trial event to our cache and update our estimates; of the function maximum value and integral. Double_t getFuncMax(); Empirically determine maximum value of function by taking a large number; of samples. The actual number depends on the number of dimensions in which; the sampling occurs. RooAcceptReject(); {}. RooAcceptReject(const RooAbsReal& func, const RooArgSet& genVars, const RooNumGenConfig& config, Bool_t verbose = kFALSE, const RooAbsReal* maxFuncVal = 0). RooAbsNumGenerator* clone(const RooAbsReal& func, const RooArgSet& genVars, const RooArgSet& , const RooNumGenConfig& config, Bool_t verbose = kFALSE, const RooAbsReal* maxFuncVal = 0) const. Bool_t canSampleConditional() const; Advertisement of capabilities. { return kTRUE ; }. Bool_t canSampleCategories() const; { return kTRUE ; }. » Last changed: Thu Sep 23 1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAcceptReject.html:10456,cache,cache,10456,root/html528/RooAcceptReject.html,https://root.cern,https://root.cern/root/html528/RooAcceptReject.html,1,['cache'],['cache']
Performance,"nc::clone ; (; const char * ; newname); const. inlineoverridevirtual . Implements RooAbsArg.; Definition at line 41 of file RooMomentMorphFunc.h. ◆ DeclFileName(). static const char * RooMomentMorphFunc::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 105 of file RooMomentMorphFunc.h. ◆ evaluate(). double RooMomentMorphFunc::evaluate ; (; ); const. overrideprotectedvirtual . Evaluate this PDF / function / constant. Needs to be overridden by all derived classes. ; Implements RooAbsReal.; Definition at line 345 of file RooMomentMorphFunc.cxx. ◆ getCache(). RooMomentMorphFunc::CacheElem * RooMomentMorphFunc::getCache ; (; const RooArgSet * ; nset); const. protected . Definition at line 161 of file RooMomentMorphFunc.cxx. ◆ getValV(). double RooMomentMorphFunc::getValV ; (; const RooArgSet * ; nset = nullptr); const. overridevirtual . Return value of object. ; If the cache is clean, return the cached value, otherwise recalculate on the fly and refill the cache ; Reimplemented from RooAbsReal.; Definition at line 313 of file RooMomentMorphFunc.cxx. ◆ idxmax(). int RooMomentMorphFunc::idxmax ; (; const double & ; m); const. protected . Definition at line 456 of file RooMomentMorphFunc.cxx. ◆ idxmin(). int RooMomentMorphFunc::idxmin ; (; const double & ; m); const. protected . Definition at line 441 of file RooMomentMorphFunc.cxx. ◆ ij(). Int_t RooMomentMorphFunc::ij ; (; const Int_t & ; i, . const Int_t & ; j . ); const. inlineprotected . Definition at line 90 of file RooMomentMorphFunc.h. ◆ initialize(). void RooMomentMorphFunc::initialize ; (; ). protected . Definition at line 128 of file RooMomentMorphFunc.cxx. ◆ IsA(). TClass * RooMomentMorphFunc::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from RooAbsReal.; Definition at line 105 of file RooMomentMorphFunc.h. ◆ isBinnedDistribution(). bool RooMomentMorphFunc::isBinnedDistribution ; (; const RooArgSe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooMomentMorphFunc.html:64297,cache,cache,64297,doc/master/classRooMomentMorphFunc.html,https://root.cern,https://root.cern/doc/master/classRooMomentMorphFunc.html,3,['cache'],"['cache', 'cached']"
Performance,"ncReduction function to combine the results of the calls to func into partial results, and these into a final result. Must return the same type as func and should be callable with const std::vector<T> where T is the output of func. ; nChunksNumber of chunks to split the input data for processing. . ReturnsA value result of ""reducing"" the vector returned by the Map operation into a single object. ; Definition at line 344 of file TProcessExecutor.hxx. ◆ MapReduce() [2/3]. template<class F , class T , class R , class Cond > . auto ROOT::TProcessExecutor::MapReduce ; (; F ; func, . std::vector< T > & ; args, . R ; redfunc . ); -> InvokeResult_t<F, T>. Execute a function in parallel over the elements of a vector (Map) and accumulate the results into a single value (Reduce). ; Benefits from partial reduction into nChunks intermediate results.; Benefits from partial reduction into nChunks intermediate results if the execution policy is multithreaded. Otherwise, it ignores the nChunks argument and performs a normal MapReduce operation.; Parameters. funcFunction to be executed. Must take an element of the sequence passed assecond argument as a parameter. ; argsVector of elements passed as an argument to func. ; redfuncReduction function to combine the results of the calls to func into partial results, and these into a final result. Must return the same type as func and should be callable with const std::vector<T> where T is the output of func. ; nChunksNumber of chunks to split the input data for processing. . ReturnsA value result of ""reducing"" the vector returned by the Map operation into a single object. ; Definition at line 302 of file TProcessExecutor.hxx. ◆ MapReduce() [3/3]. template<class F , class R , class Cond > . auto ROOT::TProcessExecutor::MapReduce ; (; F ; func, . unsigned ; nTimes, . R ; redfunc . ); -> InvokeResult_t<F>. Execute a function nTimes in parallel (Map) and accumulate the results into a single value (Reduce). ; Parameters. funcFunction to be exec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1TProcessExecutor.html:18338,perform,performs,18338,doc/v632/classROOT_1_1TProcessExecutor.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1TProcessExecutor.html,2,['perform'],['performs']
Performance,"nce Chart:. TObject. ←; TNamed. TAttLine. TAttFill. TAttMarker. ←; TTree. ←. TChain; ←. TProofChain. THbookTree. TNtuple. TNtupleD. TTreeSQL. Function documentation; TTree(); Default constructor and I/O constructor. Note: We do *not* insert ourself into the current directory. TTree(const char* name, const char* title, Int_t splitlevel = 99); Normal tree constructor. The tree is created in the current directory.; Use the various functions Branch below to add branches to this tree. If the first character of title is a ""/"", the function assumes a folder name.; In this case, it creates automatically branches following the folder hierarchy.; splitlevel may be used in this case to control the split level. ~TTree(); Destructor. TBuffer* GetTransientBuffer(Int_t size); Returns the transient buffer currently used by this TTree for reading/writing baskets. void AddBranchToCache(const char* bname, Bool_t subbranches = kFALSE); Add branch with name bname to the Tree cache.; If bname=""*"" all branches are added to the cache.; if subbranches is true all the branches of the subbranches are; also put to the cache. void AddBranchToCache(TBranch* branch, Bool_t subbranches = kFALSE); Add branch b to the Tree cache.; if subbranches is true all the branches of the subbranches are; also put to the cache. void DropBranchFromCache(const char* bname, Bool_t subbranches = kFALSE); Remove the branch with name 'bname' from the Tree cache.; If bname=""*"" all branches are removed from the cache.; if subbranches is true all the branches of the subbranches are; also removed from the cache. void DropBranchFromCache(TBranch* branch, Bool_t subbranches = kFALSE); Remove the branch b from the Tree cache.; if subbranches is true all the branches of the subbranches are; also removed from the cache. void AddClone(TTree* ); Add a cloned tree to our list of trees to be notified whenever we change; our branch addresses or when we are deleted. TFriendElement* AddFriend(const char* treename, const char* filenam",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTree.html:37764,cache,cache,37764,root/html602/TTree.html,https://root.cern,https://root.cern/root/html602/TTree.html,2,['cache'],['cache']
Performance,"nce Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Classes |; Public Member Functions |; Static Public Member Functions |; Protected Member Functions |; Protected Attributes |; List of all members ; TProofDrawListOfGraphs Class Reference. . Definition at line 257 of file TProofDraw.h. Classes; struct  Point3D_t;  . Public Member Functions;  TProofDrawListOfGraphs ();  ; TClass * IsA () const override;  ; void SlaveBegin (TTree *) override;  See TProofDraw::SlaveBegin(). ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void Terminate () override;  See TProofDraw::Terminate(). ;  ;  Public Member Functions inherited from TProofDraw;  TProofDraw ();  Constructor. ;  ;  ~TProofDraw () override;  Destructor. ;  ; void Begin (TTree *) override;  Executed by the client before processing. ;  ; void Init (TTree *) override;  Init the tree. ;  ; Bool_t Notify () override;  Called when a new tree is loaded. ;  ; Bool_t Process (Long64_t) override;  Executed for each entry. ;  ; void SlaveTerminate () override;  Executed by each slave after the processing has finished, before returning the results to the client. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; int Version () const override;  ;  Public Member Functions inherited from TSelector;  TSelector ();  Default selector ctor. ;  ;  ~TSelector () override;  Selector destructor. ;  ; virtual void Abort (const char *why, EAbort what=kAbortProcess);  Abort processing. ;  ; virtual EAbort GetAbort () const;  ; virtual Int_t GetEntry (Long64_t, Int_t=0);  ; virtual TList * GetInputList () const;  ; const char * GetOption () const override;  ; virtual TList * GetOutputList () const;  ; virtual Long64_t GetStatus () const;  ; virtual void ImportOutput (TList *output);  Imports the content of 'output' in the internal output list. ;  ; TClass * IsA () const override;  ; bool Notify () over",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofDrawListOfGraphs.html:1101,load,loaded,1101,doc/master/classTProofDrawListOfGraphs.html,https://root.cern,https://root.cern/doc/master/classTProofDrawListOfGraphs.html,1,['load'],['loaded']
Performance,"nce of approach from point px,py to this function.; /// The distance is computed in pixels units.;  ; Int_t TF2::DistancetoPrimitive(Int_t px, Int_t py); {; ...; }; Free functions documentation; Doxygen does not document default parameters of free functions if the only doxygen documentation provided for the function is in source files (as opposed to header files). To bypass this issue it is enough to provide a brief documentation for such functions in the header file. For example if the source file is:; ////////////////////////////////////////////////////////////////////////////////; /// @param[in] numthreads Number of threads to use. If not specified or; /// set to zero, the number of threads is automatically; /// decided by the implementation. Any other value is; /// used as a hint.; ///; /// ROOT must be built with the compilation flag `imt=ON` for this feature to be available.;  ; [...];  ; void EnableImplicitMT(UInt_t numthreads); and the header file:; /// Enable ROOT's implicit multi-threading for all objects and methods that provide an internal; /// parallelisation mechanism.; void EnableImplicitMT(UInt_t numthreads = 0);; Then a proper documentation with the default parameters is generated.; Data Member documentation; IMPORTANT: It is crucial to use ""///<"" and only ""///<"" to comment data members: this comment is correctly understood by genreflex/rootcling. The usage of other Doxygen constructs can interfere with the I/O subsystem!; Double_t fMymember ///< My Member; Double_t fMyTransientMember ///<! My Member; The usage of ""//!"" will still result in transiency of members but not in Doxygen documentation.; Tutorials' documentation; ROOT tutorials are also included in the ROOT documentation. The tutorials'; macros headers should look like:; \file; \ingroup tutorial_hist; \notebook; Getting Contours From TH2D.;  ; #### Image produced by `.x ContourList.C`; The contours values are drawn next to each contour.; \macro_image;  ; #### Output produced by `.x ContourLi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/formatting-comments-doxygen.html:5007,multi-thread,multi-threading,5007,d/formatting-comments-doxygen.html,https://root.cern,https://root.cern/d/formatting-comments-doxygen.html,1,['multi-thread'],['multi-threading']
Performance,"nce the check is done elsewhere.; kForward (0x4) if set, ask server to forward the file to slave; or submaster (meaningless for slave servers).; kCpBin (0x8) Retrieve from the cache the binaries associated; with the file; kCp (0x10) Retrieve the files from the cache. Int_t SendObject(const TObject* obj, TProof::ESlaves list = kActive); Send object to master or slave servers. Returns number of slaves object; was sent to, -1 in case of error. Int_t SendPrint(Option_t* option = """"); Send print command to master server. Returns number of slaves message; was sent to. Returns -1 in case of error. void SetLogLevel(Int_t level, UInt_t mask = TProofDebug::kAll); Set server logging level. void SetRealTimeLog(Bool_t on = kTRUE); Switch ON/OFF the real-time logging facility. When this option is; ON, log messages from processing are sent back as they come, instead of; being sent back at the end in one go. This may help debugging or monitoring; in some cases, but, depending on the amount of log, it may have significant; consequencies on the load over the network, so it must be used with care. Int_t SetParallelSilent(Int_t nodes, Bool_t random = kFALSE); Tell PROOF how many slaves to use in parallel. If random is TRUE a random; selection is done (if nodes is less than the available nodes).; Returns the number of parallel slaves. Returns -1 in case of error. Int_t SetParallel(Int_t nodes = 9999, Bool_t random = kFALSE); Tell PROOF how many slaves to use in parallel. Returns the number of; parallel slaves. Returns -1 in case of error. Int_t GoParallel(Int_t nodes, Bool_t accept = kFALSE, Bool_t random = kFALSE); Go in parallel mode with at most ""nodes"" slaves. Since the fSlaves; list is sorted by slave performace the active list will contain first; the most performant nodes. Returns the number of active slaves.; If random is TRUE, and nodes is less than the number of available workers,; a random selection is done.; Returns -1 in case of error. void ShowData(); List contents of the d",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProof.html:57979,load,load,57979,root/html528/TProof.html,https://root.cern,https://root.cern/root/html528/TProof.html,4,['load'],['load']
Performance,"nce. . Definition at line 52 of file TCondor.h. Public Types; enum  EState { kFree; , kSuspended; , kActive; };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  . Public Member Functions;  TCondor (const char *pool="""");  Create Condor interface object. ;  ;  ~TCondor () override;  Cleanup Condor interface. ;  ; TCondorSlave * Claim (const char *vmname, const char *cmd);  Claim virtual machine with name vmname This function does not figure out the image and performance index before returning the condor slave. ;  ; TList * Claim (Int_t n, const char *cmd);  Claim n virtual machines This function figures out the image and performance index before returning the list of condor slaves. ;  ; TString GetImage (const char *host) const;  Get image of the worker. ;  ; EState GetState () const;  ; TList * GetVirtualMachines () const;  Get the names of the virtual machines in the pool. ;  ; Bool_t GetVmInfo (const char *vm, TString &image, Int_t &perfidx) const;  Get info about worker status. ;  ; TClass * IsA () const override;  ; Bool_t IsValid () const;  ; void Print (Option_t *option="""") const override;  Print master status. ;  ; Bool_t Release ();  Release worker. ;  ; Bool_t Resume ();  Resume worker. ;  ; Bool_t SetState (EState state);  Set the state of workers. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerN",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTCondor.html:1359,perform,performance,1359,doc/master/classTCondor.html,https://root.cern,https://root.cern/doc/master/classTCondor.html,1,['perform'],['performance']
Performance,"nce. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Static Public Member Functions |; Protected Member Functions |; Protected Attributes |; Private Member Functions |; Private Attributes |; List of all members ; TBranchRef Class ReferenceTree Library. ; A branch containing and managing a TRefTable for TRef autoloading. ; It loads the TBranch containing a referenced object when requested by TRef::GetObject(), so the reference can be resolved. The information which branch to load is stored by TRefTable. Once a TBranch has read the TBranchRef's current entry it will not be told to re-read, in case the use has changed objects read from the branch. LIMITATION :; Note that this does NOT allow for autoloading of references spanning different entries. The TBranchRef's current entry has to correspond to the entry of the TBranch containing the referenced object.; The TRef cannot be stored in a top-level branch which is a TBranchObject for the auto-loading to work. E.g. you cannot store the TRefs in TObjArray, and create a top-level branch storing this TObjArray. ; Definition at line 34 of file TBranchRef.h. Public Member Functions;  TBranchRef ();  Default constructor. ;  ;  TBranchRef (TTree *tree);  Main constructor called by TTree::BranchRef. ;  ;  ~TBranchRef () override;  Typical destructor. ;  ; void Clear (Option_t *option="""") override;  Clear entries in the TRefTable. ;  ; TRefTable * GetRefTable () const;  ; TClass * IsA () const override;  ; bool Notify () override;  This function is called by TRefTable::Notify, itself called by TRef::GetObject. ;  ; void Print (Option_t *option="""") const override;  Print the TRefTable branch. ;  ; void Reset (Option_t *option="""") override;  ; void ResetAfterMerge (TFileMergeInfo *) override;  Reset a Branch after a Merge operation (drop data but keep customizations) TRefTable is cleared. ;  ; virtual Int_t SetParent (const TObject *obj, Int_t branch",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBranchRef.html:1067,load,loading,1067,doc/master/classTBranchRef.html,https://root.cern,https://root.cern/doc/master/classTBranchRef.html,1,['load'],['loading']
Performance,"nce; Inherited Members; Includes; Libraries. Function documentation; TGLAxis(); Constructor. void Init(); Default initialization. ~TGLAxis(); Destructor. void PaintGLAxis(const Double_t[3] p1, const Double_t[3] p2, Double_t wmin, Double_t wmax, Int_t ndiv, Option_t* opt = """"); Paint GL Axis. p1, p2 : Axis position in the 3D space.; wmin, wmax : Minimum and maximum values along the axis. wmin < wmax.; ndiv : Number of axis divisions. It is an integer in the form; ""ttsspp"" where ""tt"" is the number of tertiary divisions,; ""ss"" is the number of secondary divisions and ""pp"" the; number of primary divisions.; opt : Options.; ""N"" - By default the number of divisions is optimized to; get a nice labeling. When option ""N"" is given, the; number of divisions is not optimized. void PaintGLAxisBody(); Paint horizontal axis body at position (0,0,0). void PaintGLAxisTickMarks(); Paint axis tick marks. void PaintGLAxisLabels(); Paint axis labels on the main tick marks. void TicksPositions(Option_t* opt = """"); Compute ticks positions. void TicksPositionsNoOpt(); Compute ticks positions. Linear and not optimized. void TicksPositionsOpt(); Compute ticks positions. Linear and optimized. void DoLabels(); Do labels. void SetLabelsAngles(Double_t a1, Double_t a2, Double_t a3); Set labels' angles. TGLAxis(const TGLAxis& ). TGLAxis& operator=(const TGLAxis& ). void SetTickMarksLength(Double_t length); {fTickMarksLength = length;}. void SetTickMarksOrientation(Int_t tmo); {fTickMarksOrientation = tmo;}. void SetLabelsOffset(Double_t offset); {fLabelsOffset = offset;}. void SetLabelsSize(Double_t size); {fLabelsSize = size;}. void SetGridLength(Double_t grid); {fGridLength = grid;}. » Author: Olivier Couet 17/04/2007 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id$ » Last generated: 2015-06-02 15:51; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGLAxis.html:4896,optimiz,optimized,4896,root/html604/TGLAxis.html,https://root.cern,https://root.cern/root/html604/TGLAxis.html,4,['optimiz'],['optimized']
Performance,"nce; Inherited Members; Includes; Libraries. Function documentation; TGLAxis(); Constructor. void Init(); Default initialization. ~TGLAxis(); Destructor. void PaintGLAxis(const Double_t[3] p1, const Double_t[3] p2, Double_t wmin, Double_t wmax, Int_t ndiv, Option_t* opt = """"); Paint GL Axis. p1, p2 : Axis position in the 3D space.; wmin, wmax : Minimum and maximum values along the axis. wmin < wmax.; ndiv : Number of axis divisions. It is an integer in the form; ""ttsspp"" where ""tt"" is the number of tertiary divisions,; ""ss"" is the number of secondary divisions and ""pp"" the; number of primary divisions.; opt : Options.; ""N"" - By default the number of divisions is optimized to; get a nice labeling. When option ""N"" is given, the; number of divisions is not optimized. void PaintGLAxisBody(); Paint horizontal axis body at position (0,0,0). void PaintGLAxisTickMarks(); Paint axis tick marks. void PaintGLAxisLabels(); Paint axis labels on the main tick marks. void TicksPositions(Option_t* opt = """"); Compute ticks positions. void TicksPositionsNoOpt(); Compute ticks positions. Linear and not optimized. void TicksPositionsOpt(); Compute ticks positions. Linear and optimized. void DoLabels(); Do labels. void SetLabelsAngles(Double_t a1, Double_t a2, Double_t a3); Set labels' angles. TGLAxis(const TGLAxis& ). TGLAxis& operator=(const TGLAxis& ). void SetTickMarksLength(Double_t length); {fTickMarksLength = length;}. void SetTickMarksOrientation(Int_t tmo); {fTickMarksOrientation = tmo;}. void SetLabelsOffset(Double_t offset); {fLabelsOffset = offset;}. void SetLabelsSize(Double_t size); {fLabelsSize = size;}. void SetGridLength(Double_t grid); {fGridLength = grid;}. » Author: Olivier Couet 17/04/2007 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id$ » Last generated: 2015-06-30 14:52; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGLAxis.html:4896,optimiz,optimized,4896,root/html602/TGLAxis.html,https://root.cern,https://root.cern/root/html602/TGLAxis.html,4,['optimiz'],['optimized']
Performance,"nces and Scaling; The tolerance parameter fTol (a member of the base class TDecompBase) plays a crucial role in all operations of the decomposition classes. It gives the user a tool to monitor and steer the operations its default value is \(\varepsilon\) where \(1+\varepsilon=1\).; If you do not want to be bothered by the following considerations, like in most other linear algebra packages, just set the tolerance with SetTol to an arbitrary small number. The tolerance number is used by each decomposition method to decide whether the matrix is near singular, except of course SVD that can handle singular matrices. This will be checked in a different way for any decomposition. For instance in LU, a matrix is considered singular in the solving stage when a diagonal element of the decomposed matrix is smaller than fTol. Here an important point is raised. The Decompose() method is successful as long no zero diagonal element is encountered. Therefore, the user could perform decomposition and only after this step worry about the tolerance number.; If the matrix is flagged as being singular, operations with the decomposition will fail and will return matrices or vectors that are invalid. If one would like to monitor the tolerance parameter but not have the code stop in case of a number smaller than fTol, one could proceed as follows:; TVectorD b = ..;; TMatrixD a = ..;; .; TDecompLU lu(a);; Bool_t ok;; TVectorD x = lu.Solve(b,ok);; Int_t nr = 0;; while (!ok) {; lu.SetMatrix(a);; lu.SetTol(0.1*lu.GetTol());; if (nr++ > 10) break;; x = lu.Solve(b,ok);; }; if (x.IsValid()); cout << ""solved with tol ="" << lu.GetTol() << endl;; else; cout << ""solving failed "" << endl;; The observant reader will notice that by scaling the complete matrix by some small number the decomposition will detect a singular matrix. In this case, the user will have to reduce the tolerance number by this factor. (For CPU time saving we decided not to make this an automatic procedure).; 14.6.2 Condition number",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:793515,perform,perform,793515,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['perform'],['perform']
Performance,"nch * TTreeCache::CalculateMissEntries ; (; Long64_t ; pos, . int ; len, . bool ; all . ). private . Given an file read, try to determine the corresponding branch. ; Given a particular IO description (offset / length) representing a 'miss' of the TTreeCache's primary cache, calculate all the corresponding IO that should be performed.; all indicates that this function should search the set of all branches in this TTree. When set to false, we only search through branches that have previously incurred a miss.; Returns:; TBranch pointer corresponding to the basket that will be retrieved by this IO operation.; If no corresponding branch could be found (or an error occurs), this returns nullptr. . Definition at line 790 of file TTreeCache.cxx. ◆ CheckMissCache(). bool TTreeCache::CheckMissCache ; (; char * ; buf, . Long64_t ; pos, . int ; len . ). private . Check the miss cache for a particular buffer, fetching if deemed necessary. ; Given an IO operation (pos, len) that was a cache miss in the primary TTC, try the operation again with the miss cache.; Returns true if the IO operation was successful and the contents of buf were populated with the requested data. ; Definition at line 921 of file TTreeCache.cxx. ◆ Class(). static TClass * TTreeCache::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TTreeCache::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TTreeCache::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 175 of file TTreeCache.h. ◆ DeclFileName(). static const char * TTreeCache::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 175 of file TTreeCache.h. ◆ Disable(). virtual void TTreeCache::Disable ; (; ). inlinevirtual . Definition at line 136 of file TTreeCache.h. ◆ DropBranch() [1/2]. Int_t TTreeCache::DropBranch ; (; const char * ; bname, . bool ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCache.html:37016,cache,cache,37016,doc/v632/classTTreeCache.html,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html,4,['cache'],['cache']
Performance,nch buffers; TBenchmark ROOT utility to help benchmarking applications; TBinomialEfficiencyFitter Binomial Fitter for the division of two histograms; TBits Bit container; TBits::TReference ; TBox Box class; TBranch Branch descriptor; TBranchClones Branch in case of an array of clone objects; TBranchElement Branch in case of an object; TBranchObject Branch in case of an object; TBranchRef to support referenced objects on other branches; TBranchSTL Branch handling STL collection of pointers; TBrowser ROOT Object Browser; TBrowserImp ABC describing browser implementation protocol; TBrowserPlugin basic plugin description class; TBtree A B-tree; TBtreeIter B-tree iterator; TBuffer Buffer base class used for serializing objects; TBuffer3D 3D primitives description; TBufferFile concrete implementation of TBuffer for writing/reading to/from a ROOT file or socket.; TBufferSQL Implementation of TBuffer to load and write to a SQL database; TBufferSQL2 a specialized TBuffer to convert data to SQL statements or read data from SQL tables; TBufferXML a specialized TBuffer to read/write to XML files; TButton A user interface button.; TCL C++ replacement for CERNLIB matrix / triangle matrix packages: F110 and F112; TCONE CONE shape; TCONS CONS shape; TCTUB The Cut Tube shape; TCanvas Graphics canvas; TCanvasImp ABC describing main window protocol; TChain A chain of TTrees; TChainElement A chain element; TChainIndex A Tree Index with majorname and minorname.; TChainIndex::TChainIndexEntry ; TChair A base class to provide a user custom interface to TTable class objects; TCint Interface to CINT C/C++ interpreter; TClass Dictionary containing class information; TClassDocInfo info cache for class documentation; TClassDocOutput generates documentation web pages for a class; TClassEdit ; TClassGenerator interface for TClass generators; TClassMenuItem One element of the class context menu; TClassRef ; TClassStreamer ; TClassTable Table of known classes; TClassTree Manager class to draw class,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html524/ClassIndex.html:49079,load,load,49079,root/html524/ClassIndex.html,https://root.cern,https://root.cern/root/html524/ClassIndex.html,1,['load'],['load']
Performance,"nch to the list of branches to be stored in the cache; this is to be used by user (thats why we pass the name of the branch).; It works in exactly the same way as TTree::SetBranchStatus so you; probably want to look over ther for details about the use of bname; with regular expresions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped. Bool_t FillBuffer(); Fill the cache buffer with the branches in the cache. Double_t GetEfficiency() const; Give the total efficiency of the cache... defined as the ratio; of blocks found in the cache vs. the number of blocks prefetched; ( it could be more than 1 if we read the same block from the cache more; than once ); Note: This should eb used at the end of the processing or we will; get uncomplete stats. Double_t GetEfficiencyRel() const; This will indicate a sort of relative efficiency... a ratio of the; reads found in the cache to the number of reads so far. Int_t GetLearnEntries(); static function returning the number of entries used to train the cache; see SetLearnEntries. TTree * GetOwner() const; return the owner of this cache. TTree * GetTree() const; return Tree in the cache. void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; see also class TTreePerfStats. Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at pos",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreeCache.html:18617,cache,cache,18617,root/html528/TTreeCache.html,https://root.cern,https://root.cern/root/html528/TTreeCache.html,1,['cache'],['cache']
Performance,"nch to the list of branches to be stored in the cache; this is to be used by user (thats why we pass the name of the branch).; It works in exactly the same way as TTree::SetBranchStatus so you; probably want to look over ther for details about the use of bname; with regular expresions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped. Bool_t FillBuffer(); Fill the cache buffer with the branches in the cache. Double_t GetEfficiency() const; Give the total efficiency of the cache... defined as the ratio; of blocks found in the cache vs. the number of blocks prefetched; ( it could be more than 1 if we read the same block from the cache more; than once ); Note: This should eb used at the end of the processing or we will; get uncomplete stats. Double_t GetEfficiencyRel() const; This will indicate a sort of relative efficiency... a ratio of the; reads found in the cache to the number of reads so far. Int_t GetLearnEntries(); static function returning the number of entries used to train the cache; see SetLearnEntries. TTree * GetOwner() const; return the owner of this cache. TTree * GetTree() const; return Tree in the cache. void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; see also class TTreePerfStats. Int_t ReadBufferNormal(char* buf, Long64_t pos, Int_t len). Int_t ReadBu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TTreeCache.html:20483,cache,cache,20483,root/html530/TTreeCache.html,https://root.cern,https://root.cern/root/html530/TTreeCache.html,1,['cache'],['cache']
Performance,"nch to the list of branches to be stored in the cache; this is to be used by user (thats why we pass the name of the branch).; It works in exactly the same way as TTree::SetBranchStatus so you; probably want to look over ther for details about the use of bname; with regular expresions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped. Bool_t FillBuffer(); Fill the cache buffer with the branches in the cache. Double_t GetEfficiency() const; Give the total efficiency of the cache... defined as the ratio; of blocks found in the cache vs. the number of blocks prefetched; ( it could be more than 1 if we read the same block from the cache more; than once ); Note: This should eb used at the end of the processing or we will; get uncomplete stats. Double_t GetEfficiencyRel() const; This will indicate a sort of relative efficiency... a ratio of the; reads found in the cache to the number of reads so far. Int_t GetLearnEntries(); static function returning the number of entries used to train the cache; see SetLearnEntries. TTree * GetOwner() const; return the owner of this cache. TTree * GetTree() const; return Tree in the cache. void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; see also class TTreePerfStats.; if option contains 'cachedbranches', the list of branches being; cached",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTreeCache.html:21325,cache,cache,21325,root/html532/TTreeCache.html,https://root.cern,https://root.cern/root/html532/TTreeCache.html,2,['cache'],['cache']
Performance,"nch to the list of branches to be stored in the cache; this is to be used by user (thats why we pass the name of the branch).; It works in exactly the same way as TTree::SetBranchStatus so you; probably want to look over ther for details about the use of bname; with regular expresions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped. Bool_t FillBuffer(); Fill the cache buffer with the branches in the cache. Double_t GetEfficiency() const; Give the total efficiency of the cache... defined as the ratio; of blocks found in the cache vs. the number of blocks prefetched; ( it could be more than 1 if we read the same block from the cache more; than once ); Note: This should eb used at the end of the processing or we will; get uncomplete stats. Double_t GetEfficiencyRel() const; This will indicate a sort of relative efficiency... a ratio of the; reads found in the cache to the number of reads so far. Int_t GetLearnEntries(); static function returning the number of entries used to train the cache; see SetLearnEntries. void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; see also class TTreePerfStats.; if option contains 'cachedbranches', the list of branches being; cached is printed. Int_t ReadBufferNormal(char* buf, Long64_t pos, Int_t len). Int_t ReadBufferPrefetch(char* buf, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTreeCache.html:23325,cache,cache,23325,root/html534/TTreeCache.html,https://root.cern,https://root.cern/root/html534/TTreeCache.html,4,['cache'],['cache']
Performance,"nch(fantomline);; 3124}; 3125 ; 3126// This static function is a hop of TCling::IsLibraryLoaded, which is taking a lock and calling; 3127// into this function. This is because we wanted to avoid a duplication in TCling::IsLoaded, which; 3128// was already taking a lock.; 3129static Bool_t s_IsLibraryLoaded(const char* libname, cling::Interpreter* fInterpreter); 3130{; 3131 // Check shared library.; 3132 TString tLibName(libname);; 3133 if (gSystem->FindDynamicLibrary(tLibName, kTRUE)); 3134 return fInterpreter->getDynamicLibraryManager()->isLibraryLoaded(tLibName.Data());; 3135 return false;; 3136}; 3137 ; 3138Bool_t TCling::IsLibraryLoaded(const char* libname) const; 3139{; 3140 R__LOCKGUARD(gInterpreterMutex);; 3141 return s_IsLibraryLoaded(libname, GetInterpreterImpl());; 3142}; 3143 ; 3144////////////////////////////////////////////////////////////////////////////////; 3145/// Return true if ROOT has cxxmodules pcm for a given library name.; 3146// FIXME: We need to be able to support lazy loading of pcm generated by ACLiC.; 3147Bool_t TCling::HasPCMForLibrary(const char *libname) const; 3148{; 3149 llvm::StringRef ModuleName(libname);; 3150 ModuleName = llvm::sys::path::stem(ModuleName);; 3151 ModuleName.consume_front(""lib"");; 3152 ; 3153 // FIXME: In case when the modulemap is not yet loaded we will return the; 3154 // wrong result. Consider a call to HasPCMForLibrary(../test/libEvent.so); 3155 // We will only load the modulemap for libEvent.so after we dlopen libEvent; 3156 // which may happen after calling this interface. Maybe we should also check; 3157 // if there is a Event.pcm file and a module.modulemap, load it and return; 3158 // true.; 3159 clang::ModuleMap &moduleMap = fInterpreter->getCI()->getPreprocessor().getHeaderSearchInfo().getModuleMap();; 3160 clang::Module *M = moduleMap.findModule(ModuleName);; 3161 return M && !M->IsUnimportable && M->getASTFile();; 3162}; 3163 ; 3164////////////////////////////////////////////////////////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:121522,load,loading,121522,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['load'],['loading']
Performance,nchAddressStatus { kMissingBranch; kInternalError; kMissingCompiledCollectionProxy; kMismatch; kClassMismatch; kMatch; kMatchConversion; kMatchConversionCollection; kMakeClass; kVoidPtr; kNoCheck; };; enum TTree::[unnamed] { kForceRead; kCircular; kSplitCollectionOfPointers; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TList*TTree::fAliasesList of aliases for expressions based on the tree branches.; Float_t*fArgs! [fNvar] Array of variables; Long64_tTTree::fAutoFlushAutoflush tree when fAutoFlush entries written; Long64_tTTree::fAutoSaveAutosave tree when fAutoSave bytes produced; TBranchRef*TTree::fBranchRefBranch supporting the TRefTable (if any); TObjArrayTTree::fBranchesList of Branches; Bool_tTTree::fCacheDoAutoInit! true if cache auto creation or resize check is needed; Long64_tTTree::fCacheSize! Maximum size of file buffers; Bool_tTTree::fCacheUserSet! true if the cache setting was explicitly given by user; Long64_tTTree::fChainOffset! Offset of 1st entry of this Tree in a TChain; TList*TTree::fClones! List of cloned trees which share our addresses; Long64_t*TTree::fClusterRangeEnd[fNClusterRange] Last entry of a cluster range.; Long64_t*TTree::fClusterSize[fNClusterRange] Number of entries in each cluster for a given range.; Int_tTTree::fDebug! Debug level; Long64_tTTree::fDebugMax! Last entry number to debug; Long64_tTTree::fDebugMin! First entry number to debug; Int_tTTree::fDefaultEntryOffsetLenInitial Length of fEntryOffset table in the basket buffers; TDirectory*TTree::fDirectory! Pointer to directory holding this tree; Long64_tTTree::fEntriesNumber of entries; TEntryList*TTree::fEntryList! Pointer to event selection list (if one); Long64_tTTree::fEstimateNumber of entries to estimate histogram limits; TEventList*TTree::fEventList! Po,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TNtuple.html:22588,cache,cache,22588,root/html534/TNtuple.html,https://root.cern,https://root.cern/root/html534/TNtuple.html,4,['cache'],['cache']
Performance,nchAddressStatusTTree::kNoCheck; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TTree::(anonymous)TTree::kSplitCollectionOfPointers; static TTree::ESetBranchAddressStatusTTree::kVoidPtr; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TList*TTree::fAliasesList of aliases for expressions based on the tree branches.; Double_t*fArgs! [fNvar] Array of variables; Long64_tTTree::fAutoFlushAutoflush tree when fAutoFlush entries written or -fAutoFlush (compressed) bytes produced; Long64_tTTree::fAutoSaveAutosave tree when fAutoSave entries written or -fAutoSave (compressed) bytes produced; TBranchRef*TTree::fBranchRefBranch supporting the TRefTable (if any); TObjArrayTTree::fBranchesList of Branches; Bool_tTTree::fCacheDoAutoInit! true if cache auto creation or resize check is needed; Long64_tTTree::fCacheSize! Maximum size of file buffers; Bool_tTTree::fCacheUserSet! true if the cache setting was explicitly given by user; Long64_tTTree::fChainOffset! Offset of 1st entry of this Tree in a TChain; TList*TTree::fClones! List of cloned trees which share our addresses; Long64_t*TTree::fClusterRangeEnd[fNClusterRange] Last entry of a cluster range.; Long64_t*TTree::fClusterSize[fNClusterRange] Number of entries in each cluster for a given range.; Int_tTTree::fDebug! Debug level; Long64_tTTree::fDebugMax! Last entry number to debug; Long64_tTTree::fDebugMin! First entry number to debug; Int_tTTree::fDefaultEntryOffsetLenInitial Length of fEntryOffset table in the basket buffers; TDirectory*TTree::fDirectory! Pointer to directory holding this tree; Long64_tTTree::fEntriesNumber of entries; TEntryList*TTree::fEntryList! Pointer to event selection list (if one); Long64_tTTree::fEstimateNumber of entries to estimate histog,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TNtupleD.html:23623,cache,cache,23623,root/html604/TNtupleD.html,https://root.cern,https://root.cern/root/html604/TNtupleD.html,4,['cache'],['cache']
Performance,"nchName () const;  Construct a mangled name from the actual name that is free of any math symbols that might be interpreted by TTree. ;  ; void clearShapeDirty () const;  ; void clearValueAndShapeDirty () const;  ; void clearValueDirty () const;  ; virtual void getObservablesHook (const RooArgSet *, RooArgSet *) const;  ; virtual void getParametersHook (const RooArgSet *, RooArgSet *, bool) const;  ; void graphVizAddConnections (std::set< std::pair< RooAbsArg *, RooAbsArg * > > &);  Utility function that inserts all point-to-point client-server connections between any two RooAbsArgs in the expression tree headed by this object in the linkSet argument. ;  ; bool inhibitDirty () const;  Delete watch flag. ;  ; virtual void ioStreamerPass2 ();  Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ;  ; virtual void optimizeDirtyHook (const RooArgSet *);  ; void printAttribList (std::ostream &os) const;  Transient boolean attributes (not copied in ctor) ;  ; void registerProxy (RooArgProxy &proxy);  Register an RooArgProxy in the proxy list. ;  ; void registerProxy (RooListProxy &proxy);  Register an RooListProxy in the proxy list. ;  ; void registerProxy (RooSetProxy &proxy);  Register an RooSetProxy in the proxy list. ;  ; void setProxyNormSet (const RooArgSet *nset);  Forward a change in the cached normalization argset to all the registered proxies. ;  ; void setShapeDirty (const RooAbsArg *source);  Notify that a shape-like property (e.g. binning) has changed. ;  ; void setValueDirty (const RooAbsArg *source);  Force element to re-evaluate itself when a value is requested. ;  ; void unRegisterProxy (RooArgProxy &proxy);  Remove proxy from proxy list. ;  ; void unRegisterProxy (RooListProxy &proxy);  Remove proxy from proxy list. ;  ; void unRegisterProxy (RooSetProxy &proxy);  Remove proxy from proxy list. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCachedReal.html:56111,optimiz,optimizeDirtyHook,56111,doc/master/classRooCachedReal.html,https://root.cern,https://root.cern/doc/master/classRooCachedReal.html,1,['optimiz'],['optimizeDirtyHook']
Performance,"nchToCache. ;  ; virtual void Disable ();  ; virtual Int_t DropBranch (const char *branch, bool subbranches=false);  Remove a branch to the list of branches to be stored in the cache this is to be used by user (thats why we pass the name of the branch). ;  ; virtual Int_t DropBranch (TBranch *b, bool subbranches=false);  Remove a branch to the list of branches to be stored in the cache this function is called by TBranch::GetBasket. ;  ; virtual void Enable ();  ; virtual bool FillBuffer ();  Fill the cache buffer with the branches in the cache. ;  ; const TObjArray * GetCachedBranches () const;  ; EPrefillType GetConfiguredPrefillType () const;  Return the desired prefill type from the environment or resource variable. ;  ; Double_t GetEfficiency () const;  Give the total efficiency of the primary cache... defined as the ratio of blocks found in the cache vs. ;  ; Double_t GetEfficiencyRel () const;  This will indicate a sort of relative efficiency... a ratio of the reads found in the cache to the number of reads so far. ;  ; virtual Int_t GetEntryMax () const;  ; virtual Int_t GetEntryMin () const;  ; virtual EPrefillType GetLearnPrefill () const;  ; Double_t GetMissEfficiency () const;  The total efficiency of the 'miss cache' - defined as the ratio of blocks found in the cache versus the number of blocks prefetched. ;  ; Double_t GetMissEfficiencyRel () const;  Relative efficiency of the 'miss cache' - ratio of the reads found in cache to the number of reads so far. ;  ; bool GetOptimizeMisses () const;  ; TTree * GetTree () const;  ; TClass * IsA () const override;  ; bool IsAutoCreated () const;  ; virtual bool IsEnabled () const;  ; bool IsLearning () const override;  ; Int_t LearnBranch (TBranch *b, bool subgbranches=false) override;  Add a branch discovered by actual usage to the list of branches to be stored in the cache this function is called by TBranch::GetBasket If we are not longer in the training phase this is an error. ;  ; virtual void LearnPrefill (",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCache.html:13541,cache,cache,13541,doc/v632/classTTreeCache.html,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html,2,['cache'],['cache']
Performance,"nches automatically when a branch buffer is read during the learning phase.; The TreeCache interface provides functions to instruct the cache about the used; branches if they are known a priori. In the examples below, portions of analysis; code are shown. The few statements involving the TreeCache are marked with //<<<. 1- with TTree::Draw. the TreeCache is automatically used by TTree::Draw. The function knows; which branches are used in the query and it puts automatically these branches; in the cache. The entry range is also known automatically. 2- with TTree::Process and TSelectors. You must enable the cache and tell the system which branches to cache; and also specify the entry range. It is important to specify the entry range; in case you process only a subset of the events, otherwise you run the risk; to store in the cache entries that you do not need. --example 2a; --; TTree *T = (TTree*)f->Get(""mytree"");; Long64_t nentries = T->GetEntries();; Int_t cachesize = 10000000; //10 MBytes; T->SetCacheSize(cachesize); //<<<; T->AddBranchToCache(""*"",kTRUE); //<<< add all branches to the cache; T->Process('myselector.C+"");; //in the TSelector::Process function we read all branches; T->GetEntry(i);; -- ... here you process your entry. --example 2b; in the Process function we read a subset of the branches.; Only the branches used in the first entry will be put in the cache; --; TTree *T = (TTree*)f->Get(""mytree"");; //we want to process only the 200 first entries; Long64_t nentries=200;; int efirst= 0;; int elast = efirst+nentries;; Int_t cachesize = 10000000; //10 MBytes; TTreeCache::SetLearnEntries(1); //<<< we can take the decision after 1 entry; T->SetCacheSize(cachesize); //<<<; T->SetCacheEntryRange(efirst,elast); //<<<; T->Process('myselector.C+"","""",nentries,efirst);; // in the TSelector::Process we read only 2 branches; TBranch *b1 = T->GetBranch(""branch1"");; b1->GetEntry(i);; if (somecondition) return;; TBranch *b2 = T->GetBranch(""branch2"");; b2->GetEntry(i);; ...",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTreeCache.html:5101,cache,cachesize,5101,root/html532/TTreeCache.html,https://root.cern,https://root.cern/root/html532/TTreeCache.html,24,['cache'],"['cache', 'cachesize']"
Performance,"nches. An alternative to this function is to read directly and only; the interesting branches. Example:; TBranch *brc = T.GetBranch(""c"");; TBranch *bre = T.GetBranch(""e"");; brc->GetEntry(i);; bre->GetEntry(i);. If found is not 0, the number of branch(es) found matching the regular; expression is returned in *found AND the error message 'unknown branch'; is suppressed. void SetBranchStyle(Int_t style = 1); Set the current branch style. (static function). style = 0 old Branch; style = 1 new Bronch. Int_t SetCacheSize(Long64_t cachesize = -1); Set maximum size of the file cache .; if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing; the Tree (default is 30 MBytes).; Returns 0 size set, cache was created if possible; -1 on error. Int_t SetCacheSizeAux(Bool_t autocache = kTRUE, Long64_t cacheSize = 0); Set the size of the file cache and create it if possible. If autocache is true:; this may be an autocreated cache, possibly enlarging an existing; autocreated cache. The size is calculated. The value passed in cacheSize:; cacheSize = 0 make cache if default cache creation is enabled; cacheSize = -1 make a default sized cache in any case. If autocache is false:; this is a user requested cache. cacheSize is used to size the cache.; This cache should never be automatically adjusted.; Returns 0 size set, or existing autosized cache almost large enough.; (cache was created if possible); -1 on error. Int_t SetCacheEntryRange(Long64_t first, Long64_t last); interface to TTreeCache to set the cache entry range; Returns 0 entry range set; -1 on error. void SetCacheLearnEntries(Int_t n = 10); interface to TTreeCache to set the number of entries for the learning phase. void SetCircular(Long64_t maxEntries); Enable/Disable circularity for this tree. if maxEntries > 0 a maximum of maxEntries is kept in one buffer/basket; per branch in memory.; Note that when this function is called (maxEntries>0) the Tree; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TTree.html:133722,cache,cache,133722,root/html604/TTree.html,https://root.cern,https://root.cern/root/html604/TTree.html,4,['cache'],['cache']
Performance,"nchmarks . ; Contribute . ; Collaborate with Us . You are hereHome » ROOT 6 Analysis Workshop 2. Running code in ROOT. Interpreting; ROOT executes your C++ code. There are two ways: loading it into the interpreter or compiling it as a shared library. Either way, it's easiest to provide a function that has the same name as the file. For instance you could have a file printTree.C containing; int printTree(TFile* file, const char* name) {; TTree* tree = 0;; file->GetObject(name, tree);; if (tree) {; tree->Print();; return 0;; } else {; Error(""printTree()"", ""Cannot find tree %s!"", name);; return -1;; }; }. You can now run this as; .x printTree.C(file, ""MyTree"");. This is equivalent to; .L printTree.C; printTree(file, ""MyTree"");. Compiling; You can also have your code compiled into a shared library, simply by adding a ""+"" behind the file name:; .x printTree.C+(file, ""MyTree"");. In the above example this will fail: we need to add the #includes for he compiler to be able to understand the code, while the interpreter has a lot of contextual knowledge and can automatically include headers and load libraries.; Expressions; You saw that with "".x"", ROOT prints the result of running the function while when using "".L"" and calling th function it does not. The way to trigger the printing of expression results is by omitting the trailing semicolon:; TMath::Gaus(1., 1., 1.). will print; (Double_t) 1.000000e+00. Help!; For TMath::Gaus() as well as for any other ROOT class or function, please check ROOT's reference guide.; Try to find the documentation for TTree::Print()!; We have now covered the basics - let's look at the tree's data!; . ‹ 1. Extracting an object from a TFile; up; 4. Histogramming ›. Navigate through this book; 0. Setting up ROOT; 1. Extracting an object from a TFile; 2. Running code in ROOT; 4. Histogramming; 3. Examining a TTree's data; 5. Fitting; 6. Multivariate Analysis; 7. Using the TTreeReader; 8. Efficiency Calculation; 9. Fitting By Coding; 10. Go Parallel!; T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/2-running-code-root.html:2892,load,load,2892,d/2-running-code-root.html,https://root.cern,https://root.cern/d/2-running-code-root.html,1,['load'],['load']
Performance,"ncipal"" and a reference to it; is added to the list of specials Root objects.; you can retrieve a pointer to the created object via:; TPrincipal *principal =; (TPrincipal*)gROOT->GetListOfSpecials()->FindObject(""principal"");. void Print(Option_t* option = """") const; Print a summary of the tree contents. If option contains ""all"" friend trees are also printed.; If option contains ""toponly"" only the top level branches are printed.; If option contains ""clusters"" information about the cluster of baskets is printed. Wildcarding can be used to print only a subset of the branches, e.g.,; T.Print(""Elec*"") will print all branches with name starting with ""Elec"". void PrintCacheStats(Option_t* option = """") const; print statistics about the TreeCache for this tree, like; ******TreeCache statistics for file: cms2.root ******; Reading 73921562 bytes in 716 transactions; Average transaction = 103.242405 Kbytes; Number of blocks in current cache: 202, total size : 6001193. if option = ""a"" the list of blocks in the cache is printed. Long64_t Process(const char* filename, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Process this tree executing the TSelector code in the specified filename.; The return value is -1 in case of error and TSelector::GetStatus() in; in case of success. The code in filename is loaded (interpreted or compiled, see below),; filename must contain a valid class implementation derived from TSelector,; where TSelector has the following member functions:. Begin(): called every time a loop on the tree starts,; a convenient place to create your histograms.; SlaveBegin(): called after Begin(), when on PROOF called only on the; slave servers.; Process(): called for each event, in this function you decide what; to read and fill your histograms.; SlaveTerminate: called at the end of the loop on the tree, when on PROOF; called only on the slave servers.; Terminate(): called at the end of the loop on the tree,; a convenient place to draw/",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTree.html:116762,cache,cache,116762,root/html534/TTree.html,https://root.cern,https://root.cern/root/html534/TTree.html,6,['cache'],['cache']
Performance,"ncipal"" and a reference to it; is added to the list of specials Root objects.; you can retrieve a pointer to the created object via:; TPrincipal *principal =; (TPrincipal*)gROOT->GetListOfSpecials()->FindObject(""principal"");. void Print(Option_t* option = """") const; Print a summary of the tree contents. If option contains ""all"" friend trees are also printed.; If option contains ""toponly"" only the top level branches are printed.; If option contains ""clusters"" information about the cluster of baskets is printed. Wildcarding can be used to print only a subset of the branches, e.g.,; T.Print(""Elec*"") will print all branches with name starting with ""Elec"". void PrintCacheStats(Option_t* option = """") const; print statistics about the TreeCache for this tree, like; ******TreeCache statistics for file: cms2.root ******; Reading 73921562 bytes in 716 transactions; Average transaction = 103.242405 Kbytes; Number of blocks in current cache: 202, total size : 6001193. if option = ""a"" the list of blocks in the cache is printed. Long64_t Process(const char* filename, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Process this tree executing the TSelector code in the specified filename.; The return value is -1 in case of error and TSelector::GetStatus() in; in case of success. The code in filename is loaded (interpreted or compiled, see below),; filename must contain a valid class implementation derived from TSelector,; where TSelector has the following member functions:. Begin(): called everytime a loop on the tree starts,; a convenient place to create your histograms.; SlaveBegin(): called after Begin(), when on PROOF called only on the; slave servers.; Process(): called for each event, in this function you decide what; to read and fill your histograms.; SlaveTerminate: called at the end of the loop on the tree, when on PROOF; called only on the slave servers.; Terminate(): called at the end of the loop on the tree,; a convenient place to draw/f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TTree.html:110414,cache,cache,110414,root/html530/TTree.html,https://root.cern,https://root.cern/root/html530/TTree.html,3,['cache'],['cache']
Performance,"nclude ""TMVA/Reader.h""; #include ""TMVA/MethodCuts.h""; ; using namespace TMVA;; ; void TMVAClassificationApplication( TString myMethodList = """" ); {; ; //---------------------------------------------------------------; // This loads the library; TMVA::Tools::Instance();; ; // Default MVA methods to be trained + tested; std::map<std::string,int> Use;; ; // Cut optimisation; Use[""Cuts""] = 1;; Use[""CutsD""] = 1;; Use[""CutsPCA""] = 0;; Use[""CutsGA""] = 0;; Use[""CutsSA""] = 0;; //; // 1-dimensional likelihood (""naive Bayes estimator""); Use[""Likelihood""] = 1;; Use[""LikelihoodD""] = 0; // the ""D"" extension indicates decorrelated input variables (see option strings); Use[""LikelihoodPCA""] = 1; // the ""PCA"" extension indicates PCA-transformed input variables (see option strings); Use[""LikelihoodKDE""] = 0;; Use[""LikelihoodMIX""] = 0;; //; // Mutidimensional likelihood and Nearest-Neighbour methods; Use[""PDERS""] = 1;; Use[""PDERSD""] = 0;; Use[""PDERSPCA""] = 0;; Use[""PDEFoam""] = 1;; Use[""PDEFoamBoost""] = 0; // uses generalised MVA method boosting; Use[""KNN""] = 1; // k-nearest neighbour method; //; // Linear Discriminant Analysis; Use[""LD""] = 1; // Linear Discriminant identical to Fisher; Use[""Fisher""] = 0;; Use[""FisherG""] = 0;; Use[""BoostedFisher""] = 0; // uses generalised MVA method boosting; Use[""HMatrix""] = 0;; //; // Function Discriminant analysis; Use[""FDA_GA""] = 1; // minimisation of user-defined function using Genetics Algorithm; Use[""FDA_SA""] = 0;; Use[""FDA_MC""] = 0;; Use[""FDA_MT""] = 0;; Use[""FDA_GAMT""] = 0;; Use[""FDA_MCMT""] = 0;; //; // Neural Networks (all are feed-forward Multilayer Perceptrons); Use[""MLP""] = 0; // Recommended ANN; Use[""MLPBFGS""] = 0; // Recommended ANN with optional training method; Use[""MLPBNN""] = 1; // Recommended ANN with BFGS training method and bayesian regulator; Use[""CFMlpANN""] = 0; // Depreciated ANN from ALEPH; Use[""TMlpANN""] = 0; // ROOT's own ANN; Use[""DNN_CPU""] = 0; // CUDA-accelerated DNN training.; Use[""DNN_GPU""] = 0; // Multi-core accelerated DN",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAClassificationApplication_8C.html:5197,load,loads,5197,doc/master/TMVAClassificationApplication_8C.html,https://root.cern,https://root.cern/doc/master/TMVAClassificationApplication_8C.html,1,['load'],['loads']
Performance,"ncluded; -1 on error . Reimplemented from TFileCacheRead.; Definition at line 350 of file TTreeCache.cxx. ◆ LearnPrefill(). void TTreeCache::LearnPrefill ; (; ). virtual . Perform an initial prefetch, attempting to read as much of the learning phase baskets for all branches at once. ; Definition at line 2250 of file TTreeCache.cxx. ◆ operator=(). TTreeCache & TTreeCache::operator= ; (; const TTreeCache & ; ). privatedelete . ◆ Print(). void TTreeCache::Print ; (; Option_t * ; option = """"); const. overridevirtual . Print cache statistics. ; Like:; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352; sizesize_t size(const MatrixT &matrix)retrieve the size of a square matrix; totalstatic unsigned int totalDefinition TGWin32ProxyDefs.h:40; bytesOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t bytesDefinition TGWin32VirtualXProxy.cxx:245. if option = ""a"" the list of",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCache.html:44438,cache,cache,44438,doc/v632/classTTreeCache.html,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html,1,['cache'],['cache']
Performance,"ncluded; -1 on error . Reimplemented from TFileCacheRead.; Definition at line 350 of file TTreeCache.cxx. ◆ LearnPrefill(). void TTreeCache::LearnPrefill ; (; ). virtual . Perform an initial prefetch, attempting to read as much of the learning phase baskets for all branches at once. ; Definition at line 2251 of file TTreeCache.cxx. ◆ operator=(). TTreeCache & TTreeCache::operator= ; (; const TTreeCache & ; ). privatedelete . ◆ Print(). void TTreeCache::Print ; (; Option_t * ; option = """"); const. overridevirtual . Print cache statistics. ; Like:; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352; sizesize_t size(const MatrixT &matrix)retrieve the size of a square matrix; totalstatic unsigned int totalDefinition TGWin32ProxyDefs.h:40; bytesOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t bytesDefinition TGWin32VirtualXProxy.cxx:245. if option = ""a"" the list of",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeCache.html:44442,cache,cache,44442,doc/master/classTTreeCache.html,https://root.cern,https://root.cern/doc/master/classTTreeCache.html,1,['cache'],['cache']
Performance,"nction by name. ;  ; TFunction * GetGlobalFunctionWithPrototype (const char *name, const char *proto=nullptr, Bool_t load=kFALSE);  Return pointer to global function by name. ;  ; TInterpreter * GetInterpreter () const;  ; TList * GetListOfBrowsables () const;  ; TSeqCollection * GetListOfBrowsers () const;  ; TSeqCollection * GetListOfCanvases () const;  ; TCollection * GetListOfClasses () const;  ; TCollection * GetListOfClassGenerators () const;  ; TSeqCollection * GetListOfCleanups () const;  ; TSeqCollection * GetListOfClosedObjects () const;  ; TSeqCollection * GetListOfColors () const;  ; TSeqCollection * GetListOfDataSets () const;  ; TCollection * GetListOfEnums (Bool_t load=kFALSE);  ; TSeqCollection * GetListOfFiles () const;  ; TCollection * GetListOfFunctionOverloads (const char *name) const;  Return the collection of functions named ""name"". ;  ; TCollection * GetListOfFunctions () const;  ; TCollection * GetListOfFunctionTemplates ();  ; TSeqCollection * GetListOfGeometries () const;  ; TCollection * GetListOfGlobalFunctions (Bool_t load=kFALSE);  Return list containing the TFunctions currently defined. ;  ; TCollection * GetListOfGlobals (Bool_t load=kFALSE);  Return list containing the TGlobals currently defined. ;  ; TSeqCollection * GetListOfMappedFiles () const;  ; TSeqCollection * GetListOfMessageHandlers () const;  ; TSeqCollection * GetListOfProofs () const;  ; TSeqCollection * GetListOfSecContexts () const;  ; TSeqCollection * GetListOfSockets () const;  ; TSeqCollection * GetListOfSpecials () const;  ; TSeqCollection * GetListOfStreamerInfo () const;  ; TSeqCollection * GetListOfStyles () const;  ; TSeqCollection * GetListOfTasks () const;  ; TCollection * GetListOfTypes (Bool_t load=kFALSE);  Return a dynamic list giving access to all TDataTypes (typedefs) currently defined. ;  ; Int_t GetNclasses () const;  Get number of classes. ;  ; Int_t GetNtypes () const;  Get number of types. ;  ; TPluginManager * GetPluginManager () const;  ; TFolder",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTROOT.html:7751,load,load,7751,doc/v632/classTROOT.html,https://root.cern,https://root.cern/doc/v632/classTROOT.html,2,['load'],['load']
Performance,"nction just copies the cached values of source,; 2995/// it is the callers responsibility to make sure the cache is clean.; 2996 ; 2997void RooAbsReal::copyCache(const RooAbsArg* source, bool /*valueOnly*/, bool setValDirty); 2998{; 2999 auto other = static_cast<const RooAbsReal*>(source);; 3000 assert(dynamic_cast<const RooAbsReal*>(source));; 3001 ; 3002 _value = other->_treeReadBuffer ? other->_treeReadBuffer->operator double() : other->_value;; 3003 ; 3004 if (setValDirty) {; 3005 setValueDirty() ;; 3006 }; 3007}; 3008 ; 3009 ; 3010////////////////////////////////////////////////////////////////////////////////; 3011 ; 3012void RooAbsReal::attachToVStore(RooVectorDataStore& vstore); 3013{; 3014 vstore.addReal(this)->setBuffer(this,&_value);; 3015}; 3016 ; 3017 ; 3018////////////////////////////////////////////////////////////////////////////////; 3019/// Attach object to a branch of given TTree. By default it will; 3020/// register the internal value cache RooAbsReal::_value as branch; 3021/// buffer for a double tree branch with the same name as this; 3022/// object. If no double branch is found with the name of this; 3023/// object, this method looks for a Float_t Int_t, UChar_t and UInt_t, etc; 3024/// branch. If any of these are found, a TreeReadBuffer; 3025/// that branch is created, and saved in _treeReadBuffer.; 3026/// TreeReadBuffer::operator double() can be used to convert the values.; 3027/// This is used by copyCache().; 3028void RooAbsReal::attachToTree(TTree& t, Int_t bufSize); 3029{; 3030 // First determine if branch is taken; 3031 TString cleanName(cleanBranchName()) ;; 3032 TBranch* branch = t.GetBranch(cleanName) ;; 3033 if (branch) {; 3034 ; 3035 // Determine if existing branch is Float_t or double; 3036 TLeaf* leaf = static_cast<TLeaf*>(branch->GetListOfLeaves()->At(0)) ;; 3037 ; 3038 // Check that leaf is _not_ an array; 3039 Int_t dummy ;; 3040 TLeaf* counterLeaf = leaf->GetLeafCounter(dummy) ;; 3041 if (counterLeaf) {; 3042 coutE(Eval) << ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8cxx_source.html:130937,cache,cache,130937,doc/master/RooAbsReal_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html,1,['cache'],['cache']
Performance,"nction pointer.; 353 ; 354 // Initially this function pointer's value is & GetROOT1 whose role is to; 355 // create and initialize the TROOT object itself.; 356 // At the very end of the TROOT constructor the value of the function pointer; 357 // is switch to & GetROOT2 whose role is to initialize the interpreter.; 358 ; 359 // This mechanism was primarily intended to fix the issues with order in which; 360 // global TROOT and LLVM globals are initialized. TROOT was initializing; 361 // Cling, but Cling could not be used yet due to LLVM globals not being; 362 // Initialized yet. The solution is to delay initializing the interpreter in; 363 // TROOT till after main() when all LLVM globals are initialized.; 364 ; 365 // Technically, the mechanism used actually delay the interpreter; 366 // initialization until the first use of gROOT *after* the end of the; 367 // TROOT constructor.; 368 ; 369 // So to delay until after the start of main, we also made sure that none; 370 // of the ROOT code (mostly the dictionary code) used during library loading; 371 // is using gROOT (directly or indirectly).; 372 ; 373 // In practice, the initialization of the interpreter is now delayed until; 374 // the first use gROOT (or gInterpreter) after the start of main (but user; 375 // could easily break this by using gROOT in their library initialization; 376 // code).; 377 ; 378 extern TROOT *gROOTLocal;; 379 ; 380 TROOT *GetROOT1() {; 381 if (gROOTLocal); 382 return gROOTLocal;; 383 static TROOTAllocator alloc;; 384 return gROOTLocal;; 385 }; 386 ; 387 TROOT *GetROOT2() {; 388 static Bool_t initInterpreter = kFALSE;; 389 if (!initInterpreter) {; 390 initInterpreter = kTRUE;; 391 gROOTLocal->InitInterpreter();; 392 // Load and init threads library; 393 gROOTLocal->InitThreads();; 394 }; 395 return gROOTLocal;; 396 }; 397 typedef TROOT *(*GetROOTFun_t)();; 398 ; 399 static GetROOTFun_t gGetROOT = &GetROOT1;; 400 ; 401 static Func_t GetSymInLibImt(const char *funcname); 402 {; 403 const st",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8cxx_source.html:12973,load,loading,12973,doc/master/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8cxx_source.html,2,['load'],['loading']
Performance,"nction returning the total number of read calls from all files. ;  ; static Bool_t GetOnlyStaged ();  Returns staged only flag. ;  ; static UInt_t GetOpenTimeout ();  Returns open timeout (in ms). ;  ; static Int_t GetReadaheadSize ();  Static function returning the readahead buffer size. ;  ; static Bool_t GetReadStreamerInfo ();  If the streamerinfos are to be read at file opening. ;  ; static EFileType GetType (const char *name, Option_t *option="""", TString *prefix=nullptr);  Resolve the file type as a function of the protocol field in 'name'. ;  ; static void IncrementFileCounter ();  ; static TFile * Open (const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0);  Create / open a file. ;  ; static TFile * Open (TFileOpenHandle *handle);  Waits for the completion of an asynchronous open request. ;  ; static Bool_t SetCacheFileDir (std::string_view cacheDir, Bool_t operateDisconnected=kTRUE, Bool_t forceCacheread=kFALSE);  Sets the directory where to locally stage/cache remote files. ;  ; static void SetFileBytesRead (Long64_t bytes=0);  ; static void SetFileBytesWritten (Long64_t bytes=0);  ; static void SetFileReadCalls (Int_t readcalls=0);  ; static Bool_t SetOnlyStaged (Bool_t onlystaged);  Sets only staged flag. ;  ; static UInt_t SetOpenTimeout (UInt_t timeout);  Sets open timeout time (in ms). Returns previous timeout value. ;  ; static void SetReadaheadSize (Int_t bufsize=256000);  ; static void SetReadStreamerInfo (Bool_t readinfo=kTRUE);  Specify if the streamerinfos must be read at file opening. ;  ; static Bool_t ShrinkCacheFileDir (Long64_t shrinkSize, Long_t cleanupInteval=0);  Try to shrink the cache to the desired size. ;  ;  Static Public Member Functions inherited from TDirectoryFile; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public M",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTXMLFile.html:29234,cache,cacheDir,29234,doc/master/classTXMLFile.html,https://root.cern,https://root.cern/doc/master/classTXMLFile.html,30,['cache'],"['cache', 'cacheDir']"
Performance,"nction that tells wether the multithreading unzipping is activated.Definition TTreeCacheUnzip.cxx:416; TTreeCacheA cache to speed-up the reading of ROOT datasets.Definition TTreeCache.h:32; TTreeCache::IsAutoCreatedbool IsAutoCreated() constDefinition TTreeCache.h:150; TTreeCache::SetBufferSizeInt_t SetBufferSize(Long64_t buffersize) overrideChange the underlying buffer size of the cache.Definition TTreeCache.cxx:2073; TTreeCache::SetLearnEntriesstatic void SetLearnEntries(Int_t n=10)Static function to set the number of entries to be used in learning mode The default value for n is 1...Definition TTreeCache.cxx:2145; TTreeCache::GetTreeTTree * GetTree() constDefinition TTreeCache.h:149; TTreeCache::SetEntryRangevirtual void SetEntryRange(Long64_t emin, Long64_t emax)Set the minimum and maximum entry number to be processed this information helps to optimize the numbe...Definition TTreeCache.cxx:2106; TTreeCache::DropBranchvirtual Int_t DropBranch(TBranch *b, bool subbranches=false)Remove a branch to the list of branches to be stored in the cache this function is called by TBranch:...Definition TTreeCache.cxx:541; TTreeCache::SetAutoCreatedvoid SetAutoCreated(bool val)Definition TTreeCache.h:164; TTreeCache::StopLearningPhasevirtual void StopLearningPhase()This is the counterpart of StartLearningPhase() and can be used to stop the learning phase.Definition TTreeCache.cxx:2187; TTreeCache::Printvoid Print(Option_t *option="""") const overridePrint cache statistics.Definition TTreeCache.cxx:1899; TTreeCache::AddBranchInt_t AddBranch(TBranch *b, bool subgbranches=false) overrideAdd a branch to the list of branches to be stored in the cache this function is called by the user vi...Definition TTreeCache.cxx:376; TTreeClonerClass implementing or helping the various TTree cloning method.Definition TTreeCloner.h:31; TTreeCloner::kNoWarnings@ kNoWarningsDefinition TTreeCloner.h:100; TTreeCloner::GetWarningconst char * GetWarning() constDefinition TTreeCloner.h:117; TTreeCloner::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:430061,cache,cache,430061,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['cache'],['cache']
Performance,"nction to calculate in parallel process; set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; Bool_t_calcInProgress; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_t_forceCalc; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Bool_t_inlineMode; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_t_pidPID of child process; Int_t_pipeToClient[2]Pipe to client process; Int_t_pip",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooRealMPFE.html:31275,cache,cache,31275,root/html526/RooRealMPFE.html,https://root.cern,https://root.cern/root/html526/RooRealMPFE.html,3,['cache'],['cache']
Performance,nction using an adaptive method or MonteCarlo Integration (GSLMCIntegrator). The basic classes ROOT::Math::IntegratorOneDim provides a common interface for the one-dimensional methods while the class ROOT::Math::IntegratorMultiDim provides the interface for the multi-dimensional ones. The methods can be configured (e.g setting the default method with its default parameters) using the ROOT::Math::IntegratorOneDimOptions and ROOT::Math::IntegratorMultiDimOptions classes. . Modules;  Numerical Monte Carlo Integration Classes;  Classes implementing method for Monte Carlo Integration. ;  . Classes; class  ROOT::Math::AdaptiveIntegratorMultiDim;  Class for adaptive quadrature integration in multi-dimensions using rectangular regions. More...;  ; class  ROOT::Math::BaseIntegratorOptions;  Base class for Numerical integration options common in 1D and multi-dimension This is an internal class and is not supposed to be instantiated by the user. More...;  ; class  ROOT::Math::GaussIntegrator;  User class for performing function integration. More...;  ; class  ROOT::Math::GaussLegendreIntegrator;  User class for performing function integration. More...;  ; class  ROOT::Math::GSLIntegrator;  Class for performing numerical integration of a function in one dimension. More...;  ; class  ROOT::Math::IntegratorMultiDim;  User class for performing multidimensional integration. More...;  ; class  ROOT::Math::IntegratorMultiDimOptions;  Numerical multi dimensional integration options. More...;  ; class  ROOT::Math::IntegratorOneDim;  User Class for performing numerical integration of a function in one dimension. More...;  ; class  ROOT::Math::IntegratorOneDimOptions;  Numerical one dimensional integration options. More...;  ; class  ROOT::Math::VirtualIntegrator;  Abstract class for all numerical integration methods (1D and multi-dim) Interface defining the common methods for the numerical integrator classes of one and multi dimensions The derived class VirtualIntegratorOneDim defines th,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Integration.html:1462,perform,performing,1462,doc/master/group__Integration.html,https://root.cern,https://root.cern/doc/master/group__Integration.html,1,['perform'],['performing']
Performance,"nction will return; only when an incoming TERMINATE message is received. void calculate() const; Client-side function that instructs server process to start; asynchronuous (re)calculation of function value. This function; returns immediately. The calculated value can be retrieved; using getVal(). Double_t getValV(const RooArgSet* nset = 0) const; If value needs recalculation and calculation has not beed started; with a call to calculate() start it now. This function blocks; until remote process has finished calculation and returns; remote value. Double_t evaluate() const; Send message to server process to retrieve output value; If error were logged use logEvalError() on remote side; transfer those errors to the local eval error queue. void standby(); Terminate remote server process and return front-end class; to standby mode. Calls to calculate() or evaluate() after; this call will automatically recreated the server process. void constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTracking = kTRUE); Intercept call to optimize constant term in test statistics; and forward it to object on server side. void setVerbose(Bool_t clientFlag = kTRUE, Bool_t serverFlag = kTRUE); Control verbose messaging related to inter process communication; on both client and server side. void applyNLLWeightSquared(Bool_t flag); Control verbose messaging related to inter process communication; on both client and server side. void doApplyNLLW2(Bool_t flag). void enableOffsetting(Bool_t flag); Control verbose messaging related to inter process communication; on both client and server side. TObject* clone(const char* newname) const; { return new RooRealMPFE(*this,newname); }. void followAsSlave(RooRealMPFE& master); { _updateMaster = &master ; }. » Last changed: Tue Jun 2 15:33:24 2015 » Last generated: 2015-06-02 15:33; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooRealMPFE.html:41275,optimiz,optimize,41275,root/html604/RooRealMPFE.html,https://root.cern,https://root.cern/root/html604/RooRealMPFE.html,2,['optimiz'],['optimize']
Performance,"nction.reset(fExtObjFunction->Clone());; 820 fResult->fObjFunc = fObjFunction;; 821 fResult->fFitData = fData;; 822 ; 823#ifdef DEBUG; 824 std::cout << ""ROOT::Fit::Fitter::DoMinimization : ncalls = "" << fResult->fNCalls << "" type of objfunc "" << fFitFitResType << "" typeid: "" << typeid(*fObjFunction).name() << "" use gradient "" << fUseGradient << std::endl;; 825#endif; 826 ; 827 if (fConfig.NormalizeErrors() && fFitType == ROOT::Math::FitMethodFunction::kLeastSquare ); 828 fResult->NormalizeErrors();; 829 ; 830 // set also new parameter values and errors in FitConfig; 831 if (fConfig.UpdateAfterFit() && isValid) DoUpdateFitConfig();; 832 ; 833 return isValid;; 834}; 835template<class ObjFunc_t>; 836bool Fitter::DoMinimization(std::unique_ptr<ObjFunc_t> objFunc, const ROOT::Math::IMultiGenFunction * chi2func) {; 837 // perform the minimization initializing the minimizer starting from a given obj function; 838 fFitType = objFunc->Type();; 839 fExtObjFunction = nullptr;; 840 fObjFunction = std::move(objFunc);; 841 if (!DoInitMinimizer()) return false;; 842 return DoMinimization(chi2func);; 843}; 844template<class ObjFunc_t>; 845bool Fitter::DoWeightMinimization(std::unique_ptr<ObjFunc_t> objFunc, const ROOT::Math::IMultiGenFunction * chi2func) {; 846 // perform the minimization initializing the minimizer starting from a given obj function; 847 // and apply afterwards the correction for weights. This applies only for logL fitting; 848 this->fFitType = objFunc->Type();; 849 fExtObjFunction = nullptr;; 850 // need to use a temporary shared pointer to the objective function since we cannot use the unique pointer when it has been moved; 851 std::shared_ptr<ObjFunc_t> sObjFunc{ std::move(objFunc)};; 852 fObjFunction = sObjFunc;; 853 if (!DoInitMinimizer()) return false;; 854 if (!DoMinimization(chi2func)) return false;; 855 sObjFunc->UseSumOfWeightSquare();; 856 return ApplyWeightCorrection(*sObjFunc);; 857}; 858 ; 859 ; 860void Fitter::DoUpdateFitConfig() {; 861 // update the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Fitter_8cxx_source.html:32354,perform,perform,32354,doc/master/Fitter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html,2,['perform'],['perform']
Performance,"nction::kSymmRelu@ kSymmRelu; TMVA::DNN::ELossFunctionELossFunctionEnum that represents objective functions for the net, i.e.Definition Functions.h:57; TMVA::DNN::TMVAInput_tstd::tuple< const std::vector< Event * > &, const DataSetInfo & > TMVAInput_tDefinition DataLoader.h:40; TMVAcreate variable transformationsDefinition GeneticMinimizer.h:22; TMVA::gConfigConfig & gConfig(); TMVA::gToolsTools & gTools(); TMVA::fetchValueTmpTString fetchValueTmp(const std::map< TString, TString > &keyValueMap, TString key)Definition MethodDL.cxx:75; TMVA::EndlMsgLogger & Endl(MsgLogger &ml)Definition MsgLogger.h:148; TMath::IsNaNBool_t IsNaN(Double_t x)Definition TMath.h:892; TMath::LogDouble_t Log(Double_t x)Returns the natural logarithm of x.Definition TMath.h:756; TMVA::TTrainingSettingsAll of the options that can be specified in the training string.Definition MethodDL.h:72; TMVA::TTrainingSettings::batchSizesize_t batchSizeDefinition MethodDL.h:73; TMVA::TTrainingSettings::optimizerParamsstd::map< TString, double > optimizerParamsDefinition MethodDL.h:84; TMVA::TTrainingSettings::optimizerNameTString optimizerNameDefinition MethodDL.h:79; TMVA::TTrainingSettings::optimizerDNN::EOptimizer optimizerDefinition MethodDL.h:78; TMVA::TTrainingSettings::maxEpochssize_t maxEpochsDefinition MethodDL.h:76; TMVA::TTrainingSettings::momentumDouble_t momentumDefinition MethodDL.h:81; TMVA::TTrainingSettings::weightDecayDouble_t weightDecayDefinition MethodDL.h:82; TMVA::TTrainingSettings::testIntervalsize_t testIntervalDefinition MethodDL.h:74; TMVA::TTrainingSettings::regularizationDNN::ERegularization regularizationDefinition MethodDL.h:77; TMVA::TTrainingSettings::convergenceStepssize_t convergenceStepsDefinition MethodDL.h:75; TMVA::TTrainingSettings::dropoutProbabilitiesstd::vector< Double_t > dropoutProbabilitiesDefinition MethodDL.h:83; TMVA::TTrainingSettings::learningRateDouble_t learningRateDefinition MethodDL.h:80; mTMarker mDefinition textangle.C:8; lTLine lDefinition textangle.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDL_8cxx_source.html:121316,optimiz,optimizerParamsstd,121316,doc/master/MethodDL_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDL_8cxx_source.html,2,['optimiz'],"['optimizerParamsDefinition', 'optimizerParamsstd']"
Performance,"nction; This method stops the manager,; flashes all the buffered data and closes the output tree. void SetBufferSize(Int_t buffersize); Set the maximum number of alloc/free calls to be buffered.; if the alloc and free are in the buffer, the corresponding entries; are not saved tio the Tree, reducing considerably the Tree output size. void SetMaxCalls(Int_t maxcalls); Set the maximum number of new/delete registered in the output Tree. void Enable(); Enable memory hooks. void Disable(); Disble memory hooks. void MacAllocHook(void* ptr, size_t size); AllocHook - a static function; a special memory hook for Mac OS X memory zones.; Triggered when memory is allocated. void MacFreeHook(void* ptr); AllocHook - a static function; a special memory hook for Mac OS X memory zones.; Triggered when memory is deallocated. void * AllocHook(size_t size, const void* ); AllocHook - a static function; A glibc memory allocation hook. void FreeHook(void* ptr, const void* ); FreeHook - a static function; A glibc memory deallocation hook. Int_t generateBTID(UChar_t* CRCdigest, Int_t stackEntries, void** stackPointers); An internal function, which returns a bitid for a corresponding CRC digest; cache variables. void AddPointer(void* ptr, Int_t size); Add pointer to table.; This method is called every time when any of the hooks are triggered.; The memory de-/allocation information will is recorded. void FillTree(); loop on all entries in the buffer and fill the output Tree; entries with alloc and free in the buffer are eliminated. TMemStatMng(). void SetUseGNUBuiltinBacktrace(Bool_t newVal); stack data members. » Author: Anar Manafov (A.Manafov@gsi.de) 2008-03-02 » Copyright (C) 1995-2010, Rene Brun and Fons Rademakers. *; » Last changed: root/memstat:$Id: TMemStatMng.h 36382 2010-10-20 12:27:40Z brun $ » Last generated: 2010-11-27 09:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/memstat__TMemStatMng.html:8383,cache,cache,8383,root/html528/memstat__TMemStatMng.html,https://root.cern,https://root.cern/root/html528/memstat__TMemStatMng.html,1,['cache'],['cache']
Performance,"nction; This method stops the manager,; flashes all the buffered data and closes the output tree. void SetBufferSize(Int_t buffersize); Set the maximum number of alloc/free calls to be buffered.; if the alloc and free are in the buffer, the corresponding entries; are not saved tio the Tree, reducing considerably the Tree output size. void SetMaxCalls(Int_t maxcalls); Set the maximum number of new/delete registered in the output Tree. void Enable(); Enable memory hooks. void Disable(); Disble memory hooks. void MacAllocHook(void* ptr, size_t size); AllocHook - a static function; a special memory hook for Mac OS X memory zones.; Triggered when memory is allocated. void MacFreeHook(void* ptr); AllocHook - a static function; a special memory hook for Mac OS X memory zones.; Triggered when memory is deallocated. void * AllocHook(size_t size, const void* ); AllocHook - a static function; A glibc memory allocation hook. void FreeHook(void* ptr, const void* ); FreeHook - a static function; A glibc memory deallocation hook. Int_t generateBTID(UChar_t* CRCdigest, Int_t stackEntries, void** stackPointers); An internal function, which returns a bitid for a corresponding CRC digest; cache variables. void AddPointer(void* ptr, Int_t size); Add pointer to table.; This method is called every time when any of the hooks are triggered.; The memory de-/allocation information will is recorded. void FillTree(); loop on all entries in the buffer and fill the output Tree; entries with alloc and free in the buffer are eliminated. TMemStatMng(). void SetUseGNUBuiltinBacktrace(Bool_t newVal); stack data members. » Author: Anar Manafov (A.Manafov@gsi.de) 2008-03-02 » Copyright (C) 1995-2010, Rene Brun and Fons Rademakers. *; » Last changed: root/memstat:$Id: TMemStatMng.h 36382 2010-10-20 12:27:40Z brun $ » Last generated: 2011-07-04 15:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/memstat__TMemStatMng.html:8452,cache,cache,8452,root/html530/memstat__TMemStatMng.html,https://root.cern,https://root.cern/root/html530/memstat__TMemStatMng.html,1,['cache'],['cache']
Performance,"nction; This method stops the manager,; flashes all the buffered data and closes the output tree. void SetBufferSize(Int_t buffersize); Set the maximum number of alloc/free calls to be buffered.; if the alloc and free are in the buffer, the corresponding entries; are not saved tio the Tree, reducing considerably the Tree output size. void SetMaxCalls(Int_t maxcalls); Set the maximum number of new/delete registered in the output Tree. void Enable(); Enable memory hooks. void Disable(); Disble memory hooks. void MacAllocHook(void* ptr, size_t size); AllocHook - a static function; a special memory hook for Mac OS X memory zones.; Triggered when memory is allocated. void MacFreeHook(void* ptr); AllocHook - a static function; a special memory hook for Mac OS X memory zones.; Triggered when memory is deallocated. void * AllocHook(size_t size, const void* ); AllocHook - a static function; A glibc memory allocation hook. void FreeHook(void* ptr, const void* ); FreeHook - a static function; A glibc memory deallocation hook. Int_t generateBTID(UChar_t* CRCdigest, Int_t stackEntries, void** stackPointers); An internal function, which returns a bitid for a corresponding CRC digest; cache variables. void AddPointer(void* ptr, Int_t size); Add pointer to table.; This method is called every time when any of the hooks are triggered.; The memory de-/allocation information will is recorded. void FillTree(); loop on all entries in the buffer and fill the output Tree; entries with alloc and free in the buffer are eliminated. TMemStatMng(). void SetUseGNUBuiltinBacktrace(Bool_t newVal); stack data members. » Author: Anar Manafov (A.Manafov@gsi.de) 2008-03-02 » Copyright (C) 1995-2010, Rene Brun and Fons Rademakers. *; » Last changed: root/memstat:$Id: TMemStatMng.h 36382 2010-10-20 12:27:40Z brun $ » Last generated: 2011-11-03 20:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/memstat__TMemStatMng.html:8452,cache,cache,8452,root/html532/memstat__TMemStatMng.html,https://root.cern,https://root.cern/root/html532/memstat__TMemStatMng.html,1,['cache'],['cache']
Performance,"nctionCalls(); }; 295 ; 296 /// max iterations; 297 unsigned int MaxIterations() const { return fOptions.MaxIterations(); }; 298 ; 299 /// absolute tolerance; 300 double Tolerance() const { return fOptions.Tolerance(); }; 301 ; 302 /// precision of minimizer in the evaluation of the objective function; 303 /// ( a value <=0 corresponds to the let the minimizer choose its default one); 304 double Precision() const { return fOptions.Precision(); }; 305 ; 306 /// strategy; 307 int Strategy() const { return fOptions.Strategy(); }; 308 ; 309 /// status code of minimizer; 310 int Status() const { return fStatus; }; 311 ; 312 /// status code of Minos (to be re-implemented by the minimizers supporting Minos); 313 virtual int MinosStatus() const { return -1; }; 314 ; 315 /// return the statistical scale used for calculate the error; 316 /// is typically 1 for Chi2 and 0.5 for likelihood minimization; 317 double ErrorDef() const { return fOptions.ErrorDef(); }; 318 ; 319 ///return true if Minimizer has performed a detailed error validation (e.g. run Hesse for Minuit); 320 bool IsValidError() const { return fValidError; }; 321 ; 322 /// retrieve the minimizer options (implement derived class if needed); 323 virtual MinimizerOptions Options() const {; 324 return fOptions;; 325 }; 326 ; 327 /// set print level; 328 void SetPrintLevel(int level) { fOptions.SetPrintLevel(level); }; 329 ; 330 ///set maximum of function calls; 331 void SetMaxFunctionCalls(unsigned int maxfcn) { if (maxfcn > 0) fOptions.SetMaxFunctionCalls(maxfcn); }; 332 ; 333 /// set maximum iterations (one iteration can have many function calls); 334 void SetMaxIterations(unsigned int maxiter) { if (maxiter > 0) fOptions.SetMaxIterations(maxiter); }; 335 ; 336 /// set the tolerance; 337 void SetTolerance(double tol) { fOptions.SetTolerance(tol); }; 338 ; 339 /// set in the minimizer the objective function evaluation precision; 340 /// ( a value <=0 means the minimizer will choose its optimal value automatically, i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Minimizer_8h_source.html:14316,perform,performed,14316,doc/master/Minimizer_8h_source.html,https://root.cern,https://root.cern/doc/master/Minimizer_8h_source.html,1,['perform'],['performed']
Performance,"nctions inherited from TClass; static void AddClass (TClass *cl);  static: Add a class to the list and map of classes. ;  ; static void AddClassToDeclIdMap (TDictionary::DeclId_t id, TClass *cl);  static: Add a TClass* to the map of classes. ;  ; static Bool_t AddRule (const char *rule);  Add a schema evolution customization rule. ;  ; static Int_t AutoBrowse (TObject *obj, TBrowser *browser);  Browse external object inherited from TObject. ;  ; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; template<typename T > ; static TClass * GetClass (Bool_t load=kTRUE, Bool_t silent=kFALSE);  ; static TClass * GetClass (ClassInfo_t *info, Bool_t load=kTRUE, Bool_t silent=kFALSE);  Static method returning pointer to TClass of the specified ClassInfo. ;  ; static TClass * GetClass (const char *name, Bool_t load, Bool_t silent, size_t hint_pair_offset, size_t hint_pair_size);  ; static TClass * GetClass (const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE);  Static method returning pointer to TClass of the specified class name. ;  ; static TClass * GetClass (const std::type_info &typeinfo, Bool_t load=kTRUE, Bool_t silent=kFALSE, size_t hint_pair_offset=0, size_t hint_pair_size=0);  Return pointer to class with name. ;  ; static Bool_t GetClass (DeclId_t id, std::vector< TClass * > &classes);  ; static DictFuncPtr_t GetDict (const char *cname);  Return a pointer to the dictionary loading function generated by rootcint. ;  ; static DictFuncPtr_t GetDict (const std::type_info &info);  Return a pointer to the dictionary loading function generated by rootcint. ;  ; static Bool_t HasDictionarySelection (const char *clname);  Check whether a class has a dictionary or ROOT can load one. ;  ; static ENewType IsCallingNew ();  Static method returning the defConstructor flag passed to TClass::New(). ;  ; static TClass * Load (TBuffer &b);  Load class description from I/O buffer",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQClass.html:33716,load,load,33716,doc/master/classTQClass.html,https://root.cern,https://root.cern/doc/master/classTQClass.html,2,['load'],['load']
Performance,"nctions |; Private Member Functions |; Private Attributes |; Static Private Attributes |; Friends |; List of all members ; TProofLite Class ReferencePROOF » PROOF kernel Libraries. ; This class starts a PROOF session on the local machine: no daemons, client and master merged, communications via UNIX-like sockets. ; By default the number of workers started is NumberOfCores+1; a different number can be forced on construction. ; Definition at line 40 of file TProofLite.h. Public Member Functions;  TProofLite (const char *masterurl, const char *conffile=kPROOF_ConfFile, const char *confdir=kPROOF_ConfDir, Int_t loglevel=0, const char *alias=0, TProofMgr *mgr=0);  Create a PROOF environment. ;  ;  ~TProofLite () override;  Destructor. ;  ; Bool_t CancelStagingDataSet (const char *dataset) override;  Cancels a dataset staging request. ;  ; void ClearCache (const char *file=0) override;  Remove files from all file caches. ;  ; void ClearDataSetCache (const char *dataset=0) override;  Clear the content of the dataset cache, if any (matching 'dataset', if defined). ;  ; Long64_t DrawSelect (TDSet *dset, const char *varexp, const char *selection="""", Option_t *option="""", Long64_t nentries=-1, Long64_t firstentry=0) override;  Execute the specified drawing action on a data set (TDSet). ;  ; Bool_t ExistsDataSet (const char *uri) override;  Returns kTRUE if 'dataset' described by 'uri' exists, kFALSE otherwise. ;  ; TFileCollection * GetDataSet (const char *uri, const char *=0) override;  Get a list of TFileInfo objects describing the files of the specified dataset. ;  ; TMap * GetDataSets (const char *uri="""", const char *=0) override;  lists all datasets that match given uri ;  ; TList * GetListOfQueries (Option_t *opt="""") override;  Get the list of queries. ;  ; TFileCollection * GetStagingStatusDataSet (const char *dataset) override;  Obtains a TFileCollection showing the staging status of the specified dataset. ;  ; TTree * GetTreeHeader (TDSet *tdset) override;  Creates a t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofLite.html:1245,cache,cache,1245,doc/master/classTProofLite.html,https://root.cern,https://root.cern/doc/master/classTProofLite.html,1,['cache'],['cache']
Performance,"nctions). void SetFCN(void* ). void SetMinuitFCN(ROOT::Minuit2::FCNBase* f); set FCN using Minuit interface; you pass to the class ownership of FCNBase pointer. const ROOT::Minuit2::FCNBase * GetMinuitFCN() const; { return fMinuitFCN; }. const ROOT::Minuit2::ModularFunctionMinimizer * GetMinimizer() const; { return fMinimizer; }. int Minimize(int nfcn = 0, double edmval = 0.1); additional abstract methods to be implemented by derived classes. int GetStrategy(); { return fStrategy; }. int PrintLevel(); { return fDebug; }. void SetStrategy(int stra); { fStrategy = stra; }. void SetPrintLevel(int level); { fDebug = level; }. void SetMinimumTolerance(double mintol); set minimum tolerance to avoid having clients (as TGraf::Fit) setting tolerances too small. { fMinTolerance = mintol; }. double MinimumTolerance() const; { return fMinTolerance; }. void CreateMinimizer(TFitterMinuit::EMinimizerType = kMigrad); create the minimizer type (Migard or Simplex); can be re-implemented in the derived classes. void SetMinimizer(ROOT::Minuit2::ModularFunctionMinimizer* m); { fMinimizer = m; }. void CreateChi2FCN(); functions to create FCN - re-implemented in derived class (GFumili). void CreateChi2ExtendedFCN(). void CreateBinLikelihoodFCN(). void CreateUnbinLikelihoodFCN(); {}. ROOT::Minuit2::FunctionMinimum DoMinimization(int nfcn = 0, double edmval = 0.1); internal function to perform the actual minimization (could be implemented by derived classes). int ExamineMinimum(const ROOT::Minuit2::FunctionMinimum& ); internal funcition to study Function minimum results; return 0 if function minimum is OK or an error code. void Initialize(). » Author: L. Moneta 10/2005 » Copyright (c) 2005 ROOT Foundation, CERN/PH-SFT *; » Last changed: root/minuit2:$Id: TFitterMinuit.h 20880 2007-11-19 11:23:41Z rdm $ » Last generated: 2010-12-15 15:11; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFitterMinuit.html:14273,perform,perform,14273,root/html528/TFitterMinuit.html,https://root.cern,https://root.cern/root/html528/TFitterMinuit.html,1,['perform'],['perform']
Performance,"nctions). void SetFCN(void* ). void SetMinuitFCN(ROOT::Minuit2::FCNBase* f); set FCN using Minuit interface; you pass to the class ownership of FCNBase pointer. const ROOT::Minuit2::FCNBase * GetMinuitFCN() const; { return fMinuitFCN; }. const ROOT::Minuit2::ModularFunctionMinimizer * GetMinimizer() const; { return fMinimizer; }. int Minimize(int nfcn = 0, double edmval = 0.1); additional abstract methods to be implemented by derived classes. int GetStrategy(); { return fStrategy; }. int PrintLevel(); { return fDebug; }. void SetStrategy(int stra); { fStrategy = stra; }. void SetPrintLevel(int level); { fDebug = level; }. void SetMinimumTolerance(double mintol); set minimum tolerance to avoid having clients (as TGraf::Fit) setting tolerances too small. { fMinTolerance = mintol; }. double MinimumTolerance() const; { return fMinTolerance; }. void CreateMinimizer(TFitterMinuit::EMinimizerType = kMigrad); create the minimizer type (Migard or Simplex); can be re-implemented in the derived classes. void SetMinimizer(ROOT::Minuit2::ModularFunctionMinimizer* m); { fMinimizer = m; }. void CreateChi2FCN(); functions to create FCN - re-implemented in derived class (GFumili). void CreateChi2ExtendedFCN(). void CreateBinLikelihoodFCN(). void CreateUnbinLikelihoodFCN(); {}. ROOT::Minuit2::FunctionMinimum DoMinimization(int nfcn = 0, double edmval = 0.1); internal function to perform the actual minimization (could be implemented by derived classes). int ExamineMinimum(const ROOT::Minuit2::FunctionMinimum& ); internal funcition to study Function minimum results; return 0 if function minimum is OK or an error code. void Initialize(). » Author: L. Moneta 10/2005 » Copyright (c) 2005 ROOT Foundation, CERN/PH-SFT *; » Last changed: root/minuit2:$Id: TFitterMinuit.h 20880 2007-11-19 11:23:41Z rdm $ » Last generated: 2011-07-04 15:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TFitterMinuit.html:14344,perform,perform,14344,root/html530/TFitterMinuit.html,https://root.cern,https://root.cern/root/html530/TFitterMinuit.html,1,['perform'],['perform']
Performance,"nctions). void SetFCN(void* ). void SetMinuitFCN(ROOT::Minuit2::FCNBase* f); set FCN using Minuit interface; you pass to the class ownership of FCNBase pointer. const ROOT::Minuit2::FCNBase * GetMinuitFCN() const; { return fMinuitFCN; }. const ROOT::Minuit2::ModularFunctionMinimizer * GetMinimizer() const; { return fMinimizer; }. int Minimize(int nfcn = 0, double edmval = 0.1); additional abstract methods to be implemented by derived classes. int GetStrategy(); { return fStrategy; }. int PrintLevel(); { return fDebug; }. void SetStrategy(int stra); { fStrategy = stra; }. void SetPrintLevel(int level); { fDebug = level; }. void SetMinimumTolerance(double mintol); set minimum tolerance to avoid having clients (as TGraf::Fit) setting tolerances too small. { fMinTolerance = mintol; }. double MinimumTolerance() const; { return fMinTolerance; }. void CreateMinimizer(TFitterMinuit::EMinimizerType = kMigrad); create the minimizer type (Migard or Simplex); can be re-implemented in the derived classes. void SetMinimizer(ROOT::Minuit2::ModularFunctionMinimizer* m); { fMinimizer = m; }. void CreateChi2FCN(); functions to create FCN - re-implemented in derived class (GFumili). void CreateChi2ExtendedFCN(). void CreateBinLikelihoodFCN(). void CreateUnbinLikelihoodFCN(); {}. ROOT::Minuit2::FunctionMinimum DoMinimization(int nfcn = 0, double edmval = 0.1); internal function to perform the actual minimization (could be implemented by derived classes). int ExamineMinimum(const ROOT::Minuit2::FunctionMinimum& ); internal funcition to study Function minimum results; return 0 if function minimum is OK or an error code. void Initialize(). » Author: L. Moneta 10/2005 » Copyright (c) 2005 ROOT Foundation, CERN/PH-SFT *; » Last changed: root/minuit2:$Id: TFitterMinuit.h 20880 2007-11-19 11:23:41Z rdm $ » Last generated: 2011-12-02 14:27; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TFitterMinuit.html:14344,perform,perform,14344,root/html532/TFitterMinuit.html,https://root.cern,https://root.cern/root/html532/TFitterMinuit.html,2,['perform'],['perform']
Performance,"nd DN.; const char *password: Password. Usually you have to specify bind DN and; password to have the write permissions. Default; values for bind DN and password are zero, that means; anonymous connection. Usually it is enough to read; the data from the server.; Int_t version Set LDAP protocol version: LDAP_VERSION1,; LDAP_VERSION2, LDAP_VERSION3. TLDAPServer(const TLDAPServer& ); Copy constructor. TLDAPServer& operator=(const TLDAPServer& ); Equal operator. ~TLDAPServer(); If the object is connected to the server, it disconnects. Int_t Bind(); Binds to the server with specified binddn and password.; Return value: LDAP error code, 0 if successfully bound. void Unbind(); Unbinds from the server with specified binddn and password. const char * GetNamingContexts(); Performs an LDAPSearch with the attribute ""namingContexts"" to be; returned with the result. The value of this attribute is; extracted and returned as const char. const char * GetSubschemaSubentry(); Performs an LDAPSearch with the attribute ""subschemaSubentry"" to; be returned with the result. The value of this attribute is; extracted and returned as const char. TLDAPResult * GetObjectClasses(); Calls GetSubschemaSubentry() and performs and LDAPSearch with; the attribute ""objectClasses"" to be returned with the result.; The returned result object must be deleted by the user. TLDAPResult * GetAttributeTypes(); Calls GetSubschemaSubentry() and performs and LDAPSearch with the; attribute ""attributeTypes"" to be returned with the result.; The returned result object must be deleted by the user. TLDAPResult * Search(const char* base = """", Int_t scope = LDAP_SCOPE_BASE, const char* filter = 0, TList* attrs = 0, Bool_t attrsonly = 0); Performs searching at the LDAP directory.; Return value: a TLDAPResult object or 0 in case of error.; Result needs to be deleted by user.; const char *base: Specifies the base object for the search operation; Int_t scope: Specifies the portion of the LDAP tree, relative to; the base objec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TLDAPServer.html:7492,Perform,Performs,7492,root/html532/TLDAPServer.html,https://root.cern,https://root.cern/root/html532/TLDAPServer.html,1,['Perform'],['Performs']
Performance,"nd a NULL pointer is returned.; 2147///; 2148/// NOTE that the Y axis attributes of the TH2 are copied to the X axis of the profile.; 2149///; 2150/// NOTE that the default under- / overflow behavior differs from what ProjectionX; 2151/// does! Profiles take the bin center into account, so here the under- and overflow; 2152/// bins are ignored by default.; 2153///; 2154/// NOTE that the return profile histogram is computed using the X bin center values instead of; 2155/// the real X values which are used to fill the 2d histogram. Therefore the obtained profile is just an approximation of the; 2156/// correct profile histogram that would be obtained when filling it directly with the original data (see ROOT-7770); 2157 ; 2158 ; 2159TProfile *TH2::ProfileY(const char *name, Int_t firstxbin, Int_t lastxbin, Option_t *option) const; 2160{; 2161 return DoProfile(false, name, firstxbin, lastxbin, option);; 2162}; 2163 ; 2164 ; 2165////////////////////////////////////////////////////////////////////////////////; 2166/// Internal (protected) method for performing projection on the X or Y axis; 2167/// called by ProjectionX or ProjectionY; 2168 ; 2169TH1D *TH2::DoProjection(bool onX, const char *name, Int_t firstbin, Int_t lastbin, Option_t *option) const; 2170{; 2171 const char *expectedName = nullptr;; 2172 Int_t inNbin;; 2173 const TAxis* outAxis;; 2174 const TAxis* inAxis;; 2175 ; 2176 TString opt = option;; 2177 TString cut;; 2178 Int_t i1 = opt.Index(""["");; 2179 if (i1>=0) {; 2180 Int_t i2 = opt.Index(""]"");; 2181 cut = opt(i1,i2-i1+1);; 2182 }; 2183 opt.ToLower(); //must be called after having parsed the cut name; 2184 bool originalRange = opt.Contains(""o"");; 2185 ; 2186 if ( onX ); 2187 {; 2188 expectedName = ""_px"";; 2189 inNbin = fYaxis.GetNbins();; 2190 outAxis = GetXaxis();; 2191 inAxis = GetYaxis();; 2192 }; 2193 else; 2194 {; 2195 expectedName = ""_py"";; 2196 inNbin = fXaxis.GetNbins();; 2197 outAxis = GetYaxis();; 2198 inAxis = GetXaxis();; 2199 }; 2200 ; 2201 // ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH2_8cxx_source.html:88682,perform,performing,88682,doc/master/TH2_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html,1,['perform'],['performing']
Performance,"nd also in TTree::Set... void SetUnzipBufferSize(Long64_t bufferSize); Sets the size for the unzipping cache... by default it should be; two times the size of the prefetching cache. Int_t UnzipBuffer(char** dest, char* src); UNzips a ROOT specific buffer... by reading the header at the beginning.; returns the size of the inflated buffer or -1 if error; Note!! : If *dest == 0 we will allocate the buffer and it will be the; responsability of the caller to free it... it is useful for example; to pass it to the creator of TBuffer; src is the original buffer with the record (header+compressed data); *dest is the inflated buffer (including the header). Int_t UnzipCache(Int_t& startindex, Int_t& locbuffsz, char*& locbuff); This inflates all the buffers in the cache.. passing the data to a new; buffer that will only wait there to be read...; We can not inflate all the buffers in the cache so we will try to do; it until the cache gets full... there is a member called fUnzipBufferSize which will; tell us the max size we can allocate for this cache. note that we will unzip in the order they were put into the cache not; the order of the transference so it has to be read in that order or the; pre-unzipping will be useless. startindex is used as start index to check for blks to be unzipped. returns 0 in normal conditions or -1 if error, 1 if it would like to sleep. This func is supposed to compete among an indefinite number of threads to get a chunk to inflate; in order to accommodate multiple unzippers; Since everything is so async, we cannot use a fixed buffer, we are forced to keep; the individual chunks as separate blocks, whose summed size does not exceed the maximum; allowed. The pointers are kept globally in the array fUnzipChunks. void Print(Option_t* option = """") const. Int_t ReadBufferExt(char* buf, Long64_t pos, Int_t len, Int_t& loc). TTreeCacheUnzip(const TTreeCacheUnzip& ). TTreeCacheUnzip& operator=(const TTreeCacheUnzip& ). EParUnzipMode GetParallelUnzip(); Methods",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreeCacheUnzip.html:18176,cache,cache,18176,root/html528/TTreeCacheUnzip.html,https://root.cern,https://root.cern/root/html528/TTreeCacheUnzip.html,10,['cache'],['cache']
Performance,"nd binning specified in xlo,xhi and nBins. ; The dimensions of the arrays xlo,xhi, nBins should match the number of objects in vars. ; Definition at line 897 of file RooAbsRealLValue.cxx. ◆ createIntegral(). RooFit::OwningPtr< RooAbsReal > RooAbsRealLValue::createIntegral ; (; const RooArgSet & ; iset, . const RooArgSet * ; nset = nullptr, . const RooNumIntConfig * ; cfg = nullptr, . const char * ; rangeName = nullptr . ); const. overridevirtual . Create an object that represents the integral of the function over one or more observables listed in iset. ; The actual integration calculation is only performed when the return object is evaluated. The name of the integral object is automatically constructed from the name of the input function, the variables it integrates and the range integrates over. If nset is specified the integrand is request to be normalized over nset (only meaningful when the integrand is a pdf). If rangename is specified the integral is performed over the named range, otherwise it is performed over the domain of each integrated observable. If cfg is specified it will be used to configure any numeric integration aspect of the integral. It will not force the integral to be performed numerically, which is decided automatically by RooRealIntegral. ; Reimplemented from RooAbsReal.; Definition at line 1056 of file RooAbsRealLValue.cxx. ◆ DeclFileName(). static const char * RooAbsRealLValue::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 164 of file RooAbsRealLValue.h. ◆ fitRangeOKForPlotting(). bool RooAbsRealLValue::fitRangeOKForPlotting ; (; ); const. protected . Check if fit range is usable as plot range, i.e. ; it is neither open ended, nor empty ; Definition at line 493 of file RooAbsRealLValue.cxx. ◆ frame() [1/6]. RooPlot * RooAbsRealLValue::frame ; (; ); const. Create a new RooPlot on the heap with a drawing frame initialized for this object, but no plot contents. ; Use x.frame() ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsRealLValue.html:75892,perform,performed,75892,doc/master/classRooAbsRealLValue.html,https://root.cern,https://root.cern/doc/master/classRooAbsRealLValue.html,2,['perform'],['performed']
Performance,"nd copy it inside.Definition WrappedMultiTF1.h:399; ROOT::Math::WrappedMultiTF1Templ::fFuncTF1 * fFuncDefinition WrappedMultiTF1.h:187; ROOT::Math::WrappedMultiTF1Templ::DoParameterDerivativeT DoParameterDerivative(const T *x, const double *p, unsigned int ipar) const overrideevaluate the partial derivative with respect to the parameterDefinition WrappedMultiTF1.h:363; ROOT::Math::WrappedMultiTF1Templ::HasParameterHessianbool HasParameterHessian() const overrideDefinition WrappedMultiTF1.h:357; ROOT::Math::WrappedMultiTF1Templ::~WrappedMultiTF1Templ~WrappedMultiTF1Templ() overrideDestructor (no operations).Definition WrappedMultiTF1.h:66; ROOT::Math::WrappedMultiTF1Templ::fDimunsigned int fDimDefinition WrappedMultiTF1.h:188; ROOT::Math::WrappedMultiTF1Templ::Parametersconst double * Parameters() const overrideget the parameter values (return values from TF1)Definition WrappedMultiTF1.h:100; ROOT::Math::WrappedMultiTF1Templ::DoEvalT DoEval(const T *x) const overrideevaluate function using the cached parameter values (of TF1) re-implement for better efficiencyDefinition WrappedMultiTF1.h:172; ROOT::Math::WrappedMultiTF1Templ::ParameterG2bool ParameterG2(const T *, const double *, T *) const overrideEvaluate all the second derivatives (diagonal ones) of the function with respect to the parameters at...Definition WrappedMultiTF1.h:135; ROOT::Math::WrappedMultiTF1Templ::SetDerivPrecisionstatic void SetDerivPrecision(double eps)precision value used for calculating the derivative step-size h = eps * |x|.Definition WrappedMultiTF1.h:387; ROOT::Math::WrappedMultiTF1Templ::GetDerivPrecisionstatic double GetDerivPrecision()get precision value used for calculating the derivative step-sizeDefinition WrappedMultiTF1.h:393; ROOT::Math::WrappedMultiTF1Templ::BaseParamFuncROOT::Math::IParametricGradFunctionMultiDimTempl< T > BaseParamFuncDefinition WrappedMultiTF1.h:52; ROOT::Math::WrappedMultiTF1Templ::operator=WrappedMultiTF1Templ & operator=(const WrappedMultiTF1Templ< T > &rhs)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/WrappedMultiTF1_8h_source.html:16805,cache,cached,16805,doc/master/WrappedMultiTF1_8h_source.html,https://root.cern,https://root.cern/doc/master/WrappedMultiTF1_8h_source.html,1,['cache'],['cached']
Performance,"nd dedicated buffers to reduce the memory usage and to speed up access. Consequently, mapping TTree functionality to Python is not straightforward, and most of the following features are implemented in ROOT release 4.01/04 and later only, whereas you will need 5.02 if you require all of them.; 19.1.9.1 Accessing an Existing Tree; Let us assume that you have a file containing TTrees, TChains, or TNtuples and want to read the contents for use in your analysis code. This is commonly the case when you work with the result of the reconstruction software of your experiment (e.g. the combined ntuple in ATLAS). The following example code outlines the main steps (you can run it on the result of the tree1.C macro):; from ROOT import TFile. # open the file; myfile = TFile('tree1.root'). # retrieve the ntuple of interest; mychain = myfile.Get('t1'); entries = mychain.GetEntriesFast(). for jentry in xrange(entries):; # get the next tree in the chain and verify; ientry = mychain.LoadTree(jentry); if ientry < 0:; break. # copy next entry into memory and verify; nb = mychain.GetEntry(jentry); if nb<=0:; continue. # use the values directly from the tree; nEvent = int(mychain.ev); if nEvent<0:; continue. print(mychain.pz, '=', mychain.px*mychain.px, '+', mychain.py*mychain.py); Access to arrays works the same way as access to single value tree elements, where the size of the array is determined by the number of values actually read from the file. For example:; # loop over array tree element; for d in mychain.mydoubles:; print(d). # direct access into an array tree element; i5 = mychain.myints[5]; 19.1.9.2 Writing a Tree; Writing a ROOT TTree in a Python session is a little convoluted, if only because you will need a C++ class to make sure that data members can be mapped, unless you are working with built-in types. Here is an example for working with the latter only:; from ROOT import TFile, TTree; from array import array. h = TH1F('h1','test',100,-10.,10.); f = TFile('test.root','rec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1069562,Load,LoadTree,1069562,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['Load'],['LoadTree']
Performance,"nd ending with an integer corresponding to Ntotal_states-1. The mapping from a given logical node to a state number is generally not possible, as for the node B_1 that appears as current node for 2 different states. The numbering order of states is therefore not important, but it can be used as in the following lines:. gGeoManager->InitTrack(pt,dir); // anything to initialize a state; Int_t istate = gGeoManager->GetCurrentNodeId(); // in fact state Id; {; //... code changing the current state; }; gGeoManager->CdNode(istate); // forces state's re-initialization. Current global transformation. This represents the transformation from MARS to the local reference of the current node, being the product of all local mother-daughter transformations in the branch. The global transformation can be referenced or copied:. const TGeoHMatrix *global = gGeoManager->GetCurrentMatrix();; TGeoHMatrix *copy = new TGeoHMatrix(*global);. One often needs to perform master-to-local and local-to-master point and vector conversions to get from MARS to the local node coordinates. This can be done by using the global transformation or directly the TGeoManager corresponding interfaces:. Double_t *glob_pt = gGeoManager->GetCurrentPoint();; Double_t *glob_dir = gGeoManager->GetCurrentDirection();; Double_t loc_pt[3], loc_dir[3];; // Go from MARS to local coordinates:; gGeoManager->MasterToLocal(glob_pt,loc_pt); // or:; global->MasterToLocal(glob_pt,loc_pt); // will be omitted from now; 18.5.6 Saving and Restoring the Current State; As we already described, saving and restoring modeller states can be quite useful during tracking and is a feature extensively used by external tracking engines. We will call this navigation history management, which in most of the cases can be performed by handling the state identifiers. For quite big geometries, state indexing is not possible anymore and will be automatically disabled by the modeller. Fortunately there is a backup solution working in any condition: ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:980735,perform,perform,980735,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['perform'],['perform']
Performance,"nd exp common parameter; ; # signal + background function; iparSB = np.array(; [; 1, # exp amplitude in S+B histo; 2, # exp common parameter; 3, # Gaussian amplitude; 4, # Gaussian mean; 5, # Gaussian sigma; ],; dtype=np.int32,; ); ; # Create the GlobalCHi2 structure; ; class GlobalChi2(object):; def __init__(self, f1, f2):; self._f1 = f1; self._f2 = f2; ; def __call__(self, par):; # parameter vector is first background (in common 1 and 2) and then is; # signal (only in 2); ; # the zero-copy way to get a numpy array from a double *; par_arr = np.frombuffer(par, dtype=np.float64, count=6); ; p1 = par_arr[iparB]; p2 = par_arr[iparSB]; ; return self._f1(p1) + self._f2(p2); ; ; hB = ROOT.TH1D(""hB"", ""histo B"", 100, 0, 100); hSB = ROOT.TH1D(""hSB"", ""histo S+B"", 100, 0, 100); ; fB = ROOT.TF1(""fB"", ""expo"", 0, 100); fB.SetParameters(1, -0.05); hB.FillRandom(""fB""); ; fS = ROOT.TF1(""fS"", ""gaus"", 0, 100); fS.SetParameters(1, 30, 5); ; hSB.FillRandom(""fB"", 2000); hSB.FillRandom(""fS"", 1000); ; # perform now global fit; ; fSB = ROOT.TF1(""fSB"", ""expo + gaus(2)"", 0, 100); ; wfB = ROOT.Math.WrappedMultiTF1(fB, 1); wfSB = ROOT.Math.WrappedMultiTF1(fSB, 1); ; opt = ROOT.Fit.DataOptions(); rangeB = ROOT.Fit.DataRange(); # set the data range; rangeB.SetRange(10, 90); dataB = ROOT.Fit.BinData(opt, rangeB); ROOT.Fit.FillData(dataB, hB); ; rangeSB = ROOT.Fit.DataRange(); rangeSB.SetRange(10, 50); dataSB = ROOT.Fit.BinData(opt, rangeSB); ROOT.Fit.FillData(dataSB, hSB); ; chi2_B = ROOT.Fit.Chi2Function(dataB, wfB); chi2_SB = ROOT.Fit.Chi2Function(dataSB, wfSB); ; globalChi2 = GlobalChi2(chi2_B, chi2_SB); ; fitter = ROOT.Fit.Fitter(); ; Npar = 6; par0 = np.array([5, 5, -0.1, 100, 30, 10]); ; # create before the parameter settings in order to fix or set range on them; fitter.Config().SetParamsSettings(6, par0); # fix 5-th parameter; fitter.Config().ParSettings(4).Fix(); # set limits on the third and 4-th parameter; fitter.Config().ParSettings(2).SetLimits(-10, -1.0e-4); fitter.Config().ParSetting",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/combinedFit_8py.html:1811,perform,perform,1811,doc/master/combinedFit_8py.html,https://root.cern,https://root.cern/doc/master/combinedFit_8py.html,1,['perform'],['perform']
Performance,"nd f2 are always taken; to be end the end-points of the parameter alpha, regardless of what; the those numeric values are. Since the value of fbar(x) cannot be easily calculated for a given value; of x, class RooIntegralMorph is an implementation of RooAbsCachedPdf and; calculates the shape of the interpolated p.d.f. fbar(x) for all values; of x for a given value of alpha,p,q and caches these values in a histogram; (as implemented by RooAbsCachedPdf). The binning granularity of the cache; can be controlled by the binning named ""cache"" on the RooRealVar representing; the observable x. The fbar sampling algorithm is based on a recursive division; mechanism with a built-in precision cutoff: First an initial sampling in; 64 equally spaced bins is made. Then the value of fbar is calculated in; the center of each gap. If the calculated value deviates too much from; the value obtained by linear interpolation from the edge bins, gap; is recursively divided. This strategy makes it possible to define a very; fine cache sampling (e.g. 1000 or 10000) bins without incurring a; corresponding CPU penalty. Note on numeric stability of the algorithm. Since the algorithm relies; on a numeric inversion of cumulative distributions functions, some precision; may be lost at the 'edges' of the same (i.e. at regions in x where the; c.d.f. value is close to zero or one). The general sampling strategy is; to start with 64 equally spaces samples in the range y=(0.01-0.99).; Then the y ranges are pushed outward by reducing y (or the distance of y to 1.0); by a factor of sqrt(10) iteratively up to the point where the corresponding; x value no longer changes significantly. For p.d.f.s with very flat tails; such as Gaussians some part of the tail may be lost due to limitations; in numeric precision in the CDF inversion step. An effect related to the above limitation in numeric precision should; be anticipated when floating the alpha parameter in a fit. If a p.d.f; with such flat tails is fitted, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooIntegralMorph.html:2160,cache,cache,2160,root/html526/RooIntegralMorph.html,https://root.cern,https://root.cern/root/html526/RooIntegralMorph.html,11,['cache'],['cache']
Performance,"nd fast if a point different from the current one has or not the same location inside the geometry tree. To do that, the new point should not be introduced by using TGeoManager::SetCurrentPoint() method, but rather by calling the specific method:; Bool_t TGeoManager::IsSameLocation(Double_t x,Double_t y,; Double_t z,Bool_t change=kFALSE);; In the prototype above, x, y and z are the coordinates of the new point. The modeller will check whether the current volume still contains the new point or its location has changed in the geometry hierarchy. If the new location is different, two actions are possible according to the value of change:. change = kFALSE (default) - the modeller does not change the current state but just inform the caller about this change.; change = kTRUE - the modeller will actually perform a new ‘Where am I?'search after finding out that the location has changed. The current state will be actualized accordingly. Note that even when performing a normal search on the current state after changing the current point coordinates (e.g. gGeoManager->FindNode(newX,newY,newZ)), users can always query if the previous state has changed by using a method having the same name but without parameters:; Bool_t TGeoManager::IsSameLocation();; 18.5.7.2 Finding the Distance to the Next Boundary; All tracking engines need to compare the currently proposed physical step with the maximum allowed distance in the current material. The modeller provides this information by computing the distance to the first boundary starting from the current point along a straight line. The starting point and direction for this procedure are the ones corresponding to the current state. The boundary search is initialized inside the current volume and the crossed boundary can belong either to the current node or to one of its daughters. The full prototype of the method is:; TGeoNode *TGeoManager::FindNextBoundary(Double_t step=kBig);; In the prototype above, besides the current point and direc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:984049,perform,performing,984049,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['perform'],['performing']
Performance,"nd points of curve; 1593///; 1594/// <tr><td> `Precision(double eps)` <td> Control precision of drawn curve w.r.t to scale of plot, default is 1e-3. Higher precision; 1595/// will result in more and more densely spaced curve points; 1596///; 1597/// <tr><td> `Invisible(bool flag)` <td> Add curve to frame, but do not display. Useful in combination AddTo(); 1598///; 1599/// <tr><td> `VisualizeError(const RooFitResult& fitres, double Z=1, bool linearMethod=true)`; 1600/// <td> Visualize the uncertainty on the parameters, as given in fitres, at 'Z' sigma'. The linear method is fast but may not be accurate in the presence of strong correlations (~>0.9) and at Z>2 due to linear and Gaussian approximations made. Intervals from the sampling method can be asymmetric, and may perform better in the presence of strong correlations, but may take (much) longer to calculate; 1601///; 1602/// <tr><td> `VisualizeError(const RooFitResult& fitres, const RooArgSet& param, double Z=1, bool linearMethod=true)`; 1603/// <td> Visualize the uncertainty on the subset of parameters 'param', as given in fitres, at 'Z' sigma'; 1604/// </table>; 1605///; 1606/// Details on error band visualization; 1607/// -----------------------------------; 1608/// *VisualizeError() uses plotOnWithErrorBand(). Documentation of the latter:*; 1609/// \see plotOnWithErrorBand(); 1610 ; 1611RooPlot* RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1, const RooCmdArg& arg2,; 1612 const RooCmdArg& arg3, const RooCmdArg& arg4,; 1613 const RooCmdArg& arg5, const RooCmdArg& arg6,; 1614 const RooCmdArg& arg7, const RooCmdArg& arg8,; 1615 const RooCmdArg& arg9, const RooCmdArg& arg10) const; 1616{; 1617 RooLinkedList l ;; 1618 l.Add((TObject*)&arg1) ; l.Add((TObject*)&arg2) ;; 1619 l.Add((TObject*)&arg3) ; l.Add((TObject*)&arg4) ;; 1620 l.Add((TObject*)&arg5) ; l.Add((TObject*)&arg6) ;; 1621 l.Add((TObject*)&arg7) ; l.Add((TObject*)&arg8) ;; 1622 l.Add((TObject*)&arg9) ; l.Add((TObject*)&arg10) ;; 1623 return plotO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8cxx_source.html:68909,perform,perform,68909,doc/master/RooAbsReal_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html,1,['perform'],['perform']
Performance,"nd prefetching is started) when:; TTreeCache::StopLearningPhase is called.; An entry outside the 'learning' range is requested The 'learning range is from fEntryMin (default to 0) to fEntryMin + fgLearnEntries.; A 'cached' TChain switches over to a new file. Self-optimization in presence of cache misses; The TTreeCache can optimize its behavior on a cache miss. When miss optimization is enabled (see the SetOptimizeMisses method), it tracks all branches utilized after the learning phase which caused a cache miss. When one cache miss occurs, all the utilized branches are be prefetched for that event. This optimization utilizes the observation that infrequently accessed branches are often accessed together. An example scenario where such behavior is desirable, is an analysis where a set of collections are read only for a few events in which a certain condition is respected, e.g. a trigger fired. Additional memory and CPU usage when optimizing for cache misses; When this mode is enabled, the memory dedicated to the cache can increase by at most a factor two in the case of cache miss. Additionally, on the first miss of an event, we must iterate through all the ""active branches"" for the miss cache and find the correct basket. This can be potentially a CPU-expensive operation compared to, e.g., the latency of a SSD. This is why the miss cache is currently disabled by default. Example usages of TTreeCache; A few use cases are discussed below. A cache may be created with automatic sizing when a TTree is used:; In some applications, e.g. central processing workflows of experiments, the list of branches to read is known a priori. For these cases, the TTreeCache can be instructed about the branches which will be read via explicit calls to the TTree or TTreeCache interfaces. In less streamlined applications such as analysis, predicting the branches which will be read can be difficult. In such cases, ROOT I/O flags used branches automatically when a branch buffer is read during th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCache.html:5037,optimiz,optimizing,5037,doc/v632/classTTreeCache.html,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html,8,"['cache', 'optimiz']","['cache', 'optimizing']"
Performance,"nd to set the external visible; 5701 // storage flag for them.; 5702 public:; 5703 ExtVisibleStorageAdder(std::unordered_set<const NamespaceDecl*>& nsSet): fNSSet(nsSet) {};; 5704 bool VisitNamespaceDecl(NamespaceDecl* nsDecl) {; 5705 // We want to enable the external lookup for this namespace; 5706 // because it may shadow the lookup of other names contained; 5707 // in that namespace; 5708 ; 5709 nsDecl->setHasExternalVisibleStorage();; 5710 fNSSet.insert(nsDecl);; 5711 return true;; 5712 }; 5713 bool VisitClassTemplateSpecializationDecl(ClassTemplateSpecializationDecl* specDecl) {; 5714 // We want to enable the external lookup for this specialization; 5715 // because we can provide a definition for it!; 5716 if (specDecl->getTemplateSpecializationKind() == TSK_ExplicitSpecialization); 5717 //SpecSet.insert(specDecl);; 5718 specDecl->setHasExternalLexicalStorage();; 5719 ; 5720 // No need to recurse. On the contrary, recursing is actively harmful:; 5721 // NOTE: must not recurse to prevent this visitor from triggering loading from; 5722 // the external AST source (i.e. autoloading). This would be triggered right here,; 5723 // before autoloading is even set up, as rootmap file parsing happens before that.; 5724 // Even if autoloading is off and has no effect, triggering loading from external; 5725 // AST source resets the flag setHasExternalLexicalStorage(), hiding this specialization; 5726 // from subsequent autoloads!; 5727 return false;; 5728 }; 5729 private:; 5730 std::unordered_set<const NamespaceDecl*>& fNSSet;; 5731 };; 5732}; 5733 ; 5734////////////////////////////////////////////////////////////////////////////////; 5735/// Load map between class and library. If rootmapfile is specified a; 5736/// specific rootmap file can be added (typically used by ACLiC).; 5737/// In case of error -1 is returned, 0 otherwise.; 5738/// The interpreter uses this information to automatically load the shared; 5739/// library for a class (autoload mechanism), see the AutoLo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:222822,load,loading,222822,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['load'],['loading']
Performance,"nd will all point to the same normalization list. Lists; for up to 'maxSize' different normalization/ projection; configurations can be cached. ; . Function Members (Methods); public:. RooCacheManager<RooAbsCacheElement>(Int_t maxSize = 10); RooCacheManager<RooAbsCacheElement>(RooAbsArg* owner, Int_t maxSize = 10); RooCacheManager<RooAbsCacheElement>(const RooCacheManager<RooAbsCacheElement>& other, RooAbsArg* owner = 0); virtual~RooCacheManager<RooAbsCacheElement>(); Int_tcacheSize() const; static TClass*Class(); virtual voidRooAbsCache::findConstantNodes(const RooArgSet&, RooArgSet&, RooLinkedList&); RooAbsCacheElement*getObj(const RooArgSet* nset, Int_t* sterileIndex = 0, const TNamed* isetRangeName = 0); RooAbsCacheElement*getObj(const RooArgSet* nset, const RooArgSet* iset, Int_t* sterileIdx = 0, const TNamed* isetRangeName = 0); RooAbsCacheElement*getObjByIndex(Int_t index) const; virtual voidinsertObjectHook(RooAbsCacheElement&); virtual TClass*IsA() const; Int_tlastIndex() const; const RooNameSet*nameSet1ByIndex(Int_t index) const; const RooNameSet*nameSet2ByIndex(Int_t index) const; RooCacheManager<RooAbsCacheElement>&operator=(const RooCacheManager<RooAbsCacheElement>&); virtual voidoperModeHook(); virtual voidRooAbsCache::optimizeCacheMode(const RooArgSet&, RooArgSet&, RooLinkedList&); virtual voidprintCompactTreeHook(ostream&, const char*); virtual Bool_tredirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidreset(); Int_tsetObj(const RooArgSet* nset, RooAbsCacheElement* obj, const TNamed* isetRangeName = 0); Int_tsetObj(const RooArgSet* nset, const RooArgSet* iset, RooAbsCacheElement* obj, const TNamed* isetRangeName = 0); virtual voidShowMembers(TMemberInspector& insp); voidsterilize(); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; protected:. Int_t_lastIndexLast slot accessed; Int_t_maxSizeMaximum size; RooNormSetCache*_nsetCache! Normalization/Integration set manager; RooAbsCacheElement**_object!",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooCacheManager_RooAbsCacheElement_.html:2278,optimiz,optimizeCacheMode,2278,root/html528/RooCacheManager_RooAbsCacheElement_.html,https://root.cern,https://root.cern/root/html528/RooCacheManager_RooAbsCacheElement_.html,1,['optimiz'],['optimizeCacheMode']
Performance,"nd. void SetCompressionLevel(Int_t level = 1); Set level of compression for this file:; level = 0 objects written to this file will not be compressed.; level = 1 minimal compression level but fast. level = 9 maximal compression level but slow. Note that the compression level may be changed at any time.; The new compression level will only apply to newly written objects.; The function TFile::Map shows the compression factor; for each object written to this file.; The function TFile::GetCompressionFactor returns the global; compression factor for this file. void SetCacheRead(TFileCacheRead* cache); Set a pointer to the read cache.; NOTE: This relinquish ownership of the previous cache, so if you do not; already have a pointer to the previous cache (and there was a previous; cache), you ought to retrieve (and delete it if needed) using:; TFileCacheRead *older = myfile->GetCacheRead();. void SetCacheWrite(TFileCacheWrite* cache); Set a pointer to the write cache.; If file is null the existing write cache is deleted. Int_t Sizeof() const; Return the size in bytes of the file header. void Streamer(TBuffer& b); Stream a TFile object. void SumBuffer(Int_t bufsize); Increment statistics for buffer sizes of objects in this file. void UseCache(Int_t maxCacheSize = 10, Int_t pageSize = 0); Dummy function kept for backward compatibility.; The read cache is now managed by TFileCacheRead; The write cache is now managed by TFileCacheWrite; Both caches are created automatically by the system. Int_t Write(const char* name = 0, Int_t opt = 0, Int_t bufsiz = 0); Write memory objects to this file.; Loop on all objects in memory (including subdirectories).; A new key is created in the KEYS linked list for each object.; The list of keys is then saved on the file (via WriteKeys); as a single data record.; For values of opt see TObject::Write().; The directory header info is rewritten on the directory header record.; The linked list of FREE segments is written.; The file header is written (",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFile.html:37634,cache,cache,37634,root/html528/TFile.html,https://root.cern,https://root.cern/root/html528/TFile.html,1,['cache'],['cache']
Performance,"ndPdf, RooFormulaVar, RooGenericPdf, RooHistFunc, RooHistPdf, RooPolyVar, RooProduct, RooRatio, RooRealIntegral, RooRealSumFunc, RooRealSumPdf, RooRealVar, RooRecursiveFraction, RooNormalizedPdf, and RooFixedProdPdf.; Definition at line 2546 of file RooAbsArg.cxx. ◆ treeNodeServerList(). void RooAbsArg::treeNodeServerList ; (; RooAbsCollection * ; list, . const RooAbsArg * ; arg = nullptr, . bool ; doBranch = true, . bool ; doLeaf = true, . bool ; valueOnly = false, . bool ; recurseFundamental = false . ); const. Fill supplied list with nodes of the arg tree, following all server links, starting with ourself as top node. ; Parameters. [in]listOutput list ; [in]argStart searching at this element of the tree. ; [in]doBranchAdd branch nodes to the list. ; [in]doLeafAdd leaf nodes to the list. ; [in]valueOnlyOnly check if an element is a value server (no shape server). ; [in]recurseFundamental. Definition at line 499 of file RooAbsArg.cxx. ◆ unRegisterCache(). void RooAbsArg::unRegisterCache ; (; RooAbsCache & ; cache). Unregister a RooAbsCache. Called from the RooAbsCache destructor. ; Definition at line 2126 of file RooAbsArg.cxx. ◆ unRegisterProxy() [1/3]. void RooAbsArg::unRegisterProxy ; (; RooArgProxy & ; proxy). protected . Remove proxy from proxy list. ; This functions is called by owned proxies upon their destruction. ; Definition at line 1358 of file RooAbsArg.cxx. ◆ unRegisterProxy() [2/3]. void RooAbsArg::unRegisterProxy ; (; RooListProxy & ; proxy). protected . Remove proxy from proxy list. ; This functions is called by owned proxies upon their destruction. ; Definition at line 1432 of file RooAbsArg.cxx. ◆ unRegisterProxy() [3/3]. void RooAbsArg::unRegisterProxy ; (; RooSetProxy & ; proxy). protected . Remove proxy from proxy list. ; This functions is called by owned proxies upon their destruction. ; Definition at line 1393 of file RooAbsArg.cxx. ◆ valueClients(). const RefCountList_t & RooAbsArg::valueClients ; (; ); const. inline . List of all value clien",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsArg.html:103986,cache,cache,103986,doc/master/classRooAbsArg.html,https://root.cern,https://root.cern/doc/master/classRooAbsArg.html,1,['cache'],['cache']
Performance,"ndard; kVerbose; kTreeStructure; };. protected:. set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsString::_lenLength of _value; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; char*RooAbsString::_value[_len] Value; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; I",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooStringVar.html:17353,cache,caches,17353,root/html526/RooStringVar.html,https://root.cern,https://root.cern/root/html526/RooStringVar.html,6,['cache'],"['cache', 'caches']"
Performance,"nded = kFALSE) const; Double_tgetCoefNorm(Int_t coefIdx, const RooArgSet* nset, const TNamed* rangeName) const; virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; static voidRooAbsReal::globalSelectComp(Bool_t flag); voidRooAbsArg::graphVizAddConnections(set<pair<RooAbsArg*,RooAbsArg*> >&); Bool_tRooAbsArg::inhibitDirty() const; TStringRooAbsReal::integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset = 0, const char* rangeName = 0, Bool_t omitEmpty = kFALSE) const; Bool_tRooAbsReal::isSelectedComp() const; virtual Bool_tRooAbsReal::isValid() const; virtual Bool_tRooAbsReal::isValidReal(Double_t value, Bool_t printError = kFALSE) const; voidmakeCoefVarList(RooArgList&) const; voidRooAbsReal::makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; voidTObject::MakeZombie(); Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c, const RooArgProxy& d) const; Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooArgSet& params, Bool_t showConstants = kFALSE, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsAnaConvPdf.html:37917,optimiz,optimizeDirtyHook,37917,root/html602/RooAbsAnaConvPdf.html,https://root.cern,https://root.cern/root/html602/RooAbsAnaConvPdf.html,4,['optimiz'],['optimizeDirtyHook']
Performance,"nded side effect as we want to prevent non-expert users from performing assignments (=) rather than comparisons (==). Expert users can resort to compiled callables if they absolutely have to assign to column values (not recommended). See ROOT-11009 for further discussion.; For some TTrees, RDataFrame::GetColumnNames might now returns multiple valid spellings for a given column. For example, leaf ""l"" under branch ""b"" might now be mentioned as ""l"" as well as ""b.l"", while only one of the two spellings might have been recognized before.; Certain RDF-related types in the ROOT::Detail and ROOT::Internal namespaces have been renamed, most notably RCustomColumn is now RDefine. This does not impact code that only makes use of entities in the public ROOT namespace, and should not impact downstream code unless it was patching or reusing internal RDataFrame types. Notable bug fixes and improvements. A critical issue has been fixed that could potentially result in wrong data being silently read in multi-thread runs when an input TChain contained more than one TTree coming from the same input file. More details are available at #7143.; The start-up time of event loops with large computation graphs with many just-in-time-compiled expressions (e.g. thousands of string Filters and Defines) has been greatly reduced. See the corresponding pull request for more details. The full list of bug fixes for this release is available below.; Distributed computing with RDataFrame; ROOT 6.24 introduces ROOT.RDF.Experimental.Distributed, an experimental python package that enhances RDataFrame with distributed computing capabilities. The new package allows distributing RDataFrame applications through one of the supported distributed backends. The package was designed so that different backends can be easily plugged in. Currently the Apache Spark backend is supported and support for Dask is coming soon. The backend submodules of this package expose their own RDataFrame objects. The only needed chang",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v624/release-notes.html:10033,multi-thread,multi-thread,10033,doc/v624/release-notes.html,https://root.cern,https://root.cern/doc/v624/release-notes.html,1,['multi-thread'],['multi-thread']
Performance,"nded. RooFFTConvPdf(const char* name, const char* title, RooAbsReal& pdfConvVar, RooRealVar& convVar, RooAbsPdf& pdf1, RooAbsPdf& pdf2, Int_t ipOrder = 2); Constructor for convolution of pdf1 (x) pdf2 in observable convVar. The binning used for the FFT sampling is controlled; by the binning named ""cache"" in the convolution observable. The resulting FFT convolved histogram is interpolated at; order 'ipOrder' A minimum binning of 1000 bins is recommended. RooFFTConvPdf(const RooFFTConvPdf& other, const char* name = 0); Copy constructor. ~RooFFTConvPdf(); Destructor. const char* inputBaseName() const; Return base name component for cache components in this case 'PDF1_CONV_PDF2'. TString histNameSuffix() const; Suffix for cache histogram (added in addition to suffix for cache name). void fillCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; Fill the contents of the cache the FFT convolution output. void fillCacheSlice(RooFFTConvPdf::FFTCacheElem& cache, const RooArgSet& slicePosition) const; Fill a slice of cachePdf with the output of the FFT convolution calculation. Double_t* scanPdf(RooRealVar& obs, RooAbsPdf& pdf, const RooDataHist& hist, const RooArgSet& slicePos, Int_t& N, Int_t& N2, Int_t& zeroBin, Double_t shift) const; Scan the values of 'pdf' in observable 'obs' using the bin values stored in 'hist' at slice position 'slicePos'; N is filled with the number of bins defined in hist, N2 is filled with N plus the number of buffer bins; The return value is an array of doubles of length N2 with the sampled values. The caller takes ownership; of the array. RooArgSet* actualObservables(const RooArgSet& nset) const; Return the observables to be cached given the normalization set nset. If the cache observables is in nset then this is; - the convolution observable plus; - any member of nset that is either a RooCategory,; - or was previously specified through setCacheObservables(). In case the cache observable is _not_ in nset, then it is; - the convolution observab",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooFFTConvPdf.html:47862,cache,cache,47862,root/html526/RooFFTConvPdf.html,https://root.cern,https://root.cern/root/html526/RooFFTConvPdf.html,22,['cache'],"['cache', 'cachePdf']"
Performance,"nderlying fProofChain (chain proxy) is always; rebuilt (even if already existing).; If gettreeheader is kTRUE the header of the tree will be read from the; PROOF cluster: this is only needed for browsing and should be used with; care because it may take a long time to execute. void SetWeight(Double_t w = 1, Option_t* option = """"); -- Set chain weight. The weight is used by TTree::Draw to automatically weight each; selected entry in the resulting histogram.; For example the equivalent of; chain.Draw(""x"",""w""); is; chain.SetWeight(w,""global"");; chain.Draw(""x"");. By default the weight used will be the weight; of each Tree in the TChain. However, one can force the individual; weights to be ignored by specifying the option ""global"".; In this case, the TChain global weight will be used for all Trees. void Streamer(TBuffer& b); -- Stream a class object. void UseCache(Int_t maxCacheSize = 10, Int_t pageSize = 0); -- Dummy function kept for back compatibility.; The cache is now activated automatically when processing TTrees/TChain. TChain(const TChain& ). TChain& operator=(const TChain& ). void ReleaseChainProof(). Long64_t Draw(const char* varexp, const TCut& selection, Option_t* option = """", Long64_t nentries = kBigNumber, Long64_t firstentry = 0). Int_t Fill(); { MayNotUse(""Fill()""); return -1; }. Int_t GetNtrees() const; { return fNtrees; }. Long64_t GetEntries() const. TObjArray * GetListOfFiles() const; Warning, GetListOfFiles returns the list of TChainElements (not the list of files); see TChain::AddFile to see how to get the corresponding TFile objects. {return fFiles;}. TList * GetStatus() const; { return fStatus; }. TTree * GetTree() const; { return fTree; }. Int_t GetTreeNumber() const; { return fTreeNumber; }. Long64_t * GetTreeOffset() const; { return fTreeOffset; }. Int_t GetTreeOffsetLen() const; { return fTreeOffsetLen; }. void SetMakeClass(Int_t make); { TTree::SetMakeClass(make); if (fTree) fTree->SetMakeClass(make);}. » Author: Rene Brun 03/02/97 » Copyright",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TChain.html:48815,cache,cache,48815,root/html526/TChain.html,https://root.cern,https://root.cern/root/html526/TChain.html,5,['cache'],['cache']
Performance,"ndex () const;  ; Int_t GetCompressionAlgorithm () const;  ; Float_t GetCompressionFactor ();  Return the file compression factor. ;  ; Int_t GetCompressionLevel () const;  ; Int_t GetCompressionSettings () const;  ; virtual Long64_t GetEND () const;  ; virtual const TUrl * GetEndpointUrl () const;  ; virtual Int_t GetErrno () const;  Method returning errno. ;  ; Int_t GetFd () const;  ; TList * GetListOfFree () const;  ; TObjArray * GetListOfProcessIDs () const;  ; virtual Int_t GetNbytesFree () const;  ; virtual Int_t GetNbytesInfo () const;  ; virtual Int_t GetNfree () const;  ; virtual Int_t GetNProcessIDs () const;  ; Option_t * GetOption () const override;  ; virtual Int_t GetReadCalls () const;  ; Int_t GetRecordHeader (char *buf, Long64_t first, Int_t maxbytes, Int_t &nbytes, Int_t &objlen, Int_t &keylen);  Read the logical record header starting at a certain postion. ;  ; Long64_t GetRelOffset () const;  ; virtual Long64_t GetSeekFree () const;  ; virtual Long64_t GetSeekInfo () const;  ; const TList * GetStreamerInfoCache ();  Returns the cached list of StreamerInfos used in this file. ;  ; virtual TList * GetStreamerInfoList () final;  Read the list of TStreamerInfo objects written to this file. ;  ; Int_t GetVersion () const;  ; virtual void IncrementProcessIDs ();  ; TClass * IsA () const override;  ; virtual Bool_t IsArchive () const;  ; Bool_t IsBinary () const;  ; virtual Bool_t IsOpen () const;  Returns kTRUE in case file is open and kFALSE if file is not open. ;  ; Bool_t IsRaw () const;  ; void ls (Option_t *option="""") const override;  List file contents. ;  ; virtual void MakeFree (Long64_t first, Long64_t last);  Mark unused bytes on the file. ;  ; virtual void MakeProject (const char *dirname, const char *classes=""*"", Option_t *option=""new"");  Generate source code necessary to access the objects stored in the file. ;  ; virtual void Map ();  ; virtual void Map (Option_t *opt);  List the contents of a file sequentially. ;  ; virtual Bool_t Match",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDavixFile.html:4890,cache,cached,4890,doc/master/classTDavixFile.html,https://root.cern,https://root.cern/doc/master/classTDavixFile.html,1,['cache'],['cached']
Performance,"ndex () const;  ; Int_t GetCompressionAlgorithm () const;  ; Float_t GetCompressionFactor ();  Return the file compression factor. ;  ; Int_t GetCompressionLevel () const;  ; Int_t GetCompressionSettings () const;  ; virtual Long64_t GetEND () const;  ; virtual const TUrl * GetEndpointUrl () const;  ; virtual Int_t GetErrno () const;  Method returning errno. ;  ; Int_t GetFd () const;  ; TList * GetListOfFree () const;  ; TObjArray * GetListOfProcessIDs () const;  ; virtual Int_t GetNbytesFree () const;  ; virtual Int_t GetNbytesInfo () const;  ; virtual Int_t GetNfree () const;  ; virtual Int_t GetNProcessIDs () const;  ; Option_t * GetOption () const override;  ; virtual Int_t GetReadCalls () const;  ; Int_t GetRecordHeader (char *buf, Long64_t first, Int_t maxbytes, Int_t &nbytes, Int_t &objlen, Int_t &keylen);  Read the logical record header starting at a certain postion. ;  ; Long64_t GetRelOffset () const;  ; virtual Long64_t GetSeekFree () const;  ; virtual Long64_t GetSeekInfo () const;  ; const TList * GetStreamerInfoCache ();  Returns the cached list of StreamerInfos used in this file. ;  ; virtual TList * GetStreamerInfoList () final;  Read the list of TStreamerInfo objects written to this file. ;  ; Int_t GetVersion () const;  ; virtual void IncrementProcessIDs ();  ; virtual Bool_t IsArchive () const;  ; Bool_t IsBinary () const;  ; Bool_t IsRaw () const;  ; void ls (Option_t *option="""") const override;  List file contents. ;  ; virtual void MakeFree (Long64_t first, Long64_t last);  Mark unused bytes on the file. ;  ; virtual void MakeProject (const char *dirname, const char *classes=""*"", Option_t *option=""new"");  Generate source code necessary to access the objects stored in the file. ;  ; virtual void Map ();  ; virtual void Map (Option_t *opt);  List the contents of a file sequentially. ;  ; virtual Bool_t Matches (const char *name);  Return kTRUE if 'url' matches the coordinates of this file. ;  ; virtual Bool_t MustFlush () const;  ; void Paint (O",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTNetXNGFile.html:5066,cache,cached,5066,doc/master/classTNetXNGFile.html,https://root.cern,https://root.cern/doc/master/classTNetXNGFile.html,1,['cache'],['cached']
Performance,"ndex numbers. ; Triggers a recomputation if the shape is dirty. ; Definition at line 168 of file RooAbsCategory.h. ◆ stateNames() [2/2]. const std::map< std::string, value_type > & RooAbsCategory::stateNames ; (; ); const. inlineprotected . Access the map of state names to index numbers. ; Triggers a recomputation if the shape is dirty. ; Definition at line 158 of file RooAbsCategory.h. ◆ Streamer(). void RooAbsCategory::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject.; Reimplemented in RooAbsCategoryLValue, RooBinningCategory, RooCategory, RooMappedCategory, RooMultiCategory, RooSuperCategory, and RooThresholdCategory. ◆ StreamerNVirtual(). void RooAbsCategory::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 226 of file RooAbsCategory.h. ◆ syncCache(). void RooAbsCategory::syncCache ; (; const RooArgSet * ; set = nullptr). overrideprotectedvirtual . Explicitly synchronize RooAbsCategory internal cache. ; Implements RooAbsArg.; Definition at line 547 of file RooAbsCategory.cxx. ◆ typeIterator(). TIterator * RooAbsCategory::typeIterator ; (; ); const. Deprecated:Use begin() and end() instead. ; NoteUsing this iterator creates useless RooCatType instances, which will leak unless deleted by the user. ; Definition at line 678 of file RooAbsCategory.cxx. ◆ writeToStream(). void RooAbsCategory::writeToStream ; (; std::ostream & ; os, . bool ; compact . ); const. overridevirtual . Write object contents to ostream. ; Implements RooAbsArg.; Reimplemented in RooCategory, RooMappedCategory, RooMultiCategory, and RooThresholdCategory.; Definition at line 391 of file RooAbsCategory.cxx. Friends And Related Symbol Documentation. ◆ RooVectorDataStore. friend class RooVectorDataStore. friend . Definition at line 203 of file RooAbsCategory.h. Member Data Documentation. ◆ _currentIndex. value_type RooAbsCategory::_currentIndex {std::numeric_limits<int>::min()}. mutableprotec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsCategory.html:63458,cache,cache,63458,doc/master/classRooAbsCategory.html,https://root.cern,https://root.cern/doc/master/classRooAbsCategory.html,1,['cache'],['cache']
Performance,"ndex,end);; 2223 if (sub[0]!='-' && sub[1]!='L') {; 2224 libs.ReplaceAll(sub,"""");; 2225 }; 2226 }; 2227 start += end+1;; 2228 }; 2229 libs = libs.Strip(TString::kBoth);; 2230 }; 2231 ; 2232 // Select according to regexp; 2233 if (regexp && *regexp) {; 2234 static TRegexp separator(""[^ \\t\\s]+"");; 2235 TRegexp user_re(regexp, kTRUE);; 2236 TString s;; 2237 Ssiz_t start, index, end;; 2238 start = index = end = 0;; 2239 ; 2240 while ((start < libs.Length()) && (index != kNPOS)) {; 2241 index = libs.Index(separator,&end,start);; 2242 if (index >= 0) {; 2243 s = libs(index,end);; 2244 if ((isRegexp && s.Index(user_re) != kNPOS) ||; 2245 (!isRegexp && s.Index(regexp) != kNPOS)) {; 2246 if (!fListLibs.IsNull()); 2247 fListLibs.Append("" "");; 2248 fListLibs.Append(s);; 2249 }; 2250 }; 2251 start += end+1;; 2252 }; 2253 } else; 2254 fListLibs = libs;; 2255 ; 2256#if defined(R__MACOSX); 2257// We need to remove the libraries that are dynamically loaded and not linked; 2258{; 2259 TString libs2 = fListLibs;; 2260 TString maclibs;; 2261 ; 2262 static TRegexp separator(""[^ \\t\\s]+"");; 2263 static TRegexp dynload(""/lib-dynload/"");; 2264 ; 2265 Ssiz_t start, index, end;; 2266 start = index = end = 0;; 2267 ; 2268 while ((start < libs2.Length()) && (index != kNPOS)) {; 2269 index = libs2.Index(separator, &end, start);; 2270 if (index >= 0) {; 2271 TString s = libs2(index, end);; 2272 if (s.Index(dynload) == kNPOS) {; 2273 if (!maclibs.IsNull()) maclibs.Append("" "");; 2274 maclibs.Append(s);; 2275 }; 2276 }; 2277 start += end+1;; 2278 }; 2279 fListLibs = maclibs;; 2280}; 2281#endif; 2282 ; 2283 return fListLibs.Data();; 2284}; 2285 ; 2286//---- RPC ---------------------------------------------------------------------; 2287 ; 2288////////////////////////////////////////////////////////////////////////////////; 2289/// Get Internet Protocol (IP) address of host.; 2290 ; 2291TInetAddress TSystem::GetHostByName(const char *); 2292{; 2293 AbstractMethod(""GetHostByName"");; 2294 return TIne",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8cxx_source.html:73123,load,loaded,73123,doc/master/TSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html,1,['load'],['loaded']
Performance,"nding of RooAbsReal func to; variables 'vars'. Use the provided nset as normalization set to; be passed to RooAbsReal::getVal() If rangeName is not null, use; the range of with that name as range associated with the; variables of this function binding. If clipInvalid is true,; values requested to the function binding that are outside the; defined range of the variables are clipped to fit in the defined; range. RooRealBinding(const RooRealBinding& other, const RooArgSet* nset = 0); Construct a lightweight function binding of RooAbsReal func to; variables 'vars'. Use the provided nset as normalization set to; be passed to RooAbsReal::getVal() If rangeName is not null, use; the range of with that name as range associated with the; variables of this function binding. If clipInvalid is true,; values requested to the function binding that are outside the; defined range of the variables are clipped to fit in the defined; range. ~RooRealBinding(); Destructor. void saveXVec() const; Save value of all variables. void restoreXVec() const; Restore value of all variables to previously; saved values by saveXVec(). void loadValues(const Double_t[] xvector) const; Load the vector of variable values into the RooRealVars associated; as variables with the bound RooAbsReal function. Double_t operator()(const Double_t[] xvector) const; Evaluate the bound RooAbsReal at the variable values provided in xvector. Double_t getMinLimit(UInt_t dimension) const; Return lower limit on i-th variable. Double_t getMaxLimit(UInt_t dimension) const; Return upper limit on i-th variable. const char* getName() const; Return name of function. std::list<Double_t>* plotSamplingHint(RooAbsRealLValue& , Double_t , Double_t ) const. std::list<Double_t>* binBoundaries(Int_t ) const. » Last changed: Tue Jun 30 14:35:16 2015 » Last generated: 2015-06-30 14:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooRealBinding.html:3398,load,loadValues,3398,root/html602/RooRealBinding.html,https://root.cern,https://root.cern/root/html602/RooRealBinding.html,3,"['Load', 'load']","['Load', 'loadValues']"
Performance,"nditionalObservables() -- Define projected observables; Verbose() -- Verbose output of GOF framework. RooChi2Var(const char* name, const char* title, RooAbsPdf& pdf, RooDataHist& data, Bool_t extended = kFALSE, const char* rangeName = 0, const char* addCoefRangeName = 0, Int_t nCPU = 1, RooFit::MPSplit interleave = RooFit::BulkPartition, Bool_t verbose = kTRUE, Bool_t splitCutRange = kTRUE, RooDataHist::ErrorType = RooDataHist::SumW2); Constructor of a chi2 for given p.d.f. with respect given binned; dataset. If cutRange is specified the calculation of the chi2 is; restricted to that named range. If addCoefRange is specified, the; interpretation of fractions for all component RooAddPdfs that do; not have a frozen range interpretation is set to chosen range; name. If nCPU is greater than one the chi^2 calculation is; paralellized over the specified number of processors. If; interleave is true the partitioning of event over processors; follows a (i % n == i_set) strategy rather than a bulk; partitioning strategy which may result in unequal load balancing; in binned datasets with many (adjacent) zero bins. If; splitCutRange is true the cutRange is used to construct an; individual cutRange for each RooSimultaneous index category state; name cutRange_{indexStateName}. RooChi2Var(const char* name, const char* title, RooAbsReal& func, RooDataHist& data, const RooArgSet& projDeps, RooChi2Var::FuncMode funcMode, const char* rangeName = 0, const char* addCoefRangeName = 0, Int_t nCPU = 1, RooFit::MPSplit interleave = RooFit::BulkPartition, Bool_t verbose = kTRUE, Bool_t splitCutRange = kTRUE, RooDataHist::ErrorType = RooDataHist::SumW2); Constructor of a chi2 for given p.d.f. with respect given binned; dataset taking the observables specified in projDeps as projected; observables. If cutRange is specified the calculation of the chi2; is restricted to that named range. If addCoefRange is specified,; the interpretation of fractions for all component RooAddPdfs that; do not have ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooChi2Var.html:47779,load,load,47779,root/html602/RooChi2Var.html,https://root.cern,https://root.cern/root/html602/RooChi2Var.html,4,['load'],['load']
Performance,"ndividual instances:; o = ROOT.TObject(); ROOT.SetOwnership( o, False ) # True to own, False to release; 19.1.6.2 Memory Management by Hand; If needed, you can explicitly destroy a ROOT object that you own through its associated TClass:; myobject.IsA().Destructor(myobject); which will send out the deletion notification to the system (thus you do not need to care anymore at this point about Python reference counting, the object will go, even if it’s reference count it non-zero), and free the memory.; 19.1.7 Performance; The performance of PyROOT when programming with ROOT in Python is similar to that of Cling. Differences occur mainly because of differences in the respective languages: C++ is much harder to parse, but once parsed, it is much easier to optimize. Consequently, individual calls to ROOT are typically faster from PyROOT, whereas loops are typically slower.; When programming in Python, the modus operandi is to consider performance generally “good enough” on the outset, and when it turns out that, it is not good enough; the performance critical part is converted into C/C++ in an extension module. The school of thought where pre-mature optimization is the root of all evil should find this way of working very satisfying. In addition, if you look at their history, you will see that many of the standard Python modules have followed this path.; Your code should always make maximum use of ROOT facilities; such that most of the time is spending in compiled code. This goes even for very simple things: e.g. do not compute invariant masses in Python, use TLorentzVector instead. Moreover, before you start optimizing, make sure that you have run a profiler to find out where the bottlenecks are. Some performance, without cost in terms of programmer effort, may be gained by using psyco, see the next link: http://psyco.sourceforge.net, a Python just in time compiler (JIT). Note, however, that psyco is limited to Intel i386 CPUs. Since psyco optimizes Python, not PyROOT cal",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1063178,perform,performance,1063178,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,4,['perform'],['performance']
Performance,"ndl;; 2432 ; 2433 SaveMarkerAttributes(out, chName.Data(), 1, 1, 1);; 2434}; 2435 ; 2436////////////////////////////////////////////////////////////////////////////////; 2437/// Loop on tree and print entries passing selection.; 2438/// - If varexp is 0 (or """") then print only first 8 columns.; 2439/// - If varexp = ""*"" print all columns.; 2440/// - Otherwise a columns selection can be made using ""var1:var2:var3"".; 2441/// See TTreePlayer::Scan for more information.; 2442 ; 2443Long64_t TChain::Scan(const char* varexp, const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); 2444{; 2445 if (LoadTree(firstentry) < 0) {; 2446 return 0;; 2447 }; 2448 return TTree::Scan(varexp, selection, option, nentries, firstentry);; 2449}; 2450 ; 2451////////////////////////////////////////////////////////////////////////////////; 2452/// Set the global branch kAutoDelete bit.; 2453///; 2454/// When LoadTree loads a new Tree, the branches for which; 2455/// the address is set will have the option AutoDelete set; 2456/// For more details on AutoDelete, see TBranch::SetAutoDelete.; 2457 ; 2458void TChain::SetAutoDelete(bool autodelete); 2459{; 2460 if (autodelete) {; 2461 SetBit(kAutoDelete, true);; 2462 } else {; 2463 SetBit(kAutoDelete, false);; 2464 }; 2465}; 2466 ; 2467Int_t TChain::SetCacheSize(Long64_t cacheSize); 2468{; 2469 // Set the cache size of the underlying TTree,; 2470 // See TTree::SetCacheSize.; 2471 // Returns 0 cache state ok (exists or not, as appropriate); 2472 // -1 on error; 2473 ; 2474 Int_t res = 0;; 2475 ; 2476 // remember user has requested this cache setting; 2477 fCacheUserSet = true;; 2478 ; 2479 if (fTree) {; 2480 res = fTree->SetCacheSize(cacheSize);; 2481 } else {; 2482 // If we don't have a TTree yet only record the cache size wanted; 2483 res = 0;; 2484 }; 2485 fCacheSize = cacheSize; // Record requested size.; 2486 return res;; 2487}; 2488 ; 2489////////////////////////////////////////////////////////////////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TChain_8cxx_source.html:88601,load,loads,88601,doc/master/TChain_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TChain_8cxx_source.html,1,['load'],['loads']
Performance,"ndle,; 96 const char* canonicalName);; 97 void TCling__LibraryUnloaded(const void* dyLibHandle,; 98 const char* canonicalName);; 99 void TCling__RegisterRdictForLoadPCM(const std::string &pcmFileNameFullPath, llvm::StringRef *pcmContent);; 100}; 101 ; 102class TCling final : public TInterpreter {; 103private: // Static Data Members; 104 ; 105 static void* fgSetOfSpecials; // set of TObjects used in CINT variables; 106 ; 107private: // Data Members; 108 ; 109 Int_t fExitCode; // Value passed to exit() in interpreter.; 110 char fPrompt[64]; // Command line prompt string.; 111 //cling::DictPosition fDictPos; // dictionary context after initialization is complete.; 112 //cling::DictPosition fDictPosGlobals; // dictionary context after ResetGlobals().; 113 TString fSharedLibs; // Shared libraries loaded by G__loadfile().; 114 Int_t fGlobalsListSerial;// Last time we refreshed the ROOT list of globals.; 115 TString fIncludePath; // Interpreter include path.; 116 TString fRootmapLoadPath; // Dynamic load path for rootmap files.; 117 TEnv* fMapfile; // Association of classes to libraries.; 118 std::vector<std::string> fAutoLoadLibStorage; // A storage to return a const char* from GetClassSharedLibsForModule.; 119 std::map<size_t,std::vector<const char*>> fClassesHeadersMap; // Map of classes hashes and headers associated; 120 std::map<const cling::Transaction*,size_t> fTransactionHeadersMap; // Map which transaction contains which autoparse.; 121 std::set<size_t> fLookedUpClasses; // Set of classes for which headers were looked up already; 122 std::set<size_t> fPayloads; // Set of payloads; 123 std::set<const char*> fParsedPayloadsAddresses; // Set of payloads which were parsed; 124 std::hash<std::string> fStringHashFunction; // A simple hashing function; 125 std::unordered_set<const clang::NamespaceDecl*> fNSFromRootmaps; // Collection of namespaces fwd declared in the rootmaps; 126 TObjArray* fRootmapFiles; // Loaded rootmap files.; 127 Bool_t fLockProcessLine; // True if ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8h_source.html:3687,load,load,3687,doc/master/TCling_8h_source.html,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html,1,['load'],['load']
Performance,"ndle.cxx:666; TCandle::IsViolinScaledBool_t IsViolinScaled() constReturns true if violin plot should be scaled.Definition TCandle.cxx:191; TCandle::IsHorizontalBool_t IsHorizontal() constDefinition TCandle.h:112; TCandle::ParseOptionint ParseOption(char *optin)Parsing of the option-string.Definition TCandle.cxx:244; TCandle::SetOptionvoid SetOption(CandleOption opt)Definition TCandle.h:117; TCandle::SetHistogramvoid SetHistogram(TH1D *proj)Definition TCandle.h:123; TCandle::IsCandleScaledBool_t IsCandleScaled() constReturns true if candle plot should be scaled.Definition TCandle.cxx:183; TCandle::SetCandleWidthvoid SetCandleWidth(const Double_t width)Definition TCandle.h:121; TCandle::SetAxisPositionvoid SetAxisPosition(const Double_t candlePos)Definition TCandle.h:119; TCanvas::SupportAlphastatic Bool_t SupportAlpha()Static function returning ""true"" if transparency is supported.Definition TCanvas.cxx:2476; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:3035; TCollection::SetNamevoid SetName(const char *name)Definition TCollection.h:206; TCollection::GetSizevirtual Int_t GetSize() constReturn the capacity of the collection, i.e.Definition TCollection.h:184; TCollection::Paintvoid Paint(Option_t *option="""") overridePaint all objects in this collection.Definition TCollection.cxx:417; TColorThe color creation and management class.Definition TColor.h:21; TColor::SetRGBvirtual void SetRGB(Float_t r, Float_t g, Float_t b)Initialize this color and its ""dark"" and ""bright"" associated colors.Definition TColor.cxx:1850; TColor::RGBtoHLSstatic void RGBtoHLS(Float_t r, Float_t g, Float_t b, Float_t &h, Float_t &l, Float_t &s)Definition TColor.h:82; TColor::GetRGBvirtual void GetRGB(Float_t &r, Float_t &g, Float_t &b) constDefinition TColor.h:54; TColor::GetColorstatic Int_t GetColor(const char *hexcolor)Static method returning color numbe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THistPainter_8cxx_source.html:449946,load,load,449946,doc/master/THistPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html,1,['load'],['load']
Performance,"ndling -- RooTreeDataStore::loadValues(ds) Skipping event #8 because y cannot accommodate the value 11.1861; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping event #12 because y cannot accommodate the value 13.7009; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping event #14 because y cannot accommodate the value -10.6852; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping ...; [#0] WARNING:DataHandling -- RooTreeDataStore::loadValues(ds) Ignored 35 out-of-range events; RooDataSet::ds[x,y] = 65 entries; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds2) Skipping event #7 because y cannot accommodate the value 13.3845; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds2) Skipping event #8 because y cannot accommodate the value 11.1861; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds2) Skipping event #12 because y cannot accommodate the value 13.7009; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds2) Skipping event #14 because y cannot accommodate the value -10.6852; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds2) Skipping ...; [#0] WARNING:DataHandling -- RooTreeDataStore::loadValues(ds2) Ignored 36 out-of-range events; RooDataSet::ds2[x,y,z] = 26 entries; [#1] INFO:DataHandling -- RooAbsReal::attachToTree(i) TTree Int_t branch i will be converted to double precision.; RooDataSet::ds3[i,x] = 100 entries; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds4) Skipping event #2 because i cannot accommodate the value 0; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds4) Skipping event #5 because i cannot accommodate the value 0; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds4) Skipping event #8 because i cannot accommodate the value 0; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds4) Skipping event #11 because i cannot accommodate the value 0; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds4) Skipping ...; [#0] WARNING:DataH",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf401__importttreethx_8C.html:8077,load,loadValues,8077,doc/master/rf401__importttreethx_8C.html,https://root.cern,https://root.cern/doc/master/rf401__importttreethx_8C.html,1,['load'],['loadValues']
Performance,"ndoArgsundo values; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static TCollection::(anonymous)TCollection::kIsOwner. Class Charts. Inheritance Chart:. TObject. ←; TCollection. ←; TSeqCollection. ←; TList. TQObject. ←; TQCommand. ←; TQUndoManager. Function documentation; TQUndoManager(); Constructor. ~TQUndoManager(); Destructor. void ls(Option_t* option = """") const; Lists all commands in stack. void PrintCollectionEntry(TObject* entry, Option_t* option, Int_t recurse) const; Print collection entry. void SetLogging(Bool_t on = kTRUE); Start logging. Delete all previous log records; Note: logging is not implemented yet. void Add(TObject* obj, Option_t* opt); Add command to the stack of commands.; Command's redo action will be executed. option string can contain the following substrings:; ""merge"" - input command will be merged; ""compress"" - input command will be compressed. void CurrentChanged(TQCommand* c); emit signal. void Undo(Option_t* option = """"); Performs undo action. Move cursor position backward in history stack. void Redo(Option_t* option = """"); Performs redo action. Move cursor position forward in history stack. Bool_t CanRedo() const; Returns kTRUE if redo action is possible. Bool_t CanUndo() const; Returns kTRUE if undo action is possible. Bool_t IsLogging() const; Returns kTRUE if logging is ON. TQCommand * GetCurrent() const; Returns the last executed command. TQCommand * GetCursor() const; Returns a command correspondent to the current cursor position in stack. void SetLimit(UInt_t limit); Returns a maximum number of commands which could be located in stack. UInt_t GetLimit() const; Returns a maximum number of commands which could be located in stack. TQCommand & operator=(const TQUndoManager& ). void Add(TObject* obj, Option_t* opt). TQUndoManager(). » Author: Valeriy Onuchin 04/27/2004 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-02 16:31",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TQUndoManager.html:20152,Perform,Performs,20152,root/html604/TQUndoManager.html,https://root.cern,https://root.cern/root/html604/TQUndoManager.html,1,['Perform'],['Performs']
Performance,"ndoArgsundo values; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static TCollection::(anonymous)TCollection::kIsOwner. Class Charts. Inheritance Chart:. TObject. ←; TCollection. ←; TSeqCollection. ←; TList. TQObject. ←; TQCommand. ←; TQUndoManager. Function documentation; TQUndoManager(); Constructor. ~TQUndoManager(); Destructor. void ls(Option_t* option = """") const; Lists all commands in stack. void PrintCollectionEntry(TObject* entry, Option_t* option, Int_t recurse) const; Print collection entry. void SetLogging(Bool_t on = kTRUE); Start logging. Delete all previous log records; Note: logging is not implemented yet. void Add(TObject* obj, Option_t* opt); Add command to the stack of commands.; Command's redo action will be executed. option string can contain the following substrings:; ""merge"" - input command will be merged; ""compress"" - input command will be compressed. void CurrentChanged(TQCommand* c); emit signal. void Undo(Option_t* option = """"); Performs undo action. Move cursor position backward in history stack. void Redo(Option_t* option = """"); Performs redo action. Move cursor position forward in history stack. Bool_t CanRedo() const; Returns kTRUE if redo action is possible. Bool_t CanUndo() const; Returns kTRUE if undo action is possible. Bool_t IsLogging() const; Returns kTRUE if logging is ON. TQCommand * GetCurrent() const; Returns the last executed command. TQCommand * GetCursor() const; Returns a command correspondent to the current cursor position in stack. void SetLimit(UInt_t limit); Returns a maximum number of commands which could be located in stack. UInt_t GetLimit() const; Returns a maximum number of commands which could be located in stack. TQCommand & operator=(const TQUndoManager& ). void Add(TObject* obj, Option_t* opt). TQUndoManager(). » Author: Valeriy Onuchin 04/27/2004 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-30 15:29",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TQUndoManager.html:20152,Perform,Performs,20152,root/html602/TQUndoManager.html,https://root.cern,https://root.cern/root/html602/TQUndoManager.html,1,['Perform'],['Performs']
Performance,"ndomRays(Int_t nrays, Double_t startx, Double_t starty, Double_t startz); Shoot nrays in the current drawn geometry. void Raytrace(Option_t* option = """"); Raytrace current drawn geometry. TGeoNode * SamplePoints(Int_t npoints, Double_t& dist, Double_t epsil, const char* g3path); shoot npoints randomly in a box of 1E-5 arround current point.; return minimum distance to points outside. void SetBombFactors(Double_t bombx = 1.3, Double_t bomby = 1.3, Double_t bombz = 1.3, Double_t bombr = 1.3); --- Set cartesian and radial bomb factors for translations. void SetExplodedView(Int_t iopt = 0); set type of exploding view. void SetNsegments(Int_t nseg = 20); Set number of segments to approximate circles. void SetNmeshPoints(Int_t npoints); Set number of points to be generated on the shape outline when checking for overlaps. void SetCheckedNode(TGeoNode* node); Select a node to be checked for overlaps. All overlaps not involving it will; be ignored. void SetVisLevel(Int_t level = 3); Set default level down to which visualization is performed. void SetTopVisible(Bool_t vis = kTRUE); Set top geometry volume as visible. void SetVisOption(Int_t option = 0); set drawing mode :; option=0 (default) all nodes drawn down to vislevel; option=1 leaves and nodes at vislevel drawn; option=2 path is drawn. Int_t ShapeDistancetoPrimitive(const TGeoShape* shape, Int_t numpoints, Int_t px, Int_t py) const; Returns distance between point px,py on the pad an a shape. void Test(Int_t npoints, Option_t* option); Check time of finding ""Where am I"" for n points. void TestOverlaps(const char* path); --- Geometry overlap checker based on sampling. Bool_t TestVoxels(TGeoVolume* vol); Check voxels efficiency per volume. void UnbombTranslation(const Double_t* tr, Double_t* bombtr); get the new 'unbombed' translation vector according current exploded view mode. Double_t Weight(Double_t precision, Option_t* option = ""v""); Compute weight [kg] of the current volume. TGeoPainter(TGeoManager* manager). void Ge",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoPainter.html:19408,perform,performed,19408,root/html528/TGeoPainter.html,https://root.cern,https://root.cern/root/html528/TGeoPainter.html,4,['perform'],['performed']
Performance,"ndow to handle all callbacks One has to be sure,...Definition RWebWindow.cxx:1680; ROOT::RWebWindow::fConnCntunsigned fConnCnt! counter of new connections to assign idsDefinition RWebWindow.hxx:148; ROOT::RWebWindow::fProtocolConnIdunsigned fProtocolConnId! connection id, which is used for writing protocolDefinition RWebWindow.hxx:172; ROOT::RWebWindow::GetWindowConnectionsConnectionsList_t GetWindowConnections(unsigned connid=0, bool only_active=false) constreturns connection list (or all active connections)Definition RWebWindow.cxx:1458; ROOT::RWebWindow::fSendMTbool fSendMT! true is special threads should be used for sending dataDefinition RWebWindow.hxx:145; ROOT::RWebWindow::fCallbacksThrdIdstd::thread::id fCallbacksThrdId! thread id where callbacks should be invokedDefinition RWebWindow.hxx:160; ROOT::RWebWindow::RemoveKeyvoid RemoveKey(const std::string &key)Removes all connections with the key.Definition RWebWindow.cxx:583; ROOT::RWebWindow::fInputQueuestd::queue< QueueEntry > fInputQueue! input queue for all callbacksDefinition RWebWindow.hxx:164; ROOT::RWebWindow::_CanTrustInbool _CanTrustIn(std::shared_ptr< WebConn > &conn, const std::string &key, const std::string &ntry, bool remote, bool test_first_time)Check if provided hash, ntry parameters from the connection request could be accepted.Definition RWebWindow.cxx:513; ROOT::RWebWindow::SetConnTokenvoid SetConnToken(const std::string &token="""")Configures connection token (default none) When specified, in URL of webpage such token should be pro...Definition RWebWindow.cxx:715; ROOT::RWebWindow::MakeHeadlessunsigned MakeHeadless(bool create_new=false)Start headless browser for specified window Normally only single instance is used,...Definition RWebWindow.cxx:202; ROOT::RWebWindow::GetUrlstd::string GetUrl(bool remote=true)Return URL string to connect web window URL typically includes extra parameters required for connecti...Definition RWebWindow.cxx:173; ROOT::RWebWindow::CloseConnectionsvoid CloseConnecti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RWebWindow_8hxx_source.html:24534,queue,queue,24534,doc/v632/RWebWindow_8hxx_source.html,https://root.cern,https://root.cern/doc/v632/RWebWindow_8hxx_source.html,2,['queue'],['queue']
Performance,"ndow to handle all callbacks One has to be sure,...Definition RWebWindow.cxx:1722; ROOT::RWebWindow::fConnCntunsigned fConnCnt! counter of new connections to assign idsDefinition RWebWindow.hxx:151; ROOT::RWebWindow::fProtocolConnIdunsigned fProtocolConnId! connection id, which is used for writing protocolDefinition RWebWindow.hxx:175; ROOT::RWebWindow::GetWindowConnectionsConnectionsList_t GetWindowConnections(unsigned connid=0, bool only_active=false) constreturns connection list (or all active connections)Definition RWebWindow.cxx:1500; ROOT::RWebWindow::fSendMTbool fSendMT! true is special threads should be used for sending dataDefinition RWebWindow.hxx:148; ROOT::RWebWindow::fCallbacksThrdIdstd::thread::id fCallbacksThrdId! thread id where callbacks should be invokedDefinition RWebWindow.hxx:163; ROOT::RWebWindow::RemoveKeyvoid RemoveKey(const std::string &key)Removes all connections with the key.Definition RWebWindow.cxx:584; ROOT::RWebWindow::fInputQueuestd::queue< QueueEntry > fInputQueue! input queue for all callbacksDefinition RWebWindow.hxx:167; ROOT::RWebWindow::_CanTrustInbool _CanTrustIn(std::shared_ptr< WebConn > &conn, const std::string &key, const std::string &ntry, bool remote, bool test_first_time)Check if provided hash, ntry parameters from the connection request could be accepted.Definition RWebWindow.cxx:514; ROOT::RWebWindow::SetConnTokenvoid SetConnToken(const std::string &token="""")Configures connection token (default none) When specified, in URL of webpage such token should be pro...Definition RWebWindow.cxx:716; ROOT::RWebWindow::MakeHeadlessunsigned MakeHeadless(bool create_new=false)Start headless browser for specified window Normally only single instance is used,...Definition RWebWindow.cxx:202; ROOT::RWebWindow::GetUrlstd::string GetUrl(bool remote=true)Return URL string to connect web window URL typically includes extra parameters required for connecti...Definition RWebWindow.cxx:173; ROOT::RWebWindow::CloseConnectionsvoid CloseConnecti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RWebWindow_8hxx_source.html:24923,queue,queue,24923,doc/master/RWebWindow_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RWebWindow_8hxx_source.html,2,['queue'],['queue']
Performance,"ndow::fDataCallback. private . ! main callback when data over channel 1 is arrived ; Definition at line 158 of file RWebWindow.hxx. ◆ fDefaultPage. std::string ROOT::RWebWindow::fDefaultPage. private . ! HTML page (or file name) returned when window URL is opened ; Definition at line 139 of file RWebWindow.hxx. ◆ fDisconnCallback. WebWindowConnectCallback_t ROOT::RWebWindow::fDisconnCallback. private . ! callback for disconnect event ; Definition at line 159 of file RWebWindow.hxx. ◆ fHasWindowThrd. bool ROOT::RWebWindow::fHasWindowThrd {false}. private . ! indicate if special window thread was started ; Definition at line 162 of file RWebWindow.hxx. ◆ fHeight. unsigned ROOT::RWebWindow::fHeight {0}. private . ! initial window width and height when displayed, zeros are ignored ; Definition at line 166 of file RWebWindow.hxx. ◆ fId. unsigned ROOT::RWebWindow::fId {0}. private . ! unique identifier ; Definition at line 141 of file RWebWindow.hxx. ◆ fInputQueue. std::queue<QueueEntry> ROOT::RWebWindow::fInputQueue. private . ! input queue for all callbacks ; Definition at line 164 of file RWebWindow.hxx. ◆ fInputQueueMutex. std::mutex ROOT::RWebWindow::fInputQueueMutex. private . ! mutex to protect input queue ; Definition at line 165 of file RWebWindow.hxx. ◆ fMaster. std::shared_ptr<RWebWindow> ROOT::RWebWindow::fMaster. private . ! master window where this window is embedded ; Definition at line 137 of file RWebWindow.hxx. ◆ fMasterConns. std::vector<MasterConn> ROOT::RWebWindow::fMasterConns. private . ! master connections ; Definition at line 138 of file RWebWindow.hxx. ◆ fMaxQueueLength. unsigned ROOT::RWebWindow::fMaxQueueLength {10}. private . ! maximal number of queue entries ; Definition at line 156 of file RWebWindow.hxx. ◆ fMgr. std::shared_ptr<RWebWindowsManager> ROOT::RWebWindow::fMgr. private . ! display manager ; Definition at line 136 of file RWebWindow.hxx. ◆ fNativeOnlyConn. bool ROOT::RWebWindow::fNativeOnlyConn {false}. private . ! only native conn",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RWebWindow.html:55988,queue,queue,55988,doc/v632/classROOT_1_1RWebWindow.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RWebWindow.html,1,['queue'],['queue']
Performance,"ndow::fDataCallback. private . ! main callback when data over channel 1 is arrived ; Definition at line 161 of file RWebWindow.hxx. ◆ fDefaultPage. std::string ROOT::RWebWindow::fDefaultPage. private . ! HTML page (or file name) returned when window URL is opened ; Definition at line 142 of file RWebWindow.hxx. ◆ fDisconnCallback. WebWindowConnectCallback_t ROOT::RWebWindow::fDisconnCallback. private . ! callback for disconnect event ; Definition at line 162 of file RWebWindow.hxx. ◆ fHasWindowThrd. bool ROOT::RWebWindow::fHasWindowThrd {false}. private . ! indicate if special window thread was started ; Definition at line 165 of file RWebWindow.hxx. ◆ fHeight. unsigned ROOT::RWebWindow::fHeight {0}. private . ! initial window width and height when displayed, zeros are ignored ; Definition at line 169 of file RWebWindow.hxx. ◆ fId. unsigned ROOT::RWebWindow::fId {0}. private . ! unique identifier ; Definition at line 144 of file RWebWindow.hxx. ◆ fInputQueue. std::queue<QueueEntry> ROOT::RWebWindow::fInputQueue. private . ! input queue for all callbacks ; Definition at line 167 of file RWebWindow.hxx. ◆ fInputQueueMutex. std::mutex ROOT::RWebWindow::fInputQueueMutex. private . ! mutex to protect input queue ; Definition at line 168 of file RWebWindow.hxx. ◆ fMaster. std::shared_ptr<RWebWindow> ROOT::RWebWindow::fMaster. private . ! master window where this window is embedded ; Definition at line 140 of file RWebWindow.hxx. ◆ fMasterConns. std::vector<MasterConn> ROOT::RWebWindow::fMasterConns. private . ! master connections ; Definition at line 141 of file RWebWindow.hxx. ◆ fMaxQueueLength. unsigned ROOT::RWebWindow::fMaxQueueLength {10}. private . ! maximal number of queue entries ; Definition at line 159 of file RWebWindow.hxx. ◆ fMgr. std::shared_ptr<RWebWindowsManager> ROOT::RWebWindow::fMgr. private . ! display manager ; Definition at line 139 of file RWebWindow.hxx. ◆ fNativeOnlyConn. bool ROOT::RWebWindow::fNativeOnlyConn {false}. private . ! only native conn",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RWebWindow.html:54872,queue,queue,54872,doc/master/classROOT_1_1RWebWindow.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RWebWindow.html,1,['queue'],['queue']
Performance,"ndows(Window_t id). void MapRaised(Window_t id). void UnmapWindow(Window_t id). void DestroyWindow(Window_t id). void DestroySubwindows(Window_t id). void RaiseWindow(Window_t id). void LowerWindow(Window_t id). void MoveResizeWindow(Window_t id, Int_t x, Int_t y, UInt_t w, UInt_t h). void IconifyWindow(Window_t id). void ReparentWindow(Window_t id, Window_t pid, Int_t x, Int_t y). void SetWindowBackground(Window_t id, ULong_t color). void SetWindowBackgroundPixmap(Window_t id, Pixmap_t pxm). Window_t CreateWindow(Window_t parent, Int_t x, Int_t y, UInt_t w, UInt_t h, UInt_t border, Int_t depth, UInt_t clss, void* visual, SetWindowAttributes_t* attr, UInt_t wtype). void CloseDisplay(). Display_t GetDisplay() const. Visual_t GetVisual() const. Int_t GetScreen() const. Int_t GetDepth() const. Colormap_t GetColormap() const. Atom_t InternAtom(const char* atom_name, Bool_t only_if_exist). Window_t GetDefaultRootWindow() const. Window_t GetParent(Window_t id) const. FontStruct_t LoadQueryFont(const char* font_name). FontH_t GetFontHandle(FontStruct_t fs). void DeleteFont(FontStruct_t fs). GContext_t CreateGC(Drawable_t id, GCValues_t* gval). void ChangeGC(GContext_t gc, GCValues_t* gval). void CopyGC(GContext_t org, GContext_t dest, Mask_t mask). void DeleteGC(GContext_t gc). Cursor_t CreateCursor(ECursor cursor). Pixmap_t CreatePixmap(Drawable_t id, UInt_t w, UInt_t h). Pixmap_t CreatePixmap(Drawable_t id, const char* bitmap, UInt_t width, UInt_t height, ULong_t forecolor, ULong_t backcolor, Int_t depth). Pixmap_t CreateBitmap(Drawable_t id, const char* bitmap, UInt_t width, UInt_t height). Bool_t CreatePictureFromFile(Drawable_t id, const char* filename, Pixmap_t& pict, Pixmap_t& pict_mask, PictureAttributes_t& attr). Bool_t ReadPictureDataFromFile(const char* filename, char*** ret_data). void DeletePictureData(void* data). void SetDashes(GContext_t gc, Int_t offset, const char* dash_list, Int_t n). Bool_t ParseColor(Colormap_t cmap, const char* cname, ColorStruct_t& co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGX11.html:41184,Load,LoadQueryFont,41184,root/html532/TGX11.html,https://root.cern,https://root.cern/root/html532/TGX11.html,4,['Load'],['LoadQueryFont']
Performance,"ne 236 of file TSQLFile.h. ◆ ProduceClassSelectQuery(). Bool_t TSQLFile::ProduceClassSelectQuery ; (; TVirtualStreamerInfo * ; info, . TSQLClassInfo * ; sqlinfo, . TString & ; columns, . TString & ; tables, . Int_t & ; tablecnt . ). protected . used by MakeClassSelectQuery method to add columns from table of class, specified by TVirtualStreamerInfo structure ; Definition at line 1237 of file TSQLFile.cxx. ◆ ReadBuffer() [1/2]. Bool_t TSQLFile::ReadBuffer ; (; char * ; buf, . Int_t ; len . ). inlinefinalvirtual . Read a buffer from the file. ; This is the basic low level read operation. Returns kTRUE in case of failure. ; Reimplemented from TFile.; Definition at line 237 of file TSQLFile.h. ◆ ReadBuffer() [2/2]. Bool_t TSQLFile::ReadBuffer ; (; char * ; buf, . Long64_t ; pos, . Int_t ; len . ). inlinefinalvirtual . Read a buffer from the file at the offset 'pos' in the file. ; Returns kTRUE in case of failure. Compared to ReadBuffer(char*, Int_t), this routine does not change the cursor on the physical file representation (fD) if the data is in this TFile's cache. ; Reimplemented from TFile.; Definition at line 238 of file TSQLFile.h. ◆ ReadConfigurations(). Bool_t TSQLFile::ReadConfigurations ; (; ). protected . read table configurations as special table ; Definition at line 1054 of file TSQLFile.cxx. ◆ ReadFree(). void TSQLFile::ReadFree ; (; ). inlinefinalvirtual . Read the FREE linked list. ; Every file has a linked list (fFree) of free segments. This linked list has been written on the file via WriteFree as a single data record. ; Reimplemented from TFile.; Definition at line 239 of file TSQLFile.h. ◆ ReadSpecialObject(). TObject * TSQLFile::ReadSpecialObject ; (; Long64_t ; keyid, . TObject * ; obj = nullptr . ). protected . Read data of special kind of objects. ; Definition at line 851 of file TSQLFile.cxx. ◆ ReadSQLClassInfos(). void TSQLFile::ReadSQLClassInfos ; (; ). protected . Read all class infos from IdsTable. ; Definition at line 1911 of file TSQLFile.c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSQLFile.html:83449,cache,cache,83449,doc/master/classTSQLFile.html,https://root.cern,https://root.cern/doc/master/classTSQLFile.html,1,['cache'],['cache']
Performance,ne 253 of file RuleFitParams.h. ◆ fNEveEffPath. Double_t TMVA::RuleFitParams::fNEveEffPath. protected . sum of weights for Path events ; Definition at line 201 of file RuleFitParams.h. ◆ fNEveEffPerf. Double_t TMVA::RuleFitParams::fNEveEffPerf. protected . idem for Perf events ; Definition at line 202 of file RuleFitParams.h. ◆ fNLinear. UInt_t TMVA::RuleFitParams::fNLinear. protected . number of linear terms ; Definition at line 192 of file RuleFitParams.h. ◆ fNRules. UInt_t TMVA::RuleFitParams::fNRules. protected . number of rules ; Definition at line 191 of file RuleFitParams.h. ◆ fNTCoeff. Double_t* TMVA::RuleFitParams::fNTCoeff. protected . GD path: rule coefficients. ; Definition at line 243 of file RuleFitParams.h. ◆ fNTCoefRad. Double_t TMVA::RuleFitParams::fNTCoefRad. protected . GD path: 'radius' of all rulecoeffs. ; Definition at line 241 of file RuleFitParams.h. ◆ fNTErrorRate. Double_t TMVA::RuleFitParams::fNTErrorRate. protected . GD path: error rate (or performance) ; Definition at line 239 of file RuleFitParams.h. ◆ fNTLinCoeff. Double_t* TMVA::RuleFitParams::fNTLinCoeff. protected . GD path: linear coefficients. ; Definition at line 244 of file RuleFitParams.h. ◆ fNTNuval. Double_t TMVA::RuleFitParams::fNTNuval. protected . GD path: value of nu. ; Definition at line 240 of file RuleFitParams.h. ◆ fNTOffset. Double_t TMVA::RuleFitParams::fNTOffset. protected . GD path: model offset. ; Definition at line 242 of file RuleFitParams.h. ◆ fNTRisk. Double_t TMVA::RuleFitParams::fNTRisk. protected . GD path: risk. ; Definition at line 238 of file RuleFitParams.h. ◆ fPathIdx1. UInt_t TMVA::RuleFitParams::fPathIdx1. protected . first event index for path search ; Definition at line 197 of file RuleFitParams.h. ◆ fPathIdx2. UInt_t TMVA::RuleFitParams::fPathIdx2. protected . last event index for path search ; Definition at line 198 of file RuleFitParams.h. ◆ fPerfIdx1. UInt_t TMVA::RuleFitParams::fPerfIdx1. protected . first event index for performance evaluatio,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1RuleFitParams.html:25350,perform,performance,25350,doc/master/classTMVA_1_1RuleFitParams.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1RuleFitParams.html,1,['perform'],['performance']
Performance,"ne 57 of file TEveProjectionManager.h. ◆ GetImportEmpty(). Bool_t TEveProjectionManager::GetImportEmpty ; (; ); const. inline . Definition at line 60 of file TEveProjectionManager.h. ◆ GetProjection(). TEveProjection * TEveProjectionManager::GetProjection ; (; ). inline . Definition at line 49 of file TEveProjectionManager.h. ◆ HandleElementPaste(). Bool_t TEveProjectionManager::HandleElementPaste ; (; TEveElement * ; el). overridevirtual . React to element being pasted or dnd-ed. ; Return true if redraw is needed (virtual method). ; Reimplemented from TEveElement.; Definition at line 172 of file TEveProjectionManager.cxx. ◆ ImportElements(). TEveElement * TEveProjectionManager::ImportElements ; (; TEveElement * ; el, . TEveElement * ; ext_list = nullptr . ). virtual . Recursively import elements and apply projection to the newly imported objects. ; If ext_list is not 0 the new element is also added to the list. This simplifies construction of complex views where projected elements are distributed into several scenes for optimization of updates and rendering.; Returns the projected replica of el. Can be 0, if el and none of its children are projectable. ; Definition at line 279 of file TEveProjectionManager.cxx. ◆ ImportElementsRecurse(). TEveElement * TEveProjectionManager::ImportElementsRecurse ; (; TEveElement * ; el, . TEveElement * ; parent . ). virtual . If el is TEveProjectable add projected instance else add plain TEveElementList to parent. ; Call the same function on el's children.; Returns the projected replica of el. Can be 0, if el and none of its children are projectable. ; Definition at line 225 of file TEveProjectionManager.cxx. ◆ IsA(). TClass * TEveProjectionManager::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TEveElementList.; Definition at line 77 of file TEveProjectionManager.h. ◆ operator=(). TEveProjectionManager & TEveProjectionManager::operator= ; (; const TEveProjectionManager & ; )",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEveProjectionManager.html:40153,optimiz,optimization,40153,doc/master/classTEveProjectionManager.html,https://root.cern,https://root.cern/doc/master/classTEveProjectionManager.html,1,['optimiz'],['optimization']
Performance,"ne after the CINT dictionary has been fully populated and ca...Definition TClass.cxx:6026; TClass::LoadClassstatic TClass * LoadClass(const char *requestedname, Bool_t silent)Helper function used by TClass::GetClass().Definition TClass.cxx:5816; TClass::SizeInt_t Size() constReturn size of object of this class.Definition TClass.cxx:5771; TClass::kLoading@ kLoadingDefinition TClass.h:332; TClass::kUnloading@ kUnloadingDefinition TClass.h:332; TClass::fStreamerInfoTObjArray * fStreamerInfoDefinition TClass.h:198; TClass::IsLoadedBool_t IsLoaded() constReturn true if the shared library of this class is currently in the a process's memory.Definition TClass.cxx:5979; TClass::GetClassInfoClassInfo_t * GetClassInfo() constDefinition TClass.h:433; TClass::fClassInfoClassInfo_t * fClassInfoDefinition TClass.h:222; TClass::GetCollectionProxyTVirtualCollectionProxy * GetCollectionProxy() constReturn the proxy describing the collection (if any).Definition TClass.cxx:2964; TClass::ResetCachesvoid ResetCaches()To clean out all caches.Definition TClass.cxx:4282; TClass::PropertyLong_t Property() const overrideReturns the properties of the TClass as a bit field stored as a Long_t value.Definition TClass.cxx:6153; TClass::ReadRulesstatic Int_t ReadRules()Read the class.rules files from the default location:.Definition TClass.cxx:1887; TClass::kInterpreted@ kInterpretedDefinition TClass.h:126; TClass::kHasTClassInit@ kHasTClassInitDefinition TClass.h:127; TClass::kEmulated@ kEmulatedDefinition TClass.h:125; TClass::kForwardDeclared@ kForwardDeclaredDefinition TClass.h:124; TClass::kNamespaceForMeta@ kNamespaceForMetaDefinition TClass.h:131; TClass::GetClassVersionVersion_t GetClassVersion() constDefinition TClass.h:420; TClass::fHasRootPcmInfostd::atomic< Bool_t > fHasRootPcmInfoC++ Property of the class (is abstract, has virtual table, etc.)Definition TClass.h:259; TClass::GetDeclFileNameconst char * GetDeclFileName() constReturn name of the file containing the declaration of this cl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:401161,cache,caches,401161,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['cache'],['caches']
Performance,"ne can use the setCacheAlpha() method to instruct RooIntegralMorph to construct a two-dimensional cache for its output values in both x and alpha. If linear interpolation is requested on the resulting output histogram, the resulting interpolation of the p.d.f in the alpha dimension will smooth out the discontinuities in the tail regions result in a continuous likelihood distribution that can be fitted. An added advantage of the cacheAlpha option is that if parameters p,q of f1,f2 are fixed, the cached values in RooIntegralMorph are valid for the entire fit session and do not need to be recalculated for each change in alpha, which may result an considerable increase in calculation speed. ; Definition at line 26 of file RooIntegralMorph.h. Classes; class  MorphCacheElem;  . Public Member Functions;  RooIntegralMorph ()=default;  ;  RooIntegralMorph (const char *name, const char *title, RooAbsReal &_pdf1, RooAbsReal &_pdf2, RooAbsReal &_x, RooAbsReal &_alpha, bool cacheAlpha=false);  Constructor with observables x, pdf shapes pdf1 and pdf2 which represent the shapes at the end points of the interpolation parameter alpha If doCacheAlpha is true, a two-dimensional cache is constructed in both alpha and x. ;  ;  RooIntegralMorph (const RooIntegralMorph &other, const char *name=nullptr);  Copy constructor. ;  ; bool cacheAlpha () const;  ; TObject * clone (const char *newname) const override;  ; TClass * IsA () const override;  ; void preferredObservableScanOrder (const RooArgSet &obs, RooArgSet &orderedObs) const override;  Indicate to the RooAbsCachedPdf base class that for the filling of the cache the traversal of the x should be in the innermost loop, to minimize recalculation of the one-dimensional internal cache for a fixed value of alpha. ;  ; bool selfNormalized () const override;  Shows if a PDF is self-normalized, which means that no attempt is made to add a normalization term. ;  ; void setCacheAlpha (bool flag);  ; void Streamer (TBuffer &) override;  Stream an ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooIntegralMorph.html:4437,cache,cacheAlpha,4437,doc/master/classRooIntegralMorph.html,https://root.cern,https://root.cern/doc/master/classRooIntegralMorph.html,2,['cache'],"['cache', 'cacheAlpha']"
Performance,"ne collection printing to given amount. ;  . Protected Member Functions; RooFit::OwningPtr< RooArgSet > actualObservables (const RooArgSet &nset) const override;  If this pdf is operated with a fixed set of observables, return the subset of the fixed observables that are actual dependents of the external input p.d.f. ;  ; RooFit::OwningPtr< RooArgSet > actualParameters (const RooArgSet &nset) const override;  If this p.d.f is operated with a fixed set of observables, return all variables of the external input p.d.f that are not one of the cache observables. ;  ; FuncCacheElem * createCache (const RooArgSet *nset) const override;  Interface function to create an internal cache object that represent each cached function configuration. ;  ; double evaluate () const override;  Dummy evaluate, it is never called. ;  ; void fillCacheObject (FuncCacheElem &cacheFunc) const override;  Update contents of cache histogram by resampling the input function. ;  ; const char * inputBaseName () const override;  Return base name for caches, i.e. the name of the cached function. ;  ; void operModeHook () override;  ; const char * payloadUniqueSuffix () const override;  ;  Protected Member Functions inherited from RooAbsCachedReal; virtual const char * binningName () const;  ; TString cacheNameSuffix (const RooArgSet &nset) const;  Construct unique suffix name for cache p.d.f object. ;  ; FuncCacheElem * getCache (const RooArgSet *nset) const;  Retrieve cache corresponding to observables in nset. ;  ;  Protected Member Functions inherited from RooAbsReal; void attachToTree (TTree &t, Int_t bufSize=32000) override;  Attach object to a branch of given TTree. ;  ; void attachToVStore (RooVectorDataStore &vstore) override;  ; void copyCache (const RooAbsArg *source, bool valueOnly=false, bool setValDirty=true) override;  Copy the cached value of another RooAbsArg to our cache. ;  ; RooFit::OwningPtr< RooAbsReal > createIntObj (const RooArgSet &iset, const RooArgSet *nset, const RooNumIntC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCachedReal.html:50044,cache,caches,50044,doc/master/classRooCachedReal.html,https://root.cern,https://root.cern/doc/master/classRooCachedReal.html,1,['cache'],['caches']
Performance,"ne verifies that : \( Q.Q^{-1} = Q^{-1}.Q = Q|_r*Q|_r + Q|_V*Q|_V + Q|_r*Q|_V -Q|_r*Q|_V + Q|_VXQ|_V = Q\leq|_r + Q\leq|_V = 1 \); The rotation of a vector V by the rotation described by a unit quaternion Q is obtained by the following operation : \( V' = Q*V*Q^{-1} \), considering V as a quaternion whose real part is null.; Numeric computation considerations :; Numerically, the quaternion multiplication involves 12 additions and 16 multiplications. It is therefore faster than 3x3 matrixes multiplication involving 18 additions and 27 multiplications.; On the contrary, rotation of a vector by the above formula ( \( Q*V*Q^{-1} \) ) involves 18 additions and 24 multiplications, whereas multiplication of a 3-vector by a 3x3 matrix involves only 6 additions and 9 multiplications.; When dealing with numerous composition of space rotation, it is therefore faster to use quaternion product. On the other hand if a huge set of vectors must be rotated by a given quaternion, it is more optimized to convert the quaternion into a rotation matrix once, and then use that later to rotate the set of vectors.; More information :; http://en.wikipedia.org/wiki/Quaternions_and_spatial_rotation; http://en.wikipedia.org/wiki/Quaternion; This Class represents all quaternions (unit or non-unit) It possesses a Normalize() method to make a given quaternion unit The Rotate(TVector3&) and Rotation(TVector3&) methods can be used even for a non-unit quaternion, in that case, the proper normalization is applied to perform the rotation.; A TRotation constructor exists than takes a quaternion for parameter (even non-unit), in that cas the proper normalisation is applied. ; Definition at line 11 of file TQuaternion.h. Public Member Functions;  TQuaternion (const Double_t *);  ;  TQuaternion (const Float_t *);  ;  TQuaternion (const TQuaternion &);  ;  TQuaternion (const TVector3 &vector, Double_t real=0);  ;  TQuaternion (Double_t real=0, Double_t X=0, Double_t Y=0, Double_t Z=0);  ;  ~TQuaternion () o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQuaternion.html:4327,optimiz,optimized,4327,doc/master/classTQuaternion.html,https://root.cern,https://root.cern/doc/master/classTQuaternion.html,1,['optimiz'],['optimized']
Performance,"ne.h:42; TAttLine::SetLineWidthvirtual void SetLineWidth(Width_t lwidth)Set the line width.Definition TAttLine.h:43; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TAttMarker::SetMarkerStylevirtual void SetMarkerStyle(Style_t mstyle=1)Set the marker style.Definition TAttMarker.h:40; TCanvasThe Canvas class.Definition TCanvas.h:23; TDirectoryFile::GetTObject * Get(const char *namecycle) overrideReturn pointer to object identified by namecycle.Definition TDirectoryFile.cxx:937; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TFile::Openstatic TFile * Open(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Create / open a file.Definition TFile.cxx:4089; TFile::SetCacheFileDirstatic Bool_t SetCacheFileDir(std::string_view cacheDir, Bool_t operateDisconnected=kTRUE, Bool_t forceCacheread=kFALSE)Sets the directory where to locally stage/cache remote files.Definition TFile.cxx:4626; TGraphAsymmErrorsTGraph with asymmetric error bars.Definition TGraphAsymmErrors.h:26; TGraphAsymmErrors::SetPointEYlowvirtual void SetPointEYlow(Int_t i, Double_t eyl)Set EYlow for point i.Definition TGraphAsymmErrors.cxx:1376; TGraphAsymmErrors::SetPointErrorvirtual void SetPointError(Double_t exl, Double_t exh, Double_t eyl, Double_t eyh)Set ex and ey values for point pointed by the mouse.Definition TGraphAsymmErrors.cxx:1299; TGraphAsymmErrors::SetPointEYhighvirtual void SetPointEYhigh(Int_t i, Double_t eyh)Set EYhigh for point i.Definition TGraphAsymmErrors.cxx:1390; TGraphErrorsA TGraphErrors is a TGraph with error bars.Definition TGraphErrors.h:26; TGraph::SetPointvirtual void SetPoint(Int_t i, Double_t x, Double_t y)Set x and y values for point number i.Definition TGraph.cxx:2342; TGraph::GetNInt_t GetN() constDefinition TGraph.h:132; TGraph::Drawv",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/AtlasExample_8C.html:7796,cache,cacheDir,7796,doc/master/AtlasExample_8C.html,https://root.cern,https://root.cern/doc/master/AtlasExample_8C.html,2,['cache'],"['cache', 'cacheDir']"
Performance,"neDim"", ""Error found in integrating function %s in [%f,%f] using %s. Result = %f +/- %f - status = %d"", GetName(), a, b, igName.c_str(), result, error, status);; 2658 TString msg(""\t\tFunction Parameters = {"");; 2659 for (int ipar = 0; ipar < GetNpar(); ++ipar) {; 2660 msg += TString::Format("" %s = %f "", GetParName(ipar), GetParameter(ipar));; 2661 if (ipar < GetNpar() - 1) msg += TString("","");; 2662 else msg += TString(""}"");; 2663 }; 2664 Info(""IntegralOneDim"", ""%s"", msg.Data());; 2665 }; 2666 return result;; 2667}; 2668 ; 2669////////////////////////////////////////////////////////////////////////////////; 2670/// Return Error on Integral of a parametric function between a and b; 2671/// due to the parameter uncertainties and their covariance matrix from the fit.; 2672/// In addition to the integral limits, this method takes as input a pointer to the fitted parameter values; 2673/// and a pointer the covariance matrix from the fit. These pointers should be retrieved from the; 2674/// previously performed fit using the TFitResult class.; 2675/// Note that to get the TFitResult, te fit should be done using the fit option `S`.; 2676/// Example:; 2677/// ~~~~{.cpp}; 2678/// TFitResultPtr r = histo->Fit(func, ""S"");; 2679/// func->IntegralError(x1,x2,r->GetParams(), r->GetCovarianceMatrix()->GetMatrixArray() );; 2680/// ~~~~; 2681///; 2682/// IMPORTANT NOTE1:; 2683///; 2684/// A null pointer to the parameter values vector and to the covariance matrix can be passed.; 2685/// In this case, when the parameter values pointer is null, the parameter values stored in this; 2686/// TF1 function object are used in the integral error computation.; 2687/// When the poassed pointer to the covariance matrix is null, a covariance matrix from the last fit is retrieved; 2688/// from a global fitter instance when it exists. Note that the global fitter instance; 2689/// esists only when ROOT is not running with multi-threading enabled (ROOT::IsImplicitMTEnabled() == True).; 2690/// When ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TF1_8cxx_source.html:99649,perform,performed,99649,doc/master/TF1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html,1,['perform'],['performed']
Performance,"near fit settings. void DoNoChi2(); Slot connected to 'no chi2' option settings. void DoRobustFit(); Slot connected to 'robust fitting' option settings. void DoNoStoreDrawing(); Slot connected to 'no storing, no drawing' settings. void DoPrintOpt(Bool_t on); Slot connected to print option settings. void DoReset(); Reset all fit parameters. void DoSetParameters(); Open set parameters dialog. void DoSliderXMoved(); Slot connected to range settings on x-axis. void DrawSelection(bool restore = false); Draws the square around the object showing where the limits for; fitting are. void DoNumericSliderXChanged(); Sincronize the numeric sliders with the graphical one. void DoSliderYMoved(); Slot connected to range settings on y-axis. void DoNumericSliderYChanged(); syncronize the numeric slider with the graphical one. void DoSliderZMoved(); Slot connected to range settings on z-axis. void DoUserDialog(); Open a dialog for getting a user defined method. void SetFunction(const char* function); Set the function to be used in performed fit. Bool_t SetObjectType(TObject* obj); Check whether the object suitable for fitting and set; its type, dimension and method combo box accordingly. void ShowObjectName(TObject* obj); Show object name on the top. Option_t * GetDrawOption() const; Get draw options of the selected object. void DoLibrary(Bool_t on); Set selected minimization library in use. void DoMinMethod(Int_t ); Set selected minimization method in use. void DoMaxIterations(); Set the maximum number of iterations. void MakeTitle(TGCompositeFrame* parent, const char* title); Create section title in the GUI. TF1* HasFitFunction(); Look in the list of function for TF1. If a TF1 is; found in the list of functions, it will be returned. void RetrieveOptions(Foption_t& , TString& , ROOT::Math::MinimizerOptions& , Int_t ); Retrieve the fitting options from all the widgets. void SetEditable(Bool_t ); Set the state of some input widgets depending on whether the fit; function can be defined",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TFitEditor.html:35588,perform,performed,35588,root/html530/TFitEditor.html,https://root.cern,https://root.cern/root/html530/TFitEditor.html,9,['perform'],['performed']
Performance,"near plane. Camera must have valid frustum cache - call Apply() after last modifcation, before using. Note: TGLBoundingBox is not really valid when filled with truncated pyramid; - this is used as a visual debug aid only so ok. TGLVertex3 EyePoint() const; Return the camera eye point (vertex) in world space; Camera must have valid frustum cache - call Apply() after last modifcation, before using. TGLVector3 EyeDirection() const; Extract the camera eye direction (vector), running from EyePoint(); Camera must have valid frustum cache - call Apply() after last modifcation, before using. TGLVertex3 FrustumCenter() const; Find the center of the camera frustum from intersection of planes; This method will work even with parallel left/right & top/bottom and; infinite eye point of ortho cameras; Camera must have valid frustum cache - call Apply() after last modifcation, before using. EOverlap FrustumOverlap(const TGLBoundingBox& box) const; Calcaulte overlap (kInside, kOutside, kPartial) of box with camera; frustum; Camera must have valid frustum cache - call Apply() after last modifcation, before using. EOverlap ViewportOverlap(const TGLBoundingBox& box) const; Calculate overlap (kInside, kOutside, kPartial) of box projection onto viewport; (as rect) against the viewport rect.; Camera must have valid frustum cache - call Apply() after last modifcation, before using. TGLRect ViewportRect(const TGLBoundingBox& box, TGLBoundingBox::EFace face) const; Calculate viewport rectangle which just contains projection of single 'face'; of world frame bounding box 'box' onto the viewport. Note use other version; of ViewportRect() if you want whole 'box' contained. TGLRect ViewportRect(const TGLBoundingBox& box, const TGLBoundingBox::EFace* face = 0) const; Calculate viewport rectangle which just contains projection of; world frame bounding box 'box' onto the viewport. If face is; null the rect contains the whole bounding box (8 vertices/6; faces). If face is non-null it indicates a box ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGLCamera.html:8190,cache,cache,8190,root/html528/TGLCamera.html,https://root.cern,https://root.cern/root/html528/TGLCamera.html,4,['cache'],['cache']
Performance,"nection (unsigned connid=0, bool only_active=true) const;  returns true if specified connection id exists ;  ; bool IsNativeOnlyConn () const;  returns true if only native (own-created) connections are allowed ;  ; bool IsRequireAuthKey () const;  returns true if authentication string is required ;  ; bool IsShown () const;  Returns true when window was shown at least once. ;  ; bool IsUseCurrentDir () const;  returns true if window can access local files via currentdir/ path of http server ;  ; int NumConnections (bool with_pending=false) const;  Returns current number of active clients connections. ;  ; void RecordData (const std::string &fname=""protocol.json"", const std::string &fprefix="""");  Configures recording of communication data in protocol file Provided filename will be used to store JSON array with names of written files - text or binary If data was send from client, ""send"" entry will be placed. ;  ; void Run (double tm=0.);  Run window functionality for specified time If no action can be performed - just sleep specified time. ;  ; void Send (unsigned connid, const std::string &data);  Sends data to specified connection. ;  ; void SendBinary (unsigned connid, const void *data, std::size_t len);  Send binary data to specified connection. ;  ; void SendBinary (unsigned connid, std::string &&data);  Send binary data to specified connection. ;  ; _R__DEPRECATED_LATER(""Use GetUrl() to get valid connection URL"") std _R__DEPRECATED_LATER(""Use GetAddr() to get valid connection URL"") std void SetCallBacks (WebWindowConnectCallback_t conn, WebWindowDataCallback_t data, WebWindowConnectCallback_t disconn=nullptr);  Set call-backs function for connect, data and disconnect events. ;  ; void SetClearOnClose (const std::shared_ptr< void > &handle=nullptr);  Set handle which is cleared when last active connection is closed Typically can be used to destroy web-based widget at such moment. ;  ; void SetClientVersion (const std::string &vers);  Set client version, used as p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RWebWindow.html:5687,perform,performed,5687,doc/master/classROOT_1_1RWebWindow.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RWebWindow.html,1,['perform'],['performed']
Performance,"nection (unsigned connid=0, bool only_active=true) const;  returns true if specified connection id exists ;  ; bool IsNativeOnlyConn () const;  returns true if only native (own-created) connections are allowed ;  ; bool IsRequireAuthKey () const;  returns true if authentication string is required ;  ; bool IsShown () const;  Returns true when window was shown at least once. ;  ; bool IsUseCurrentDir () const;  returns true if window can access local files via currentdir/ path of http server ;  ; int NumConnections (bool with_pending=false) const;  Returns current number of active clients connections. ;  ; void RecordData (const std::string &fname=""protocol.json"", const std::string &fprefix="""");  Configures recording of communication data in protocol file Provided filename will be used to store JSON array with names of written files - text or binary If data was send from client, ""send"" entry will be placed. ;  ; void Run (double tm=0.);  Run window functionality for specified time If no action can be performed - just sleep specified time. ;  ; void Send (unsigned connid, const std::string &data);  Sends data to specified connection. ;  ; void SendBinary (unsigned connid, const void *data, std::size_t len);  Send binary data to specified connection. ;  ; void SendBinary (unsigned connid, std::string &&data);  Send binary data to specified connection. ;  ; void SetCallBacks (WebWindowConnectCallback_t conn, WebWindowDataCallback_t data, WebWindowConnectCallback_t disconn=nullptr);  Set call-backs function for connect, data and disconnect events. ;  ; void SetClearOnClose (const std::shared_ptr< void > &handle=nullptr);  Set handle which is cleared when last active connection is closed Typically can be used to destroy web-based widget at such moment. ;  ; void SetClientVersion (const std::string &vers);  Set client version, used as prefix in scripts URL When changed, web browser will reload all related JS files while full URL will be different Default is empty value - n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RWebWindow.html:6223,perform,performed,6223,doc/v632/classROOT_1_1RWebWindow.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RWebWindow.html,1,['perform'],['performed']
Performance,"ned by ROOT::Math::MinimizerOptions::DefaultMinimizerType(). . AttentionThis overrides the default fitter of this RooMinimizer. ; Parameters. [in]algFit algorithm to use. (Optional) . Definition at line 281 of file RooMinimizer.cxx. ◆ minimizerType(). std::string const & RooMinimizer::minimizerType ; (; ); const. inline . Definition at line 175 of file RooMinimizer.h. ◆ minos() [1/2]. int RooMinimizer::minos ; (; ). Execute MINOS. ; Changes in parameter values and calculated errors are automatically propagated back the RooRealVars representing the floating parameters in the MINUIT operation. ; Definition at line 376 of file RooMinimizer.cxx. ◆ minos() [2/2]. int RooMinimizer::minos ; (; const RooArgSet & ; minosParamList). Execute MINOS for given list of parameters. ; Changes in parameter values and calculated errors are automatically propagated back the RooRealVars representing the floating parameters in the MINUIT operation. ; Definition at line 393 of file RooMinimizer.cxx. ◆ optimizeConst(). void RooMinimizer::optimizeConst ; (; int ; flag). If flag is true, perform constant term optimization on function being minimized. ; Definition at line 489 of file RooMinimizer.cxx. ◆ profileStart(). void RooMinimizer::profileStart ; (; ). private . Start profiling timer. ; Definition at line 698 of file RooMinimizer.cxx. ◆ profileStop(). void RooMinimizer::profileStop ; (; ). private . Stop profiling timer and report results of last session. ; Definition at line 710 of file RooMinimizer.cxx. ◆ save(). RooFit::OwningPtr< RooFitResult > RooMinimizer::save ; (; const char * ; userName = nullptr, . const char * ; userTitle = nullptr . ). Save and return a RooFitResult snapshot of current minimizer status. ; This snapshot contains the values of all constant parameters, the value of all floating parameters at RooMinimizer construction and after the last MINUIT operation, the MINUIT status, variance quality, EDM setting, number of calls with evaluation problems, the minimized func",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooMinimizer.html:24894,optimiz,optimizeConst,24894,doc/master/classRooMinimizer.html,https://root.cern,https://root.cern/doc/master/classRooMinimizer.html,1,['optimiz'],['optimizeConst']
Performance,"ned in *found AND the error message 'unknown branch'; is suppressed. void SetBranchStyle(Int_t style = 1); Set the current branch style. (static function). style = 0 old Branch; style = 1 new Bronch. Int_t SetCacheSize(Long64_t cachesize = -1); Set maximum size of the file cache .; if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing; the Tree (default is 30 MBytes).; Returns 0 size set, cache was created if possible; -1 on error. Int_t SetCacheSizeAux(Bool_t autocache = kTRUE, Long64_t cacheSize = 0); Set the size of the file cache and create it if possible. If autocache is true:; this may be an autocreated cache, possibly enlarging an existing; autocreated cache. The size is calculated. The value passed in cacheSize:; cacheSize = 0 make cache if default cache creation is enabled; cacheSize = -1 make a default sized cache in any case. If autocache is false:; this is a user requested cache. cacheSize is used to size the cache.; This cache should never be automatically adjusted.; Returns 0 size set, or existing autosized cache almost large enough.; (cache was created if possible); -1 on error. Int_t SetCacheEntryRange(Long64_t first, Long64_t last); interface to TTreeCache to set the cache entry range; Returns 0 entry range set; -1 on error. void SetCacheLearnEntries(Int_t n = 10); interface to TTreeCache to set the number of entries for the learning phase. void SetCircular(Long64_t maxEntries); Enable/Disable circularity for this tree. if maxEntries > 0 a maximum of maxEntries is kept in one buffer/basket; per branch in memory.; Note that when this function is called (maxEntries>0) the Tree; must be empty or having only one basket per branch.; if maxEntries <= 0 the tree circularity is disabled. NOTE 1:; Circular Trees are interesting in online real time environments; to store the results of the last maxEntries events.; NOTE 2:; Calling SetCircular with maxEntries <= 0 is necessary before;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TTree.html:134010,cache,cacheSize,134010,root/html604/TTree.html,https://root.cern,https://root.cern/root/html604/TTree.html,4,['cache'],"['cache', 'cacheSize']"
Performance,"ned int i, unsigned int j) constreturn correlation coefficient between variable i and j.Definition Minimizer.h:264; ROOT::Math::Minimizer::~Minimizervirtual ~Minimizer()Destructor (no operations).Definition Minimizer.h:127; ROOT::Math::Minimizer::ErrorDefdouble ErrorDef() constreturn the statistical scale used for calculate the error is typically 1 for Chi2 and 0....Definition Minimizer.h:317; ROOT::Math::Minimizer::fOptionsMinimizerOptions fOptionsminimizer optionsDefinition Minimizer.h:370; ROOT::Math::Minimizer::operator=Minimizer & operator=(Minimizer const &)=delete; ROOT::Math::Minimizer::SetFixedVariablevirtual bool SetFixedVariable(unsigned int ivar, const std::string &name, double val)set a new fixed variable (override if minimizer supports them )Definition Minimizer.cxx:44; ROOT::Math::Minimizer::SetMaxFunctionCallsvoid SetMaxFunctionCalls(unsigned int maxfcn)set maximum of function callsDefinition Minimizer.h:331; ROOT::Math::Minimizer::IsValidErrorbool IsValidError() constreturn true if Minimizer has performed a detailed error validation (e.g. run Hesse for Minuit)Definition Minimizer.h:320; ROOT::Math::Minimizer::Edmvirtual double Edm() constreturn expected distance reached from the minimum (re-implement if minimizer provides itDefinition Minimizer.h:222; ROOT::Math::Minimizer::GetMinosErrorvirtual bool GetMinosError(unsigned int ivar, double &errLow, double &errUp, int option=0)minos error for variable i, return false if Minos failed or not supported and the lower and upper err...Definition Minimizer.cxx:172; ROOT::Math::Minimizer::SetOptionsvoid SetOptions(const MinimizerOptions &opt)set all options in one goDefinition Minimizer.h:353; ROOT::Math::Minimizer::SetVariableValuesvirtual bool SetVariableValues(const double *x)set the values of all existing variables (array must be dimensioned to the size of the existing param...Definition Minimizer.h:187; ROOT::Math::Minimizer::Clearvirtual void Clear()reset for consecutive minimization - implement if neede",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Minimizer_8h_source.html:29745,perform,performed,29745,doc/master/Minimizer_8h_source.html,https://root.cern,https://root.cern/doc/master/Minimizer_8h_source.html,1,['perform'],['performed']
Performance,"ned names can be given. For example, if the formula; *-* TFormula old(sin(x*(x<0.5 || x>1))) one can assign a name to the formula. By default; *-* the name of the object = title = formula itself.; *-* old.SetName(""old"").; *-* then, old can be reused in a new expression.; *-* TFormula new(""x*old"") is equivalent to:; *-* TFormula new(""x*sin(x*(x<0.5 || x>1))""); -; *-* Up to 4 dimensions are supported (indicated by x, y, z, t); *-* An expression may have 0 parameters or a list of parameters; *-* indicated by the sequence [par_number]; -; *-* A graph showing the logic to compile and analyze a formula; *-* is shown in TFormula::Compile and TFormula::Analyze.; *-* Once a formula has been compiled, it can be evaluated for a given; *-* set of parameters. see graph in TFormula::EvalPar.; -; *-* This class is the base class for the function classes TF1,TF2 and TF3.; *-* It is also used by the ntuple selection mechanism TNtupleFormula.; -; *-* In version 7 of TFormula, the usage of fOper has been changed; *-* to improve the performance of TFormula::EvalPar.; *-* Conceptually, fOper was changed from a simple array of Int_t; *-* to an array of composite values.; *-* For example a 'ylandau(5)' operation used to be encoded as 4105;; *-* it is now encoded as (klandau >> kTFOperShit) + 5; *-* Any class inheriting from TFormula and using directly fOper (which; *-* is now a private data member), needs to be updated to take this; *-* in consideration. The member functions recommended to set and; *-* access fOper are: SetAction, GetAction, GetActionParam; *-* For more performant access to the information, see the implementation; *-* TFormula::EvalPar; -; *-* CHANGING DEFAULT SETTINGS; *-* =========================; *-* When creating complex formula , it may be necessary to increase; *-* some default parameters. see static function TFormula::SetMaxima; -; *-* WHY TFormula CANNOT ACCEPT A CLASS MEMBER FUNCTION ?; *-* ====================================================; *-* This is a freq",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFormula.html:2532,perform,performance,2532,root/html528/TFormula.html,https://root.cern,https://root.cern/root/html528/TFormula.html,4,['perform'],['performance']
Performance,"ned with Keras. ; This tutorial shows how to store several models in a single header file and the weights in a ROOT binary file. The models are then evaluated using the RDataFrame First, generate the input model by running TMVA_Higgs_Classification.C.; This tutorial parses the input model and runs the inference using ROOT's JITing capability.; ; import ROOT; from os.path import exists; ; ROOT.TMVA.PyMethodBase.PyInitialize(); ; ; ## generate and train Keras models with different architectures; ; import numpy as np; from tensorflow.keras.models import Sequential; from tensorflow.keras.layers import Dense; from tensorflow.keras.optimizers import Adam; ; from sklearn.model_selection import train_test_split; ; def CreateModel(nlayers = 4, nunits = 64):; model = Sequential(); model.add(Dense(nunits, activation='relu',input_dim=7)); for i in range(1,nlayers) :; model.add(Dense(nunits, activation='relu')); ; model.add(Dense(1, activation='sigmoid')); model.compile(loss = 'binary_crossentropy', optimizer = Adam(learning_rate = 0.001), weighted_metrics = ['accuracy']); model.summary(); return model; ; def PrepareData() :; #get the input data; inputFileName = ""Higgs_data.root""; inputFile = ""http://root.cern.ch/files/"" + inputFileName; ; df1 = ROOT.RDataFrame(""sig_tree"", inputFile); sigData = df1.AsNumpy(columns=['m_jj', 'm_jjj', 'm_lv', 'm_jlv', 'm_bb', 'm_wbb', 'm_wwbb']); #print(sigData); ; # stack all the 7 numpy array in a single array (nevents x nvars); xsig = np.column_stack(list(sigData.values())); data_sig_size = xsig.shape[0]; print(""size of data"", data_sig_size); ; # make SOFIE inference on background data; df2 = ROOT.RDataFrame(""bkg_tree"", inputFile); bkgData = df2.AsNumpy(columns=['m_jj', 'm_jjj', 'm_lv', 'm_jlv', 'm_bb', 'm_wbb', 'm_wwbb']); xbkg = np.column_stack(list(bkgData.values())); data_bkg_size = xbkg.shape[0]; ; ysig = np.ones(data_sig_size); ybkg = np.zeros(data_bkg_size); inputs_data = np.concatenate((xsig,xbkg),axis=0); inputs_targets = np.concatenate(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__SOFIE__Models_8py.html:1299,optimiz,optimizer,1299,doc/master/TMVA__SOFIE__Models_8py.html,https://root.cern,https://root.cern/doc/master/TMVA__SOFIE__Models_8py.html,1,['optimiz'],['optimizer']
Performance,"needed; for objects that have the kMustCleanup bit set. Most useful to; update browsers that show the file system or other objects external; to the running ROOT session. void RegisterModule(const char* modulename, const char** headers, const char** includePaths, const char* payLoadCode, const char* fwdDeclCode, void(*)() triggerFunc, const TROOT::FwdDeclArgsToKeepCollection_t& fwdDeclsArgToSkip, const char** classesHeaders); Called by static dictionary initialization to register clang modules; for headers. Calls TCling::RegisterModule() unless gCling; is NULL, i.e. during startup, where the information is buffered in; the static GetModuleHeaderInfoBuffer(). void RemoveClass(TClass* ); Remove a class from the list and map of classes.; This routine is deprecated, use TClass::RemoveClass directly. void Reset(Option_t* option = """"); Delete all global interpreter objects created since the last call to Reset. If option=""a"" is set reset to startup context (i.e. unload also; all loaded files, classes, structs, typedefs, etc.). This function is typically used at the beginning (or end) of an unnamed macro; to clean the environment. IMPORTANT WARNING:; Do not use this call from within any function (neither compiled nor; interpreted. This should only be used from a unnamed macro; (which starts with a { (curly braces) ). For example, using TROOT::Reset; from within an interpreted function will lead to the unloading of the; dictionary and source file, including the one defining the function being; executed. void SaveContext(); Save the current interpreter context. void SetCutClassName(const char* name = ""TCutG""); Set the default graphical cut class name for the graphics editor; By default the graphics editor creates an instance of a class TCutG.; This function may be called to specify a different class that MUST; derive from TCutG. void SetEditorMode(const char* mode = """"); Set editor mode. void SetStyle(const char* stylename = ""Default""); Change current style to style with name ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TROOT.html:35616,load,loaded,35616,root/html602/TROOT.html,https://root.cern,https://root.cern/root/html602/TROOT.html,4,['load'],['loaded']
Performance,"nerator context ; Reimplemented from RooAbsPdf.; Definition at line 864 of file RooFFTConvPdf.cxx. ◆ getMaxVal(). Int_t RooFFTConvPdf::getMaxVal ; (; const RooArgSet & ; vars); const. inlineoverridevirtual . Advertise capability to determine maximum value of function for given set of observables. ; If no direct generator method is provided, this information will assist the accept/reject generator to operate more efficiently as it can skip the initial trial sampling phase to empirically find the function maximum ; Reimplemented from RooAbsReal.; Definition at line 61 of file RooFFTConvPdf.h. ◆ histNameSuffix(). TString RooFFTConvPdf::histNameSuffix ; (; ); const. overrideprotectedvirtual . Suffix for cache histogram (added in addition to suffix for cache name) ; Reimplemented from RooAbsCachedPdf.; Definition at line 448 of file RooFFTConvPdf.cxx. ◆ inputBaseName(). const char * RooFFTConvPdf::inputBaseName ; (; ); const. overrideprotectedvirtual . Return base name component for cache components in this case 'PDF1_CONV_PDF2'. ; Implements RooAbsCachedPdf.; Definition at line 327 of file RooFFTConvPdf.cxx. ◆ IsA(). TClass * RooFFTConvPdf::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from RooAbsCachedPdf.; Definition at line 124 of file RooFFTConvPdf.h. ◆ maxVal(). double RooFFTConvPdf::maxVal ; (; Int_t ; code); const. inlineoverridevirtual . Return maximum value for set of observables identified by code assigned in getMaxVal. ; Reimplemented from RooAbsReal.; Definition at line 62 of file RooFFTConvPdf.h. ◆ pdfObservable(). RooAbsArg & RooFFTConvPdf::pdfObservable ; (; RooAbsArg & ; histObservable); const. overrideprotectedvirtual . Return p.d.f. ; observable (which can be a function) to substitute given p.d.f. observable. Substitutes x by xprime if xprime is set. ; Reimplemented from RooAbsCachedPdf.; Definition at line 847 of file RooFFTConvPdf.cxx. ◆ prepareFFTBinning(). void RooFFTConvPdf::prepareFFTBinning ; (",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooFFTConvPdf.html:92514,cache,cache,92514,doc/master/classRooFFTConvPdf.html,https://root.cern,https://root.cern/doc/master/classRooFFTConvPdf.html,1,['cache'],['cache']
Performance,"nerator(const RooArgSet& theEvent); voidTObject::MakeZombie(); voidresampleData(Double_t& ratio). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. UInt_t_expectedEventsNumber of expected events from extended p.d.f; RooAbsPdf::ExtendMode_extendModeExtended mode capabilities of p.d.f.; RooDataSet*_genData! Data being generated; Bool_t_isValidIs context in valid state?; static Int_tRooPrintable::_nameLength; Int_t_nextProtoIndexNext prototype event to load according to LUT; Int_t*_protoOrderLUT with traversal order of prototype data; RooArgSet_protoVarsPrototype observables; const RooDataSet*_prototypePointer to prototype dataset; RooArgSet*_theEventPointer to observable event being generated; Bool_t_verboseVerbose messaging?; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsGenContext(); Destructor. void attach(const RooArgSet& params); Interface to attach given parameters to object in this context. RooDataSet * generate(Int_t nEvents = 0); Generate the specified number of events with nEvents>0 and; and return a dataset containing the generated events. With nEvents<=0,; generate the number of events in the prototype dataset, if available,; or else the expected number of events, if non-zero. The returned; dataset belongs to the caller. Return zero in case of an error.; Generation of individual events is delegated to a virtual generateEvent(); method. A virtual initGenerator() method is also called just",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsGenContext.html:7593,load,load,7593,root/html526/RooAbsGenContext.html,https://root.cern,https://root.cern/root/html526/RooAbsGenContext.html,1,['load'],['load']
Performance,"nerator::~TClassGenerator ; (; ). inlineprotectedvirtual . Definition at line 32 of file TClassGenerator.h. Member Function Documentation. ◆ Class(). static TClass * TClassGenerator::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TClassGenerator::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TClassGenerator::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 40 of file TClassGenerator.h. ◆ DeclFileName(). static const char * TClassGenerator::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 40 of file TClassGenerator.h. ◆ GetClass() [1/4]. virtual TClass * TClassGenerator::GetClass ; (; const char * ; classname, . Bool_t ; load . ). pure virtual . Implemented in TPyClassGenerator. ◆ GetClass() [2/4]. TClass * TClassGenerator::GetClass ; (; const char * ; classname, . Bool_t ; load, . Bool_t ; silent . ). virtual . Reimplemented in TPyClassGenerator.; Definition at line 25 of file TClassGenerator.cxx. ◆ GetClass() [3/4]. virtual TClass * TClassGenerator::GetClass ; (; const std::type_info & ; typeinfo, . Bool_t ; load . ). pure virtual . Implemented in TPyClassGenerator. ◆ GetClass() [4/4]. TClass * TClassGenerator::GetClass ; (; const std::type_info & ; typeinfo, . Bool_t ; load, . Bool_t ; silent . ). virtual . Reimplemented in TPyClassGenerator.; Definition at line 32 of file TClassGenerator.cxx. ◆ IsA(). TClass * TClassGenerator::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 40 of file TClassGenerator.h. ◆ Streamer(). void TClassGenerator::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void TClassGenerator::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline .",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClassGenerator.html:11757,load,load,11757,doc/master/classTClassGenerator.html,https://root.cern,https://root.cern/doc/master/classTClassGenerator.html,1,['load'],['load']
Performance,"nes (> 256; colors). void CollectImageColors(ULong_t pixel, ULong_t*& orgcolors, Int_t& ncolors, Int_t& maxcolors); Collect in orgcolors all different original image colors. void MakeOpaqueColors(Int_t percent, ULong_t* orgcolors, Int_t ncolors); Get RGB values for orgcolors, add percent neutral to the RGB and; allocate fNewColors. Int_t FindColor(ULong_t pixel, ULong_t* orgcolors, Int_t ncolors); Returns index in orgcolors (and fNewColors) for pixel. void SetRGB(Int_t cindex, Float_t r, Float_t g, Float_t b); Set color intensities for given color index.; cindex : color index; r,g,b : red, green, blue intensities between 0.0 and 1.0. void SetTextAlign(Short_t talign = 11); Set text alignment.; txalh : horizontal text alignment; txalv : vertical text alignment. void SetTextColor(Color_t cindex); Set color index for text. Int_t SetTextFont(char* fontname, TVirtualX::ETextSetMode mode); Set text font to specified name.; mode : loading flag; mode=0 : search if the font exist (kCheck); mode=1 : search the font and load it if it exists (kLoad); font : font name. Set text font to specified name. This function returns 0 if; the specified font is found, 1 if not. void SetTextFont(Font_t fontnumber); Set current text font number. void SetTextSize(Float_t textsize); Set current text size. void Sync(Int_t mode); Set synchronisation on or off.; mode : synchronisation on/off; mode=1 on; mode<>0 off. void UpdateWindow(Int_t mode); Update display.; mode : (1) update; (0) sync. Synchronise client and server once (not permanent).; Copy the pixmap gCws->fDrawing on the window gCws->fWindow; if the double buffer is on. void Warp(Int_t ix, Int_t iy, Window_t id = 0); Set pointer position.; ix : New X coordinate of pointer; iy : New Y coordinate of pointer; Coordinates are relative to the origin of the window id; or to the origin of the current window if id == 0. void WritePixmap(Int_t wid, UInt_t w, UInt_t h, char* pxname); Write the pixmap wid in the bitmap file pxname.; wid : Pixmap ad",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGX11.html:35242,load,loading,35242,root/html528/TGX11.html,https://root.cern,https://root.cern/root/html528/TGX11.html,20,['load'],"['load', 'loading']"
Performance,"nes are; copied to the new structures, then the old elements are deleted. Double_t TMatrixT<Element> Determinant() const; Return the matrix determinant. void TMatrixT<Element> Determinant(Double_t& d1, Double_t& d2) const; Return the matrix determinant as d1,d2 where det = d1*TMath::Power(2.0,d2). TMatrixT<Double_t> &TMatrixT<Double_t> Invert(Double_t* det = 0); Invert the matrix and calculate its determinant. TMatrixT<Element> &TMatrixT<Element> InvertFast(Double_t* det = 0); Invert the matrix and calculate its determinant, however upto (6x6); a fast Cramer inversion is used . TMatrixT<Element> &TMatrixT<Element> Transpose(const TMatrixT<float>& source); Transpose matrix source. TMatrixT<Element> &TMatrixT<Element> Rank1Update(const TVectorT<float>& v, float alpha = 1.0); Perform a rank 1 operation on matrix A:; A += alpha * v * v^T. TMatrixT<Element> &TMatrixT<Element> Rank1Update(const TVectorT<float>& v1, const TVectorT<float>& v2, float alpha = 1.0); Perform a rank 1 operation on matrix A:; A += alpha * v1 * v2^T. Element TMatrixT<Element> Similarity(const TVectorT<float>& v) const; Calculate scalar v * (*this) * v^T. TMatrixT<Element> &TMatrixT<Element> NormByColumn(const TVectorT<float>& v, Option_t* option = ""D""); Multiply/divide matrix columns by a vector:; option:; ""D"" : b(i,j) = a(i,j)/v(i) i = 0,fNrows-1 (default); else : b(i,j) = a(i,j)*v(i). TMatrixT<Element> &TMatrixT<Element> NormByRow(const TVectorT<float>& v, Option_t* option = ""D""); Multiply/divide matrix rows with a vector:; option:; ""D"" : b(i,j) = a(i,j)/v(j) i = 0,fNcols-1 (default); else : b(i,j) = a(i,j)*v(j). TMatrixT<Element> &TMatrixT<Element> operator=(const TMatrixT<Element> &source); Assignment operator. TMatrixT<Element> &TMatrixT<Element> operator=(const TMatrixTSym<Element> &source); Assignment operator. TMatrixT<Element> &TMatrixT<Element> operator=(const TMatrixTSparse<Element> &source); Assignment operator. TMatrixT<Element> &TMatrixT<Element> operator=(const TMatrixTLazy<Element>",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMatrixT_float_.html:20362,Perform,Perform,20362,root/html534/TMatrixT_float_.html,https://root.cern,https://root.cern/root/html534/TMatrixT_float_.html,1,['Perform'],['Perform']
Performance,"nes at end of curve to ensure proper closure. Add DrawOption(""F"") for filled drawing. . FillColor(Int_t color) Select fill color by ROOT color code. Range(const char* name) Only draw curve in range defined by given name. Range(double lo, double hi) Only draw curve in specified range. VLines() Add vertical lines to y=0 at end points of curve. Precision(double eps) Control precision of drawn curve w.r.t to scale of plot, default is 1e-3. Higher precision will result in more and more densely spaced curve points. Invisible(bool flag) Add curve to frame, but do not display. Useful in combination AddTo(). VisualizeError(const RooFitResult& fitres, double Z=1, bool linearMethod=true) Visualize the uncertainty on the parameters, as given in fitres, at 'Z' sigma'. The linear method is fast but may not be accurate in the presence of strong correlations (~>0.9) and at Z>2 due to linear and Gaussian approximations made. Intervals from the sampling method can be asymmetric, and may perform better in the presence of strong correlations, but may take (much) longer to calculate. VisualizeError(const RooFitResult& fitres, const RooArgSet& param, double Z=1, bool linearMethod=true) Visualize the uncertainty on the subset of parameters 'param', as given in fitres, at 'Z' sigma' . Details on error band visualization; VisualizeError() uses plotOnWithErrorBand(). Documentation of the latter: See alsoplotOnWithErrorBand(). PyROOT; The RooAbsReal::plotOn() function is pythonized with the command argument pythonization. The keywords must correspond to the CmdArgs of the function. . Reimplemented in RooSimultaneous, RooAbsPdf, and RooSimultaneous.; Definition at line 1611 of file RooAbsReal.cxx. ◆ plotOn() [2/3]. RooPlot * RooAbsReal::plotOn ; (; RooPlot * ; frame, . PlotOpt ; o . ); const. protectedvirtual . Plotting engine function for internal use. ; Plot ourselves on given frame. If frame contains a histogram, all dimensions of the plotted function that occur in the previously plotted da",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsReal.html:134411,perform,perform,134411,doc/master/classRooAbsReal.html,https://root.cern,https://root.cern/doc/master/classRooAbsReal.html,1,['perform'],['perform']
Performance,"nes at end of curve to ensure proper closure. Add DrawOption(""F"") for filled drawing. . FillColor(Int_t color) Select fill color by ROOT color code. Range(const char* name) Only draw curve in range defined by given name. Range(double lo, double hi) Only draw curve in specified range. VLines() Add vertical lines to y=0 at end points of curve. Precision(double eps) Control precision of drawn curve w.r.t to scale of plot, default is 1e-3. Higher precision will result in more and more densely spaced curve points. Invisible(bool flag) Add curve to frame, but do not display. Useful in combination AddTo(). VisualizeError(const RooFitResult& fitres, double Z=1, bool linearMethod=true) Visualize the uncertainty on the parameters, as given in fitres, at 'Z' sigma'. The linear method is fast but may not be accurate in the presence of strong correlations (~>0.9) and at Z>2 due to linear and Gaussian approximations made. Intervals from the sampling method can be asymmetric, and may perform better in the presence of strong correlations, but may take (much) longer to calculate. VisualizeError(const RooFitResult& fitres, const RooArgSet& param, double Z=1, bool linearMethod=true) Visualize the uncertainty on the subset of parameters 'param', as given in fitres, at 'Z' sigma' . Details on error band visualization; VisualizeError() uses plotOnWithErrorBand(). Documentation of the latter: See alsoplotOnWithErrorBand(). PyROOT; The RooAbsReal::plotOn() function is pythonized with the command argument pythonization. The keywords must correspond to the CmdArgs of the function. . Reimplemented in RooSimultaneous, RooAbsPdf, and RooSimultaneous.; Definition at line 1639 of file RooAbsReal.cxx. ◆ plotOn() [2/3]. RooPlot * RooAbsReal::plotOn ; (; RooPlot * ; frame, . PlotOpt ; o . ); const. protectedvirtual . Plotting engine function for internal use. ; Plot ourselves on given frame. If frame contains a histogram, all dimensions of the plotted function that occur in the previously plotted da",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAbsReal.html:135741,perform,perform,135741,doc/v632/classRooAbsReal.html,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html,1,['perform'],['perform']
Performance,"nes. void SetupClipObject(); Setup clip-object. Protected virtual method. void PreRender(); Initialize render-context, setup camera, GL, render-area.; Check and lock scenes, determine their visibility. void SubRenderScenes(TGLViewerBase::SubRender_foo render_foo); Call sub-rendering function render_foo on all currently visible; scenes. void Render(); Render all scenes. This is done in four passes:; - render opaque objects from all scenes; - render transparent objects from all scenes; - clear depth buffer; - render opaque selected objects from all scenes (with highlight); - render transparent selected objects from all scenes (with highlight). void RenderNonSelected(); Render non-selected objects from all scenes. void RenderSelected(); Render selected objects from all scenes. void RenderOverlay(Int_t state, Bool_t selection); Render overlay objects. void PostRender(); Function called after rendering is finished.; Here we just unlock the scenes. void PreRenderOverlaySelection(); Perform minimal initialization for overlay selection.; Here we assume that scene has already been drawn and that; camera and overall bounding box are ok.; Scenes are not locked. void PostRenderOverlaySelection(); Perform cleanup after overlay selection. Bool_t ResolveSelectRecord(TGLSelectRecord& rec, Int_t recIdx); Process selection record on buffer-position 'recIdx' and; fill the data into 'rec'. Returns TRUE if scene was demangled and an object identified.; When FALSE is returned it is still possible that scene has been; identified. Check for this if interested in scene-selection. The select-buffer is taken form fRnrCtx. Bool_t FindClosestRecord(TGLSelectRecord& rec, Int_t& recIdx); Find next select record that can be resolved, starting from; position 'recIdx'.; 'recIdx' is passed as reference and points to found record in the buffer. Bool_t FindClosestOpaqueRecord(TGLSelectRecord& rec, Int_t& recIdx); Find next select record that can be resolved and whose result is; not transparent, startin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGLViewerBase.html:6426,Perform,Perform,6426,root/html532/TGLViewerBase.html,https://root.cern,https://root.cern/root/html532/TGLViewerBase.html,1,['Perform'],['Perform']
Performance,"networks; : (TMlpANN, interfaced via TMVA) performed equally well, with however; : a clear speed advantage for the MLP. The Clermont-Ferrand neural ; : net (CFMlpANN) exhibited worse classification performance in these; : tests, which is partly due to the slow convergence of its training; : (at least 10k training cycles are required to achieve approximately; : competitive results).; : ; : ␛[1mOvertraining: ␛[0monly the TMlpANN performs an explicit separation of the; : full training sample into independent training and validation samples.; : We have found that in most high-energy physics applications the ; : available degrees of freedom (training events) are sufficient to ; : constrain the weights of the relatively simple architectures required; : to achieve good performance. Hence no overtraining should occur, and ; : the use of validation samples would only reduce the available training; : information. However, if the performance on the training sample is ; : found to be significantly better than the one found with the inde-; : pendent test sample, caution is needed. The results for these samples ; : are printed to standard output at the end of each training job.; : ; : ␛[1m--- Performance tuning via configuration options:␛[0m; : ; : The hidden layer architecture for all ANNs is defined by the option; : ""HiddenLayers=N+1,N,..."", where here the first hidden layer has N+1; : neurons and the second N neurons (and so on), and where N is the number ; : of input variables. Excessive numbers of hidden layers should be avoided,; : in favour of more neurons in the first hidden layer.; : ; : The number of cycles should be above 500. As said, if the number of; : adjustable weights is small compared to the training sample size,; : using a large number of training samples should not lead to overtraining.; : ; : <Suppress this message by specifying ""!H"" in the booking option>; : ␛[1m================================================================␛[0m; : ; TFHandler_MLPBNN : Vari",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAClassification_8C.html:43420,perform,performance,43420,doc/master/TMVAClassification_8C.html,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html,1,['perform'],['performance']
Performance,"nevalNumber evaluations used in last minimization; RooRealProxy_nllInput -log(L) function; RooSetProxy_obsParameters of profile likelihood; RooArgSet_obsAbsMinObservable values at absolute minimum; TIterator*_oiter! Iterator of profile likelihood output parameter(s); RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooSetProxy_parMarginialized parameters of likelihood; RooArgSet_paramAbsMinParameter values at absolute minimum; map<std::string,bool>_paramFixedParameter constant status at last time of use; TIterator*_piter! Iterator over profile likelihood parameters to be minimized ; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; Bool_t_startFromMinAlways start minimization for global minimum?; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNam",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooProfileLL.html:33596,cache,cache,33596,root/html532/RooProfileLL.html,https://root.cern,https://root.cern/root/html532/RooProfileLL.html,2,['cache'],['cache']
Performance,"newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); RooAbsString(); RooAbsString(const RooAbsString& other, const char* name = 0); RooAbsString(const char* name, const char* title, Int_t size = 128); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); const m",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsString.html:13997,cache,cache,13997,root/html602/RooAbsString.html,https://root.cern,https://root.cern/root/html602/RooAbsString.html,4,['cache'],['cache']
Performance,"nfidenceIntervals ; (; double ; cl = 0.95, . bool ; norm = false . ); const. evaluate confidence interval for the data set used in the last fit the confidence interval are returned as a vector of data points ; Definition at line 599 of file FitResult.cxx. ◆ GetConfidenceIntervals() [3/3]. void ROOT::Fit::FitResult::GetConfidenceIntervals ; (; unsigned int ; n, . unsigned int ; stride1, . unsigned int ; stride2, . const double * ; x, . double * ; ci, . double ; cl = 0.95, . bool ; norm = false . ); const. get confidence intervals for an array of n points x. ; stride1 indicates the stride in the coordinate space while stride2 the stride in dimension space. For 1-dim points : stride1=1, stride2=1 for multi-dim points arranged as (x0,x1,...,xN,y0,....yN) stride1=1 stride2=n for multi-dim points arranged as (x0,y0,..,x1,y1,...,xN,yN,..) stride1=ndim, stride2=1; the confidence interval are returned in the array ci cl is the desired confidence interval value norm is a flag to control if the intervals need to be normalized to the chi2/ndf value The intervals can be corrected optionally using the chi2/ndf value of the fit if a chi2 fit is performed. This has changed since ROOT 6.14, before the interval were corrected by default. ; Definition at line 506 of file FitResult.cxx. ◆ GetCorrelationMatrix(). template<class Matrix > . void ROOT::Fit::FitResult::GetCorrelationMatrix ; (; Matrix & ; mat); const. inline . fill a correlation matrix elements using a generic symmetric matrix class implementing operator(i,j) the matrix must be previously allocates with right size (npar * npar) ; Definition at line 249 of file FitResult.h. ◆ GetCovarianceMatrix(). template<class Matrix > . void ROOT::Fit::FitResult::GetCovarianceMatrix ; (; Matrix & ; mat); const. inline . fill covariance matrix elements using a generic matrix class implementing operator(i,j) the matrix must be previously allocates with right size (npar * npar) ; Definition at line 235 of file FitResult.h. ◆ GetErrors(). co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Fit_1_1FitResult.html:15863,perform,performed,15863,doc/master/classROOT_1_1Fit_1_1FitResult.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Fit_1_1FitResult.html,1,['perform'],['performed']
Performance,"nfigParameters Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Static Public Member Functions |; Public Attributes |; Private Member Functions |; Private Attributes |; List of all members ; TMVA::OptimizeConfigParameters Class ReferenceTMVA. . Definition at line 49 of file OptimizeConfigParameters.h. Public Member Functions;  OptimizeConfigParameters (MethodBase *const method, std::map< TString, TMVA::Interval * > tuneParameters, TString fomType=""Separation"", TString optimizationType=""GA"");  Constructor which sets either ""Classification or Regression"". ;  ; virtual ~OptimizeConfigParameters ();  the destructor (delete the OptimizeConfigParameters, store the graph and .. delete it) ;  ; virtual TClass * IsA () const;  ; std::map< TString, Double_t > optimize ();  ; virtual void Streamer (TBuffer &);  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TMVA::IFitterTarget;  IFitterTarget ();  constructor ;  ; virtual ~IFitterTarget ();  ; virtual void ProgressNotifier (TString, TString);  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TMVA::IFitterTarget; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  . Public Attributes; friend TestOptimizeConfigParameters;  . Private Member Functions; Double_t EstimatorFunction (std::vector< Double_t > &);  return the estimator (from current FOM) for the fitting interface ;  ; Double_t GetBkgEffAtSigEff (Double_t sigEff=0.5);  calculate the background efficiency for a given signal efficiency ;  ; Double_t GetBkgRejAtSigEff (Doub",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1OptimizeConfigParameters.html:883,optimiz,optimize,883,doc/master/classTMVA_1_1OptimizeConfigParameters.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1OptimizeConfigParameters.html,1,['optimiz'],['optimize']
Performance,"nfo = (TStreamerInfo*)fInfo;; 1565 TStreamerElement *aElement = fCompInfo->fElem;; 1566 fprintf(stdout,""StreamerInfoAction, class:%s, name=%s, fType[%d]=%d,""; 1567 "" %s, bufpos=%d, arr=%p, eoffset=%d, Redirect=%p\n"",; 1568 info->GetClass()->GetName(),aElement->GetName(),fElemId,fCompInfo->fType,; 1569 aElement->ClassName(),b.Length(),addr, 0,b.PeekDataCache() ? b.PeekDataCache()->GetObjectAt(0) : 0);; 1570 }; 1571 ; 1572 }; 1573 ~TConfigurationUseCache() override {}; 1574 TConfiguration *Copy() override; 1575 {; 1576 TConfigurationUseCache *copy = new TConfigurationUseCache(*this);; 1577 fAction.fConfiguration = copy->fAction.fConfiguration->Copy(); // since the previous allocation did a 'move' of fAction we need to fix it.; 1578 return copy;; 1579 }; 1580 };; 1581 ; 1582 INLINE_TEMPLATE_ARGS Int_t UseCache(TBuffer &b, void *addr, const TConfiguration *conf); 1583 {; 1584 TConfigurationUseCache *config = (TConfigurationUseCache*)conf;; 1585 ; 1586 Int_t bufpos = b.Length();; 1587 TVirtualArray *cached = b.PeekDataCache();; 1588 if (cached==0) {; 1589 TStreamerElement *aElement = conf->fCompInfo->fElem;; 1590 TStreamerInfo *info = (TStreamerInfo*)conf->fInfo;; 1591 Warning(""ReadBuffer"",""Skipping %s::%s because the cache is missing."",info->GetName(),aElement->GetName());; 1592 char *ptr = (char*)addr;; 1593 info->ReadBufferSkip(b,&ptr,config->fCompInfo,config->fCompInfo->fType+TStreamerInfo::kSkip,aElement,1,0);; 1594 } else {; 1595 config->fAction(b, (*cached)[0]);; 1596 }; 1597 // Idea: Factor out this 'if' to a UseCacheRepeat function; 1598 if (config->fNeedRepeat) {; 1599 b.SetBufferOffset(bufpos);; 1600 }; 1601 return 0;; 1602 }; 1603 ; 1604 INLINE_TEMPLATE_ARGS Int_t UseCacheVectorPtrLoop(TBuffer &b, void *start, const void *end, const TConfiguration *conf); 1605 {; 1606 TConfigurationUseCache *config = (TConfigurationUseCache*)conf;; 1607 Int_t bufpos = b.Length();; 1608 ; 1609 TVirtualArray *cached = b.PeekDataCache();; 1610 if (cached==0) {; 1611 TStreamerEle",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html:65465,cache,cached,65465,doc/master/TStreamerInfoActions_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html,1,['cache'],['cached']
Performance,nfo*fCurrentInfo!cached current streamer info.; TList*fDatalinked list for data members; Short_tfDeclFileLineline of class declaration; const char*fDeclFileNamename of class declaration file; void*fDeletepointer to a function deleting one object.; void*fDeleteArraypointer to a function deleting an array of objects.; void*fDestructorpointer to a function call an object's destructor.; void*fDirAutoAddpointer which implements the Directory Auto Add feature for this class.']'; IsAGlobalFunc_tfGlobalIsApointer to a global IsA function.; Short_tfImplFileLineline of class implementation; const char*fImplFileNamename of class implementation file; UInt_tfInstanceCountnumber of instances of this class; void*fInterShowMembersInterpreter call setup for ShowMembers; TVirtualIsAProxy*fIsA!pointer to the class's IsA proxy.; TMethodCall*fIsAMethod!saved info to call a IsA member function; Bool_tfIsOffsetStreamerSet!saved remember if fOffsetStreamer has been set.; TVirtualStreamerInfo*fLastReadInfo!cached streamer info used in the last read.; void*fMergepointer to a function implementing Merging objects of this class.; TList*fMethodlinked list for methods; void*fNewpointer to a function newing one object.; void*fNewArraypointer to a function newing an array of objects.; Long_tfOffsetStreamer!saved info to call Streamer; UInt_tfOnHeapnumber of instances on heap; TClass**fPersistentRef!Persistent address of pointer to this TClass object and its successors.; Long_tfProperty!Property; TList*fRealDatalinked list for persistent members including base classes; TVirtualRefProxy*fRefProxy!Pointer to reference proxy if this class represents a reference; void*fResetAfterMergepointer to a function implementing Merging objects of this class.; ROOT::TSchemaRuleSet*fSchemaRules! Schema evolution rules; TStringfSharedLibsshared libraries containing class code; ShowMembersFunc_tfShowMemberspointer to the class's ShowMembers function; Int_tfSizeofSizeof the class.; TClassStreamer*fStreamerpointer to ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TClass.html:16647,cache,cached,16647,root/html534/TClass.html,https://root.cern,https://root.cern/root/html534/TClass.html,2,['cache'],['cached']
Performance,"nfo_TypeTypeInfo_t * MethodInfo_Type(MethodInfo_t *minfo) const finalDefinition TCling.cxx:9109; TCling::fAutoLoadLibStoragestd::vector< std::string > fAutoLoadLibStorageDefinition TCling.h:118; TCling::CallFunc_Deletevoid CallFunc_Delete(CallFunc_t *func) const finalDefinition TCling.cxx:7843; TCling::fLockProcessLineBool_t fLockProcessLineDefinition TCling.h:127; TCling::LoadFileint LoadFile(const char *path) const finalLoad a source file or library called path into the interpreter.Definition TCling.cxx:7500; TCling::ResetAllvoid ResetAll() finalReset the Cling state to its initial state.Definition TCling.cxx:3724; TCling::SetDeclAttrvoid SetDeclAttr(DeclId_t, const char *) finalDefinition TCling.cxx:8725; TCling::HandleNewDeclvoid HandleNewDecl(const void *DV, bool isDeserialized, std::set< TClass * > &modifiedClasses)Definition TCling.cxx:496; TCling::InvalidateCachedDeclvoid InvalidateCachedDecl(const std::tuple< TListOfDataMembers *, TListOfFunctions *, TListOfFunctionTemplates *, TListOfEnums * > &Lists, const clang::Decl *D)Invalidate cached TCling information for the given declaration, and removed it from the appropriate o...Definition TCling.cxx:6891; TCling::MethodInfo_PropertyLong_t MethodInfo_Property(MethodInfo_t *minfo) const finalDefinition TCling.cxx:9091; TCling::LoadFunctionTemplatesvirtual void LoadFunctionTemplates(TClass *cl) const finalCreate list of pointers to function templates for TClass cl.Definition TCling.cxx:4442; TCling::ClassInfo_IsValidMethodbool ClassInfo_IsValidMethod(ClassInfo_t *info, const char *method, const char *proto, Longptr_t *offset, ROOT::EFunctionMatchMode=ROOT::kConversionMatch) const finalDefinition TCling.cxx:8336; TCling::DataMemberInfo_PropertyLong_t DataMemberInfo_Property(DataMemberInfo_t *dminfo) const finalDefinition TCling.cxx:8658; TCling::SetClassAutoparsingint SetClassAutoparsing(int) finalEnable/Disable the Autoparsing of headers.Definition TCling.cxx:7585; TCling::fCurExecutingMacrosstd::vector< const cha",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:419736,cache,cached,419736,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,2,['cache'],['cached']
Performance,"ng (true when >8 planes, false otherwise); static Int_tfgSymbItaFontIdxSymbol italic font index; static Int_tfgTBlankWtrailing blanks width; static Int_tfgWidthstring width, used to compute X alignment; static TTF::(anonymous)kMaxGlyphs; static TTF::(anonymous)kTTMaxFonts. Class Charts. Inheritance Chart:. TTF. Function documentation; ~TTF(); Cleanup TTF environment. void Init(); Initialise the TrueType fonts interface. void Cleanup(); Cleanup. Is called by the gCleanupTTF destructor. Short_t CharToUnicode(UInt_t code); Map char to unicode. Returns 0 in case no mapping exists. void GetTextExtent(UInt_t& w, UInt_t& h, char* text); Get width (w) and height (h) when text is horizontal. void GetTextAdvance(UInt_t& a, char* text); Get advance (a) when text is horizontal. void GetTextExtent(UInt_t& w, UInt_t& h, wchar_t* text); Get width (w) and height (h) when text is horizontal. void LayoutGlyphs(); Compute the glyps positions, fgAscent and fgWidth (needed for alignment).; Perform the Glyphs transformation.; Compute the string control box.; If required take the ""kerning"" into account.; SetRotation and PrepareString should have been called before. void PrepareString(const char* string); Put the characters in ""string"" in the ""glyphs"" array. void PrepareString(const wchar_t* string); Put the characters in ""string"" in the ""glyphs"" array. void SetHinting(Bool_t state); Set hinting flag. void SetKerning(Bool_t state); Set kerning flag. void SetRotationMatrix(Float_t angle); Set the rotation matrix used to rotate the font outlines. void SetSmoothing(Bool_t state); Set smoothing (anti-aliasing) flag. Int_t SetTextFont(const char* fontname, Int_t italic = 0); Set text font to specified name.; font : font name; italic : the fonts should be slanted. Used for symbol font. Set text font to specified name. This function returns 0 if; the specified font is found, 1 if not. void SetTextFont(Font_t fontnumber); Set specified font.; List of the currently supported fonts (screen and PostS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTF.html:3363,Perform,Perform,3363,root/html602/TTF.html,https://root.cern,https://root.cern/root/html602/TTF.html,2,['Perform'],['Perform']
Performance,"ng ROOT . ; Tutorials . ; Javascript Root . ; ROOT and Spark . ; Publications . ; FAQ . ; News . ; Blog . ; Workshops . ; Support . ; Forum . ; Bug submission guidelines . ; Submit a Bug . ; RootTalk Digest . ; Discourse Mailing List Mode . ; About . ; Licence . ; Contact Us . ; Project Founders . ; Team . ; Previous Developers . ; Development . ; Program of Work . ; Code Owners . ; Release Checklist . ; Coding Conventions . ; Shifter's Instructions . ; Git Primer . ; Creating a Pull Request . ; Github ssh key . ; Git Tips and Tricks . ; Git How Tos . ; A suggested work flow for distributed projects: NoSY . ; Browse Sources . ; Meetings . ; ROOT 7 . ; Run the tests . ; Setup externals from AFS/CVMFS . ; Jenkins . ; Doxygen . ; Benchmarks . ; Contribute . ; Collaborate with Us . You are hereHome » Documentation Frequently Asked Questions; [expand all][collapse all]. How to generate a dictionary . A dictionary is a source file that once compiled, linked into a library or executable and loaded into a process will give to CINT all the information its need about a type or variable. A dictionary is essential for a C++ to entity to useable from a CINT script or to be Streamed in or out of a ROOT file.; You have 3 options to create a dictionary.; Use ACLiC to generate the dictionary for everything defined in a source or header file:; root [] .L myScript.cxx+; or (from compiled code):; gROOT->ProcessLine("".L myScript.cxx+""). To generate the dictionary for a single class or for a class template instance use (with ROOT v5.27/06 and above):gInterpreter->GenerateDictionary(""vector<Track&gt"",""Track.h;vector"");; gInterpreter->GenerateDictionary(""myclass"",""myheader.h"");. To generate the dictionary from a Makefile, you can use the following rule to generate a dictionary for the headers $(HEADERS) and a library containing the dictionary and the compiled $(SOURCES):. MyDict.cxx: $(HEADERS) Linkdef.h; [TAB] rootcint -f $@ -c $(CXXFLAGS) -p $^. libMyLib.so: MyDict.cxx $(SOURCES); [TAB] g",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/faq-page.html:2054,load,loaded,2054,d/faq-page.html,https://root.cern,https://root.cern/d/faq-page.html,1,['load'],['loaded']
Performance,"ng a TRootIOCtor* as an argument). In other words, if this routine returns true, TClass::New is guarantee to succeed. To know if the class described by this TClass has a default constructor (public or not), use cl->GetProperty() & kClassHasDefaultCtor; kClassHasDefaultCtor@ kClassHasDefaultCtorDefinition TDictionary.h:140; To know if the class described by this TClass has a public default constructor use: gInterpreter->ClassInfo_HasDefaultConstructor(aClass->GetClassInfo());; gInterpreter#define gInterpreterDefinition TInterpreter.h:573. Definition at line 7393 of file TClass.cxx. ◆ HasDictionary(). Bool_t TClass::HasDictionary ; (; ); const. Check whether a class has a dictionary or not. ; This is equivalent to ask if a class is coming from a bootstrapping procedure initiated during the loading of a library. ; Definition at line 3906 of file TClass.cxx. ◆ HasDictionarySelection(). Bool_t TClass::HasDictionarySelection ; (; const char * ; clname). static . Check whether a class has a dictionary or ROOT can load one. ; This is equivalent to ask HasDictionary() or whether a library is known where it can be loaded from, or whether a Dictionary function is available because the class's dictionary library was already loaded. ; Definition at line 3917 of file TClass.cxx. ◆ HasInterpreterInfo(). Bool_t TClass::HasInterpreterInfo ; (; ); const. inline . Definition at line 410 of file TClass.h. ◆ HasInterpreterInfoInMemory(). Bool_t TClass::HasInterpreterInfoInMemory ; (; ); const. inline . Definition at line 409 of file TClass.h. ◆ HasLocalHashMember(). Bool_t TClass::HasLocalHashMember ; (; ); const. Returns true if this class has an definition and/or overload of the member function Hash. ; For example to test if the class overload TObject::Hash use if (cl->IsTObject() && cl->HasLocalHashMember()). Definition at line 7421 of file TClass.cxx. ◆ HasNoInfoOrEmuOrFwdDeclaredDecl(). Bool_t TClass::HasNoInfoOrEmuOrFwdDeclaredDecl ; (; const char * ; name). staticprivate . Definit",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTClass.html:95277,load,load,95277,doc/v632/classTClass.html,https://root.cern,https://root.cern/doc/v632/classTClass.html,1,['load'],['load']
Performance,"ng a TRootIOCtor* as an argument). In other words, if this routine returns true, TClass::New is guarantee to succeed. To know if the class described by this TClass has a default constructor (public or not), use cl->GetProperty() & kClassHasDefaultCtor; kClassHasDefaultCtor@ kClassHasDefaultCtorDefinition TDictionary.h:140; To know if the class described by this TClass has a public default constructor use: gInterpreter->ClassInfo_HasDefaultConstructor(aClass->GetClassInfo());; gInterpreter#define gInterpreterDefinition TInterpreter.h:573. Definition at line 7460 of file TClass.cxx. ◆ HasDictionary(). Bool_t TClass::HasDictionary ; (; ); const. Check whether a class has a dictionary or not. ; This is equivalent to ask if a class is coming from a bootstrapping procedure initiated during the loading of a library. ; Definition at line 3973 of file TClass.cxx. ◆ HasDictionarySelection(). Bool_t TClass::HasDictionarySelection ; (; const char * ; clname). static . Check whether a class has a dictionary or ROOT can load one. ; This is equivalent to ask HasDictionary() or whether a library is known where it can be loaded from, or whether a Dictionary function is available because the class's dictionary library was already loaded. ; Definition at line 3984 of file TClass.cxx. ◆ HasInterpreterInfo(). Bool_t TClass::HasInterpreterInfo ; (; ); const. inline . Definition at line 410 of file TClass.h. ◆ HasInterpreterInfoInMemory(). Bool_t TClass::HasInterpreterInfoInMemory ; (; ); const. inline . Definition at line 409 of file TClass.h. ◆ HasLocalHashMember(). Bool_t TClass::HasLocalHashMember ; (; ); const. Returns true if this class has an definition and/or overload of the member function Hash. ; For example to test if the class overload TObject::Hash use if (cl->IsTObject() && cl->HasLocalHashMember()). Definition at line 7488 of file TClass.cxx. ◆ HasNoInfoOrEmuOrFwdDeclaredDecl(). Bool_t TClass::HasNoInfoOrEmuOrFwdDeclaredDecl ; (; const char * ; name). staticprivate . Definit",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClass.html:95278,load,load,95278,doc/master/classTClass.html,https://root.cern,https://root.cern/doc/master/classTClass.html,1,['load'],['load']
Performance,"ng because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooProduct(); Default constructor. ~RooProduct(); Destructor. RooProduct(const char* name, const char* title, const RooArgSet& _prodSet); Construct function representing the product of functions in prodSet. RooProduct(const RooProduct& other, const char* name = 0); Copy constructor. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force internal handling of integration of given observable if any; of the product terms depend on it. Int_t getPartIntList(const RooArgSet* iset, const char* rangeName = 0) const; Return list of (partial) integrals whose product defines the integral of this; RooProduct over the observables in iset in range isetRange. If no such list; exists, create it now and store it in the cache for future use. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Declare that we handle all integrations internally. Double_t analyticalIntegral(Int_t code, const char* rangeName = 0) const; Calculate integral internally from appropriate partial integral cache. Double_t calculate(const RooArgList& partIntList) const; Calculate and return product of partial terms in partIntList. const char* makeFPName(const char* pfx, const RooArgSet& terms) const; Construct automatic name for internal product terms. Double_t evaluate() const; Evaluate product of input functions. std::list<Double_t>* binBoundaries(RooAbsRealLValue& , Double_t , Double_t ) const; Forward the plot sampling hint from the p.d.f. that defines the observable obs. Bool_t isBinnedDistribution(const RooArgSet& obs) const; If all components that depend on obs are binned that so is the product. std::list<Double_t>* plotSampli",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooProduct.html:34812,cache,cache,34812,root/html532/RooProduct.html,https://root.cern,https://root.cern/root/html532/RooProduct.html,2,['cache'],['cache']
Performance,"ng because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooProduct(); Default constructor. ~RooProduct(); Destructor. RooProduct(const char* name, const char* title, const RooArgSet& _prodSet); Construct function representing the product of functions in prodSet. RooProduct(const RooProduct& other, const char* name = 0); Copy constructor. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force internal handling of integration of given observable if any; of the product terms depend on it. Int_t getPartIntList(const RooArgSet* iset, const char* rangeName = 0) const; Return list of (partial) integrals whose product defines the integral of this; RooProduct over the observables in iset in range isetRange. If no such list; exists, create it now and store it in the cache for future use. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Declare that we handle all integrations internally. Double_t analyticalIntegral(Int_t code, const char* rangeName = 0) const; Calculate integral internally from appropriate partial integral cache. Double_t calculate(const RooArgList& partIntList) const; Calculate and return product of partial terms in partIntList. const char* makeFPName(const char* pfx, const RooArgSet& terms) const; Construct automatic name for internal product terms. Double_t evaluate() const; Evaluate product of input functions. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooProduct to more intuitively reflect the contents of the; product operator construction. TObject* clone(const char* newname) const; { return new RooProduct(*this, newname); }. ProdMap* groupProductTerms(const RooArgSet& ) const. » Last changed: ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooProduct.html:33360,cache,cache,33360,root/html526/RooProduct.html,https://root.cern,https://root.cern/root/html526/RooProduct.html,1,['cache'],['cache']
Performance,"ng because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooProduct(); Default constructor. ~RooProduct(); Destructor. RooProduct(const char* name, const char* title, const RooArgSet& _prodSet); Construct function representing the product of functions in prodSet. RooProduct(const RooProduct& other, const char* name = 0); Copy constructor. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force internal handling of integration of given observable if any; of the product terms depend on it. Int_t getPartIntList(const RooArgSet* iset, const char* rangeName = 0) const; Return list of (partial) integrals whose product defines the integral of this; RooProduct over the observables in iset in range isetRange. If no such list; exists, create it now and store it in the cache for future use. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Declare that we handle all integrations internally. Double_t analyticalIntegral(Int_t code, const char* rangeName = 0) const; Calculate integral internally from appropriate partial integral cache. Double_t calculate(const RooArgList& partIntList) const; Calculate and return product of partial terms in partIntList. const char* makeFPName(const char* pfx, const RooArgSet& terms) const; Construct automatic name for internal product terms. Double_t evaluate() const; Evaluate product of input functions. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooProduct to more intuitively reflect the contents of the; product operator construction. TObject* clone(const char* newname) const; { return new RooProduct(*this, newname); }. RooArgSet components(); { RooArgSet tmp(_compRSet) ; tmp.add(_compCSe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooProduct.html:33624,cache,cache,33624,root/html528/RooProduct.html,https://root.cern,https://root.cern/root/html528/RooProduct.html,2,['cache'],['cache']
Performance,"ng connections ids One also can exclude specified connection from return result, which can be useful to be able reply too all but this connections ;  ; unsigned GetConnLimit () const;  returns configured connections limit (0 - default) ;  ; unsigned GetDisplayConnection () const;  Returns first connection id where window is displayed It could be that connection(s) not yet fully established - but also not timed out Batch jobs will be ignored here Returns 0 if connection not exists. ;  ; unsigned GetHeight () const;  returns configured window height (0 - default) ;  ; unsigned GetId () const;  Returns ID for the window - unique inside window manager. ;  ; std::shared_ptr< RWebWindowsManager > GetManager () const;  Returns window manager. ;  ; unsigned GetMaxQueueLength () const;  Return maximal queue length of data which can be held by window. ;  ; float GetOperationTmout () const;  Returns timeout for synchronous WebWindow operations. ;  ; int GetSendQueueLength (unsigned connid) const;  Returns send queue length for specified connection. ;  ; THttpServer * GetServer ();  Return THttpServer instance serving requests to the window. ;  ; std::string GetUrl (bool remote=true);  Return URL string to connect web window URL typically includes extra parameters required for connection with the window like http://localhost:9635/win1/?key=<connection_key>#<session_key> When. ;  ; std::string GetUserArgs () const;  Returns configured user arguments for web window See SetUserArgs method for more details. ;  ; unsigned GetWidth () const;  returns configured window width (0 - default) actual window width can be different ;  ; int GetX () const;  returns configured window X position (-1 - default) ;  ; int GetY () const;  returns configured window Y position (-1 - default) ;  ; bool HasConnection (unsigned connid=0, bool only_active=true) const;  returns true if specified connection id exists ;  ; bool IsNativeOnlyConn () const;  returns true if only native (own-created) connection",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RWebWindow.html:3883,queue,queue,3883,doc/master/classROOT_1_1RWebWindow.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RWebWindow.html,1,['queue'],['queue']
Performance,"ng dictionary for the class.; 2163/// (typically used for class that are used only for transient members); 2164///; 2165/// The 'requestedname' is expected to be already normalized.; 2166 ; 2167TClass *TROOT::LoadClass(const char *requestedname, Bool_t silent) const; 2168{; 2169 return TClass::LoadClass(requestedname, silent);; 2170}; 2171 ; 2172////////////////////////////////////////////////////////////////////////////////; 2173/// Check if class ""classname"" is known to the interpreter (in fact,; 2174/// this check is not needed anymore, so classname is ignored). If; 2175/// not it will load library ""libname"". If the library couldn't be found with original; 2176/// libname and if the name was not prefixed with lib, try to prefix with ""lib"" and search again.; 2177/// If DynamicPathName still couldn't find the library, return -1.; 2178/// If check is true it will only check if libname exists and is; 2179/// readable.; 2180/// Returns 0 on successful loading, -1 in case libname does not; 2181/// exist or in case of error and -2 in case of version mismatch.; 2182 ; 2183Int_t TROOT::LoadClass(const char * /*classname*/, const char *libname,; 2184 Bool_t check); 2185{; 2186 TString lib(libname);; 2187 ; 2188 // Check if libname exists in path or not; 2189 if (char *path = gSystem->DynamicPathName(lib, kTRUE)) {; 2190 // If check == true, only check if it exists and if it's readable; 2191 if (check) {; 2192 delete [] path;; 2193 return 0;; 2194 }; 2195 ; 2196 // If check == false, try to load the library; 2197 else {; 2198 int err = gSystem->Load(path, nullptr, kTRUE);; 2199 delete [] path;; 2200 ; 2201 // TSystem::Load returns 1 when the library was already loaded, return success in this case.; 2202 if (err == 1); 2203 err = 0;; 2204 return err;; 2205 }; 2206 } else {; 2207 // This is the branch where libname didn't exist; 2208 if (check) {; 2209 FileStat_t stat;; 2210 if (!gSystem->GetPathInfo(libname, stat) && (R_ISREG(stat.fMode) &&; 2211 !gSystem->AccessPathName(libn",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8cxx_source.html:83536,load,loading,83536,doc/master/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8cxx_source.html,2,['load'],['loading']
Performance,"ng executed. ; Reimplemented in TUnixSystem, and TWinNTSystem.; Definition at line 1572 of file TSystem.cxx. ◆ Getenv(). const char * TSystem::Getenv ; (; const char * ; env). virtual . Get environment variable. ; Reimplemented in TUnixSystem, and TWinNTSystem.; Definition at line 1665 of file TSystem.cxx. ◆ GetErrno(). Int_t TSystem::GetErrno ; (; ). static . Static function returning system error number. ; Definition at line 276 of file TSystem.cxx. ◆ GetError(). const char * TSystem::GetError ; (; ). virtual . Return system error string. ; Reimplemented in TUnixSystem, and TWinNTSystem.; Definition at line 254 of file TSystem.cxx. ◆ GetErrorStr(). const char * TSystem::GetErrorStr ; (; ); const. inline . Definition at line 350 of file TSystem.h. ◆ GetFlagsDebug(). const char * TSystem::GetFlagsDebug ; (; ); const. virtual . Return the debug flags. ; Definition at line 3927 of file TSystem.cxx. ◆ GetFlagsOpt(). const char * TSystem::GetFlagsOpt ; (; ); const. virtual . Return the optimization flags. ; Definition at line 3935 of file TSystem.cxx. ◆ GetFPEMask(). Int_t TSystem::GetFPEMask ; (; ). virtual . Return the bitmap of conditions that trigger a floating point exception. ; Reimplemented in TUnixSystem, and TWinNTSystem.; Definition at line 632 of file TSystem.cxx. ◆ GetFromPipe(). TString TSystem::GetFromPipe ; (; const char * ; command). virtual . Execute command and return output in TString. ; Definition at line 680 of file TSystem.cxx. ◆ GetFsInfo(). int TSystem::GetFsInfo ; (; const char * ; path, . Long_t * ; id, . Long_t * ; bsize, . Long_t * ; blocks, . Long_t * ; bfree . ). virtual . Get info about a file system: fs type, block size, number of blocks, number of free blocks. ; Reimplemented in TUnixSystem, and TWinNTSystem.; Definition at line 1472 of file TSystem.cxx. ◆ GetGid(). Int_t TSystem::GetGid ; (; const char * ; group = nullptr). virtual . Returns the group's id. If group = 0, returns current user's group. ; Reimplemented in TUnixSystem, and T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSystem.html:58181,optimiz,optimization,58181,doc/master/classTSystem.html,https://root.cern,https://root.cern/doc/master/classTSystem.html,1,['optimiz'],['optimization']
Performance,"ng fMap and reset map counter. ;  ; void SetBufferDisplacement () override;  ; void SetBufferDisplacement (Int_t skipped) override;  ; void SetPidOffset (UShort_t offset) override;  This offset is used when a key (or basket) is transfered from one file to the other. ;  ; void SetReadParam (Int_t mapsize) override;  Set the initial size of the map used to store object and class references during reading. ;  ; void SetWriteParam (Int_t mapsize) override;  Set the initial size of the hashtable used to store object and class references during writing. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void TagStreamerInfo (TVirtualStreamerInfo *info) override;  Mark the classindex of the current file as using this TStreamerInfo. ;  ; Int_t WriteClones (TClonesArray *a, Int_t nobjects) override;  Interface to TStreamerInfo::WriteBufferClones. ;  ; template<class T > ; Int_t WriteObject (const T *objptr, Bool_t cacheReuse=kTRUE);  ; virtual void WriteObject (const TObject *obj, Bool_t cacheReuse)=0;  ; void WriteObject (const TObject *obj, Bool_t cacheReuse=kTRUE) override;  Write object to I/O buffer. ;  ; Int_t WriteObjectAny (const void *obj, const TClass *ptrClass, Bool_t cacheReuse=kTRUE) override;  Write object to I/O buffer. ;  ; UShort_t WriteProcessID (TProcessID *pid) override;  Check if the ProcessID pid is already in the file. ;  ;  Public Member Functions inherited from TBuffer;  TBuffer (EMode mode);  Create an I/O buffer object. ;  ;  TBuffer (EMode mode, Int_t bufsiz);  Create an I/O buffer object. ;  ;  TBuffer (EMode mode, Int_t bufsiz, void *buf, Bool_t adopt=kTRUE, ReAllocCharFun_t reallocfunc=nullptr);  Create an I/O buffer object. ;  ; virtual ~TBuffer ();  Delete an I/O buffer object. ;  ; void AutoExpand (Int_t size_needed);  Automatically calculate a new size and expand the buffer to fit at least size_needed. ;  ; char * Buffer () const;  ; Int_t BufferSize () const;  ; Bool_t ByteSwapBuffer (Long64_t n, EDataType type);  Byte-s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBufferJSON.html:28003,cache,cacheReuse,28003,doc/master/classTBufferJSON.html,https://root.cern,https://root.cern/doc/master/classTBufferJSON.html,15,['cache'],['cacheReuse']
Performance,"ng mode). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsCachedPdf(); Destructor. Double_t getVal(const RooArgSet* set = 0) const; Implementation of getVal() overriding default implementation; of RooAbsPdf. Return normalized value stored in cache p.d.f; rather than return value of evaluate() which is undefined; for RooAbsCachedPdf. RooAbsPdf* getCachePdf(const RooArgSet* nset); Return pointer to RooHistPdf cache pdf for given choice of observables. RooDataHist* getCacheHist(const RooArgSet* nset); Return pointer to RooDataHist cache histogram for given choice of observables. void clearCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; Mark all bins of given cache as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct string with unique suffix for cache objects based on; observable names that define cache configuration. void setInterpolationOrder(Int_t order); Change the interpolation order that is used in RooHistPdf cache; representation smoothing the RooDataHist shapes. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force RooRealIntegral to offer all our actual observable for internal; integration. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertises internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implements internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Bool_t selfNormalized() const; Declare p.d.f self normalized. RooAbsPdf* getCachePdf(const RooArgSet& nset); Return RooHistPdf that represents cache histogram. RooDataHist* getCacheHist(const RooArgSet& nset); Return RooDataHist w",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsCachedPdf.html:42149,cache,cache,42149,root/html526/RooAbsCachedPdf.html,https://root.cern,https://root.cern/root/html526/RooAbsCachedPdf.html,1,['cache'],['cache']
Performance,"ng on this check.; The default implementation checks the file name only. const TUrl * GetEndpointUrl(const char* name); Get final URL for file being opened asynchronously.; Returns 0 is the information is not yet available. void CpProgress(Long64_t bytesread, Long64_t size, TStopwatch& watch); Print file copy progress. Bool_t Cp(const char* dst, Bool_t progressbar = kTRUE, UInt_t buffersize = 1000000); Allows to copy this file to the dst URL. Returns kTRUE in case of success,; kFALSE otherwise. Bool_t Cp(const char* src, const char* dst, Bool_t progressbar = kTRUE, UInt_t buffersize = 1000000); Allows to copy file from src to dst URL. Returns kTRUE in case of success,; kFALSE otherwise. Bool_t ReadBufferAsync(Long64_t offs, Int_t len); Read specified byte range asynchronously. Actually we tell the kernel; which blocks we are going to read so it can start loading these blocks; in the buffer cache. Int_t GetBytesToPrefetch() const; Max number of bytes to prefetch. By default this is 75% of the; read cache size. But specific TFile implementations may need to change it. Int_t GetCompressionAlgorithm() const. Int_t GetCompressionLevel() const. Int_t GetCompressionSettings() const. EAsyncOpenStatus GetAsyncOpenStatus(); { return fAsyncOpenStatus; }. Long64_t DirCreateEntry(TDirectory* ); Interface for text-based TDirectory I/O. { return 0; }. Int_t DirReadKeys(TDirectory* ); { return 0; }. void DirWriteKeys(TDirectory* ); {}. void DirWriteHeader(TDirectory* ); {}. void operator=(const TFile& ). void Copy(TObject& ) const; { MayNotUse(""Copy(TObject &)""); }. TArchiveFile * GetArchive() const; { return fArchive; }. Long64_t GetArchiveOffset() const; { return fArchiveOffset; }. TArrayC * GetClassIndex() const; { return fClassIndex; }. Long64_t GetEND() const; { return fEND; }. Int_t GetFd() const; { return fD; }. const TUrl * GetEndpointUrl() const; { return &fUrl; }. TObjArray * GetListOfProcessIDs() const; {return fProcessIDs;}. TList * GetListOfFree() const; { return fFree",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TFile.html:54566,cache,cache,54566,root/html532/TFile.html,https://root.cern,https://root.cern/root/html532/TFile.html,8,['cache'],['cache']
Performance,"ng optimized, one cannot use later the TClonesArray with split>0. For example, there is a problem with the following scenario:; A class Foo has a TClonesArray of Bar objects; The Foo object is written with split=0 to Tree T1. In this case the StreamerInfo for the class Bar is created in optimized mode in such a way that data members of the same type are written as an array improving the I/O performance.; In a new program, T1 is read and a new Tree T2 is created with the object Foo in split>1; When the T2 branch is created, the StreamerInfo for the class Bar is created with no optimization (mandatory for the split mode). The optimized Bar StreamerInfo is going to be used to read the TClonesArray in T1. The result will be Bar objects with data member values not in the right sequence. The solution to this problem is to call BypassStreamer(kFALSE) for the TClonesArray. In this case, the normal Bar::Streamer function will be called. The Bar::Streamer function works OK independently if the Bar StreamerInfo had been generated in optimized mode or not. . Definition at line 321 of file TClonesArray.cxx. ◆ CanBypassStreamer(). Bool_t TClonesArray::CanBypassStreamer ; (; ); const. inline . Definition at line 64 of file TClonesArray.h. ◆ Class(). static TClass * TClonesArray::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TClonesArray::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TClonesArray::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 83 of file TClonesArray.h. ◆ Clear(). void TClonesArray::Clear ; (; Option_t * ; option = """"). overridevirtual . Clear the clones array. ; Only use this routine when your objects don't allocate memory since it will not call the object dtors. However, if the class in the TClonesArray implements the function Clear(Option_t *option) and if option = ""C"" the function Clear() is called for all ob",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClonesArray.html:32454,optimiz,optimized,32454,doc/master/classTClonesArray.html,https://root.cern,https://root.cern/doc/master/classTClonesArray.html,1,['optimiz'],['optimized']
Performance,"ng point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; RooRealProxy_meas; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; RooRealProxy_true; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooPullVar.html:33136,cache,cache,33136,root/html532/RooPullVar.html,https://root.cern,https://root.cern/root/html532/RooPullVar.html,2,['cache'],['cache']
Performance,"ng point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction2Ref<double,double,int>funcFunction pointer reference; RooRealProxyxArgument reference; RooRealProxyyArgument reference.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooCFunction2Binding_double_double_int_.html:32475,cache,cache,32475,root/html526/RooCFunction2Binding_double_double_int_.html,https://root.cern,https://root.cern/root/html526/RooCFunction2Binding_double_double_int_.html,2,['cache'],['cache']
Performance,"ng point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction2Ref<double,int,double>funcFunction pointer reference; RooRealProxyxArgument reference; RooRealProxyyArgument reference.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooCFunction2Binding_double_int_double_.html:32475,cache,cache,32475,root/html526/RooCFunction2Binding_double_int_double_.html,https://root.cern,https://root.cern/root/html526/RooCFunction2Binding_double_int_double_.html,2,['cache'],['cache']
Performance,"ng size. One should do:; resize(""drawing"");; As second argument one could specify exact size for draw elements like:; resize(""drawing"", { width: 500, height: 200 });; To correctly cleanup JSROOT drawings from HTML element, one should call:; cleanup(""drawing"");; 1.11.4 File API; JSROOT defines the TFile class, which can be used to access binary ROOT files. One should always remember that all I/O operations are asynchronous in JSROOT. Therefore promises are used to retrieve results when the I/O operation is completed. For example, reading an object from a file and displaying it will look like:; import { openFile, draw } from 'https://root.cern/js/latest/modules/main.mjs';; let filename = ""https://root.cern/js/files/hsimple.root"";; let file = await openFile(filename);; let obj = await file.readObject(""hpxpy;1"");; await draw(""drawing"", obj, ""colz"");; console.log('drawing completed');; Here is running example and source code; 1.11.5 TTree API; Simple TTree::Draw operation can be performed with following code:; import { openFile } from 'https://root.cern/js/latest/modules/io.mjs';; import { draw } from 'https://root.cern/js/latest/modules/draw.mjs';; let file = await openFile(""https://root.cern/js/files/hsimple.root"");; let tree = await file.readObject(""ntuple;1"");; draw(""drawing"", tree, ""px:py::pz>5"");; To get access to selected branches, one should use TSelector class:; import { openFile } from 'https://root.cern/js/latest/modules/io.mjs';; import { draw } from 'https://root.cern/js/latest/modules/draw.mjs';; import { TSelector, treeProcess } from 'https://root.cern/js/latest/modules/tree.mjs';. let file = await openFile(""https://root.cern/js/files/hsimple.root"");; let tree = await file.readObject(""ntuple;1"");; let selector = new TSelector();. selector.AddBranch(""px"");; selector.AddBranch(""py"");. let cnt = 0, sumpx = 0, sumpy = 0;. selector.Begin = function() {; // function called before reading of TTree starts; }. selector.Process = function() {; // function called for",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:28593,perform,performed,28593,root/htmldoc/guides/JSROOT/JSROOT.html,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html,2,['perform'],['performed']
Performance,"ng that the user knows what the normalization of his \(\mbox{FCN}\) means, and also that he is interested in parameter errors, the user can change the error definition which allows him to define what he means by one “error”, in terms of the change in the \(\mbox{FCN}\) value which should be caused by changing one parameter by one “error”. If the \(\mbox{FCN}\) is the usual chisquare function (defined below) and if the user wants the usual one-standard-deviation errors, then the error definition (return value of the FCNBase::up() method, see [howto:errordef]) should be \(1.0\). If the \(\mbox{FCN}\) is a negative-log-likelihood function, then the one-standard-deviation value for FCNBase::up() to return is \(0.5\). If the \(\mbox{FCN}\) is a chisquare, but the user wants two-standard-deviation errors, then FCNBase::up() should return \(= 4.0\), etc.; Note that in the usual case where M is being used to perform a fit to some experimental data, the parameter errors will be proportional to the uncertainty in the data, and therefore meaningful parameter errors cannot be obtained unless the measurement errors of the data are known. In the common case of a least-squares fit, \(\mbox{FCN}\) is usually defined as a chisquare:; \[\chi^2 (\alpha) = \sum_{i=1}^{n} (\frac{f(x_i,\alpha) - m_i)^2}{\sigma_i^2}\]; where \(\alpha\) is the vector of free parameters being fitted, and the \(\sigma_i\) are the uncertainties in the individual measurements \(m_i\). If these uncertainties are not known, and are simply left out of the calculation, then the fit may still have meaning, but not the quantitative values of the resulting parameter errors. (Only the relative errors of different parameters with respect to each other may be meaningful.); If the \(\sigma_i\) are all overestimated by a factor \(\beta\), then the resulting parameter errors from the fit will be overestimated by the same factor \(\beta\).; 2.5.2 The error matrix; The M processors \(\mbox{MIGRAD}\) (MnMigrad, see [api:migrad",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/minuit2/Minuit2.html:19787,perform,perform,19787,root/html534/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/html534/guides/minuit2/Minuit2.html,2,['perform'],['perform']
Performance,"ng the base classes. Instead of using InheritsFrom, which lead in some cases, including the case where the class derived from an STL collection, to spurrious autoparsing (to look at the base class of the collection!), we use a custom walk through the tree of base classes that checks their value of fCanSplit. This also has the side-effect of allowing the extension of the concept ‘base class that prevent its derived class from being split’ to any user class. This fixes ROOT-7972.; TTree. Do not automatically setup read cache during TTree::Fill(). This fixes ROOT-8031.; Fast Cloning We added a cache specifically for the fast option of the TTreeCloner to significantly reduce the run-time when fast-cloning remote files to address ROOT-5078. It can be controlled from the TTreeCloner, TTree::CopyEntries or hadd interfaces. The new cache is enabled by default, to update the size of the cache or disable it from TTreeCloner use: TTreeCloner::SetCacheSize. To do the same from TTree::CopyEntries add to the option string “cachesize=SIZE”. To update the size of the cache or disable it from hadd, use the command line option -cachesize SIZE. SIZE shouyld be given in number bytes and can be expressed in ‘human readable form’ (number followed by size unit like MB, MiB, GB or GiB, etc. or SIZE can be set zero to disable the cache. Histogram Libraries. Protect access to TROOT::GetListOfGlobalFunctions in TFormula. Math. Update MixMax random number generator for 32 bit architectures. TColor. Import TColor from master to make sure the high quality palettes are defined only ones. This was requested here. PyROOT. Fix case where c++ exception in a constructor were not propagated to python ROOT-7864; Fix case where PyROOT was unable to call copy constructor ROOT-7783; Fix handling of vector<enums> ROOT-7916; Fix the wrong return value when calling a c++ function returning short, or when retuning a char with a negative value ROOT-7872; Added a new configuration option (ROOT.PyConfig.DisableRo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v606/release-notes.html:25963,cache,cachesize,25963,doc/v606/release-notes.html,https://root.cern,https://root.cern/doc/v606/release-notes.html,1,['cache'],['cachesize']
Performance,"ng the class declaration ; Definition at line 51 of file RooCachedPdf.h. ◆ evaluate(). double RooCachedPdf::evaluate ; (; ); const. inlineoverrideprotectedvirtual . Evaluate this PDF / function / constant. Needs to be overridden by all derived classes. ; Implements RooAbsReal.; Definition at line 39 of file RooCachedPdf.h. ◆ fillCacheObject(). void RooCachedPdf::fillCacheObject ; (; RooAbsCachedPdf::PdfCacheElem & ; cache); const. overrideprotectedvirtual . Update contents of cache histogram by resampling the input p.d.f. ; Note that the cache is filled with normalized p.d.f values so that the RooHistPdf that represents the cache contents can be explicitly declared as self normalized eliminating the need for superfluous numeric calculations of unit normalization.s ; Implements RooAbsCachedPdf.; Definition at line 92 of file RooCachedPdf.cxx. ◆ inputBaseName(). const char * RooCachedPdf::inputBaseName ; (; ); const. inlineoverrideprotectedvirtual . Return the base name for cache objects, in this case the name of the cached p.d.f. ; Implements RooAbsCachedPdf.; Definition at line 33 of file RooCachedPdf.h. ◆ IsA(). TClass * RooCachedPdf::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from RooAbsCachedPdf.; Definition at line 51 of file RooCachedPdf.h. ◆ payloadUniqueSuffix(). const char * RooCachedPdf::payloadUniqueSuffix ; (; ); const. inlineoverrideprotectedvirtual . Reimplemented from RooAbsCachedPdf.; Definition at line 44 of file RooCachedPdf.h. ◆ preferredObservableScanOrder(). void RooCachedPdf::preferredObservableScanOrder ; (; const RooArgSet & ; obs, . RooArgSet & ; orderedObs . ); const. overridevirtual . Defer preferred scan order to cached pdf preference. ; Reimplemented from RooAbsReal.; Definition at line 114 of file RooCachedPdf.cxx. ◆ Streamer(). void RooCachedPdf::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from RooAbsCachedPdf. ◆ StreamerNVir",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCachedPdf.html:81659,cache,cache,81659,doc/master/classRooCachedPdf.html,https://root.cern,https://root.cern/doc/master/classRooCachedPdf.html,2,['cache'],"['cache', 'cached']"
Performance,"ng the default of kBigNumber) and no; wildcarding is used, ALWAYS returns 1 without regard to whether; the file exists or contains the correct tree. If wildcarding is used, regardless of the value of nentries,; returns the number of files matching the name without regard to; whether they contain the correct tree. If nentries<=0 and wildcarding is not used, return 1 if the file; exists and contains the correct tree and 0 otherwise. Int_t AddFile(const char* name, Long64_t nentries = kBigNumber, const char* tname = """"); -- Add a new file to this chain. Filename formats are similar to TChain::Add. Wildcards are not; applied. urls may also contain query and fragment identifiers; where the tree name can be specified in the url fragment. eg.; root://machine/path/file_name.root?query#tree_name. If tree_name is given as a part of the file name it is used to; as the name of the tree to load from the file. Otherwise if tname; argument is specified the chain will load the tree named tname from; the file, otherwise the original treename specified in the TChain; constructor will be used. A. If nentries <= 0, the file is opened and the tree header read; into memory to get the number of entries. B. If nentries > 0, the file is not opened, and nentries is assumed; to be the number of entries in the file. In this case, no check; is made that the file exists nor that the tree exists in the file.; This second mode is interesting in case the number of entries in; the file is already stored in a run database for example. C. If nentries == kBigNumber (default), the file is not opened.; The number of entries in each file will be read only when the file; is opened to read an entry. This option is the default and very; efficient if one processes the chain sequentially. Note that in; case GetEntry(entry) is called and entry refers to an entry in the; third file, for example, this forces the tree headers in the first; and second file to be read to find the number of entries in those; files. N",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TChain.html:32755,load,load,32755,root/html534/TChain.html,https://root.cern,https://root.cern/root/html534/TChain.html,6,['load'],['load']
Performance,"ng the resultant world vector which equates to it. ; Useful for making 3D world objects track mouse moves.; Camera must have valid frustum cache - call Apply() ; Definition at line 546 of file TGLCamera.cxx. ◆ ViewportOverlap(). Rgl::EOverlap TGLCamera::ViewportOverlap ; (; const TGLBoundingBox & ; box); const. Calculate overlap (kInside, kOutside, kPartial) of box projection onto viewport (as rect) against the viewport rect. ; Camera must have valid frustum cache - call Apply() after last modification, before using. ; Definition at line 319 of file TGLCamera.cxx. ◆ ViewportPlaneIntersection() [1/2]. std::pair< Bool_t, TGLVertex3 > TGLCamera::ViewportPlaneIntersection ; (; const TPoint & ; viewport, . const TGLPlane & ; worldPlane . ); const. Find the intersection of projection of supplied viewport TPoint (a 3D world line - see ViewportToWorld) with supplied world plane. ; Returns std::pair of bool and vertex. If line intersects; Camera must have valid frustum cache - call Apply() after last modification, before using ; Definition at line 533 of file TGLCamera.cxx. ◆ ViewportPlaneIntersection() [2/2]. std::pair< Bool_t, TGLVertex3 > TGLCamera::ViewportPlaneIntersection ; (; Double_t ; viewportX, . Double_t ; viewportY, . const TGLPlane & ; worldPlane . ); const. Find the intersection of projection of supplied viewport point (a 3D world line - see ViewportToWorld) with supplied world plane. ; Returns std::pair of Bool_t and TGLVertex3. If line intersects std::pair.first (Bool_t) is kTRUE, and std::pair.second (TGLVertex) contains the intersection vertex. If line does not intersect (line and plane parallel) std::pair.first (Bool_t) if kFALSE, and std::pair.second (TGLVertex) is invalid.; NOTE: The projection lines is extended for the plane intersection test hence the intersection vertex can lie outside the near/far clip regions (not visible); Camera must have valid frustum cache - call Apply() after last modification, before using ; Definition at line 517 of file TGLC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGLCamera.html:35237,cache,cache,35237,doc/master/classTGLCamera.html,https://root.cern,https://root.cern/doc/master/classTGLCamera.html,1,['cache'],['cache']
Performance,"ng them a name, value, uncertainty. Once all parameters are added to MnUserParameters, they can fix a parameter or put limits on another one before handing them over to Minuit for minimization.; 4.3.2 What the user can supply; Optionally the user can supply their own gradient calculator by implementing the FCNGradientBase interface or supply a full covariance matrix for input if one is available. The covariance matrix can be supplied in form of a std::vector\(<\)double\(>\) in packed storage format (upper triangular), or in a more user-friendly way by using the interface provided by the MnUserCovariance.; 4.4 Running a M minimization; Two use cases are addressed for minimization:. The user just wants the function to be minimized in one go.; The user wants to minimize the \(\mbox{FCN}\) in several minimization steps, re-using the result of the preceeding minimization in the next step and change parameters in between (fix/release/put limits on them, etc.). How M minimizations can be performed is shown in [example:main].; 4.4.1 Direct usage of minimizers; Minimizers such as the VariableMetricMinimizer are designed as state-less minimization engines, which means that they do not depend on the current function and its parameters. Any \(\mbox{FCN}\) function can be minimized with the same minimizer. The interface is restricted to minimization and no parameter interaction is possible.; 4.4.2 Using an application (MnMigrad); MnMigrad uses the VariableMetricMinimizer for minimization but allows as well for parameter interaction by the user. An instance of MnMigrad is specific to the current \(\mbox{FCN}\) and user parameters. Any parameter interaction of the user between two minimization steps will make use of the result of the preceeding minimization in an optimal way. The interface for parameters (see [api:parameters], [api:covariance] and [api:state]) is forwardedin MnMigrad.; 4.4.3 Subsequent minimizations; M takes care that all information is treated in an optimal and co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:35062,perform,performed,35062,root/htmldoc/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html,2,['perform'],['performed']
Performance,"ng this class . ◆ Class_Name(). static const char * TTreeCacheUnzip::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TTreeCacheUnzip::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 159 of file TTreeCacheUnzip.h. ◆ CreateTasks(). Int_t TTreeCacheUnzip::CreateTasks ; (; ). We create a TTaskGroup and asynchronously maps each group of baskets(> 100 kB in total) to a task. ; In TTaskGroup, we use TThreadExecutor to do the actually work of unzipping a group of basket. The purpose of creating TTaskGroup is to avoid competing with main thread. ; Definition at line 613 of file TTreeCacheUnzip.cxx. ◆ DeclFileName(). static const char * TTreeCacheUnzip::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 159 of file TTreeCacheUnzip.h. ◆ FillBuffer(). bool TTreeCacheUnzip::FillBuffer ; (; ). overridevirtual . Fill the cache buffer with the branches in the cache. ; Reimplemented from TTreeCache.; Definition at line 267 of file TTreeCacheUnzip.cxx. ◆ GetNFound(). Int_t TTreeCacheUnzip::GetNFound ; (; ). inline . Definition at line 154 of file TTreeCacheUnzip.h. ◆ GetNMissed(). Int_t TTreeCacheUnzip::GetNMissed ; (; ). inline . Definition at line 153 of file TTreeCacheUnzip.h. ◆ GetNUnzip(). Int_t TTreeCacheUnzip::GetNUnzip ; (; ). inline . Definition at line 152 of file TTreeCacheUnzip.h. ◆ GetParallelUnzip(). TTreeCacheUnzip::EParUnzipMode TTreeCacheUnzip::GetParallelUnzip ; (; ). static . Static function that returns the parallel option (to indicate an additional thread) ; Definition at line 407 of file TTreeCacheUnzip.cxx. ◆ GetRecordHeader(). Int_t TTreeCacheUnzip::GetRecordHeader ; (; char * ; buf, . Int_t ; maxbytes, . Int_t & ; nbytes, . Int_t & ; objlen, . Int_t & ; keylen . ). Read the logical record header from the buffer buf. ; That must be the pointer tho the header part not the object by itself and must c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCacheUnzip.html:29048,cache,cache,29048,doc/v632/classTTreeCacheUnzip.html,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html,2,['cache'],['cache']
Performance,"ng this class . ◆ Class_Name(). static const char * TTreeCacheUnzip::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TTreeCacheUnzip::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 159 of file TTreeCacheUnzip.h. ◆ CreateTasks(). Int_t TTreeCacheUnzip::CreateTasks ; (; ). We create a TTaskGroup and asynchronously maps each group of baskets(> 100 kB in total) to a task. ; In TTaskGroup, we use TThreadExecutor to do the actually work of unzipping a group of basket. The purpose of creating TTaskGroup is to avoid competing with main thread. ; Definition at line 614 of file TTreeCacheUnzip.cxx. ◆ DeclFileName(). static const char * TTreeCacheUnzip::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 159 of file TTreeCacheUnzip.h. ◆ FillBuffer(). bool TTreeCacheUnzip::FillBuffer ; (; ). overridevirtual . Fill the cache buffer with the branches in the cache. ; Reimplemented from TTreeCache.; Definition at line 267 of file TTreeCacheUnzip.cxx. ◆ GetNFound(). Int_t TTreeCacheUnzip::GetNFound ; (; ). inline . Definition at line 154 of file TTreeCacheUnzip.h. ◆ GetNMissed(). Int_t TTreeCacheUnzip::GetNMissed ; (; ). inline . Definition at line 153 of file TTreeCacheUnzip.h. ◆ GetNUnzip(). Int_t TTreeCacheUnzip::GetNUnzip ; (; ). inline . Definition at line 152 of file TTreeCacheUnzip.h. ◆ GetParallelUnzip(). TTreeCacheUnzip::EParUnzipMode TTreeCacheUnzip::GetParallelUnzip ; (; ). static . Static function that returns the parallel option (to indicate an additional thread) ; Definition at line 408 of file TTreeCacheUnzip.cxx. ◆ GetRecordHeader(). Int_t TTreeCacheUnzip::GetRecordHeader ; (; char * ; buf, . Int_t ; maxbytes, . Int_t & ; nbytes, . Int_t & ; objlen, . Int_t & ; keylen . ). Read the logical record header from the buffer buf. ; That must be the pointer tho the header part not the object by itself and must c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeCacheUnzip.html:29052,cache,cache,29052,doc/master/classTTreeCacheUnzip.html,https://root.cern,https://root.cern/doc/master/classTTreeCacheUnzip.html,2,['cache'],['cache']
Performance,"ng to a double. ;  ; virtual RooPlot * plotOn (RooPlot *frame, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={}, const RooCmdArg &arg9={}, const RooCmdArg &arg10={}) const;  Plot (project) PDF on specified frame. ;  ; virtual RooPlot * plotOn (RooPlot *frame, RooLinkedList &cmdList) const;  Internal back-end function of plotOn() with named arguments. ;  ; virtual void preferredObservableScanOrder (const RooArgSet &obs, RooArgSet &orderedObs) const;  Interface method for function objects to indicate their preferred order of observables for scanning their values into a (multi-dimensional) histogram or RooDataSet. ;  ; void printValue (std::ostream &os) const override;  Print object value. ;  ; bool readFromStream (std::istream &is, bool compact, bool verbose=false) override;  Read object contents from stream (dummy for now) ;  ; void selectComp (bool flag);  ; void setCachedValue (double value, bool notifyClients=true) final;  Overwrite the value stored in this object's cache. ;  ; virtual bool setData (RooAbsData &, bool=true);  ; void setIntegratorConfig ();  Remove the specialized numeric integration configuration associated with this object. ;  ; void setIntegratorConfig (const RooNumIntConfig &config);  Set the given integrator configuration as default numeric integration configuration for this object. ;  ; void setParameterizeIntegral (const RooArgSet &paramVars);  ; void setPlotLabel (const char *label);  Set the label associated with this variable. ;  ; void setUnit (const char *unit);  ; RooAbsMoment * sigma (RooRealVar &obs);  ; RooAbsMoment * sigma (RooRealVar &obs, const RooArgSet &nset);  ; RooNumIntConfig * specialIntegratorConfig () const;  Returns the specialized integrator configuration for this RooAbsReal. ;  ; RooNumIntConfig * specialIntegratorConfig (bool createOnTheFly);  Returns the special",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooRealIntegral.html:18180,cache,cache,18180,doc/master/classRooRealIntegral.html,https://root.cern,https://root.cern/doc/master/classRooRealIntegral.html,1,['cache'],['cache']
Performance,"ng to major and minor number.; Note that this function returns only the entry number, not the data; To read the data corresponding to an entry number, use TTree::GetEntryWithIndex; the BuildIndex function has created a table of Double_t* of sorted values; corresponding to val = major<<31 + minor;; The function performs binary search in this sorted table.; If it finds a pair that maches val, it returns directly the; index in the table.; If an entry corresponding to major and minor is not found, the function; returns the index of the major,minor pair immediatly lower than the; requested value, ie it will return -1 if the pair is lower than; the first entry in the index. See also GetEntryNumberWithIndex. Long64_t GetEntryNumberWithIndex(Int_t major, Int_t minor) const; Return entry number corresponding to major and minor number.; Note that this function returns only the entry number, not the data; To read the data corresponding to an entry number, use TTree::GetEntryWithIndex; the BuildIndex function has created a table of Double_t* of sorted values; corresponding to val = major<<31 + minor;; The function performs binary search in this sorted table.; If it finds a pair that maches val, it returns directly the; index in the table, otherwise it returns -1. See also GetEntryNumberWithBestIndex. TTreeFormula * GetMajorFormula(); Return a pointer to the TreeFormula corresponding to the majorname. TTreeFormula * GetMinorFormula(); Return a pointer to the TreeFormula corresponding to the minorname. TTreeFormula * GetMajorFormulaParent(const TTree* parent); Return a pointer to the TreeFormula corresponding to the majorname in parent tree. TTreeFormula * GetMinorFormulaParent(const TTree* parent); Return a pointer to the TreeFormula corresponding to the minorname in parent tree. void Print(Option_t* option = """") const; Print the table with : serial number, majorname, minorname.; if option = ""10"" print only the first 10 entries; if option = ""100"" print only the first 100 entries;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TTreeIndex.html:11252,perform,performs,11252,root/html530/TTreeIndex.html,https://root.cern,https://root.cern/root/html530/TTreeIndex.html,3,['perform'],['performs']
Performance,ng to print; static Bool_t_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_t_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_t_negCountNumber of negative probablities remaining to print; RooAbsReal*_norm! Normalization integral (owned by _normMgr); RooObjCacheManager_normMgrThe cache manager; RooArgSet*_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_t_rawValue; Bool_t_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsPdf.html:40398,cache,cache,40398,root/html526/RooAbsPdf.html,https://root.cern,https://root.cern/root/html526/RooAbsPdf.html,1,['cache'],['cache']
Performance,ng to print; static Bool_t_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_t_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_t_negCountNumber of negative probablities remaining to print; RooAbsReal*_norm! Normalization integral (owned by _normMgr); RooObjCacheManager_normMgrThe cache manager; TString_normRangeNormalization range; static TString_normRangeOverride; RooArgSet*_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_t_rawValue; Bool_t_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbs,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsPdf.html:40939,cache,cache,40939,root/html528/RooAbsPdf.html,https://root.cern,https://root.cern/root/html528/RooAbsPdf.html,1,['cache'],['cache']
Performance,ng to print; static Bool_t_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_t_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_t_negCountNumber of negative probablities remaining to print; RooAbsReal*_norm! Normalization integral (owned by _normMgr); RooObjCacheManager_normMgrThe cache manager; TString_normRangeNormalization range; static TString_normRangeOverride; RooArgSet*_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_t_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_t_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*_specG,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooAbsPdf.html:41205,cache,cache,41205,root/html530/RooAbsPdf.html,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html,1,['cache'],['cache']
Performance,"ng tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Bool_t_useCdfBoundariesAre c.d.f boundary conditions used by the RooHistFuncs?; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxyfuncProxy to function being cached. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooCachedReal(const char* name, const char* title, RooAbsReal& _func); Constructor taking name, title and function to be cached. To control; granularity of the binning of the cache histogram set the desired properties; in the binning named ""cache"" in the observables of the function. RooCachedReal(const char* name, const char* title, RooAbsReal& _func, const RooArgSet& cacheObs); Constructor taking name, title and function to be cached and; fixed choice of variable to cache. To control granularity of the; binning of the cache histogram set the desired properties in the; binning named ""cache"" in the observables of the function.; If the fixed set of cache observables does not match the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooCachedReal.html:34777,cache,cached,34777,root/html532/RooCachedReal.html,https://root.cern,https://root.cern/root/html532/RooCachedReal.html,1,['cache'],['cached']
Performance,"ng will be done without unzipping or unstreaming the baskets; 3097/// (i.e., a direct copy of the raw bytes on disk).; 3098///; 3099/// When 'fast' is specified, 'option' can also contain a sorting; 3100/// order for the baskets in the output file.; 3101///; 3102/// There are currently 3 supported sorting order:; 3103///; 3104/// - SortBasketsByOffset (the default); 3105/// - SortBasketsByBranch; 3106/// - SortBasketsByEntry; 3107///; 3108/// When using SortBasketsByOffset the baskets are written in the; 3109/// output file in the same order as in the original file (i.e. the; 3110/// baskets are sorted by their offset in the original file; Usually; 3111/// this also means that the baskets are sorted by the index/number of; 3112/// the _last_ entry they contain); 3113///; 3114/// When using SortBasketsByBranch all the baskets of each individual; 3115/// branches are stored contiguously. This tends to optimize reading; 3116/// speed when reading a small number (1->5) of branches, since all; 3117/// their baskets will be clustered together instead of being spread; 3118/// across the file. However it might decrease the performance when; 3119/// reading more branches (or the full entry).; 3120///; 3121/// When using SortBasketsByEntry the baskets with the lowest starting; 3122/// entry are written first. (i.e. the baskets are sorted by the; 3123/// index/number of the first entry they contain). This means that on; 3124/// the file the baskets will be in the order in which they will be; 3125/// needed when reading the whole tree sequentially.; 3126///; 3127/// For examples of CloneTree, see tutorials:; 3128///; 3129/// - copytree.C:; 3130/// A macro to copy a subset of a TTree to a new TTree.; 3131/// The input file has been generated by the program in; 3132/// $ROOTSYS/test/Event with: Event 1000 1 1 1; 3133///; 3134/// - copytree2.C:; 3135/// A macro to copy a subset of a TTree to a new TTree.; 3136/// One branch of the new Tree is written to a separate file.; 3137/// T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:124695,optimiz,optimize,124695,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['optimiz'],['optimize']
Performance,"ng, although all other generic MonaLisa ApMon functionality; can be exploited through the ApMon class directly via; dynamic_cast<TMonaLisaWriter*>(gMonitoringWriter)->GetApMon(). Additions/modifications by Fabrizio Furano 10/04/2008; - The implementation of TFile throughput and info sending was; just sending 'regular' samples about the activity of the single TFile; instance that happened to trigger an activity in the right moment.; - Now TMonaLisaWriter keeps internally track of every activity; and regularly sends summaries valid for all the files which had; activity in the last time interval.; - Additionally, it's now finalized the infrastructure able to measure; and keep track of the file Open latency. A packet is sent for each; successful Open, sending the measures of the latencies for the; various phases of the open. Currently exploited fully by TAlienFile; and TXNetFile. Easy to report from other TFiles too.; - Now, the hook for the Close() func triggers sending of a packet; containing various information about the performance related to that; file only.; - Added support also for performance monitoring when writing. Function Members (Methods); public:. TMonaLisaWriter(const char* monserver, const char* montag, const char* monid = 0, const char* monsubid = 0, const char* option = """"); virtual~TMonaLisaWriter(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMonaLisaWriter.html:1873,perform,performance,1873,root/html530/TMonaLisaWriter.html,https://root.cern,https://root.cern/root/html530/TMonaLisaWriter.html,3,['perform'],['performance']
Performance,"ng...; Searching...; No Matches. List of all members |; Public Types |; Public Member Functions |; Static Public Member Functions |; Protected Member Functions |; Protected Attributes |; Static Protected Attributes |; Private Member Functions |; Friends |; List of all members ; TGLViewer Class ReferenceGraphics » 3D Graphics » OpenGL rendering. ; Base GL viewer object - used by both standalone and embedded (in pad) GL. ; Contains core viewer objects :; GL scene - collection of main drawn objects - see TGLStdScene Cameras (fXyzzCamera) - ortho and perspective cameras - see TGLCamera Clipping (fClipXyzz) - collection of clip objects - see TGLClip Manipulators (fXyzzManip) - collection of manipulators - see TGLManip; It maintains the current active draw styles, clipping object, manipulator, camera etc.; TGLViewer is 'GUI free' in that it does not derive from any ROOT GUI TGFrame etc - see TGLSAViewer for this. However it contains GUI GUI style methods HandleButton() etc to which GUI events can be directed from standalone frame or embedding pad to perform interaction.; Also, the TGLWidget needs to be created externally. It is not owned by the viewer.; For embedded (pad) GL this viewer is created directly by plugin manager. For standalone the derived TGLSAViewer is. ; Definition at line 51 of file TGLViewer.h. Public Types; enum  ECameraType { ;   kCameraPerspXOZ; , kCameraPerspYOZ; , kCameraPerspXOY; , kCameraOrthoXOY; , ;   kCameraOrthoXOZ; , kCameraOrthoZOY; , kCameraOrthoZOX; , kCameraOrthoXnOY; , ;   kCameraOrthoXnOZ; , kCameraOrthoZnOY; , kCameraOrthoZnOX. };  ; enum  EDragAction { ;   kDragNone; , kDragCameraRotate; , kDragCameraTruck; , kDragCameraDolly; , ;   kDragOverlay. };  ; enum  EPushAction { kPushStd; , kPushCamCenter; , kPushAnnotate; };  ; enum  ESecSelType { kOnRequest; , kOnKeyMod1; };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGLViewer.html:1143,perform,perform,1143,doc/master/classTGLViewer.html,https://root.cern,https://root.cern/doc/master/classTGLViewer.html,1,['perform'],['perform']
Performance,ng...; Searching...; No Matches. List of all members |; Static Public Attributes |; Static Private Attributes |; List of all members ; ROOT::Internal::VecOps::RVecInlineStorageSize< T > Struct Template Reference. ; template<typename T>; struct ROOT::Internal::VecOps::RVecInlineStorageSize< T >The size of the inline storage of an RVec. ; Our policy is to allocate at least 8 elements (or more if they all fit into one cacheline) unless the size of the buffer with 8 elements would be over a certain maximum size. ; Definition at line 512 of file RVec.hxx. Static Public Attributes; static constexpr unsigned value;  . Static Private Attributes; static constexpr std::size_t cacheLineSize = 64;  ; static constexpr unsigned elementsPerCacheLine = (cacheLineSize - sizeof(SmallVectorBase)) / sizeof(T);  ; static constexpr unsigned maxInlineByteSize = 1024;  . #include <ROOT/RVec.hxx>; Member Data Documentation. ◆ cacheLineSize. template<typename T > . constexpr std::size_t ROOT::Internal::VecOps::RVecInlineStorageSize< T >::cacheLineSize = 64. staticconstexprprivate . Definition at line 518 of file RVec.hxx. ◆ elementsPerCacheLine. template<typename T > . constexpr unsigned ROOT::Internal::VecOps::RVecInlineStorageSize< T >::elementsPerCacheLine = (cacheLineSize - sizeof(SmallVectorBase)) / sizeof(T). staticconstexprprivate . Definition at line 520 of file RVec.hxx. ◆ maxInlineByteSize. template<typename T > . constexpr unsigned ROOT::Internal::VecOps::RVecInlineStorageSize< T >::maxInlineByteSize = 1024. staticconstexprprivate . Definition at line 521 of file RVec.hxx. ◆ value. template<typename T > . constexpr unsigned ROOT::Internal::VecOps::RVecInlineStorageSize< T >::value. staticconstexpr . Initial value:=; elementsPerCacheLine >= 8 ? elementsPerCacheLine : (sizeof(T) * 8 > maxInlineByteSize ? 0 : 8); ROOT::Internal::VecOps::RVecInlineStorageSize::maxInlineByteSizestatic constexpr unsigned maxInlineByteSizeDefinition RVec.hxx:521; ROOT::Internal::VecOps::RVecInlineStorage,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/structROOT_1_1Internal_1_1VecOps_1_1RVecInlineStorageSize.html:1162,cache,cacheLineSize,1162,doc/master/structROOT_1_1Internal_1_1VecOps_1_1RVecInlineStorageSize.html,https://root.cern,https://root.cern/doc/master/structROOT_1_1Internal_1_1VecOps_1_1RVecInlineStorageSize.html,1,['cache'],['cacheLineSize']
Performance,"ng.; - x; Extend your pattern's legibility by permitting whitespace and comments.; - p; Preserve the string matched such that ${^PREMATCH}, ${^MATCH},; and ${^POSTMATCH} are available for use after matching.; - g and c; Global matching, and keep the Current position after failed matching.; Unlike i, m, s and x, these two flags affect the way the regex is used; rather than the regex itself. See Using regular expressions in Perl in; perlretut for further explanation of the g and c modifiers.; For more detail see: http://perldoc.perl.org/perlre.html#Modifiers. TString GetModifiers() const; Return PCRE modifier options as string.; For meaning of mods see ParseMods(). void Compile(); Compile the fPattern. void Optimize(); Send the pattern through the optimizer. Int_t ReplaceSubs(const TString& s, TString& final, const TString& replacePattern, Int_t* ovec, Int_t nmatch) const; Returns the number of expanded '$' constructs. Int_t MatchInternal(const TString& s, Int_t start, Int_t nMaxMatch, TArrayI* pos = 0) const; Perform the actual matching - protected method. Int_t Match(const TString& s, const TString& mods = """", Int_t start = 0, Int_t nMaxMatch = 10, TArrayI* pos = 0); The number of matches is returned, this equals the full match +; sub-pattern matches.; nMaxMatch is the maximum allowed number of matches.; pos contains the string indices of the matches. Its usage is; shown in the routine MatchS.; For meaning of mods see ParseMods(). TObjArray * MatchS(const TString& s, const TString& mods = """", Int_t start = 0, Int_t nMaxMatch = 10); Returns a TObjArray of matched substrings as TObjString's.; The TObjArray is owner of the objects and must be deleted by the user.; The first entry is the full matched pattern, followed by the subpatterns.; If a pattern was not matched, it will return an empty substring:. TObjArray *subStrL = TPRegexp(""(a|(z))(bc)"").MatchS(""abc"");; for (Int_t i = 0; i < subStrL->GetLast()+1; i++) {; const TString subStr = ((TObjString *)subStrL->At(i))->Ge",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TPRegexp.html:4268,Perform,Perform,4268,root/html602/TPRegexp.html,https://root.cern,https://root.cern/root/html602/TPRegexp.html,2,['Perform'],['Perform']
Performance,"ng64_t index, Int_t &treenum)Return the index of ""index""-th non-zero entry in the TTree or TChain and the # of the corresponding t...Definition TEntryList.cxx:835; TEntryList::GetFileNamevirtual const char * GetFileName() constDefinition TEntryList.h:80; TEntryList::Scanstatic Int_t Scan(const char *fn, TList *roots)Scan TEntryList in 'fn' to find the common parts of paths.Definition TEntryList.cxx:1608; TEntryList::DirectoryAutoAddvirtual void DirectoryAutoAdd(TDirectory *)Called by TKey and others to automatically add us to a directory when we are read from a file.Definition TEntryList.cxx:619; TEntryList::kBlockSize@ kBlockSizeDefinition TEntryList.h:54; TEntryList::fNLong64_t fNnumber of entries in the listDefinition TEntryList.h:36; TEntryList::SetReapplyCutvirtual void SetReapplyCut(bool apply=false)Definition TEntryList.h:108; TEntryList::SetTreeNumbervirtual void SetTreeNumber(Int_t index)Definition TEntryList.h:107; TEntryList::fLastIndexReturnedLong64_t fLastIndexReturned! used to optimize GetEntry() function from a loopDefinition TEntryList.h:45; TEntryList::Nextvirtual Long64_t Next()Return the next non-zero entry index (next after fLastIndexQueried) this function is faster than GetE...Definition TEntryList.cxx:998; TEntryList::SetDirectoryvirtual void SetDirectory(TDirectory *dir)Add reference to directory dir. dir can be 0.Definition TEntryList.cxx:1170; TEntryList::EnterRangevoid EnterRange(Long64_t start, Long64_t end, TTree *tree=nullptr, UInt_t step=1U)Enter all entries in a range in the TEntryList.Definition TEntryList.cxx:703; TEntryList::GetCurrentListvirtual TEntryList * GetCurrentList() constDefinition TEntryList.h:71; TEntryList::SetTreeNamevirtual void SetTreeName(const char *treename)Definition TEntryList.h:105; TEntryList::Resetvirtual void Reset()Reset this list.Definition TEntryList.cxx:1138; TEntryList::IsValidbool IsValid() constDefinition TEntryList.h:84; TEntryList::fNBlocksInt_t fNBlocksnumber of TEntryListBlocksDefinition TEntryLis",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TEntryList_8h_source.html:11308,optimiz,optimize,11308,doc/master/TEntryList_8h_source.html,https://root.cern,https://root.cern/doc/master/TEntryList_8h_source.html,1,['optimiz'],['optimize']
Performance,ng64_t*TFileCacheRead::fBSeekSort[fBNseek]; Int_t*TFileCacheRead::fBSeekSortLen[fBNseek]; TList*fBrNames! list of branch names in the cache; TObjArray*fBranches! List of branches to be stored in the cache; char*TFileCacheRead::fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tTFileCacheRead::fBufferLenCurrent buffer length (<= fBufferSize); Int_tTFileCacheRead::fBufferSizeAllocated size of fBuffer (at a given time); Int_tTFileCacheRead::fBufferSizeMinOriginal size of fBuffer; Long64_tTFileCacheRead::fBytesReadNumber of bytes read for this cache; Long64_tTFileCacheRead::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Bool_tTFileCacheRead::fEnablePrefetchingreading by prefetching asynchronously; Bool_tfEnabled! cache enabled for cached reading; Long64_tfEntryCurrent! current lowest entry number in the cache; Long64_tfEntryMax! last entry in the cache; Long64_tfEntryMin! first entry in the cache; Long64_tfEntryNext! next entry number where cache must be filled; TFile*TFileCacheRead::fFilePointer to file; Int_tfFillTimes! how many times we can fill the current buffer; Bool_tfFirstBuffer! true if first buffer is used for prefetching; Long64_tfFirstEntry! save the value of the first entry; Bool_tfFirstTime! save the fact that we processes the first entry; Bool_tfIsLearning! true if cache is in learning mode; Bool_tfIsManual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; Int_tfNReadMissNumber of blocks read and not found in the chache; Int_tfNReadOkNumber of blocks read and found in the cache; Int_tfNReadPrefNumber of blocks that were prefetched; Int_tTFileCacheRead::fNbNumber of long buffers; Int_tfNbranches! Number of branches in the cache; Long64_tTFileCacheRead::fNoCacheBytesReadNumber of bytes read by basket to fill cached tree; ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTreeCache.html:19281,cache,cache,19281,root/html602/TTreeCache.html,https://root.cern,https://root.cern/root/html602/TTreeCache.html,4,['cache'],['cache']
Performance,"ng::npos) {; 215 std::string msg = ""Type alias '"" + std::string(1, col.second) + ""' is not supported.\n"";; 216 msg += ""Supported type aliases are 'O' for boolean, 'D' for double, 'L' for Long64_t, 'T' for std::string."";; 217 throw std::runtime_error(msg);; 218 }; 219 }; 220}; 221 ; 222void RCsvDS::InferColTypes(std::vector<std::string> &columns); 223{; 224 const auto second_line = fCsvFile->GetFilePos();; 225 ; 226 for (auto i = 0u; i < columns.size(); ++i) {; 227 const auto userSpecifiedType = fColTypes.find(fHeaders[i]);; 228 if (userSpecifiedType != fColTypes.end()) {; 229 fColTypesList.push_back(userSpecifiedType->second);; 230 continue;; 231 }; 232 ; 233 // read <=10 extra lines until a non-empty cell on this column is found, so that type is determined; 234 for (auto extraRowsRead = 0u; extraRowsRead < 10u && columns[i] == ""nan""; ++extraRowsRead) {; 235 std::string line;; 236 if (!fCsvFile->Readln(line)); 237 break; // EOF; 238 const auto temp_columns = ParseColumns(line);; 239 if (temp_columns[i] != ""nan""); 240 columns[i] = temp_columns[i]; // will break the loop in the next iteration; 241 }; 242 // reset the reading from the second line, because the first line is already loaded in `columns`; 243 fCsvFile->Seek(second_line);; 244 ; 245 if (columns[i] == ""nan"") {; 246 // could not find a non-empty value, default to double; 247 fColTypes[fHeaders[i]] = 'D';; 248 fColTypesList.push_back('D');; 249 } else {; 250 InferType(columns[i], i);; 251 }; 252 }; 253}; 254 ; 255void RCsvDS::InferType(const std::string &col, unsigned int idxCol); 256{; 257 ColType_t type;; 258 int dummy;; 259 ; 260 if (fgIntRegex.Index(col, &dummy) != -1) {; 261 type = 'L'; // Long64_t; 262 } else if (fgDoubleRegex1.Index(col, &dummy) != -1 || fgDoubleRegex2.Index(col, &dummy) != -1 ||; 263 fgDoubleRegex3.Index(col, &dummy) != -1) {; 264 type = 'D'; // double; 265 } else if (fgTrueRegex.Index(col, &dummy) != -1 || fgFalseRegex.Index(col, &dummy) != -1) {; 266 type = 'O'; // bool; 267 } else {",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RCsvDS_8cxx_source.html:8995,load,loaded,8995,doc/master/RCsvDS_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RCsvDS_8cxx_source.html,1,['load'],['loaded']
Performance,"ng; 151 // calls methods Train() implemented by derived classes; 152 void TrainMethod();; 153 ; 154 // optimize tuning parameters; 155 virtual std::map<TString,Double_t> OptimizeTuningParameters(TString fomType=""ROCIntegral"", TString fitType=""FitGA"");; 156 virtual void SetTuneParameters(std::map<TString,Double_t> tuneParameters);; 157 ; 158 virtual void Train() = 0;; 159 ; 160 // store and retrieve time used for training; 161 void SetTrainTime( Double_t trainTime ) { fTrainTime = trainTime; }; 162 Double_t GetTrainTime() const { return fTrainTime; }; 163 ; 164 // store and retrieve time used for testing; 165 void SetTestTime ( Double_t testTime ) { fTestTime = testTime; }; 166 Double_t GetTestTime () const { return fTestTime; }; 167 ; 168 // performs classifier testing; 169 virtual void TestClassification();; 170 virtual Double_t GetKSTrainingVsTest(Char_t SorB, TString opt=""X"");; 171 ; 172 // performs multiclass classifier testing; 173 virtual void TestMulticlass();; 174 ; 175 // performs regression testing; 176 virtual void TestRegression( Double_t& bias, Double_t& biasT,; 177 Double_t& dev, Double_t& devT,; 178 Double_t& rms, Double_t& rmsT,; 179 Double_t& mInf, Double_t& mInfT, // mutual information; 180 Double_t& corr,; 181 Types::ETreeType type );; 182 ; 183 // options treatment; 184 virtual void Init() = 0;; 185 virtual void DeclareOptions() = 0;; 186 virtual void ProcessOptions() = 0;; 187 virtual void DeclareCompatibilityOptions(); // declaration of past options; 188 ; 189 // reset the Method --> As if it was not yet trained, just instantiated; 190 // virtual void Reset() = 0;; 191 //for the moment, I provide a dummy (that would not work) default, just to make; 192 // compilation/running w/o parameter optimisation still possible; 193 virtual void Reset(){return;}; 194 ; 195 // classifier response:; 196 // some methods may return a per-event error estimate; 197 // error calculation is skipped if err==0; 198 virtual Double_t GetMvaValue( Double_t* errLower = n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodBase_8h_source.html:6043,perform,performs,6043,doc/master/MethodBase_8h_source.html,https://root.cern,https://root.cern/doc/master/MethodBase_8h_source.html,1,['perform'],['performs']
Performance,ng; Bool_tfAutoCreated! true if cache was automatically created; Bool_tTFileCacheRead::fBIsSorted; Bool_tTFileCacheRead::fBIsTransferred; Int_t*TFileCacheRead::fBLen; Int_tTFileCacheRead::fBNb; Int_tTFileCacheRead::fBNseek; Int_tTFileCacheRead::fBNtot; Long64_t*TFileCacheRead::fBPos; Long64_t*TFileCacheRead::fBSeek; Int_t*TFileCacheRead::fBSeekIndex; Int_t*TFileCacheRead::fBSeekLen; Int_t*TFileCacheRead::fBSeekPos; Int_tTFileCacheRead::fBSeekSize; Long64_t*TFileCacheRead::fBSeekSort; Int_t*TFileCacheRead::fBSeekSortLen; TList*fBrNames! list of branch names in the cache; TObjArray*fBranches! List of branches to be stored in the cache; char*TFileCacheRead::fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tTFileCacheRead::fBufferLenCurrent buffer length (<= fBufferSize); Int_tTFileCacheRead::fBufferSizeAllocated size of fBuffer (at a given time); Int_tTFileCacheRead::fBufferSizeMinOriginal size of fBuffer; Long64_tTFileCacheRead::fBytesReadNumber of bytes read for this cache; Long64_tTFileCacheRead::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Bool_tTFileCacheRead::fEnablePrefetchingreading by prefetching asynchronously ; Bool_tfEnabled! cache enabled for cached reading; Long64_tfEntryCurrent! current lowest entry number in the cache; Long64_tfEntryMax! last entry in the cache; Long64_tfEntryMin! first entry in the cache; Long64_tfEntryNext! next entry number where cache must be filled; TFile*TFileCacheRead::fFilePointer to file; Int_tfFillTimes! how many times we can fill the current buffer; Bool_tfFirstBuffer! true if first buffer is used for prefetching; Long64_tfFirstEntry! save the value of the first entry; Bool_tfFirstTime! save the fact that we processes the first entry; Bool_tfIsLearning! true if cache is in learning mode; Bool_tfIsManual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains someth,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTreeCache.html:18256,cache,cache,18256,root/html534/TTreeCache.html,https://root.cern,https://root.cern/root/html534/TTreeCache.html,2,['cache'],['cache']
Performance,"ng>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooAICRegistry_codeReg! Registry of component analytical integration codes; Double_t*_coefCache! Transiet cache with transformed values of coefficients; Int_t_coefErrCount! Coefficient error counter; TIterator*_coefIter! Iterator over coefficient list; RooListProxy_coefListList of coefficients; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; Bool_t_haveLastCoefFlag indicating if last PDFs coefficient was supplied in the ctor; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling glo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAddPdf.html:41386,cache,cache,41386,root/html534/RooAddPdf.html,https://root.cern,https://root.cern/root/html534/RooAddPdf.html,2,['cache'],['cache']
Performance,"ng>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooAICRegistry_codeReg! Registry of component analytical integration codes; Double_t*_coefCache! Transiet cache with transformed values of coefficients; Int_t_coefErrCount! Coefficient error counter; TIterator*_coefIter! Iterator over coefficient list; RooListProxy_coefListList of coefficients; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; Bool_t_haveLastCoefFlag indicating if last PDFs coefficient was supplied in the ctor; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static RooFormulaVar*RooResolutionModel::_identityIdentity basis",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAddModel.html:42015,cache,cache,42015,root/html534/RooAddModel.html,https://root.cern,https://root.cern/root/html534/RooAddModel.html,2,['cache'],['cache']
Performance,"ng>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; RooNumConvolution*_conv! Actual convolution calculation; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Bool_t_init! do not persist; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooNumConvPdf.html:44175,cache,cache,44175,root/html602/RooNumConvPdf.html,https://root.cern,https://root.cern/root/html602/RooNumConvPdf.html,4,['cache'],['cache']
Performance,"ngBox Frustum(Bool_t asBox = kTRUE) const; Return the the current camera frustum. If asBox == kFALSE return; a true frustum (truncated square based pyramid). If asBox == kTRUE; return a true box, using the far clipping plane intersection projected; back to the near plane. Camera must have valid frustum cache - call Apply() after last modifcation, before using. Note: TGLBoundingBox is not really valid when filled with truncated pyramid; - this is used as a visual debug aid only so ok. TGLVertex3 EyePoint() const; Return the camera eye point (vertex) in world space; Camera must have valid frustum cache - call Apply() after last modifcation, before using. TGLVector3 EyeDirection() const; Extract the camera eye direction (vector), running from EyePoint(); Camera must have valid frustum cache - call Apply() after last modifcation, before using. TGLVertex3 FrustumCenter() const; Find the center of the camera frustum from intersection of planes; This method will work even with parallel left/right & top/bottom and; infinite eye point of ortho cameras; Camera must have valid frustum cache - call Apply() after last modifcation, before using. EOverlap FrustumOverlap(const TGLBoundingBox& box) const; Calcaulte overlap (kInside, kOutside, kPartial) of box with camera; frustum; Camera must have valid frustum cache - call Apply() after last modifcation, before using. EOverlap ViewportOverlap(const TGLBoundingBox& box) const; Calculate overlap (kInside, kOutside, kPartial) of box projection onto viewport; (as rect) against the viewport rect.; Camera must have valid frustum cache - call Apply() after last modifcation, before using. TGLRect ViewportRect(const TGLBoundingBox& box, TGLBoundingBox::EFace face) const; Calculate viewport rectangle which just contains projection of single 'face'; of world frame bounding box 'box' onto the viewport. Note use other version; of ViewportRect() if you want whole 'box' contained. TGLRect ViewportRect(const TGLBoundingBox& box, const TGLBoundingB",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGLCamera.html:7965,cache,cache,7965,root/html528/TGLCamera.html,https://root.cern,https://root.cern/root/html528/TGLCamera.html,4,['cache'],['cache']
Performance,"ngBox Frustum(Bool_t asBox = kTRUE) const; Return the the current camera frustum. If asBox == kFALSE return; a true frustum (truncated square based pyramid). If asBox == kTRUE; return a true box, using the far clipping plane intersection projected; back to the near plane. Camera must have valid frustum cache - call Apply() after last modifcation, before using. Note: TGLBoundingBox is not really valid when filled with truncated pyramid; - this is used as a visual debug aid only so ok. TGLVertex3 EyePoint() const; Return the camera eye point (vertex) in world space; Camera must have valid frustum cache - call Apply() after last modifcation, before using. TGLVector3 EyeDirection() const; Extract the camera eye direction (vector), running from EyePoint(); Camera must have valid frustum cache - call Apply() after last modifcation, before using. TGLVertex3 FrustumCenter() const; Find the center of the camera frustum from intersection of planes; This method will work even with parallel left/right & top/bottom and; infinite eye point of ortho cameras; Camera must have valid frustum cache - call Apply() after last modifcation, before using. Rgl::EOverlap FrustumOverlap(const TGLBoundingBox& box) const; Calcaulte overlap (kInside, kOutside, kPartial) of box with camera; frustum; Camera must have valid frustum cache - call Apply() after last modifcation, before using. Rgl::EOverlap ViewportOverlap(const TGLBoundingBox& box) const; Calculate overlap (kInside, kOutside, kPartial) of box projection onto viewport; (as rect) against the viewport rect.; Camera must have valid frustum cache - call Apply() after last modifcation, before using. TGLRect ViewportRect(const TGLBoundingBox& box, TGLBoundingBox::EFace face) const; Calculate viewport rectangle which just contains projection of single 'face'; of world frame bounding box 'box' onto the viewport. Note use other version; of ViewportRect() if you want whole 'box' contained. TGLRect ViewportRect(const TGLBoundingBox& box, const TG",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGLCamera.html:12610,cache,cache,12610,root/html534/TGLCamera.html,https://root.cern,https://root.cern/root/html534/TGLCamera.html,6,['cache'],['cache']
Performance,"ngDictionaries(THashTable& result, bool recurse = false); Get the classes that have a missing dictionary starting from this one.; With recurse = false the classes checked for missing dictionaries are:; the class itself, all base classes, direct data members,; and for collection proxies the container's; elements without iterating over the element's data members;; With recurse = true the classes checked for missing dictionaries are:; the class itself, all base classes, recursing on the data members,; and for the collection proxies recursiong on the elements of the; collection and iterating over the element's data members. Bool_t IsFolder(void* obj) const; Return kTRUE if the class has elements. void ReplaceWith(TClass* newcl) const; Inform the other objects to replace this object by the new TClass (newcl). void ResetClassInfo(Long_t tagnum); Make sure that the current ClassInfo is up to date. void ResetClassInfo(); Make sure that the current ClassInfo is up to date. void ResetCaches(); To clean out all caches. void ResetMenuList(); Resets the menu list to it's standard value. void ls(Option_t* opt = """") const; The ls function lists the contents of a class on stdout. Ls output; is typically much less verbose then Dump().; If options contains 'streamerinfo', run ls on the list of streamerInfos; and the list of conversion streamerInfos. void MakeCustomMenuList(); Makes a customizable version of the popup menu list, i.e. makes a list; of TClassMenuItem objects of methods accessible by context menu.; The standard (and different) way consists in having just one element; in this list, corresponding to the whole standard list.; Once the customizable version is done, one can remove or add elements. void Move(void* arenaFrom, void* arenaTo) const; Register the fact that an object was moved from the memory location; 'arenaFrom' to the memory location 'arenaTo'. TList * GetMenuList() const; Return the list of menu items associated with the class. TListOfFunctions * GetMethodList()",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TClass.html:41323,cache,caches,41323,root/html602/TClass.html,https://root.cern,https://root.cern/root/html602/TClass.html,4,['cache'],['caches']
Performance,"ngEnabled(); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); RooDataHist*RooAbsReal::fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); virtual Bool_tRooAbsCachedReal::forceAnalyticalInt(const RooAbsArg&) const; virtual voidRooAbsReal::forceNumInt(Bool_t flag = kTRUE); RooFunctor*RooAbsReal::functor(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; virtual In",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsSelfCachedReal.html:10996,cache,cacheList,10996,root/html526/RooAbsSelfCachedReal.html,https://root.cern,https://root.cern/root/html526/RooAbsSelfCachedReal.html,4,['cache'],['cacheList']
Performance,"ngEnabled(); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); RooDataHist*RooAbsReal::fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); virtual Bool_tRooAbsReal::forceAnalyticalInt(const RooAbsArg&) const; virtual voidRooAbsReal::forceNumInt(Bool_t flag = kTRUE); RooAbsReal&RooAbsOptTestStatistic::function(); const RooAbsReal&RooAbsOptTestStatistic::function() const; RooFunctor*RooAbsReal::functor(const RooArgList",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooChi2Var.html:12536,cache,cacheList,12536,root/html526/RooChi2Var.html,https://root.cern,https://root.cern/root/html526/RooChi2Var.html,4,['cache'],['cacheList']
Performance,"ngEnabled(); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); RooDataHist*RooAbsReal::fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); virtual Bool_tRooAbsReal::forceAnalyticalInt(const RooAbsArg&) const; virtual voidRooAbsReal::forceNumInt(Bool_t flag = kTRUE); RooAbsReal&function(); const RooAbsReal&function() const; RooFunctor*RooAbsReal::functor(const RooArgList& obs, const RooArgList& pars = RooArgList(), co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsOptTestStatistic.html:11440,cache,cacheList,11440,root/html526/RooAbsOptTestStatistic.html,https://root.cern,https://root.cern/root/html526/RooAbsOptTestStatistic.html,1,['cache'],['cacheList']
Performance,"ngEnabled(); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); RooDataHist*RooAbsReal::fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); virtual Bool_tRooAbsReal::forceAnalyticalInt(const RooAbsArg&) const; virtual voidRooAbsReal::forceNumInt(Bool_t flag = kTRUE); RooFunctor*RooAbsReal::functor(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; virtual Int_tRoo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsHiddenReal.html:10626,cache,cacheList,10626,root/html526/RooAbsHiddenReal.html,https://root.cern,https://root.cern/root/html526/RooAbsHiddenReal.html,42,['cache'],['cacheList']
Performance,"ngEnabled(); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); RooDataHist*RooAbsReal::fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); virtual Bool_tRooAbsReal::forceAnalyticalInt(const RooAbsArg&) const; virtual voidRooAbsReal::forceNumInt(Bool_t flag = kTRUE); RooFunctor*RooAbsReal::functor(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; virtual Int_tget",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooHistFunc.html:10599,cache,cacheList,10599,root/html526/RooHistFunc.html,https://root.cern,https://root.cern/root/html526/RooHistFunc.html,2,['cache'],['cacheList']
Performance,"ngEnabled(); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); RooDataHist*RooAbsReal::fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); virtual Bool_tRooAbsReal::forceAnalyticalInt(const RooAbsArg&) const; virtual voidRooAbsReal::forceNumInt(Bool_t flag = kTRUE); RooPlot*RooAbsRealLValue::frame() const; RooPlot*RooAbsRealLValue::frame(const RooLinkedList& cmdList) const; RooPlot*RooAbsRealLValue::frame(Int_t nbins",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooLinearVar.html:12380,cache,cacheList,12380,root/html526/RooLinearVar.html,https://root.cern,https://root.cern/root/html526/RooLinearVar.html,1,['cache'],['cacheList']
Performance,"ngEnabled(); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); RooDataHist*RooAbsReal::fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); virtual Bool_tRooAbsReal::forceAnalyticalInt(const RooAbsArg&) const; virtual voidRooAbsReal::forceNumInt(Bool_t flag = kTRUE); RooPlot*frame() const; RooPlot*frame(const RooLinkedList& cmdList) const; RooPlot*frame(Int_t nbins) const; RooPlot*frame(Double_t lo, Double_t hi) const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsRealLValue.html:11948,cache,cacheList,11948,root/html526/RooAbsRealLValue.html,https://root.cern,https://root.cern/root/html526/RooAbsRealLValue.html,1,['cache'],['cacheList']
Performance,"ngEnabled(); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); RooDataHist*RooAbsReal::fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); virtual Bool_tRooAbsReal::forceAnalyticalInt(const RooAbsArg&) const; virtual voidRooAbsReal::forceNumInt(Bool_t flag = kTRUE); TString*format(const RooCmdArg& formatArg) const; TString*format(Int_t sigDigits, const char* options) const; RooPlot*RooAbsRealLValue::frame() const; Ro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooRealVar.html:11955,cache,cacheList,11955,root/html526/RooRealVar.html,https://root.cern,https://root.cern/root/html526/RooRealVar.html,1,['cache'],['cacheList']
Performance,"ngEnabled(); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); RooDataHist*RooAbsReal::fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); virtual Bool_tforceAnalyticalInt(const RooAbsArg& dep) const; virtual voidRooAbsReal::forceNumInt(Bool_t flag = kTRUE); RooFunctor*RooAbsReal::functor(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; virtual Int_tRooAbsReal:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooProduct.html:10403,cache,cacheList,10403,root/html526/RooProduct.html,https://root.cern,https://root.cern/root/html526/RooProduct.html,1,['cache'],['cacheList']
Performance,"ngEnabled(); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); RooDataHist*RooAbsReal::fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); virtual Bool_tforceAnalyticalInt(const RooAbsArg&) const; virtual voidRooAbsReal::forceNumInt(Bool_t flag = kTRUE); RooFunctor*RooAbsReal::functor(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; virtual Int_tRooAbsReal::get",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsCachedReal.html:11099,cache,cacheList,11099,root/html526/RooAbsCachedReal.html,https://root.cern,https://root.cern/root/html526/RooAbsCachedReal.html,1,['cache'],['cacheList']
Performance,"ngRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; RooRealProxy_t; RooCategoryProxy_tag; RooRealProxy_tau; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; RooBCPEffDecay::DecayType_type; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooBCPEffDecay.html:46741,cache,cache,46741,root/html602/RooBCPEffDecay.html,https://root.cern,https://root.cern/root/html602/RooBCPEffDecay.html,4,['cache'],['cache']
Performance,"ngRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; RooRealProxy_t; RooCategoryProxy_tag; RooRealProxy_tau; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; RooBCPGenDecay::DecayType_type; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooBCPGenDecay.html:46600,cache,cache,46600,root/html602/RooBCPGenDecay.html,https://root.cern,https://root.cern/root/html602/RooBCPGenDecay.html,4,['cache'],['cache']
Performance,"ngRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; RooRealProxyalpha; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxym; RooRealProxym0; RooRealProxyn; RooRealProxysigma.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooCBShape.html:39101,cache,cache,39101,root/html528/RooCBShape.html,https://root.cern,https://root.cern/root/html528/RooCBShape.html,2,['cache'],['cache']
Performance,"ngRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; RooCategoryProxy_rhoQ; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; RooRealProxy_t; RooCategoryProxy_tag; RooRealProxy_tau; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; RooNonCPEigenDecay::DecayType_type; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; RooRealProxy_wQ; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooNonCPEigenDecay.html:45903,cache,cache,45903,root/html534/RooNonCPEigenDecay.html,https://root.cern,https://root.cern/root/html534/RooNonCPEigenDecay.html,2,['cache'],['cache']
Performance,"ngRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooRealProxy_origModelOriginal resolution model; RooRealProxy_origPdfOriginal input PDF; RooRealProxy_origVarOriginal convolution variable; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooNumConvPdf.html:42034,cache,cache,42034,root/html528/RooNumConvPdf.html,https://root.cern,https://root.cern/root/html528/RooNumConvPdf.html,2,['cache'],['cache']
Performance,"ngTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; static Bool_tTVirtualStreamerInfo::fgCanDeleteTrue if ReadBuffer can delete object; static TVirtualStreamerInfo*TVirtualStreamerInfo::fgInfoFactory; static Bool_tTVirtualStreamerInfo::fgOptimizeTrue if optimization on; static Bool_tTVirtualStreamerInfo::fgStreamMemberWiseTrue if the collections are to be stream ""member-wise"" (when possible). private:. UInt_tfCheckSumchecksum of original class; TClass*fClass!pointer to class; Int_tfClassVersionClass version identifier; TStreamerInfo::TCompInfo*fComp![fNslots with less than fElements->GetEntries()*1.5 used] Compiled info; TStreamerInfo::TCompInfo**fCompFull![fElements->GetEntries()]; TStreamerInfo::TCompInfo**fCompOpt![fNdata]; TObjArray*fElementsArray of TStreamerElements; ULong_tfLiveCount! Number of outstanding pointer to this StreamerInfo.; Int_tfNVirtualInfoLoc! Number of virtual info location to update.; Int_tfNdata!number of optimized elements; Int_tfNfulldata!number of elements; Int_tfNslots!total numbrer of slots in fComp.; Int_tfNumber!Unique identifier; Version_tfOldVersion! Version of the TStreamerInfo object read from the file; Int_tfOnFileClassVersion!Class version identifier as stored on file.; TStreamerInfoActions::TActionSequence*fReadMemberWise! List of read action resulting from the compilation for use in member wise streaming.; TStreamerInfoActions::TActionSequence*fReadMemberWiseVecPtr! List of read action resulting from the compilation for use in member wise streaming.; TStreamerInfoActions::TActionSequence*fReadObjectWise! List of read action resulting from the compilation.; Int_tfSize!size of the persistent class; ULong_t*fVirtualInfoLoc![fNVirtualInfoLoc] Location of the pointer to the TStreamerInfo inside the object (when emulated); TStreamerInfoActions::TActionSequence*fWriteMemberWise! List of write action resulting from the compilation for use in member wise streaming.; TStreamerInfoActions::TActionSequence*fWriteMemberWis",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TStreamerInfo.html:14250,optimiz,optimized,14250,root/html534/TStreamerInfo.html,https://root.cern,https://root.cern/root/html534/TStreamerInfo.html,2,['optimiz'],['optimized']
Performance,"ng_t sz, UInt_t hash = fnv1a32start); update 32 bit FNV1A hash. ULong64_t fnv1a64(const char* data); calculate 64 bit FNV1A hash of string. ULong64_t fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); update 64 bit FNV1A hash. void printCompactTreeHook(ostream& os, const char* ind = """"); Hook function interface for object to insert additional information; when printed in the context of a tree structure. This default; implementation prints nothing. void registerCache(RooAbsCache& cache); Register RooAbsCache with this object. This function is called; by RooAbsCache constructors for objects that are a datamember; of this RooAbsArg. By registering itself the RooAbsArg is aware; of all its cache data members and will forward server change; and cache mode change calls to the cache objects, which in turn; can forward them their contents. void unRegisterCache(RooAbsCache& cache); Unregister a RooAbsCache. Called from the RooAbsCache destructor. Int_t numCaches() const; Return number of registered caches. RooAbsCache* getCache(Int_t index) const; Return registered cache object by index. RooArgSet* getVariables(Bool_t stripDisconnected = kTRUE) const; Return RooArgSet with all variables (tree leaf nodes of expresssion tree). RooLinkedList getCloningAncestors() const; Return ancestors in cloning chain of this RooAbsArg. NOTE: Returned pointers; are not guaranteed to be 'live', so do not dereference without proper caution. void graphVizTree(const char* fileName, const char* delimiter = ""\n"", bool useTitle = false, bool useLatex = false); Create a GraphViz .dot file visualizing the expression tree headed by; this RooAbsArg object. Use the GraphViz tool suite to make e.g. a gif; or ps file from the .dot file. Based on concept developed by Kyle Cranmer. void graphVizTree(ostream& os, const char* delimiter = ""\n"", bool useTitle = false, bool useLatex = false); Write the GraphViz representation of the expression tree headed by; this RooAbsArg object to the given o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsArg.html:35361,cache,caches,35361,root/html534/RooAbsArg.html,https://root.cern,https://root.cern/root/html534/RooAbsArg.html,6,['cache'],['caches']
Performance,"ng_tTDataSetManager::fMTimeGroupConfigLast modification of the group config file; Int_tTDataSetManager::fNDisappearedFilesNumber of files disappared in the last ScanDataSet operation; Int_tTDataSetManager::fNOpenedFilesNumber of files opened in the last ScanDataSet operation; Int_tTDataSetManager::fNTouchedFilesNumber of files touched in the last ScanDataSet operation; TStringTDataSetManager::fUserOwner of the session; TMapTDataSetManager::fUserUsed<group> --> <map of users> --> <value>; static TStringTDataSetManager::fgCommonDataSetTagName for common datasets, default: COMMON; static TList*TDataSetManager::fgDataSetSrvMapsList of TPair(TRegexp, TObjString) for mapping server coordinates. private:. Int_tfCacheUpdatePeriodPeriod for checking for new updated information; TStringfDataSetDirLocation of datasets; TStringfDataSetLockFileDataset lock file; Bool_tfIsRemoteTrue if the repository is remote; TStringfListFileFile to check repository updates; TStringfLocalCacheDirLocal cache when the repository is remote; Int_tfLockFileTimeLimitLimit in seconds after a lock automatically expires; TStringfMSSUrlURL for the Mass Storage System; TStringfStageOptsOption string to be used in issuing staging requests; Bool_tfUseCacheTrue if the cache is used for browsing remote repositories. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TDataSetManagerFile(const char* group, const char* user, const char* ins). Main constructor. TDataSetManagerFile(const char* ins). Main constructor. void Init(); Do the real inititialization. void InitLocalCache(); Init the local cache if required. void ParseInitOpts(const char* opts); Parse the input string and set the init bits accordingly; Format is; dir:<datasetdir> [mss:<mss-url>] [opt:<base-options>]; The <datasetdir> is mandatory.; See TDataSetManager::ParseInitOpts for the available; base options.; The base options are laready initialized by the base constructor. const char * GetDataSetPath(const cha",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TDataSetManagerFile.html:11411,cache,cache,11411,root/html528/TDataSetManagerFile.html,https://root.cern,https://root.cern/root/html528/TDataSetManagerFile.html,8,['cache'],['cache']
Performance,"ng_tTNamed::Hash() const; virtual voidTQObject::HighPriority(const char* signal_name, const char* slot_name = 0); voidTClass::IgnoreTObjectStreamer(Bool_t ignore = kTRUE); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTClass::InheritsFrom(const char* cl) const; virtual Bool_tTClass::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTClass::InterpretedShowMembers(void* obj, TMemberInspector& insp); voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; static TClass::ENewTypeTClass::IsCallingNew(); virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTClass::IsFolder() const; Bool_tTClass::IsFolder(void* obj) const; Bool_tTClass::IsForeign() const; Bool_tTClass::IsLoaded() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTClass::IsStartingWithTObject() const; Bool_tTClass::IsTObject() const; Bool_tTObject::IsZombie() const; static TClass*TClass::Load(TBuffer& b); static voidTQObject::LoadRQ_OBJECT(); virtual voidTQObject::LowPriority(const char* signal_name, const char* slot_name = 0); virtual voidTClass::ls(Option_t* opt = """") const; voidTClass::MakeCustomMenuList(); voidTObject::MayNotUse(const char* method) const; virtual voidTQObject::Message(const char* msg)SIGNAL ; voidTClass::Move(void* arenaFrom, void* arenaTo) const; void*TClass::New(TClass::ENewType defConstructor = kClassNew) const; void*TClass::New(void* arena, TClass::ENewType defConstructor = kClassNew) const; void*TClass::NewArray(Long_t nElements, TClass::ENewType defConstructor = kClassNew) const; void*TClass::NewArray(Long_t nElements, void* arena, TClass::ENewType defConstructor = kClassNew) const; virtual Bool_tTObject::Notify(); virtual Int_tTQObject::NumberOfConnections() const; virtual Int_tTQObject::NumberOfSignals() const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delet",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TQClass.html:11594,Load,Load,11594,root/html532/TQClass.html,https://root.cern,https://root.cern/root/html532/TQClass.html,1,['Load'],['Load']
Performance,"nge (say the bin content), the bin content; 93of the original histogram is changed.; 94 ; 95The convention used in ROOT is that a Draw operation only adds; 96a reference to the object. The effective drawing is performed; 97when the canvas receives a signal to be painted.; 98 ; 99\image html gpad_pad1.png; 100 ; 101This signal is generally sent when typing carriage return in the; 102command input or when a graphical operation has been performed on one; 103of the pads of this canvas.; 104When a Canvas/Pad is repainted, the member function Paint for all; 105objects in the Pad linked list is invoked.; 106 ; 107\image html gpad_pad2.png; 108 ; 109When the mouse is moved on the Pad, The member function DistancetoPrimitive; 110is called for all the elements in the pad. DistancetoPrimitive returns; 111the distance in pixels to this object.; 112 ; 113When the object is within the distance window, the member function; 114ExecuteEvent is called for this object.; 115 ; 116In ExecuteEvent, move, changes can be performed on the object.; 117 ; 118For examples of DistancetoPrimitive and ExecuteEvent functions,; 119see classes; 120~~~ {.cpp}; 121 TLine::DistancetoPrimitive, TLine::ExecuteEvent; 122 TBox::DistancetoPrimitive, TBox::ExecuteEvent; 123 TH1::DistancetoPrimitive, TH1::ExecuteEvent; 124~~~; 125A Pad supports linear and log scales coordinate systems.; 126The transformation coefficients are explained in TPad::ResizePad.; 127*/; 128 ; 129////////////////////////////////////////////////////////////////////////////////; 130/// Pad default constructor.; 131 ; 132TPad::TPad(); 133{; 134 fModified = kTRUE;; 135 fTip = nullptr;; 136 fPadPointer = nullptr;; 137 fPrimitives = nullptr;; 138 fExecs = nullptr;; 139 fCanvas = nullptr;; 140 fPadPaint = 0;; 141 fPixmapID = -1;; 142 fGLDevice = -1;; 143 fCopyGLDevice = kFALSE;; 144 fEmbeddedGL = kFALSE;; 145 fTheta = 30;; 146 fPhi = 30;; 147 fNumber = 0;; 148 fAbsCoord = kFALSE;; 149 fEditable = kTRUE;; 150 fCrosshair = 0;; 151 fCrosshairPos",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TPad_8cxx_source.html:3761,perform,performed,3761,doc/master/TPad_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html,1,['perform'],['performed']
Performance,"nge the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; TMVA_SOFIE_GNN_Parser.treetreeDefinition TMVA_SOFIE_GNN_Parser.py:169; rf401_importttreethxDefinition rf401_importttreethx.py:1; ; RooDataHist::dh[c,x] = 300 bins (2964 weights); RooDataHist::dh[c,x] = 300 bins (2964 weights); [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping event #7 because y cannot accommodate the value 13.3845; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping event #8 because y cannot accommodate the value 11.1861; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping event #12 because y cannot accommodate the value 13.7009; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping event #14 because y cannot accommodate the value -10.6852; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping ...; [#0] WARNING:DataHandling -- RooTreeDataStore::loadValues(ds) Ignored 35 out-of-range events; RooDataSet::ds[x,y] = 65 entries; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds2) Skipping event #7 because y cannot accommodate the value 13.3845; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds2) Skipping event #8 because y cannot accommodate the value 11.1861; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds2) Skipping event #12 because y cannot accommodate the value 13.7009; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds2) Skipping event #14 because y cannot accommodate the value -10.6852; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds2) Skipping ...; [#0] WARNING:DataHandling -- RooTreeDataStore::loadValues(ds2) Ignored 36 out-of-range events; RooDataSet::ds2[x,y,z] = 26 entries; [#1] INFO:DataHandling -- RooAbsReal::attachToTree(i) TTree Int_t branch i will be converted to double precision.; RooDataSet::ds3[i,x] = 100 entries; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds4) Skipping event #2 because i cannot accommodate the value 0; [#1] INFO:D",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf401__importttreethx_8C.html:7573,load,loadValues,7573,doc/master/rf401__importttreethx_8C.html,https://root.cern,https://root.cern/doc/master/rf401__importttreethx_8C.html,2,['load'],['loadValues']
Performance,"nge. Multiple ranges may be specified; by passing multiple Range() arguments. RooAbsReal* createIntegral(const RooArgSet& iset, const RooArgSet* nset = 0, const RooNumIntConfig* cfg = 0, const char* rangeName = 0) const; Create an object that represents the integral of the function over one or more observables listed in iset; The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. If nset is specified the integrand is request; to be normalized over nset (only meaningful when the integrand is a pdf). If rangename is specified; the integral is performed over the named range, otherwise it is performed over the domain of each; integrated observable. If cfg is specified it will be used to configure any numeric integration; aspect of the integral. It will not force the integral to be performed numerically, which is; decided automatically by RooRealIntegral. RooAbsReal* createIntObj(const RooArgSet& iset, const RooArgSet* nset, const RooNumIntConfig* cfg, const char* rangeName) const; Utility function for createIntegral that creates the actual integreal object. void findInnerMostIntegration(const RooArgSet& allObs, RooArgSet& innerObs, const char* rangeName) const; Utility function for createIntObj() that aids in the construct of recursive integrals; over functions with multiple observables with parameterized ranges. This function; finds in a given set allObs over which integration is requested the largeset subset; of observables that can be integrated simultaneously. This subset consists of; observables with fixed ranges and observables with parameterized ranges whose; parameterization does not depend on any observable that is also integrated. TString integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset = 0, const char* rangeName = 0, Bool_t omitEmpty = kFALSE) const; Con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsReal.html:37195,perform,performed,37195,root/html528/RooAbsReal.html,https://root.cern,https://root.cern/root/html528/RooAbsReal.html,9,['perform'],['performed']
Performance,"nge; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; RooListProxy_x; Double_t_z; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooMultiVarGaussian.html:41953,cache,cache,41953,root/html532/RooMultiVarGaussian.html,https://root.cern,https://root.cern/root/html532/RooMultiVarGaussian.html,4,['cache'],['cache']
Performance,"nge; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; TF1*func; RooListProxylist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooTFnPdfBinding.html:40011,cache,cache,40011,root/html532/RooTFnPdfBinding.html,https://root.cern,https://root.cern/root/html532/RooTFnPdfBinding.html,4,['cache'],['cache']
Performance,"ngeEnd;; 1025 fClusterRangeEnd = nullptr;; 1026 delete [] fClusterSize;; 1027 fClusterSize = nullptr;; 1028 ; 1029 if (fTransientBuffer) {; 1030 delete fTransientBuffer;; 1031 fTransientBuffer = nullptr;; 1032 }; 1033}; 1034 ; 1035////////////////////////////////////////////////////////////////////////////////; 1036/// Returns the transient buffer currently used by this TTree for reading/writing baskets.; 1037 ; 1038TBuffer* TTree::GetTransientBuffer(Int_t size); 1039{; 1040 if (fTransientBuffer) {; 1041 if (fTransientBuffer->BufferSize() < size) {; 1042 fTransientBuffer->Expand(size);; 1043 }; 1044 return fTransientBuffer;; 1045 }; 1046 fTransientBuffer = new TBufferFile(TBuffer::kRead, size);; 1047 return fTransientBuffer;; 1048}; 1049 ; 1050////////////////////////////////////////////////////////////////////////////////; 1051/// Add branch with name bname to the Tree cache.; 1052/// If bname=""*"" all branches are added to the cache.; 1053/// if subbranches is true all the branches of the subbranches are; 1054/// also put to the cache.; 1055///; 1056/// Returns:; 1057/// - 0 branch added or already included; 1058/// - -1 on error; 1059 ; 1060Int_t TTree::AddBranchToCache(const char*bname, bool subbranches); 1061{; 1062 if (!GetTree()) {; 1063 if (LoadTree(0)<0) {; 1064 Error(""AddBranchToCache"",""Could not load a tree"");; 1065 return -1;; 1066 }; 1067 }; 1068 if (GetTree()) {; 1069 if (GetTree() != this) {; 1070 return GetTree()->AddBranchToCache(bname, subbranches);; 1071 }; 1072 } else {; 1073 Error(""AddBranchToCache"", ""No tree is available. Branch was not added to the cache"");; 1074 return -1;; 1075 }; 1076 ; 1077 TFile *f = GetCurrentFile();; 1078 if (!f) {; 1079 Error(""AddBranchToCache"", ""No file is available. Branch was not added to the cache"");; 1080 return -1;; 1081 }; 1082 TTreeCache *tc = GetReadCache(f,true);; 1083 if (!tc) {; 1084 Error(""AddBranchToCache"", ""No cache is available, branch not added"");; 1085 return -1;; 1086 }; 1087 return tc->AddBranch(bnam",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:37941,cache,cache,37941,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['cache'],['cache']
Performance,"ngeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction1Ref<double,double>funcFunction pointer reference; RooRealProxyxArgument reference.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooCFunction1PdfBinding_double_double_.html:42704,cache,cache,42704,root/html534/RooCFunction1PdfBinding_double_double_.html,https://root.cern,https://root.cern/root/html534/RooCFunction1PdfBinding_double_double_.html,2,['cache'],['cache']
Performance,"nge_{indexStateName}. RooChi2Var(const char* name, const char* title, RooAbsReal& func, RooDataHist& data, const RooArgSet& projDeps, RooChi2Var::FuncMode funcMode, const char* rangeName = 0, const char* addCoefRangeName = 0, Int_t nCPU = 1, Bool_t interleave = kFALSE, Bool_t verbose = kTRUE, Bool_t splitCutRange = kTRUE, RooAbsData::ErrorType = RooDataHist::SumW2); Constructor of a chi2 for given p.d.f. with respect given binned; dataset taking the observables specified in projDeps as projected; observables. If cutRange is specified the calculation of the chi2; is restricted to that named range. If addCoefRange is specified,; the interpretation of fractions for all component RooAddPdfs that; do not have a frozen range interpretation is set to chosen range; name. If nCPU is greater than one the chi^2 calculation is; paralellized over the specified number of processors. If; interleave is true the partitioning of event over processors; follows a (i % n == i_set) strategy rather than a bulk; partitioning strategy which may result in unequal load balancing; in binned datasets with many (adjacent) zero bins. If; splitCutRange is true the cutRange is used to construct an; individual cutRange for each RooSimultaneous index category state; name cutRange_{indexStateName}. RooChi2Var(const RooChi2Var& other, const char* name = 0); Copy constructor. ~RooChi2Var(); Destructor. Double_t evaluatePartition(Int_t firstEvent, Int_t lastEvent, Int_t stepSize) const; Calculate chi^2 in partition from firstEvent to lastEvent using given stepSize. TObject* clone(const char* newname) const; { return new RooChi2Var(*this,newname); }. RooAbsTestStatistic* create(const char* name, const char* title, RooAbsReal& pdf, RooAbsData& dhist, const RooArgSet& projDeps, const char* rangeName = 0, const char* addCoefRangeName = 0, Int_t nCPU = 1, Bool_t interleave = kFALSE, Bool_t verbose = kTRUE, Bool_t splitCutRange = kTRUE); Virtual constructor. Double_t defaultErrorLevel() const; The default error",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooChi2Var.html:41206,load,load,41206,root/html528/RooChi2Var.html,https://root.cern,https://root.cern/root/html528/RooChi2Var.html,3,['load'],['load']
Performance,"nged () override;  Update limits and notify data users. ;  ; void GetCellData (const TEveCaloData::CellId_t &id, TEveCaloData::CellData_t &data) const override;  Get cell geometry and value from cell ID. ;  ; void GetCellList (Float_t etaMin, Float_t etaMax, Float_t phi, Float_t phiRng, vCellId_t &out) const override;  Get list of cell IDs in given eta and phi range. ;  ; void GetEtaLimits (Double_t &min, Double_t &max) const override;  Get eta limits. ;  ; TH2F * GetHist (Int_t slice) const;  Get histogram in given slice. ;  ; void GetPhiLimits (Double_t &min, Double_t &max) const override;  Get phi limits. ;  ; THStack * GetStack ();  ; TClass * IsA () const override;  ; void Rebin (TAxis *ax, TAxis *ay, vCellId_t &in, Bool_t et, RebinData_t &out) const override;  Rebin. ;  ; void Streamer (TBuffer &) override;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TEveCaloData;  TEveCaloData (const char *n=""TEveCalData"", const char *t="""");  ;  ~TEveCaloData () override;  ; virtual void CellSelectionChanged ();  Tell users (TEveCaloViz instances using this data) that cell selection has changed and they should update selection cache if necessary. ;  ; Bool_t Empty () const;  ; void FillImpliedSelectedSet (Set_t &impSelSet) override;  Populate set impSelSet with derived / dependant elements. ;  ; vCellId_t & GetCellsHighlighted ();  ; vCellId_t & GetCellsSelected ();  ; virtual Float_t GetEps () const;  ; virtual TAxis * GetEtaBins () const;  ; TString GetHighlightTooltip () override;  ; virtual Float_t GetMaxVal (Bool_t et) const;  ; Int_t GetNSlices () const;  ; virtual TAxis * GetPhiBins () const;  ; Color_t GetSliceColor (Int_t slice) const;  Get color for given slice. ;  ; Float_t GetSliceThreshold (Int_t slice) const;  Get threshold for given slice. ;  ; Char_t GetSliceTransparency (Int_t slice) const;  Get transparency for given slice. ;  ; Bool_t GetWrapTwoPi () const;  ; virtual void InvalidateUsersCellIdC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEveCaloDataHist.html:1912,cache,cache,1912,doc/master/classTEveCaloDataHist.html,https://root.cern,https://root.cern/doc/master/classTEveCaloDataHist.html,1,['cache'],['cache']
Performance,"ngleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTProofBenchRun::fParListList of PARs to be loaded; TProof*TProofBenchRun::fProofProof; TStringTProofBenchRun::fSelNameName of the selector to be run; TStringTProofBenchRun::fSelOptionOption field for processing the selector. private:. TCanvas*fCPerfProfilescanvas for performance profile histograms; TProofBenchDataSet*fDSdataset operations handler; Int_tfDebugdebug switch; TDirectory*fDirProofBenchdirectory for proof outputs; Int_tfFilesPerWrk# of files to be processed per worker; TH2*fHist_perfstat_IO; TH2*fHist_perfstat_event; TList*fListPerfPlotslist of performance plots; Long64_tfNEventsnumber of events per file; Int_tfNTriesnumber of tries; TStringfNamename of this run; TProofNodes*fNodeslist of nodes information; TLegend*fNormLegend_evtLegend for norms evts; TLegend*fNormLegend_mbLegend for norms mbs; TProfile*fNorm_perfstat_IOmax; TProfile*fNorm_perfstat_evtmax; TProfile*fNorm_queryresult_IO; TProfile*fNorm_queryresult_event; TLegend*fProfLegend_evtLegend for profiles evts; TLegend*fProfLegend_mbLegend for profiles mbs; TProfile*fProfile_cpu_eff; TProfile*fProfile_perfstat_IO; TProfile*fProfile_perfstat_IOmax; TProfile*fProfile_perfstat_event; TProfile*fProfile_perfstat_evtmax; TProfile*fProfile_queryresult_IO; TProfile*fProfile_queryresult_event; TProof*fProofpointer to proof; TPBReadType*fReadTyperead type; Bool_tfReleaseCacheRelease cache for data reads between runs; Int_tfStartstart number of workers; Int_tfSteptest to be performed every fStep workers; Int_tfStopstop number of workers. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofBenchRunDataRead(TProofBenchDataSet* pbds, TPBReadType* readtype = 0, TDirectory* dirproofbench = 0, TProof* proof = 0, TProofNodes* nodes = 0, Long64_t nevents = -1, Int_t ntries = 2, Int_t start = 1, Int_t stop = -1, Int_t step = 1, Int_t debug = 0). ~TProo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofBenchRunDataRead.html:7775,perform,performance,7775,root/html602/TProofBenchRunDataRead.html,https://root.cern,https://root.cern/root/html602/TProofBenchRunDataRead.html,16,"['cache', 'perform']","['cache', 'performance', 'performed']"
Performance,"ngleLine; kStandard; kVerbose; kTreeStructure; };. protected:. set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_t_lenLength of _value; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; char*_value[_len] Value; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libra",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsString.html:17203,cache,caches,17203,root/html526/RooAbsString.html,https://root.cern,https://root.cern/root/html526/RooAbsString.html,6,['cache'],"['cache', 'caches']"
Performance,"ngs (RCompressionSetting::EAlgorithm::EValues algorithm, int compressionLevel);  ; int CompressionSettings (ROOT::ECompressionAlgorithm algorithm, int compressionLevel) R__DEPRECATED(6;  ; TClass * CreateClass (const char *cname, Version_t id, const char *dfil, const char *ifil, Int_t dl, Int_t il);  Global function called by a class' static Dictionary() method (see the ClassDef macro). ;  ; TClass * CreateClass (const char *cname, Version_t id, const std::type_info &info, TVirtualIsAProxy *isa, const char *dfil, const char *ifil, Int_t dl, Int_t il);  Global function called by a class' static Dictionary() method (see the ClassDef macro). ;  ; void DisableImplicitMT ();  Disables the implicit multi-threading in ROOT (see EnableImplicitMT). ;  ; void EnableImplicitMT (UInt_t numthreads=0);  Enable ROOT's implicit multi-threading for all objects and methods that provide an internal parallelisation mechanism. ;  ; void EnableThreadSafety ();  Enable support for multi-threading within the ROOT code in particular, enables the global mutex to make ROOT thread safe/aware. ;  ; static std::string::size_type FindEndSymbol (std::string &command);  ; template<typename T > ; EFromHumanReadableSize FromHumanReadableSize (std::string_view str, T &value);  Convert strings like the following into byte counts 5MB, 5 MB, 5M, 3.7GB, 123b, 456kB, 3.7GiB, 5MiB with some amount of forgiveness baked into the parsing. ;  ; template<typename T > ; TClass * GetClass (const T *);  ; template<typename T > ; TClass * GetClass (const T **);  ; template<typename T > ; TClass * GetClass (const T *const *);  ; template<typename T > ; TClass * GetClass (T *);  ; template<typename T > ; TClass * GetClass (T **);  ; std::vector< std::unique_ptr< TClassRec > > & GetDelayedAddClass ();  ; std::vector< std::pair< const char *, const char * > > & GetDelayedAddClassAlternate ();  ; TString & GetMacroPath ();  ; TROOT * GetROOT ();  ; void GetRuleIncludes (std::list< std::string > &result);  Get the list of",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT.html:13823,multi-thread,multi-threading,13823,doc/master/namespaceROOT.html,https://root.cern,https://root.cern/doc/master/namespaceROOT.html,1,['multi-thread'],['multi-threading']
Performance,"ngs will only apply to branches created; or attached after the setting is changed and other objects written; after the setting is changed. void SetCacheRead(TFileCacheRead* cache); Set a pointer to the read cache.; NOTE: This relinquish ownership of the previous cache, so if you do not; already have a pointer to the previous cache (and there was a previous; cache), you ought to retrieve (and delete it if needed) using:; TFileCacheRead *older = myfile->GetCacheRead();. void SetCacheWrite(TFileCacheWrite* cache); Set a pointer to the write cache.; If file is null the existing write cache is deleted. Int_t Sizeof() const; Return the size in bytes of the file header. void Streamer(TBuffer& b); Stream a TFile object. void SumBuffer(Int_t bufsize); Increment statistics for buffer sizes of objects in this file. void UseCache(Int_t maxCacheSize = 10, Int_t pageSize = 0); Dummy function kept for backward compatibility.; The read cache is now managed by TFileCacheRead; The write cache is now managed by TFileCacheWrite; Both caches are created automatically by the system. Int_t Write(const char* name = 0, Int_t opt = 0, Int_t bufsiz = 0); Write memory objects to this file.; Loop on all objects in memory (including subdirectories).; A new key is created in the KEYS linked list for each object.; The list of keys is then saved on the file (via WriteKeys); as a single data record.; For values of opt see TObject::Write().; The directory header info is rewritten on the directory header record.; The linked list of FREE segments is written.; The file header is written (bytes 1->fBEGIN). Int_t Write(const char* name = 0, Int_t opt = 0, Int_t bufsiz = 0) const; One can not save a const TDirectory object. Bool_t WriteBuffer(const char* buf, Int_t len); Write a buffer to the file. This is the basic low level write operation.; Returns kTRUE in case of failure. Int_t WriteBufferViaCache(const char* buf, Int_t len); Write buffer via cache. Returns 0 if cache is not active, 1 in case; write v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TFile.html:39411,cache,cache,39411,root/html530/TFile.html,https://root.cern,https://root.cern/root/html530/TFile.html,9,['cache'],"['cache', 'caches']"
Performance,"ngs.; 61 long long GetNumWarnings() const { return fNumWarnings; }; 62 ; 63 /// Returns the current number of errors.; 64 long long GetNumErrors() const { return fNumErrors; }; 65 ; 66 /// Returns the current number of fatal errors.; 67 long long GetNumFatalErrors() const { return fNumFatalErrors; }; 68 ; 69 /// Increase warning or error count.; 70 void Increment(ELogLevel severity); 71 {; 72 switch (severity) {; 73 case ELogLevel::kFatal: ++fNumFatalErrors; break;; 74 case ELogLevel::kError: ++fNumErrors; break;; 75 case ELogLevel::kWarning: ++fNumWarnings; break;; 76 default:;; 77 }; 78 }; 79};; 80 ; 81/**; 82 Abstract RLogHandler base class. ROOT logs everything from info to error; 83 to entities of this class.; 84 */; 85class RLogHandler {; 86public:; 87 virtual ~RLogHandler();; 88 /// Emit a log entry.; 89 /// \param entry - the RLogEntry to be emitted.; 90 /// \returns false if further emission of this Log should be suppressed.; 91 ///; 92 /// \note This function is called concurrently; log emission must be locked; 93 /// if needed. (The default log handler using ROOT's DefaultErrorHandler is locked.); 94 virtual bool Emit(const RLogEntry &entry) = 0;; 95};; 96 ; 97/**; 98 A log configuration for a channel, e.g. ""RHist"".; 99 Each ROOT module has its own log, with potentially distinct verbosity.; 100 */; 101class RLogChannel : public RLogDiagCount {; 102 /// Name as shown in diagnostics; 103 std::string fName;; 104 ; 105 /// Verbosity of this channel. By default, use the global verbosity.; 106 ELogLevel fVerbosity = ELogLevel::kUnset;; 107 ; 108public:; 109 /// Construct an anonymous channel.; 110 RLogChannel() = default;; 111 ; 112 /// Construct an anonymous channel with a default verbosity.; 113 explicit RLogChannel(ELogLevel verbosity) : fVerbosity(verbosity) {}; 114 ; 115 /// Construct a log channel given its name, which is part of the diagnostics.; 116 RLogChannel(const std::string &name) : fName(name) {}; 117 ; 118 ELogLevel SetVerbosity(ELogLevel verbosit",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RLogger_8hxx_source.html:3099,concurren,concurrently,3099,doc/master/RLogger_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RLogger_8hxx_source.html,1,['concurren'],['concurrently']
Performance,"ngs.batchSize = fetchValueTmp(block, ""BatchSize"", 30);; 336 settings.maxEpochs = fetchValueTmp(block, ""MaxEpochs"", 2000);; 337 settings.testInterval = fetchValueTmp(block, ""TestRepetitions"", 7);; 338 settings.weightDecay = fetchValueTmp(block, ""WeightDecay"", 0.0);; 339 settings.learningRate = fetchValueTmp(block, ""LearningRate"", 1e-5);; 340 settings.momentum = fetchValueTmp(block, ""Momentum"", 0.3);; 341 settings.dropoutProbabilities = fetchValueTmp(block, ""DropConfig"", std::vector<Double_t>());; 342 ; 343 TString regularization = fetchValueTmp(block, ""Regularization"", TString(""NONE""));; 344 if (regularization == ""L1"") {; 345 settings.regularization = DNN::ERegularization::kL1;; 346 } else if (regularization == ""L2"") {; 347 settings.regularization = DNN::ERegularization::kL2;; 348 } else {; 349 settings.regularization = DNN::ERegularization::kNone;; 350 }; 351 ; 352 TString optimizer = fetchValueTmp(block, ""Optimizer"", TString(""ADAM""));; 353 settings.optimizerName = optimizer;; 354 if (optimizer == ""SGD"") {; 355 settings.optimizer = DNN::EOptimizer::kSGD;; 356 } else if (optimizer == ""ADAM"") {; 357 settings.optimizer = DNN::EOptimizer::kAdam;; 358 } else if (optimizer == ""ADAGRAD"") {; 359 settings.optimizer = DNN::EOptimizer::kAdagrad;; 360 } else if (optimizer == ""RMSPROP"") {; 361 settings.optimizer = DNN::EOptimizer::kRMSProp;; 362 } else if (optimizer == ""ADADELTA"") {; 363 settings.optimizer = DNN::EOptimizer::kAdadelta;; 364 } else {; 365 // Make Adam as default choice if the input string is; 366 // incorrect.; 367 settings.optimizer = DNN::EOptimizer::kAdam;; 368 settings.optimizerName = ""ADAM"";; 369 }; 370 // check for specific optimizer parameters; 371 std::vector<TString> optimParamLabels = {""_beta1"", ""_beta2"", ""_eps"", ""_rho""};; 372 //default values; 373 std::map<TString, double> defaultValues = {; 374 {""ADADELTA_eps"", 1.E-8}, {""ADADELTA_rho"", 0.95},; 375 {""ADAGRAD_eps"", 1.E-8},; 376 {""ADAM_beta1"", 0.9}, {""ADAM_beta2"", 0.999}, {""ADAM_eps"", 1.E-7},; 377 {""RMSP",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDL_8cxx_source.html:13719,optimiz,optimizerName,13719,doc/master/MethodDL_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDL_8cxx_source.html,3,['optimiz'],"['optimizer', 'optimizerName']"
Performance,"ngth; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; char*_value[_len] Value; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsString(); Destructor. const char* getVal() const; Return value of object. Calculated if dirty, otherwise cached value is returned. Bool_t operator==(const char* ) const; Equality operator comparing with a TString. Bool_t operator==(const RooAbsArg& other); Equality operator comparing to another RooAbsArg. Bool_t readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Read object contents from stream (dummy for now). void writeToStream(ostream& os, Bool_t compact) const; Write object contents to stream (dummy for now). void printValue(ostream& os) const; Print value. Bool_t isValid() const; Check if current value is valid. Bool_t isValidString(const char* , Bool_t printError = kFALSE) const; Check if given string value is valid. Bool_t traceEvalHook(const char* value) const; Hook function for trace evaluation. const char* traceEval() const; Calculate current value of object, with error tracing wrapper. void syncCache(const RooArgSet* nset = 0); Forcibly bring internal cache up-to-date. void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE, Bool_t setValDiry = k",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsString.html:19679,cache,cached,19679,root/html532/RooAbsString.html,https://root.cern,https://root.cern/root/html532/RooAbsString.html,1,['cache'],['cached']
Performance,"ng fMsgReadBuffer;  ; TString fMsgReadBuffer10;  ; Bool_t fNoProxy;  ; TUrl fProxy;  ; Long64_t fSize;  ; TSocket * fSocket;  ; TUrl fUrlOrg;  ;  Protected Attributes inherited from TFile; TArchiveFile * fArchive {nullptr};  !Archive file from which we read this file ;  ; Long64_t fArchiveOffset {0};  !Offset at which file starts in archive ;  ; TFileOpenHandle * fAsyncHandle {nullptr};  !For proper automatic cleanup ;  ; EAsyncOpenStatus fAsyncOpenStatus {kAOSNotAsync};  !Status of an asynchronous open request ;  ; Long64_t fBEGIN {0};  First used byte in file. ;  ; Long64_t fBytesRead {0};  Number of bytes read from this file. ;  ; Long64_t fBytesReadExtra {0};  Number of extra bytes (overhead) read by the readahead buffer. ;  ; Long64_t fBytesWrite {0};  Number of bytes written to this file. ;  ; TFileCacheRead * fCacheRead {nullptr};  !Pointer to the read cache (if any) ;  ; TMap * fCacheReadMap {nullptr};  !Pointer to the read cache (if any) ;  ; TFileCacheWrite * fCacheWrite {nullptr};  !Pointer to the write cache (if any) ;  ; TArrayC * fClassIndex {nullptr};  !Index of TStreamerInfo classes written to this file ;  ; Int_t fCompress {0};  Compression level and algorithm. ;  ; Int_t fD {-1};  File descriptor. ;  ; Long64_t fEND {0};  Last used byte in file. ;  ; TList * fFree {nullptr};  Free segments linked list table. ;  ; bool fGlobalRegistration = true;  ! if true, bypass use of global lists ;  ; TList * fInfoCache {nullptr};  !Cached list of the streamer infos in this file ;  ; Bool_t fInitDone {kFALSE};  !True if the file has been initialized ;  ; Bool_t fIsArchive {kFALSE};  !True if this is a pure archive file ;  ; Bool_t fIsPcmFile {kFALSE};  !True if the file is a ROOT pcm file. ;  ; Bool_t fIsRootFile {kTRUE};  !True is this is a ROOT file, raw file otherwise ;  ; Bool_t fMustFlush {kTRUE};  !True if the file buffers must be flushed ;  ; Int_t fNbytesFree {0};  Number of bytes for free segments structure. ;  ; Int_t fNbytesInfo {0};  Number of bytes ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTS3WebFile.html:38918,cache,cache,38918,doc/master/classTS3WebFile.html,https://root.cern,https://root.cern/doc/master/classTS3WebFile.html,6,['cache'],['cache']
Performance,"nheritance; Inherited Members; Includes; Libraries. Function documentation; TSlave(const char* host, const char* ord, Int_t perf, const char* image, TProof* proof, Int_t stype, const char* workdir, const char* msd); Create a PROOF slave object. Called via the TProof ctor. TSlave(); Default constructor used by derived classes. void Init(const char* host, Int_t port, Int_t stype); Init a PROOF slave object. Called via the TSlave ctor.; The Init method is technology specific and is overwritten by derived; classes. Int_t SetupServ(Int_t stype, const char* conffile); Init a PROOF slave object. Called via the TSlave ctor.; The Init method is technology specific and is overwritten by derived; classes. void Init(TSocket* s, Int_t stype); Init a PROOF slave object using the connection opened via s. Used to; avoid double opening when an attempt via TXSlave found a remote proofd. ~TSlave(); Destroy slave. void Close(Option_t* opt = """"); Close slave socket. Int_t Compare(const TObject* obj) const; Used to sort slaves by performance index. void Print(Option_t* option = """") const; Printf info about slave. void SetInputHandler(TFileHandler* ih); Adopt and register input handler for this slave. Handler will be deleted; by the slave. Int_t OldAuthSetup(Bool_t master, TString wconf); Setup authentication related stuff for old versions.; Provided for backward compatibility. TSlave * Create(const char* url, const char* ord, Int_t perf, const char* image, TProof* proof, Int_t stype, const char* workdir, const char* msd); Static method returning the appropriate TSlave object for the remote; server. Int_t Ping(); Ping the remote master or slave servers.; Returns 0 if ok, -1 in case of error. void Interrupt(Int_t type); Send interrupt OOB byte to master or slave servers.; Returns 0 if ok, -1 in case of error. void StopProcess(Bool_t abort, Int_t timeout); Sent stop/abort request to PROOF server. TObjString * SendCoordinator(Int_t kind, const char* msg = 0, Int_t int2 = 0); Send message to i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSlave.html:9188,perform,performance,9188,root/html528/TSlave.html,https://root.cern,https://root.cern/root/html528/TSlave.html,6,['perform'],['performance']
Performance,"nherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TGLCamera; void UpdateCache () const;  largest box diagonal seen in OfInterest() - used when bootstrapping interest box ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Attributes inherited from TGLCamera; Bool_t fCacheDirty;  ; TGLMatrix fCamBase;  ; TGLMatrix fCamTrans;  ; TGLVector3 * fCenter;  ; TGLMatrix fClipM;  modelView matrix (cached) ;  ; TGLVector3 fDefCenter;  ; Double_t fDollyDefault;  last applied far-clip ;  ; Double_t fDollyDistance;  ; TGLVector3 fExtCenter;  ; Bool_t fExternalCenter;  ; Double_t fFarClip;  last applied near-clip ;  ; TGLVector3 fFDCenter;  ; Bool_t fFixDefCenter;  ; TGLPlane fFrustumPlanes [kPlanesPerFrustum];  object space clip matrix (cached) ;  ; TGLBoundingBox fInterestBox;  viewport (GL coords - origin bottom left) ;  ; Double_t fLargestSeen;  the interest box - created in UpdateInterest() ;  ; TGLMatrix fLastNoPickProjM;  timestamp ;  ; TGLMatrix fModVM;  projection matrix (cached) ;  ; Double_t fNearClip;  current camera center ;  ; TGLMatrix fProjM;  no-pick projection matrix (cached) ;  ; UInt_t fTimeStamp;  cached items dirty? ;  ; Float_t fVAxisMinAngle;  ; TGLRect fViewport;  frustum planes (cached) ;  ; Bool_t fWasArcBalled;  ;  Static Protected Attributes inherited from TGLCamera; static UInt_t fgDollyDeltaSens = 500;  . #include <TGLOrthoCamera.h>. Inheritance diagram for TGLOrthoCamera:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Enumeration Documentation. ◆ EType. enum TGLOrthoCamera::EType. EnumeratorkZOY ; kXOZ ; kXOY ; kZnOY ; kXnOZ ; kXnOY ; kZOX ; kZnOX . Definition at line 38 of file TGLOrthoCamera.h. Constructor & Destructor Documentation. ◆ TGLOrthoCamera() [1/2]",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGLOrthoCamera.html:19840,cache,cached,19840,doc/master/classTGLOrthoCamera.html,https://root.cern,https://root.cern/doc/master/classTGLOrthoCamera.html,6,['cache'],['cached']
Performance,"nherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TGLCamera; void UpdateCache () const;  largest box diagonal seen in OfInterest() - used when bootstrapping interest box ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Attributes inherited from TGLCamera; Bool_t fCacheDirty;  ; TGLMatrix fCamBase;  ; TGLMatrix fCamTrans;  ; TGLVector3 * fCenter;  ; TGLMatrix fClipM;  modelView matrix (cached) ;  ; TGLVector3 fDefCenter;  ; Double_t fDollyDefault;  last applied far-clip ;  ; Double_t fDollyDistance;  ; TGLVector3 fExtCenter;  ; Bool_t fExternalCenter;  ; Double_t fFarClip;  last applied near-clip ;  ; TGLVector3 fFDCenter;  ; Bool_t fFixDefCenter;  ; TGLPlane fFrustumPlanes [kPlanesPerFrustum];  object space clip matrix (cached) ;  ; TGLBoundingBox fInterestBox;  viewport (GL coords - origin bottom left) ;  ; Double_t fLargestSeen;  the interest box - created in UpdateInterest() ;  ; TGLMatrix fLastNoPickProjM;  timestamp ;  ; TGLMatrix fModVM;  projection matrix (cached) ;  ; Double_t fNearClip;  current camera center ;  ; TGLMatrix fProjM;  no-pick projection matrix (cached) ;  ; UInt_t fTimeStamp;  cached items dirty? ;  ; Float_t fVAxisMinAngle;  ; TGLRect fViewport;  frustum planes (cached) ;  ; Bool_t fWasArcBalled;  ;  Static Protected Attributes inherited from TGLCamera; static UInt_t fgDollyDeltaSens = 500;  . #include <TGLPerspectiveCamera.h>. Inheritance diagram for TGLPerspectiveCamera:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TGLPerspectiveCamera() [1/2]. TGLPerspectiveCamera::TGLPerspectiveCamera ; (; ). Construct default XOZ perspective camera. ; Definition at line 34 of file TGLPerspectiveCamera.cxx. ◆ TGLPerspectiveCa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGLPerspectiveCamera.html:18927,cache,cached,18927,doc/master/classTGLPerspectiveCamera.html,https://root.cern,https://root.cern/doc/master/classTGLPerspectiveCamera.html,6,['cache'],['cached']
Performance,"nhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction4Ref<double,double,double,double,int>funcFunction pointer reference; RooRealProxywArgument reference; RooRealProxyxArgument reference; RooRealProxyyArgument reference; RooRealProxyzArgument reference. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void RooCFunction4Ref<VO,VI1,VI2,VI3,VI4> Str",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooCFunction4Binding_double_double_double_double_int_.html:35408,cache,cache,35408,root/html534/RooCFunction4Binding_double_double_double_double_int_.html,https://root.cern,https://root.cern/root/html534/RooCFunction4Binding_double_double_double_double_int_.html,4,['cache'],['cache']
Performance,"nimization); Simplex; Minimize (a combination of Simplex + Migrad); Minimize; Scan; Seek. Minuit2 (class ROOT::Minuit2::Minuit2Minimizer); Migrad (default); Simplex; Minimize; Fumili (Fumili2); Scan. Fumili (class TFumiliMinimizer); GSLMultiMin (class ROOT::Math::GSLMinimizer) available when ROOT is built with mathmore support; BFGS2 (Default); BFGS; ConjugateFR; ConjugatePR; SteepestDescent. GSLMultiFit (class ROOT::Math::GSLNLMinimizer) available when ROOT is built mathmore support; GSLSimAn (class ROOT::Math::GSLSimAnMinimizer) available when ROOT is built with mathmore support; Genetic (class ROOT::Math::GeneticMinimizer); RMinimizer (class ROOT::Math::RMinimizer) available when ROOT is built with r support; BFGS (default); L-BFGS-S; Nelder-Mead; CG; and more methods, see the Details in the documentation of the function optimix of the optmix R package. The Minimizer class provides the interface to perform the minimization including; In addition to provide the API for function minimization (via ROOT::Math::Minimizer::Minimize) the Minimizer class provides:; the interface for setting the function to be minimized. The objective function passed to the Minimizer must implement the multi-dimensional generic interface ROOT::Math::IBaseFunctionMultiDim. If the function provides gradient calculation (e.g. implementing the ROOT::Math::IGradientFunctionMultiDim interface) the gradient will be used by the Minimizer class, when needed. There are convenient classes for the users to wrap their own functions in this required interface for minimization. These are the ROOT::Math::Functor class and the ROOT::Math::GradFunctor class for wrapping functions providing both evaluation and gradient. Some methods, like Fumili, Fumili2 and GSLMultiFit are specialized method for least-square and also likelihood minimizations. They require then that the given function implements in addition the ROOT::Math::FitMethodFunction interface.; The interface for setting the initial values for the fu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1Minimizer.html:1977,perform,perform,1977,doc/master/classROOT_1_1Math_1_1Minimizer.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1Minimizer.html,1,['perform'],['perform']
Performance,"nimizer status code; doublefValminimum function value; boolfValidflag for indicating valid fit. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; FitResult(). Default constructor for an empty (non valid) fit result. FitResult(const FitConfig & fconfig). Constructor from a fit-config for a dummy fit; (e.g. when only one fcn evaluation is done). FitResult(ROOT::Math::Minimizer& min, const ROOT::Fit::FitConfig& fconfig, const ROOT::Fit::FitResult::IModelFunction* f, bool isValid, unsigned int sizeOfData = 0, bool binFit = true, const ROOT::Math::IMultiGenFunction* chi2func = 0, unsigned int ncalls = 0). Construct from a Minimizer instance after fitting; Run also Minos if requested from the configuration. FitResult(const FitResult &). Copy constructor. virtual ~FitResult(). Destructor. bool Update(const ROOT::Math::Minimizer& min, bool isValid, unsigned int ncalls = 0). Update the fit result with a new minimization status; To be run only if same fit is performed with same configuration; Note that in this case MINOS is not re-run. If one wants to run also MINOS; a new result must be created. const std::string & MinimizerType() const; minimization quantities ; minimizer type. { return fMinimType; }. bool IsValid() const. True if fit successful, otherwise false.; A fit is considered successful if the minimizer succeded in finding the; minimum. It could happen that subsequent operations like error analysis (e.g. Minos); failed. In that case the status can be still true if the original minimization algorithm; succeeded in finding the minimum.; One can query in that case the minimizer return status using Status().; It is responability to the Minimizer class to tag a found minimum as valid or not; and to produce also a status code. { return fValid; }. bool IsEmpty() const; True if a fit result does not exist (even invalid) with parameter values. { return (fParams.size() == 0); }. double MinFcnValue() const; Return value of the objective ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Fit__FitResult.html:5717,perform,performed,5717,root/html534/ROOT__Fit__FitResult.html,https://root.cern,https://root.cern/root/html534/ROOT__Fit__FitResult.html,4,['perform'],['performed']
Performance,"nimizer status.; This snapshot contains the values of all constant parameters,; the value of all floating parameters at RooMinimizer construction and; after the last MINUIT operation, the MINUIT status, variance quality,; EDM setting, number of calls with evaluation problems, the minimized; function value and the full correlation matrix. RooPlot* contour(RooRealVar& var1, RooRealVar& var2, Double_t n1 = 1, Double_t n2 = 2, Double_t n3 = 0, Double_t n4 = 0, Double_t n5 = 0, Double_t n6 = 0); Create and draw a TH2 with the error contours in parameters var1 and v2 at up to 6 'sigma' settings; where 'sigma' is calculated as n*n*errorLevel. void profileStart(); Start profiling timer. void profileStop(); Stop profiling timer and report results of last session. void applyCovarianceMatrix(TMatrixDSym& V); Apply results of given external covariance matrix. i.e. propagate its errors; to all RRV parameter representations and give this matrix instead of the; HESSE matrix at the next save() call. RooFitResult* lastMinuitFit(const RooArgList& varList = RooArgList()); Import the results of the last fit performed, interpreting; the fit parameters as the given varList of parameters. RooMinimizer(RooAbsReal& function). void setEvalErrorWall(Bool_t flag); { _fcn->SetEvalErrorWall(flag); }. void setPrintEvalErrors(Int_t numEvalErrors); { _fcn->SetPrintEvalErrors(numEvalErrors); }. void setVerbose(Bool_t flag = kTRUE); { _verbose = flag ; _fcn->SetVerbose(flag); }. void setProfile(Bool_t flag = kTRUE); { _profile = flag ; }. Bool_t setLogFile(const char* logf = 0); { return _fcn->SetLogFile(logf); }. Int_t getNPar() const; { return _fcn->NDim() ; }. ofstream* logfile() const; { return _fcn->GetLogFile(); }. Double_t& maxFCN(); { return _fcn->GetMaxFCN() ; }. » Last changed: Thu Sep 23 20:00:09 2010 » Last generated: 2010-09-23 20:00; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooMinimizer.html:12194,perform,performed,12194,root/html528/RooMinimizer.html,https://root.cern,https://root.cern/root/html528/RooMinimizer.html,1,['perform'],['performed']
Performance,"ning data from the input data; 120 * type to the accelerator device or the CPU. A TTensorDataLoader object manages; 121 * a number of host and device buffer pairs that are used in a round-robin manner; 122 * for the transfer of batches to the device.; 123 *; 124 * Each TTensorDataLoader object has an associated batch size and a number of total; 125 * samples in the dataset. One epoch is the number of buffers required to transfer; 126 * the complete training set. Using the begin() and end() member functions allows; 127 * the user to iterate over the batches in one epoch.; 128 *; 129 * \tparam Data_t The input data type.; 130 * \tparam Architecture_t The architecture class of the underlying architecture.; 131 */; 132template <typename Data_t, typename Architecture_t>; 133class TTensorDataLoader {; 134private:; 135 using HostBuffer_t = typename Architecture_t::HostBuffer_t;; 136 using DeviceBuffer_t = typename Architecture_t::DeviceBuffer_t;; 137 using Matrix_t = typename Architecture_t::Matrix_t;; 138 using Tensor_t = typename Architecture_t::Tensor_t;; 139 using Shape_t = typename Architecture_t::Tensor_t::Shape_t;; 140 using BatchIterator_t = TTensorBatchIterator<Data_t, Architecture_t>;; 141 ; 142 const Data_t &fData; ///< The data that should be loaded in the batches.; 143 size_t fNSamples; ///< The total number of samples in the dataset.; 144 size_t fBatchSize; ///< The size of a batch.; 145 Shape_t fInputLayout; ///< The input data layout (does not include batch size); 146 size_t fBatchDepth; ///< The number of matrices in the tensor.; 147 size_t fBatchHeight; ///< The number od rows in each matrix.; 148 size_t fBatchWidth; ///< The number of columns in each matrix.; 149 size_t fNOutputFeatures; ///< The number of outputs from the classifier/regressor.; 150 size_t fBatchIndex; ///< The index of the batch when there are multiple batches in parallel; 151 ; 152 ; 153 size_t fNStreams; ///< Number of buffer pairs.; 154 std::vector<DeviceBuffer_t> fDeviceBuffers; ///<",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TensorDataLoader_8h_source.html:5634,load,loaded,5634,doc/master/TensorDataLoader_8h_source.html,https://root.cern,https://root.cern/doc/master/TensorDataLoader_8h_source.html,1,['load'],['loaded']
Performance,"ning mymacro.C will print:. root [0] .x mymacro.C; In mymacro.C; TCint::GetCurrentMacroName() returns ./mymacro.C; TCint::GetTopLevelMacroName() returns ./mymacro.C; Now calling inclfunc...; In inclfile.h; TCint::GetCurrentMacroName() returns inclfile.h; TCint::GetTopLevelMacroName() returns ./mymacro.C. const char * TypeName(const char* typeDesc); Return the absolute type of typeDesc.; E.g.: typeDesc = ""class TNamed**"", returns ""TNamed"".; You need to use the result immediately before it is being overwritten. Int_t LoadLibraryMap(const char* rootmapfile = 0); Load map between class and library. If rootmapfile is specified a; specific rootmap file can be added (typically used by ACLiC).; In case of error -1 is returned, 0 otherwise.; Cint uses this information to automatically load the shared library; for a class (autoload mechanism).; See also the AutoLoadCallback() method below. Int_t RescanLibraryMap(); Scan again along the dynamic path for library maps. Entries for the loaded; shared libraries are unloaded first. This can be useful after reseting; the dynamic path through TSystem::SetDynamicPath(); In case of error -1 is returned, 0 otherwise. Int_t ReloadAllSharedLibraryMaps(); Reload the library map entries coming from all the loaded shared libraries,; after first unloading the current ones.; In case of error -1 is returned, 0 otherwise. Int_t UnloadAllSharedLibraryMaps(); Unload the library map entries coming from all the loaded shared libraries.; Returns 0 if succesful. Int_t UnloadLibraryMap(const char* library); Unload library map entries coming from the specified library.; Returns -1 in case no entries for the specified library were found,; 0 otherwise. Int_t AutoLoad(const char* classname); Load library containing the specified class. Returns 0 in case of error; and 1 in case if success. Int_t AutoLoadCallback(const char* cls, const char* lib); Load library containing specified class. Returns 0 in case of error; and 1 in case if success. void * FindSpecial",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TCint.html:27866,load,loaded,27866,root/html526/TCint.html,https://root.cern,https://root.cern/root/html526/TCint.html,5,['load'],['loaded']
Performance,"ning mymacro.C will print:. root [0] .x mymacro.C; In mymacro.C; TCint::GetCurrentMacroName() returns ./mymacro.C; TCint::GetTopLevelMacroName() returns ./mymacro.C; Now calling inclfunc...; In inclfile.h; TCint::GetCurrentMacroName() returns inclfile.h; TCint::GetTopLevelMacroName() returns ./mymacro.C. const char * TypeName(const char* typeDesc); Return the absolute type of typeDesc.; E.g.: typeDesc = ""class TNamed**"", returns ""TNamed"".; You need to use the result immediately before it is being overwritten. Int_t LoadLibraryMap(const char* rootmapfile = 0); Load map between class and library. If rootmapfile is specified a; specific rootmap file can be added (typically used by ACLiC).; In case of error -1 is returned, 0 otherwise.; Cint uses this information to automatically load the shared library; for a class (autoload mechanism).; See also the AutoLoadCallback() method below. Int_t RescanLibraryMap(); Scan again along the dynamic path for library maps. Entries for the loaded; shared libraries are unloaded first. This can be useful after reseting; the dynamic path through TSystem::SetDynamicPath(); In case of error -1 is returned, 0 otherwise. Int_t ReloadAllSharedLibraryMaps(); Reload the library map entries coming from all the loaded shared libraries,; after first unloading the current ones.; In case of error -1 is returned, 0 otherwise. Int_t UnloadAllSharedLibraryMaps(); Unload the library map entries coming from all the loaded shared libraries.; Returns 0 if successful. Int_t UnloadLibraryMap(const char* library); Unload library map entries coming from the specified library.; Returns -1 in case no entries for the specified library were found,; 0 otherwise. Int_t SetClassSharedLibs(const char* cls, const char* libs); Register the autoloading information for a class.; libs is a space separated list of libraries. Int_t AutoLoad(const char* classname); Load library containing the specified class. Returns 0 in case of error; and 1 in case if success. Int_t AutoLoa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TCint.html:29383,load,loaded,29383,root/html534/TCint.html,https://root.cern,https://root.cern/root/html534/TCint.html,2,['load'],['loaded']
Performance,"ning to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxypdfProxy to p.d.f being cached. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooCachedPdf(const char* name, const char* title, RooAbsPdf& _pdf); Constructor taking name, title and function to be cached. To control; granularity of the binning of the cache histogram set the desired properties; in the binning named ""cache"" in the observables of the function. The dimensions; of the cache are automatically matched to the number of observables used; in each use context. Multiple cache in different observable may exists; simultanously if the cached p.d.f is used with multiple observable; configurations simultaneously. RooCachedPdf(const char* name, const char* title, RooAbsPdf& _pdf, const RooArgSet& cacheObs); Constructor taking name, title and function to be cached and; fixed choice of variable to cache. To control granularity of the; binning of the cache histogram set the desired properties in the; binning named ""cache"" in the observables of the function.; If the fixed set of cache observables does not match the observables; defined in the use context of the p.d.f the cache is still filled; completely. Ee.g. when it is specified to cache x and p and only x; is a observable in the given use context the cache histogram will; store sampled values for all values of ob",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooCachedPdf.html:41224,cache,cache,41224,root/html526/RooCachedPdf.html,https://root.cern,https://root.cern/root/html526/RooCachedPdf.html,8,['cache'],['cache']
Performance,"ning(Bool_t)when this static function is called, it sets the flag whether events with negative event weight shoul...Definition Event.cxx:399; TMVA::FactoryThis is the main MVA steering class.Definition Factory.h:80; TMVA::Factory::PrintHelpMessagevoid PrintHelpMessage(const TString &datasetname, const TString &methodTitle="""") constPrint predefined help message of classifier.Definition Factory.cxx:1333; TMVA::Factory::fCorrelationsBool_t fCorrelations! enable to calculate correlationsDefinition Factory.h:215; TMVA::Factory::MVectorstd::vector< IMethod * > MVectorDefinition Factory.h:84; TMVA::Factory::TrainAllMethodsvoid TrainAllMethods()Iterates through all booked methods and calls training.Definition Factory.cxx:1114; TMVA::Factory::VerboseBool_t Verbose(void) constDefinition Factory.h:134; TMVA::Factory::WriteDataInformationvoid WriteDataInformation(DataSetInfo &fDataSetInfo)Definition Factory.cxx:602; TMVA::Factory::BookMethodMethodBase * BookMethod(DataLoader *loader, TString theMethodName, TString methodTitle, TString theOption="""")Book a classifier or regression method.Definition Factory.cxx:352; TMVA::Factory::FactoryFactory(TString theJobName, TFile *theTargetFile, TString theOption="""")Standard constructor.Definition Factory.cxx:113; TMVA::Factory::TestAllMethodsvoid TestAllMethods()Evaluates all booked methods on the testing data and adds the output to the Results in the corresponi...Definition Factory.cxx:1271; TMVA::Factory::fVerboseBool_t fVerbose! verbose modeDefinition Factory.h:213; TMVA::Factory::EvaluateAllMethodsvoid EvaluateAllMethods(void)Iterates over all MVAs that have been booked, and calls their evaluation methods.Definition Factory.cxx:1376; TMVA::Factory::EvaluateImportanceRandomTH1F * EvaluateImportanceRandom(DataLoader *loader, UInt_t nseeds, Types::EMVA theMethod, TString methodTitle, const char *theOption="""")Definition Factory.cxx:2473; TMVA::Factory::GetImportanceTH1F * GetImportance(const int nbits, std::vector< Double_t > importances,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html:120807,load,loader,120807,doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,1,['load'],['loader']
Performance,"ning(disable : 4711); 112#endif; 113 ; 114 ; 115/* This code uses static_assert to check some conditions.; 116 * Unfortunately some compilers still do not support it, so we have a; 117 * replacement function here. */; 118#if defined(__STDC_VERSION__) && __STDC_VERSION__ > 201100L; 119#define mg_static_assert _Static_assert; 120#elif defined(__cplusplus) && __cplusplus >= 201103L; 121#define mg_static_assert static_assert; 122#else; 123char static_assert_replacement[1];; 124#define mg_static_assert(cond, txt) \; 125 extern char static_assert_replacement[(cond) ? 1 : -1]; 126#endif; 127 ; 128mg_static_assert(sizeof(int) == 4 || sizeof(int) == 8,; 129 ""int data type size check"");; 130mg_static_assert(sizeof(void *) == 4 || sizeof(void *) == 8,; 131 ""pointer data type size check"");; 132mg_static_assert(sizeof(void *) >= sizeof(int), ""data type size check"");; 133 ; 134 ; 135/* Select queue implementation. Diagnosis features originally only implemented; 136 * for the ""ALTERNATIVE_QUEUE"" have been ported to the previous queue; 137 * implementation (NO_ALTERNATIVE_QUEUE) as well. The new configuration value; 138 * ""CONNECTION_QUEUE_SIZE"" is only available for the previous queue; 139 * implementation, since the queue length is independent from the number of; 140 * worker threads there, while the new queue is one element per worker thread.; 141 *; 142 */; 143#if defined(NO_ALTERNATIVE_QUEUE) && defined(ALTERNATIVE_QUEUE); 144/* The queues are exclusive or - only one can be used. */; 145#error \; 146 ""Define ALTERNATIVE_QUEUE or NO_ALTERNATIVE_QUEUE (or none of them), but not both""; 147#endif; 148#if !defined(NO_ALTERNATIVE_QUEUE) && !defined(ALTERNATIVE_QUEUE); 149/* Use a default implementation */; 150#define NO_ALTERNATIVE_QUEUE; 151#endif; 152 ; 153#if defined(NO_FILESYSTEMS) && !defined(NO_FILES); 154/* File system access:; 155 * NO_FILES = do not serve any files from the file system automatically.; 156 * However, with NO_FILES CivetWeb may still write log files, read acce",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:5623,queue,queue,5623,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,2,['queue'],['queue']
Performance,"ningHistory_PyKeras_'accuracy', Entries= 0, Total sum= 13.4202; TH1.Print Name = TrainingHistory_PyKeras_'loss', Entries= 0, Total sum= 11.959; TH1.Print Name = TrainingHistory_PyKeras_'val_accuracy', Entries= 0, Total sum= 13.2436; TH1.Print Name = TrainingHistory_PyKeras_'val_loss', Entries= 0, Total sum= 12.1109; Factory : === Destroy and recreate all methods via weight files for testing ===; : ; : Reading weight file: ␛[0;36mdataset/weights/TMVA_Higgs_Classification_Likelihood.weights.xml␛[0m; : Reading weight file: ␛[0;36mdataset/weights/TMVA_Higgs_Classification_Fisher.weights.xml␛[0m; : Reading weight file: ␛[0;36mdataset/weights/TMVA_Higgs_Classification_BDT.weights.xml␛[0m; : Reading weight file: ␛[0;36mdataset/weights/TMVA_Higgs_Classification_DNN_CPU.weights.xml␛[0m; : Reading weight file: ␛[0;36mdataset/weights/TMVA_Higgs_Classification_PyKeras.weights.xml␛[0m; Factory : ␛[1mTest all methods␛[0m; Factory : Test method: Likelihood for Classification performance; : ; Likelihood : [dataset] : Evaluation of Likelihood on testing sample (6000 events); : Elapsed time for evaluation of 6000 events: 0.012 sec ; Factory : Test method: Fisher for Classification performance; : ; Fisher : [dataset] : Evaluation of Fisher on testing sample (6000 events); : Elapsed time for evaluation of 6000 events: 0.00146 sec ; : Dataset[dataset] : Evaluation of Fisher on testing sample; Factory : Test method: BDT for Classification performance; : ; BDT : [dataset] : Evaluation of BDT on testing sample (6000 events); : Elapsed time for evaluation of 6000 events: 0.0456 sec ; Factory : Test method: DNN_CPU for Classification performance; : ; : Evaluate deep neural network on CPU using batches with size = 1000; : ; TFHandler_DNN_CPU : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : m_jj: 0.017919 1.0069 [ -3.3498 3.4247 ]; : m_jjj: 0.020352 1.0044 [ -3.2831 3.3699 ]; : m_lv: 0.016356 0.99266 [ -3.2339 3.3958 ]; : m_jlv: -0.018431 0.9824",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__Higgs__Classification_8C.html:49734,perform,performance,49734,doc/master/TMVA__Higgs__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__Higgs__Classification_8C.html,1,['perform'],['performance']
Performance,"ningful only if; validation is required).; Returns kTRUE on success. Int_t SetDataSetTreeName(const char* dataset, const char* treename); Set/Change the name of the default tree. The tree name may contain; subdir specification in the form ""subdir/name"".; Returns 0 on success, -1 otherwise. TMap * GetDataSets(const char* uri = """", const char* optStr = """"); Lists all datasets that match given uri.; The 'optStr' can contain a comma-separated list of servers for which the; information is wanted. If ':lite:' (case insensitive) is specified in 'optStr'; only the global information in the TFileCollection is retrieved; useful to only; get the list of available datasets. void ShowDataSets(const char* uri = """", const char* optStr = """"); Shows datasets in locations that match the uri.; By default shows the user's datasets and global ones. Bool_t ExistsDataSet(const char* dataset); Returns kTRUE if 'dataset' exists, kFALSE otherwise. void ClearDataSetCache(const char* dataset = 0); Clear the content of the dataset cache, if any (matching 'dataset', if defined). void ShowDataSetCache(const char* dataset = 0); Display the content of the dataset cache, if any (matching 'dataset', if defined). TFileCollection * GetDataSet(const char* dataset, const char* optStr = """"); Get a list of TFileInfo objects describing the files of the specified; dataset.; To get the short version (containing only the global meta information); specify optStr = ""S:"" or optStr = ""short:"".; To get the sub-dataset of files located on a given server(s) specify; the list of servers (comma-separated) in the 'optStr' field. void ShowDataSet(const char* dataset = """", const char* opt = ""filter:SsCc""); display meta-info for given dataset usi. Int_t RemoveDataSet(const char* dataset, const char* optStr = """"); Remove the specified dataset from the PROOF cluster.; Files are not deleted. TList* FindDataSets(const char* searchString, const char* optStr = """"); Find datasets, returns in a TList all found datasets. Bool_t Req",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProof.html:92883,cache,cache,92883,root/html534/TProof.html,https://root.cern,https://root.cern/root/html534/TProof.html,6,['cache'],['cache']
Performance,"nippet below).; 298 /// Multiple callbacks can be registered with the same RResultPtr (i.e. results of RDataFrame actions) and will; 299 /// be executed sequentially. Callbacks are executed in the order they were registered.; 300 /// The type of the value contained in a RResultPtr is also available as RResultPtr<T>::Value_t, e.g.; 301 /// \code{.cpp}; 302 /// auto h = tdf.Histo1D(""x"");; 303 /// // h.kOnce is 0; 304 /// // decltype(h)::Value_t is TH1D; 305 /// \endcode; 306 ///; 307 /// When implicit multi-threading is enabled, the callback:; 308 /// - will never be executed by multiple threads concurrently: it needs not be thread-safe. For example the snippet; 309 /// above that draws the partial histogram on a canvas works seamlessly in multi-thread event loops.; 310 /// - will always be executed ""everyNEvents"": partial results will ""contain"" that number of events more from; 311 /// one call to the next; 312 /// - might be executed by a different worker thread at different times: the value of `std::this_thread::get_id()`; 313 /// might change between calls; 314 ///; 315 /// To register a callback that is called by _each_ worker thread (concurrently) every N events one can use; 316 /// OnPartialResultSlot().; 317 // clang-format on; 318 RResultPtr<T> &OnPartialResult(ULong64_t everyNEvents, std::function<void(T &)> callback); 319 {; 320 ThrowIfNull();; 321 const auto nSlots = fLoopManager->GetNSlots();; 322 auto actionPtr = fActionPtr;; 323 auto c = [nSlots, actionPtr, callback](unsigned int slot) {; 324 if (slot != nSlots - 1); 325 return;; 326 auto partialResult = static_cast<Value_t *>(actionPtr->PartialUpdate(slot));; 327 callback(*partialResult);; 328 };; 329 fLoopManager->RegisterCallback(everyNEvents, std::move(c));; 330 return *this;; 331 }; 332 ; 333 // clang-format off; 334 /// Register a callback that RDataFrame will execute in each worker thread concurrently on that thread's partial result.; 335 ///; 336 /// \param[in] everyNEvents Frequency at which the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RResultPtr_8hxx_source.html:13735,concurren,concurrently,13735,doc/master/RResultPtr_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RResultPtr_8hxx_source.html,1,['concurren'],['concurrently']
Performance,"nique object id. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void SysError (const char *method, const char *msgfmt,...) const;  Issue system error message. ;  ; R__ALWAYS_INLINE Bool_t TestBit (UInt_t f) const;  ; Int_t TestBits (UInt_t f) const;  ; virtual void UseCurrentStyle ();  Set current style settings in this object This function is called when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  . Private Member Functions;  ClassDef (MethodPyTorch, 0);  ; UInt_t GetNumValidationSamples ();  Validation of the ValidationSize option. ;  ; void SetupPyTorchModel (Bool_t loadTrainedModel);  . Private Attributes; UInt_t fBatchSize {0};  ; Bool_t fContinueTraining;  ; TString fFilenameModel;  ; TString fFilenameTrainedModel;  ; TString fLearningRateSchedule;  ; bool fModelIsSetup = false;  ; UInt_t fNOutputs {0};  ; UInt_t fNumEpochs {0};  ; Int_t fNumThreads {0};  ; TString fNumValidationString;  ; UInt_t fNVars {0};  ; std::vector< float > fOutput;  ; Bool_t fSaveBestOnly;  ; TString fUserCodeName;  ; float * fVals = nullptr;  . Additional Inherited Members;  Public Types inherited from TMVA::MethodBase; enum  EWeightFileType { kROOT =0; , kTEXT; };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodPyTorch.html:21879,load,loadTrainedModel,21879,doc/master/classTMVA_1_1MethodPyTorch.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodPyTorch.html,1,['load'],['loadTrainedModel']
Performance,"niqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsPdf::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attributes() const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooBukinPdf.html:1884,cache,cacheUniqueSuffix,1884,root/html602/RooBukinPdf.html,https://root.cern,https://root.cern/root/html602/RooBukinPdf.html,72,['cache'],['cacheUniqueSuffix']
Performance,"niqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsPdf::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attributes() const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidclearConvolutionWindow(); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooNumConvPdf.html:4142,cache,cacheUniqueSuffix,4142,root/html602/RooNumConvPdf.html,https://root.cern,https://root.cern/root/html602/RooNumConvPdf.html,4,['cache'],['cacheUniqueSuffix']
Performance,"niqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsPdf::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attributes() const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Int_tcalculateBandWidth(Int_t kernel = -999); Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/Roo2DKeysPdf.html:1948,cache,cacheUniqueSuffix,1948,root/html602/Roo2DKeysPdf.html,https://root.cern,https://root.cern/root/html602/Roo2DKeysPdf.html,4,['cache'],['cacheUniqueSuffix']
Performance,"nit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMemberInspector&); RooAbsMoment*RooAbsReal::sigma(RooRealVar& obs); RooAbsMoment*RooAbsReal::sigma(RooRealVar& obs, const RooArgSet& nset); virtual Int_tTNamed::Sizeof() const; RooNumGenConfig*RooAbsPdf::specialGeneratorConfig() const; RooNumGenConfig*RooAbsPdf::specialGeneratorConfig(Bool_t createOnTheFly); RooNumIntConfig*RooAbsReal::specialIntegratorConfig() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig(Bool_t createOnTheFly); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); const map<std::string,std::string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual Bool_tRooAbsPdf::traceEvalHook(Double_t value) const; Bool_tRooAbsPdf::traceEvalPdf(Double_t value) const; const set<std::string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; RooFIterRooAbsArg::valueClientMIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); static intRooAbsPdf::verboseEval(); static voidRooAbsPdf::verboseEval(Int_t stat); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; voidRooAbsArg::wireAllCaches(); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidRooAbsReal::writeToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsAnaConvPdf.html:34193,cache,cache,34193,root/html534/RooAbsAnaConvPdf.html,https://root.cern,https://root.cern/root/html534/RooAbsAnaConvPdf.html,134,['cache'],['cache']
Performance,"nitSlave(RooAbsReal& real, RooAbsData& indata, const RooArgSet& projDeps, const char* rangeName, const char* addCoefRangeName). ~RooAbsOptTestStatistic(); Destructor. Double_t combinedValue(RooAbsReal** gofArray, Int_t nVal) const; Method to combined test statistic results calculated into partitions into; the global result. This default implementation adds the partition return; values. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); Catch server redirect calls and forward to internal clone of function. void printCompactTreeHook(ostream& os, const char* indent = """"); Catch print hook function and forward to function clone. void constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); Driver function to propagate constant term optimizations in test statistic.; If code Activate is sent, constant term optimization will be executed.; If code Deacivate is sent, any existing constant term optimizations will; be abanoned. If codes ConfigChange or ValueChange are sent, any existing; constant term optimizations will be redone. void optimizeCaching(); This method changes the value caching logic for all nodes that depends on any of the observables; as defined by the given dataset. When evaluating a test statistic constructed from the RooAbsReal; with a dataset the observables are guaranteed to change with every call, thus there is no point; in tracking these changes which result in a net overhead. Thus for observable-dependent nodes,; the evaluation mechanism is changed from being dependent on a 'valueDirty' flag to guaranteed evaluation.; On the dataset side, the observables objects are modified to no longer send valueDirty messages; to their client. void optimizeConstantTerms(Bool_t , Bool_t = kTRUE); Driver function to activate global constant term optimization.; If activated constant terms are found and cached with the dataset; The operation mode of cached no",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsOptTestStatistic.html:38501,optimiz,optimizations,38501,root/html532/RooAbsOptTestStatistic.html,https://root.cern,https://root.cern/root/html532/RooAbsOptTestStatistic.html,7,['optimiz'],['optimizations']
Performance,"nitialize without arguments. This is done BEFORE generating first MC event and AFTER allocating FOAM object and resetting (optionally) its internal parameters/switches. The overall operational scheme of the FOAM is the following:. This method invokes several other methods:; InitCells initializes memory storage for cells and begins exploration process from the root cell. The empty cells are allocated/filled using CellFill. The procedure Grow which loops over cells, picks up the cell with the biggest `‘driver integral’', see Computer Physics Communications 152 152 (2003) 55 for explanations, with the help of PeekMax procedure. The chosen cell is split using Divide. Subsequently, the procedure Explore called by the Divide (and by InitCells for the root cell) does the most important job in the FOAM object build-up: it performs a small MC run for each newly allocated daughter cell. Explore calculates how profitable the future split of the cell will be and defines the optimal cell division geometry with the help of Carver or Varedu procedures, for maximum weight or variance optimization respectively. All essential results of the exploration are written into the explored cell object. At the very end of the foam build-up, Finally, MakeActiveList is invoked to create a list of pointers to all active cells, for the purpose of the quick access during the MC generation. The procedure Explore employs MakeAlpha to generate random coordinates inside a given cell with the uniform distribution. The above sequence of the procedure calls is depicted in the following figure:. Definition at line 307 of file TFoam.cxx. ◆ IsA(). TClass * TFoam::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 143 of file TFoam.h. ◆ LinkCells(). void TFoam::LinkCells ; (; void ; ). virtual . Definition at line 1519 of file TFoam.cxx. ◆ MakeActiveList(). void TFoam::MakeActiveList ; (; ). virtual . Internal method used by In",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFoam.html:33351,optimiz,optimization,33351,doc/master/classTFoam.html,https://root.cern,https://root.cern/doc/master/classTFoam.html,1,['optimiz'],['optimization']
Performance,"nitializes the X system. ;  ; Int_t InitWindow (ULong_t window) override;  Creates a new window and return window number. ;  ; Atom_t InternAtom (const char *atom_name, Bool_t only_if_exist) override;  Returns the atom identifier associated with the specified ""atom_name"" string. ;  ; void IntersectRegion (Region_t rega, Region_t regb, Region_t result) override;  Computes the intersection of two regions. ;  ; Bool_t IsCmdThread () const override;  ; Bool_t IsCocoaDraw () const;  ; Bool_t IsDNDAware (Window_t win, Atom_t *typelist) override;  Checks if the Window is DND aware, and knows any of the DND formats passed in argument. ;  ; Int_t KeysymToKeycode (UInt_t keysym) override;  Converts the ""keysym"" to the appropriate keycode. ;  ; char ** ListFonts (const char *fontname, Int_t max, Int_t &count) override;  Returns list of font names matching fontname regexp, like ""-*-times-*"". ;  ; FontStruct_t LoadQueryFont (const char *font_name) override;  Provides the most common way for accessing a font: opens (loads) the specified font and returns a pointer to the appropriate FontStruct_t structure. ;  ; void LookupString (Event_t *event, char *buf, Int_t buflen, UInt_t &keysym) override;  Converts the keycode from the event structure to a key symbol (according to the modifiers specified in the event structure and the current keyboard mapping). ;  ; void LowerWindow (Window_t wid) override;  Lowers the specified window ""id"" to the bottom of the stack so that it does not obscure any sibling windows. ;  ; Bool_t MakeOpenGLContextCurrent (Handle_t ctx, Window_t windowID) override;  Makes context ctx current OpenGL context. ;  ; void MapRaised (Window_t wid) override;  Maps the window ""id"" and all of its subwindows that have had map requests on the screen and put this window on the top of of the stack of all windows. ;  ; void MapSubwindows (Window_t wid) override;  Maps all subwindows for the specified window ""id"" in top-to-bottom stacking order. ;  ; void MapWindow (Window_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGQuartz.html:19744,load,loads,19744,doc/master/classTGQuartz.html,https://root.cern,https://root.cern/doc/master/classTGQuartz.html,1,['load'],['loads']
Performance,"nition Factory.cxx:1305; TMVA::Factory::BookMethodWeightfileMethodBase * BookMethodWeightfile(DataLoader *dataloader, TMVA::Types::EMVA methodType, const TString &weightfile)Adds an already constructed method to be managed by this factory.Definition Factory.cxx:501; TMVA::Factory::fModelPersistenceBool_t fModelPersistence! option to save the trained model in xml file or using serializationDefinition Factory.h:222; TMVA::Factory::OptimizeAllMethodsstd::map< TString, Double_t > OptimizeAllMethods(TString fomType=""ROCIntegral"", TString fitType=""FitGA"")Iterates through all booked methods and sees if they use parameter tuning and if so does just that,...Definition Factory.cxx:701; TMVA::Factory::GetROCROCCurve * GetROC(DataLoader *loader, TString theMethodName, UInt_t iClass=0, Types::ETreeType type=Types::kTesting)Private method to generate a ROCCurve instance for a given method.Definition Factory.cxx:749; TMVA::Factory::EvaluateImportanceShortTH1F * EvaluateImportanceShort(DataLoader *loader, Types::EMVA theMethod, TString methodTitle, const char *theOption="""")Definition Factory.cxx:2358; TMVA::Factory::fAnalysisTypeTypes::EAnalysisType fAnalysisType! the training typeDefinition Factory.h:221; TMVA::Factory::HasMethodBool_t HasMethod(const TString &datasetname, const TString &title) constChecks whether a given method name is defined for a given dataset.Definition Factory.cxx:586; TMVA::Factory::GetROCCurveTGraph * GetROCCurve(DataLoader *loader, TString theMethodName, Bool_t setTitles=kTRUE, UInt_t iClass=0, Types::ETreeType type=Types::kTesting)Argument iClass specifies the class to generate the ROC curve in a multiclass setting.Definition Factory.cxx:912; TMVA::Factory::EvaluateImportanceAllTH1F * EvaluateImportanceAll(DataLoader *loader, Types::EMVA theMethod, TString methodTitle, const char *theOption="""")Definition Factory.cxx:2246; TMVA::Factory::SetVerbosevoid SetVerbose(Bool_t v=kTRUE)Definition Factory.cxx:343; TMVA::Factory::fgTargetFileTFile * fgTargetFile! R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html:124210,load,loader,124210,doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,1,['load'],['loader']
Performance,"nition RResultPtr.hxx:228; CPyCppyy::ExecCPYCPPYY_EXTERN bool Exec(const std::string &cmd)Definition API.cxx:446; See the Book() method for more information and this tutorial for a more complete example.; Injecting arbitrary code in the event loop with Foreach() and ForeachSlot(); Foreach() takes a callable (lambda expression, free function, functor...) and a list of columns and executes the callable on the values of those columns for each event that passes all upstream selections. It can be used to perform actions that are not already available in the interface. For example, the following snippet evaluates the root mean square of column ""x"": // Single-thread evaluation of RMS of column ""x"" using Foreach; double sumSq = 0.;; unsigned int n = 0;; df.Foreach([&sumSq, &n](double x) { ++n; sumSq += x*x; }, {""x""});; std::cout << ""rms of x: "" << std::sqrt(sumSq / n) << std::endl;; nconst Int_t nDefinition legend1.C:16; In multi-thread runs, users are responsible for the thread-safety of the expression passed to Foreach(): thread will execute the expression concurrently. The code above would need to employ some resource protection mechanism to ensure non-concurrent writing of rms; but this is probably too much head-scratch for such a simple operation.; ForeachSlot() can help in this situation. It is an alternative version of Foreach() for which the function takes an additional ""processing slot"" parameter besides the columns it should be applied to. RDataFrame guarantees that ForeachSlot() will invoke the user expression with different slot parameters for different concurrent executions (see Special helper columns: rdfentry_ and rdfslot_ for more information on the slot parameter). We can take advantage of ForeachSlot() to evaluate a thread-safe root mean square of column ""x"": // Thread-safe evaluation of RMS of column ""x"" using ForeachSlot; ROOT::EnableImplicitMT();; const unsigned int nSlots = df.GetNSlots();; std::vector<double> sumSqs(nSlots, 0.);; std::vector<unsigned i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html:68179,multi-thread,multi-thread,68179,doc/v632/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html,4,"['concurren', 'multi-thread']","['concurrently', 'multi-thread']"
Performance,"nition TCling.cxx:6989; TCling::MethodArgInfo_Nextint MethodArgInfo_Next(MethodArgInfo_t *marginfo) const finalDefinition TCling.cxx:9280; TCling::SnapshotMutexStatevoid SnapshotMutexState(ROOT::TVirtualRWMutex *mtx) finalDefinition TCling.cxx:9603; TCling::TypeInfo_PropertyLong_t TypeInfo_Property(TypeInfo_t *tinfo) const finalDefinition TCling.cxx:9396; TCling::MethodInfo_GetPrototypeconst char * MethodInfo_GetPrototype(MethodInfo_t *minfo) const finalDefinition TCling.cxx:9129; TCling::FuncTempInfo_TemplateMinReqArgsUInt_t FuncTempInfo_TemplateMinReqArgs(FuncTempInfo_t *) const finalReturn the number of required template arguments of the function template described by ft_info.Definition TCling.cxx:8860; TCling::fTemporariesstd::vector< cling::Value > * fTemporariesDefinition TCling.h:133; TCling::RegisterModulevoid RegisterModule(const char *modulename, const char **headers, const char **includePaths, const char *payloadCode, const char *fwdDeclsCode, void(*triggerFunc)(), const FwdDeclArgsToKeepCollection_t &fwdDeclsArgToSkip, const char **classesHeaders, Bool_t lateRegistration=false, Bool_t hasCxxModule=false) finalInject the module named ""modulename"" into cling; load all headers.Definition TCling.cxx:2010; TCling::ShallowAutoLoadImplstatic Int_t ShallowAutoLoadImpl(const char *cls)Definition TCling.cxx:6156; TCling::MethodInfo_CreateSignaturevoid MethodInfo_CreateSignature(MethodInfo_t *minfo, TString &signature) const finalDefinition TCling.cxx:9009; TCling::CheckClassTemplateBool_t CheckClassTemplate(const char *name) finalReturn true if there is a class template by the given name ...Definition TCling.cxx:4349; TCling::LibraryLoadedvoid LibraryLoaded(const void *dyLibHandle, const char *canonicalName)Definition TCling.cxx:6974; TCling::RegisterTClassUpdatevoid RegisterTClassUpdate(TClass *oldcl, DictFuncPtr_t dict) finalRegister classes that already existed prior to their dictionary loading and that already had a ClassI...Definition TCling.cxx:2384; TCling::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:443401,load,load,443401,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['load'],['load']
Performance,"nition TGWin32VirtualXProxy.cxx:245; valueOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void valueDefinition TGWin32VirtualXProxy.cxx:142; namechar name[80]Definition TGX11.cxx:110; TNamed.h; TObjArray.h; ROOT::v5::TFormulaThe FORMULA class (ROOT version 5)Definition TFormula.h:65; ROOT::v5::TFormula::fConstDouble_t * fConstDefinition TFormula.h:82; ROOT::v5::TFormula::Clearvoid Clear(Option_t *option="""") overrideResets the objects.Definition TFormula_v5.cxx:2212; ROOT::v5::TFormula::GetNumbervirtual Int_t GetNumber() constDefinition TFormula.h:239; ROOT::v5::TFormula::StringToNumbervirtual Bool_t StringToNumber(Int_t code)Try to 'demote' a string into an array bytes.Definition TFormula_v5.cxx:2201; ROOT::v5::TFormula::GetParameterDouble_t GetParameter(Int_t ipar) constReturn value of parameter number ipar.Definition TFormula_v5.cxx:3222; ROOT::v5::TFormula::fExprOptimizedTString * fExprOptimizedNumber of operators after optimization.Definition TFormula.h:92; ROOT::v5::TFormula::fNumberInt_t fNumberDefinition TFormula.h:75; ROOT::v5::TFormula::EvalParvirtual Double_t EvalPar(const Double_t *x, const Double_t *params=nullptr)Definition TFormula.h:235; ROOT::v5::TFormula::IsNormalizedvirtual Bool_t IsNormalized() constDefinition TFormula.h:248; ROOT::v5::TFormula::GetParametersvirtual Double_t * GetParameters() constDefinition TFormula.h:243; ROOT::v5::TFormula::DefinedValuevirtual Double_t DefinedValue(Int_t code)Return value corresponding to special code.Definition TFormula_v5.cxx:2586; ROOT::v5::TFormula::Evalvirtual Double_t Eval(Double_t x, Double_t y=0, Double_t z=0, Double_t t=0) constEvaluate this formula.Definition TFormula_v5.cxx:2668; ROOT::v5::TFormula::kLinear@ kLinearDefinition TFormula.h:214; ROOT::v5::TFormula::kNormalized@ kNormalizedDefinition TFormula.h:213; ROOT::v5::TFormula::kNotGlobal@ kNotGlobalDefinition TFormula.h:212; ROOT::v5::TFormula::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/v5_2TFormula_8h_source.html:12997,optimiz,optimization,12997,doc/master/v5_2TFormula_8h_source.html,https://root.cern,https://root.cern/doc/master/v5_2TFormula_8h_source.html,1,['optimiz'],['optimization']
Performance,"nition TProfile.h:32; TRandom::Rannorvirtual void Rannor(Float_t &a, Float_t &b)Return 2 numbers distributed following a gaussian with mean=0 and sigma=1.Definition TRandom.cxx:507; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; TMVA_SOFIE_GNN_Parser.treetreeDefinition TMVA_SOFIE_GNN_Parser.py:169. PyROOT; The TTree class has several additions for its use from Python, which are also available in its subclasses e.g. TChain and TNtuple.; First, TTree instances are iterable in Python. Therefore, assuming t is a TTree instance, we can do: for entry in t:; x = entry.branch_name; ...; At each iteration, a new entry of the tree will be read. In the code above, entry allows to access the branch values for the current entry. This can be done with the syntax entry.branch_name or, if the branch name is incompatible with Python naming rules, with e.g. ""getattr(entry, '1_branch_name')"".; Please note that iterating in Python can be slow, so only iterate over a tree as described above if performance is not an issue or when dealing with a small dataset. To read and process the entries of a tree in a much faster way, please use ROOT::RDataFrame.; Second, a couple of TTree methods have been modified to facilitate their use from Python: TTree::Branch and TTree::SetBranchAddress.; Regarding TTree::Branch, the following example shows how we can create different types of branches of a TTree. Note that Branch will just link the new branch with a given Python object, so it is still necessary to fill such object with the desired content before calling TTree::Fill. from array import array; import numpy as np; import ROOT; from ROOT import addressof; ; # Basic type branch (float) - use array of length 1; n = array('f', [ 1.5 ]); t.Branch('floatb', n, 'floatb/F'); ; # Array branch - use array of length N; N = 10; a = array('d', N*[ 0. ]); t.Branch('arrayb', a, 'arrayb[' + str(N) + ']/D'); ; # Array branch - use NumPy array of length N; npa = np.array(N*[ 0. ]); t.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTree.html:15466,perform,performance,15466,doc/v632/classTTree.html,https://root.cern,https://root.cern/doc/v632/classTTree.html,2,['perform'],['performance']
Performance,"nition TTree.h:214; TTree::SetTreeIndexvirtual void SetTreeIndex(TVirtualIndex *index)The current TreeIndex is replaced by the new index.Definition TTree.cxx:9346; TTree::OptimizeBasketsvirtual void OptimizeBaskets(ULong64_t maxMemory=10000000, Float_t minComp=1.1, Option_t *option="""")This function may be called after having filled some entries in a Tree.Definition TTree.cxx:7057; TTree::Projectvirtual Long64_t Project(const char *hname, const char *varexp, const char *selection="""", Option_t *option="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0)Make a projection of a tree using selections.Definition TTree.cxx:7498; TTree::SetCacheEntryRangevirtual Int_t SetCacheEntryRange(Long64_t first, Long64_t last)interface to TTreeCache to set the cache entry rangeDefinition TTree.cxx:8831; TTree::GetMaxTreeSizestatic Long64_t GetMaxTreeSize()Static function which returns the tree file size limit in bytes.Definition TTree.cxx:6265; TTree::fCacheDoClusterPrefetchbool fCacheDoClusterPrefetch! true if cache is prefetching whole clustersDefinition TTree.h:140; TTree::SetBranchAddressImpInt_t SetBranchAddressImp(TBranch *branch, void *addr, TBranch **ptr)Change branch address, dealing with clone trees properly.Definition TTree.cxx:8445; TTree::SetAliasvirtual bool SetAlias(const char *aliasName, const char *aliasFormula)Set a tree variable alias.Definition TTree.cxx:8141; TTree::CopyAddressesvirtual void CopyAddresses(TTree *, bool undo=false)Set branch addresses of passed tree equal to ours.Definition TTree.cxx:3299; TTree::fMaxEntriesLong64_t fMaxEntriesMaximum number of entries in case of circular buffers.Definition TTree.h:97; TTree::DropBuffersvirtual void DropBuffers(Int_t nbytes)Drop branch buffers to accommodate nbytes below MaxVirtualsize.Definition TTree.cxx:4531; TTree::GetListOfFriendsvirtual TList * GetListOfFriends() constDefinition TTree.h:530; TTree::Refreshvirtual void Refresh()Refresh contents of this tree and its branches from the current status on disk",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:460872,cache,cache,460872,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['cache'],['cache']
Performance,"nition TTree.h:570; TTree::SetTreeIndexvirtual void SetTreeIndex(TVirtualIndex *index)The current TreeIndex is replaced by the new index.Definition TTree.cxx:9346; TTree::OptimizeBasketsvirtual void OptimizeBaskets(ULong64_t maxMemory=10000000, Float_t minComp=1.1, Option_t *option="""")This function may be called after having filled some entries in a Tree.Definition TTree.cxx:7057; TTree::Projectvirtual Long64_t Project(const char *hname, const char *varexp, const char *selection="""", Option_t *option="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0)Make a projection of a tree using selections.Definition TTree.cxx:7498; TTree::SetCacheEntryRangevirtual Int_t SetCacheEntryRange(Long64_t first, Long64_t last)interface to TTreeCache to set the cache entry rangeDefinition TTree.cxx:8831; TTree::GetMaxTreeSizestatic Long64_t GetMaxTreeSize()Static function which returns the tree file size limit in bytes.Definition TTree.cxx:6265; TTree::fCacheDoClusterPrefetchbool fCacheDoClusterPrefetch! true if cache is prefetching whole clustersDefinition TTree.h:140; TTree::SetBranchAddressImpInt_t SetBranchAddressImp(TBranch *branch, void *addr, TBranch **ptr)Change branch address, dealing with clone trees properly.Definition TTree.cxx:8445; TTree::SetAliasvirtual bool SetAlias(const char *aliasName, const char *aliasFormula)Set a tree variable alias.Definition TTree.cxx:8141; TTree::GetTimerIntervalvirtual Int_t GetTimerInterval() constDefinition TTree.h:554; TTree::CopyAddressesvirtual void CopyAddresses(TTree *, bool undo=false)Set branch addresses of passed tree equal to ours.Definition TTree.cxx:3299; TTree::SetScanFieldvirtual void SetScanField(Int_t n=50)Sets the default maximum number of lines to be shown before <CR> when calling Scan().Definition TTree.h:691; TTree::TTreeTTree(const TTree &tt)=delete; TTree::fMaxEntriesLong64_t fMaxEntriesMaximum number of entries in case of circular buffers.Definition TTree.h:97; TTree::SetBranchAddressInt_t SetBranchAddress(const ch",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8h_source.html:83988,cache,cache,83988,doc/master/TTree_8h_source.html,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html,1,['cache'],['cache']
Performance,"nition at line 146 of file TStreamerElement.h. ◆ IsaPointer(). virtual Bool_t TStreamerElement::IsaPointer ; (; ); const. inlinevirtual . Reimplemented in TStreamerBasicPointer, TStreamerLoop, TStreamerObjectPointer, TStreamerObjectAnyPointer, and TStreamerSTL.; Definition at line 128 of file TStreamerElement.h. ◆ IsBase(). Bool_t TStreamerElement::IsBase ; (; ); const. virtual . Return kTRUE if the element represent a base class. ; Reimplemented in TStreamerBase, and TStreamerSTL.; Definition at line 431 of file TStreamerElement.cxx. ◆ IsOldFormat(). Bool_t TStreamerElement::IsOldFormat ; (; const char * ; newTypeName). virtual . The early 3.00/00 and 3.01/01 versions used to store dm->GetTypeName instead of dm->GetFullTypename if this case is detected, the element type name is modified. ; Definition at line 419 of file TStreamerElement.cxx. ◆ IsTransient(). Bool_t TStreamerElement::IsTransient ; (; ); const. virtual . Return kTRUE if the element represent an entity that is not written to the disk (transient members, cache allocator/deallocator, etc.) ; Definition at line 440 of file TStreamerElement.cxx. ◆ ls(). void TStreamerElement::ls ; (; Option_t * ; option = """"); const. overridevirtual . Print the content of the element. ; Reimplemented from TNamed.; Reimplemented in TStreamerSTL.; Definition at line 458 of file TStreamerElement.cxx. ◆ operator=(). TStreamerElement & TStreamerElement::operator= ; (; const TStreamerElement & ; ). privatedelete . ◆ SetArrayDim(). void TStreamerElement::SetArrayDim ; (; Int_t ; dim). virtual . Set number of array dimensions. ; Reimplemented in TStreamerBasicPointer, TStreamerObjectPointer, and TStreamerObjectAnyPointer.; Definition at line 480 of file TStreamerElement.cxx. ◆ SetMaxIndex(). void TStreamerElement::SetMaxIndex ; (; Int_t ; dim, . Int_t ; max . ). virtual . set maximum index for array with dimension dim ; Definition at line 490 of file TStreamerElement.cxx. ◆ SetNewClass(). virtual void TStreamerElement::SetNewClas",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTStreamerElement.html:24787,cache,cache,24787,doc/master/classTStreamerElement.html,https://root.cern,https://root.cern/doc/master/classTStreamerElement.html,1,['cache'],['cache']
Performance,"nition at line 313 of file TGeoNavigator.cxx. ◆ CdDown() [2/2]. void TGeoNavigator::CdDown ; (; TGeoNode * ; node). Make a daughter of current node current. ; Can be called only with a valid daughter node (no check). Updates cache accordingly. ; Definition at line 333 of file TGeoNavigator.cxx. ◆ CdNext(). void TGeoNavigator::CdNext ; (; ). Do a cd to the node found next by FindNextBoundary. ; Definition at line 405 of file TGeoNavigator.cxx. ◆ CdNode(). void TGeoNavigator::CdNode ; (; Int_t ; nodeid). Change current path to point to the node having this id. ; Node id has to be in range : 0 to fNNodes-1 (no check for performance reasons) ; Definition at line 301 of file TGeoNavigator.cxx. ◆ CdTop(). void TGeoNavigator::CdTop ; (; ). Make top level node the current node. ; Updates the cache accordingly. Determine the overlapping state of current node. ; Definition at line 386 of file TGeoNavigator.cxx. ◆ CdUp(). void TGeoNavigator::CdUp ; (; ). Go one level up in geometry. ; Updates cache accordingly. Determine the overlapping state of current node. ; Definition at line 352 of file TGeoNavigator.cxx. ◆ CheckPath(). Bool_t TGeoNavigator::CheckPath ; (; const char * ; path); const. Check if a geometry path is valid without changing the state of the navigator. ; Definition at line 256 of file TGeoNavigator.cxx. ◆ Class(). static TClass * TGeoNavigator::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TGeoNavigator::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TGeoNavigator::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 282 of file TGeoNavigator.h. ◆ CrossBoundaryAndLocate(). TGeoNode * TGeoNavigator::CrossBoundaryAndLocate ; (; Bool_t ; downwards, . TGeoNode * ; skipnode . ). Cross next boundary and locate within current node The current point must be on the boundary of fCurrentNode. ; Definition at line 523 of file TG",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoNavigator.html:24698,cache,cache,24698,doc/master/classTGeoNavigator.html,https://root.cern,https://root.cern/doc/master/classTGeoNavigator.html,1,['cache'],['cache']
Performance,"nition at line 460 of file RGeomData.cxx. ◆ BuildDescription(). void RGeomDescription::BuildDescription ; (; TGeoNode * ; topnode, . TGeoVolume * ; topvolume . ). private . Build geometry description. ; Definition at line 494 of file RGeomData.cxx. ◆ ChangeConfiguration(). bool RGeomDescription::ChangeConfiguration ; (; const std::string & ; json). Change configuration by client Returns true if any parameter was really changed. ; Definition at line 2105 of file RGeomData.cxx. ◆ ChangeNodeVisibility(). bool RGeomDescription::ChangeNodeVisibility ; (; const std::vector< std::string > & ; path, . bool ; on . ). Change visibility for specified element Returns true if changes was performed. ; Definition at line 1850 of file RGeomData.cxx. ◆ ClearAllPhysVisibility(). bool RGeomDescription::ClearAllPhysVisibility ; (; ). Reset all custom visibility settings. ; Definition at line 2089 of file RGeomData.cxx. ◆ ClearCache(). void RGeomDescription::ClearCache ; (; ). Clear cached data, need to be clear when connection broken. ; Definition at line 1381 of file RGeomData.cxx. ◆ ClearDescription(). void RGeomDescription::ClearDescription ; (; ). private . Clear geometry description. ; Definition at line 478 of file RGeomData.cxx. ◆ ClearDrawData(). void RGeomDescription::ClearDrawData ; (; ). Clear raw data. Will be rebuild when next connection will be established. ; Definition at line 1370 of file RGeomData.cxx. ◆ ClearPhysNodeVisibility(). bool RGeomDescription::ClearPhysNodeVisibility ; (; const std::vector< std::string > & ; path). Reset custom visibility of physical node by path. ; Definition at line 2065 of file RGeomData.cxx. ◆ CollectNodes(). void RGeomDescription::CollectNodes ; (; RGeomDrawing & ; drawing, . bool ; all_nodes = false . ). private . Collect nodes which are used in visibles. ; Definition at line 721 of file RGeomData.cxx. ◆ CopyMaterialProperties(). void RGeomDescription::CopyMaterialProperties ; (; TGeoVolume * ; vol, . RGeomNode & ; node . ). private . C",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RGeomDescription.html:12762,cache,cached,12762,doc/v632/classROOT_1_1RGeomDescription.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RGeomDescription.html,2,['cache'],['cached']
Performance,"nition of observables. ;  ; virtual void optimizeCacheMode (const RooArgSet &observables, RooArgSet &optNodes, RooLinkedList &processedNodes);  Activate cache mode optimization with given definition of observables. ;  ; bool findConstantNodes (const RooArgSet &observables, RooArgSet &cacheList);  Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; bool findConstantNodes (const RooArgSet &observables, RooArgSet &cacheList, RooLinkedList &processedNodes);  Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; virtual void constOptimizeTestStatistic (ConstOpCode opcode, bool doAlsoTrackingOpt=true);  Interface function signaling a request to perform constant term optimization. ;  ; bool isShapeDirty () const;  ; bool isValueDirty () const;  ; bool isValueDirtyAndClear () const;  ; bool isValueOrShapeDirtyAndClear () const;  ; void registerCache (RooAbsCache &cache);  Register RooAbsCache with this object. ;  ; void unRegisterCache (RooAbsCache &cache);  Unregister a RooAbsCache. Called from the RooAbsCache destructor. ;  ; Int_t numCaches () const;  Return number of registered caches. ;  ; RooAbsCache * getCache (Int_t index) const;  Return registered cache object by index. ;  ; OperMode operMode () const;  Query the operation mode of this node. ;  ; void setOperMode (OperMode mode, bool recurseADirty=true);  Set the operation mode of this node. ;  ; void setValueDirty ();  Mark the element dirty. This forces a re-evaluation when a value is requested. ;  ; void setShapeDirty ();  Notify that a shape-like property (e.g. binning) has changed. ;  ; const char * aggregateCacheUniqueSuffix () const;  ; virtual const char * cacheUniqueSuffix () const;  ; void wireAllCaches ();  ; RooExpensiveObjectCache & expensiveObjectCache () const;  ; virtual void setExpensiveObjectCache (R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAddPdf.html:49111,cache,cache,49111,doc/v632/classRooAddPdf.html,https://root.cern,https://root.cern/doc/v632/classRooAddPdf.html,9,['cache'],['cache']
Performance,"nition of the TRef data member in the original class, do:; TRef fRef; //EXEC:execName. points to something; When the special keyword ""EXEC:"" is found in the comment field of the member,; the next string is assumed to be the name of a TExec object.; When a file is connected, the dictionary of the classes on the file; is read in memory (see TFile::ReadStreamerInfo). When the TStreamerElement; object is read, a TExec object is automatically created with the name; specified after the keywork ""EXEC:"" in case a TExec with a same name does; not already exist.; The action to be executed via this TExec can be specified with:; - a call to the TExec constructor, if the constructor is called before; opening the file.; - a call to TExec::SetAction at any time.; One can compute a pointer to an existing TExec with a name with:; TExec *myExec = gROOT->GetExec(execName);; myExec->SetAction(actionCommand); where; - actionCommand is a string containing a CINT instruction. Examples:; myExec->SetAction(""LoadHits()"");; myExec->SetAction("".x script.C"");. When a TRef is dereferenced via TRef::GetObject, its TExec will be; automatically executed. In the function/script being executed, one or more; of the following actions can be executed:; - load a file containing the referenced object. This function typically; looks in the file catalog (GRID).; - compute a pointer to the referenced object and communicate this pointer; back to the calling function TRef::GetObject via:; TRef::SetStaticObject(object).; When the TExec is called, it has access to the dereferencing TRef; by calling GetStaticObject() (TRef::GetObject() sets fgObject to ""this""; before the call to TExec). This can be useful for accessing the TRef's; fUniqueID.; As soon as an object is returned to GetObject, the fUniqueID of the TRef is set; to the fUniqueID of the referenced object. At the next call to GetObject,; the pointer stored in fPid:fObjects[fUniqueID] will be returned directly. An example of action on demand is shown in $R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TRef.html:6149,Load,LoadHits,6149,root/html532/TRef.html,https://root.cern,https://root.cern/root/html532/TRef.html,4,['Load'],['LoadHits']
Performance,"nizing the remote server (if an old rootd the TNetFile's Create; method will be called). The options field of the URL can be used for the following purposes:; a. open a non-ROOT generic file; ""root://server1:port1[,server2:port2,...]/pathfile?filetype=raw""; b. re-check the environment variables; ""root://server1:port1[,server2:port2,...]/pathfile?checkenv""; c. set the cache size (in bytes); ""root://server1:port1[,server2:port2,...]/pathfile?cachesz=20000000""; d. set the read-ahead size (in bytes); ""root://server1:port1[,server2:port2,...]/pathfile?readaheadsz=100000""; e. set the cache remove policy; ""root://server1:port1[,server2:port2,...]/pathfile?rmpolicy=1""; f. set the max number of redirections; ""root://server1:port1[,server2:port2,...]/pathfile?mxredir=2""; (multiple options can be set concurrently). ~TXNetFile(); Destructor. void FormUrl(TUrl uut, TString& uu); Form url for rootd socket. Int_t ParseOptions(const char* opts, Int_t& cachesz, Int_t& readaheadsz, Int_t& rmpolicy, Int_t& mxredir, Int_t& rastrategy, Int_t& readtrimblksz); Parse input options for cache parameters. void CreateXClient(const char* url, Option_t* option, Int_t netopt, Bool_t parallelopen); The real creation work is done here. Int_t GetRootdProtocol(TSocket* s); Find out the remote rootd protocol version.; Returns -1 in case of error. Bool_t Open(Option_t* option, Bool_t parallelopen); The real creation work is done here. Bool_t ReadBuffer(char* buf, Int_t len); Override TNetFile::ReadBuffer to deal with the xrootd server.; Returns kTRUE in case of errors. Bool_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Pass through to TNetFile implementation which will call back eventually; to our ReadBuffer with 2 arguments to deal with xrootd errors. Bool_t ReadBufferAsync(Long64_t offs, Int_t len); Implementation dealing with the xrootd server.; Returns kTRUE in case of errors.; This is the same as TXNetFile::ReadBuffer but using the async; call from xrootd. Bool_t ReadBuffers(char* buf, Long64_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TXNetFile.html:25994,cache,cachesz,25994,root/html528/TXNetFile.html,https://root.cern,https://root.cern/root/html528/TXNetFile.html,20,['cache'],"['cache', 'cachesz']"
Performance,"nk you for clarifying a . Thank you for clarifying a transition plan, it is quite a reasonable approach. I just want to add a personal request to your wish list. Would it be possible to improve IO speed for reading? Very often analysis code is constrained by CPU/disk access limits when reading ntuples. The speed varies from ~100kHz for a tree with few float branches to ~200 Hz for complex data structure. A factor of few improvement for complex data can be a difference between requiring just one machine or a small farm. Submitted by Anonymous (not verified) on Thu, 07/23/2015 - 21:51 Permalink . Re: I/O Performance . Hi ROOT User,; We have dramatically improved the I/O performance over the last two years. If you use the latest production release also for writing data you might be able to see a performance improvement of an order of magnitude compared to e.g. 5.26, both in real and CPU time! See e.g. this blog entry.; We have been comparing the performance of ROOT I/O with competitors like Google ProtoBuf; we know exactly where we spend extra time and why, e.g. for schema evolution, proper C++ type support, introspection, pointers.; On the other hand, are you sure you make use of all the performance features ROOT offers? Did you enable the tree cache (on by default for PROOF and one tree per file, off - for now, still - otherwise)? Do you only read the branches you need? I am working on a new TTree read access class that should simplify all of that considerably (and is type safe - no more void*&!); maybe I should take your comment as an invitation to speed up :-); Cheers, Axel. Submitted by Anonymous (not verified) on Thu, 07/23/2015 - 21:51 Permalink . Re: Interpreters . Hi ROOT user,; Thanks for your comments - they are excellent!; Your scenario would probably work - but we decided against it, and I believe that we have good reasons for that :-); GCCXML's future is limited; there is a re-write based on GCC's plugin mechanism, but both suffer from the same problems: w",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/blog/do-we-need-yet-another-custom-c-interpreter.html:15529,perform,performance,15529,d/blog/do-we-need-yet-another-custom-c-interpreter.html,https://root.cern,https://root.cern/d/blog/do-we-need-yet-another-custom-c-interpreter.html,1,['perform'],['performance']
Performance,"nline . Definition at line 216 of file TTreeFormula.h. ◆ StringToNumber(). bool TTreeFormula::StringToNumber ; (; Int_t ; oper). overrideprotectedvirtual . Try to 'demote' a string into an array bytes. ; If this is not possible, return false. ; Reimplemented from ROOT::v5::TFormula.; Definition at line 5078 of file TTreeFormula.cxx. ◆ SwitchToFormLeafInfo(). bool TTreeFormula::SwitchToFormLeafInfo ; (; Int_t ; code). protectedvirtual . Convert the underlying lookup method from the direct technique (dereferencing the address held by the branch) to the method using TFormLeafInfo. ; This is in particular useful in the case where we need to append an additional TFormLeafInfo (for example to call a method). Return false if the switch was unsuccessful (basically in the case of an old style split tree). ; Definition at line 5714 of file TTreeFormula.cxx. ◆ UpdateFormulaLeaves(). void TTreeFormula::UpdateFormulaLeaves ; (; ). virtual . This function is called TTreePlayer::UpdateFormulaLeaves, itself called by TChain::LoadTree when a new Tree is loaded. ; Because Trees in a TChain may have a different list of leaves, one must update the leaves numbers in the TTreeFormula used by the TreePlayer.; A safer alternative would be to recompile the whole thing .... However currently compile HAS TO be called from the constructor! ; Definition at line 5107 of file TTreeFormula.cxx. Friends And Related Symbol Documentation. ◆ TTreeFormulaManager. friend class TTreeFormulaManager. friend . Definition at line 60 of file TTreeFormula.h. Member Data Documentation. ◆ fAliases. TObjArray TTreeFormula::fAliases. protected . ! List of TTreeFormula for each alias used. ; Definition at line 107 of file TTreeFormula.h. ◆ fAliasesUsed. std::vector<std::string> TTreeFormula::fAliasesUsed. protected . ! List of aliases used during the parsing of the expression. ; Definition at line 128 of file TTreeFormula.h. ◆ fAxis. TAxis* TTreeFormula::fAxis. protected . ! pointer to histogram axis if this is a st",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeFormula.html:50550,load,loaded,50550,doc/master/classTTreeFormula.html,https://root.cern,https://root.cern/doc/master/classTTreeFormula.html,1,['load'],['loaded']
Performance,"nline . create the solver from the type and size of number of fitting points and number of parameters ; Definition at line 285 of file GSLMultiRootSolver.h. ◆ GetDx(). gsl_vector * ROOT::Math::GSLMultiRootDerivSolver::GetDx ; (; ); const. inlineoverridevirtual . return function steps ; Implements ROOT::Math::GSLMultiRootBaseSolver.; Definition at line 343 of file GSLMultiRootSolver.h. ◆ GetF(). gsl_vector * ROOT::Math::GSLMultiRootDerivSolver::GetF ; (; ); const. inlineoverridevirtual . return function values ; Implements ROOT::Math::GSLMultiRootBaseSolver.; Definition at line 337 of file GSLMultiRootSolver.h. ◆ GetRoot(). gsl_vector * ROOT::Math::GSLMultiRootDerivSolver::GetRoot ; (; ); const. inlineoverridevirtual . solution values at the current iteration ; Implements ROOT::Math::GSLMultiRootBaseSolver.; Definition at line 331 of file GSLMultiRootSolver.h. ◆ Iterate(). int ROOT::Math::GSLMultiRootDerivSolver::Iterate ; (; ). inlineoverridevirtual . perform an iteration ; Implements ROOT::Math::GSLMultiRootBaseSolver.; Definition at line 325 of file GSLMultiRootSolver.h. ◆ Name(). const std::string & ROOT::Math::GSLMultiRootDerivSolver::Name ; (; ); const. inlineoverridevirtual . return name ; Implements ROOT::Math::GSLMultiRootBaseSolver.; Definition at line 321 of file GSLMultiRootSolver.h. ◆ operator=() [1/2]. GSLMultiRootDerivSolver & ROOT::Math::GSLMultiRootDerivSolver::operator= ; (; const GSLMultiRootDerivSolver & ; rhs). delete . ◆ operator=() [2/2]. GSLMultiRootDerivSolver & ROOT::Math::GSLMultiRootDerivSolver::operator= ; (; GSLMultiRootDerivSolver && ; rhs). delete . ◆ SetSolver(). int ROOT::Math::GSLMultiRootDerivSolver::SetSolver ; (; const std::vector< ROOT::Math::IMultiGenFunction * > & ; funcVec, . const double * ; x . ). inlineoverridevirtual . set the solver parameters for the case of derivative ; Implements ROOT::Math::GSLMultiRootBaseSolver.; Definition at line 296 of file GSLMultiRootSolver.h. Member Data Documentation. ◆ fDerivFunctions. GSLM",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1GSLMultiRootDerivSolver.html:4835,perform,perform,4835,doc/master/classROOT_1_1Math_1_1GSLMultiRootDerivSolver.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1GSLMultiRootDerivSolver.html,1,['perform'],['perform']
Performance,"nlinevirtual . Reimplemented in TRint.; Definition at line 116 of file TApplication.h. ◆ Help(). void TApplication::Help ; (; const char * ; line). protectedvirtual . The function lists useful commands ("".help"") or opens the online reference guide, generated with Doxygen ("".help scope"" or "".help scope::member""). ; NoteYou can use "".?"" as the short version of "".help"" ; Parameters. [in]linecommand from the command line . Definition at line 1208 of file TApplication.cxx. ◆ Hide(). virtual void TApplication::Hide ; (; ). inlinevirtual . Definition at line 130 of file TApplication.h. ◆ Iconify(). virtual void TApplication::Iconify ; (; ). inlinevirtual . Definition at line 131 of file TApplication.h. ◆ Init(). virtual void TApplication::Init ; (; ). inlinevirtual . Definition at line 117 of file TApplication.h. ◆ InitializeGraphics(). void TApplication::InitializeGraphics ; (; Bool_t ; only_web = kFALSE). Initialize the graphics environment. ; IfParameters. only_webis specified, only web-related part of graphics is loaded . Definition at line 244 of file TApplication.cxx. ◆ InputFiles(). TObjArray * TApplication::InputFiles ; (; ); const. inline . Definition at line 146 of file TApplication.h. ◆ IsA(). TClass * TApplication::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Reimplemented in TRint, TGApplication, TApplicationRemote, TApplicationServer, TProofServ, and TProofServLite.; Definition at line 167 of file TApplication.h. ◆ IsCmdThread(). virtual Bool_t TApplication::IsCmdThread ; (; ). inlinevirtual . Definition at line 135 of file TApplication.h. ◆ IsRunning(). Bool_t TApplication::IsRunning ; (; ); const. inline . Definition at line 152 of file TApplication.h. ◆ KeyPressed(). void TApplication::KeyPressed ; (; Int_t ; key). virtual . Emit signal when console keyboard key was pressed. ; Definition at line 1949 of file TApplication.cxx. ◆ LineProcessed(). void TApplication::LineProcessed ; (; const ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTApplication.html:29818,load,loaded,29818,doc/master/classTApplication.html,https://root.cern,https://root.cern/doc/master/classTApplication.html,1,['load'],['loaded']
Performance,"nlinks files only,; 4700 // if there is a symbolic link with '.ROOT.cachefile' for safety ;-); 4701 ; 4702 TString cmd;; 4703#if defined(R__WIN32); 4704 cmd = ""echo <TFile::ShrinkCacheFileDir>: cleanup to be implemented"";; 4705#elif defined(R__MACOSX); 4706 cmd.Form(""perl -e 'my $cachepath = \""%s\""; my $cachesize = %lld;my $findcommand=\""find $cachepath -type f -exec stat -f \\\""\\%%a::\\%%N::\\%%z\\\"" \\{\\} \\\\\\;\"";my $totalsize=0;open FIND, \""$findcommand | sort -k 1 |\"";while (<FIND>) { my ($accesstime, $filename, $filesize) = split \""::\"",$_; $totalsize += $filesize;if ($totalsize > $cachesize) {if ( ( -e \""${filename}.ROOT.cachefile\"" ) || ( -e \""${filename}\"" ) ) {unlink \""$filename.ROOT.cachefile\"";unlink \""$filename\"";}}}close FIND;' "", fgCacheFileDir.Data(),shrinksize);; 4707#else; 4708 cmd.Form(""perl -e 'my $cachepath = \""%s\""; my $cachesize = %lld;my $findcommand=\""find $cachepath -type f -exec stat -c \\\""\\%%x::\\%%n::\\%%s\\\"" \\{\\} \\\\\\;\"";my $totalsize=0;open FIND, \""$findcommand | sort -k 1 |\"";while (<FIND>) { my ($accesstime, $filename, $filesize) = split \""::\"",$_; $totalsize += $filesize;if ($totalsize > $cachesize) {if ( ( -e \""${filename}.ROOT.cachefile\"" ) || ( -e \""${filename}\"" ) ) {unlink \""$filename.ROOT.cachefile\"";unlink \""$filename\"";}}}close FIND;' "", fgCacheFileDir.Data(),shrinksize);; 4709#endif; 4710 ; 4711 tagfile->WriteBuffer(cmd, 4096);; 4712 delete tagfile;; 4713 ; 4714 if ((gSystem->Exec(cmd)) != 0) {; 4715 ::Error(""TFile::ShrinkCacheFileDir"", ""error executing clean-up script"");; 4716 return kFALSE;; 4717 }; 4718 ; 4719 return kTRUE;; 4720}; 4721 ; 4722////////////////////////////////////////////////////////////////////////////////; 4723/// Sets open timeout time (in ms). Returns previous timeout value.; 4724 ; 4725UInt_t TFile::SetOpenTimeout(UInt_t timeout); 4726{; 4727 UInt_t to = fgOpenTimeout;; 4728 fgOpenTimeout = timeout;; 4729 return to;; 4730}; 4731 ; 4732/////////////////////////////////////////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:172686,cache,cachepath,172686,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,4,['cache'],"['cachepath', 'cachesize']"
Performance,"nll(); virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t scaleFactor = 1.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooProfileLL.html:18233,optimiz,optimizeCacheMode,18233,root/html526/RooProfileLL.html,https://root.cern,https://root.cern/root/html526/RooProfileLL.html,2,['optimiz'],['optimizeCacheMode']
Performance,"nly for UNIX. ;  ; virtual void SetDynamicPath (const char *pathname);  Set the dynamic path to a new value. ;  ; virtual void Setenv (const char *name, const char *value);  Set environment variable. ;  ; void SetErrorStr (const char *errstr);  Set the system error string. ;  ; virtual void SetFlagsDebug (const char *);  FlagsDebug should contain the options to pass to the C++ compiler in order to compile the library in debug mode. ;  ; virtual void SetFlagsOpt (const char *);  FlagsOpt should contain the options to pass to the C++ compiler in order to compile the library in optimized mode. ;  ; virtual Int_t SetFPEMask (Int_t mask=kDefaultMask);  Set which conditions trigger a floating point exception. ;  ; virtual void SetIncludePath (const char *includePath);  IncludePath should contain the list of compiler flags to indicate where to find user defined header files. ;  ; virtual void SetLinkdefSuffix (const char *suffix);  The 'suffix' will be appended to the name of a script loaded by ACLiC and used to locate any eventual additional linkdef information that ACLiC should used to produce the dictionary. ;  ; virtual void SetLinkedLibs (const char *linkedLibs);  LinkedLibs should contain the library directory and list of libraries needed to recreate the current executable. ;  ; virtual void SetMakeExe (const char *directives);  Directives has the same syntax as the argument of SetMakeSharedLib but is used to create an executable. ;  ; virtual void SetMakeSharedLib (const char *directives);  Directives should contain the description on how to compile and link a shared lib. ;  ; virtual void SetObjExt (const char *objExt);  Set object files extension, should be either .o, .obj, etc. ;  ; virtual void SetProgname (const char *name);  Set the application name (from command line, argv[0]) and copy it in gProgName. ;  ; virtual int SetSockOpt (int sock, int kind, int val);  Set socket option. ;  ; virtual void SetSoExt (const char *soExt);  Set shared library extension, sh",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDavixSystem.html:17022,load,loaded,17022,doc/master/classTDavixSystem.html,https://root.cern,https://root.cern/doc/master/classTDavixSystem.html,6,['load'],['loaded']
Performance,"nnection will try to connect to the first server:port; and if that does not succeed, it will try the second one, and so on; until it finds a server that will respond. See the TNetFile documentation for the description of the other arguments. The creation consists of internal variable settings (most important is; the client's domain), creation of a TXUrl array containing all specified; urls (a single url is serverX:portX/pathfile), trying to connect to the; servers calling Connect() method, getting a valid access to the remote; server the client is connected to using GetAccessToSrv() method,; recognizing the remote server (if an old rootd the TNetFile's Create; method will be called). The options field of the URL can be used for the following purposes:; a. open a non-ROOT generic file; ""root://server1:port1[,server2:port2,...]/pathfile?filetype=raw""; b. re-check the environment variables; ""root://server1:port1[,server2:port2,...]/pathfile?checkenv""; c. set the cache size (in bytes); ""root://server1:port1[,server2:port2,...]/pathfile?cachesz=20000000""; d. set the read-ahead size (in bytes); ""root://server1:port1[,server2:port2,...]/pathfile?readaheadsz=100000""; e. set the cache remove policy; ""root://server1:port1[,server2:port2,...]/pathfile?rmpolicy=1""; f. set the max number of redirections; ""root://server1:port1[,server2:port2,...]/pathfile?mxredir=2""; (multiple options can be set concurrently). ~TXNetFile(); Destructor. void FormUrl(TUrl uut, TString& uu); Form url for rootd socket. Int_t ParseOptions(const char* opts, Int_t& cachesz, Int_t& readaheadsz, Int_t& rmpolicy, Int_t& mxredir, Int_t& rastrategy, Int_t& readtrimblksz); Parse input options for cache parameters. void CreateXClient(const char* url, Option_t* option, Int_t netopt, Bool_t parallelopen); The real creation work is done here. Int_t GetRootdProtocol(TSocket* s); Find out the remote rootd protocol version.; Returns -1 in case of error. Bool_t Open(Option_t* option, Bool_t parallelopen); The real cr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TXNetFile.html:25414,cache,cache,25414,root/html528/TXNetFile.html,https://root.cern,https://root.cern/root/html528/TXNetFile.html,10,['cache'],['cache']
Performance,"nnection(int sock, Bool_t force = kFALSE); Close socket connection. int RecvRaw(int sock, void* buffer, int length, int flag); Receive exactly length bytes into buffer. Use opt to receive out-of-band; data or to have a peek at what is in the buffer (see TSocket). int SendRaw(int sock, const void* buffer, int length, int flag); Send exactly length bytes from buffer. Use opt to send out-of-band; data (see TSocket). int RecvBuf(int sock, void* buffer, int length); Receive a buffer headed by a length indicator. int SendBuf(int sock, const void* buffer, int length); Send a buffer headed by a length indicator. int SetSockOpt(int sock, int kind, int val); Set socket option. int GetSockOpt(int sock, int kind, int* val); Get socket option. int GetSysInfo(SysInfo_t* info) const; Returns static system info, like OS type, CPU type, number of CPUs; RAM size, etc into the SysInfo_t structure. Returns -1 in case of error,; 0 otherwise. int GetCpuInfo(CpuInfo_t* info, Int_t sampleTime = 1000) const; Returns cpu load average and load info into the CpuInfo_t structure.; Returns -1 in case of error, 0 otherwise. Use sampleTime to set the; interval over which the CPU load will be measured, in ms (default 1000). int GetMemInfo(MemInfo_t* info) const; Returns ram and swap memory usage info into the MemInfo_t structure.; Returns -1 in case of error, 0 otherwise. int GetProcInfo(ProcInfo_t* info) const; Returns cpu and memory used by this process into the ProcInfo_t structure.; Returns -1 in case of error, 0 otherwise. int CompileMacro(const char* filename, Option_t* opt = """", const char* library_name = """", const char* build_dir = """", UInt_t dirmode = 0); This method compiles and loads a shared library containing; the code from the file ""filename"". The possible options are:; k : keep the shared library after the session end.; f : force recompilation.; g : compile with debug symbol; O : optimized the code (ignore if 'g' is specified); c : compile only, do not attempt to load the library.; - ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSystem.html:36838,load,load,36838,root/html528/TSystem.html,https://root.cern,https://root.cern/root/html528/TSystem.html,2,['load'],['load']
Performance,"nnection(int sock, Bool_t force = kFALSE); Close socket connection. int RecvRaw(int sock, void* buffer, int length, int flag); Receive exactly length bytes into buffer. Use opt to receive out-of-band; data or to have a peek at what is in the buffer (see TSocket). int SendRaw(int sock, const void* buffer, int length, int flag); Send exactly length bytes from buffer. Use opt to send out-of-band; data (see TSocket). int RecvBuf(int sock, void* buffer, int length); Receive a buffer headed by a length indicator. int SendBuf(int sock, const void* buffer, int length); Send a buffer headed by a length indicator. int SetSockOpt(int sock, int kind, int val); Set socket option. int GetSockOpt(int sock, int kind, int* val); Get socket option. int GetSysInfo(SysInfo_t* info) const; Returns static system info, like OS type, CPU type, number of CPUs; RAM size, etc into the SysInfo_t structure. Returns -1 in case of error,; 0 otherwise. int GetCpuInfo(CpuInfo_t* info, Int_t sampleTime = 1000) const; Returns cpu load average and load info into the CpuInfo_t structure.; Returns -1 in case of error, 0 otherwise. Use sampleTime to set the; interval over which the CPU load will be measured, in ms (default 1000). int GetMemInfo(MemInfo_t* info) const; Returns ram and swap memory usage info into the MemInfo_t structure.; Returns -1 in case of error, 0 otherwise. int GetProcInfo(ProcInfo_t* info) const; Returns cpu and memory used by this process into the ProcInfo_t structure.; Returns -1 in case of error, 0 otherwise. int CompileMacro(const char* filename, Option_t* opt = """", const char* library_name = """", const char* build_dir = """", UInt_t dirmode = 0); This method compiles and loads a shared library containing; the code from the file ""filename"". The return value is true (1) in case of success and false (0); in case of error. The possible options are:; k : keep the shared library after the session end.; f : force recompilation.; g : compile with debug symbol; O : optimized the code (ignor",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TSystem.html:36907,load,load,36907,root/html530/TSystem.html,https://root.cern,https://root.cern/root/html530/TSystem.html,10,['load'],['load']
Performance,"nnection(int sock, Bool_t force = kFALSE); Close socket connection. int RecvRaw(int sock, void* buffer, int length, int flag); Receive exactly length bytes into buffer. Use opt to receive out-of-band; data or to have a peek at what is in the buffer (see TSocket). int SendRaw(int sock, const void* buffer, int length, int flag); Send exactly length bytes from buffer. Use opt to send out-of-band; data (see TSocket). int RecvBuf(int sock, void* buffer, int length); Receive a buffer headed by a length indicator. int SendBuf(int sock, const void* buffer, int length); Send a buffer headed by a length indicator. int SetSockOpt(int sock, int kind, int val); Set socket option. int GetSockOpt(int sock, int kind, int* val); Get socket option. int GetSysInfo(SysInfo_t* info) const; Returns static system info, like OS type, CPU type, number of CPUs; RAM size, etc into the SysInfo_t structure. Returns -1 in case of error,; 0 otherwise. int GetCpuInfo(CpuInfo_t* info, Int_t sampleTime = 1000) const; Returns cpu load average and load info into the CpuInfo_t structure.; Returns -1 in case of error, 0 otherwise. Use sampleTime to set the; interval over which the CPU load will be measured, in ms (default 1000). int GetMemInfo(MemInfo_t* info) const; Returns ram and swap memory usage info into the MemInfo_t structure.; Returns -1 in case of error, 0 otherwise. int GetProcInfo(ProcInfo_t* info) const; Returns cpu and memory used by this process into the ProcInfo_t structure.; Returns -1 in case of error, 0 otherwise. int CompileMacro(const char* filename, Option_t* opt = """", const char* library_name = """", const char* build_dir = """", UInt_t dirmode = 0); This method compiles and loads a shared library containing; the code from the file ""filename"". The return value is true (1) in case of success and false (0); in case of error. The possible options are:; k : keep the shared library after the session end.; f : force recompilation.; g : compile with debug symbol; O : optimized the code; c : c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSystem.html:38518,load,load,38518,root/html602/TSystem.html,https://root.cern,https://root.cern/root/html602/TSystem.html,8,['load'],['load']
Performance,"nning*_binning! Pointer to default binning definition; set<string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooErrorVar.html:39389,cache,cache,39389,root/html602/RooErrorVar.html,https://root.cern,https://root.cern/root/html602/RooErrorVar.html,14,"['Cache', 'cache']","['Cached', 'cache']"
Performance,"no partition cell number. TH2Poly(const char* name, const char* title, Int_t nX, Double_t xlow, Double_t xup, Int_t nY, Double_t ylow, Double_t yup); Constructor with specified name and boundaries and partition cell number. ~TH2Poly(); Destructor. Int_t AddBin(TObject* poly); Adds a new bin to the histogram. It can be any object having the method; IsInside(). It returns the bin number in the histogram. It returns 0 if; it failed to add. To allow the histogram limits to expand when a bin; outside the limits is added, call SetFloat() before adding the bin. Int_t AddBin(Int_t n, const Double_t* x, const Double_t* y); Adds a new bin to the histogram. The number of vertices and their (x,y); coordinates are required as input. It returns the bin number in the; histogram. Int_t AddBin(Double_t x1, Double_t y1, Double_t x2, Double_t y2); Add a new bin to the histogram. The bin shape is a rectangle.; It returns the bin number of the bin in the histogram. Bool_t Add(const TH1* h1, Double_t c1); Performs the operation: this = this + c1*h1. Bool_t Add(TF1* h1, Double_t c1 = 1, Option_t* option = """"); Performs the operation: this = this + c1*f1. Bool_t Add(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1); Replace contents of this histogram by the addition of h1 and h2. void AddBinToPartition(TH2PolyBin* bin); Adds the input bin into the partition cell matrix. This method is called; in AddBin() and ChangePartition(). void ChangePartition(Int_t n, Int_t m); Changes the number of partition cells in the histogram.; Deletes the old partition and constructs a new one. TObject* Clone(const char* newname = """") const; Make a complete copy of the underlying object. If 'newname' is set,; the copy's name will be set to that name. void ClearBinContents(); Clears the contents of all bins in the histogram. void Reset(Option_t* option); Reset this histogram: contents, errors, etc. Int_t FindBin(Double_t x, Double_t y, Double_t z = 0); Returns the bin number of the bin at the given ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TH2Poly.html:35026,Perform,Performs,35026,root/html602/TH2Poly.html,https://root.cern,https://root.cern/root/html602/TH2Poly.html,2,['Perform'],['Performs']
Performance,"no partition cell number. TH2Poly(const char* name, const char* title, Int_t nX, Double_t xlow, Double_t xup, Int_t nY, Double_t ylow, Double_t yup); Constructor with specified name and boundaries and partition cell number. ~TH2Poly(); Destructor. Int_t AddBin(TObject* poly); Adds a new bin to the histogram. It can be any object having the method; IsInside(). It returns the bin number in the histogram. It returns 0 if; it failed to add. To allow the histogram limits to expand when a bin; outside the limits is added, call SetFloat() before adding the bin. Int_t AddBin(Int_t n, const Double_t* x, const Double_t* y); Adds a new bin to the histogram. The number of vertices and their (x,y); coordinates are required as input. It returns the bin number in the; histogram. Int_t AddBin(Double_t x1, Double_t y1, Double_t x2, Double_t y2); Add a new bin to the histogram. The bin shape is a rectangle.; It returns the bin number of the bin in the histogram. Bool_t Add(const TH1* h1, Double_t c1); Performs the operation: this = this + c1*h1. Bool_t Add(TF1* h1, Double_t c1 = 1, Option_t* option = """"); Performs the operation: this = this + c1*f1. Bool_t Add(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1); Replace contents of this histogram by the addition of h1 and h2. void AddBinToPartition(TH2PolyBin* bin); Adds the input bin into the partition cell matrix. This method is called; in AddBin() and ChangePartition(). void ChangePartition(Int_t n, Int_t m); Changes the number of partition cells in the histogram.; Deletes the old partition and constructs a new one. void ClearBinContents(); Clears the contents of all bins in the histogram. void Reset(Option_t* option); Reset this histogram: contents, errors, etc. TH1 * DrawCopy(Option_t* option = """") const; Draw copy. Int_t FindBin(Double_t x, Double_t y, Double_t z = 0); Returns the bin number of the bin at the given coordinate. -1 to -9 are; the overflow and underflow bins. overflow bin -5 is the unbinned areas in; th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TH2Poly.html:33263,Perform,Performs,33263,root/html534/TH2Poly.html,https://root.cern,https://root.cern/root/html534/TH2Poly.html,1,['Perform'],['Performs']
Performance,"nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Int_t_ipOrderInterpolation order for cache histograms ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsCachedReal.html:33188,cache,cache,33188,root/html526/RooAbsCachedReal.html,https://root.cern,https://root.cern/root/html526/RooAbsCachedReal.html,2,['cache'],['cache']
Performance,"nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; RooListProxy_list; TIterator*_listIter! do not persist; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooRecursiveFraction.html:31984,cache,cache,31984,root/html526/RooRecursiveFraction.html,https://root.cern,https://root.cern/root/html526/RooRecursiveFraction.html,2,['cache'],['cache']
Performance,"non-versioned layouts of the class have been\n\; 1062 loaded so far. This prevent the proper reading of objects written with\n\; 1063 the class layout version %d, in particular from the file:\n\; 1064 %s.\n\; 1065 To work around this issue, load fewer 'old' files in the same ROOT session."",; 1066 GetName(),fClass->GetClassVersion(),fClassVersion,file->GetName());; 1067 } else {; 1068 Warning(""BuildCheck"", ""\n\; 1069 The class %s transitioned from not having a specified class version\n\; 1070 to having a specified class version (the current class version is %d).\n\; 1071 However too many different non-versioned layouts of the class have been\n\; 1072 loaded so far. This prevent the proper reading of objects written with\n\; 1073 the class layout version %d.\n\; 1074 To work around this issue, load fewer 'old' files in the same ROOT session."",; 1075 GetName(),fClass->GetClassVersion(),fClassVersion);; 1076 }; 1077 } else {; 1078 if (file) {; 1079 if (done) {; 1080 Warning(""BuildCheck"", ""\n\; 1081 The StreamerInfo for version %d of class %s read from the file %s\n\; 1082 has a different checksum than the previously loaded StreamerInfo.\n\; 1083 Reading objects of type %s from the file %s \n\; 1084 (and potentially other files) might not work correctly.\n\; 1085 Most likely the version number of the class was not properly\n\; 1086 updated [See ClassDef(%s,%d)]."",; 1087 fClassVersion, GetName(), file->GetName(), GetName(), file->GetName(), GetName(), fClassVersion);; 1088 } else {; 1089 Warning(""BuildCheck"", ""\n\; 1090 The StreamerInfo from %s does not match existing one (%s:%d)\n\; 1091 The existing one has not been used yet and will be discarded.\n\; 1092 Reading the file %s will work properly, however writing object of\n\; 1093 type %s will not work properly. Most likely the version number\n\; 1094 of the class was not properly updated [See ClassDef(%s,%d)]."",; 1095 file->GetName(), GetName(), fClassVersion,file->GetName(),GetName(), GetName(), fClassVersion);; 1096 };",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:40619,load,loaded,40619,doc/master/TStreamerInfo_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html,1,['load'],['loaded']
Performance,"non-zero at xMax some spillover occurs and; a rising tail may appear at xMin. This effect can be reduced or eliminated by; introducing a buffer zone in the FFT calculation. If this feature is activated; input the sampling array for the FFT calculation is extended in both directions; and filled with repetitions of the lowest bin value and highest bin value; respectively. The buffer bins are stripped again when the FFT output values; are transferred to the p.d.f cache. The default buffer size is 10% of the; observable domain size and can be changed with setBufferFraction() member function. This class is a caching p.d.f inheriting from RooAbsCachedPdf. If this p.d.f; is evaluated for a particular value of x, the FFT calculate the values for the; p.d.f at all points in observables space for the given choice of parameters,; which are stored in the cache. Subsequent evaluations of RooFFTConvPdf with; identical parameters will retrieve results from the cache. If one or more; of the parameters change, the cache will be updated. The sampling density of the cache is controlled by the binning of the; the convolution observable, which can be changed from RooRealVar::setBins(N); For good results N should be large (>1000). Additional interpolation of; cache values may improve the result if courser binning are chosen. These can be; set in the constructor or through the setInterpolationOrder() member function.; For N>1000 interpolation will not substantially improve the performance. Additionial information on caching activities can be displayed by monitoring; the message stream with topic ""Caching"" at the INFO level, i.e.; do RooMsgService::instance().addStream(RooMsgService::INFO,Topic(""Caching"")); to see these message on stdout. Multi-dimensional convolutions are not supported yet, but will be in the future; as FFTW can calculate them. Installing a copy of FFTW on Linux and compiling ROOT to use it. 1) Go to www.fftw.org and download the latest stable version (a .tar.gz file). If ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooFFTConvPdf.html:2340,cache,cache,2340,root/html526/RooFFTConvPdf.html,https://root.cern,https://root.cern/root/html526/RooFFTConvPdf.html,11,['cache'],['cache']
Performance,"nonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TFormula::(anonymous)TFormula::kLinear; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TFormula::(anonymous)TFormula::kNormalized; static TObject::(anonymous)TObject::kNotDeleted; static TF1::(anonymous)kNotDraw; static TFormula::(anonymous)TFormula::kNotGlobal; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Double_t*fAlpha!Array alpha. for each bin in x the deconvolution r of fIntegral; TBitsTFormula::fAlreadyFound! cache for information; Double_t*fBeta!Array beta. is approximated by x = alpha +beta*r *gamma*r**2; Double_tfChisquareFunction fit chisquare; Double_t*TFormula::fConst[fNconst] Array of fNconst formula constants; TString*TFormula::fExpr[fNoper] List of expressions; TString*TFormula::fExprOptimized![fNOperOptimized] List of expressions; Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; TObjArrayTFormula::fFunctionsArray of function calls to make; ROOT::Math::ParamFunctorfFunctor! Functor object to wrap any C++ callable object; Double_t*fGamma!Array gamma.; TH1*fHistogram!Pointer to histogram used for visualisation; Double_t*fIntegral![fNpx] Integral of function binned on fNpx bins; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TObjArrayTFormula::fLinearPartsLinear parts if the formula is linear (contains '|' or ""++""); Color_tTAttMarker::fMarkerColorMarker color i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TF1.html:23420,cache,cache,23420,root/html602/TF1.html,https://root.cern,https://root.cern/root/html602/TF1.html,2,['cache'],['cache']
Performance,"nonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Double_tfRotationMatrix[9]rotation matrix; Double_tfScale[3]scale component; Double_tfTranslation[3]translation component. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoHMatrix(); dummy ctor. TGeoHMatrix(const char* name); constructor. TGeoHMatrix(const TGeoMatrix& matrix); assignment. ~TGeoHMatrix(); destructor. TGeoHMatrix & operator=(const TGeoMatrix* matrix); assignment. TGeoHMatrix & operator=(const TGeoMatrix& matrix); assignment. void CopyFrom(const TGeoMatrix* other); Fast copy method. void Clear(Option_t* option = """"); clear the data for this matrix. TGeoMatrix * MakeClone() const; Make a clone of this matrix. void FastRotZ(const Double_t* sincos); Perform a rotation about Z having the sine/cosine of the rotation angle. TGeoMatrix& Inverse() const; Return a temporary inverse of this. Double_t Determinant() const; computes determinant of the rotation matrix. void Multiply(const TGeoMatrix* right); multiply to the right with an other transformation; if right is identity matrix, just return. void MultiplyLeft(const TGeoMatrix* left); multiply to the left with an other transformation; if right is identity matrix, just return. void RotateX(Double_t angle); Rotate about X axis with angle expressed in degrees. void RotateY(Double_t angle); Rotate about Y axis with angle expressed in degrees. void RotateZ(Double_t angle); Rotate about Z axis with angle expressed in degrees. void ReflectX(Bool_t leftside, Bool_t rotonly = kFALSE); Multiply by a reflection respect to YZ. void ReflectY(Bool_t leftside, Bool_t rotonly = kFALSE); Multiply by a reflection respect to ZX. void ReflectZ(Bool_t leftside, Bool_t rotonly = kFALSE); Multiply by a reflection respect ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoHMatrix.html:16588,Perform,Perform,16588,root/html602/TGeoHMatrix.html,https://root.cern,https://root.cern/root/html602/TGeoHMatrix.html,2,['Perform'],['Perform']
Performance,"nonymous)TObject::kWriteDelete; static TFile::EStatusBitsTFile::kWriteError; static TObject::(anonymous)TObject::kZombie. protected:. TArchiveFile*TFile::fArchive!Archive file from which we read this file; Long64_tTFile::fArchiveOffset!Offset at which file starts in archive; TFileOpenHandle*TFile::fAsyncHandle!For proper automatic cleanup; TFile::EAsyncOpenStatusTFile::fAsyncOpenStatus!Status of an asynchronous open request; Long64_tTFile::fBEGINFirst used byte in file; Int_tTDirectoryFile::fBufferSizeDefault buffer size to create new TKeys; Long64_tTFile::fBytesReadNumber of bytes read from this file; Long64_tTFile::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Long64_tTFile::fBytesWriteNumber of bytes written to this file; TFileCacheRead*TFile::fCacheRead!Pointer to the read cache (if any); TMap*TFile::fCacheReadMap!Pointer to the read cache (if any); TFileCacheWrite*TFile::fCacheWrite!Pointer to the write cache (if any); TArrayC*TFile::fClassIndex!Index of TStreamerInfo classes written to this file; Int_tTFile::fCompressCompression level and algorithm; TDirectory::TContext*TDirectory::fContext!Pointer to a list of TContext object pointing to this TDirectory; Int_tTFile::fDFile descriptor; TDatimeTDirectoryFile::fDatimeCDate and time when directory is created; TDatimeTDirectoryFile::fDatimeMDate and time of last modification; XMLDocPointer_tfDoc!; Long64_tTFile::fENDLast used byte in file; TFile*TDirectoryFile::fFilepointer to current file in memory; TList*TFile::fFreeFree segments linked list table; Int_tfIOVersion! indicates format of ROOT xml file; TList*TFile::fInfoCache!Cached list of the streamer infos in this file; Bool_tTFile::fInitDone!True if the file has been initialized; Bool_tTFile::fIsArchive!True if this is a pure archive file; Bool_tTFile::fIsPcmFile!True if the file is a ROOT pcm file.; Bool_tTFile::fIsRootFile!True is this is a ROOT file, raw file otherwise; Long64_tfKeyCounter! counter of created keys, used for ke",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TXMLFile.html:22808,cache,cache,22808,root/html602/TXMLFile.html,https://root.cern,https://root.cern/root/html602/TXMLFile.html,14,"['Cache', 'cache']","['Cached', 'cache']"
Performance,"nore its value for map and multimap;; 1031 return fPointers && !(fSTL_type == ROOT::kSTLmap || fSTL_type == ROOT::kSTLmultimap ||; 1032 fSTL_type == ROOT::kSTLunorderedmap || fSTL_type == ROOT::kSTLunorderedmultimap);; 1033}; 1034 ; 1035////////////////////////////////////////////////////////////////////////////////; 1036/// Return a pointer to the TClass representing the content.; 1037 ; 1038TClass *TGenCollectionProxy::GetValueClass() const; 1039{; 1040 auto value = fValue.load(std::memory_order_relaxed);; 1041 if (!value) {; 1042 Initialize(kFALSE);; 1043 value = fValue.load(std::memory_order_relaxed);; 1044 }; 1045 return value ? (*value).fType.GetClass() : 0;; 1046}; 1047 ; 1048////////////////////////////////////////////////////////////////////////////////; 1049/// If the content is a simple numerical value, return its type (see TDataType); 1050 ; 1051EDataType TGenCollectionProxy::GetType() const; 1052{; 1053 auto value = fValue.load(std::memory_order_relaxed);; 1054 if (!value) {; 1055 Initialize(kFALSE);; 1056 value = fValue.load(std::memory_order_relaxed);; 1057 }; 1058 return value ? (*value).fKind : kNoType_t;; 1059}; 1060 ; 1061////////////////////////////////////////////////////////////////////////////////; 1062/// Return the address of the value at index 'idx'; 1063 ; 1064void* TGenCollectionProxy::At(UInt_t idx); 1065{; 1066 if ( fEnv && fEnv->fObject ) {; 1067 switch (fSTL_type) {; 1068 case ROOT::kSTLvector:; 1069 if ((*fValue).fKind == kBool_t) {; 1070 auto vec = (std::vector<bool> *)(fEnv->fObject);; 1071 fEnv->fLastValueVecBool = (*vec)[idx];; 1072 fEnv->fIdx = idx;; 1073 return &(fEnv->fLastValueVecBool);; 1074 }; 1075 // intentional fall through; 1076 case ROOT::kROOTRVec:; 1077 fEnv->fIdx = idx;; 1078 switch( idx ) {; 1079 case 0:; 1080 return fEnv->fStart = fFirst.invoke(fEnv);; 1081 default:; 1082 if (! fEnv->fStart ) fEnv->fStart = fFirst.invoke(fEnv);; 1083 return ((char*)fEnv->fStart) + fValDiff*idx;; 1084 }; 1085 case ROOT::kSTLbitset: ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:34347,load,load,34347,doc/master/TGenCollectionProxy_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html,1,['load'],['load']
Performance,"normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_t_relParam; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooHistConstraint.html:44260,cache,cache,44260,root/html602/RooHistConstraint.html,https://root.cern,https://root.cern/root/html602/RooHistConstraint.html,4,['cache'],['cache']
Performance,"normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; Bool_t_protectNegative; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxymean; RooRealProxyx.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooPoisson.html:44216,cache,cache,44216,root/html602/RooPoisson.html,https://root.cern,https://root.cern/root/html602/RooPoisson.html,4,['cache'],['cache']
Performance,"normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_t_ownBasisFlag indicating ownership of _basis ; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxyxDependent/convolution variable.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooResolutionModel.html:41418,cache,cache,41418,root/html528/RooResolutionModel.html,https://root.cern,https://root.cern/root/html528/RooResolutionModel.html,2,['cache'],['cache']
Performance,"normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; RooRealProxy_t; RooCategoryProxy_tagFlav; RooRealProxy_tau; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; RooBMixDecay::DecayType_type; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooBMixDecay.html:44970,cache,cache,44970,root/html534/RooBMixDecay.html,https://root.cern,https://root.cern/root/html534/RooBMixDecay.html,2,['cache'],['cache']
Performance,"normalization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_tRooResolutionModel::_ownBasisFlag indicating ownership of _basis ; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInter",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooGaussModel.html:41217,cache,cache,41217,root/html530/RooGaussModel.html,https://root.cern,https://root.cern/root/html530/RooGaussModel.html,2,['cache'],['cache']
Performance,"not be recalculated; if the observable p changes. RooCachedPdf(const RooCachedPdf& other, const char* name = 0); Copy constructor. ~RooCachedPdf(); Destructor. void fillCacheObject(RooAbsCachedPdf::PdfCacheElem& cachePdf) const; Update contents of cache histogram by resampling the input p.d.f. Note that; the cache is filled with normalized p.d.f values so that the RooHistPdf; that represents the cache contents can be explicitly declared as self normalized; eliminating the need for superfluous numeric calculations of unit normalization.s. void preferredObservableScanOrder(const RooArgSet& obs, RooArgSet& orderedObs) const; Defer preferred scan order to cached pdf prefernece. RooArgSet* actualObservables(const RooArgSet& nset) const; If this pdf is operated with a fixed set of observables, return; the subset of the fixed observables that are actual dependents; of the external input p.d.f. If this p.d.f is operated without; a fixed set of cache observables, return the actual observables; of the external input p.d.f given the choice of observables defined; in nset. RooArgSet* actualParameters(const RooArgSet& nset) const; If this p.d.f is operated with a fixed set of observables, return; all variables of the external input p.d.f that are not one of; the cache observables. If this p.d.f is operated in automatic mode,; return the parameters of the external input p.d.f. RooCachedPdf(); {}. TObject* clone(const char* newname) const; { return new RooCachedPdf(*this,newname); }. const char* inputBaseName() const; Return the base name for cache objects, in this case the name of the cached p.d.f. Double_t evaluate() const; Dummy evaluate, it is never called. const char* payloadUniqueSuffix() const; { return pdf.arg().aggregateCacheUniqueSuffix() ; }. » Last changed: Mon Jul 4 15:22:22 2011 » Last generated: 2011-07-04 15:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooCachedPdf.html:44686,cache,cache,44686,root/html530/RooCachedPdf.html,https://root.cern,https://root.cern/root/html530/RooCachedPdf.html,3,['cache'],"['cache', 'cached']"
Performance,"not be recalculated; if the observable p changes. RooCachedPdf(const RooCachedPdf& other, const char* name = 0); Copy constructor. ~RooCachedPdf(); Destructor. void fillCacheObject(RooAbsCachedPdf::PdfCacheElem& cachePdf) const; Update contents of cache histogram by resampling the input p.d.f. Note that; the cache is filled with normalized p.d.f values so that the RooHistPdf; that represents the cache contents can be explicitly declared as self normalized; eliminating the need for superfluous numeric calculations of unit normalization.s. void preferredObservableScanOrder(const RooArgSet& obs, RooArgSet& orderedObs) const; Defer preferred scan order to cached pdf prefernece. RooArgSet* actualObservables(const RooArgSet& nset) const; If this pdf is operated with a fixed set of observables, return; the subset of the fixed observables that are actual dependents; of the external input p.d.f. If this p.d.f is operated without; a fixed set of cache observables, return the actual observables; of the external input p.d.f given the choice of observables defined; in nset. RooArgSet* actualParameters(const RooArgSet& nset) const; If this p.d.f is operated with a fixed set of observables, return; all variables of the external input p.d.f that are not one of; the cache observables. If this p.d.f is operated in automatic mode,; return the parameters of the external input p.d.f. RooCachedPdf(); {}. TObject* clone(const char* newname) const; { return new RooCachedPdf(*this,newname); }. const char* inputBaseName() const; Return the base name for cache objects, in this case the name of the cached p.d.f. Double_t evaluate() const; Dummy evaluate, it is never called. const char* payloadUniqueSuffix() const; { return pdf.arg().aggregateCacheUniqueSuffix() ; }. » Last changed: Thu Nov 3 20:07:41 2011 » Last generated: 2011-11-03 20:07; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooCachedPdf.html:45093,cache,cache,45093,root/html532/RooCachedPdf.html,https://root.cern,https://root.cern/root/html532/RooCachedPdf.html,3,['cache'],"['cache', 'cached']"
Performance,"not be recalculated; if the observable p changes. RooCachedPdf(const RooCachedPdf& other, const char* name = 0); Copy constructor. ~RooCachedPdf(); Destructor. void fillCacheObject(RooAbsCachedPdf::PdfCacheElem& cachePdf) const; Update contents of cache histogram by resampling the input p.d.f. Note that; the cache is filled with normalized p.d.f values so that the RooHistPdf; that represents the cache contents can be explicitly declared as self normalized; eliminating the need for superfluous numeric calculations of unit normalization.s. void preferredObservableScanOrder(const RooArgSet& obs, RooArgSet& orderedObs) const; Defer preferred scan order to cached pdf prefernece. RooArgSet* actualObservables(const RooArgSet& nset) const; If this pdf is operated with a fixed set of observables, return; the subset of the fixed observables that are actual dependents; of the external input p.d.f. If this p.d.f is operated without; a fixed set of cache observables, return the actual observables; of the external input p.d.f given the choice of observables defined; in nset. RooArgSet* actualParameters(const RooArgSet& nset) const; If this p.d.f is operated with a fixed set of observables, return; all variables of the external input p.d.f that are not one of; the cache observables. If this p.d.f is operated in automatic mode,; return the parameters of the external input p.d.f. RooCachedPdf(); {}. TObject* clone(const char* newname) const; { return new RooCachedPdf(*this,newname); }. const char* inputBaseName() const; Return the base name for cache objects, in this case the name of the cached p.d.f. Double_t evaluate() const; Dummy evaluate, it is never called. const char* payloadUniqueSuffix() const; { return pdf.arg().aggregateCacheUniqueSuffix() ; }. » Last changed: Tue Jun 2 15:29:45 2015 » Last generated: 2015-06-02 15:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooCachedPdf.html:49119,cache,cache,49119,root/html604/RooCachedPdf.html,https://root.cern,https://root.cern/root/html604/RooCachedPdf.html,6,['cache'],"['cache', 'cached']"
Performance,"not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooRealProxyRooAbsMoment::_funcInput function; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; RooRealProxy_ifInt(F(x))dx ;; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; RooRealProxy_ixfInt(X*F(X))dx ;; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; RooRealProxyRooAbsMoment::_meanMean (if calculated for central moment); static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooFirstMoment.html:34989,cache,cache,34989,root/html602/RooFirstMoment.html,https://root.cern,https://root.cern/root/html602/RooFirstMoment.html,20,"['Cache', 'cache']","['Cached', 'cache']"
Performance,"not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static RooFormulaVar*RooResolutionModel::_identityIdentity basis function pointe; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooTruthModel.html:44353,cache,cache,44353,root/html602/RooTruthModel.html,https://root.cern,https://root.cern/root/html602/RooTruthModel.html,10,"['Cache', 'cache']","['Cached', 'cache']"
Performance,"not guaranteed to be 'live', so do not dereference without proper caution. void graphVizTree(const char* fileName, const char* delimiter, bool useTitle, bool useLatex); Create a GraphViz .dot file visualizing the expression tree headed by; this RooAbsArg object. Use the GraphViz tool suite to make e.g. a gif; or ps file from the .dot file. Based on concept developed by Kyle Cranmer. void graphVizTree(ostream& os, const char* delimiter, bool useTitle, bool useLatex); Write the GraphViz representation of the expression tree headed by; this RooAbsArg object to the given ostream. Based on concept developed by Kyle Cranmer. void graphVizAddConnections(set<pair<RooAbsArg*,RooAbsArg*> >& linkSet); Utility function that inserts all point-to-point client-server connections; between any two RooAbsArgs in the expression tree headed by this object; in the linkSet argument. Bool_t inhibitDirty(); Return current status of the inhibitDirty global flag. If true; no dirty state change tracking occurs and all caches are considered; to be always dirty. Bool_t addOwnedComponents(const RooArgSet& comps); Take ownership of the contents of 'comps'. RooAbsArg* cloneTree(const char* newname = 0) const; Clone tree expression of objects. All tree nodes will be owned by; the head node return by cloneTree(). RooExpensiveObjectCache& expensiveObjectCache() const. Bool_t flipAClean(). TObject* clone(const char* newname) const. TObject* Clone(const char* newname = 0) const. Bool_t isDerived() const; Accessors to client-server relation information. Bool_t dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg=0); Does this arg depend on the value of any of of the values in serverList?. Bool_t dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg=0); Does this arg depend on the value of server?. Bool_t hasClients() const; { return _clientList.GetSize()>0 ? kTRUE : kFALSE ; }. TIterator* clientIterator() const; Return iterator over all client RooAbsArgs. TIterator*",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsArg.html:34625,cache,caches,34625,root/html526/RooAbsArg.html,https://root.cern,https://root.cern/root/html526/RooAbsArg.html,1,['cache'],['caches']
Performance,"not hold in general. For non-cyclical variables, wrap-around artifacts may be encountered, e.g. if the PDF is zero at xMin and non-zero at xMax. A rising tail may appear at xMin. This is inevitable when using FFTs. A distribution with 3 bins therefore looks like: ... 0 1 2 0 1 2 0 1 2 ...; Therefore, if bins 0 and 2 are not equal, the FFT sees a cyclical function with a step at the 2|0 boundary, which causes artifacts in Fourier space.; The spillover or discontinuity can be reduced or eliminated by introducing a buffer zone in the FFT calculation. If this feature is activated (on by default), the sampling array for the FFT calculation is extended in both directions, and padded with the lowest/highest bin. Example: original: -5 -4 -3 -2 -1 0 +1 +2 +3 +4 +5; add buffer zones: U U -5 -4 -3 -2 -1 0 +1 +2 +3 +4 +5 O O; rotate: 0 +1 +2 +3 +4 +5 O O U U -5 -4 -3 -2 -1; zonesDefinition zones.py:1; The buffer bins are stripped away when the FFT output values are transferred back to the p.d.f cache. The default buffer size is 10% of the observable domain size, and can be changed with the setBufferFraction() member function.; The RooFFTConvPdf uses caching inherited from a RooAbsCachedPdf. If it is evaluated for a particular value of x, the FFT and convolution is calculated for all bins in the observable space for the given choice of parameters, which are also stored in the cache. Subsequent evaluations for different values of the convolution observable and identical parameters will be retrieved from the cache. If one or more of the parameters change, the cache will be updated, i.e., a new FFT runs.; The sampling density of the FFT is controlled by the binning of the the convolution observable, which can be changed using RooRealVar::setBins(N). For good results, N should be large (>=1000). Additional interpolation between the bins may improve the result if coarse binnings are chosen. These can be activated in the constructor or by calling setInterpolationOrder(). For N >> 1000",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooFFTConvPdf.html:2366,cache,cache,2366,doc/master/classRooFFTConvPdf.html,https://root.cern,https://root.cern/doc/master/classRooFFTConvPdf.html,1,['cache'],['cache']
Performance,"not implemented in this case; 406 if (!extended) {; 407 MATH_WARN_MSG(""Fitter::DoBinnedLikelihoodFit"",; 408 ""Not-extended binned fit with gradient not yet supported - do an extended fit"");; 409 extended = true;; 410 }; 411 if (fFunc_v) {; 412 // create a chi2 function to be used for the equivalent chi-square; 413 Chi2FCN<BaseFunc, IModelFunction_v> chi2(data, fFunc_v);; 414 std::shared_ptr<IGradModelFunction_v> gradFun = std::dynamic_pointer_cast<IGradModelFunction_v>(fFunc_v);; 415 if (!gradFun) {; 416 MATH_ERROR_MSG(""Fitter::DoBinnedLikelihoodFit"", ""wrong type of function - it does not provide gradient"");; 417 return false;; 418 }; 419 auto logl = std::make_unique<PoissonLikelihoodFCN<BaseGradFunc, IModelFunction_v>>(data, gradFun, useWeight, extended, executionPolicy);; 420 // do minimization; 421 return (useWeight) ? DoWeightMinimization(std::move(logl),&chi2) : DoMinimization(std::move(logl),&chi2);; 422 } else {; 423 // create a chi2 function to be used for the equivalent chi-square; 424 Chi2FCN<BaseFunc> chi2(data, fFunc);; 425 // check if fFunc provides gradient; 426 std::shared_ptr<IGradModelFunction> gradFun = std::dynamic_pointer_cast<IGradModelFunction>(fFunc);; 427 if (!gradFun) {; 428 MATH_ERROR_MSG(""Fitter::DoBinnedLikelihoodFit"", ""wrong type of function - it does not provide gradient"");; 429 return false;; 430 }; 431 // use gradient for minimization; 432 auto logl = std::make_unique<PoissonLikelihoodFCN<BaseGradFunc>>(data, gradFun, useWeight, extended, executionPolicy);; 433 // do minimization; 434 return (useWeight) ? DoWeightMinimization(std::move(logl),&chi2) : DoMinimization(std::move(logl),&chi2);; 435 }; 436 }; 437 return false;; 438}; 439 ; 440bool Fitter::DoUnbinnedLikelihoodFit(bool extended, const ROOT::EExecutionPolicy &executionPolicy) {; 441 // perform a likelihood fit on a set of unbinned data; 442 ; 443 std::shared_ptr<UnBinData> data = std::dynamic_pointer_cast<UnBinData>(fData);; 444 assert(data);; 445 ; 446 bool useWeight = fConfig.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Fitter_8cxx_source.html:16660,perform,perform,16660,doc/master/Fitter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html,1,['perform'],['perform']
Performance,"not of interest); if (myMethodList != """") {; for (std::map<std::string,int>::iterator it = Use.begin(); it != Use.end(); it++) it->second = 0;; ; std::vector<TString> mlist = gTools().SplitString( myMethodList, ',' );; for (UInt_t i=0; i<mlist.size(); i++) {; std::string regMethod(mlist[i].Data());; ; if (Use.find(regMethod) == Use.end()) {; std::cout << ""Method \"""" << regMethod << ""\"" not known in TMVA under this name. Choose among the following:"" << std::endl;; for (std::map<std::string,int>::iterator it = Use.begin(); it != Use.end(); it++) std::cout << it->first << "" "";; std::cout << std::endl;; return;; }; Use[regMethod] = 1;; }; }; ; // --------------------------------------------------------------------------------------------------; ; // Here the preparation phase begins; ; // Create a new root output file; TString outfileName( ""TMVAReg.root"" );; TFile* outputFile = TFile::Open( outfileName, ""RECREATE"" );; ; // Create the factory object. Later you can choose the methods; // whose performance you'd like to investigate. The factory will; // then run the performance analysis for you.; //; // The first argument is the base of the name of all the; // weightfiles in the directory weight/; //; // The second argument is the output file for the training results; // All TMVA output can be suppressed by removing the ""!"" (not) in; // front of the ""Silent"" argument in the option string; TMVA::Factory *factory = new TMVA::Factory( ""TMVARegression"", outputFile,; ""!V:!Silent:Color:DrawProgressBar:AnalysisType=Regression"" );; ; ; TMVA::DataLoader *dataloader=new TMVA::DataLoader(""datasetreg"");; // If you wish to modify default settings; // (please check ""src/Config.h"" to see all available global options); //; // (TMVA::gConfig().GetVariablePlotting()).fTimesRMS = 8.0;; // (TMVA::gConfig().GetIONames()).fWeightFileDir = ""myWeightDirectory"";; ; // Define the input variables that shall be used for the MVA training; // note that you may also use variable expressions, such as: ""3",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:137309,perform,performance,137309,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['perform'],['performance']
Performance,"not warn about missing dictionary for the class.; 5767/// (typically used for class that are used only for transient members); 5768///; 5769/// The 'requestedname' is expected to be already normalized.; 5770 ; 5771TClass *TClass::LoadClassDefault(const char *requestedname, Bool_t /* silent */); 5772{; 5773 // This function does not (and should not) attempt to check in the; 5774 // list of loaded classes or in the typedef.; 5775 ; 5776 DictFuncPtr_t dict = TClassTable::GetDictNorm(requestedname);; 5777 ; 5778 if (!dict) {; 5779 if (gInterpreter->AutoLoad(requestedname,kTRUE)) {; 5780 dict = TClassTable::GetDictNorm(requestedname);; 5781 }; 5782 }; 5783 ; 5784 if (dict) {; 5785 TClass *ncl = (dict)();; 5786 if (ncl) ncl->PostLoadCheck();; 5787 return ncl;; 5788 }; 5789 return nullptr;; 5790}; 5791 ; 5792////////////////////////////////////////////////////////////////////////////////; 5793/// Helper function used by TClass::GetClass().; 5794/// This function attempts to load the dictionary for 'classname'; 5795/// from the list of generator.; 5796/// If silent is 'true', do not warn about missing dictionary for the class.; 5797/// (typically used for class that are used only for transient members); 5798///; 5799/// The 'requestedname' is expected to be already normalized.; 5800 ; 5801TClass *TClass::LoadClassCustom(const char *requestedname, Bool_t silent); 5802{; 5803 // This function does not (and should not) attempt to check in the; 5804 // list of loaded classes or in the typedef.; 5805 ; 5806 TIter next(gROOT->GetListOfClassGenerators());; 5807 TClassGenerator *gen;; 5808 while ((gen = (TClassGenerator*) next())) {; 5809 TClass *cl = gen->GetClass(requestedname, kTRUE, silent);; 5810 if (cl) {; 5811 cl->PostLoadCheck();; 5812 return cl;; 5813 }; 5814 }; 5815 return nullptr;; 5816}; 5817 ; 5818////////////////////////////////////////////////////////////////////////////////; 5819/// Try to load the ClassInfo if available. This function may require parsing; 5820/// t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:221935,load,load,221935,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['load'],['load']
Performance,"not warn about missing dictionary for the class.; 5834/// (typically used for class that are used only for transient members); 5835///; 5836/// The 'requestedname' is expected to be already normalized.; 5837 ; 5838TClass *TClass::LoadClassDefault(const char *requestedname, Bool_t /* silent */); 5839{; 5840 // This function does not (and should not) attempt to check in the; 5841 // list of loaded classes or in the typedef.; 5842 ; 5843 DictFuncPtr_t dict = TClassTable::GetDictNorm(requestedname);; 5844 ; 5845 if (!dict) {; 5846 if (gInterpreter->AutoLoad(requestedname,kTRUE)) {; 5847 dict = TClassTable::GetDictNorm(requestedname);; 5848 }; 5849 }; 5850 ; 5851 if (dict) {; 5852 TClass *ncl = (dict)();; 5853 if (ncl) ncl->PostLoadCheck();; 5854 return ncl;; 5855 }; 5856 return nullptr;; 5857}; 5858 ; 5859////////////////////////////////////////////////////////////////////////////////; 5860/// Helper function used by TClass::GetClass().; 5861/// This function attempts to load the dictionary for 'classname'; 5862/// from the list of generator.; 5863/// If silent is 'true', do not warn about missing dictionary for the class.; 5864/// (typically used for class that are used only for transient members); 5865///; 5866/// The 'requestedname' is expected to be already normalized.; 5867 ; 5868TClass *TClass::LoadClassCustom(const char *requestedname, Bool_t silent); 5869{; 5870 // This function does not (and should not) attempt to check in the; 5871 // list of loaded classes or in the typedef.; 5872 ; 5873 TIter next(gROOT->GetListOfClassGenerators());; 5874 TClassGenerator *gen;; 5875 while ((gen = (TClassGenerator*) next())) {; 5876 TClass *cl = gen->GetClass(requestedname, kTRUE, silent);; 5877 if (cl) {; 5878 cl->PostLoadCheck();; 5879 return cl;; 5880 }; 5881 }; 5882 return nullptr;; 5883}; 5884 ; 5885////////////////////////////////////////////////////////////////////////////////; 5886/// Try to load the ClassInfo if available. This function may require parsing; 5887/// t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:224686,load,load,224686,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['load'],['load']
Performance,"not work correctly.\n\; 1104 Most likely the version number of the class was not properly\n\; 1105 updated [See ClassDef(%s,%d)]."",; 1106 fClassVersion, GetName(), GetName(), GetName(), fClassVersion);; 1107 } else {; 1108 Warning(""BuildCheck"", ""\n\; 1109 The StreamerInfo does not match existing one (%s:%d)\n\; 1110 The existing one has not been used yet and will be discarded.\n\; 1111 Reading should work properly, however writing object of\n\; 1112 type %s will not work properly. Most likely the version number\n\; 1113 of the class was not properly updated [See ClassDef(%s,%d)]."",; 1114 GetName(), fClassVersion, GetName(), GetName(), fClassVersion);; 1115 }; 1116 }; 1117 }; 1118 CompareContent(0,info,kTRUE,kTRUE,file);; 1119 fClass->SetBit(TClass::kWarned);; 1120 }; 1121 if (done) {; 1122 return;; 1123 }; 1124 }; 1125 // The slot was free, however it might still be reserved for the current; 1126 // loaded version of the class; 1127 if (fClass->IsLoaded(); 1128 && fClass->HasDataMemberInfo(); 1129 && (fClassVersion != 0) // We don't care about transient classes; 1130 && (fClassVersion == fClass->GetClassVersion()); 1131 && (fCheckSum != fClass->GetCheckSum())) {; 1132 ; 1133 // If the old TStreamerInfo matches the in-memory one when we either; 1134 // - ignore the members of type enum; 1135 // or; 1136 // - ignore the comments annotation (//[xyz]); 1137 // we can accept the old TStreamerInfo.; 1138 ; 1139 if (!fClass->MatchLegacyCheckSum(fCheckSum)) {; 1140 ; 1141 Bool_t warn = !fClass->TestBit(TClass::kWarned);; 1142 if (warn) {; 1143 warn = !CompareContent(fClass,0,kFALSE,kFALSE,file);; 1144 }; 1145#ifdef TEST_FOR_BACKWARD_COMPATIBILITY_ABSTRACT_CLASSES; 1146 if (warn && file->GetVersion() < 51800 && fClass && (fClass->Property() & kIsAbstract); 1147 && fClass->GetListOfDataMembers()->GetEntries() != 0); 1148 {; 1149 // In some instances of old files (v5.17 and less), some StreamerInfo for; 1150 // an abstract class where not written correctly, and add no; 1151 // ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:42675,load,loaded,42675,doc/master/TStreamerInfo_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html,1,['load'],['loaded']
Performance,"notPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TSystem; virtual void DoBeep (Int_t=-1, Int_t=-1) const;  ; virtual const char * ExpandFileName (const char *fname);  Expand a pathname getting rid of special shell characters like ~. ;  ; virtual Bool_t ExpandFileName (TString &fname);  Expand a pathname getting rid of special shell characters like ~. ;  ; TSystem * FindHelper (const char *path, void *dirptr=nullptr);  Create helper TSystem to handle file and directory operations that might be special for remote file access. ;  ; TString & GetLastErrorString ();  Return the thread local storage for the custom last error message. ;  ; const TString & GetLastErrorString () const;  Return the thread local storage for the custom last error message. ;  ; virtual const char * GetLinkedLibraries ();  Get list of shared libraries loaded at the start of the executable. ;  ; virtual void SigAlarmInterruptsSyscalls (Bool_t);  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Static Protected Member Functions inherited from TSystem; static const char * StripOffProto (const char *path, const char *proto);  Strip off protocol string from specified path. ;  ;  Protected Attributes inherited from TSystem; EAclicMode fAclicMode {kDefault};  ; Int_t fAclicProperties {0};  ; Int_t fBeepDuration {0};  ; Int_t fBeepFreq {0};  ; TString fBuildArch;  ; TString fBuildCompiler;  ; TString fBuildCompilerVersion;  ; TString fBuildCompilerVersionStr;  ; TString fBuildDir;  ; TString fBuildNode;  ; TSeqCollection * fCompiled {nullptr};  ; Bool_t fDone {kFALSE};  ; TSeqCollection * fFileHandler {nullptr};  ; TString fFlagsDebug;  ; TString fFlagsOpt; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDavixSystem.html:31297,load,loaded,31297,doc/master/classTDavixSystem.html,https://root.cern,https://root.cern/doc/master/classTDavixSystem.html,2,['load'],['loaded']
Performance,"nown branch'; is suppressed. void SetDirectory(TDirectory* dir); Remove reference to this chain from current directory and add; reference to new directory dir. dir can be 0 in which case the chain; does not belong to any directory. void SetEntryList(TEntryList* elist, Option_t* opt = """"); Set the input entry list (processing the entries of the chain will then be; limited to the entries in the list); This function finds correspondance between the sub-lists of the TEntryList; and the trees of the TChain; By default (opt=""""), both the file names of the chain elements and; the file names of the TEntryList sublists are expanded to full path name.; If opt = ""ne"", the file names are taken as they are and not expanded. void SetEntryListFile(const char* filename = """", Option_t* opt = """"); Set the input entry list (processing the entries of the chain will then be; limited to the entries in the list). This function creates a special kind; of entry list (TEntryListFromFile object) that loads lists, corresponding; to the chain elements, one by one, so that only one list is in memory at a time. If there is an error opening one of the files, this file is skipped and the; next file is loaded. File naming convention:; - by default, filename_elist.root is used, where filename is the; name of the chain element; - xxx$xxx.root - $ sign is replaced by the name of the chain element; If the list name is not specified (by passing filename_elist.root/listname to; the TChain::SetEntryList() function, the first object of class TEntryList; in the file is taken. It is assumed, that there are as many list files, as there are elements in; the chain and they are in the same order. void SetEventList(TEventList* evlist); This function transfroms the given TEventList into a TEntryList. NOTE, that this function loads all tree headers, because the entry numbers; in the TEventList are global and have to be recomputed, taking into account; the number of entries in each tree. The new TEntryList is owned b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TChain.html:46184,load,loads,46184,root/html526/TChain.html,https://root.cern,https://root.cern/root/html526/TChain.html,11,['load'],['loads']
Performance,"npar parameters. ;  ; virtual ~ParamFunction ();  ; unsigned int NPar () const;  Return the number of parameters. ;  ; virtual const double * Parameters () const;  Access the parameter values. ;  ; virtual void SetParameters (const double *p);  Set the parameter values. ;  ;  Public Member Functions inherited from ROOT::Math::IParametricGradFunctionOneDim;  ~IParametricGradFunctionOneDim () override;  Virtual Destructor (no operations) ;  ; double ParameterDerivative (const double *x, const double *p, unsigned int ipar=0) const;  Partial derivative with respect a parameter Compatibility interface with multi-dimensional functions. ;  ; double ParameterDerivative (const double *x, unsigned int ipar=0) const;  Evaluate partial derivative using cached parameter values (multi-dim like interface) ;  ; double ParameterDerivative (double x, const double *p, unsigned int ipar=0) const;  Partial derivative with respect a parameter. ;  ; double ParameterDerivative (double x, unsigned int ipar=0) const;  Evaluate partial derivative using cached parameter values. ;  ; void ParameterGradient (const double *x, const double *p, double *grad) const;  Compatibility interface with multi-dimensional functions. ;  ; void ParameterGradient (const double *x, double *grad) const;  Evaluate all derivatives using cached parameter values (multi-dim like interface) ;  ; virtual void ParameterGradient (double x, const double *p, double *grad) const;  Evaluate the derivatives of the function with respect to the parameters at a point x. ;  ; void ParameterGradient (double x, double *grad) const;  Evaluate all derivatives using cached parameter values. ;  ;  Public Member Functions inherited from ROOT::Math::IParametricFunctionOneDim; double operator() (const double *x, const double *p) const;  multidim-like interface ;  ; double operator() (double x, const double *p) const;  Evaluate function at a point x and for given parameters p. ;  ;  Public Member Functions inherited from ROOT::Math::IBaseFun",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1Polynomial.html:4188,cache,cached,4188,doc/master/classROOT_1_1Math_1_1Polynomial.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1Polynomial.html,1,['cache'],['cached']
Performance,"nputFile = TFile.Open(inputFileName); ; ; # --- Register the training and test trees; signalTree = inputFile.Get(""sig_tree""); backgroundTree = inputFile.Get(""bkg_tree""); signalTree.Print(); ; ## Declare DataLoader(s); ; # The next step is to declare the DataLoader class that deals with input variables; # Define the input variables that shall be used for the MVA training; # note that you may also use variable expressions, which can be parsed by TTree::Draw( ""expression"" )]; loader = TMVA.DataLoader(""dataset""); ; loader.AddVariable(""m_jj""); loader.AddVariable(""m_jjj""); loader.AddVariable(""m_lv""); loader.AddVariable(""m_jlv""); loader.AddVariable(""m_bb""); loader.AddVariable(""m_wbb""); loader.AddVariable(""m_wwbb""); ; # We set now the input data trees in the TMVA DataLoader class; # global event weights per tree (see below for setting event-wise weights); signalWeight = 1.0; backgroundWeight = 1.0; # You can add an arbitrary number of signal or background trees; loader.AddSignalTree(signalTree, signalWeight); loader.AddBackgroundTree(backgroundTree, backgroundWeight); ; # Set individual event weights (the variables must exist in the original TTree); # for signal : factory->SetSignalWeightExpression (""weight1*weight2"");; # for background: factory->SetBackgroundWeightExpression(""weight1*weight2"");; # loader->SetBackgroundWeightExpression( ""weight"" );; ; ; # Apply additional cuts on the signal and background samples (can be different); mycuts = ROOT.TCut("""") # for example: TCut mycuts = ""abs(var1)<0.5 && abs(var2-0.5)<1"";; mycutb = ROOT.TCut("""") # for example: TCut mycutb = ""abs(var1)<0.5"";; ; # Tell the factory how to use the training and testing events; #; # If no numbers of events are given, half of the events in the tree are used; # for training, and the other half for testing:; # loader->PrepareTrainingAndTestTree( mycut, ""SplitMode=random:!V"" );; # To also specify the number of testing events, use:; ; loader.PrepareTrainingAndTestTree(; mycuts, mycutb, nTrain_Signal=7000",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__Higgs__Classification_8py.html:59840,load,loader,59840,doc/master/TMVA__Higgs__Classification_8py.html,https://root.cern,https://root.cern/doc/master/TMVA__Higgs__Classification_8py.html,1,['load'],['loader']
Performance,"nput_line_""));; 1152#endif; 1153 return;; 1154 }; 1155 ; 1156 Module *OwningModule = ND->getOwningModule()->getTopLevelModule();; 1157 assert(OwningModule);; 1158 assert(!ND->getName().empty() && ""Empty name"");; 1159 if (AddSingleEntry && DefinitionIDs.count(ND->getName())); 1160 return;; 1161 // FIXME: The FileEntry in not stable to serialize.; 1162 // FIXME: We might end up with many times with the same module.; 1163 // FIXME: We might end up two modules containing a definition.; 1164 // FIXME: What do we do if no definition is found.; 1165 DefinitionIDs[ND->getName()].push_back(OwningModule->getASTFile());; 1166 }; 1167 };; 1168 DefinitionFinder defFinder(IDs, CI.getASTContext().getTranslationUnitDecl());; 1169 ; 1170 llvm::cantFail(GlobalModuleIndex::writeIndex(CI.getFileManager(),; 1171 CI.getPCHContainerReader(),; 1172 ModuleIndexPath,; 1173 &IDs));; 1174 ModuleManager->resetForReload();; 1175 ModuleManager->loadGlobalIndex();; 1176 GlobalIndex = ModuleManager->getGlobalIndex();; 1177 }; 1178 HaveFullGlobalModuleIndex = true;; 1179 }; 1180 return GlobalIndex;; 1181}; 1182 ; 1183static void RegisterCxxModules(cling::Interpreter &clingInterp); 1184{; 1185 if (!clingInterp.getCI()->getLangOpts().Modules); 1186 return;; 1187 ; 1188 // Loading of a module might deserialize.; 1189 cling::Interpreter::PushTransactionRAII deserRAII(&clingInterp);; 1190 ; 1191 // Setup core C++ modules if we have any to setup.; 1192 ; 1193 // Load libc and stl first.; 1194 // Load vcruntime module for windows; 1195#ifdef R__WIN32; 1196 LoadModule(""vcruntime"", clingInterp);; 1197 LoadModule(""services"", clingInterp);; 1198#endif; 1199 ; 1200#ifdef R__MACOSX; 1201 LoadModule(""Darwin"", clingInterp);; 1202#else; 1203 LoadModule(""libc"", clingInterp);; 1204#endif; 1205 LoadModule(""std"", clingInterp);; 1206 ; 1207 LoadModule(""_Builtin_intrinsics"", clingInterp);; 1208 ; 1209 // Load core modules; 1210 // This should be vector in order to be able to pass it to LoadModules; 1211 std::vector<std::s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:42675,load,loadGlobalIndex,42675,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['load'],['loadGlobalIndex']
Performance,"ns 'b': Optional boundary crossing check + timing per volume. STAGE 1: extensive overlap checking by sampling per volume. Stdout need to be; checked by user to get report, then TGeoVolume::CheckOverlaps(0.01, ""s"") can; be called for the suspicious volumes.; STAGE2 : normal overlap checking using the shapes mesh - fills the list of; overlaps.; STAGE3 : shooting NRAYS rays from VERTEX and counting the total number of; crossings per volume (rays propagated from boundary to boundary until; geometry exit). Timing computed and results stored in a histo.; STAGE4 : shooting 1 mil. random rays inside EACH volume and calling; FindNextBoundary() + Safety() for each call. The timing is normalized by the; number of crossings computed at stage 2 and presented as percentage.; One can get a picture on which are the most ""burned"" volumes during; transportation from geometry point of view. Another plot of the timing per; volume vs. number of daughters is produced. void CheckGeometry(Option_t* option = """"); Perform last checks on the geometry. void CheckOverlaps(Double_t ovlp = 0.1, Option_t* option = """"); Check all geometry for illegal overlaps within a limit OVLP. void PrintOverlaps() const; Prints the current list of overlaps. Double_t Weight(Double_t precision = 0.01, Option_t* option = ""va""); Estimate weight of volume VOL with a precision SIGMA(W)/W better than PRECISION.; Option can be ""v"" - verbose (default). ULong_t SizeOf(const TGeoNode* node, Option_t* option); computes the total size in bytes of the branch starting with node.; The option can specify if all the branch has to be parsed or only the node. void Streamer(TBuffer& ); Stream an object of class TGeoManager. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Execute mouse actions on this manager. Int_t Export(const char* filename, const char* name = """", Option_t* option = ""vg""); Export this geometry to a file. -Case 1: root file or root/xml file; if filename end with "".root"". The key will be named name; By default t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoManager.html:68947,Perform,Perform,68947,root/html534/TGeoManager.html,https://root.cern,https://root.cern/root/html534/TGeoManager.html,1,['Perform'],['Perform']
Performance,"ns 'b': Optional boundary crossing check + timing per volume. STAGE 1: extensive overlap checking by sampling per volume. Stdout need to be; checked by user to get report, then TGeoVolume::CheckOverlaps(0.01, ""s"") can; be called for the suspicious volumes.; STAGE2 : normal overlap checking using the shapes mesh - fills the list of; overlaps.; STAGE3 : shooting NRAYS rays from VERTEX and counting the total number of; crossings per volume (rays propagated from boundary to boundary until; geometry exit). Timing computed and results stored in a histo.; STAGE4 : shooting 1 mil. random rays inside EACH volume and calling; FindNextBoundary() + Safety() for each call. The timing is normalized by the; number of crossings computed at stage 2 and presented as percentage.; One can get a picture on which are the most ""burned"" volumes during; transportation from geometry point of view. Another plot of the timing per; volume vs. number of daughters is produced. void CheckGeometry(Option_t* option = """"); Perform last checks on the geometry. void CheckOverlaps(Double_t ovlp = 0.10000000000000001, Option_t* option = """"); Check all geometry for illegal overlaps within a limit OVLP. void PrintOverlaps() const; Prints the current list of overlaps. Double_t Weight(Double_t precision = 0.01, Option_t* option = ""va""); Estimate weight of volume VOL with a precision SIGMA(W)/W better than PRECISION.; Option can be ""v"" - verbose (default). ULong_t SizeOf(const TGeoNode* node, Option_t* option); computes the total size in bytes of the branch starting with node.; The option can specify if all the branch has to be parsed or only the node. void Streamer(TBuffer& ); Stream an object of class TGeoManager. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Execute mouse actions on this manager. Int_t Export(const char* filename, const char* name = """", Option_t* option = ""vg""); Export this geometry to a file. -Case 1: root file or root/xml file; if filename end with "".root"". The key will be named na",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoManager.html:69458,Perform,Perform,69458,root/html602/TGeoManager.html,https://root.cern,https://root.cern/root/html602/TGeoManager.html,2,['Perform'],['Perform']
Performance,"ns -5 if pipe broken or reset by peer (EPIPE || ECONNRESET). int UnixSend(int sock, const void* buf, int len, int flag); Send exactly length bytes from buffer. Returns -1 in case of error,; otherwise number of sent bytes. Returns -4 in case of kNoBlock and; errno == EWOULDBLOCK. Returns -5 if pipe broken or reset by peer; (EPIPE || ECONNRESET). void AddDynamicPath(const char* lib); Add a new directory to the dynamic path. const char * GetDynamicPath(); Return the dynamic path (used to find shared libraries). void SetDynamicPath(const char* lib); Set the dynamic path to a new value.; If the value of 'path' is zero, the dynamic path is reset to its; default value. char * DynamicPathName(const char* lib, Bool_t quiet = kFALSE); Returns the path of a shared library (searches for library in the; shared library search path). If no file name extension is provided; it first tries .so, .sl, .dl and then .a (for AIX). The returned string; must be deleted. void * FindDynLib(const char* lib); Returns the handle to a loaded shared library. Returns 0 when library; not loaded. int UnixDynLoad(const char* lib); Load a shared library. Returns 0 on successful loading, 1 in; case lib was already loaded and -1 in case lib does not exist; or in case of error. Func_t UnixDynFindSymbol(const char* lib, const char* entry); Finds and returns a function pointer to a symbol in the shared library.; Returns 0 when symbol not found. void UnixDynListSymbols(const char* lib, const char* re = """"); List symbols in a shared library. One can use wildcards to list only; the interesting symbols. void UnixDynListLibs(const char* lib = """"); List all loaded shared libraries. void UnixDynUnload(const char* lib); Unload a shared library. int GetSysInfo(SysInfo_t* info) const; Returns static system info, like OS type, CPU type, number of CPUs; RAM size, etc into the SysInfo_t structure. Returns -1 in case of error,; 0 otherwise. int GetCpuInfo(CpuInfo_t* info, Int_t sampleTime = 1000) const; Returns cpu load a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TUnixSystem.html:42236,load,loaded,42236,root/html534/TUnixSystem.html,https://root.cern,https://root.cern/root/html534/TUnixSystem.html,2,['load'],['loaded']
Performance,"ns -5 if pipe broken or reset by peer (EPIPE || ECONNRESET). int UnixSend(int sock, const void* buf, int len, int flag); Send exactly length bytes from buffer. Returns -1 in case of error,; otherwise number of sent bytes. Returns -4 in case of kNoBlock and; errno == EWOULDBLOCK. Returns -5 if pipe broken or reset by peer; (EPIPE || ECONNRESET). void AddDynamicPath(const char* lib); Add a new directory to the dynamic path. const char * GetDynamicPath(); Return the dynamic path (used to find shared libraries). void SetDynamicPath(const char* lib); Set the dynamic path to a new value.; If the value of 'path' is zero, the dynamic path is reset to its; default value. char * DynamicPathName(const char* lib, Bool_t quiet = kFALSE); Returns the path of a shared library (searches for library in the; shared library search path). If no file name extension is provided; it first tries .so, .sl, .dl and then .a (for AIX). The returned string; must be deleted. void * FindDynLib(const char* lib); Returns the handle to a loaded shared library. Returns 0 when library; not loaded. int UnixDynLoad(const char* lib); Load a shared library. Returns 0 on successful loading, 1 in; case lib was already loaded and -1 in case lib does not exist; or in case of error. Func_t UnixDynFindSymbol(const char* lib, const char* entry); Finds and returns a function pointer to a symbol in the shared library.; Returns 0 when symbol not found. void UnixDynListSymbols(const char* lib, const char* re = """"); List symbols in a shared library. One can use wildcards to list only; the interesting symbols. void UnixDynListLibs(const char* lib = """"); List all loaded shared libraries. void UnixDynUnload(const char* lib); Unload a shared library. int ReadUtmpFile(); Read utmp file. Returns number of entries in utmp file. void * SearchUtmpEntry(int nentries, const char* tty); Look for utmp entry which is connected to terminal tty. int GetSysInfo(SysInfo_t* info) const; Returns static system info, like OS type, CPU type",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TUnixSystem.html:41472,load,loaded,41472,root/html528/TUnixSystem.html,https://root.cern,https://root.cern/root/html528/TUnixSystem.html,4,['load'],['loaded']
Performance,"ns fetch from the shape; // (if possible) and add again; if (reqSections != TBuffer3D::kNone); shape.GetBuffer3D(reqSections, localFrame);; Together these allow clients to publish objects to any one of the 3D viewers free of viewer specific drawing code. They allow our simple x3d viewer, and considerably more sophisticated OpenGL one to both work with both geometry libraries (g3d and geom) efficiently.; In addition to external viewers, created in separate windows, this architecture is also used by internal TPad drawing when it requires 3D projections. Publishing to a viewer consists of the following steps:; 1- Create / obtain viewer handle.; 2- Begin scene on viewer.; 3- Fill mandatory parts of TBuffer3D describing object.; 4- Add to viewer.; 5- Fill optional parts of TBuffer3D as requested by viewer.; [ …. repeat 3/4/5 as required for other/child objects]; 6- End scene on viewer.; You should attach the top-level node of your external geometry (or the manager) to a TPad object using TObject::Draw(), and perform the publishing to the viewer in your object’s TObject::Paint() overloaded method. See “Scene Rebuilds”, and example scripts, for more details.; 9.13.4.1 Creating / Obtaining Viewer Handle; External viewers are bound to a TPad object (this may be removed as a requirement in the future). You can create or obtain the current viewer handle via the method:; TVirtualViewer3D * v = gPad->GetViewer3D(""type"");; Here the “type” string defines the viewer type - currently one of:. “ogl” : External GL viewer; “x3d”: External X3D viewer; “pad”: Pad viewer. If no type is passed (null string), and there is no current viewer, then the type is defaulted to “pad”. If no type is passed and there is a current viewer, then this is returned - hence once a viewer is created it can be obtained elsewhere by:; TVirtualViewer3D * v = gPad->GetViewer3D();; 9.13.4.2 Opening / Closing Scenes; Objects must be added to viewer between BeginScene() and EndScene() calls e.g.; viewer->BeginScene(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:404068,perform,perform,404068,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['perform'],['perform']
Performance,"ns inclfile.h; TCint::GetTopLevelMacroName() returns ./mymacro.C. const char * TypeName(const char* typeDesc); Return the absolute type of typeDesc.; E.g.: typeDesc = ""class TNamed**"", returns ""TNamed"".; You need to use the result immediately before it is being overwritten. Int_t LoadLibraryMap(const char* rootmapfile = 0); Load map between class and library. If rootmapfile is specified a; specific rootmap file can be added (typically used by ACLiC).; In case of error -1 is returned, 0 otherwise.; Cint uses this information to automatically load the shared library; for a class (autoload mechanism).; See also the AutoLoadCallback() method below. Int_t RescanLibraryMap(); Scan again along the dynamic path for library maps. Entries for the loaded; shared libraries are unloaded first. This can be useful after reseting; the dynamic path through TSystem::SetDynamicPath(); In case of error -1 is returned, 0 otherwise. Int_t ReloadAllSharedLibraryMaps(); Reload the library map entries coming from all the loaded shared libraries,; after first unloading the current ones.; In case of error -1 is returned, 0 otherwise. Int_t UnloadAllSharedLibraryMaps(); Unload the library map entries coming from all the loaded shared libraries.; Returns 0 if succesful. Int_t UnloadLibraryMap(const char* library); Unload library map entries coming from the specified library.; Returns -1 in case no entries for the specified library were found,; 0 otherwise. Int_t AutoLoad(const char* classname); Load library containing the specified class. Returns 0 in case of error; and 1 in case if success. Int_t AutoLoadCallback(const char* cls, const char* lib); Load library containing specified class. Returns 0 in case of error; and 1 in case if success. void * FindSpecialObject(const char* name, Cint::G__ClassInfo* type, void** prevObj, void** assocPtr); Static function called by CINT when it finds an un-indentified object.; This function tries to find the UO in the ROOT files, directories, etc.; This funct",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TCint.html:28131,load,loaded,28131,root/html526/TCint.html,https://root.cern,https://root.cern/root/html526/TCint.html,5,['load'],['loaded']
Performance,"ns inclfile.h; TCint::GetTopLevelMacroName() returns ./mymacro.C. const char * TypeName(const char* typeDesc); Return the absolute type of typeDesc.; E.g.: typeDesc = ""class TNamed**"", returns ""TNamed"".; You need to use the result immediately before it is being overwritten. Int_t LoadLibraryMap(const char* rootmapfile = 0); Load map between class and library. If rootmapfile is specified a; specific rootmap file can be added (typically used by ACLiC).; In case of error -1 is returned, 0 otherwise.; Cint uses this information to automatically load the shared library; for a class (autoload mechanism).; See also the AutoLoadCallback() method below. Int_t RescanLibraryMap(); Scan again along the dynamic path for library maps. Entries for the loaded; shared libraries are unloaded first. This can be useful after reseting; the dynamic path through TSystem::SetDynamicPath(); In case of error -1 is returned, 0 otherwise. Int_t ReloadAllSharedLibraryMaps(); Reload the library map entries coming from all the loaded shared libraries,; after first unloading the current ones.; In case of error -1 is returned, 0 otherwise. Int_t UnloadAllSharedLibraryMaps(); Unload the library map entries coming from all the loaded shared libraries.; Returns 0 if successful. Int_t UnloadLibraryMap(const char* library); Unload library map entries coming from the specified library.; Returns -1 in case no entries for the specified library were found,; 0 otherwise. Int_t SetClassSharedLibs(const char* cls, const char* libs); Register the autoloading information for a class.; libs is a space separated list of libraries. Int_t AutoLoad(const char* classname); Load library containing the specified class. Returns 0 in case of error; and 1 in case if success. Int_t AutoLoadCallback(const char* cls, const char* lib); Load library containing specified class. Returns 0 in case of error; and 1 in case if success. void * FindSpecialObject(const char* name, Cint::G__ClassInfo* type, void** prevObj, void** assocPtr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TCint.html:29648,load,loaded,29648,root/html534/TCint.html,https://root.cern,https://root.cern/root/html534/TCint.html,2,['load'],['loaded']
Performance,"ns inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; TList * fAliases;  List of aliases for expressions based on the tree branches. ;  ; std::atomic< UInt_t > fAllocationCount {0};  indicates basket should be resized to exact memory usage, but causes significant ;  ; Long64_t fAutoFlush;  Auto-flush tree when fAutoFlush entries written or -fAutoFlush (compressed) bytes produced. ;  ; Long64_t fAutoSave;  Autosave tree when fAutoSave entries written or -fAutoSave (compressed) bytes produced. ;  ; TObjArray fBranches;  List of Branches. ;  ; TBranchRef * fBranchRef;  Branch supporting the TRefTable (if any) ;  ; bool fCacheDoAutoInit;  ! true if cache auto creation or resize check is needed ;  ; bool fCacheDoClusterPrefetch;  ! true if cache is prefetching whole clusters ;  ; Long64_t fCacheSize;  ! Maximum size of file buffers ;  ; bool fCacheUserSet;  ! true if the cache setting was explicitly given by user ;  ; Long64_t fChainOffset;  ! Offset of 1st entry of this Tree in a TChain ;  ; TList * fClones;  ! List of cloned trees which share our addresses ;  ; Long64_t * fClusterRangeEnd;  [fNClusterRange] Last entry of a cluster range. ;  ; Long64_t * fClusterSize;  [fNClusterRange] Number of entries in each cluster for a given range. ;  ; Int_t fDebug;  ! Debug level ;  ; Long64_t fDebugMax;  ! Last entry number to debug ;  ; Long64_t fDebugMin;  ! First entry number to debug ;  ; Int_t fDefaultEntryOffsetLen;  Initial Length of fEntryOffset table in the basket buffers. ;  ; TDirectory * fDirectory;  ! Pointer to directory holding this tree ;  ; Long64_t fEntries;  Number of entries. ;  ; TEntryList * fEntryList;  ! Pointer to event selection list (if one) ;  ; Long64_t fEstimate;  Number of entries to estimate histogram limits. ;  ; TEventList * fEventList;  ! Pointer to event selection list (if one) ;  ; TList * f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTree.html:60102,cache,cache,60102,doc/v632/classTTree.html,https://root.cern,https://root.cern/doc/v632/classTTree.html,6,['cache'],['cache']
Performance,"ns map<string,string> with all string attributes defined. const std::set<std::string>& transientAttributes() const; Return set of transient boolean attributes. Bool_t isConstant() const; Returns true if 'Constant' attribute is set. Bool_t IsSortable() const; Object is sortable in ROOT container class. Bool_t operator==(const RooAbsArg& other). Bool_t inRange(const char* ) const; Range management. Bool_t hasRange(const char* ) const; Has this argument a defined range (dummy interface always returns flase). Bool_t isShapeDirty() const; Dirty state accessor. Bool_t isValueDirty() const; Returns true of value has been invalidated by server value change. OperMode operMode() const; { return _operMode==AClean ? (flipAClean() ? ADirty : AClean ) : _operMode ; }. const RooArgSet* ownedComponents() const; { return _ownedComponents ; }. void setProhibitServerRedirect(Bool_t flag); { _prohibitServerRedirect = flag ; }. void operModeHook(); friend class RooSimCloneTool ;. {}. void optimizeDirtyHook(const RooArgSet* ); {}. void getParametersHook(const RooArgSet* , RooArgSet* , Bool_t ) const; {}. void getObservablesHook(const RooArgSet* , RooArgSet* ) const; {}. void setValueDirty() const; Dirty state modifiers. { setValueDirty(0) ; }. void setShapeDirty() const; { setShapeDirty(0) ; }. void clearValueDirty() const. void clearShapeDirty() const. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); { return kFALSE ; }. void serverNameChangeHook(const RooAbsArg* , const RooAbsArg* ); { }. void setExpensiveObjectCache(RooExpensiveObjectCache& cache); { _eocache = &cache ; }. void syncCache(const RooArgSet* nset = 0). void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE). void setTreeBranchStatus(TTree& t, Bool_t active). void fillTreeBranch(TTree& t). » Last changed: Mon Dec 7 13:45:31 2009 » Last generated: 2009-12-07 13:45; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsArg.html:39998,optimiz,optimizeDirtyHook,39998,root/html526/RooAbsArg.html,https://root.cern,https://root.cern/root/html526/RooAbsArg.html,1,['optimiz'],['optimizeDirtyHook']
Performance,"ns map<string,string> with all string attributes defined. const std::set<std::string>& transientAttributes() const; Return set of transient boolean attributes. Bool_t isConstant() const; Returns true if 'Constant' attribute is set. Bool_t IsSortable() const; Object is sortable in ROOT container class. Bool_t operator==(const RooAbsArg& other). Bool_t inRange(const char* ) const; Range management. Bool_t hasRange(const char* ) const; Has this argument a defined range (dummy interface always returns flase). Bool_t isShapeDirty() const; Dirty state accessor. Bool_t isValueDirty() const; Returns true of value has been invalidated by server value change. OperMode operMode() const; { return _operMode==AClean ? (flipAClean() ? ADirty : AClean ) : _operMode ; }. const RooArgSet* ownedComponents() const; { return _ownedComponents ; }. void setProhibitServerRedirect(Bool_t flag); { _prohibitServerRedirect = flag ; }. void operModeHook(); friend class RooSimCloneTool ;. {}. void optimizeDirtyHook(const RooArgSet* ); {}. void getParametersHook(const RooArgSet* , RooArgSet* , Bool_t ) const; {}. void getObservablesHook(const RooArgSet* , RooArgSet* ) const; {}. void setValueDirty() const; Dirty state modifiers. { setValueDirty(0) ; }. void setShapeDirty() const; { setShapeDirty(0) ; }. void clearValueDirty() const. void clearShapeDirty() const. const char* cacheUniqueSuffix() const; { return 0 ; }. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); { return kFALSE ; }. void serverNameChangeHook(const RooAbsArg* , const RooAbsArg* ); { }. void setExpensiveObjectCache(RooExpensiveObjectCache& cache); { _eocache = &cache ; }. Bool_t importWorkspaceHook(RooWorkspace& ); { return kFALSE ; }. void syncCache(const RooArgSet* nset = 0). void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE). void setTreeBranchStatus(TTree& t, Bool_t active). void fillTreeBranch(TTree& t). » Last changed: Mon Jul 4 15:21:16 2011 » Last generated: 2011-07-04 15:21;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooAbsArg.html:40566,optimiz,optimizeDirtyHook,40566,root/html530/RooAbsArg.html,https://root.cern,https://root.cern/root/html530/RooAbsArg.html,1,['optimiz'],['optimizeDirtyHook']
Performance,"ns map<string,string> with all string attributes defined. const std::set<std::string>& transientAttributes() const; Return set of transient boolean attributes. Bool_t isConstant() const; Returns true if 'Constant' attribute is set. Bool_t IsSortable() const; Object is sortable in ROOT container class. Bool_t operator==(const RooAbsArg& other). Bool_t inRange(const char* ) const; Range management. Bool_t hasRange(const char* ) const; Has this argument a defined range (dummy interface always returns flase). Bool_t isShapeDirty() const; Dirty state accessor. Bool_t isValueDirty() const; Returns true of value has been invalidated by server value change. OperMode operMode() const; { return _operMode==AClean ? (flipAClean() ? ADirty : AClean ) : _operMode ; }. const RooArgSet* ownedComponents() const; { return _ownedComponents ; }. void setProhibitServerRedirect(Bool_t flag); { _prohibitServerRedirect = flag ; }. void operModeHook(); friend class RooSimCloneTool ;. {}. void optimizeDirtyHook(const RooArgSet* ); {}. void getParametersHook(const RooArgSet* , RooArgSet* , Bool_t ) const; {}. void getObservablesHook(const RooArgSet* , RooArgSet* ) const; {}. void setValueDirty() const; Dirty state modifiers. { setValueDirty(0) ; }. void setShapeDirty() const; { setShapeDirty(0) ; }. void clearValueDirty() const. void clearShapeDirty() const. const char* cacheUniqueSuffix() const; { return 0 ; }. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); { return kFALSE ; }. void serverNameChangeHook(const RooAbsArg* , const RooAbsArg* ); { }. void setExpensiveObjectCache(RooExpensiveObjectCache& cache); { _eocache = &cache ; }. void syncCache(const RooArgSet* nset = 0). void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE). void setTreeBranchStatus(TTree& t, Bool_t active). void fillTreeBranch(TTree& t). » Last changed: Sat Oct 9 22:38:27 2010 » Last generated: 2010-10-09 22:38; This page has been automatically generated. For comments or sugg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsArg.html:40455,optimiz,optimizeDirtyHook,40455,root/html528/RooAbsArg.html,https://root.cern,https://root.cern/root/html528/RooAbsArg.html,1,['optimiz'],['optimizeDirtyHook']
Performance,"ns of this data set; static RooAbsData::StorageTypedefaultStorageType; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void setDefaultStorageType(RooAbsData::StorageType s). void claimVars(RooAbsData* ). Bool_t releaseVars(RooAbsData* ); If return value is true variables can be deleted. ~RooAbsData(); Destructor. void convertToVectorStore(); Convert tree-based storage to vector-based storage. Bool_t changeObservableName(const char* from, const char* to). void fill(). Int_t numEntries() const. void reset(). const RooArgSet* get(Int_t index) const. void cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0, Bool_t skipZeroWeights = kFALSE); Internal method -- Cache given set of functions with data. void resetCache(); Internal method -- Remove cached function values. void attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); Internal method -- Attach dataset copied with cache contents to copied instances of functions. void setArgStatus(const RooArgSet& set, Bool_t active). void setDirtyProp(Bool_t flag); Control propagation of dirty flags from observables in dataset. RooAbsData* reduce(const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); Create a reduced copy of this dataset. The caller takes ownership of the returned dataset. The following optional named arguments are accepted. SelectVars(const RooArgSet& vars) -- Only retain the listed observables in the output dataset; Cut(const char* expression) -- Only retain event surviving the given cut expression; Cut(const RooFormulaVar& expr) -- Only retain event surviving the given cut formula; CutRange(const char* name) -- Only retain events ins",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsData.html:15515,cache,cachedVars,15515,root/html534/RooAbsData.html,https://root.cern,https://root.cern/root/html534/RooAbsData.html,4,['cache'],"['cache', 'cachedVars']"
Performance,"ns the memory list of all files. TObject * FindObjectAnyFile(const char* name) const; Scan the memory lists of all files for an object with name. const char * FindObjectClassName(const char* name) const; Returns class name of a ROOT object including CINT globals. const char * FindObjectPathName(const TObject* obj) const; Return path name of obj somewhere in the //root/... path.; The function returns the first occurence of the object in the list; of folders. The returned string points to a static char array in TROOT.; If this function is called in a loop or recursively, it is the; user's responsability to copy this string in their area. TClass * FindSTLClass(const char* name, Bool_t load, Bool_t silent = kFALSE) const; return a TClass object corresponding to 'name' assuming it is an STL container.; In particular we looking for possible alternative name (default template; parameter, typedefs template arguments, typedefed name). TClass * GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE) const; Return pointer to class with name. Obsolete, use TClass::GetClass directly. TClass * GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE) const; Return pointer to class from its name. Obsolete, use TClass::GetClass directly; See TClass::GetClass. TColor * GetColor(Int_t color) const; Return address of color with index color. TCanvas * MakeDefCanvas() const; Return a default canvas. TDataType * GetType(const char* name, Bool_t load = kFALSE) const; Return pointer to type with name. TFile * GetFile(const char* name) const; Return pointer to file with name. TStyle * GetStyle(const char* name) const; Return pointer to style with name. TObject * GetFunction(const char* name) const; Return pointer to function with name. TFunctionTemplate * GetFunctionTemplate(const char* name). TGlobal * GetGlobal(const char* name, Bool_t load = kFALSE) const; Return pointer to global variable by name. If load is true force; reading of all currently defi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TROOT.html:25861,load,load,25861,root/html602/TROOT.html,https://root.cern,https://root.cern/root/html602/TROOT.html,4,['load'],['load']
Performance,"ns the pointer position. ;  ; virtual void QueryPointer (Window_t id, Window_t &rootw, Window_t &childw, Int_t &root_x, Int_t &root_y, Int_t &win_x, Int_t &win_y, UInt_t &mask);  Returns the root window the pointer is logically on and the pointer coordinates relative to the root window's origin. ;  ; virtual void RaiseWindow (Window_t id);  Raises the specified window to the top of the stack so that no sibling window obscures it. ;  ; virtual Pixmap_t ReadGIF (Int_t x0, Int_t y0, const char *file, Window_t id=0);  If id is NULL - loads the specified gif file at position [x0,y0] in the current window. ;  ; virtual Bool_t ReadPictureDataFromFile (const char *filename, char ***ret_data);  Reads picture data from file ""filename"" and store it in ""ret_data"". ;  ; virtual void RemoveWindow (ULongptr_t qwid);  Removes the created by Qt window ""qwid"". ;  ; virtual void ReparentWindow (Window_t id, Window_t pid, Int_t x, Int_t y);  If the specified window is mapped, ReparentWindow automatically performs an UnmapWindow request on it, removes it from its current position in the hierarchy, and inserts it as the child of the specified parent. ;  ; virtual Int_t RequestLocator (Int_t mode, Int_t ctyp, Int_t &x, Int_t &y);  Requests Locator position. ;  ; virtual Int_t RequestString (Int_t x, Int_t y, char *text);  Requests string: text is displayed and can be edited with Emacs-like keybinding. ;  ; virtual void RescaleWindow (Int_t wid, UInt_t w, UInt_t h);  Rescales the window ""wid"". ;  ; virtual Int_t ResizePixmap (Int_t wid, UInt_t w, UInt_t h);  Resizes the specified pixmap ""wid"". ;  ; virtual void ResizeWindow (Int_t wid);  Resizes the window ""wid"" if necessary. ;  ; virtual void ResizeWindow (Window_t id, UInt_t w, UInt_t h);  Changes the width and height of the specified window ""id"", not including its borders. ;  ; virtual UInt_t ScreenWidthMM () const;  Returns the width of the screen in millimeters. ;  ; virtual void SelectInput (Window_t id, UInt_t evmask);  Defines whic",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTVirtualX.html:22565,perform,performs,22565,doc/master/classTVirtualX.html,https://root.cern,https://root.cern/doc/master/classTVirtualX.html,1,['perform'],['performs']
Performance,"ns to activate normalization value caching; TVectorD*_mref; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; TIterator*_pdfItr!; RooListProxy_pdfList; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; RooMomentMorph::Setting_setting; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooMomentMorph.html:39611,cache,cache,39611,root/html530/RooMomentMorph.html,https://root.cern,https://root.cern/root/html530/RooMomentMorph.html,1,['cache'],['cache']
Performance,"ns(); define the options (their key words) that can be set in the option string; here the options valid for ALL MVA methods are declared.; know options: VariableTransform=None,Decorrelated,PCA to use transformed variables; instead of the original ones; VariableTransformType=Signal,Background which decorrelation matrix to use; in the method. Only the Likelihood; Method can make proper use of independent; transformations of signal and background; fNbinsMVAPdf = 50 Number of bins used to create a PDF of MVA; fNsmoothMVAPdf = 2 Number of times a histogram is smoothed before creating the PDF; fHasMVAPdfs create PDFs for the MVA outputs; V for Verbose output (!V) for non verbos; H for Help message. void ProcessBaseOptions(); the option string is decoded, for availabel options see ""DeclareOptions"". void CreateVariableTransforms(const TString& trafoDefinition). void DeclareCompatibilityOptions(). std::map<TString,Double_t> OptimizeTuningParameters(TString fomType = ""ROCIntegral"", TString fitType = ""FitGA""); call the Optimzier with the set of paremeters and ranges that; are meant to be tuned. void SetTuneParameters(map<TString,Double_t> tuneParameters); set the tuning parameters accoding to the argument; This is just a dummy .. have a look at the MethodBDT how you could; perhaps implment the same thing for the other Classifiers.. void TrainMethod(). void GetRegressionDeviation(UInt_t tgtNum, TMVA::Types::ETreeType type, Double_t& stddev, Double_t& stddev90Percent) const. void AddRegressionOutput(TMVA::Types::ETreeType type); prepare tree branch with the method's discriminating variable. void AddMulticlassOutput(TMVA::Types::ETreeType type); prepare tree branch with the method's discriminating variable. void NoErrorCalc(Double_t *const err, Double_t *const errUpper). Double_t GetMvaValue(const TMVA::Event *const ev, Double_t* err = 0, Double_t* errUpper = 0). void AddClassifierOutput(TMVA::Types::ETreeType type); prepare tree branch with the method's discriminating variable. v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MethodBase.html:21021,tune,tuned,21021,root/html528/TMVA__MethodBase.html,https://root.cern,https://root.cern/root/html528/TMVA__MethodBase.html,1,['tune'],['tuned']
Performance,ns; Parameters. dfltif result is not defined ; namename of the env variable . Definition at line 48 of file RWebWindowsManager.cxx. ◆ GetCodeVersion(). std::string ROOT::RWebWindowWSHandler::GetCodeVersion ; (; ). inlineoverrideprotectedvirtual . Method generate extra suffix for all kinds of loaded code. ; Reimplemented from THttpWSHandler.; Definition at line 38 of file RWebWindowWSHandler.hxx. ◆ GetDefaultPageContent(). TString ROOT::RWebWindowWSHandler::GetDefaultPageContent ; (; ). inlineoverridevirtual . returns content of default web-page THttpWSHandler interface ; Reimplemented from THttpWSHandler.; Definition at line 135 of file RWebWindowWSHandler.hxx. ◆ ProcessBatchHolder(). Bool_t ROOT::RWebWindowWSHandler::ProcessBatchHolder ; (; std::shared_ptr< THttpCallArg > & ; ). inlineoverrideprotectedvirtual . Method used to accept or reject root_batch_holder.js request. ; Reimplemented from THttpWSHandler.; Definition at line 33 of file RWebWindowWSHandler.hxx. ◆ ProcessWS(). Bool_t ROOT::RWebWindowWSHandler::ProcessWS ; (; THttpCallArg * ; arg). inlineoverridevirtual . Process websocket request - called from THttpServer thread THttpWSHandler interface. ; Implements THttpWSHandler.; Definition at line 142 of file RWebWindowWSHandler.hxx. ◆ VerifyDefaultPageContent(). void ROOT::RWebWindowWSHandler::VerifyDefaultPageContent ; (; std::shared_ptr< THttpCallArg > & ; arg). inlineoverrideprotectedvirtual . Method called when default page content is prepared for use By default no-cache header is provided. ; Reimplemented from THttpWSHandler.; Definition at line 41 of file RWebWindowWSHandler.hxx. Member Data Documentation. ◆ fWindow. RWebWindow& ROOT::RWebWindowWSHandler::fWindow. ! window reference ; Definition at line 123 of file RWebWindowWSHandler.hxx. gui/webdisplay/src/RWebWindowWSHandler.hxx; gui/webdisplay/src/RWebWindowsManager.cxx. ROOTRWebWindowWSHandler. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:00 (GVA Time) using Doxygen 1.9.8   ; . ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RWebWindowWSHandler.html:17664,cache,cache,17664,doc/master/classROOT_1_1RWebWindowWSHandler.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RWebWindowWSHandler.html,1,['cache'],['cache']
Performance,"ns; RooNDKeysPdf General N-dimensional non-parametric kernel estimation p.d.f; RooNLLVar Function representing (extended) -log(L) of p.d.f and dataset; RooNameReg String name registry; RooNameSet A sterile version of RooArgSet, containing only the names of the contained RooAbsArgs; RooNonCPEigenDecay PDF to model CP-violating decays to final states which are not CP eigenstates; RooNormSetCache Management tool for tracking sets of similar integration/normalization sets; RooNovosibirsk Novosibirsk PDF; RooNumCdf Numeric calculator for CDF for a given PDF; RooNumConvPdf Operator PDF implementing numeric convolution of 2 input PDFs; RooNumConvolution Operator PDF implementing numeric convolution of 2 input functions; RooNumGenConfig Numeric (MC) Event generator configuration ; RooNumGenFactory Numeric Generator factory; RooNumIntConfig Numeric Integrator configuration ; RooNumIntFactory Numeric Integrator factory; RooNumRunningInt Numeric calculator for running integral of a given function; RooNumber wrapper class for portable numerics; RooObjCacheManager Cache manager for generic caches that contain RooAbsArg objects; RooParamBinning Binning specification with ranges parameterized by external RooAbsReal functions; RooParametricStepFunction Parametric Step Function Pdf; RooPlot Plot frame and container for graphics objects; RooPlotable Abstract interface for plotable objects in a RooPlot; RooPoisson A Poisson PDF; RooPolyVar Polynomial function; RooPolynomial Polynomial PDF; RooPrintable Interface for printable objects; RooProdGenContext Context for efficient generation of a a dataset from a RooProdPdf; RooProdPdf PDF representing a product of PDFs; RooProduct Product of RooAbsReal and/or RooAbsCategory terms; RooProfileLL Real-valued function representing profile likelihood of external (likelihood) function; RooProjectedPdf Operator p.d.f calculating projection of another p.d.f; RooPullVar Calculation of pull of measurement w.r.t a truth value; RooQuasiRandomGenerator Q",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html524/ClassIndex.html:38347,cache,caches,38347,root/html524/ClassIndex.html,https://root.cern,https://root.cern/root/html524/ClassIndex.html,1,['cache'],['caches']
Performance,"ns;  CrossValidation (TString jobName, TMVA::DataLoader *dataloader, TFile *outputFile, TString options);  ;  CrossValidation (TString jobName, TMVA::DataLoader *dataloader, TString options);  ;  ~CrossValidation ();  ; void Evaluate ();  Does training, test set evaluation and performance evaluation of using cross-evalution. ;  ; Factory & GetFactory ();  ; UInt_t GetNumFolds ();  ; const std::vector< CrossValidationResult > & GetResults () const;  ; TString GetSplitExpr ();  ; void InitOptions ();  ; virtual TClass * IsA () const;  ; void ParseOptions ();  Method to parse the internal option string. ;  ; void SetNumFolds (UInt_t i);  ; void SetSplitExpr (TString splitExpr);  ; virtual void Streamer (TBuffer &);  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TMVA::Envelope;  ~Envelope ();  Default destructor. ;  ; virtual void BookMethod (TString methodname, TString methodtitle, TString options="""");  Method to book the machine learning method to perform the algorithm. ;  ; virtual void BookMethod (Types::EMVA method, TString methodtitle, TString options="""");  Method to book the machine learning method to perform the algorithm. ;  ; DataLoader * GetDataLoader ();  Method to get the pointer to TMVA::DataLoader object. ;  ; TFile * GetFile ();  Method to get the pointer to TFile object. ;  ; std::vector< OptionMap > & GetMethods ();  Method get the Booked methods in a option map object. ;  ; Bool_t HasMethod (TString methodname, TString methodtitle);  function to check methods booked ;  ; Bool_t IsModelPersistence ();  Method to see if the algorithm model is saved in xml or serialized files. ;  ; Bool_t IsSilentFile ();  Method to see if a file is available to save results. ;  ; Bool_t IsVerbose ();  Method to see if the algorithm should print extra information. ;  ; void SetDataLoader (DataLoader *dalaloader);  Method to set the pointer to TMVA::DataLoader object. ;  ; v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1CrossValidation.html:2218,perform,perform,2218,doc/master/classTMVA_1_1CrossValidation.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1CrossValidation.html,1,['perform'],['perform']
Performance,"nsDecl);; 5711 return true;; 5712 }; 5713 bool VisitClassTemplateSpecializationDecl(ClassTemplateSpecializationDecl* specDecl) {; 5714 // We want to enable the external lookup for this specialization; 5715 // because we can provide a definition for it!; 5716 if (specDecl->getTemplateSpecializationKind() == TSK_ExplicitSpecialization); 5717 //SpecSet.insert(specDecl);; 5718 specDecl->setHasExternalLexicalStorage();; 5719 ; 5720 // No need to recurse. On the contrary, recursing is actively harmful:; 5721 // NOTE: must not recurse to prevent this visitor from triggering loading from; 5722 // the external AST source (i.e. autoloading). This would be triggered right here,; 5723 // before autoloading is even set up, as rootmap file parsing happens before that.; 5724 // Even if autoloading is off and has no effect, triggering loading from external; 5725 // AST source resets the flag setHasExternalLexicalStorage(), hiding this specialization; 5726 // from subsequent autoloads!; 5727 return false;; 5728 }; 5729 private:; 5730 std::unordered_set<const NamespaceDecl*>& fNSSet;; 5731 };; 5732}; 5733 ; 5734////////////////////////////////////////////////////////////////////////////////; 5735/// Load map between class and library. If rootmapfile is specified a; 5736/// specific rootmap file can be added (typically used by ACLiC).; 5737/// In case of error -1 is returned, 0 otherwise.; 5738/// The interpreter uses this information to automatically load the shared; 5739/// library for a class (autoload mechanism), see the AutoLoad() methods below.; 5740 ; 5741Int_t TCling::LoadLibraryMap(const char* rootmapfile); 5742{; 5743 if (rootmapfile && *rootmapfile && !requiresRootMap(rootmapfile)); 5744 return 0;; 5745 ; 5746 R__LOCKGUARD(gInterpreterMutex);; 5747 ; 5748 // open the [system].rootmap files; 5749 if (!fMapfile) {; 5750 fMapfile = new TEnv();; 5751 fMapfile->IgnoreDuplicates(kTRUE);; 5752 fRootmapFiles = new TObjArray;; 5753 fRootmapFiles->SetOwner();; 5754 InitRootmapFile("".",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:223079,load,loading,223079,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['load'],['loading']
Performance,"nsert object before object before in the list. void Clear(Option_t* option); Remove all objects from the list. Does not delete the objects unless; the THashList is the owner (set via SetOwner()). void Delete(Option_t* option = """"); Delete all TDataMember object files. TObject * FindObject(const char* name) const; Specialize FindObject to do search for the; a data member just by name or create it if its not already in the list. TDictionary * Find(TListOfDataMembers::DeclId_t id) const; Return (after creating it if necessary) the TDataMember; describing the data member corresponding to the Decl 'id'. TDictionary * Get(TListOfDataMembers::DeclId_t id); Return (after creating it if necessary) the TDataMember; describing the data member corresponding to the Decl 'id'. TDictionary * Get(DataMemberInfo_t* info, bool skipChecks = kFALSE); Return (after creating it if necessary) the TDataMember; describing the data member corresponding to the Decl 'id'.; The skipChecks flag controls the consistency checks performed inspecting; the AST. In some cases, we explicitely alter the datamembers in the; typesystem with respect to the AST and therefore we must not enforce; consistency. void UnmapObject(TObject* obj); Remove a pair<id, object> from the map of data members and their ids. void RecursiveRemove(TObject* obj); Remove object from this collection and recursively remove the object; from all other objects (and collections).; This function overrides TCollection::RecursiveRemove that calls; the Remove function. THashList::Remove cannot be called because; it uses the hash value of the hash table. This hash value; is not available anymore when RecursiveRemove is called from; the TObject destructor. TObject* Remove(TObject* obj); Remove object from the list. TObject* Remove(TObjLink* lnk); Remove object via its objlink from the list. void Load(); Load all the DataMembers known to the intepreter for the scope 'fClass'; into this collection. void Streamer(TBuffer& ); Stream an object ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TListOfDataMembers.html:14152,perform,performed,14152,root/html604/TListOfDataMembers.html,https://root.cern,https://root.cern/root/html604/TListOfDataMembers.html,2,['perform'],['performed']
Performance,"nsertauto Insert(const std::string &string) -> decltype(fStrings)::const_iteratorInserts the input string in the cache and returns an iterator to the cached string.Definition RDFUtils.cxx:444; ROOT::RDF::RDataSourceRDataSource defines an API that RDataFrame can use to read arbitrary data formats.Definition RDataSource.hxx:109; ROOT::RDF::RDataSource::HasColumnvirtual bool HasColumn(std::string_view colName) const =0Checks if the dataset has a certain column.; ROOT::RDF::RDataSource::GetTypeNamevirtual std::string GetTypeName(std::string_view colName) const =0Type of a column as a string, e.g.; TBranchElementA Branch for the case of an object.Definition TBranchElement.h:39; TBranchElement::GetClassvirtual TClass * GetClass() constDefinition TBranchElement.h:187; TBranch::Classstatic TClass * Class(); TClassRefTClassRef is used to implement a permanent reference to a TClass object.Definition TClassRef.h:28; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:3035; TInterpreter::EErrorCodeEErrorCodeDefinition TInterpreter.h:72; TInterpreter::kNoError@ kNoErrorDefinition TInterpreter.h:73; TLeafA TLeaf describes individual elements of a TBranch See TBranch structure in TTree.Definition TLeaf.h:57; TLeaf::GetTypeNamevirtual const char * GetTypeName() constDefinition TLeaf.h:139; TLeaf::GetLeafCountvirtual TLeaf * GetLeafCount() constIf this leaf stores a variable-sized array or a multi-dimensional array whose last dimension has vari...Definition TLeaf.h:121; TLeaf::GetLenStaticvirtual Int_t GetLenStatic() constReturn the fixed length of this leaf.Definition TLeaf.h:132; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; TTree::FindBranchvirtual TBranch * FindBranch(const char *name)Return the branch that correspond to the p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDFUtils_8cxx_source.html:21287,load,load,21287,doc/master/RDFUtils_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RDFUtils_8cxx_source.html,1,['load'],['load']
Performance,"nserted object to back to drawing stack if requested; 2846 if (pc.getInt(""moveToBack"") && frame->numItems()>1) {; 2847 frame->drawBefore(frame->getObject(0)->GetName(), frame->getCurve()->GetName());; 2848 }; 2849 ; 2850 ; 2851 return frame ;; 2852}; 2853 ; 2854 ; 2855 ; 2856 ; 2857////////////////////////////////////////////////////////////////////////////////; 2858/// Utility function for plotOn(), perform general sanity check on frame to ensure safe plotting operations; 2859 ; 2860bool RooAbsReal::plotSanityChecks(RooPlot* frame) const; 2861{; 2862 // check that we are passed a valid plot frame to use; 2863 if(nullptr == frame) {; 2864 coutE(Plotting) << ClassName() << ""::"" << GetName() << "":plotOn: frame is null"" << std::endl;; 2865 return true;; 2866 }; 2867 ; 2868 // check that this frame knows what variable to plot; 2869 RooAbsReal* var = frame->getPlotVar() ;; 2870 if(!var) {; 2871 coutE(Plotting) << ClassName() << ""::"" << GetName(); 2872 << "":plotOn: frame does not specify a plot variable"" << std::endl;; 2873 return true;; 2874 }; 2875 ; 2876 // check that the plot variable is not derived; 2877 if(!dynamic_cast<RooAbsRealLValue*>(var)) {; 2878 coutE(Plotting) << ClassName() << ""::"" << GetName() << "":plotOn: cannot plot variable \""""; 2879 << var->GetName() << ""\"" of type "" << var->ClassName() << std::endl;; 2880 return true;; 2881 }; 2882 ; 2883 // check if we actually depend on the plot variable; 2884 if(!this->dependsOn(*var)) {; 2885 coutE(Plotting) << ClassName() << ""::"" << GetName() << "":plotOn: WARNING: variable is not an explicit dependent: ""; 2886 << var->GetName() << std::endl;; 2887 }; 2888 ; 2889 return false ;; 2890}; 2891 ; 2892 ; 2893 ; 2894 ; 2895////////////////////////////////////////////////////////////////////////////////; 2896/// Utility function for plotOn() that constructs the set of; 2897/// observables to project when plotting ourselves as function of; 2898/// 'plotVar'. 'allVars' is the list of variables that must be; 2899/// projecte",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8cxx_source.html:124686,perform,perform,124686,doc/master/RooAbsReal_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html,1,['perform'],['perform']
Performance,"nset) const; virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; static voidRooAbsReal::globalSelectComp(Bool_t flag); voidRooAbsArg::graphVizAddConnections(set<std::pair<RooAbsArg*,RooAbsArg*> >&); intidxmax(const double& m) const; intidxmin(const double& m) const; Int_tij(const Int_t& i, const Int_t& j) const; static Bool_tRooAbsArg::inhibitDirty(); voidinitialize(); TStringRooAbsReal::integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset = 0, const char* rangeName = 0, Bool_t omitEmpty = kFALSE) const; Bool_tRooAbsReal::isSelectedComp() const; virtual Bool_tRooAbsReal::isValid() const; virtual Bool_tRooAbsReal::isValidReal(Double_t value, Bool_t printError = kFALSE) const; voidRooAbsReal::makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; voidTObject::MakeZombie(); Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c, const RooArgProxy& d) const; Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooArgSet& params, Bool_t showConstants = kFALSE, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooMomentMorph.html:32756,optimiz,optimizeDirtyHook,32756,root/html526/RooMomentMorph.html,https://root.cern,https://root.cern/root/html526/RooMomentMorph.html,5,['optimiz'],['optimizeDirtyHook']
Performance,"nset, const RooArgSet *iset, const char *isetRangeName=nullptr) const;  ; void doEvalImpl (RooAbsArg const *caller, const RooProdPdf::CacheElem &cache, RooFit::EvalContext &) const;  Evaluate product of PDFs in batch mode. ;  ; double evaluate () const override;  Calculate current value of object. ;  ; void factorizeProduct (const RooArgSet &normSet, const RooArgSet &intSet, RooLinkedList &termList, RooLinkedList &normList, RooLinkedList &impDepList, RooLinkedList &crossDepList, RooLinkedList &intList) const;  Factorize product in irreducible terms for given choice of integration/normalization. ;  ; std::unique_ptr< RooArgSet > fillNormSetForServer (RooArgSet const &normSet, RooAbsArg const &server) const;  ; RooAbsGenContext * genContext (const RooArgSet &vars, const RooDataSet *prototype=nullptr, const RooArgSet *auxProto=nullptr, bool verbose=false) const override;  Return generator context optimized for generating events from product p.d.f.s. ;  ; CacheElem * getCacheElem (RooArgSet const *nset) const;  The cache manager. ;  ; void getParametersHook (const RooArgSet *, RooArgSet *, bool stripDisconnected) const override;  ; Int_t getPartIntList (const RooArgSet *nset, const RooArgSet *iset, const char *isetRangeName=nullptr) const;  Return list of (partial) integrals of product terms for integration of p.d.f over observables iset while normalization over observables nset. ;  ; void groupProductTerms (std::list< std::vector< RooArgSet * > > &groupedTerms, RooArgSet &outerIntDeps, const RooLinkedList &terms, const RooLinkedList &norms, const RooLinkedList &imps, const RooLinkedList &ints, const RooLinkedList &cross) const;  Group product into terms that can be calculated independently. ;  ; void initializeFromCmdArgList (const RooArgSet &fullPdfSet, const RooLinkedList &l);  Initialize RooProdPdf configuration from given list of RooCmdArg configuration arguments and set of 'regular' p.d.f.s in product. ;  ; std::unique_ptr< RooAbsReal > makeCondPdfRatioCorr (RooAbs",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooProdPdf.html:63662,cache,cache,63662,doc/master/classRooProdPdf.html,https://root.cern,https://root.cern/doc/master/classRooProdPdf.html,1,['cache'],['cache']
Performance,"nsetCache! Normalization/Integration set manager; vector<RooAbsCacheElement*>RooCacheManager<RooAbsCacheElement>::_object! Payload; Bool_t_optCacheModeSeen!; RooArgSet*_optCacheObservables! current optCacheObservables; RooAbsArg*RooAbsCache::_ownerPointer to owning RooAbsArg; Int_tRooCacheManager<RooAbsCacheElement>::_size! Actual use; Bool_tRooCacheManager<RooAbsCacheElement>::_wired! In wired mode, there is a single payload which is returned always. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooObjCacheManager(RooAbsArg* owner = 0, Int_t maxSize = 2, Bool_t clearCacheOnServerRedirect = kTRUE, Bool_t allowOptimize = kFALSE); Constructor of object cache manager for given owner. If clearCacheOnServerRedirect is true; all cache elements will be cleared when a server redirect is intercepted by the cache manager.; This is the default strategy and should only be overridden when you really understand; what you're doing as properly implementing server redirect in cache elements can get very; complicated, especially if there are (cyclical) reference back to the owning object. RooObjCacheManager(const RooObjCacheManager& other, RooAbsArg* owner = 0); Copy constructor. ~RooObjCacheManager(); Destructor. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Intercept server redirect calls. If clearOnRedirect was set, sterilize; the cache (i.e. keep the structure but delete all contents). If not; forward serverRedirect to cache elements. void operModeHook(); Intercept changes to cache operation mode and forward to cache elements. void optimizeCacheMode(const RooArgSet& , RooArgSet& , RooLinkedList& ); Intercept calls to perform automatic optimization of cache mode operation.; Forward calls to existing cache elements and save configuration of; cache mode optimization so that it can be applied on new cache elements; upon insertion. void sterilize(). void insertObjectHook(RooAbsCacheElement& ); Set owner li",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooObjCacheManager.html:4520,cache,cache,4520,root/html602/RooObjCacheManager.html,https://root.cern,https://root.cern/root/html602/RooObjCacheManager.html,4,['cache'],['cache']
Performance,"nsformation; # - Type of Architecture (e.g. CPU, GPU, Standard); ; # We can then book the DL method using the built option string; if useDL:; useDLGPU = ROOT.gSystem.GetFromPipe(""root-config --has-tmva-gpu"") == ""yes""; ; # Define DNN layout; # Define Training strategies; # one can catenate several training strategies; training1 = ROOT.TString(; ""LearningRate=1e-3,Momentum=0.9,""; ""ConvergenceSteps=10,BatchSize=128,TestRepetitions=1,""; ""MaxEpochs=20,WeightDecay=1e-4,Regularization=None,""; ""Optimizer=ADAM,ADAM_beta1=0.9,ADAM_beta2=0.999,ADAM_eps=1.E-7,"" # ADAM default parameters; ""DropConfig=0.0+0.0+0.0+0.""; ); # training2 = ROOT.TString(""LearningRate=1e-3,Momentum=0.9""; # ""ConvergenceSteps=10,BatchSize=128,TestRepetitions=1,""; # ""MaxEpochs=20,WeightDecay=1e-4,Regularization=None,""; # ""Optimizer=SGD,DropConfig=0.0+0.0+0.0+0.""); ; # General Options.; dnnMethodName = ROOT.TString(""DNN_CPU""); ; if useDLGPU:; arch = ""GPU""; dnnMethodName = ""DNN_GPU""; else:; arch = ""CPU""; ; factory.BookMethod(; loader,; TMVA.Types.kDL,; dnnMethodName,; H=False,; V=True,; ErrorStrategy=""CROSSENTROPY"",; VarTransform=""G"",; WeightInitialization=""XAVIER"",; InputLayout=""1|1|7"",; BatchLayout=""1|128|7"",; Layout=""DENSE|64|TANH,DENSE|64|TANH,DENSE|64|TANH,DENSE|64|TANH,DENSE|1|LINEAR"",; TrainingStrategy=training1,; Architecture=arch,; ); ; # Keras DL; if useKeras:; ROOT.Info(""TMVA_Higgs_Classification"", ""Building Deep Learning keras model""); # create Keras model with 4 layers of 64 units and relu activations; import tensorflow; from tensorflow.keras.models import Sequential; from tensorflow.keras.optimizers import Adam; from tensorflow.keras.layers import Input, Dense; ; model = Sequential(); model.add(Dense(64, activation=""relu"", input_dim=7)); model.add(Dense(64, activation=""relu"")); model.add(Dense(64, activation=""relu"")); model.add(Dense(64, activation=""relu"")); model.add(Dense(2, activation=""sigmoid"")); model.compile(loss=""binary_crossentropy"", optimizer=Adam(learning_rate=0.001), weighted_metrics=",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__Higgs__Classification_8py.html:66024,load,loader,66024,doc/master/TMVA__Higgs__Classification_8py.html,https://root.cern,https://root.cern/doc/master/TMVA__Higgs__Classification_8py.html,1,['load'],['loader']
Performance,"nsibility of the caller to free it... it is useful for example to pass it to the creator of TBuffer src is the original buffer with the record (header+compressed data) *dest is the inflated buffer (including the header) ; Definition at line 853 of file TTreeCacheUnzip.cxx. ◆ UnzipCache(). Int_t TTreeCacheUnzip::UnzipCache ; (; Int_t ; index). This inflates a basket in the cache. ; . passing the data to a new buffer that will only wait there to be read... This function is responsible to update corresponding elements in fUnzipStatus, fUnzipChunks and fUnzipLen. Since we use atomic variables in fUnzipStatus to exclusively unzip the basket, we must update fUnzipStatus after fUnzipChunks and fUnzipLen and make sure fUnzipChunks and fUnzipLen are ready before main thread fetch the data. ; Definition at line 526 of file TTreeCacheUnzip.cxx. ◆ UpdateBranches(). void TTreeCacheUnzip::UpdateBranches ; (; TTree * ; tree). overridevirtual . update pointer to current Tree and recompute pointers to the branches in the cache ; Reimplemented from TTreeCache.; Definition at line 392 of file TTreeCacheUnzip.cxx. Member Data Documentation. ◆ fAsyncReading. bool TTreeCacheUnzip::fAsyncReading. protected . Definition at line 81 of file TTreeCacheUnzip.h. ◆ fCompBuffer. char* TTreeCacheUnzip::fCompBuffer. private . Definition at line 112 of file TTreeCacheUnzip.h. ◆ fCompBufferSize. Int_t TTreeCacheUnzip::fCompBufferSize. private . Definition at line 113 of file TTreeCacheUnzip.h. ◆ fCycle. Int_t TTreeCacheUnzip::fCycle. protected . Definition at line 83 of file TTreeCacheUnzip.h. ◆ fEmpty. bool TTreeCacheUnzip::fEmpty. protected . Definition at line 82 of file TTreeCacheUnzip.h. ◆ fgParallel. TTreeCacheUnzip::EParUnzipMode TTreeCacheUnzip::fgParallel = TTreeCacheUnzip::kDisable. staticprotected . Indicate if we want to activate the parallelism. ; Definition at line 88 of file TTreeCacheUnzip.h. ◆ fgRelBuffSize. Double_t TTreeCacheUnzip::fgRelBuffSize = .5. staticprotected . This is the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCacheUnzip.html:38639,cache,cache,38639,doc/v632/classTTreeCacheUnzip.html,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html,1,['cache'],['cache']
Performance,"nsibility of the caller to free it... it is useful for example to pass it to the creator of TBuffer src is the original buffer with the record (header+compressed data) *dest is the inflated buffer (including the header) ; Definition at line 854 of file TTreeCacheUnzip.cxx. ◆ UnzipCache(). Int_t TTreeCacheUnzip::UnzipCache ; (; Int_t ; index). This inflates a basket in the cache. ; . passing the data to a new buffer that will only wait there to be read... This function is responsible to update corresponding elements in fUnzipStatus, fUnzipChunks and fUnzipLen. Since we use atomic variables in fUnzipStatus to exclusively unzip the basket, we must update fUnzipStatus after fUnzipChunks and fUnzipLen and make sure fUnzipChunks and fUnzipLen are ready before main thread fetch the data. ; Definition at line 527 of file TTreeCacheUnzip.cxx. ◆ UpdateBranches(). void TTreeCacheUnzip::UpdateBranches ; (; TTree * ; tree). overridevirtual . update pointer to current Tree and recompute pointers to the branches in the cache ; Reimplemented from TTreeCache.; Definition at line 393 of file TTreeCacheUnzip.cxx. Member Data Documentation. ◆ fAsyncReading. bool TTreeCacheUnzip::fAsyncReading. protected . Definition at line 81 of file TTreeCacheUnzip.h. ◆ fCompBuffer. char* TTreeCacheUnzip::fCompBuffer. private . Definition at line 112 of file TTreeCacheUnzip.h. ◆ fCompBufferSize. Int_t TTreeCacheUnzip::fCompBufferSize. private . Definition at line 113 of file TTreeCacheUnzip.h. ◆ fCycle. Int_t TTreeCacheUnzip::fCycle. protected . Definition at line 83 of file TTreeCacheUnzip.h. ◆ fEmpty. bool TTreeCacheUnzip::fEmpty. protected . Definition at line 82 of file TTreeCacheUnzip.h. ◆ fgParallel. TTreeCacheUnzip::EParUnzipMode TTreeCacheUnzip::fgParallel = TTreeCacheUnzip::kDisable. staticprotected . Indicate if we want to activate the parallelism. ; Definition at line 88 of file TTreeCacheUnzip.h. ◆ fgRelBuffSize. Double_t TTreeCacheUnzip::fgRelBuffSize = .5. staticprotected . This is the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeCacheUnzip.html:38713,cache,cache,38713,doc/master/classTTreeCacheUnzip.html,https://root.cern,https://root.cern/doc/master/classTTreeCacheUnzip.html,1,['cache'],['cache']
Performance,"nsient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManager_cacheMgr! The cache manager; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooRealProxy_effEfficiency function; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; RooArgSet*_fixedNset! Fixed normalization set overriding default normalization set (if provided); Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_local",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooEffProd.html:41760,cache,cache,41760,root/html602/RooEffProd.html,https://root.cern,https://root.cern/root/html602/RooEffProd.html,4,['cache'],['cache']
Performance,"nsient! Transient boolean attributes (not copied in ctor); UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManager_cacheMgr! The cache manager; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooRealProxy_effEfficiency function; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; RooArgSet*_fixedNset! Fixed normalization set overriding default normalization set (if provided); Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooEffProd.html:38940,cache,cache,38940,root/html532/RooEffProd.html,https://root.cern,https://root.cern/root/html532/RooEffProd.html,4,['cache'],['cache']
Performance,"nsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Bool_t_useDefaultGenUse default or distributed event generator; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooProdPdf(); Default constructor. RooProdPdf(const char* name, const char* title, Double_t cutOff = 0); Dummy constructor. RooProdPdf(const char* name, const char* title, RooAbsPdf& pdf1, RooAbsPdf& pdf2, Double_t cutOff = 0); Constructor with 2 PDFs (most frequent use case). The optional cutOff parameter can be used as a speed optimization if; one or more of the PDF have sizable regions with very small values,; which would pull the entire product of PDFs to zero in those regions. After each PDF multiplication, the running product is compared with; the cutOff parameter. If the running product is smaller than the; cutOff value, the product series is terminated and remaining PDFs; are not evaluated. There is no magic value of the cutOff, the user should experiment; to find the appropriate balance between speed and precision.; If a cutoff is specified, the PDFs most likely to be small should; be put first in the product. The default cutOff value is zero. RooProdPdf(const char* name, const char* title, const RooArgList& pdfList, Double_t cutOff = 0); Constructor from a list of PDFs. The optional cutOff parameter can be used as a speed optimization if; one or more of the PDF have sizable regions with very small values,; which would pull the entire product of PDFs to zero in those regions. After each PDF multiplication, the running product is compared with; the cut",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooProdPdf.html:49203,optimiz,optimization,49203,root/html602/RooProdPdf.html,https://root.cern,https://root.cern/root/html602/RooProdPdf.html,4,['optimiz'],['optimization']
Performance,"nsional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302. It is part of the MathCore library. The user can control the relative and absolute tolerance and the maximum allowed number of function evaluation.; 13.8.3.4 ROOT::Math::GSLMCIntegrator; It is a class for performing numerical integration of a multidimensional function. It uses the numerical integration algorithms of GSL, which reimplements the algorithms used in the QUADPACK, a numerical integration package written in Fortran. Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges. For a detail description of the GSL methods visit the GSL users guide. Specific configuration options (documented in the GSL user guide) for the ROOT::Math::GSLMCIntegration can be set directly in the class, or when using it via the ROOT::Math::IntegratorMultiDim interface, can be defined using the ROOT::Math::IntegratorMultiDimOptions.; 13.9 Function Derivation; There are in ROOT only two classes to perform numerical derivation. One of them is in the MathCore library while the other is in the MathMore wrapping an integration function from the GSL library. * RichardsonDerivator: Implements the Richardson method for numerical integration. It can calculate up to the third derivative of a function. * GSLDerivator of MathMore based on GSL.; 13.10 Numerical Minimization; The algorithms provided by ROOT for numerical integration are implemented following the hierarchy shown in the next image. The left branch of classes are used for one dimensional minimization, while the right one is used for multidimensional minimization. In the case of multidimensional minimization we have also the classes TMinuitMinimizer implemented using TMinuit, TFumiliMinimizer implemented using TFumili for least square or likelihood minimizations. We encourage the use of the GSL algorithms for one dimensional minimization and Minuit2 (or the old versionMinuit) for multi dimensional minimization. N",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:713348,perform,perform,713348,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['perform'],['perform']
Performance,"nsions to activate normalization value caching; RooResolutionModel*_model! Original resolution model; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInter",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooAbsAnaConvPdf.html:41719,cache,cache,41719,root/html530/RooAbsAnaConvPdf.html,https://root.cern,https://root.cern/root/html530/RooAbsAnaConvPdf.html,1,['cache'],['cache']
Performance,"nsiveObjectCache(RooExpensiveObjectCache& cache); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); const map<std::string,std::string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; const set<std::string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; RooFIterRooAbsArg::valueClientMIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidwriteToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsString.html:14579,cache,cache,14579,root/html532/RooAbsString.html,https://root.cern,https://root.cern/root/html532/RooAbsString.html,1,['cache'],['cache']
Performance,"nsiveObjectCache* RooAbsArg::_eocache {nullptr}. mutableprotected . Prohibit server redirects – Debugging tool. ; Definition at line 696 of file RooAbsArg.h. ◆ _fast. bool RooAbsArg::_fast = false. mutableprotected . Definition at line 689 of file RooAbsArg.h. ◆ _inhibitDirty. bool RooAbsArg::_inhibitDirty. staticprotected . Definition at line 668 of file RooAbsArg.h. ◆ _isConstant. bool RooAbsArg::_isConstant = false. protected . De-duplicated name pointer. This will be equal for all objects with the same name. ; Definition at line 699 of file RooAbsArg.h. ◆ _localNoInhibitDirty. bool RooAbsArg::_localNoInhibitDirty = false. mutableprotected . Cached isConstant status. ; Definition at line 701 of file RooAbsArg.h. ◆ _myws. RooWorkspace* RooAbsArg::_myws = nullptr. mutableprotected . Prevent 'AlwaysDirty' mode for this node. ; Definition at line 706 of file RooAbsArg.h. ◆ _namePtr. const TNamed* RooAbsArg::_namePtr = nullptr. mutableprotected . Pointer to global cache manager for any expensive components created by this object. ; Definition at line 698 of file RooAbsArg.h. ◆ _operMode. OperMode RooAbsArg::_operMode = Auto. mutableprotected . Definition at line 688 of file RooAbsArg.h. ◆ _ownedComponents. RooArgSet* RooAbsArg::_ownedComponents = nullptr. protected . Definition at line 692 of file RooAbsArg.h. ◆ _prohibitServerRedirect. bool RooAbsArg::_prohibitServerRedirect = false. mutableprotected . Set of owned component. ; Definition at line 694 of file RooAbsArg.h. ◆ _proxyList. RooRefArray RooAbsArg::_proxyList. protected . Definition at line 611 of file RooAbsArg.h. ◆ _proxyListCache. ProxyListCache RooAbsArg::_proxyListCache. protected . Definition at line 664 of file RooAbsArg.h. ◆ _serverList. RefCountList_t RooAbsArg::_serverList. protected . Definition at line 606 of file RooAbsArg.h. ◆ _shapeDirty. bool RooAbsArg::_shapeDirty = true. mutableprotected . Definition at line 686 of file RooAbsArg.h. ◆ _stringAttrib. std::map<std::string,std::string> RooAbsAr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsArg.html:109701,cache,cache,109701,doc/master/classRooAbsArg.html,https://root.cern,https://root.cern/doc/master/classRooAbsArg.html,1,['cache'],['cache']
Performance,"nspector::TAutoInspectorTAutoInspector(TBrowser *b)Definition TClass.cxx:906; TAutoInspector::~TAutoInspectorvirtual ~TAutoInspector()Definition TClass.cxx:911; TAutoInspector::fCountInt_t fCountDefinition TClass.cxx:903; TAutoInspector::Inspectvoid Inspect(TClass *cl, const char *parent, const char *name, const void *addr, Bool_t isTransient) overrideThis method is called from ShowMembers() via AutoBrowse().Definition TClass.cxx:920; TBaseClassEach class (see TClass) has a linked list of its base class(es).Definition TBaseClass.h:33; TBaseClass::GetDeltaInt_t GetDelta()Get offset from ""this"" to part of base class.Definition TBaseClass.cxx:75; TBaseClass::IsSTLContainerROOT::ESTLType IsSTLContainer()Return which type (if any) of STL container the data member is.Definition TBaseClass.cxx:101; TBaseClass::PropertyLong_t Property() const overrideGet property description word. For meaning of bits see EProperty.Definition TBaseClass.cxx:134; TBaseClass::GetClassPointerTClass * GetClassPointer(Bool_t load=kTRUE)Get pointer to the base class TClass.Definition TBaseClass.cxx:63; TBrowserUsing a TBrowser one can browse all ROOT objects.Definition TBrowser.h:37; TBufferBuffer base class used for serializing objects.Definition TBuffer.h:43; TBuildRealDataDefinition TClass.cxx:751; TBuildRealData::Inspectvoid Inspect(TClass *cl, const char *parent, const char *name, const void *addr, Bool_t isTransient) overrideThis method is called from ShowMembers() via BuildRealdata().Definition TClass.cxx:771; TBuildRealData::fRealDataClassTClass * fRealDataClassDefinition TClass.cxx:755; TBuildRealData::fRealDataObjectvoid * fRealDataObjectDefinition TClass.cxx:754; TBuildRealData::TBuildRealDataTBuildRealData(void *obj, TClass *cl)Definition TClass.cxx:758; TClassGeneratorObjects following this interface can be passed onto the TROOT object to implement a user customized w...Definition TClassGenerator.h:28; TClassGenerator::GetClassvirtual TClass * GetClass(const char *classname, Bool_t lo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:304112,load,load,304112,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['load'],['load']
Performance,"nspector::TAutoInspectorTAutoInspector(TBrowser *b)Definition TClass.cxx:973; TAutoInspector::~TAutoInspectorvirtual ~TAutoInspector()Definition TClass.cxx:978; TAutoInspector::fCountInt_t fCountDefinition TClass.cxx:970; TAutoInspector::Inspectvoid Inspect(TClass *cl, const char *parent, const char *name, const void *addr, Bool_t isTransient) overrideThis method is called from ShowMembers() via AutoBrowse().Definition TClass.cxx:987; TBaseClassEach class (see TClass) has a linked list of its base class(es).Definition TBaseClass.h:33; TBaseClass::GetDeltaInt_t GetDelta()Get offset from ""this"" to part of base class.Definition TBaseClass.cxx:75; TBaseClass::IsSTLContainerROOT::ESTLType IsSTLContainer()Return which type (if any) of STL container the data member is.Definition TBaseClass.cxx:101; TBaseClass::PropertyLong_t Property() const overrideGet property description word. For meaning of bits see EProperty.Definition TBaseClass.cxx:134; TBaseClass::GetClassPointerTClass * GetClassPointer(Bool_t load=kTRUE)Get pointer to the base class TClass.Definition TBaseClass.cxx:63; TBrowserUsing a TBrowser one can browse all ROOT objects.Definition TBrowser.h:37; TBufferBuffer base class used for serializing objects.Definition TBuffer.h:43; TBuildRealDataDefinition TClass.cxx:818; TBuildRealData::Inspectvoid Inspect(TClass *cl, const char *parent, const char *name, const void *addr, Bool_t isTransient) overrideThis method is called from ShowMembers() via BuildRealdata().Definition TClass.cxx:838; TBuildRealData::fRealDataClassTClass * fRealDataClassDefinition TClass.cxx:822; TBuildRealData::fRealDataObjectvoid * fRealDataObjectDefinition TClass.cxx:821; TBuildRealData::TBuildRealDataTBuildRealData(void *obj, TClass *cl)Definition TClass.cxx:825; TClassGeneratorObjects following this interface can be passed onto the TROOT object to implement a user customized w...Definition TClassGenerator.h:28; TClassGenerator::GetClassvirtual TClass * GetClass(const char *classname, Bool_t lo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:306750,load,load,306750,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['load'],['load']
Performance,"nst RooAbsArg &testArg const { return observableOverlaps(dset,testArg);  ; const RooAbsArg &testArg const { return observableOverlaps(depList, testArg);  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Static Protected Member Functions inherited from RooAbsReal; static void globalSelectComp (bool flag);  Global switch controlling the activation of the selectComp() functionality. ;  ;  Static Protected Member Functions inherited from RooAbsArg; static void ioStreamerPass2Finalize ();  Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ;  ;  Static Protected Attributes inherited from RooAbsHiddenReal; static RooCategory * _dummyBlindState = nullptr;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooUnblindCPAsymVar.h>. Inheritance diagram for RooUnblindCPAsymVar:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RooUnblindCPAsymVar() [1/4]. RooUnblindCPAsymVar::RooUnblindCPAsymVar ; (; ). Default constructor. ; Definition at line 40 of file RooUnblindCPAsymVar.cxx. ◆ RooUnblindCPAsymVar() [2/4]. RooUnblindCPAsymVar::RooUnblindCPAsymVar ; (; const char * ; name, . const char * ; title, . const char * ; blindString, . RooAbsReal & ; cpasym . ). Constructor from a given RooAbsReal (to hold the blind value) and a set of blinding parameters. ; Definition at line 47 of file RooUnblindCPAsymVar.cxx. ◆ RooUnblindCPAsymVar() [3/4]. RooUnblindCPAsymVar::RooUnblindCPAsymVar ; (; const char * ; name, . cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooUnblindCPAsymVar.html:61998,cache,cache,61998,doc/master/classRooUnblindCPAsymVar.html,https://root.cern,https://root.cern/doc/master/classRooUnblindCPAsymVar.html,1,['cache'],['cache']
Performance,"nst RooAbsArg &testArg const { return observableOverlaps(dset,testArg);  ; const RooAbsArg &testArg const { return observableOverlaps(depList, testArg);  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Static Protected Member Functions inherited from RooAbsReal; static void globalSelectComp (bool flag);  Global switch controlling the activation of the selectComp() functionality. ;  ;  Static Protected Member Functions inherited from RooAbsArg; static void ioStreamerPass2Finalize ();  Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ;  ;  Static Protected Attributes inherited from RooAbsHiddenReal; static RooCategory * _dummyBlindState = nullptr;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooUnblindOffset.h>. Inheritance diagram for RooUnblindOffset:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RooUnblindOffset() [1/4]. RooUnblindOffset::RooUnblindOffset ; (; ). default . ◆ RooUnblindOffset() [2/4]. RooUnblindOffset::RooUnblindOffset ; (; const char * ; name, . const char * ; title, . const char * ; blindString, . double ; scale, . RooAbsReal & ; blindValue . ). Constructor from a given RooAbsReal (to hold the blind value) and a set of blinding parameters. ; Definition at line 40 of file RooUnblindOffset.cxx. ◆ RooUnblindOffset() [3/4]. RooUnblindOffset::RooUnblindOffset ; (; const char * ; name, . const char * ; title, . const char * ; blindString, . double ; scale, . RooAbsReal & ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooUnblindOffset.html:61899,cache,cache,61899,doc/master/classRooUnblindOffset.html,https://root.cern,https://root.cern/doc/master/classRooUnblindOffset.html,1,['cache'],['cache']
Performance,"nst RooAbsArg &testArg const { return observableOverlaps(dset,testArg);  ; const RooAbsArg &testArg const { return observableOverlaps(depList, testArg);  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Static Protected Member Functions inherited from RooAbsReal; static void globalSelectComp (bool flag);  Global switch controlling the activation of the selectComp() functionality. ;  ;  Static Protected Member Functions inherited from RooAbsArg; static void ioStreamerPass2Finalize ();  Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ;  ;  Static Protected Attributes inherited from RooAbsHiddenReal; static RooCategory * _dummyBlindState = nullptr;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooUnblindPrecision.h>. Inheritance diagram for RooUnblindPrecision:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RooUnblindPrecision() [1/4]. RooUnblindPrecision::RooUnblindPrecision ; (; ). default . ◆ RooUnblindPrecision() [2/4]. RooUnblindPrecision::RooUnblindPrecision ; (; const char * ; name, . const char * ; title, . const char * ; blindString, . double ; centralValue, . double ; scale, . RooAbsReal & ; blindValue, . bool ; sin2betaMode = false . ). Constructor from a given RooAbsReal (to hold the blind value) and a set of blinding parameters. ; Definition at line 40 of file RooUnblindPrecision.cxx. ◆ RooUnblindPrecision() [3/4]. RooUnblindPrecision::RooUnblindPrecision ; (; const char * ; na",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooUnblindPrecision.html:62024,cache,cache,62024,doc/master/classRooUnblindPrecision.html,https://root.cern,https://root.cern/doc/master/classRooUnblindPrecision.html,1,['cache'],['cache']
Performance,"nst RooAbsArg &testArg const { return observableOverlaps(dset,testArg);  ; const RooAbsArg &testArg const { return observableOverlaps(depList, testArg);  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Static Protected Member Functions inherited from RooAbsReal; static void globalSelectComp (bool flag);  Global switch controlling the activation of the selectComp() functionality. ;  ;  Static Protected Member Functions inherited from RooAbsArg; static void ioStreamerPass2Finalize ();  Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ;  ;  Static Protected Attributes inherited from RooAbsHiddenReal; static RooCategory * _dummyBlindState = nullptr;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooUnblindUniform.h>. Inheritance diagram for RooUnblindUniform:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RooUnblindUniform() [1/3]. RooUnblindUniform::RooUnblindUniform ; (; ). default . ◆ RooUnblindUniform() [2/3]. RooUnblindUniform::RooUnblindUniform ; (; const char * ; name, . const char * ; title, . const char * ; blindString, . double ; scale, . RooAbsReal & ; blindValue . ). Constructor from a given RooAbsReal (to hold the blinded value) and a set of blinding parameters. ; Parameters. nameName of this transformation ; titleTitle (for plotting) ; blindStringString to initialise the random generator ; scaleScale the offset. High values make the blinding more violent. ; blindValueThe paramet",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooUnblindUniform.html:61721,cache,cache,61721,doc/master/classRooUnblindUniform.html,https://root.cern,https://root.cern/doc/master/classRooUnblindUniform.html,1,['cache'],['cache']
Performance,"nst RooAbsArg* newOwner, const RooArgSet& cachedVars); Initialize cache of dataset: attach variables of cache ArgSet; to the corresponding TTree branches. void resetCache(). void setArgStatus(const RooArgSet& set, Bool_t active); Disabling of branches is (intentionally) not implemented in vector; data stores (as the doesn't result in a net saving of time). void attachBuffers(const RooArgSet& extObs). void resetBuffers(). void dump(). void Streamer(TBuffer& b); Stream an object of class RooVectorDataStore. RooAbsDataStore* clone(const char* newname = 0) const; { return new RooVectorDataStore(*this,newname) ; }. RooAbsDataStore* clone(const RooArgSet& vars, const char* newname = 0) const; { return new RooVectorDataStore(*this,vars,newname) ; }. Bool_t isWeighted() const; { return (_wgtVar!=0||_extWgtArray!=0) ; }. Double_t sumEntries() const; { return _sumWeight ; }. const RooAbsArg* cacheOwner(); Constant term optimizer interface. { return _cacheOwner ; }. const RooVectorDataStore* cache() const; { return _cache ; }. void setExternalWeightArray(Double_t* arrayWgt, Double_t* arrayWgtErrLo, Double_t* arrayWgtErrHi, Double_t* arraySumW2). void setDirtyProp(Bool_t flag). const RooArgSet& row(); virtual void checkInit() const;. { return _varsww ; }. RealVector& operator=(const RooVectorDataStore& ). std::vector<RealVector*>& realStoreList(); { return _realStoreList ; }. std::vector<RealFullVector*>& realfStoreList(); { return _realfStoreList ; }. std::vector<CatVector*>& catStoreList(); { return _catStoreList ; }. CatVector* addCategory(RooAbsCategory* cat). RealVector* addReal(RooAbsReal* real). Bool_t isFullReal(RooAbsReal* real). Bool_t hasError(RooAbsReal* real). Bool_t hasAsymError(RooAbsReal* real). RealFullVector* addRealFull(RooAbsReal* real). » Last changed: Fri Dec 2 14:27:16 2011 » Last generated: 2011-12-02 14:27; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT su",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooVectorDataStore.html:16696,cache,cache,16696,root/html532/RooVectorDataStore.html,https://root.cern,https://root.cern/root/html532/RooVectorDataStore.html,2,['cache'],['cache']
Performance,"nst RooAbsArg* source, Bool_t valueOnly = kFALSE); const RooCatType*RooAbsCategory::defineType(const char* label); const RooCatType*RooAbsCategory::defineType(const char* label, Int_t index); const RooCatType*RooAbsCategory::defineTypeUnchecked(const char* label, Int_t index); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual RooCatTypeevaluate() const; virtual voidRooAbsCategory::fillTreeBranch(TTree& t); static Bool_tRooAbsArg::flipAClean(); virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; const RooCatType*RooAbsCategory::getOrdinal(UInt_t n, const char* rangeName = 0) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; voidRooAbsArg::graphVizAddConnections(set<std::pair<RooAbsArg*,RooAbsArg*> >&); static Bool_tRooAbsArg::inhibitDirty(); voidinitialize(); virtual Bool_tRooAbsCategory::isValid() const; virtual Bool_tRooAbsCategory::isValid(RooCatType value) const; voidTObject::MakeZombie(); Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); voidRooAbsArg::printAttribList(ostream& os) const; voidRooAbsArg::registerProxy(RooArgProxy& proxy); voidRooAbsArg::registerProxy(RooSetProxy& proxy); voidRooAbsArg::registerProxy(RooListProxy& proxy); voidRooAbsArg::setProxyNormSet(const RooArgSet* nset); voidRooAbsArg::setShapeDirty(const RooAbsArg* source) const; virtual voidRooAbsCategory::setTreeBranchStatus(TTree& t, Bool_t active); voidRooAbsArg::setValueDirty(const RooAbsArg* source) const; virtual voidRooAbsCategory::syncCache(const RooArgSet* set = 0); RooCatTypeRooAbsCategory::traceEval() const; virtual Bool_tRooAbsCategory::traceEvalHook(RooCatType) const; voidRooAbsArg::unRegisterProxy(RooArgProxy& proxy); voidRooAbsArg::unRegisterProxy(RooSetProxy& proxy); voidRooAbsArg::unRegisterProxy(RooListProxy& proxy).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooBinningCategory.html:17104,optimiz,optimizeDirtyHook,17104,root/html526/RooBinningCategory.html,https://root.cern,https://root.cern/root/html526/RooBinningCategory.html,2,['optimiz'],['optimizeDirtyHook']
Performance,"nst RooAbsReal& func, const RooArgSet& vars, Int_t code, const RooArgSet* normSet = 0, const TNamed* rangeName = 0); virtual~RooRealAnalytic(); static TClass*Class(); UInt_tRooAbsFunc::getDimension() const; virtual Double_tRooRealBinding::getMaxLimit(UInt_t dimension) const; virtual Double_tRooRealBinding::getMinLimit(UInt_t dimension) const; virtual const char*RooRealBinding::getName() const; virtual TClass*IsA() const; Bool_tRooAbsFunc::isValid() const; Int_tRooAbsFunc::numCall() const; virtual Double_toperator()(const Double_t* xvector) const; RooAbsFunc&RooAbsFunc::operator=(const RooAbsFunc&); virtual list<Double_t>*RooRealBinding::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; voidRooAbsFunc::resetNumCall() const; virtual voidRooRealBinding::restoreXVec() const; virtual voidRooRealBinding::saveXVec() const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. voidRooRealBinding::loadValues(const Double_t* xvector) const. Data Members; protected:. Bool_tRooRealBinding::_clipInvalid; Int_t_code; UInt_tRooAbsFunc::_dimensionNumber of observables; const RooAbsReal*RooRealBinding::_func; Int_tRooAbsFunc::_ncallFunction call counter; const RooArgSet*RooRealBinding::_nset; const TNamed*RooRealBinding::_rangeName!; Bool_tRooAbsFunc::_validIs binding in valid state?; RooAbsRealLValue**RooRealBinding::_vars; Double_t*RooRealBinding::_xsave; Bool_tRooRealBinding::_xvecValid. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Double_t operator()(const Double_t* xvector) const; Evaluate our analytic integral at the specified values of the dependents. inline RooRealAnalytic(const RooAbsReal& func, const RooArgSet& vars, Int_t code, const RooArgSet* normSet = 0, const TNamed* rangeName = 0); { }. virtual ~RooRealAnalytic(); { }. » Last changed: Mon Jul 4 15:23:49 2011 » Last generated: 2011-07-04 15:23; This page has been automatically generated.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooRealAnalytic.html:1562,load,loadValues,1562,root/html530/RooRealAnalytic.html,https://root.cern,https://root.cern/root/html530/RooRealAnalytic.html,1,['load'],['loadValues']
Performance,"nst RooAbsReal& func, const RooArgSet& vars, Int_t code, const RooArgSet* normSet = 0, const TNamed* rangeName = 0); virtual~RooRealAnalytic(); static TClass*Class(); UInt_tRooAbsFunc::getDimension() const; virtual Double_tRooRealBinding::getMaxLimit(UInt_t dimension) const; virtual Double_tRooRealBinding::getMinLimit(UInt_t dimension) const; virtual const char*RooRealBinding::getName() const; virtual TClass*IsA() const; Bool_tRooAbsFunc::isValid() const; Int_tRooAbsFunc::numCall() const; virtual Double_toperator()(const Double_t* xvector) const; RooAbsFunc&RooAbsFunc::operator=(const RooAbsFunc&); virtual list<Double_t>*RooRealBinding::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; voidRooAbsFunc::resetNumCall() const; virtual voidRooRealBinding::restoreXVec() const; virtual voidRooRealBinding::saveXVec() const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. voidRooRealBinding::loadValues(const Double_t* xvector) const. Data Members; protected:. Bool_tRooRealBinding::_clipInvalid; Int_t_code; UInt_tRooAbsFunc::_dimensionNumber of observables; const RooAbsReal*RooRealBinding::_func; Int_tRooAbsFunc::_ncallFunction call counter; const RooArgSet*RooRealBinding::_nset; const TNamed*RooRealBinding::_rangeName!; Bool_tRooAbsFunc::_validIs binding in valid state?; RooAbsRealLValue**RooRealBinding::_vars; Double_t*RooRealBinding::_xsave; Bool_tRooRealBinding::_xvecValid. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Double_t operator()(const Double_t* xvector) const; Evaluate our analytic integral at the specified values of the dependents. inline RooRealAnalytic(const RooAbsReal& func, const RooArgSet& vars, Int_t code, const RooArgSet* normSet = 0, const TNamed* rangeName = 0); { }. virtual ~RooRealAnalytic(); { }. » Last changed: Thu Nov 3 20:09:05 2011 » Last generated: 2011-11-03 20:09; This page has been automatically generated.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooRealAnalytic.html:1562,load,loadValues,1562,root/html532/RooRealAnalytic.html,https://root.cern,https://root.cern/root/html532/RooRealAnalytic.html,2,['load'],['loadValues']
Performance,"nst RooAbsReal& func, const RooArgSet& vars, Int_t code, const RooArgSet* normSet = 0, const TNamed* rangeName = 0); virtual~RooRealAnalytic(); static TClass*Class(); UInt_tRooAbsFunc::getDimension() const; virtual Double_tRooRealBinding::getMaxLimit(UInt_t dimension) const; virtual Double_tRooRealBinding::getMinLimit(UInt_t dimension) const; virtual const char*RooRealBinding::getName() const; virtual TClass*IsA() const; Bool_tRooAbsFunc::isValid() const; Int_tRooAbsFunc::numCall() const; virtual Double_toperator()(const Double_t* xvector) const; RooAbsFunc&RooAbsFunc::operator=(const RooAbsFunc&); virtual list<Double_t>*RooRealBinding::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; voidRooAbsFunc::resetNumCall() const; virtual voidRooRealBinding::restoreXVec() const; virtual voidRooRealBinding::saveXVec() const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. voidRooRealBinding::loadValues(const Double_t* xvector) const. Data Members; protected:. Bool_tRooRealBinding::_clipInvalid; Int_t_code; UInt_tRooAbsFunc::_dimensionNumber of observables; const RooAbsReal*RooRealBinding::_func; Int_tRooAbsFunc::_ncallFunction call counter; const RooArgSet*RooRealBinding::_nset; const TNamed*RooRealBinding::_rangeName!; Bool_tRooAbsFunc::_validIs binding in valid state?; RooAbsRealLValue**RooRealBinding::_vars; Double_t*RooRealBinding::_xsave; Bool_tRooRealBinding::_xvecValid. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Double_t operator()(const Double_t* xvector) const; Evaluate our analytic integral at the specified values of the dependents. inline RooRealAnalytic(const RooAbsReal& func, const RooArgSet& vars, Int_t code, const RooArgSet* normSet = 0, const TNamed* rangeName = 0); { }. virtual ~RooRealAnalytic(); { }. » Last changed: Thu Sep 23 20:00:38 2010 » Last generated: 2010-09-23 20:00; This page has been automatically generated",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooRealAnalytic.html:1562,load,loadValues,1562,root/html528/RooRealAnalytic.html,https://root.cern,https://root.cern/root/html528/RooRealAnalytic.html,1,['load'],['loadValues']
Performance,"nst RooAbsReal& real, const RooAbsData& data, const RooArgSet& vars, const RooArgSet* normSet = 0); virtual~RooDataProjBinding(); static TClass*Class(); UInt_tRooAbsFunc::getDimension() const; virtual Double_tRooRealBinding::getMaxLimit(UInt_t dimension) const; virtual Double_tRooRealBinding::getMinLimit(UInt_t dimension) const; virtual const char*RooRealBinding::getName() const; virtual TClass*IsA() const; Bool_tRooAbsFunc::isValid() const; Int_tRooAbsFunc::numCall() const; virtual Double_toperator()(const Double_t* xvector) const; RooAbsFunc&RooAbsFunc::operator=(const RooAbsFunc&); virtual list<Double_t>*RooRealBinding::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; voidRooAbsFunc::resetNumCall() const; virtual voidRooRealBinding::restoreXVec() const; virtual voidRooRealBinding::saveXVec() const; virtual voidShowMembers(TMemberInspector& insp, char* parent); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. voidRooRealBinding::loadValues(const Double_t* xvector) const. Data Members; protected:. Roo1DTable*_catTableSupercategory table generated from _data; Bool_tRooRealBinding::_clipInvalid; const RooAbsData*_dataDataset used for projection; UInt_tRooAbsFunc::_dimensionNumber of observables; Bool_t_firstBit indicating if operator() has been called yet; const RooAbsReal*RooRealBinding::_func; Int_tRooAbsFunc::_ncallFunction call counter; const RooArgSet*_nsetNormalization set for real function; const RooArgSet*RooRealBinding::_nset; const TNamed*RooRealBinding::_rangeName!; const RooAbsReal*_realReal function to be projected; RooSuperCategory*_superCatSupercategory constructed from _data's category variables; Bool_tRooAbsFunc::_validIs binding in valid state?; RooAbsRealLValue**RooRealBinding::_vars; Double_t*RooRealBinding::_xsave; Bool_tRooRealBinding::_xvecValid. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooDataProjBinding(const RooAbsReal& real, const RooAbsData& data,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooDataProjBinding.html:1857,load,loadValues,1857,root/html526/RooDataProjBinding.html,https://root.cern,https://root.cern/root/html526/RooDataProjBinding.html,1,['load'],['loadValues']
Performance,"nst RooArgSet *normSet, const char *rangeName=nullptr) const override;  Advertise capability to perform (analytical) integrals internally. ;  ; virtual Int_t getCoefAnalyticalIntegral (Int_t coef, RooArgSet &allVars, RooArgSet &analVars, const char *rangeName=nullptr) const;  Default implementation of function advertising integration capabilities. ;  ; double getCoefNorm (Int_t coefIdx, const RooArgSet &nset, const char *rangeName) const;  ; double getCoefNorm (Int_t coefIdx, const RooArgSet *nset=nullptr, const char *rangeName=nullptr) const;  ; bool isDirectGenSafe (const RooAbsArg &arg) const override;  Return true if it is safe to generate the convolution observable from the internal generator (this is the case if the chosen resolution model is the truth model) ;  ; void printMultiline (std::ostream &stream, Int_t contents, bool verbose=false, TString indent="""") const override;  Print info about this object to the specified stream. ;  ; void setCacheAndTrackHints (RooArgSet &) override;  Label OK'ed components with cache-and-track. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from RooAbsPdf;  RooAbsPdf ();  Default constructor. ;  ;  RooAbsPdf (const char *name, const char *title, double minVal, double maxVal);  Constructor with name, title, and plot range. ;  ;  RooAbsPdf (const char *name, const char *title=nullptr);  Constructor with name and title only. ;  ;  ~RooAbsPdf () override;  Destructor. ;  ; double analyticalIntegralWN (Int_t code, const RooArgSet *normSet, const char *rangeName=nullptr) const override;  Analytical integral with normalization (see RooAbsReal::analyticalIntegralWN() for further information). ;  ; virtual RooAbsGenContext * autoGenContext (const RooArgSet &vars, const RooDataSet *prototype=nullptr, const RooArgSet *auxProto=nullptr, bool verbose=false, bool autoBinned=true, const char *binnedTag="""") const;  ; virtual RooAbsGenContext * binnedGenContext (const RooArgSet &vars,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooDecay.html:7190,cache,cache-and-track,7190,doc/master/classRooDecay.html,https://root.cern,https://root.cern/doc/master/classRooDecay.html,1,['cache'],['cache-and-track']
Performance,"nst RooArgSet& nset) const; virtual voidRooAbsReal::attachToTree(TTree& t, Int_t bufSize = 32000); virtual const char*RooAbsCachedPdf::binningName() const; TStringRooAbsCachedPdf::cacheNameSuffix(const RooArgSet& nset) const; RooFitResult*RooAbsReal::chi2FitDriver(RooAbsReal& fcn, RooLinkedList& cmdList); TStringRooAbsArg::cleanBranchName() const; voidRooAbsCachedPdf::clearCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; virtual voidRooAbsReal::copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE); virtual RooAbsCachedPdf::PdfCacheElem*RooAbsCachedPdf::createCache(const RooArgSet* nset) const; RooAbsReal*RooAbsReal::createIntObj(const RooArgSet& iset, const RooArgSet* nset, const RooNumIntConfig* cfg, const char* rangeName) const; voidRooAbsCachedPdf::disableCache(Bool_t flag); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual Double_tevaluate() const; virtual voidfillCacheObject(RooAbsCachedPdf::PdfCacheElem& cachePdf) const; virtual voidRooAbsReal::fillTreeBranch(TTree& t); voidRooAbsReal::findInnerMostIntegration(const RooArgSet& allObs, RooArgSet& innerObs, const char* rangeName) const; static Bool_tRooAbsArg::flipAClean(); virtual RooAbsGenContext*RooAbsPdf::genContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE) const; RooDataSet*RooAbsPdf::generate(RooAbsGenContext& context, const RooArgSet& whatVars, const RooDataSet* prototype, Int_t nEvents, Bool_t verbose, Bool_t randProtoOrder, Bool_t resampleProto) const; RooAbsCachedPdf::PdfCacheElem*RooAbsCachedPdf::getCache(const RooArgSet* nset, Bool_t recalculate = kTRUE) const; virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; static voidRooAbsReal::globalSelectComp(Bool_t flag); voidRooAbsArg::graphVizAddConnectio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooCachedPdf.html:31132,cache,cachePdf,31132,root/html526/RooCachedPdf.html,https://root.cern,https://root.cern/root/html526/RooCachedPdf.html,3,['cache'],['cachePdf']
Performance,"nst RooArgSet& nset) const; virtual voidRooAbsReal::attachToTree(TTree& t, Int_t bufSize = 32000); virtual const char*RooAbsCachedPdf::binningName() const; TStringRooAbsCachedPdf::cacheNameSuffix(const RooArgSet& nset) const; voidcalcParams(); RooFitResult*RooAbsReal::chi2FitDriver(RooAbsReal& fcn, RooLinkedList& cmdList); TStringRooAbsArg::cleanBranchName() const; voidRooAbsCachedPdf::clearCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; virtual voidRooAbsReal::copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE); virtual RooAbsCachedPdf::PdfCacheElem*createCache(const RooArgSet* nset) const; RooAbsReal*RooAbsReal::createIntObj(const RooArgSet& iset, const RooArgSet* nset, const RooNumIntConfig* cfg, const char* rangeName) const; voidRooAbsCachedPdf::disableCache(Bool_t flag); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual Double_tevaluate() const; virtual voidfillCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; voidfillCacheSlice(RooFFTConvPdf::FFTCacheElem& cache, const RooArgSet& slicePosition) const; virtual voidRooAbsReal::fillTreeBranch(TTree& t); voidRooAbsReal::findInnerMostIntegration(const RooArgSet& allObs, RooArgSet& innerObs, const char* rangeName) const; static Bool_tRooAbsArg::flipAClean(); virtual RooAbsGenContext*genContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE) const; RooDataSet*RooAbsPdf::generate(RooAbsGenContext& context, const RooArgSet& whatVars, const RooDataSet* prototype, Int_t nEvents, Bool_t verbose, Bool_t randProtoOrder, Bool_t resampleProto) const; RooAbsCachedPdf::PdfCacheElem*RooAbsCachedPdf::getCache(const RooArgSet* nset, Bool_t recalculate = kTRUE) const; virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; static ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooFFTConvPdf.html:35877,cache,cache,35877,root/html526/RooFFTConvPdf.html,https://root.cern,https://root.cern/root/html526/RooFFTConvPdf.html,3,['cache'],['cache']
Performance,"nst RooArgSet& nset); Int_tRooAbsPdf::minDimNormValueCaching() const; virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/Roo2DKeysPdf.html:21570,optimiz,optimizeCacheMode,21570,root/html528/Roo2DKeysPdf.html,https://root.cern,https://root.cern/root/html528/Roo2DKeysPdf.html,136,['optimiz'],['optimizeCacheMode']
Performance,"nst RooArgSet&numIntCatVars() const; const RooArgSet&numIntRealVars() const; Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*plotSamplingHint(RooAbsRealLValue& obs, Double_t xlo, Double_t xhi) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooRealIntegral.html:18112,optimiz,optimizeCacheMode,18112,root/html530/RooRealIntegral.html,https://root.cern,https://root.cern/root/html530/RooRealIntegral.html,3,['optimiz'],['optimizeCacheMode']
Performance,"nst RooArgSet* dset, Bool_t adjustProxies = kTRUE) const; Verify that the normalization integral cached with this PDF; is valid for given set of normalization observables. If not, the cached normalization integral (if any) is deleted; and a new integral is constructed for use with 'nset'; Elements in 'nset' can be discrete and real, but must be lvalues. For functions that declare to be self-normalized by overloading the; selfNormalized() function, a unit normalization is always constructed. void setNormValueCaching(Int_t minNumIntDim, Int_t ipOrder = 2); Activate caching of normalization integral values in a interpolated histogram; for integrals that exceed the specified minimum number of numerically integrated; dimensions, _and_ of which the integral has at most 2 parameters. The cache is scanned with a granularity defined by a binning named ""cache"" in the; scanned integral parameters and is interpolated to given order.; The cache values are kept for the livetime of the ROOT session/application; and are persisted along with the object in case the p.d.f. is persisted; in a RooWorkspace. This feature can substantially speed up fits and improve convergence with slow; multi-dimensional integrals whose value varies slowly with the parameters so that the; an interpolated histogram is a good approximation of the true integral value.; The improved convergence behavior is a result of making the value of the normalization; integral deterministic for each value of the parameters. If (multi-dimensional) numeric; integrals are calculated at insufficient precision (>=1e-7) MINUIT convergence may; be impaired by the effects numerical noise that can cause that subsequent evaluations; of an integral at the same point in parameter space can give slightly different answers. Bool_t traceEvalHook(Double_t value) const; WVE 08/21/01 Probably obsolete now. void resetErrorCounters(Int_t resetValue = 10); Reset error counter to given value, limiting the number; of future error messages for",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsPdf.html:44734,cache,cache,44734,root/html526/RooAbsPdf.html,https://root.cern,https://root.cern/root/html526/RooAbsPdf.html,4,['cache'],['cache']
Performance,"nst RooCatType*RooAbsCategory::defineType(const char* label); const RooCatType*RooAbsCategory::defineType(const char* label, Int_t index); const RooCatType*RooAbsCategory::defineTypeUnchecked(const char* label, Int_t index); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual RooCatTypeRooAbsCategory::evaluate() const; virtual voidRooAbsCategory::fillTreeBranch(TTree& t); static Bool_tRooAbsArg::flipAClean(); virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; const RooCatType*RooAbsCategory::getOrdinal(UInt_t n, const char* rangeName = 0) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; voidRooAbsArg::graphVizAddConnections(set<std::pair<RooAbsArg*,RooAbsArg*> >&); static Bool_tRooAbsArg::inhibitDirty(); virtual Bool_tRooAbsCategory::isValid() const; virtual Bool_tRooAbsCategory::isValid(RooCatType value) const; voidTObject::MakeZombie(); Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); voidRooAbsArg::printAttribList(ostream& os) const; voidRooAbsArg::registerProxy(RooArgProxy& proxy); voidRooAbsArg::registerProxy(RooSetProxy& proxy); voidRooAbsArg::registerProxy(RooListProxy& proxy); Bool_tsetOrdinal(UInt_t index, const char* rangeName); voidRooAbsArg::setProxyNormSet(const RooArgSet* nset); voidRooAbsArg::setShapeDirty(const RooAbsArg* source) const; virtual voidRooAbsCategory::setTreeBranchStatus(TTree& t, Bool_t active); voidRooAbsArg::setValueDirty(const RooAbsArg* source) const; virtual voidRooAbsCategory::syncCache(const RooArgSet* set = 0); RooCatTypeRooAbsCategory::traceEval() const; virtual Bool_tRooAbsCategory::traceEvalHook(RooCatType) const; voidRooAbsArg::unRegisterProxy(RooArgProxy& proxy); voidRooAbsArg::unRegisterProxy(RooSetProxy& proxy); voidRooAbsArg::unRegisterProxy(RooListProxy& proxy).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsCategoryLValue.html:17988,optimiz,optimizeDirtyHook,17988,root/html526/RooAbsCategoryLValue.html,https://root.cern,https://root.cern/root/html526/RooAbsCategoryLValue.html,2,['optimiz'],['optimizeDirtyHook']
Performance,"nst TMatrixDSym& covMatrix). RooMultiVarGaussian(const char* name, const char* title, const RooArgList& xvec, const RooFitResult& fr). RooMultiVarGaussian(const char* name, const char* title, const RooArgList& xvec, const TVectorD& mu, const TMatrixDSym& covMatrix). RooMultiVarGaussian(const char* name, const char* title, const RooArgList& xvec, const TMatrixDSym& covMatrix). RooMultiVarGaussian(const RooMultiVarGaussian& other, const char* name = 0). void syncMuVec() const. Double_t evaluate() const; Represent observables as vector. Int_t getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; Analytical integral known over all observables. Double_t analyticalIntegral(Int_t code, const char* rangeName = 0) const; Handle full integral here. Int_t getGenerator(const RooArgSet& directVars, RooArgSet& generateVars, Bool_t staticInitOK = kTRUE) const; Special case: generate all observables. void initGenerator(Int_t code); Clear the GenData cache as its content is not invariant under changes in; the mu vector. void generateEvent(Int_t code); Retrieve generator config from cache. void decodeCode(Int_t code, vector<int>& map1, vector<int>& map2) const; Decode analytical integration/generation code into index map of integrated/generated (map2); and non-integrated/generated observables (map1). void blockDecompose(const TMatrixD& input, const vector<int>& map1, const vector<int>& map2, TMatrixDSym& S11, TMatrixD& S12, TMatrixD& S21, TMatrixDSym& S22); Block decomposition of covI according to given maps of observables. RooMultiVarGaussian(); {}. void setAnaIntZ(Double_t z); { _z = z ; }. TObject* clone(const char* newname) const; { return new RooMultiVarGaussian(*this,newname); }. virtual ~RooMultiVarGaussian(); { }. const TMatrixDSym& covarianceMatrix() const; { return _cov ; }. AnaIntData& anaIntData(Int_t code) const. GenData& genData(Int_t code) const. » Last changed: Mon Jul 4 15:23:25 2011 » Last generated: 2011-07-04 15:23; This p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooMultiVarGaussian.html:42416,cache,cache,42416,root/html530/RooMultiVarGaussian.html,https://root.cern,https://root.cern/root/html530/RooMultiVarGaussian.html,1,['cache'],['cache']
Performance,"nst TMatrixDSym& covMatrix). RooMultiVarGaussian(const char* name, const char* title, const RooArgList& xvec, const RooFitResult& fr). RooMultiVarGaussian(const char* name, const char* title, const RooArgList& xvec, const TVectorD& mu, const TMatrixDSym& covMatrix). RooMultiVarGaussian(const char* name, const char* title, const RooArgList& xvec, const TMatrixDSym& covMatrix). RooMultiVarGaussian(const RooMultiVarGaussian& other, const char* name = 0). void syncMuVec() const. Double_t evaluate() const; Represent observables as vector. Int_t getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; Analytical integral known over all observables. Double_t analyticalIntegral(Int_t code, const char* rangeName = 0) const; Handle full integral here. Int_t getGenerator(const RooArgSet& directVars, RooArgSet& generateVars, Bool_t staticInitOK = kTRUE) const; Special case: generate all observables. void initGenerator(Int_t code); Clear the GenData cache as its content is not invariant under changes in; the mu vector. void generateEvent(Int_t code); Retrieve generator config from cache. void decodeCode(Int_t code, vector<int>& map1, vector<int>& map2) const; Decode analytical integration/generation code into index map of integrated/generated (map2); and non-integrated/generated observables (map1). void blockDecompose(const TMatrixD& input, const vector<int>& map1, const vector<int>& map2, TMatrixDSym& S11, TMatrixD& S12, TMatrixD& S21, TMatrixDSym& S22); Block decomposition of covI according to given maps of observables. RooMultiVarGaussian(); {}. void setAnaIntZ(Double_t z); { _z = z ; }. TObject* clone(const char* newname) const; { return new RooMultiVarGaussian(*this,newname); }. virtual ~RooMultiVarGaussian(); { }. const TMatrixDSym& covarianceMatrix() const; { return _cov ; }. AnaIntData& anaIntData(Int_t code) const. GenData& genData(Int_t code) const. » Last changed: Thu Sep 23 20:00:15 2010 » Last generated: 2010-09-23 20:00; This ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooMultiVarGaussian.html:41856,cache,cache,41856,root/html528/RooMultiVarGaussian.html,https://root.cern,https://root.cern/root/html528/RooMultiVarGaussian.html,1,['cache'],['cache']
Performance,"nst TNamed* set2RangeName = 0); voidinitialize(const RooNormSetCache& other); virtual TClass*IsA() const; const RooArgSet*lastSet1() const; const RooArgSet*lastSet2() const; const RooNameSet&nameSet1() const; const RooNameSet&nameSet2() const; RooNormSetCache&operator=(const RooNormSetCache&); virtual voidShowMembers(TMemberInspector& insp, char* parent); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. voidexpand(). Data Members; protected:. RooSetPair*_asArr! do not persist; RooHashTable*_htable! do not persist; RooNameSet_name1!; RooNameSet_name2!; Int_t_nreg; Int_t_regSize; TNamed*_set2RangeName!. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooNormSetCache(Int_t regSize); Construct normalization set manager with given initial size. RooNormSetCache(const RooNormSetCache& other); Copy constructor. ~RooNormSetCache(); Destructor. void clear(); Clear contents. void initialize(const RooNormSetCache& other); Initialize cache from contents of given other cache. void add(const RooArgSet* set1, const RooArgSet* set2 = 0); Add given pair of RooArgSet pointers to our store. void expand(); Expand registry size by doubling capacity. Bool_t autoCache(const RooAbsArg* self, const RooArgSet* set1, const RooArgSet* set2 = 0, const TNamed* set2RangeName = 0, Bool_t autoRefill = kTRUE); If RooArgSets set1 and set2 or sets with similar contents have; been seen by this cache manager before return kFALSE If not,; return kTRUE. If sets have not been seen and doRefill is true,; update cache reference to current input sets. Int_t index(const RooArgSet* set1, const RooArgSet* set2 = 0, const TNamed* set2RangeName = 0). Bool_t contains(const RooArgSet* set1, const RooArgSet* set2 = 0, const TNamed* set2RangeName = 0). Bool_t containsSet1(const RooArgSet* set1). const RooArgSet* lastSet1() const; { return _nreg>0?_asArr[_nreg-1]._set1:0 ; }. const RooArgSet* lastSet2() const; { return _nreg>0?_asArr[_nreg-1]._set",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooNormSetCache.html:2652,cache,cache,2652,root/html526/RooNormSetCache.html,https://root.cern,https://root.cern/root/html526/RooNormSetCache.html,2,['cache'],['cache']
Performance,"nst TSlave* sl, Long_t timeout = -1, Int_t endtype = -1, Bool_t deactonfail = kFALSE); Int_tCollect(TMonitor* mon, Long_t timeout = -1, Int_t endtype = -1, Bool_t deactonfail = kFALSE); Int_tCollectInputFrom(TSocket* s, Int_t endtype = -1, Bool_t deactonfail = kFALSE); Bool_tCreateMerger(TSlave* sl, Int_t port); voidDeActivateAsyncInput(); Int_tDisablePackage(const char* package); Int_tDisablePackageOnClient(const char* package); Int_tDisablePackages(); Int_tExec(const char* cmd, TProof::ESlaves list, Bool_t plusMaster); voidFinalizationDone(); Int_tFindNextFreeMerger(); TSlave*FindSlave(TSocket* s) const; voidFindUniqueSlaves(); Int_tGetActiveMergersCount(); static TList*GetDataSetSrvMaps(const TString& srvmaps); TList*GetListOfBadSlaves() const; TList*GetListOfInactiveSlaves() const; TList*GetListOfSlaves() const; TList*GetListOfUniqueSlaves() const; Int_tGetNumberOfActiveSlaves() const; Int_tGetNumberOfBadSlaves() const; Int_tGetNumberOfInactiveSlaves() const; Int_tGetNumberOfSlaves() const; Int_tGetNumberOfUniqueSlaves() const; Int_tGetQueryReference(Int_t qry, TString& ref); Int_tGoParallel(Int_t nodes, Bool_t accept = kFALSE, Bool_t random = kFALSE); Int_tHandleInputMessage(TSlave* wrk, TMessage* m, Bool_t deactonfail = kFALSE); voidHandleSubmerger(TMessage* mess, TSlave* sl); voidInterrupt(TProof::EUrgent type, TProof::ESlaves list = kActive); voidInterruptCurrentMonitor(); Bool_tIsEndMaster() const; Bool_tIsSync() const; Int_tLoadPackage(const char* package, Bool_t notOnClient = kFALSE, TList* loadopts = 0); Int_tLoadPackageOnClient(const char* package, TList* loadopts = 0); voidMarkBad(TSlave* wrk, const char* reason = 0); voidMarkBad(TSocket* s, const char* reason = 0); voidModifyWorkerLists(const char* ord, Bool_t add); voidNotifyLogMsg(const char* msg, const char* sfx = ""\n""); voidoperator=(const TProof&); voidParseConfigField(const char* config); Int_tPing(TProof::ESlaves list); voidPrintProgress(Long64_t total, Long64_t processed, Float_t procTime = -1.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProof.html:22638,load,loadopts,22638,root/html528/TProof.html,https://root.cern,https://root.cern/root/html528/TProof.html,2,['load'],['loadopts']
Performance,"nst TString & GetTestvarName () const;  ; const Event * GetTrainingEvent (Long64_t ievt) const;  ; virtual const std::vector< Float_t > & GetTrainingHistory (const char *);  ; UInt_t GetTrainingROOTVersionCode () const;  ; TString GetTrainingROOTVersionString () const;  calculates the ROOT version string from the training version code on the fly ;  ; UInt_t GetTrainingTMVAVersionCode () const;  ; TString GetTrainingTMVAVersionString () const;  calculates the TMVA version string from the training version code on the fly ;  ; Double_t GetTrainTime () const;  ; TransformationHandler & GetTransformationHandler (Bool_t takeReroutedIfAvailable=true);  ; const TransformationHandler & GetTransformationHandler (Bool_t takeReroutedIfAvailable=true) const;  ; TString GetWeightFileName () const;  retrieve weight file name ;  ; Double_t GetXmax (Int_t ivar) const;  ; Double_t GetXmin (Int_t ivar) const;  ; Bool_t HasMVAPdfs () const;  ; void InitIPythonInteractive ();  ; Bool_t IsModelPersistence () const;  ; virtual Bool_t IsSignalLike ();  uses a pre-set cut on the MVA output (SetSignalReferenceCut and SetSignalReferenceCutOrientation) for a quick determination if an event would be selected as signal or background ;  ; virtual Bool_t IsSignalLike (Double_t mvaVal);  uses a pre-set cut on the MVA output (SetSignalReferenceCut and SetSignalReferenceCutOrientation) for a quick determination if an event with this mva output value would be selected as signal or background ;  ; Bool_t IsSilentFile () const;  ; virtual void MakeClass (const TString &classFileName=TString("""")) const;  create reader class for method (classification only at present) ;  ; TDirectory * MethodBaseDir () const;  returns the ROOT directory where all instances of the corresponding MVA method are stored ;  ; virtual std::map< TString, Double_t > OptimizeTuningParameters (TString fomType=""ROCIntegral"", TString fitType=""FitGA"");  call the Optimizer with the set of parameters and ranges that are meant to be tuned.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodCuts.html:11893,tune,tuned,11893,doc/master/classTMVA_1_1MethodCuts.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodCuts.html,1,['tune'],['tuned']
Performance,"nst char * TF1::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TF1::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 755 of file TF1.h. ◆ Clone(). TObject * TF1::Clone ; (; const char * ; newname = nullptr); const. overridevirtual . Make a complete copy of the underlying object. ; If 'newname' is set, the copy's name will be set to that name. ; Reimplemented from TObject.; Definition at line 1064 of file TF1.cxx. ◆ ComputeCdfTable(). Bool_t TF1::ComputeCdfTable ; (; Option_t * ; option). protected . Compute the cumulative function at fNpx points between fXmin and fXmax. ; Option can be used to force a log scale (option = ""log""), linear (option = ""lin"") or automatic if empty. ; Definition at line 2081 of file TF1.cxx. ◆ Copy(). void TF1::Copy ; (; TObject & ; obj); const. overridevirtual . Copy this F1 to a new F1. ; Note that the cached integral with its related arrays are not copied (they are also set as transient data members) ; Reimplemented from TObject.; Reimplemented in TF12, TF2, and TF3.; Definition at line 1005 of file TF1.cxx. ◆ CreateHistogram(). virtual TH1 * TF1::CreateHistogram ; (; ). inlinevirtual . Reimplemented in TF2, and TF3.; Definition at line 477 of file TF1.h. ◆ DeclFileName(). static const char * TF1::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 755 of file TF1.h. ◆ DefaultAddToGlobalList(). Bool_t TF1::DefaultAddToGlobalList ; (; Bool_t ; on = kTRUE). static . Static method to add/avoid to add automatically functions to the global list (gROOT->GetListOfFunctions() ) After having called this static method, all the functions created afterwards will follow the desired behaviour. ; By default the functions are added automatically It returns the previous status (true if the functions are added automatically) ; Definition at line 838 of file TF1.cxx. ◆ DefineNSUMTerm(). void TF1:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTF1.html:60535,cache,cached,60535,doc/master/classTF1.html,https://root.cern,https://root.cern/doc/master/classTF1.html,1,['cache'],['cached']
Performance,"nst char * TGeoElementTable::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TGeoElementTable::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 447 of file TGeoElement.h. ◆ DeclFileName(). static const char * TGeoElementTable::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 447 of file TGeoElement.h. ◆ ExportElementsRN(). void TGeoElementTable::ExportElementsRN ; (; const char * ; filename = """"). Export radionuclides in a file. ; Definition at line 1303 of file TGeoElement.cxx. ◆ FindElement(). TGeoElement * TGeoElementTable::FindElement ; (; const char * ; name); const. Search an element by symbol or full name Exact matching. ; Definition at line 1334 of file TGeoElement.cxx. ◆ FindIsotope(). TGeoIsotope * TGeoElementTable::FindIsotope ; (; const char * ; name); const. Find existing isotope by name. Not optimized for a big number of isotopes. ; Definition at line 1358 of file TGeoElement.cxx. ◆ GetElement(). TGeoElement * TGeoElementTable::GetElement ; (; Int_t ; z). inline . Definition at line 435 of file TGeoElement.h. ◆ GetElementRN() [1/2]. TGeoElementRN * TGeoElementTable::GetElementRN ; (; Int_t ; a, . Int_t ; z, . Int_t ; iso = 0 . ); const. Retrieve a radionuclide by a, z, and isomeric state. ; Definition at line 1385 of file TGeoElement.cxx. ◆ GetElementRN() [2/2]. TGeoElementRN * TGeoElementTable::GetElementRN ; (; Int_t ; ENDFcode); const. Retrieve a radionuclide by ENDF code. ; Definition at line 1368 of file TGeoElement.cxx. ◆ GetElementsRN(). TObjArray * TGeoElementTable::GetElementsRN ; (; ); const. inline . Definition at line 438 of file TGeoElement.h. ◆ GetNelements(). Int_t TGeoElementTable::GetNelements ; (; ); const. inline . Definition at line 442 of file TGeoElement.h. ◆ GetNelementsRN(). Int_t TGeoElementTable::GetNelementsRN ; (; ); const. inline . Definition at line 443 of fil",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoElementTable.html:15869,optimiz,optimized,15869,doc/master/classTGeoElementTable.html,https://root.cern,https://root.cern/doc/master/classTGeoElementTable.html,1,['optimiz'],['optimized']
Performance,"nst char *command);  Execute command and return output in TString. ;  ; virtual int GetFsInfo (const char *path, Long_t *id, Long_t *bsize, Long_t *blocks, Long_t *bfree);  Get info about a file system: fs type, block size, number of blocks, number of free blocks. ;  ; virtual Int_t GetGid (const char *group=nullptr);  Returns the group's id. If group = 0, returns current user's group. ;  ; virtual UserGroup_t * GetGroupInfo (const char *group=nullptr);  Returns all group info in the UserGroup_t structure. ;  ; virtual UserGroup_t * GetGroupInfo (Int_t gid);  Returns all group info in the UserGroup_t structure. ;  ; virtual std::string GetHomeDirectory (const char *userName=nullptr) const;  Return the user's home directory. ;  ; virtual TInetAddress GetHostByName (const char *server);  Get Internet Protocol (IP) address of host. ;  ; virtual const char * GetIncludePath ();  Get the list of include path. ;  ; virtual const char * GetLibraries (const char *regexp="""", const char *option="""", Bool_t isRegexp=kTRUE);  Return a space separated list of loaded shared libraries. ;  ; virtual const char * GetLinkdefSuffix () const;  Return the linkdef suffix chosen by the user for ACLiC. ;  ; virtual const char * GetLinkedLibs () const;  Return the list of library linked to this executable. ;  ; virtual TSeqCollection * GetListOfFileHandlers () const;  ; virtual TSeqCollection * GetListOfSignalHandlers () const;  ; virtual TSeqCollection * GetListOfStdExceptionHandlers () const;  ; virtual TList * GetListOfTimers () const;  ; virtual const char * GetMakeExe () const;  Return the command line use to make an executable. ;  ; virtual const char * GetMakeSharedLib () const;  Return the command line use to make a shared library. ;  ; virtual int GetMemInfo (MemInfo_t *info) const;  Returns ram and swap memory usage info into the MemInfo_t structure. ;  ; virtual const char * GetObjExt () const;  Get the object file extension. ;  ; int GetPathInfo (const char *path, Long_t *id, Long6",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDavixSystem.html:8732,load,loaded,8732,doc/master/classTDavixSystem.html,https://root.cern,https://root.cern/doc/master/classTDavixSystem.html,5,['load'],['loaded']
Performance,"nst char *command);  Execute command and return output in TString. ;  ; virtual int GetFsInfo (const char *path, Long_t *id, Long_t *bsize, Long_t *blocks, Long_t *bfree);  Get info about a file system: fs type, block size, number of blocks, number of free blocks. ;  ; virtual Int_t GetGid (const char *group=nullptr);  Returns the group's id. If group = 0, returns current user's group. ;  ; virtual UserGroup_t * GetGroupInfo (const char *group=nullptr);  Returns all group info in the UserGroup_t structure. ;  ; virtual UserGroup_t * GetGroupInfo (Int_t gid);  Returns all group info in the UserGroup_t structure. ;  ; virtual std::string GetHomeDirectory (const char *userName=nullptr) const;  Return the user's home directory. ;  ; virtual TInetAddress GetHostByName (const char *server);  Get Internet Protocol (IP) address of host. ;  ; virtual const char * GetIncludePath ();  Get the list of include path. ;  ; virtual const char * GetLibraries (const char *regexp="""", const char *option="""", Bool_t isRegexp=kTRUE);  Return a space separated list of loaded shared libraries. ;  ; virtual const char * GetLinkdefSuffix () const;  Return the linkdef suffix chosen by the user for ACLiC. ;  ; virtual const char * GetLinkedLibs () const;  Return the list of library linked to this executable. ;  ; virtual TSeqCollection * GetListOfFileHandlers () const;  ; virtual TSeqCollection * GetListOfSignalHandlers () const;  ; virtual TSeqCollection * GetListOfStdExceptionHandlers () const;  ; virtual TList * GetListOfTimers () const;  ; virtual const char * GetMakeExe () const;  Return the command line use to make an executable. ;  ; virtual const char * GetMakeSharedLib () const;  Return the command line use to make a shared library. ;  ; virtual int GetMemInfo (MemInfo_t *info) const;  Returns ram and swap memory usage info into the MemInfo_t structure. ;  ; virtual const char * GetObjExt () const;  Get the object file extension. ;  ; virtual int GetPathInfo (const char *path, FileStat_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSystem.html:9062,load,loaded,9062,doc/master/classTSystem.html,https://root.cern,https://root.cern/doc/master/classTSystem.html,1,['load'],['loaded']
Performance,"nst char *proto, Bool_t objectIsConst=kFALSE, ROOT::EFunctionMatchMode mode=ROOT::kConversionMatch)Find the method with a given prototype.Definition TClass.cxx:4456; TClass::CopyCollectionProxyvoid CopyCollectionProxy(const TVirtualCollectionProxy &)Replaces the collection proxy for this class.Definition TClass.cxx:2470; TClass::fStreamerTypeInt_t fStreamerTypesaved info to call StreamerDefinition TClass.h:276; TClass::fRealDataTList * fRealDataDefinition TClass.h:200; TClass::fOnHeapUInt_t fOnHeapDefinition TClass.h:218; TClass::lsvoid ls(Option_t *opt="""") const overrideThe ls function lists the contents of a class on stdout.Definition TClass.cxx:4258; TClass::fBasestd::atomic< TList * > fBaseDefinition TClass.h:201; TClass::fCanSplitstd::atomic< Char_t > fCanSplitDefinition TClass.h:245; TClass::HasDictionaryBool_t HasDictionary() constCheck whether a class has a dictionary or not.Definition TClass.cxx:3906; TClass::GetListOfAllPublicMethodsconst TList * GetListOfAllPublicMethods(Bool_t load=kTRUE)Returns a list of all public methods of this class and its base classes.Definition TClass.cxx:3845; TClass::GetListOfAllPublicDataMembersTList * GetListOfAllPublicDataMembers(Bool_t load=kTRUE)Returns a list of all public data members of this class and its base classes.Definition TClass.cxx:3862; TClass::AddClassToDeclIdMapstatic void AddClassToDeclIdMap(TDictionary::DeclId_t id, TClass *cl)static: Add a TClass* to the map of classes.Definition TClass.cxx:511; TClass::~TClassvirtual ~TClass()TClass dtor. Deletes all list that might have been created.Definition TClass.cxx:1660; TClass::fIsSyntheticPairBool_t fIsSyntheticPairIndicates whether this class can be split or not. Values are -1, 0, 1, 2.Definition TClass.h:250; TClass::Destructorvoid Destructor(void *obj, Bool_t dtorOnly=kFALSE)Explicitly call destructor for object.Definition TClass.cxx:5400; TClass::fClassVersionVersion_t fClassVersionDefinition TClass.h:221; TClass::fCurrentInfostd::atomic< TVirtualStreamerInfo ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:314330,load,load,314330,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['load'],['load']
Performance,"nst char *proto, Bool_t objectIsConst=kFALSE, ROOT::EFunctionMatchMode mode=ROOT::kConversionMatch)Find the method with a given prototype.Definition TClass.cxx:4456; TClass::CopyCollectionProxyvoid CopyCollectionProxy(const TVirtualCollectionProxy &)Replaces the collection proxy for this class.Definition TClass.cxx:2470; TClass::fStreamerTypeInt_t fStreamerTypesaved info to call StreamerDefinition TClass.h:276; TClass::fRealDataTList * fRealDataDefinition TClass.h:200; TClass::fOnHeapUInt_t fOnHeapDefinition TClass.h:218; TClass::lsvoid ls(Option_t *opt="""") const overrideThe ls function lists the contents of a class on stdout.Definition TClass.cxx:4258; TClass::fBasestd::atomic< TList * > fBaseDefinition TClass.h:201; TClass::fCanSplitstd::atomic< Char_t > fCanSplitDefinition TClass.h:245; TClass::HasDictionaryBool_t HasDictionary() constCheck whether a class has a dictionary or not.Definition TClass.cxx:3906; TClass::GetListOfAllPublicMethodsconst TList * GetListOfAllPublicMethods(Bool_t load=kTRUE)Returns a list of all public methods of this class and its base classes.Definition TClass.cxx:3845; TClass::HasCustomStreamerMemberBool_t HasCustomStreamerMember() constThe class has a Streamer method and it is implemented by the user or an older (not StreamerInfo based...Definition TClass.h:508; TClass::SetDeclFilevoid SetDeclFile(const char *name, Short_t line)Definition TClass.h:555; TClass::GetListOfAllPublicDataMembersTList * GetListOfAllPublicDataMembers(Bool_t load=kTRUE)Returns a list of all public data members of this class and its base classes.Definition TClass.cxx:3862; TClass::TClassTClass(const TClass &tc)=delete; TClass::AddClassToDeclIdMapstatic void AddClassToDeclIdMap(TDictionary::DeclId_t id, TClass *cl)static: Add a TClass* to the map of classes.Definition TClass.cxx:511; TClass::~TClassvirtual ~TClass()TClass dtor. Deletes all list that might have been created.Definition TClass.cxx:1660; TClass::fIsSyntheticPairBool_t fIsSyntheticPairIndicates whether ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8h_source.html:48015,load,load,48015,doc/v632/TClass_8h_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html,1,['load'],['load']
Performance,"nst char *proto, Bool_t objectIsConst=kFALSE, ROOT::EFunctionMatchMode mode=ROOT::kConversionMatch)Find the method with a given prototype.Definition TClass.cxx:4523; TClass::CopyCollectionProxyvoid CopyCollectionProxy(const TVirtualCollectionProxy &)Replaces the collection proxy for this class.Definition TClass.cxx:2537; TClass::fStreamerTypeInt_t fStreamerTypesaved info to call StreamerDefinition TClass.h:276; TClass::fRealDataTList * fRealDataDefinition TClass.h:200; TClass::fOnHeapUInt_t fOnHeapDefinition TClass.h:218; TClass::lsvoid ls(Option_t *opt="""") const overrideThe ls function lists the contents of a class on stdout.Definition TClass.cxx:4325; TClass::fBasestd::atomic< TList * > fBaseDefinition TClass.h:201; TClass::fCanSplitstd::atomic< Char_t > fCanSplitDefinition TClass.h:245; TClass::HasDictionaryBool_t HasDictionary() constCheck whether a class has a dictionary or not.Definition TClass.cxx:3973; TClass::GetListOfAllPublicMethodsconst TList * GetListOfAllPublicMethods(Bool_t load=kTRUE)Returns a list of all public methods of this class and its base classes.Definition TClass.cxx:3912; TClass::GetListOfAllPublicDataMembersTList * GetListOfAllPublicDataMembers(Bool_t load=kTRUE)Returns a list of all public data members of this class and its base classes.Definition TClass.cxx:3929; TClass::AddClassToDeclIdMapstatic void AddClassToDeclIdMap(TDictionary::DeclId_t id, TClass *cl)static: Add a TClass* to the map of classes.Definition TClass.cxx:576; TClass::~TClassvirtual ~TClass()TClass dtor. Deletes all list that might have been created.Definition TClass.cxx:1727; TClass::fIsSyntheticPairBool_t fIsSyntheticPairIndicates whether this class can be split or not. Values are -1, 0, 1, 2.Definition TClass.h:250; TClass::Destructorvoid Destructor(void *obj, Bool_t dtorOnly=kFALSE)Explicitly call destructor for object.Definition TClass.cxx:5467; TClass::fClassVersionVersion_t fClassVersionDefinition TClass.h:221; TClass::fCurrentInfostd::atomic< TVirtualStreamerInfo ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:316968,load,load,316968,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['load'],['load']
Performance,"nst char *proto, Bool_t objectIsConst=kFALSE, ROOT::EFunctionMatchMode mode=ROOT::kConversionMatch)Find the method with a given prototype.Definition TClass.cxx:4523; TClass::CopyCollectionProxyvoid CopyCollectionProxy(const TVirtualCollectionProxy &)Replaces the collection proxy for this class.Definition TClass.cxx:2537; TClass::fStreamerTypeInt_t fStreamerTypesaved info to call StreamerDefinition TClass.h:276; TClass::fRealDataTList * fRealDataDefinition TClass.h:200; TClass::fOnHeapUInt_t fOnHeapDefinition TClass.h:218; TClass::lsvoid ls(Option_t *opt="""") const overrideThe ls function lists the contents of a class on stdout.Definition TClass.cxx:4325; TClass::fBasestd::atomic< TList * > fBaseDefinition TClass.h:201; TClass::fCanSplitstd::atomic< Char_t > fCanSplitDefinition TClass.h:245; TClass::HasDictionaryBool_t HasDictionary() constCheck whether a class has a dictionary or not.Definition TClass.cxx:3973; TClass::GetListOfAllPublicMethodsconst TList * GetListOfAllPublicMethods(Bool_t load=kTRUE)Returns a list of all public methods of this class and its base classes.Definition TClass.cxx:3912; TClass::HasCustomStreamerMemberBool_t HasCustomStreamerMember() constThe class has a Streamer method and it is implemented by the user or an older (not StreamerInfo based...Definition TClass.h:508; TClass::SetDeclFilevoid SetDeclFile(const char *name, Short_t line)Definition TClass.h:555; TClass::GetListOfAllPublicDataMembersTList * GetListOfAllPublicDataMembers(Bool_t load=kTRUE)Returns a list of all public data members of this class and its base classes.Definition TClass.cxx:3929; TClass::TClassTClass(const TClass &tc)=delete; TClass::AddClassToDeclIdMapstatic void AddClassToDeclIdMap(TDictionary::DeclId_t id, TClass *cl)static: Add a TClass* to the map of classes.Definition TClass.cxx:576; TClass::~TClassvirtual ~TClass()TClass dtor. Deletes all list that might have been created.Definition TClass.cxx:1727; TClass::fIsSyntheticPairBool_t fIsSyntheticPairIndicates whether ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8h_source.html:47843,load,load,47843,doc/master/TClass_8h_source.html,https://root.cern,https://root.cern/doc/master/TClass_8h_source.html,1,['load'],['load']
Performance,"nst char *t="""");  ;  ~TEveCaloData () override;  ; virtual void CellSelectionChanged ();  Tell users (TEveCaloViz instances using this data) that cell selection has changed and they should update selection cache if necessary. ;  ; Bool_t Empty () const;  ; void FillImpliedSelectedSet (Set_t &impSelSet) override;  Populate set impSelSet with derived / dependant elements. ;  ; vCellId_t & GetCellsHighlighted ();  ; vCellId_t & GetCellsSelected ();  ; virtual Float_t GetEps () const;  ; virtual TAxis * GetEtaBins () const;  ; TString GetHighlightTooltip () override;  ; virtual Float_t GetMaxVal (Bool_t et) const;  ; Int_t GetNSlices () const;  ; virtual TAxis * GetPhiBins () const;  ; Color_t GetSliceColor (Int_t slice) const;  Get color for given slice. ;  ; Float_t GetSliceThreshold (Int_t slice) const;  Get threshold for given slice. ;  ; Char_t GetSliceTransparency (Int_t slice) const;  Get transparency for given slice. ;  ; Bool_t GetWrapTwoPi () const;  ; virtual void InvalidateUsersCellIdCache ();  Invalidate cell ids cache on back ptr references. ;  ; void PrintCellsSelected ();  Print selected cells info. ;  ; void ProcessSelection (vCellId_t &sel_cells, TGLSelectRecord &rec);  Process newly selected cells with given select-record. ;  ; SliceInfo_t & RefSliceInfo (Int_t s);  ; virtual void SetEps (Float_t eps);  ; virtual void SetEtaBins (TAxis *ax);  ; virtual void SetPhiBins (TAxis *ax);  ; void SetSliceColor (Int_t slice, Color_t col);  Set color for given slice. ;  ; void SetSliceThreshold (Int_t slice, Float_t threshold);  Set threshold for given slice. ;  ; void SetSliceTransparency (Int_t slice, Char_t t);  Set transparency for given slice. ;  ; void SetWrapTwoPi (Bool_t w);  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void UnHighlighted () override;  Virtual method TEveElement::UnHighlighted. ;  ; void UnSelected () override;  Virtual method TEveElement::UnSelect. ;  ;  Public Member Functions inherited from TEveElement;  TEveElem",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEveCaloDataHist.html:2744,cache,cache,2744,doc/master/classTEveCaloDataHist.html,https://root.cern,https://root.cern/doc/master/classTEveCaloDataHist.html,2,['cache'],['cache']
Performance,"nst char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t resultDefinition TGWin32VirtualXProxy.cxx:174; TMVAGui.h; TObjString.h; TROOT.h; gROOT#define gROOTDefinition TROOT.h:406; TString.h; Formchar * Form(const char *fmt,...)Formats a string in a circular formatting buffer.Definition TString.cxx:2489; TSystem.h; TTree.h; Tools.h; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TFile::Openstatic TFile * Open(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Create / open a file.Definition TFile.cxx:4089; TFile::Closevoid Close(Option_t *option="""") overrideClose a file.Definition TFile.cxx:950; TMVA::CrossValidationClass to perform cross validation, splitting the dataloader into folds.Definition CrossValidation.h:124; TMVA::DataLoaderDefinition DataLoader.h:50; TMVA::DataLoader::AddSignalTreevoid AddSignalTree(TTree *signal, Double_t weight=1.0, Types::ETreeType treetype=Types::kMaxTreeType)number of signal events (used to compute significance)Definition DataLoader.cxx:371; TMVA::DataLoader::AddSpectatorvoid AddSpectator(const TString &expression, const TString &title="""", const TString &unit="""", Double_t min=0, Double_t max=0)user inserts target in data set infoDefinition DataLoader.cxx:524; TMVA::DataLoader::PrepareTrainingAndTestTreevoid PrepareTrainingAndTestTree(const TCut &cut, const TString &splitOpt)prepare the training and test trees -> same cuts for signal and backgroundDefinition DataLoader.cxx:632; TMVA::DataLoader::AddBackgroundTreevoid AddBackgroundTree(TTree *background, Double_t weight=1.0, Types::ETreeType treetype=Types::kMaxTreeType)number of signal events (used to compute significance)Definition Da",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVACrossValidation_8C.html:28176,perform,perform,28176,doc/master/TMVACrossValidation_8C.html,https://root.cern,https://root.cern/doc/master/TMVACrossValidation_8C.html,1,['perform'],['perform']
Performance,"nst char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t typeDefinition TGWin32VirtualXProxy.cxx:249; y1Option_t Option_t TPoint TPoint const char y1Definition TGWin32VirtualXProxy.cxx:70; namechar name[80]Definition TGX11.cxx:110; TString.h; TrainingHistory.h; TransformationHandler.h; TDirectoryDescribe directory structure in memory.Definition TDirectory.h:45; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TGraphA TGraph is an object made of two arrays X and Y with npoints each.Definition TGraph.h:41; TH1D1-D histogram with a double per channel (see TH1 documentation)Definition TH1.h:670; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; ClassificationClass to perform two class classification.; TMVA::ConfigurableDefinition Configurable.h:45; TMVA::CrossValidationClass to perform cross validation, splitting the dataloader into folds.Definition CrossValidation.h:124; TMVA::DataSetInfoClass that contains all the data information.Definition DataSetInfo.h:62; TMVA::DataSetInfo::GetNVariablesUInt_t GetNVariables() constDefinition DataSetInfo.h:127; TMVA::DataSetInfo::GetNTargetsUInt_t GetNTargets() constDefinition DataSetInfo.h:128; TMVA::DataSetInfo::GetDataSetDataSet * GetDataSet() constreturns data setDefinition DataSetInfo.cxx:493; TMVA::DataSetInfo::GetVariableInfoVariableInfo & GetVariableInfo(Int_t i)Definition DataSetInfo.h:105; TMVA::DataSetClass that contains all the data information.Definition DataSet.h:58; TMVA::DataSet::GetNEventsLong64_t GetNEvents(Types::ETreeType type=Types::kMaxTreeType) constDefinition DataSet.h:206; TMVA::DataSet::GetNTrainingEventsLong64_t GetNTrainingEvents() constDefinition DataSet.h:68; TMVA::EventDefinition E",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodBase_8h_source.html:35904,perform,perform,35904,doc/master/MethodBase_8h_source.html,https://root.cern,https://root.cern/doc/master/MethodBase_8h_source.html,1,['perform'],['perform']
Performance,"nst char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t targetDefinition TGWin32VirtualXProxy.cxx:247; TROOT.h; TStopwatch.h; TString.h; TSystem.h; gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:561; TTree.h; Tools.h; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TFile::Openstatic TFile * Open(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Create / open a file.Definition TFile.cxx:4089; TFile::SetCacheFileDirstatic Bool_t SetCacheFileDir(std::string_view cacheDir, Bool_t operateDisconnected=kTRUE, Bool_t forceCacheread=kFALSE)Sets the directory where to locally stage/cache remote files.Definition TFile.cxx:4626; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TH1::Fillvirtual Int_t Fill(Double_t x)Increment bin with abscissa X by 1.Definition TH1.cxx:3344; TMVA::ReaderThe Reader class serves to use the MVAs in a specific analysis context.Definition Reader.h:64; TMVA::Reader::EvaluateRegressionconst std::vector< Float_t > & EvaluateRegression(const TString &methodTag, Double_t aux=0)evaluates MVA for given set of input variablesDefinition Reader.cxx:565; TMVA::Reader::BookMVAIMethod * BookMVA(const TString &methodTag, const TString &weightfile)read method name from weight fileDefinition Reader.cxx:368; TMVA::Reader::AddSpectatorvoid AddSpectator(const TString &expression, Float_t *)Add a float spectator or expression to the reader.Definition Reade",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegressionApplication_8C.html:10322,cache,cacheDir,10322,doc/master/TMVARegressionApplication_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegressionApplication_8C.html,4,['cache'],"['cache', 'cacheDir']"
Performance,"nst char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t targetDefinition TGWin32VirtualXProxy.cxx:247; TROOT.h; TStopwatch.h; TString.h; TSystem.h; gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:561; TTree.h; Tools.h; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TFile::Openstatic TFile * Open(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Create / open a file.Definition TFile.cxx:4089; TFile::SetCacheFileDirstatic Bool_t SetCacheFileDir(std::string_view cacheDir, Bool_t operateDisconnected=kTRUE, Bool_t forceCacheread=kFALSE)Sets the directory where to locally stage/cache remote files.Definition TFile.cxx:4626; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TMVA::MethodBase::GetInputVarconst TString & GetInputVar(Int_t i) constDefinition MethodBase.h:349; TMVA::MethodCutsMultivariate optimisation of signal efficiency for given background efficiency, applying rectangular ...Definition MethodCuts.h:61; TMVA::MethodCuts::GetCutsDouble_t GetCuts(Double_t effS, std::vector< Double_t > &cutMin, std::vector< Double_t > &cutMax) constretrieve cut values for given signal efficiencyDefinition MethodCuts.cxx:551; TMVA::ReaderThe Reader class serves to use the MVAs in a specific analysis context.Definition Reader.h:64; TMVA::Reader::EvaluateMVADouble_t EvaluateMVA(const std::vector< Float_t > &, const TString &methodTag, Double_t aux=0)Evaluate a std::vector<float> of input data for a given method The parameter aux is obligatory for ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAClassificationApplication_8C.html:25175,cache,cacheDir,25175,doc/master/TMVAClassificationApplication_8C.html,https://root.cern,https://root.cern/doc/master/TMVAClassificationApplication_8C.html,4,['cache'],"['cache', 'cacheDir']"
Performance,"nst char* const argv[], void *interpLibHandle);; 196 ; 197 void AddIncludePath(const char* path) final;; 198 void *GetAutoLoadCallBack() const final { return fAutoLoadCallBack; }; 199 void *SetAutoLoadCallBack(void* cb) final { void* prev = fAutoLoadCallBack; fAutoLoadCallBack = cb; return prev; }; 200 Int_t AutoLoad(const char *classname, Bool_t knowDictNotLoaded = kFALSE) final;; 201 Int_t AutoLoad(const std::type_info& typeinfo, Bool_t knowDictNotLoaded = kFALSE) final;; 202 Int_t AutoParse(const char* cls) final;; 203 void* LazyFunctionCreatorAutoload(const std::string& mangled_name);; 204 bool LibraryLoadingFailed(const std::string&, const std::string&, bool, bool);; 205 Bool_t IsAutoLoadNamespaceCandidate(const clang::NamespaceDecl* nsDecl);; 206 void ClearFileBusy() final;; 207 void ClearStack() final; // Delete existing temporary values; 208 Bool_t Declare(const char* code) final;; 209 void EndOfLineAction() final;; 210 TClass *GetClass(const std::type_info& typeinfo, Bool_t load) const final;; 211 Int_t GetExitCode() const final { return fExitCode; }; 212 TEnv* GetMapfile() const final { return fMapfile; }; 213 Int_t GetMore() const final;; 214 TClass *GenerateTClass(const char *classname, Bool_t emulation, Bool_t silent = kFALSE) final;; 215 TClass *GenerateTClass(ClassInfo_t *classinfo, Bool_t silent = kFALSE) final;; 216 Int_t GenerateDictionary(const char* classes, const char* includes = """", const char* options = nullptr) final;; 217 char* GetPrompt() final { return fPrompt; }; 218 const char* GetSharedLibs() final;; 219 const char* GetClassSharedLibs(const char* cls, bool skipCore = true) final;; 220 const char* GetSharedLibDeps(const char* lib, bool tryDyld = false) final;; 221 const char* GetIncludePath() final;; 222 virtual const char* GetSTLIncludePath() const final;; 223 TObjArray* GetRootMapFiles() const final { return fRootmapFiles; }; 224 unsigned long long GetInterpreterStateMarker() const final { return fTransactionCount;}; 225 virtual void In",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8h_source.html:8577,load,load,8577,doc/master/TCling_8h_source.html,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html,1,['load'],['load']
Performance,"nst char* fname); Checked that filename does not contains relative path below current directory; Used to prevent access to files below current directory. Bool_t IsFileRequested(const char* uri, TString& res) const; Verifies that request is just file name; File names typically contains prefix like ""jsrootsys/""; If true, method returns real name of the file,; which should be delivered to the client; Method is thread safe and can be called from any thread. Bool_t ExecuteHttp(THttpCallArg* arg); Executes http request, specified in THttpCallArg structure; Method can be called from any thread; Actual execution will be done in main ROOT thread, where analysis code is running. void ProcessRequests(); Process requests, submitted for execution; Regularly invoked by THttpTimer, when somewhere in the code; gSystem->ProcessEvents() is called.; User can call serv->ProcessRequests() directly, but only from main analysis thread. void ProcessRequest(THttpCallArg* arg); Process single http request; Depending from requested path and filename different actions will be performed.; In most cases information is provided by TRootSniffer class. Bool_t Register(const char* subfolder, TObject* obj); Register object in folders hierarchy. See TRootSniffer::RegisterObject() for more details. Bool_t Unregister(TObject* obj); Unregister object in folders hierarchy. See TRootSniffer::UnregisterObject() for more details. const char * GetMimeType(const char* path); Returns MIME type base on file extension. char* ReadFileContent(const char* filename, Int_t& len); reads file content. void SetTopName(const char* top); these methods used to set http request arguments. const char * GetTopName() const; returns engine-specific top-name. THttpServer(const char* engine = ""civetweb:8080""). TRootSniffer * GetSniffer() const. » Last changed: Tue Jun 30 15:13:14 2015 » Last generated: 2015-06-30 15:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in ge",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/THttpServer.html:10023,perform,performed,10023,root/html602/THttpServer.html,https://root.cern,https://root.cern/root/html602/THttpServer.html,2,['perform'],['performed']
Performance,"nst char* fname); Checked that filename does not contains relative path below current directory; Used to prevent access to files below current directory. Bool_t IsFileRequested(const char* uri, TString& res) const; Verifies that request is just file name; File names typically contains prefix like ""jsrootsys/""; If true, method returns real name of the file,; which should be delivered to the client; Method is thread safe and can be called from any thread. Bool_t ExecuteHttp(THttpCallArg* arg); Executes http request, specified in THttpCallArg structure; Method can be called from any thread; Actual execution will be done in main ROOT thread, where analysis code is running. void ProcessRequests(); Process requests, submitted for execution; Regularly invoked by THttpTimer, when somewhere in the code; gSystem->ProcessEvents() is called.; User can call serv->ProcessRequests() directly, but only from main analysis thread. void ProcessRequest(THttpCallArg* arg); Process single http request; Depending from requested path and filename different actions will be performed.; In most cases information is provided by TRootSniffer class. Bool_t Register(const char* subfolder, TObject* obj); Register object in folders hierarchy. See TRootSniffer::RegisterObject() for more details. Bool_t Unregister(TObject* obj); Unregister object in folders hierarchy. See TRootSniffer::UnregisterObject() for more details. void Restrict(const char* path, const char* options); Restrict access to specified object. See TRootSniffer::Restrict() for more details. Bool_t RegisterCommand(const char* cmdname, const char* method, const char* icon = 0); Register command which can be executed from web interface. As method one typically specifies string, which is executed with; gROOT->ProcessLine() method. For instance; serv->RegisterCommand(""Invoke"",""InvokeFunction()"");. Or one could specify any method of the object which is already registered; to the server. For instance:; serv->Register(""/"", hpx);; serv->Regist",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/THttpServer.html:12770,perform,performed,12770,root/html534/THttpServer.html,https://root.cern,https://root.cern/root/html534/THttpServer.html,4,['perform'],['performed']
Performance,"nst char* indent = """", const char* namePat = 0); Print tree structure of expression tree on given ostream, only branch nodes are printed.; Lead nodes (variables) will not be shown. If namePat is not ""*"", only nodes with names matching the pattern will be printed. TString cleanBranchName() const; Construct a mangled name from the actual name that; is free of any math symbols that might be interpreted by TTree. UInt_t crc32(const char* data); Calculate crc32 checksum on given string. void printCompactTreeHook(ostream& os, const char* ind = """"); Hook function interface for object to insert additional information; when printed in the context of a tree structure. This default; implementation prints nothing. void registerCache(RooAbsCache& cache); Register RooAbsCache with this object. This function is called; by RooAbsCache constructors for objects that are a datamember; of this RooAbsArg. By registering itself the RooAbsArg is aware; of all its cache data members and will forward server change; and cache mode change calls to the cache objects, which in turn; can forward them their contents. void unRegisterCache(RooAbsCache& cache); Unregister a RooAbsCache. Called from the RooAbsCache destructor. Int_t numCaches() const; Return number of registered caches. RooAbsCache* getCache(Int_t index) const; Return registered cache object by index. RooArgSet* getVariables(Bool_t stripDisconnected = kTRUE) const; Return RooArgSet with all variables (tree leaf nodes of expresssion tree). RooLinkedList getCloningAncestors() const; Return ancestors in cloning chain of this RooAbsArg. NOTE: Returned pointers; are not guaranteed to be 'live', so do not dereference without proper caution. void graphVizTree(const char* fileName, const char* delimiter, bool useTitle, bool useLatex); Create a GraphViz .dot file visualizing the expression tree headed by; this RooAbsArg object. Use the GraphViz tool suite to make e.g. a gif; or ps file from the .dot file. Based on concept developed by Kyle Cr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsArg.html:32952,cache,cache,32952,root/html526/RooAbsArg.html,https://root.cern,https://root.cern/root/html526/RooAbsArg.html,3,['cache'],['cache']
Performance,"nst char* isetRangeName) const; virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAddModel::CacheElem*getProjCache(const RooArgSet* nset, const RooArgSet* iset = 0, const char* rangeName = 0) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; static voidRooAbsReal::globalSelectComp(Bool_t flag); voidRooAbsArg::graphVizAddConnections(set<pair<RooAbsArg*,RooAbsArg*> >&); Bool_tRooAbsArg::inhibitDirty() const; TStringRooAbsReal::integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset = 0, const char* rangeName = 0, Bool_t omitEmpty = kFALSE) const; Bool_tRooAbsReal::isSelectedComp() const; virtual Bool_tRooAbsReal::isValid() const; virtual Bool_tRooAbsReal::isValidReal(Double_t value, Bool_t printError = kFALSE) const; voidRooAbsReal::makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; voidTObject::MakeZombie(); Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c, const RooArgProxy& d) const; Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooArgSet& params, Bool_t showConstants = kFALSE, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAddModel.html:37218,optimiz,optimizeDirtyHook,37218,root/html602/RooAddModel.html,https://root.cern,https://root.cern/root/html602/RooAddModel.html,4,['optimiz'],['optimizeDirtyHook']
Performance,"nst char* location, const char* fmt, va_list va) const; TList*TProof::GetEnabledPackages() const; static Bool_tTProof::GetFileInCmd(const char* cmd, TString& fn); static Int_tTProof::GetInputData(TList* input, const char* cachedir, TString& emsg); TList*TProof::GetListOfActiveSlaves() const; TVirtualProofPlayer*TProof::GetPlayer() const; TPluginHandler*TProof::GetProgressDialog() const; Int_tTProof::GetSandbox(TString& sb, Bool_t assert = kFALSE, const char* rc = 0); virtual void*TQObject::GetSender(); virtual const char*TQObject::GetSenderClassName() const; voidTProof::HandleLibIncPath(const char* what, Bool_t add, const char* dirs); Int_tTProof::HandleOutputOptions(TString& opt, TString& target, Int_t action); Int_tTProof::Init(const char* masterurl, const char* conffile, const char* confdir, Int_t loglevel, const char* alias = 0); voidTProof::InitMembers(); virtual TVirtualProofPlayer*MakePlayer(const char* player = 0, TSocket* s = 0); voidTObject::MakeZombie(); virtual Int_tTProof::PollForNewWorkers(); voidTProof::PrepareInputDataFile(TString& dataFile); Int_tTProof::RemoveWorkers(TList* wrks); static Int_tTProof::SaveInputData(TQueryResult* qr, const char* cachedir, TString& emsg); virtual voidTProof::SaveWorkerInfo(); Int_tTProof::SendFile(const char* file, Int_t opt = (kBinary|kForward|kCp|kCpBin), const char* rfile = 0, TSlave* sl = 0); static Int_tTProof::SendInputData(TQueryResult* qr, TProof* p, TString& emsg); virtual voidTProof::SendInputDataFile(); voidTProof::SetDSet(TDSet* dset); voidTProof::SetFeedback(TString& opt, TString& optfb, Int_t action); voidTProof::SetPlayer(TVirtualProofPlayer* player); voidTProof::SetupWorkersEnv(TList* wrks, Bool_t increasingpool = kFALSE); static void*TProof::SlaveStartupThread(void* arg); virtual Bool_tStartSlaves(Bool_t); static voidTProof::SystemCmd(const char* cmd, Int_t fdout); voidTProof::UpdateDialog(); virtual voidValidateDSet(TDSet* dset); Int_tTProof::VerifyDataSetParallel(const char* uri, const char* optStr).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofSuperMaster.html:22492,cache,cachedir,22492,root/html534/TProofSuperMaster.html,https://root.cern,https://root.cern/root/html534/TProofSuperMaster.html,2,['cache'],['cachedir']
Performance,"nst char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. TBaseClass(const TBaseClass&); TBaseClass&operator=(const TBaseClass&). Data Members; public:. enum TDictionary::ESTLType { kNone; kVector; kList; kDeque; kMap; kMultimap; kSet; kMultiset; kBitset; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TClass*fClasspointer to parent class; TClassReffClassPtrpointer to the base class TClass; BaseClassInfo_t*fInfopointer to CINT base class info; Long_tfOffset!Cache offset of the baseClassInfo.; Long_tfProperty!Cache property of the baseClassInfo. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBaseClass(BaseClassInfo_t* info = 0, TClass* cl = 0); Default TBaseClass ctor. TBaseClasses are constructed in TClass; via a call to TCint::CreateListOfBaseClasses(). ~TBaseClass(); TBaseClass dtor deletes adopted CINT BaseClassInfo object. void Browse(TBrowser* b); Called by the browser, to browse a baseclass. TClass * GetClassPointer(Bool_t load = kTRUE); Get pointer to the base class TClass. Int_t GetDelta() const; Get offset from ""this"" to part of base class. const char * GetTitle() const; Get base class description (comment). int IsSTLContainer(); Return which type (if any) of STL container the data member is. Long_t Property() const; Get property description word. For meaning of bits see EProperty. TBaseClass(const TBaseClass& ). TBaseClass&",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TBaseClass.html:6335,Cache,Cache,6335,root/html534/TBaseClass.html,https://root.cern,https://root.cern/root/html534/TBaseClass.html,1,['Cache'],['Cache']
Performance,"nst char* name); Return kTRUE if 'url' matches the coordinates of this file.; The check is implementation dependent and may need to be overload; by each TFile implememtation relying on this check.; The default implementation checks the file name only. const TUrl * GetEndpointUrl(const char* name); Get final URL for file being opened asynchronously.; Returns 0 is the information is not yet available. void CpProgress(Long64_t bytesread, Long64_t size, TStopwatch& watch); Print file copy progress. Bool_t Cp(const char* src, const char* dst, Bool_t progressbar = kTRUE, UInt_t buffersize = 1000000); Allows to copy file from src to dst URL. Returns kTRUE in case of success,; kFALSE otherwise. Bool_t ReadBufferAsync(Long64_t offs, Int_t len); Read specified byte range asynchronously. Actually we tell the kernel; which blocks we are going to read so it can start loading these blocks; in the buffer cache. Int_t GetBytesToPrefetch() const; Max number of bytes to prefetch. By default this is 75% of the; read cache size. But specific TFile implementations may need to change it. EAsyncOpenStatus GetAsyncOpenStatus(); { return fAsyncOpenStatus; }. Long64_t DirCreateEntry(TDirectory* ); Interface for text-based TDirectory I/O. { return 0; }. Int_t DirReadKeys(TDirectory* ); { return 0; }. void DirWriteKeys(TDirectory* ); {}. void DirWriteHeader(TDirectory* ); {}. void operator=(const TFile& ). void Copy(TObject& ) const; { MayNotUse(""Copy(TObject &)""); }. TArchiveFile * GetArchive() const; { return fArchive; }. TArrayC * GetClassIndex() const; { return fClassIndex; }. Int_t GetCompressionLevel() const; { return fCompress; }. Long64_t GetEND() const; { return fEND; }. Int_t GetFd() const; { return fD; }. const TUrl * GetEndpointUrl() const; { return &fUrl; }. TObjArray * GetListOfProcessIDs() const; {return fProcessIDs;}. TList * GetListOfFree() const; { return fFree; }. Int_t GetNfree() const; { return fFree->GetSize(); }. Int_t GetNProcessIDs() const; { return fNProcessIDs; }. Op",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFile.html:51600,cache,cache,51600,root/html528/TFile.html,https://root.cern,https://root.cern/root/html528/TFile.html,1,['cache'],['cache']
Performance,"nst char* name); Return kTRUE if 'url' matches the coordinates of this file.; The check is implementation dependent and may need to be overload; by each TFile implememtation relying on this check.; The default implementation checks the file name only. const TUrl * GetEndpointUrl(const char* name); Get final URL for file being opened asynchronously.; Returns 0 is the information is not yet available. void CpProgress(Long64_t bytesread, Long64_t size, TStopwatch& watch); Print file copy progress. Bool_t Cp(const char* src, const char* dst, Bool_t progressbar = kTRUE, UInt_t buffersize = 1000000); Allows to copy file from src to dst URL. Returns kTRUE in case of success,; kFALSE otherwise. Bool_t ReadBufferAsync(Long64_t offs, Int_t len); Read specified byte range asynchronously. Actually we tell the kernel; which blocks we are going to read so it can start loading these blocks; in the buffer cache. Int_t GetBytesToPrefetch() const; Max number of bytes to prefetch. By default this is 75% of the; read cache size. But specific TFile implementations may need to change it. Int_t GetCompressionAlgorithm() const. Int_t GetCompressionLevel() const. Int_t GetCompressionSettings() const. EAsyncOpenStatus GetAsyncOpenStatus(); { return fAsyncOpenStatus; }. Long64_t DirCreateEntry(TDirectory* ); Interface for text-based TDirectory I/O. { return 0; }. Int_t DirReadKeys(TDirectory* ); { return 0; }. void DirWriteKeys(TDirectory* ); {}. void DirWriteHeader(TDirectory* ); {}. void operator=(const TFile& ). void Copy(TObject& ) const; { MayNotUse(""Copy(TObject &)""); }. TArchiveFile * GetArchive() const; { return fArchive; }. TArrayC * GetClassIndex() const; { return fClassIndex; }. Long64_t GetEND() const; { return fEND; }. Int_t GetFd() const; { return fD; }. const TUrl * GetEndpointUrl() const; { return &fUrl; }. TObjArray * GetListOfProcessIDs() const; {return fProcessIDs;}. TList * GetListOfFree() const; { return fFree; }. Int_t GetNfree() const; { return fFree->GetSize(); }. Int_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TFile.html:53030,cache,cache,53030,root/html530/TFile.html,https://root.cern,https://root.cern/root/html530/TFile.html,1,['cache'],['cache']
Performance,"nst char* onfile_classname, UInt_t checksum) const; TVirtualStreamerInfo*TClass::FindConversionStreamerInfo(const TClass* onfile_cl, UInt_t checksum) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TVirtualStreamerInfo*TClass::FindStreamerInfo(UInt_t checksum) const; TVirtualStreamerInfo*TClass::FindStreamerInfoAbstractEmulated(UInt_t checksum) const; TClass*TClass::GetActualClass(const void* object) const; TDictAttributeMap*TDictionary::GetAttributeMap() const; TClass*TClass::GetBaseClass(const char* classname); TClass*TClass::GetBaseClass(const TClass* base); Int_tTClass::GetBaseClassOffset(const TClass* base); TClass*TClass::GetBaseDataMember(const char* datamember); UInt_tTClass::GetCheckSum(TClass::ECheckSum code = kCurrentCheckSum) const; static TClass*TClass::GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE); static TClass*TClass::GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE); ClassInfo_t*TClass::GetClassInfo() const; Int_tTClass::GetClassSize() const; Version_tTClass::GetClassVersion() const; TVirtualCollectionProxy*TClass::GetCollectionProxy() const; const char*TClass::GetContextMenuTitle() const; TVirtualStreamerInfo*TClass::GetConversionStreamerInfo(const char* onfile_classname, Int_t version) const; TVirtualStreamerInfo*TClass::GetConversionStreamerInfo(const TClass* onfile_cl, Int_t version) const; TVirtualStreamerInfo*TClass::GetCurrentStreamerInfo(); TDataMember*TClass::GetDataMember(const char* datamember) const; Long_tTClass::GetDataMemberOffset(const char* membername) const; Short_tTClass::GetDeclFileLine() const; const char*TClass::GetDeclFileName() const; ROOT::DelFunc_tTClass::GetDelete() const; ROOT::DelArrFunc_tTClass::GetDeleteArray() const; ROOT::DesFunc_tTClass::GetDestructor() const; static VoidFuncPtr_tTClass::GetDict(const char* cname); static VoidFuncPtr_tTClass::GetDict(const type_info& info); stati",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TQClass.html:7278,load,load,7278,root/html534/TQClass.html,https://root.cern,https://root.cern/root/html534/TQClass.html,2,['load'],['load']
Performance,"nst char* proto); Find the method with a given prototype. The proto string must be of the; form: ""char*,int,double"". Returns 0 in case method is not found. TMethod * GetClassMethod(Long_t faddr); Look for a method in this class that has the interface function; address faddr. TMethod * GetClassMethod(const char* name, const char* signature); Look for a method in this class that has the name and; signature. Int_t GetNdata(); Return the number of data members of this class; Note that in case the list of data members is not yet created, it will be done; by GetListOfDataMembers(). Int_t GetNmethods(); Return the number of methods of this class; Note that in case the list of methods is not yet created, it will be done; by GetListOfMethods(). TVirtualStreamerInfo* GetStreamerInfo(Int_t version = 0) const; returns a pointer to the TVirtualStreamerInfo object for version; If the object doest not exist, it is created. Note: There are two special version numbers:. 0: Use the class version from the currently loaded class library.; -1: Assume no class library loaded (emulated class). Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. void IgnoreTObjectStreamer(Bool_t ignore = kTRUE); When the class kIgnoreTObjectStreamer bit is set, the automatically; generated Streamer will not call TObject::Streamer.; This option saves the TObject space overhead on the file.; However, the information (fBits, fUniqueID) of TObject is lost. Note that this function must be called for the class deriving; directly from TObject, eg, assuming that BigTrack derives from Track; and Track derives from TObject, one must do:; Track::Class()->IgnoreTObjectStreamer();; and not:; BigTrack::Class()->IgnoreTObjectStreamer();. Bool_t InheritsFrom(const char *classname); Return kTRUE if this class inherits from a class with name ""classname"".; not",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TClass.html:29228,load,loaded,29228,root/html526/TClass.html,https://root.cern,https://root.cern/root/html526/TClass.html,1,['load'],['loaded']
Performance,"nst char* proto); Find the method with a given prototype. The proto string must be of the; form: ""char*,int,double"". Returns 0 in case method is not found. TMethod * GetClassMethod(Long_t faddr); Look for a method in this class that has the interface function; address faddr. TMethod * GetClassMethod(const char* name, const char* signature); Look for a method in this class that has the name and; signature. Int_t GetNdata(); Return the number of data members of this class; Note that in case the list of data members is not yet created, it will be done; by GetListOfDataMembers(). Int_t GetNmethods(); Return the number of methods of this class; Note that in case the list of methods is not yet created, it will be done; by GetListOfMethods(). TVirtualStreamerInfo* GetStreamerInfo(Int_t version = 0) const; returns a pointer to the TVirtualStreamerInfo object for version; If the object doest not exist, it is created. Note: There are two special version numbers:. 0: Use the class version from the currently loaded class library.; -1: Assume no class library loaded (emulated class). Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. void IgnoreTObjectStreamer(Bool_t ignore = kTRUE); When the class kIgnoreTObjectStreamer bit is set, the automatically; generated Streamer will not call TObject::Streamer.; This option saves the TObject space overhead on the file.; However, the information (fBits, fUniqueID) of TObject is lost. Note that this function must be called for the class deriving; directly from TObject, eg, assuming that BigTrack derives from Track; and Track derives from TObject, one must do:; Track::Class()->IgnoreTObjectStreamer();; and not:; BigTrack::Class()->IgnoreTObjectStreamer();. Bool_t InheritsFrom(const char* cl) const; Return kTRUE if this class inherits from a class with name ""classname"".; note",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TClass.html:32628,load,loaded,32628,root/html528/TClass.html,https://root.cern,https://root.cern/root/html528/TClass.html,1,['load'],['loaded']
Performance,"nst char* proto); Find the method with a given prototype. The proto string must be of the; form: ""char*,int,double"". Returns 0 in case method is not found. TMethod * GetClassMethod(Long_t faddr); Look for a method in this class that has the interface function; address faddr. TMethod * GetClassMethod(const char* name, const char* signature); Look for a method in this class that has the name and; signature. Int_t GetNdata(); Return the number of data members of this class; Note that in case the list of data members is not yet created, it will be done; by GetListOfDataMembers(). Int_t GetNmethods(); Return the number of methods of this class; Note that in case the list of methods is not yet created, it will be done; by GetListOfMethods(). TVirtualStreamerInfo* GetStreamerInfo(Int_t version = 0) const; returns a pointer to the TVirtualStreamerInfo object for version; If the object doest not exist, it is created. Note: There are two special version numbers:. 0: Use the class version from the currently loaded class library.; -1: Assume no class library loaded (emulated class). Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. void IgnoreTObjectStreamer(Bool_t ignore = kTRUE); When the class kIgnoreTObjectStreamer bit is set, the automatically; generated Streamer will not call TObject::Streamer.; This option saves the TObject space overhead on the file.; However, the information (fBits, fUniqueID) of TObject is lost. Note that to be effective for objects streamed object-wise this function; must be called for the class deriving directly from TObject, eg, assuming; that BigTrack derives from Track and Track derives from TObject, one must do:; Track::Class()->IgnoreTObjectStreamer();; and not:; BigTrack::Class()->IgnoreTObjectStreamer();; To be effective for object streamed member-wise or split in a TTree,; t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TClass.html:32945,load,loaded,32945,root/html530/TClass.html,https://root.cern,https://root.cern/root/html530/TClass.html,3,['load'],['loaded']
Performance,"nst char* slot); static voidTApplication::Close(TApplication* app); static TStringTQObject::CompressName(const char* method_name); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); virtual voidDeletePlayer(); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual Int_tFork(); virtual void*TQObject::GetSender(); virtual const char*TQObject::GetSenderClassName() const; Int_tGetSessionStatus(); virtual voidHandleArchive(TMessage* mess, TString* slb = 0); virtual Int_tHandleCache(TMessage* mess, TString* slb = 0); virtual voidHandleCheckFile(TMessage* mess, TString* slb = 0); virtual Int_tHandleDataSets(TMessage* mess, TString* slb = 0); virtual voidHandleFork(TMessage* mess); virtual voidHandleLibIncPath(TMessage* mess); virtual voidHandleProcess(TMessage* mess, TString* slb = 0); virtual voidHandleQueryList(TMessage* mess); virtual voidHandleRemove(TMessage* mess, TString* slb = 0); virtual voidHandleRetrieve(TMessage* mess, TString* slb = 0); virtual voidHandleSubmerger(TMessage* mess); virtual Int_tHandleWorkerLists(TMessage* mess); virtual voidTApplication::Help(const char* line); Bool_tIsIdle(); virtual voidTApplication::LoadGraphicsLibs(); virtual voidTApplication::MakeBatch(); virtual voidMakePlayer(); voidTObject::MakeZombie(); static TApplication*TApplication::Open(const char* url, Int_t debug, const char* script); static Int_tTApplication::ParseRemoteLine(const char* ln, TString& hostdir, TString& user, Int_t& dbg, TString& script); virtual voidProcessNext(TString* slb = 0); virtual Long_tTApplication::ProcessRemote(const char* line, Int_t* error = 0); voidTApplication::SetSignalHandler(TSignalHandler* sh); virtual Int_tSetup(); Int_tSetupCommon(); Bool_tUnlinkDataDir(const char* path).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofServ.html:14379,Load,LoadGraphicsLibs,14379,root/html602/TProofServ.html,https://root.cern,https://root.cern/root/html602/TProofServ.html,1,['Load'],['LoadGraphicsLibs']
Performance,"nst char* title, Double_t value); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooConstVar.html:24015,cache,cache,24015,root/html602/RooConstVar.html,https://root.cern,https://root.cern/root/html602/RooConstVar.html,4,['cache'],['cache']
Performance,"nst char* title, RooAbsReal& _intpdf, const RooArgSet& intObs); Construct projection of input pdf '_intpdf' over observables 'intObs'. RooProjectedPdf(const RooProjectedPdf& other, const char* name = 0); Copy constructor. Double_t getValV(const RooArgSet* set = 0) const; Special version of getVal() overrides RooAbsReal::getValF() to save value of current normalization set. Double_t evaluate() const; Evaluate projected p.d.f. const RooAbsReal* getProjection(const RooArgSet* iset, const RooArgSet* nset, const char* rangeName, int& code) const; Retrieve object representing projection integral of input p.d.f; over observables iset, while normalizing over observables; nset. The code argument returned by reference is the unique code; defining this particular projection configuration. RooAbsPdf* createProjection(const RooArgSet& iset); Special version of RooAbsReal::createProjection that deals with; projections of projections. Instead of integrating twice, a new; RooProjectedPdf is returned that is configured to perform the; complete integration in one step. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force RooRealIntegral to relegate integration of all observables to internal logic. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Mark all requested variables as internally integrated. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Return analytical integral represent by appropriate element of projection cache. Int_t getGenerator(const RooArgSet& directVars, RooArgSet& generateVars, Bool_t staticInitOK = kTRUE) const; No internal generator is implemented. void generateEvent(Int_t code); No internal generator is implemented. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Bool_t , Bool_t , Bool_t ); Intercept a server redirection all and update list of dependents if necessary; Specifically update the set proxy ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooProjectedPdf.html:43620,perform,perform,43620,root/html532/RooProjectedPdf.html,https://root.cern,https://root.cern/root/html532/RooProjectedPdf.html,8,['perform'],['perform']
Performance,"nst double * X() const =0return pointer to X values at the minimum; ROOT::Math::Minimizer::NIterationsvirtual unsigned int NIterations() constnumber of iterations to reach the minimumDefinition Minimizer.h:231; ROOT::Math::Minimizer::SetMaxIterationsvoid SetMaxIterations(unsigned int maxiter)set maximum iterations (one iteration can have many function calls)Definition Minimizer.h:334; ROOT::Math::Minimizer::SetVariableInitialRangevirtual bool SetVariableInitialRange(unsigned int, double, double)set the initial range of an existing variableDefinition Minimizer.h:208; ROOT::Math::Minimizer::SetErrorDefvoid SetErrorDef(double up)set scale for calculating the errorsDefinition Minimizer.h:347; ROOT::Math::Minimizer::GetVariableSettingsvirtual bool GetVariableSettings(unsigned int ivar, ROOT::Fit::ParameterSettings &pars) constget variable settings in a variable object (like ROOT::Fit::ParamsSettings)Definition Minimizer.cxx:109; ROOT::Math::Minimizer::SetValidErrorvoid SetValidError(bool on)flag to check if minimizer needs to perform accurate error analysis (e.g. run Hesse for Minuit)Definition Minimizer.h:350; ROOT::Math::Minimizer::SetVariablesint SetVariables(const VariableIterator &begin, const VariableIterator &end)add variables . Return number of variables successfully addedDefinition Minimizer.h:146; ROOT::Math::Minimizer::GlobalCCvirtual double GlobalCC(unsigned int ivar) constreturn global correlation coefficient for variable i This is a number between zero and one which give...Definition Minimizer.cxx:161; ROOT::Math::Minimizer::MinGradientvirtual const double * MinGradient() constreturn pointer to gradient values at the minimumDefinition Minimizer.h:225; ROOT::Math::Minimizer::MinimizerMinimizer(Minimizer &&)=delete; ROOT::Math::Minimizer::fStatusint fStatusstatus of minimizerDefinition Minimizer.h:371; ROOT::Math::Minimizer::SetVariableValuevirtual bool SetVariableValue(unsigned int ivar, double value)set the value of an already existing variableDefinition Min",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Minimizer_8h_source.html:23278,perform,perform,23278,doc/master/Minimizer_8h_source.html,https://root.cern,https://root.cern/doc/master/Minimizer_8h_source.html,1,['perform'],['perform']
Performance,"nst double *), the new function dimension, the number of parameters (number of fixed variables) and an array specifying the index of the fixed variables which became; 149 parameters in the new API; 150 */; 151 ; 152 WrappedParamFunctionGen (const FuncPtr & func, unsigned int dim, unsigned int npar, const double * par, const unsigned int * idx) :; 153 fFunc(func),; 154 fDim(dim),; 155 fParams(std::vector<double>(par,par+npar) ),; 156 fParIndices(std::vector<unsigned int>(idx, idx + npar) ),; 157 fX(std::vector<double>(npar+dim) ) // cached vector; 158 {; 159 DoInit();; 160 }; 161 ; 162 /**; 163 Constructor as before but taking now a non - const pointer to a callable object.; 164 This constructor is needed in the case FuncPtr is a std::unique_ptr which has a copy ctor taking non const objects; 165 */; 166 WrappedParamFunctionGen (FuncPtr & func, unsigned int dim, unsigned int npar, const double * par, const unsigned int * idx) :; 167 fFunc(func),; 168 fDim(dim),; 169 fParams(std::vector<double>(par,par+npar) ),; 170 fParIndices(std::vector<unsigned int>(idx, idx + npar) ),; 171 fX(std::vector<double>(npar+dim) ) // cached vector; 172 {; 173 DoInit();; 174 }; 175 ; 176 /// clone the function; 177 IMultiGenFunction * Clone() const override {; 178 return new WrappedParamFunctionGen(fFunc, fDim, fParams.size(), fParams.empty() ? nullptr : &fParams.front(), fParIndices.empty() ? nullptr : &fParIndices.front());; 179 }; 180 ; 181private:; 182 // copy ctor; 183 WrappedParamFunctionGen(const WrappedParamFunctionGen &) = delete; // not implemented; 184 WrappedParamFunctionGen & operator=(const WrappedParamFunctionGen &) = delete; // not implemented; 185 ; 186public:; 187 ; 188 const double * Parameters() const override {; 189 return fParams.empty() ? nullptr : &fParams.front();; 190 }; 191 ; 192 void SetParameters(const double * p) override {; 193 unsigned int npar = NPar();; 194 std::copy(p, p+ npar, fParams.begin() );; 195 SetParValues(npar, p);; 196 }; 197 ; 198 unsigned in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/WrappedParamFunction_8h_source.html:6113,cache,cached,6113,doc/master/WrappedParamFunction_8h_source.html,https://root.cern,https://root.cern/doc/master/WrappedParamFunction_8h_source.html,1,['cache'],['cached']
Performance,"nst double* x) const; virtual voidFdF(double x, double& f, double& df) const; voidFdF(const double* x, double& f, double* df) const; voidGradient(const double* x, double* g) const; ROOT::Math::IGradientOneDim&operator=(const ROOT::Math::IGradientOneDim&). private:. virtual doubleDoDerivative(double x) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Gradient(const double* x, double* g) const. Evaluate all the vector of function derivatives (gradient) at a point x.; Derived classes must re-implement if it is more efficient than evaluting one at a time. double Derivative(const double * x, unsigned int icoord = 0). Return the partial derivative with respect to the passed coordinate. return DoDerivative(x, icoord). void FdF(const double* x, double& f, double* df) const. Optimized method to evaluate at the same time the function value and derivative at a point x.; Often both value and derivatives are needed and it is often more efficient to compute them at the same time.; Derived class should implement this method if performances play an important role and if it is faster to; evaluate value and derivative at the same time. virtual ~IGradientOneDim(); virtual destructor. {}. double Derivative(double x) const. Return the derivative of the function at a point x; Use the private method DoDerivative. void FdF(double x, double& f, double& df) const. Optimized method to evaluate at the same time the function value and derivative at a point x.; Often both value and derivatives are needed and it is often more efficient to compute them at the same time.; Derived class should implement this method if performances play an important role and if it is faster to; evaluate value and derivative at the same time. » Last changed: root/mathcore:$Id$ » Last generated: 2015-09-08 16:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__IGradientOneDim.html:2372,perform,performances,2372,root/html534/ROOT__Math__IGradientOneDim.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__IGradientOneDim.html,5,"['Optimiz', 'perform']","['Optimized', 'performances']"
Performance,"nst the values for that variables are zero.; 146 The array will be filled as h[i *ndim + j]; 147*/; 148bool Minimizer::GetHessianMatrix(double *hMat) const; 149{; 150 MATH_UNUSED(hMat);; 151 return false;; 152}; 153 ; 154/**; 155 return global correlation coefficient for variable i; 156 This is a number between zero and one which gives; 157 the correlation between the i-th parameter and that linear combination of all; 158 other parameters which is most strongly correlated with i.; 159 Minimizer must overload method if implemented; 160 */; 161double Minimizer::GlobalCC(unsigned int ivar) const; 162{; 163 MATH_UNUSED(ivar);; 164 return -1;; 165}; 166 ; 167/**; 168 minos error for variable i, return false if Minos failed or not supported; 169 and the lower and upper errors are returned in errLow and errUp; 170 An extra flag specifies if only the lower (option=-1) or the upper (option=+1) error calculation is run; 171*/; 172bool Minimizer::GetMinosError(unsigned int ivar, double &errLow, double &errUp, int option); 173{; 174 MATH_ERROR_MSG(""Minimizer::GetMinosError"", ""Minos Error not implemented"");; 175 MATH_UNUSED(ivar);; 176 MATH_UNUSED(errLow);; 177 MATH_UNUSED(errUp);; 178 MATH_UNUSED(option);; 179 return false;; 180}; 181 ; 182/**; 183 perform a full calculation of the Hessian matrix for error calculation; 184 */; 185bool Minimizer::Hesse(); 186{; 187 MATH_ERROR_MSG(""Minimizer::Hesse"", ""Hesse not implemented"");; 188 return false;; 189}; 190 ; 191/**; 192 scan function minimum for variable i. Variable and function must be set before using Scan; 193 Return false if an error or if minimizer does not support this functionality; 194 */; 195bool Minimizer::Scan(unsigned int ivar, unsigned int &nstep, double *x, double *y, double xmin, double xmax); 196{; 197 MATH_ERROR_MSG(""Minimizer::Scan"", ""Scan not implemented"");; 198 MATH_UNUSED(ivar);; 199 MATH_UNUSED(nstep);; 200 MATH_UNUSED(x);; 201 MATH_UNUSED(y);; 202 MATH_UNUSED(xmin);; 203 MATH_UNUSED(xmax);; 204 return false;;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Minimizer_8cxx_source.html:6569,perform,perform,6569,doc/master/Minimizer_8cxx_source.html,https://root.cern,https://root.cern/doc/master/Minimizer_8cxx_source.html,1,['perform'],['perform']
Performance,"nst. inlineoverridevirtual . Implements RooAbsArg.; Definition at line 34 of file RooFFTConvPdf.h. ◆ createCache(). RooFFTConvPdf::PdfCacheElem * RooFFTConvPdf::createCache ; (; const RooArgSet * ; nset); const. overrideprotectedvirtual . Return specialized cache subclass for FFT calculations. ; Reimplemented from RooAbsCachedPdf.; Definition at line 342 of file RooFFTConvPdf.cxx. ◆ DeclFileName(). static const char * RooFFTConvPdf::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 124 of file RooFFTConvPdf.h. ◆ evaluate(). double RooFFTConvPdf::evaluate ; (; ); const. inlineoverrideprotectedvirtual . Evaluate this PDF / function / constant. Needs to be overridden by all derived classes. ; Implements RooAbsReal.; Definition at line 96 of file RooFFTConvPdf.h. ◆ fillCacheObject(). void RooFFTConvPdf::fillCacheObject ; (; RooAbsCachedPdf::PdfCacheElem & ; cache); const. overrideprotectedvirtual . Fill the contents of the cache the FFT convolution output. ; Implements RooAbsCachedPdf.; Definition at line 479 of file RooFFTConvPdf.cxx. ◆ fillCacheSlice(). void RooFFTConvPdf::fillCacheSlice ; (; FFTCacheElem & ; cache, . const RooArgSet & ; slicePosition . ); const. protected . Fill a slice of cachePdf with the output of the FFT convolution calculation. ; Definition at line 559 of file RooFFTConvPdf.cxx. ◆ genContext(). RooAbsGenContext * RooFFTConvPdf::genContext ; (; const RooArgSet & ; vars, . const RooDataSet * ; prototype = nullptr, . const RooArgSet * ; auxProto = nullptr, . bool ; verbose = false . ); const. overrideprotectedvirtual . Create appropriate generator context for this convolution. ; If both input p.d.f.s support internal generation, if it is safe to use them and if no observables other than the convolution observable are requested for generation, use the specialized convolution generator context which implements a smearing strategy in the convolution observable. If not return the regular ac",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooFFTConvPdf.html:90503,cache,cache,90503,doc/master/classRooFFTConvPdf.html,https://root.cern,https://root.cern/doc/master/classRooFFTConvPdf.html,1,['cache'],['cache']
Performance,"nst. overridevirtual . Return the error of the current weight. ; Parameters. [in]etypeSwitch between simple Poisson or sum-of-weights statistics . Implements RooAbsDataStore.; Definition at line 390 of file RooVectorDataStore.cxx. ◆ weightVar(). RooRealVar * RooVectorDataStore::weightVar ; (; const RooArgSet & ; allVars, . const char * ; wgtName . ). private . Utility function for constructors Return pointer to weight variable if it is defined. ; Definition at line 125 of file RooVectorDataStore.cxx. Friends And Related Symbol Documentation. ◆ RooAbsCategory. friend class RooAbsCategory. friend . Definition at line 547 of file RooVectorDataStore.h. ◆ RooAbsReal. friend class RooAbsReal. friend . Definition at line 546 of file RooVectorDataStore.h. ◆ RooRealVar. friend class RooRealVar. friend . Definition at line 548 of file RooVectorDataStore.h. Member Data Documentation. ◆ _cache. RooVectorDataStore* RooVectorDataStore::_cache = nullptr. private . ! Optimization cache ; Definition at line 586 of file RooVectorDataStore.h. ◆ _cacheOwner. RooAbsArg* RooVectorDataStore::_cacheOwner = nullptr. private . ! Cache owner ; Definition at line 587 of file RooVectorDataStore.h. ◆ _catStoreList. std::vector<CatVector*> RooVectorDataStore::_catStoreList. private . Definition at line 572 of file RooVectorDataStore.h. ◆ _currentWeightIndex. ULong64_t RooVectorDataStore::_currentWeightIndex {0}. mutableprivate . Definition at line 584 of file RooVectorDataStore.h. ◆ _extSumW2Array. const double* RooVectorDataStore::_extSumW2Array = nullptr. private . ! External sum of weights array ; Definition at line 582 of file RooVectorDataStore.h. ◆ _extWgtArray. const double* RooVectorDataStore::_extWgtArray = nullptr. private . ! External weight array ; Definition at line 579 of file RooVectorDataStore.h. ◆ _extWgtErrHiArray. const double* RooVectorDataStore::_extWgtErrHiArray = nullptr. private . ! External weight array - high error ; Definition at line 581 of file RooVectorDataStore.h. ◆",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooVectorDataStore.html:39814,cache,cache,39814,doc/master/classRooVectorDataStore.html,https://root.cern,https://root.cern/doc/master/classRooVectorDataStore.html,1,['cache'],['cache']
Performance,"nst; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); RooCachedReal(); RooCachedReal(const RooCachedReal& other, const char* name = 0); RooCachedReal(const char* name, const char* title, RooAbsReal& _func); RooCachedReal(const char* name, const char* title, RooAbsReal& _func, const RooArgSet& cacheObs); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Bool_tRooAbsCachedReal::selfNormalized() const; TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); voidsetCacheSource(Bool_t flag); voidsetCdfBoundaries(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCachedReal.html:23413,cache,cacheObs,23413,root/html602/RooCachedReal.html,https://root.cern,https://root.cern/root/html602/RooCachedReal.html,4,['cache'],['cacheObs']
Performance,"nst; ROOT::DelArrFunc_tTClass::GetDeleteArray() const; ROOT::DesFunc_tTClass::GetDestructor() const; static DictFuncPtr_tTClass::GetDict(const char* cname); static DictFuncPtr_tTClass::GetDict(const type_info& info); static TDictionary*TDictionary::GetDictionary(const char* name); static TDictionary*TDictionary::GetDictionary(const type_info& typeinfo); ROOT::DirAutoAdd_tTClass::GetDirectoryAutoAdd() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TFunctionTemplate*TClass::GetFunctionTemplate(const char* name); UInt_tTClass::GetHeapInstanceCount() const; virtual const char*TObject::GetIconName() const; Short_tTClass::GetImplFileLine() const; const char*TClass::GetImplFileName() const; UInt_tTClass::GetInstanceCount() const; TVirtualIsAProxy*TClass::GetIsAProxy() const; TVirtualStreamerInfo*TClass::GetLastReadInfo() const; TList*TClass::GetListOfAllPublicDataMembers(Bool_t load = kTRUE); const TList*TClass::GetListOfAllPublicMethods(Bool_t load = kTRUE); TList*TClass::GetListOfBases(); TList*TQObject::GetListOfClassSignals() const; TList*TQObject::GetListOfConnections() const; TList*TClass::GetListOfDataMembers(Bool_t load = kTRUE); TList*TClass::GetListOfEnums(Bool_t load = kTRUE); TList*TClass::GetListOfFunctionTemplates(Bool_t load = kTRUE); TCollection*TClass::GetListOfMethodOverloads(const char* name) const; TList*TClass::GetListOfMethods(Bool_t load = kTRUE); TList*TClass::GetListOfRealData() const; TList*TQObject::GetListOfSignals() const; voidTClass::GetMenuItems(TList* listitems); TList*TClass::GetMenuList() const; ROOT::MergeFunc_tTClass::GetMerge() const; TMethod*TClass::GetMethod(const char* method, const char* params, Bool_t objectIsConst = kFALSE); TMethod*TClass::GetMethodAllAny(const char* method); TMethod*TClass::GetMethodAny(const char* method); TMethod*TClass::GetMethodWithPrototype(const char* method, const char* proto, Bool_t objectIsConst = kFALSE, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TQClass.html:9814,load,load,9814,root/html602/TQClass.html,https://root.cern,https://root.cern/root/html602/TQClass.html,4,['load'],['load']
Performance,"nst; Returns cpu load average and load info into the CpuInfo_t structure.; Returns -1 in case of error, 0 otherwise. Use sampleTime to set the; interval over which the CPU load will be measured, in ms (default 1000). int GetMemInfo(MemInfo_t* info) const; Returns ram and swap memory usage info into the MemInfo_t structure.; Returns -1 in case of error, 0 otherwise. int GetProcInfo(ProcInfo_t* info) const; Returns cpu and memory used by this process into the ProcInfo_t structure.; Returns -1 in case of error, 0 otherwise. int CompileMacro(const char* filename, Option_t* opt = """", const char* library_name = """", const char* build_dir = """", UInt_t dirmode = 0); This method compiles and loads a shared library containing; the code from the file ""filename"". The return value is true (1) in case of success and false (0); in case of error. The possible options are:; k : keep the shared library after the session end.; f : force recompilation.; g : compile with debug symbol; O : optimized the code; c : compile only, do not attempt to load the library.; s : silence all informational output; v : output all information output; d : debug ACLiC, keep all the output files.; - : if buildir is set, use a flat structure (see buildir below). If library_specified is specified, CompileMacro generates the file; ""library_specified"".soext where soext is the shared library extension for; the current platform. If build_dir is specified, it is used as an alternative 'root' for the; generation of the shared library. The library is stored in a sub-directories; of 'build_dir' including the full pathname of the script unless a flat; directory structure is requested ('-' option). With the '-' option the libraries; are created directly in the directory 'build_dir'; in particular this means that; 2 scripts with the same name in different source directory will over-write each; other's library.; See also TSystem::SetBuildDir. If dirmode is not zero and we need to create the target directory, the; file mo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSystem.html:39483,optimiz,optimized,39483,root/html602/TSystem.html,https://root.cern,https://root.cern/root/html602/TSystem.html,8,"['load', 'optimiz']","['load', 'optimized']"
Performance,"nst; TMVA::MethodTMlpANNMethodTMlpANN(const TMVA::MethodTMlpANN&); TMVA::MethodTMlpANNMethodTMlpANN(TMVA::DataSetInfo& theData, const TString& theWeightFile, TDirectory* theTargetDir = __null); TMVA::MethodTMlpANNMethodTMlpANN(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = ""3000:N-1:N-2"", TDirectory* theTargetDir = 0); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TMVA::MethodTMlpANN&operator=(const TMVA::MethodTMlpANN&); virtual map<TString,Double_t>TMVA::MethodBase::OptimizeTuningParameters(TString fomType = ""ROCIntegral"", TString fitType = ""FitGA""); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTMVA::Configurable::ParseOptions(); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual voidTMVA::MethodBase::PrintHelpMessage() const; voidTMVA::Configurable::PrintOptions() const; voidTMVA::MethodBase::ProcessSetup(); virtual Int_tTObject::Read(const char* name); voidTMVA::Configurable::ReadOptionsFromStream(istream& istr); voidTMVA::Configurable::ReadOptionsFromXML(void* node); voidTMVA::MethodBase::ReadStateFromFile(); voidTMVA::MethodBase::ReadStateFromStream(istream& tf); voidTMVA::MethodBase::ReadStateFromStream(TFile& rf); voidTMVA::MethodBase::ReadStateFromXMLString(const char* xmlstr); virtual voidReadWeightsFromStream(istream& istr); virtual voidReadWeightsFromXML(void* wghtnode); virtual voidTObject::RecursiveRemove(TObject* obj); voidTMVA::MethodBase::RerouteTransformationHandler(TMVA::Transformatio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__MethodTMlpANN.html:10059,Optimiz,OptimizeTuningParameters,10059,root/html602/TMVA__MethodTMlpANN.html,https://root.cern,https://root.cern/root/html602/TMVA__MethodTMlpANN.html,2,['Optimiz'],['OptimizeTuningParameters']
Performance,"nst; TObjLink**TList::DoSort(TObjLink** head, Int_t n); TObjLink*TList::FindLink(const TObject* obj, Int_t& idx) const; virtual const char*TCollection::GetCollectionEntryName(TObject* entry) const; TObjLink*TList::LinkAt(Int_t idx) const; Bool_tTList::LnkCompare(TObjLink* l1, TObjLink* l2); voidTObject::MakeZombie(); virtual TObjLink*TList::NewLink(TObject* obj, TObjLink* prev = NULL); virtual TObjLink*TList::NewOptLink(TObject* obj, Option_t* opt, TObjLink* prev = NULL); virtual voidTCollection::PrintCollectionEntry(TObject* entry, Option_t* option, Int_t recurse) const; virtual voidTCollection::PrintCollectionHeader(Option_t* option) const. Data Members; public:. enum TCollection::[unnamed] { kIsOwner; kInitCapacity; kInitHashTableCapacity; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_tTList::fAscending! sorting order (when calling Sort() or for TSortedList); TObjLink*TList::fCache! cache to speedup sequential calling of Before() and After() functions; TObjLink*TList::fFirst! pointer to first entry in linked list; TStringfJobIDthe job's ID; TObjLink*TList::fLast! pointer to last entry in linked list; TStringTCollection::fNamename of the collection; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGridJobStatusList(); { }. virtual ~TGridJobStatusList(); { }. » Author: Andreas-Joachim Peters 10/12/2006 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/net:$Id$ » Last generated: 2015-09-08 17:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGridJobStatusList.html:9618,cache,cache,9618,root/html534/TGridJobStatusList.html,https://root.cern,https://root.cern/root/html534/TGridJobStatusList.html,2,['cache'],['cache']
Performance,"nst; const char*GetGitCommit() const; const char*GetGitDate(); TGlobal*GetGlobal(const char* name, Bool_t load = kFALSE) const; TGlobal*GetGlobal(const TObject* obj, Bool_t load = kFALSE) const; TFunction*GetGlobalFunction(const char* name, const char* params = 0, Bool_t load = kFALSE); TFunction*GetGlobalFunctionWithPrototype(const char* name, const char* proto = 0, Bool_t load = kFALSE); virtual const char*TObject::GetIconName() const; TInterpreter*GetInterpreter() const; virtual TKey*TDirectory::GetKey(const char*, Short_t = 9999) const; virtual TList*TDirectory::GetList() const; TList*GetListOfBrowsables() const; TSeqCollection*GetListOfBrowsers() const; TSeqCollection*GetListOfCanvases() const; TCollection*GetListOfClasses() const; TCollection*GetListOfClassGenerators() const; TSeqCollection*GetListOfCleanups() const; TSeqCollection*GetListOfClosedObjects() const; TSeqCollection*GetListOfColors() const; TSeqCollection*GetListOfDataSets() const; TCollection*GetListOfEnums(Bool_t load = kFALSE); TSeqCollection*GetListOfFiles() const; TCollection*GetListOfFunctionOverloads(const char* name) const; TCollection*GetListOfFunctions() const; TCollection*GetListOfFunctionTemplates(); TSeqCollection*GetListOfGeometries() const; TCollection*GetListOfGlobalFunctions(Bool_t load = kFALSE); TCollection*GetListOfGlobals(Bool_t load = kFALSE); virtual TList*TDirectory::GetListOfKeys() const; TSeqCollection*GetListOfMappedFiles() const; TSeqCollection*GetListOfMessageHandlers() const; TSeqCollection*GetListOfProofs() const; TSeqCollection*GetListOfSecContexts() const; TSeqCollection*GetListOfSockets() const; TSeqCollection*GetListOfSpecials() const; TSeqCollection*GetListOfStreamerInfo() const; TSeqCollection*GetListOfStyles() const; TSeqCollection*GetListOfTasks() const; TCollection*GetListOfTypes(Bool_t load = kFALSE); static const char*GetMacroPath(); virtual TObject*TDirectory::GetMother() const; virtual TDirectory*TDirectory::GetMotherDir() const; virtual const char*TNamed:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TROOT.html:7030,load,load,7030,root/html602/TROOT.html,https://root.cern,https://root.cern/root/html602/TROOT.html,4,['load'],['load']
Performance,"nst; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TVirtualPerfStats&operator=(const TVirtualPerfStats&); virtual voidPacketEvent(const char* slave, const char* slavename, const char* filename, Long64_t eventsprocessed, Double_t latency, Double_t proctime, Double_t cputime, Long64_t bytesRead); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual voidRateEvent(Double_t proctime, Double_t deltatime, Long64_t eventsprocessed, Long64_t bytesRead); virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidSetBytesRead(Long64_t num); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetNumEvents(Long64_t num); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TVirtualPerfStats.html:4174,latency,latency,4174,root/html602/TVirtualPerfStats.html,https://root.cern,https://root.cern/root/html602/TVirtualPerfStats.html,4,['latency'],['latency']
Performance,"nst; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; RooNumIntConfig&binIntegratorConfig(); const RooNumIntConfig&binIntegratorConfig() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsOptTestStatistic::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(),",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooXYChi2Var.html:2961,cache,cacheUniqueSuffix,2961,root/html534/RooXYChi2Var.html,https://root.cern,https://root.cern/root/html534/RooXYChi2Var.html,2,['cache'],['cacheUniqueSuffix']
Performance,"nst; virtual unsigned intROOT::Math::IBaseParam::NPar() const; doubleoperator()(double x, const double* p) const; doubleoperator()(const double* x, const double* p); ROOT::Math::IParametricFunctionOneDim&operator=(const ROOT::Math::IParametricFunctionOneDim&); virtual stringROOT::Math::IBaseParam::ParameterName(unsigned int i) const; virtual const double*ROOT::Math::IBaseParam::Parameters() const; virtual voidROOT::Math::IBaseParam::SetParameters(const double* p). private:. virtual doubleDoEval(double x) const; virtual doubleDoEvalPar(double x, const double* p) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; double operator()(const double * x, const double * p ). Evaluate function at a point x and for given parameters p.; This method does not change the internal status of the function (internal parameter values).; If for some reason one prefers caching the parameter values, SetParameters(p) and then operator()(x) should be; called.; Use the pure virtual function DoEvalPar to implement it. return DoEvalPar(double x, const double* p) const. double DoEval(double x) const. Implement the ROOT::Math::IBaseFunctionMultiDim interface DoEval(x) using the cached parameter values. double operator()( double x, const double * p ). Evaluate function at a point x and for given parameters p.; This method does not change the internal status of the function (internal parameter values).; If for some reason one prefers caching the parameter values, SetParameters(p) and then operator()(x) should be; called.; Use the pure virtual function DoEvalPar to implement it. » Author: L. Moneta Tue Nov 14 14:20:07 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id: IParamFunction.h 27272 2009-01-28 09:03:03Z moneta $ » Last generated: 2009-12-07 13:43; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__IParametricFunctionOneDim.html:2423,cache,cached,2423,root/html526/ROOT__Math__IParametricFunctionOneDim.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__IParametricFunctionOneDim.html,1,['cache'],['cached']
Performance,"nst; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooExpensiveObjectCache&operator=(const RooExpensiveObjectCache&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); voidprint() const; virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tregisterObject(const char* ownerName, const char* objectName, TObject& cacheObject, TIterator* paramIter); Bool_tregisterObject(const char* ownerName, const char* objectName, TObject& cacheObject, const RooArgSet& params); voidTObject::ResetBit(UInt_t f); const TObject*retrieveObject(const char* name, TClass* tclass, const RooArgSet& params); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); Bool_tsetObj(Int_t uniqueID, TObject* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); Int_tsize() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle()",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooExpensiveObjectCache.html:4404,cache,cacheObject,4404,root/html528/RooExpensiveObjectCache.html,https://root.cern,https://root.cern/root/html528/RooExpensiveObjectCache.html,1,['cache'],['cacheObject']
Performance,"nst; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooExpensiveObjectCache&operator=(const RooExpensiveObjectCache&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); voidprint() const; virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tregisterObject(const char* ownerName, const char* objectName, TObject& cacheObject, TIterator* paramIter); Bool_tregisterObject(const char* ownerName, const char* objectName, TObject& cacheObject, const RooArgSet& params); voidTObject::ResetBit(UInt_t f); const TObject*retrieveObject(const char* name, TClass* tclass, const RooArgSet& params); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); Bool_tsetObj(Int_t uniqueID, TObject* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp, char* parent); Int_tsize() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::Use",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooExpensiveObjectCache.html:4404,cache,cacheObject,4404,root/html526/RooExpensiveObjectCache.html,https://root.cern,https://root.cern/root/html526/RooExpensiveObjectCache.html,1,['cache'],['cacheObject']
Performance,"nst;  ; bool IsAutoCreated () const;  ; virtual bool IsEnabled () const;  ; bool IsLearning () const override;  ; Int_t LearnBranch (TBranch *b, bool subgbranches=false) override;  Add a branch discovered by actual usage to the list of branches to be stored in the cache this function is called by TBranch::GetBasket If we are not longer in the training phase this is an error. ;  ; virtual void LearnPrefill ();  Perform an initial prefetch, attempting to read as much of the learning phase baskets for all branches at once. ;  ; Int_t ReadBuffer (char *buf, Long64_t pos, Int_t len) override;  Read buffer at position pos if the request is in the list of prefetched blocks read from fBuffer. ;  ; virtual Int_t ReadBufferNormal (char *buf, Long64_t pos, Int_t len);  Old method ReadBuffer before the addition of the prefetch mechanism. ;  ; virtual Int_t ReadBufferPrefetch (char *buf, Long64_t pos, Int_t len);  Used to read a chunk from a block previously fetched. ;  ; void ResetMissCache ();  Reset all the miss cache training. ;  ; void SetAutoCreated (bool val);  ; void SetFile (TFile *file, TFile::ECacheAction action=TFile::kDisconnect) override;  Change the file that is being cached. ;  ; virtual void SetLearnPrefill (EPrefillType type=kNoPrefill);  Set whether the learning period is started with a prefilling of the cache and which type of prefilling is used. ;  ; void SetOptimizeMisses (bool opt);  Start of methods for the miss cache. ;  ; void StartLearningPhase ();  The name should be enough to explain the method. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TFileCacheRead;  TFileCacheRead ();  Default Constructor. ;  ;  TFileCacheRead (TFile *file, Int_t buffersize, TObject *tree=nullptr);  Creates a TFileCacheRead data structure. ;  ;  ~TFileCacheRead () override;  Destructor. ;  ; virtual void AddNoCacheBytesRead (Long64_t len);  ; virtual void AddNoCacheReadCalls (Int_t reads);  ; virtual void Close (O",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCacheUnzip.html:7025,cache,cache,7025,doc/v632/classTTreeCacheUnzip.html,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html,2,['cache'],['cache']
Performance,"nst;  ; const char * GetGitCommit () const;  ; const char * GetGitDate ();  Return date/time make was run. ;  ; TGlobal * GetGlobal (const char *name, Bool_t load=kFALSE) const;  Return pointer to global variable by name. ;  ; TGlobal * GetGlobal (const TObject *obj, Bool_t load=kFALSE) const;  Return pointer to global variable with address addr. ;  ; TFunction * GetGlobalFunction (const char *name, const char *params=nullptr, Bool_t load=kFALSE);  Return pointer to global function by name. ;  ; TFunction * GetGlobalFunctionWithPrototype (const char *name, const char *proto=nullptr, Bool_t load=kFALSE);  Return pointer to global function by name. ;  ; TInterpreter * GetInterpreter () const;  ; TList * GetListOfBrowsables () const;  ; TSeqCollection * GetListOfBrowsers () const;  ; TSeqCollection * GetListOfCanvases () const;  ; TCollection * GetListOfClasses () const;  ; TCollection * GetListOfClassGenerators () const;  ; TSeqCollection * GetListOfCleanups () const;  ; TSeqCollection * GetListOfClosedObjects () const;  ; TSeqCollection * GetListOfColors () const;  ; TSeqCollection * GetListOfDataSets () const;  ; TCollection * GetListOfEnums (Bool_t load=kFALSE);  ; TSeqCollection * GetListOfFiles () const;  ; TCollection * GetListOfFunctionOverloads (const char *name) const;  Return the collection of functions named ""name"". ;  ; TCollection * GetListOfFunctions () const;  ; TCollection * GetListOfFunctionTemplates ();  ; TSeqCollection * GetListOfGeometries () const;  ; TCollection * GetListOfGlobalFunctions (Bool_t load=kFALSE);  Return list containing the TFunctions currently defined. ;  ; TCollection * GetListOfGlobals (Bool_t load=kFALSE);  Return list containing the TGlobals currently defined. ;  ; TSeqCollection * GetListOfMappedFiles () const;  ; TSeqCollection * GetListOfMessageHandlers () const;  ; TSeqCollection * GetListOfProofs () const;  ; TSeqCollection * GetListOfSecContexts () const;  ; TSeqCollection * GetListOfSockets () const;  ; TSeqCollection *",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTROOT.html:7376,load,load,7376,doc/v632/classTROOT.html,https://root.cern,https://root.cern/doc/v632/classTROOT.html,2,['load'],['load']
Performance,"nst;  ; virtual void SavePrimitiveHelp (std::ostream &out, const char *hname, Option_t *option="""");  Helper function for the SavePrimitive functions from TH1 or classes derived from TH1, eg TProfile, TProfile2D. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Member Functions inherited from TArray; Bool_t BoundsOk (const char *where, Int_t at) const;  ; Bool_t OutOfBoundsError (const char *where, Int_t i) const;  Generate an out-of-bounds error. Always returns false. ;  ;  Static Protected Member Functions inherited from TH3; static TH1D * DoProject1D (const TH3 &h, const char *name, const char *title, const TAxis *projX, bool computeErrors, bool originalRange, bool useUF, bool useOF);  static methdod performing the projection to 1D histogram ;  ; static TH2D * DoProject2D (const TH3 &h, const char *name, const char *title, const TAxis *projX, const TAxis *projY, bool computeErrors, bool originalRange, bool useUF, bool useOF);  static methdod performing the projection to 2D histogram ;  ;  Static Protected Member Functions inherited from TH1; static Int_t AutoP2GetBins (Int_t n);  Auxiliary function to get the next power of 2 integer value larger then n. ;  ; static Double_t AutoP2GetPower2 (Double_t x, Bool_t next=kTRUE);  Auxiliary function to get the power of 2 next (larger) or previous (smaller) a given x. ;  ; static bool CheckAxisLimits (const TAxis *a1, const TAxis *a2);  Check that the axis limits of the histograms are the same. ;  ; static bool CheckBinLabels (const TAxis *a1, const TAxis *a2);  Check that axis have same labels. ;  ; static bool CheckBinLimits (const TAxis *a1, const TAxis *a2);  Check bin limits. ;  ; static int CheckConsistency (const TH1 *h1, const TH1 *h2);  Check histogram compatibility. ;  ; static bool CheckConsistentSubAxes (const TAxis *a1, Int_t firstBin1,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGLTH3Composition.html:57933,perform,performing,57933,doc/master/classTGLTH3Composition.html,https://root.cern,https://root.cern/doc/master/classTGLTH3Composition.html,2,['perform'],['performing']
Performance,"nst;  Return a pointer to a newly allocated object of this class. ;  ; virtual void PostLoadCheck ();  Do the initialization that can only be done after the CINT dictionary has been fully populated and can not be delayed efficiently. ;  ; Long_t Property () const override;  Returns the properties of the TClass as a bit field stored as a Long_t value. ;  ; Int_t ReadBuffer (TBuffer &b, void *pointer);  Function called by the Streamer functions to deserialize information from buffer b into object at p. ;  ; Int_t ReadBuffer (TBuffer &b, void *pointer, Int_t version, UInt_t start, UInt_t count);  Function called by the Streamer functions to deserialize information from buffer b into object at p. ;  ; void RegisterStreamerInfo (TVirtualStreamerInfo *info);  Register the StreamerInfo in the given slot, change the State of the TClass as appropriate. ;  ; void RemoveStreamerInfo (Int_t slot);  Remove and delete the StreamerInfo in the given slot. ;  ; void ReplaceWith (TClass *newcl) const;  ; void ResetCaches ();  To clean out all caches. ;  ; void ResetClassInfo ();  Make sure that the current ClassInfo is up to date. ;  ; void ResetClassInfo (Long_t tagnum);  Make sure that the current ClassInfo is up to date. ;  ; void ResetInstanceCount ();  ; void ResetMenuList ();  Resets the menu list to it's standard value. ;  ; void SetCanSplit (Int_t splitmode);  Set the splitability of this class: ;  ; void SetCollectionProxy (const ROOT::Detail::TCollectionProxyInfo &);  Create the collection proxy object (and the streamer object) from using the information in the TCollectionProxyInfo. ;  ; void SetContextMenuTitle (const char *title);  Change (i.e. set) the title of the TNamed. ;  ; void SetConvStreamerFunc (ClassConvStreamerFunc_t strm);  Set a wrapper/accessor function around this class custom conversion streamer. ;  ; void SetCurrentStreamerInfo (TVirtualStreamerInfo *info);  Set pointer to current TVirtualStreamerInfo. ;  ; void SetDeclFile (const char *name, Short_t line)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTClass.html:22031,cache,caches,22031,doc/v632/classTClass.html,https://root.cern,https://root.cern/doc/v632/classTClass.html,3,['cache'],['caches']
Performance,"nstalled). ;  ; virtual Bool_t ReadBuffers10 (char *buf, Long64_t *pos, Int_t *len, Int_t nbuf);  Read specified byte ranges from remote file via HTTP 1.0 daemon (without mod-root installed). ;  ;  Protected Member Functions inherited from TFile; virtual Long64_t DirCreateEntry (TDirectory *);  ; virtual Int_t DirReadKeys (TDirectory *);  ; virtual void DirWriteHeader (TDirectory *);  ; virtual void DirWriteKeys (TDirectory *);  ; Bool_t FlushWriteCache ();  Flush the write cache if active. ;  ; virtual EAsyncOpenStatus GetAsyncOpenStatus ();  ; virtual InfoListRet GetStreamerInfoListImpl (bool lookupSICache);  See documentation of GetStreamerInfoList for more details. ;  ; Int_t MakeProjectParMake (const char *packname, const char *filename);  Create makefile at 'filemake' for PAR package 'pack'. ;  ; Int_t MakeProjectParProofInf (const char *packname, const char *proofinfdir);  Create BUILD.sh and SETUP.C under 'proofinf' for PAR package 'pack'. ;  ; Int_t ReadBufferViaCache (char *buf, Int_t len);  Read buffer via cache. ;  ; virtual Int_t SysClose (Int_t fd);  Interface to system close. All arguments like in POSIX close(). ;  ; virtual Int_t SysOpen (const char *pathname, Int_t flags, UInt_t mode);  Interface to system open. All arguments like in POSIX open(). ;  ; virtual Int_t SysRead (Int_t fd, void *buf, Int_t len);  Interface to system read. All arguments like in POSIX read(). ;  ; virtual Long64_t SysSeek (Int_t fd, Long64_t offset, Int_t whence);  Interface to system lseek. ;  ; virtual Int_t SysStat (Int_t fd, Long_t *id, Long64_t *size, Long_t *flags, Long_t *modtime);  Return file stat information. ;  ; virtual Int_t SysSync (Int_t fd);  Interface to system fsync. All arguments like in POSIX fsync(). ;  ; virtual Int_t SysWrite (Int_t fd, const void *buf, Int_t len);  Interface to system write. All arguments like in POSIX write(). ;  ; Int_t WriteBufferViaCache (const char *buf, Int_t len);  Write buffer via cache. ;  ;  Protected Member Functions inhe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTS3WebFile.html:35250,cache,cache,35250,doc/master/classTS3WebFile.html,https://root.cern,https://root.cern/doc/master/classTS3WebFile.html,1,['cache'],['cache']
Performance,"nstance(); returns gInterpreter global. void Execute(TMethod* method, TObjArray* params, int* error = 0). virtual ~TInterpreter(); { }. void AddIncludePath(const char* path). Int_t AutoLoad(const char* classname). void ClearFileBusy(). void ClearStack(). void EnableAutoLoading(). void EndOfLineAction(). Int_t GetExitCode() const. TEnv * GetMapfile() const; { return 0; }. Int_t GetMore() const. Int_t GenerateDictionary(const char* classes, const char* includes = 0, const char* options = 0). char * GetPrompt(). const char * GetSharedLibs(). const char * GetClassSharedLibs(const char* cls). const char * GetSharedLibDeps(const char* lib). const char * GetIncludePath(). const char * GetSTLIncludePath() const; { return """"; }. TObjArray * GetRootMapFiles() const. Int_t InitializeDictionaries(). Bool_t IsLoaded(const char* filename) const. Int_t Load(const char* filenam, Bool_t system = kFALSE). void LoadMacro(const char* filename, TInterpreter::EErrorCode* error = 0). Int_t LoadLibraryMap(const char* rootmapfile = 0). Int_t RescanLibraryMap(). Int_t ReloadAllSharedLibraryMaps(). Int_t UnloadAllSharedLibraryMaps(). Int_t UnloadLibraryMap(const char* library). Long_t ProcessLine(const char* line, TInterpreter::EErrorCode* error = 0). Long_t ProcessLineSynch(const char* line, TInterpreter::EErrorCode* error = 0). void PrintIntro(). Int_t SetClassSharedLibs(const char* cls, const char* libs). void SetGetline(const char *(*)(const char* prompt) getlineFunc, void (*)(const char* line) histaddFunc). void ResetAll(). void ResetGlobals(). void ResetGlobalVar(void* obj). void RewindDictionary(). Int_t DeleteGlobal(void* obj). Int_t DeleteVariable(const char* name). void SaveContext(). void SaveGlobalsContext(). void UpdateListOfGlobals(). void UpdateListOfGlobalFunctions(). void UpdateListOfTypes(). void SetClassInfo(TClass* cl, Bool_t reload = kFALSE). Bool_t CheckClassInfo(const char* name, Bool_t autoload = kTRUE). Long_t Calc(const char* line, TInterpreter::EErrorCode* error = 0)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TInterpreter.html:18906,Load,LoadLibraryMap,18906,root/html534/TInterpreter.html,https://root.cern,https://root.cern/root/html534/TInterpreter.html,1,['Load'],['LoadLibraryMap']
Performance,"nstance(); returns gInterpreter global. void Execute(TMethod* method, TObjArray* params, int* error = 0). virtual ~TInterpreter(); { }. void AddIncludePath(const char* path). Int_t AutoLoad(const char* classname). void ClearFileBusy(). void ClearStack(). void EnableAutoLoading(). void EndOfLineAction(). Int_t GetExitCode() const. TEnv * GetMapfile() const; { return 0; }. Int_t GetMore() const. Int_t GenerateDictionary(const char* classes, const char* includes = 0, const char* options = 0). char * GetPrompt(). const char * GetSharedLibs(). const char * GetClassSharedLibs(const char* cls). const char * GetSharedLibDeps(const char* lib). const char * GetIncludePath(). const char * GetSTLIncludePath() const; { return """"; }. TObjArray * GetRootMapFiles() const. Int_t InitializeDictionaries(). Bool_t IsLoaded(const char* filename) const. Int_t Load(const char* filenam, Bool_t system = kFALSE). void LoadMacro(const char* filename, TInterpreter::EErrorCode* error = 0). Int_t LoadLibraryMap(const char* rootmapfile = 0). Int_t RescanLibraryMap(). Int_t ReloadAllSharedLibraryMaps(). Int_t UnloadAllSharedLibraryMaps(). Int_t UnloadLibraryMap(const char* library). Long_t ProcessLine(const char* line, TInterpreter::EErrorCode* error = 0). Long_t ProcessLineSynch(const char* line, TInterpreter::EErrorCode* error = 0). void PrintIntro(). void SetGetline(const char *(*)(const char* prompt) getlineFunc, void (*)(const char* line) histaddFunc). void ResetAll(). void ResetGlobals(). void ResetGlobalVar(void* obj). void RewindDictionary(). Int_t DeleteGlobal(void* obj). void SaveContext(). void SaveGlobalsContext(). void UpdateListOfGlobals(). void UpdateListOfGlobalFunctions(). void UpdateListOfTypes(). void SetClassInfo(TClass* cl, Bool_t reload = kFALSE). Bool_t CheckClassInfo(const char* name, Bool_t autoload = kTRUE). Long_t Calc(const char* line, TInterpreter::EErrorCode* error = 0). void CreateListOfBaseClasses(TClass* cl). void CreateListOfDataMembers(TClass* cl). void CreateList",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TInterpreter.html:18426,Load,LoadLibraryMap,18426,root/html532/TInterpreter.html,https://root.cern,https://root.cern/root/html532/TInterpreter.html,1,['Load'],['LoadLibraryMap']
Performance,"nstexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  ;  Static Public Member Functions inherited from RooPrintable; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static std::ostream & defaultPrintStream (std::ostream *os=nullptr);  Return a reference to the current default stream to use in Print(). ;  ; static void nameFieldLength (Int_t newLen);  Set length of field reserved from printing name of RooAbsArgs in multi-line collection printing to given amount. ;  . Protected Member Functions; bool allClientsCached (RooAbsArg *, const RooArgSet &);  Utility function that determines if all clients of object 'var' appear in given list of cached nodes. ;  ; virtual void attachCache (const RooAbsArg *newOwner, const RooArgSet &cachedVars);  Internal method – Attach dataset copied with cache contents to copied instances of functions. ;  ; virtual void cacheArgs (const RooAbsArg *owner, RooArgSet &varSet, const RooArgSet *nset=nullptr, bool skipZeroWeights=false);  Internal method – Cache given set of functions with data. ;  ; double corrcov (const RooRealVar &x, const RooRealVar &y, const char *cutSpec, const char *cutRange, bool corr) const;  Internal method to calculate single correlation and covariance elements. ;  ; RooFit::OwningPtr< TMatrixDSym > corrcovMatrix (const RooArgList &vars, const char *cutSpec, const char *cutRange, bool corr) const;  Return covariance matrix from data for given list of observables. ;  ; RooRealVar * dataRealVar (const char *methodname, const RooRealVar &extVar) const;  Internal method to check if given RooRea",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsData.html:28149,cache,cached,28149,doc/master/classRooAbsData.html,https://root.cern,https://root.cern/doc/master/classRooAbsData.html,1,['cache'],['cached']
Performance,"nstruction; CloneData(Bool flag) -- Use clone of dataset in NLL (default is true). RooAbsReal* createNLL(RooAbsData& data, const RooLinkedList& cmdList); Construct representation of -log(L) of PDFwith given dataset. If dataset is unbinned, an unbinned likelihood is constructed. If the dataset; is binned, a binned likelihood is constructed. See RooAbsPdf::createNLL(RooAbsData& data, RooCmdArg arg1, RooCmdArg arg2, RooCmdArg arg3, RooCmdArg arg4,; RooCmdArg arg5, RooCmdArg arg6, RooCmdArg arg7, RooCmdArg arg8). for documentation of options. RooFitResult* fitTo(RooAbsData& data, RooCmdArg arg1 = RooCmdArg::none(), RooCmdArg arg2 = RooCmdArg::none(), RooCmdArg arg3 = RooCmdArg::none(), RooCmdArg arg4 = RooCmdArg::none(), RooCmdArg arg5 = RooCmdArg::none(), RooCmdArg arg6 = RooCmdArg::none(), RooCmdArg arg7 = RooCmdArg::none(), RooCmdArg arg8 = RooCmdArg::none()); Fit PDF to given dataset. If dataset is unbinned, an unbinned maximum likelihood is performed. If the dataset; is binned, a binned maximum likelihood is performed. By default the fit is executed through the MINUIT; commands MIGRAD, HESSE and MINOS in succession. The following named arguments are supported. Options to control construction of -log(L). ConditionalObservables(const RooArgSet& set) -- Do not normalize PDF over listed observables; Extended(Bool_t flag) -- Add extended likelihood term, off by default; Range(const char* name) -- Fit only data inside range with given name; Range(Double_t lo, Double_t hi) -- Fit only data inside given range. A range named ""fit"" is created on the fly on all observables.; Multiple comma separated range names can be specified.; SumCoefRange(const char* name) -- Set the range in which to interpret the coefficients of RooAddPdf components; NumCPU(int num) -- Parallelize NLL calculation on num CPUs; SplitRange(Bool_t flag) -- Use separate fit ranges in a simultaneous fit. Actual range name for each; subsample is assumed to by rangeName_{indexState} where indexState; is the stat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsPdf.html:49364,perform,performed,49364,root/html526/RooAbsPdf.html,https://root.cern,https://root.cern/root/html526/RooAbsPdf.html,1,['perform'],['performed']
Performance,"nstructor using the Functor class. xmin and xmax define the plotting range of the function; npar is the number of free parameters used by the function. This constructor can be used only in compiled code. WARNING! A function created with this constructor cannot be Cloned. void DoInitialize(). Bool_t AddToGlobalList(Bool_t on = kTRUE); Add to global list of functions (gROOT->GetListOfFunctions() ); return previous status (true of functions was already in the list false if not). TF1& operator=(const TF1& rhs); Operator =. ~TF1(); TF1 default destructor. TF1(const TF1& f1). void AbsValue(Bool_t reject = kTRUE); Static function: set the fgAbsValue flag.; By default TF1::Integral uses the original function value to compute the integral; However, TF1::Moment, CentralMoment require to compute the integral; using the absolute value of the function. void Browse(TBrowser* b); Browse. void Copy(TObject& f1) const; Copy this F1 to a new F1.; Note that the cached integral with its related arrays are not copied; (they are also set as transient data members). Double_t Derivative(Double_t x, Double_t* params = 0, Double_t epsilon = 0.001) const; Returns the first derivative of the function at point x,; computed by Richardson's extrapolation method (use 2 derivative estimates; to compute a third, more accurate estimation); first, derivatives with steps h and h/2 are computed by central difference formulas. the final estimate ; ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition"". if the argument params is null, the current function parameters are used,; otherwise the parameters in params are used. the argument eps may be specified to control the step size (precision).; the step size is taken as eps*(xmax-xmin).; the default value (0.001) should be good enough for the vast majority; of functions. Give a smaller value if your function has many changes; of the second derivative in the function range. Getting the error via TF1::DerivativeError:; (total error = roundo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TF1.html:26846,cache,cached,26846,root/html604/TF1.html,https://root.cern,https://root.cern/root/html604/TF1.html,2,['cache'],['cached']
Performance,"nstructor. RooAbsReal(const char* name, const char* title, const char* unit = """"); Constructor with unit label. RooAbsReal(const char* name, const char* title, Double_t minVal, Double_t maxVal, const char* unit = """"); Constructor with plot range and unit label. RooAbsReal(const RooAbsReal& other, const char* name = 0); coverity[UNINIT_CTOR]; Copy constructor. ~RooAbsReal(); Destructor. Bool_t operator==(Double_t value) const; Equality operator comparing to a Double_t. Bool_t operator==(const RooAbsArg& other); Equality operator when comparing to another RooAbsArg.; Only functional when the other arg is a RooAbsReal. Bool_t isIdentical(const RooAbsArg& other, Bool_t assumeSameType = kFALSE). TString getTitle(Bool_t appendUnit = kFALSE) const; Return this variable's title string. If appendUnit is true and; this variable has units, also append a string "" (<unit>)"". Double_t getValV(const RooArgSet* set = 0) const; Return value of object. If the cache is clean, return the; cached value, otherwise recalculate on the fly and refill; the cache. Int_t numEvalErrorItems(). Double_t traceEval(const RooArgSet* set) const; Calculate current value of object, with error tracing wrapper. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Variant of getAnalyticalIntegral that is also passed the normalization set; that should be applied to the integrand of which the integral is request.; For certain operator p.d.f it is useful to overload this function rather; than analyticalIntegralWN() as the additional normalization information; may be useful in determining a more efficient decomposition of the; requested integral. Int_t getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; Interface function getAnalyticalIntergral advertises the; analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function sho",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsReal.html:37058,cache,cache,37058,root/html602/RooAbsReal.html,https://root.cern,https://root.cern/root/html602/RooAbsReal.html,12,['cache'],"['cache', 'cached']"
Performance,"nsupported, at least two colons are needed */; 13339 while (isxdigit((unsigned char)*p) || (*p == '.') || (*p == ':')) {; 13340 if (*(p++) == ':') {; 13341 c++;; 13342 }; 13343 }; 13344 if ((*p == '\0') && (c >= 2)) {; 13345 struct sockaddr_in6 sin6;; 13346 unsigned int i;; 13347 ; 13348 /* for strict validation, an actual IPv6 argument is needed */; 13349 if (sa->sa.sa_family != AF_INET6) {; 13350 return 0;; 13351 }; 13352 if (mg_inet_pton(AF_INET6, ad, &sin6, sizeof(sin6), 0)) {; 13353 /* IPv6 format */; 13354 for (i = 0; i < 16; i++) {; 13355 uint8_t ip = sa->sin6.sin6_addr.s6_addr[i];; 13356 uint8_t net = sin6.sin6_addr.s6_addr[i];; 13357 uint8_t mask = 0;; 13358 ; 13359 if (8 * i + 8 < slash) {; 13360 mask = 0xFFu;; 13361 } else if (8 * i < slash) {; 13362 mask = (uint8_t)(0xFFu << (8 * i + 8 - slash));; 13363 }; 13364 if ((ip & mask) != net) {; 13365 return 0;; 13366 }; 13367 }; 13368 return 1;; 13369 }; 13370 }; 13371 }; 13372 }; 13373#else; 13374 (void)no_strict;; 13375#endif; 13376 ; 13377 /* malformed */; 13378 return -1;; 13379}; 13380 ; 13381 ; 13382static int; 13383set_throttle(const char *spec, const union usa *rsa, const char *uri); 13384{; 13385 int throttle = 0;; 13386 struct vec vec, val;; 13387 char mult;; 13388 double v;; 13389 ; 13390 while ((spec = next_option(spec, &vec, &val)) != NULL) {; 13391 mult = ',';; 13392 if ((val.ptr == NULL); 13393 || (sscanf(val.ptr, ""%lf%c"", &v, &mult); 13394 < 1) // NOLINT(cert-err34-c) 'sscanf' used to convert a string; 13395 // to an integer value, but function will not report; 13396 // conversion errors; consider using 'strtol' instead; 13397 || (v < 0); 13398 || ((lowercase(&mult) != 'k') && (lowercase(&mult) != 'm'); 13399 && (mult != ','))) {; 13400 continue;; 13401 }; 13402 v *= (lowercase(&mult) == 'k'); 13403 ? 1024; 13404 : ((lowercase(&mult) == 'm') ? 1048576 : 1);; 13405 if (vec.len == 1 && vec.ptr[0] == '*') {; 13406 throttle = (int)v;; 13407 } else {; 13408 int matched = parse_match_net(&vec, rsa, 0",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:391166,throttle,throttle,391166,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['throttle'],['throttle']
Performance,"nsupported, at least two colons are needed */; 13340 while (isxdigit((unsigned char)*p) || (*p == '.') || (*p == ':')) {; 13341 if (*(p++) == ':') {; 13342 c++;; 13343 }; 13344 }; 13345 if ((*p == '\0') && (c >= 2)) {; 13346 struct sockaddr_in6 sin6;; 13347 unsigned int i;; 13348 ; 13349 /* for strict validation, an actual IPv6 argument is needed */; 13350 if (sa->sa.sa_family != AF_INET6) {; 13351 return 0;; 13352 }; 13353 if (mg_inet_pton(AF_INET6, ad, &sin6, sizeof(sin6), 0)) {; 13354 /* IPv6 format */; 13355 for (i = 0; i < 16; i++) {; 13356 uint8_t ip = sa->sin6.sin6_addr.s6_addr[i];; 13357 uint8_t net = sin6.sin6_addr.s6_addr[i];; 13358 uint8_t mask = 0;; 13359 ; 13360 if (8 * i + 8 < slash) {; 13361 mask = 0xFFu;; 13362 } else if (8 * i < slash) {; 13363 mask = (uint8_t)(0xFFu << (8 * i + 8 - slash));; 13364 }; 13365 if ((ip & mask) != net) {; 13366 return 0;; 13367 }; 13368 }; 13369 return 1;; 13370 }; 13371 }; 13372 }; 13373 }; 13374#else; 13375 (void)no_strict;; 13376#endif; 13377 ; 13378 /* malformed */; 13379 return -1;; 13380}; 13381 ; 13382 ; 13383static int; 13384set_throttle(const char *spec, const union usa *rsa, const char *uri); 13385{; 13386 int throttle = 0;; 13387 struct vec vec, val;; 13388 char mult;; 13389 double v;; 13390 ; 13391 while ((spec = next_option(spec, &vec, &val)) != NULL) {; 13392 mult = ',';; 13393 if ((val.ptr == NULL); 13394 || (sscanf(val.ptr, ""%lf%c"", &v, &mult); 13395 < 1) // NOLINT(cert-err34-c) 'sscanf' used to convert a string; 13396 // to an integer value, but function will not report; 13397 // conversion errors; consider using 'strtol' instead; 13398 || (v < 0); 13399 || ((lowercase(&mult) != 'k') && (lowercase(&mult) != 'm'); 13400 && (mult != ','))) {; 13401 continue;; 13402 }; 13403 v *= (lowercase(&mult) == 'k'); 13404 ? 1024; 13405 : ((lowercase(&mult) == 'm') ? 1048576 : 1);; 13406 if (vec.len == 1 && vec.ptr[0] == '*') {; 13407 throttle = (int)v;; 13408 } else {; 13409 int matched = parse_match_net(&vec, rsa, 0",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:391199,throttle,throttle,391199,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['throttle'],['throttle']
Performance,"nt ; (; Int_t ; code). overridevirtual . algorithm adapted from code example in: Marsaglia, G. ; and Tsang, W. W. A Simple Method for Generating Gamma Variables ACM Transactions on Mathematical Software, Vol. 26, No. 3, September 2000; The speed of this algorithm depends on the speed of generating normal variates. The algorithm is limited to \( \gamma \geq 0 \) ! ; Reimplemented from RooAbsPdf.; Definition at line 182 of file RooGamma.cxx. ◆ getAnalyticalIntegral(). Int_t RooGamma::getAnalyticalIntegral ; (; RooArgSet & ; allVars, . RooArgSet & ; analVars, . const char * ; rangeName = nullptr . ); const. overridevirtual . Interface function getAnalyticalIntergral advertises the analytical integrals that are supported. ; 'integSet' is the set of dependents for which integration is requested. The function should copy the subset of dependents it can analytically integrate to anaIntSet and return a unique identification code for this integration configuration. If no integration can be performed, zero should be returned. ; Reimplemented from RooAbsReal.; Definition at line 105 of file RooGamma.cxx. ◆ getGenerator(). Int_t RooGamma::getGenerator ; (; const RooArgSet & ; directVars, . RooArgSet & ; generateVars, . bool ; staticInitOK = true . ); const. overridevirtual . Load generatedVars with the subset of directVars that we can generate events for, and return a code that specifies the generator algorithm we will use. ; A code of zero indicates that we cannot generate any of the directVars (in this case, nothing should be added to generatedVars). Any non-zero codes will be passed to our generateEvent() implementation, but otherwise its value is arbitrary. The default implementation of this method returns zero. Subclasses will usually implement this method using the matchArgs() methods to advertise the algorithms they provide. ; Reimplemented from RooAbsPdf.; Definition at line 166 of file RooGamma.cxx. ◆ IsA(). TClass * RooGamma::IsA ; (; ); const. inlineoverridevirtual . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooGamma.html:78098,perform,performed,78098,doc/master/classRooGamma.html,https://root.cern,https://root.cern/doc/master/classRooGamma.html,1,['perform'],['performed']
Performance,"nt a detailed description of the ROOT::Fit classes and how to use them. Using these classes instead of the interface provided directly in the ROOT data objects, like TH1::Fit allow are more fine control to configure and customise the fits. For example, using these classes a combined fit of several histograms can be performed.; To understand how these class work, let’s go through a simple example, such as fitting an histogram.; When fitting an histogram, instead of using TH1::Fit we will show in the following hot wo use the ROOT::Fit classes. We will show how to perform the following different type of fits with the histogram data: * a least square fit using the observed errors (Neyman chi-squared); * a least square fit using the expected errors from the function (Pearson chi-squared); * a binned likelihood fit; * an extended unbinned likelihood fits, if the histogram has been set to store in the buffer the original data used to fill it.; Let’s go through all the steps required for performing these fits using the ROOT::Fit::Fitter class. These steps are: 1. Create the input fit data object. 2. Create the input model function. 3. Configure the fit. 4. Perform the data fitting. 5. Examine the result.; 5.7.1 Creating the input fit data; We have two types of input data, binned data (class ROOT::Fit::BinData) used for least square (chi-square) fits of histograms or TGraph objects or un-binned data (class ROOT::Fit::UnBinData) used for fitting vectors of data points (e.g. from a TTree).; 5.7.1.1 Using Binned data; Let’s suppose we have an histogram, represented as a TH1 type object (it can be one or multi-dimensional). The following shows how to create and fill a ROOT:Fit::BinData object.; ROOT::Fit::DataOptions opt;; opt.fIntegral = true;; ROOT::Fit::BinData data(opt);; // fill the bin data using the histogram; // we can do this using the following helper function from the Hist library; TH1 * h1 = (TH1*) gDirectory->Get(""myHistogram"");; ROOT::Fit::FillData(data, h1);; In t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:191186,perform,performing,191186,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['perform'],['performing']
Performance,"nt a value and a ""shape"" in RooFit.Definition RooAbsArg.h:79; RooAbsArg::_fastbool _fastDefinition RooAbsArg.h:689; RooAbsArg::_valueDirtybool _valueDirtyDefinition RooAbsArg.h:685; RooAbsArg::setValueDirtyvoid setValueDirty()Mark the element dirty. This forces a re-evaluation when a value is requested.Definition RooAbsArg.h:462; RooAbsArg::inhibitDirtybool inhibitDirty() constDelete watch flag.Definition RooAbsArg.cxx:105; RooAbsArg::_inhibitDirtystatic bool _inhibitDirtyDefinition RooAbsArg.h:668; RooAbsCategoryLValueAbstract base class for objects that represent a discrete value that can be set from the outside,...Definition RooAbsCategoryLValue.h:26; RooAbsCollectionAbstract container object that can hold multiple RooAbsArg objects.Definition RooAbsCollection.h:65; RooAbsCollection::emptybool empty() constDefinition RooAbsCollection.h:273; RooAbsDataAbstract base class for binned and unbinned datasets.Definition RooAbsData.h:57; RooAbsFuncAbstract interface for evaluating a real-valued function of one real variable and performing numerica...Definition RooAbsFunc.h:27; RooAbsMomentDefinition RooAbsMoment.h:27; RooAbsRealLValueAbstract base class for objects that represent a real value that may appear on the left hand side of ...Definition RooAbsRealLValue.h:31; RooAbsReal::EvalErrorContextContext to temporarily change the error logging mode as long as the context is alive.Definition RooAbsReal.h:320; RooAbsReal::EvalErrorContext::~EvalErrorContext~EvalErrorContext()Definition RooAbsReal.h:329; RooAbsReal::EvalErrorContext::EvalErrorContextEvalErrorContext(ErrorLoggingMode m)Definition RooAbsReal.h:322; RooAbsReal::EvalErrorContext::operator=EvalErrorContext & operator=(EvalErrorContext const &)=delete; RooAbsReal::EvalErrorContext::_oldErrorLoggingMode _oldDefinition RooAbsReal.h:331; RooAbsReal::EvalErrorContext::operator=EvalErrorContext & operator=(EvalErrorContext &&)=delete; RooAbsReal::EvalErrorContext::EvalErrorContextEvalErrorContext(EvalErrorContext cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8h_source.html:29742,perform,performing,29742,doc/master/RooAbsReal_8h_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html,1,['perform'],['performing']
Performance,"nt branch ""parent.""; (note the trailing dot).; T.SetBranchStatus(""parent"",1);; will not activate the sub-branches of ""parent"". You should do:; T.SetBranchStatus(""parent*"",1);. Without the trailing dot in the branch creation you have no choice but to; call SetBranchStatus explicitly for each of the sub branches. An alternative to this function is to read directly and only; the interesting branches. Example:; TBranch *brc = T.GetBranch(""c"");; TBranch *bre = T.GetBranch(""e"");; brc->GetEntry(i);; bre->GetEntry(i);. If found is not 0, the number of branch(es) found matching the regular; expression is returned in *found AND the error message 'unknown branch'; is suppressed. void SetBranchStyle(Int_t style = 1); Set the current branch style. (static function). style = 0 old Branch; style = 1 new Bronch. void SetCacheSize(Long64_t cachesize = -1); Set maximum size of the file cache .; if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing; the Tree (default is 30 MBytes). void SetCacheSizeAux(Bool_t autocache = kTRUE, Long64_t cacheSize = 0); Set the size of the file cache and create it if needed. If autocache is true:; this will be an automatically create cache, possibly replacing an; existing autocreated cache with a larger one. The size is calculated,; cacheSize is unused. If autocache is false:; cacheSize is used to size the cache. This cache should never be; automatically adjusted. void SetCacheEntryRange(Long64_t first, Long64_t last); interface to TTreeCache to set the cache entry range. void SetCacheLearnEntries(Int_t n = 10); interface to TTreeCache to set the number of entries for the learning phase. void SetCircular(Long64_t maxEntries); Enable/Disable circularity for this tree. if maxEntries > 0 a maximum of maxEntries is kept in one buffer/basket; per branch in memory.; Note that when this function is called (maxEntries>0) the Tree; must be empty or having only one basket per branch.; i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTree.html:131716,cache,cachesize,131716,root/html534/TTree.html,https://root.cern,https://root.cern/root/html534/TTree.html,4,['cache'],['cachesize']
Performance,"nt branch ""parent.""; (note the trailing dot).; T.SetBranchStatus(""parent"",1);; will not activate the sub-branches of ""parent"". You should do:; T.SetBranchStatus(""parent*"",1);. Without the trailing dot in the branch creation you have no choice but to; call SetBranchStatus explicitly for each of the sub branches. An alternative to this function is to read directly and only; the interesting branches. Example:; TBranch *brc = T.GetBranch(""c"");; TBranch *bre = T.GetBranch(""e"");; brc->GetEntry(i);; bre->GetEntry(i);. If found is not 0, the number of branch(es) found matching the regular; expression is returned in *found AND the error message 'unknown branch'; is suppressed. void SetBranchStyle(Int_t style = 1); Set the current branch style. (static function). style = 0 old Branch; style = 1 new Bronch. void SetCacheSize(Long64_t cachesize = -1); Set maximum size of the file cache .; if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing; the Tree (default is 30 MBytes).; WARNING: Currently only ONE TTree object can be 'cached' per TFile object.; This call disable the cache for the other TTree objects read from the same; TFile object as this TTree (The SetCacheSize called __last__ wins).; To cache multiple TTree objects in the same ROOT file, you must create; one TFile object per TTree object. void SetCacheEntryRange(Long64_t first, Long64_t last); interface to TTreeCache to set the cache entry range. void SetCacheLearnEntries(Int_t n = 10); interface to TTreeCache to set the number of entries for the learning phase. void SetCircular(Long64_t maxEntries); Enable/Disable circularity for this tree. if maxEntries > 0 a maximum of maxEntries is kept in one buffer/basket; per branch in memory.; Note that when this function is called (maxEntries>0) the Tree; must be empty or having only one basket per branch.; if maxEntries <= 0 the tree circularity is disabled. NOTE 1:; Circular Trees are interesting in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTree.html:119750,cache,cachesize,119750,root/html528/TTree.html,https://root.cern,https://root.cern/root/html528/TTree.html,4,['cache'],['cachesize']
Performance,"nt buffer) if option =""*"" includes all sub-branches of this branch too. ;  ; TBuffer * GetTransientBuffer (Int_t size);  Returns the transient buffer currently used by this TBranch for reading/writing baskets. ;  ; TTree * GetTree () const;  ; Int_t GetWriteBasket () const;  ; Long64_t GetZipBytes (Option_t *option="""") const;  Return total number of zip bytes in the branch if option =""*"" includes all sub-branches of this branch too. ;  ; bool IsAutoDelete () const;  Return true if an existing object in a TBranchObject must be deleted. ;  ; bool IsFolder () const override;  Return true if more than one leaf or browsables, false otherwise. ;  ; virtual void KeepCircular (Long64_t maxEntries);  keep a maximum of fMaxEntries in memory ;  ; virtual Int_t LoadBaskets ();  Baskets associated to this branch are forced to be in memory. ;  ; void Print (Option_t *option="""") const override;  Print TBranch parameters. ;  ; void PrintCacheInfo () const;  Print the information we have about which basket is currently cached and whether they have been 'used'/'read' from the cache. ;  ; virtual void ReadBasket (TBuffer &b);  Loop on all leaves of this branch to read Basket buffer. ;  ; virtual void Refresh (TBranch *b);  Refresh this branch using new information in b This function is called by TTree::Refresh. ;  ; virtual void Reset (Option_t *option="""");  Reset a Branch. ;  ; virtual void ResetAddress ();  Reset the address of the branch. ;  ; virtual void ResetAfterMerge (TFileMergeInfo *);  Reset a Branch. ;  ; virtual void ResetReadEntry ();  ; virtual void SetAutoDelete (bool autodel=true);  Set the automatic delete bit. ;  ; virtual void SetBasketSize (Int_t buffsize);  Set the basket size The function makes sure that the basket size is greater than fEntryOffsetlen. ;  ; virtual void SetBufferAddress (TBuffer *entryBuffer);  Set address of this branch directly from a TBuffer to avoid streaming. ;  ; void SetCompressionAlgorithm (Int_t algorithm=ROOT::RCompressionSetting::EAlgo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHbookBranch.html:7349,cache,cached,7349,doc/master/classTHbookBranch.html,https://root.cern,https://root.cern/doc/master/classTHbookBranch.html,2,['cache'],"['cache', 'cached']"
Performance,"nt cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooArgSetRooAbsOptTestStatistic::_cachedNodes! List of nodes that are cached as constant expressions; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooAbsData*RooAbsTestStatistic::_dataPointer to original input dataset; RooAbsData*RooAbsOptTestStatistic::_dataClonePointer to internal clone if input data; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooAbsReal*RooAbsTestStatistic::_funcPointer to original input function; RooAbsReal*RooAbsOptTestStatistic::_funcClonePointer to internal clone of input function; RooArgSet*RooAbsOptTestStatistic::_funcCloneSetSet owning all components of internal clone of input function; RooArgSet*RooAbsOptTestStatistic::_funcObsSetList of observables in the pdf expression; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_l",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooDataWeightedAverage.html:33913,cache,cache,33913,root/html532/RooDataWeightedAverage.html,https://root.cern,https://root.cern/root/html532/RooDataWeightedAverage.html,2,['cache'],['cache']
Performance,"nt calls.; . Function Members (Methods); public:. virtual~RooAbsCache(); static TClass*Class(); virtual voidfindConstantNodes(const RooArgSet&, RooArgSet&, RooLinkedList&); virtual TClass*IsA() const; RooAbsCache&operator=(const RooAbsCache&); virtual voidoperModeHook(); virtual voidoptimizeCacheMode(const RooArgSet&, RooArgSet&, RooLinkedList&); virtual voidprintCompactTreeHook(ostream&, const char*); virtual Bool_tredirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); RooAbsCache(RooAbsArg* owner = 0); RooAbsCache(const RooAbsCache&, RooAbsArg* owner = 0); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidwireCache(). Data Members; protected:. RooAbsArg*_ownerPointer to owning RooAbsArg. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsCache(RooAbsArg* owner = 0); Constructor. Takes owner as argument and register cache with owner. RooAbsCache(const RooAbsCache& , RooAbsArg* owner = 0); Copy constructor. Takes owner as argument and registers cache with owne. ~RooAbsCache(); Destructor. Unregisters cache with owner. void optimizeCacheMode(const RooArgSet& , RooArgSet& , RooLinkedList& ); Interface for processing of cache mode optimization calls. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Interface for server redirect calls. void operModeHook(); Interface for operation mode changes. void findConstantNodes(const RooArgSet& , RooArgSet& , RooLinkedList& ); Interface for constant term node finding calls. void printCompactTreeHook(ostream& , const char* ); Interface for printing of cache guts in tree mode printing. void wireCache(); {}. » Last changed: Tue Jun 30 14:29:53 2015 » Last generated: 2015-06-30 14:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsCache.html:1748,cache,cache,1748,root/html602/RooAbsCache.html,https://root.cern,https://root.cern/root/html602/RooAbsCache.html,12,"['cache', 'optimiz']","['cache', 'optimization', 'optimizeCacheMode']"
Performance,"nt const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:561; gPad#define gPadDefinition TVirtualPad.h:308; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; TBrowserUsing a TBrowser one can browse all ROOT objects.Definition TBrowser.h:37; TH1D1-D histogram with a double per channel (see TH1 documentation)Definition TH1.h:670; TH1::SetDirectoryvirtual void SetDirectory(TDirectory *dir)By default, when a histogram is created, it is added to the list of histogram objects in the current ...Definition TH1.cxx:8937; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; TMemFileA TMemFile is like a normal TFile except that it reads and writes only from memory.Definition TMemFile.h:19; TRandomThis is the base class for the ROOT Random number generators.Definition TRandom.h:27; TSystem::ProcessEventsvirtual Bool_t ProcessEvents()Process pending events (GUI, timers, sockets).Definition TSystem.cxx:416; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; ROOT::EnableImplicitMTvoid EnableImplicitMT(UInt_t numthreads=0)Enable ROOT's implicit multi-threading for all objects and methods that provide an internal paralleli...Definition TROOT.cxx:539; ROOT::GetThreadPoolSizeUInt_t GetThreadPoolSize()Returns the size of ROOT's thread pool.Definition TROOT.cxx:577; lTLine lDefinition textangle.C:4; DateSeptember 2017 ; AuthorEnrico Guiraud (CERN) ; Definition in file df013_InspectAnalysis.C. tutorialsdataframedf013_InspectAnalysis.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/df013__InspectAnalysis_8C.html:8414,multi-thread,multi-threading,8414,doc/master/df013__InspectAnalysis_8C.html,https://root.cern,https://root.cern/doc/master/df013__InspectAnalysis_8C.html,1,['multi-thread'],['multi-threading']
Performance,"nt is repeated; TFile*fOutFileOutput file; TStringfOutFileNameName of the output file; TProof*fProofProof; TProof*fProofDSProof to be used for dataset actions; TPBReadType*fReadTypeType of read (partial, full); TProofBenchRunCPU*fRunCPUInstance to run CPU scans; TProofBenchRunDataRead*fRunDSInstance to run data-read scans. private:. Bool_tfUnlinkOutfileWhether to remove empty output files. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofBench(const char* url, const char* outfile = ""<default>"", const char* proofopt = 0); Constructor: check PROOF and load selectors PAR. ~TProofBench(); Destructor. Int_t OpenOutFile(Bool_t wrt = kFALSE, Bool_t verbose = kTRUE); Set the otuput file; Return 0 on success, -1 on error. Int_t SetOutFile(const char* outfile, Bool_t verbose = kTRUE); Set the output file; Return 0 on success, -1 on error. void CloseOutFile(); Close output file. Int_t RunCPU(Long64_t nevents = -1, Int_t start = -1, Int_t stop = -1, Int_t step = -1); Perform the CPU run; Return 0 on success, -1 on error. Int_t RunCPUx(Long64_t nevents = -1, Int_t start = -1, Int_t stop = -1); Perform the CPU run scanning over the number of workers per node; Return 0 on success, -1 on error. void DrawCPU(const char* outfile, const char* opt = ""std:""); Draw the CPU speedup plot.; opt = 'std:' draw standard evt/s plot; 'stdx:' draw standard evt/s plot, 1 worker per node; 'norm:' draw normalized plot; 'normx:' draw normalized plot, 1 worker per node. Int_t RunDataSet(const char* dset = ""BenchDataSet"", Int_t start = 1, Int_t stop = -1, Int_t step = 1); Perform a test using dataset 'dset'; Return 0 on success, -1 on error; Open the file for the results. Int_t RunDataSetx(const char* dset = ""BenchDataSet"", Int_t start = 1, Int_t stop = -1); Perform a test using dataset 'dset' scanning over the number of workers; per node.; Return 0 on success, -1 on error; Open the file for the results. void DrawDataSet(const char* outfile, const char* o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TProofBench.html:8372,Perform,Perform,8372,root/html532/TProofBench.html,https://root.cern,https://root.cern/root/html532/TProofBench.html,1,['Perform'],['Perform']
Performance,"nt kind of elements the check would be required.; 4119 TClass* t = nullptr;; 4120 if ((t = GetCollectionProxy()->GetValueClass())) {; 4121 if (!t->HasDictionary()) {; 4122 t->GetMissingDictionariesWithRecursionCheck(result, visited, recurse);; 4123 }; 4124 }; 4125 } else {; 4126 GetMissingDictionariesForMembers(result, visited, recurse);; 4127 GetMissingDictionariesForBaseClasses(result, visited, recurse);; 4128 }; 4129 }; 4130}; 4131 ; 4132////////////////////////////////////////////////////////////////////////////////; 4133/// Return kTRUE if the class has elements.; 4134 ; 4135Bool_t TClass::IsFolder(void *obj) const; 4136{; 4137 return Browse(obj,(TBrowser*)nullptr);; 4138}; 4139 ; 4140//______________________________________________________________________________; 4141//______________________________________________________________________________; 4142void TClass::ReplaceWith(TClass *newcl) const; 4143{; 4144 // Inform the other objects to replace this object by the new TClass (newcl); 4145 ; 4146 R__LOCKGUARD(gInterpreterMutex);; 4147 //we must update the class pointers pointing to 'this' in all TStreamerElements; 4148 TIter nextClass(gROOT->GetListOfClasses());; 4149 TClass *acl;; 4150 TVirtualStreamerInfo *info;; 4151 ; 4152 // Since we are in the process of replacing a TClass by a TClass; 4153 // coming from a dictionary, there is no point in loading any; 4154 // libraries during this search.; 4155 TInterpreter::SuspendAutoLoadingRAII autoloadOff(gInterpreter);; 4156 while ((acl = (TClass*)nextClass())) {; 4157 if (acl == newcl) continue;; 4158 ; 4159 TIter nextInfo(acl->GetStreamerInfos());; 4160 while ((info = (TVirtualStreamerInfo*)nextInfo())) {; 4161 ; 4162 info->Update(this, newcl);; 4163 }; 4164 }; 4165 ; 4166 gInterpreter->UnRegisterTClassUpdate(this);; 4167}; 4168 ; 4169////////////////////////////////////////////////////////////////////////////////; 4170/// Make sure that the current ClassInfo is up to date.; 4171 ; 4172void TClass::ResetClassIn",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:157293,load,loading,157293,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['load'],['loading']
Performance,"nt kind of elements the check would be required.; 4186 TClass* t = nullptr;; 4187 if ((t = GetCollectionProxy()->GetValueClass())) {; 4188 if (!t->HasDictionary()) {; 4189 t->GetMissingDictionariesWithRecursionCheck(result, visited, recurse);; 4190 }; 4191 }; 4192 } else {; 4193 GetMissingDictionariesForMembers(result, visited, recurse);; 4194 GetMissingDictionariesForBaseClasses(result, visited, recurse);; 4195 }; 4196 }; 4197}; 4198 ; 4199////////////////////////////////////////////////////////////////////////////////; 4200/// Return kTRUE if the class has elements.; 4201 ; 4202Bool_t TClass::IsFolder(void *obj) const; 4203{; 4204 return Browse(obj,(TBrowser*)nullptr);; 4205}; 4206 ; 4207//______________________________________________________________________________; 4208//______________________________________________________________________________; 4209void TClass::ReplaceWith(TClass *newcl) const; 4210{; 4211 // Inform the other objects to replace this object by the new TClass (newcl); 4212 ; 4213 R__LOCKGUARD(gInterpreterMutex);; 4214 //we must update the class pointers pointing to 'this' in all TStreamerElements; 4215 TIter nextClass(gROOT->GetListOfClasses());; 4216 TClass *acl;; 4217 TVirtualStreamerInfo *info;; 4218 ; 4219 // Since we are in the process of replacing a TClass by a TClass; 4220 // coming from a dictionary, there is no point in loading any; 4221 // libraries during this search.; 4222 TInterpreter::SuspendAutoLoadingRAII autoloadOff(gInterpreter);; 4223 while ((acl = (TClass*)nextClass())) {; 4224 if (acl == newcl) continue;; 4225 ; 4226 TIter nextInfo(acl->GetStreamerInfos());; 4227 while ((info = (TVirtualStreamerInfo*)nextInfo())) {; 4228 ; 4229 info->Update(this, newcl);; 4230 }; 4231 }; 4232 ; 4233 gInterpreter->UnRegisterTClassUpdate(this);; 4234}; 4235 ; 4236////////////////////////////////////////////////////////////////////////////////; 4237/// Make sure that the current ClassInfo is up to date.; 4238 ; 4239void TClass::ResetClassIn",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:160044,load,loading,160044,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['load'],['loading']
Performance,"nt list; fillList = kFALSE;; useList = kFALSE;; if (fChain) fChain->SetEntryList(0);; delete gDirectory->GetList()->FindObject(""elist"");; ; // case when one creates/fills the event list; if (option.Contains(""fillList"")) {; fillList = kTRUE;; elist = new TEntryList(""elist"",""H1 selection from Cut"");; // Add to the input list for processing in PROOF, if needed; if (fInput) {; fInput->Add(new TNamed(""fillList"",""""));; fInput->Add(elist);; }; } else elist = 0;; ; // case when one uses the event list generated in a previous call; if (option.Contains(""useList"")) {; useList = kTRUE;; if (fInput) {; tree->SetEntryList(elist);; TFile f(""elist.root"");; elist = (TEntryList*)f.Get(""elist"");; if (elist) elist->SetDirectory(0); //otherwise the file destructor will delete elist; } else {; // Option ""useList"" not supported in PROOF directly; Warning(""Begin"", ""option 'useList' not supported in PROOF - ignoring"");; Warning(""Begin"", ""the entry list must be set on the chain *before* calling Process"");; }; }; }; ; ; void h1analysisProxy_SlaveBegin(TTree *tree); {; // function called before starting the event loop; // -it performs some cleanup; // -it creates histograms; // -it sets some initialisation for the entry list; ; //initialize the Tree branch addresses; Init(tree);; ; //print the option specified in the Process function.; TString option = GetOption();; printf(""Starting (slave) h1analysis with process option: %s\n"",option.Data());; ; //create histograms; hdmd = new TH1F(""hdmd"",""dm_d"",40,0.13,0.17);; h2 = new TH2F(""h2"",""ptD0 vs dm_d"",30,0.135,0.165,30,-3,6);; ; fOutput->Add(hdmd);; fOutput->Add(h2);; ; //process cases with entry list; fillList = kFALSE;; useList = kFALSE;; ; // case when one creates/fills the entry list; if (option.Contains(""fillList"")) {; fillList = kTRUE;; // Get the list; if (fInput) {; if ((elist = (TEntryList *) fInput->FindObject(""elist""))); // Need to clone to avoid problems when destroying the selector; elist = (TEntryList *) elist->Clone();; }; if (elist);",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/h1analysisProxy_8C.html:5818,perform,performs,5818,doc/master/h1analysisProxy_8C.html,https://root.cern,https://root.cern/doc/master/h1analysisProxy_8C.html,1,['perform'],['performs']
Performance,"nt normalization/ projection; configurations can be cached. ; . Function Members (Methods); public:. RooCacheManager<RooAbsCacheElement>(Int_t maxSize = 2); RooCacheManager<RooAbsCacheElement>(RooAbsArg* owner, Int_t maxSize = 2); RooCacheManager<RooAbsCacheElement>(const RooCacheManager<RooAbsCacheElement>& other, RooAbsArg* owner = 0); virtual~RooCacheManager<RooAbsCacheElement>(); Int_tcacheSize() const; static TClass*Class(); virtual voidRooAbsCache::findConstantNodes(const RooArgSet&, RooArgSet&, RooLinkedList&); RooAbsCacheElement*getObj(const RooArgSet* nset, Int_t* sterileIndex = 0, const TNamed* isetRangeName = 0); RooAbsCacheElement*getObj(const RooArgSet* nset, const RooArgSet* iset, Int_t* sterileIdx, const char* isetRangeName); RooAbsCacheElement*getObj(const RooArgSet* nset, const RooArgSet* iset, Int_t* sterileIdx = 0, const TNamed* isetRangeName = 0); RooAbsCacheElement*getObjByIndex(Int_t index) const; virtual voidinsertObjectHook(RooAbsCacheElement&); virtual TClass*IsA() const; Int_tlastIndex() const; const RooNameSet*nameSet1ByIndex(Int_t index) const; const RooNameSet*nameSet2ByIndex(Int_t index) const; RooCacheManager<RooAbsCacheElement>&operator=(const RooCacheManager<RooAbsCacheElement>&); virtual voidoperModeHook(); virtual voidRooAbsCache::optimizeCacheMode(const RooArgSet&, RooArgSet&, RooLinkedList&); virtual voidprintCompactTreeHook(ostream&, const char*); virtual Bool_tredirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidreset(); Int_tsetObj(const RooArgSet* nset, RooAbsCacheElement* obj, const TNamed* isetRangeName = 0); Int_tsetObj(const RooArgSet* nset, const RooArgSet* iset, RooAbsCacheElement* obj, const TNamed* isetRangeName = 0); virtual voidShowMembers(TMemberInspector&); virtual voidsterilize(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidwireCache(). Data Members; protected:. Int_t_lastIndex! Last slot accessed; Int_t_maxSize! Maximum size; vector<",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooCacheManager_RooAbsCacheElement_.html:2395,optimiz,optimizeCacheMode,2395,root/html534/RooCacheManager_RooAbsCacheElement_.html,https://root.cern,https://root.cern/root/html534/RooCacheManager_RooAbsCacheElement_.html,2,['optimiz'],['optimizeCacheMode']
Performance,nt objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; TMatrixDSym*_corrMat; TMatrixDSym*_covMat; Double_t_d; RooDataSet&_data; vector<vector<Double_t> >_dataPts; vector<TVectorD>_dataPtsR; RooArgSet_dataVars; Bool_t_debug; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; TVectorD*_dx; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_t_fixedShape; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooNDKeysPdf::BoxInfo_fullBoxInfo; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; vector<Int_t>_idx; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Double_t_maxWeight; vector<Double_t>_mean; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; Double_t_minWeight; Bool_t_mirror; Double_t_n; Int_t_nDim; Int_t_nEvents; Double_t_nEventsBMSW; Double_t_nEventsBW; Int_t_nEventsM; Double_t_nEventsW; Double_t_nSigma; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print;,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooNDKeysPdf.html:38873,cache,cache,38873,root/html526/RooNDKeysPdf.html,https://root.cern,https://root.cern/root/html526/RooNDKeysPdf.html,5,['cache'],['cache']
Performance,"nt of TTree::Process();; SaveSource : save the current session as a C++ macro;; SetScanFileName : define a name for the file where TTree::Scan command is redirected when the <Scan> button is checked;; SetTreeName : open a new tree with this name in the viewer;. A specific context menu is activated if expressions/leaves are right-clicked.; Commands are :; Draw : draw a histogram for this item;; EditExpression : pops-up the expression editor;; Empty : empty the name and alias of this item;; RemoveItem : removes clicked item from the list;; Scan : scan this expression;; SetExpression : edit name and alias for this item by hand;. Starting the viewer. From the TBrowser: Select a tree in the TBrowser, then call the StartViewer() method from its context menu (right-click on the tree).; From the command line: Start a ROOT session in the directory where you have your tree. You will need first to load the library for TTreeViewer and optionally other libraries for user defined classes (you can do this later in the session) : root [0] gSystem->Load(\""TTreeViewer\"");; gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:561; TSystem::Loadvirtual int Load(const char *module, const char *entry="""", Bool_t system=kFALSE)Load a shared library.Definition TSystem.cxx:1857; Supposing you have the tree MyTree in the file MyFile, you can do : root [1] TFile file(""Myfile"");; root [2] new TTreeViewer(""Mytree"");; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TTreeViewerA graphic user interface designed to handle ROOT trees and to take advantage of TTree class features.Definition TTreeViewer.h:54; or : root [2] TTreeViewer *tv = new TTreeViewer();; root [3] tv->SetTreeName(""Mytree"");; . Definition at line 54 of file TTreeViewer.h. Public Types; enum  EListItemType { ;   kLTNoType = 0; , kLTPackType = (1ULL << ( 0 )); , kLTTreeType = (1ULL << ( 1 )); , kLTBranchType = (1ULL << ( 2 )); , ;   kLTLeafType = (1U",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeViewer.html:7093,load,load,7093,doc/master/classTTreeViewer.html,https://root.cern,https://root.cern/doc/master/classTTreeViewer.html,1,['load'],['load']
Performance,"nt pad, a reference to the graphics is kept that PyROOT isn’t currently aware of, and it is up to the developer to keep at lease one Python reference alive. See $ROOTSYS/tutorials/pyroot/zdemo.py (available in the latest release) for an example. Alternatively, one can tell python to give up ownership for individual instances:; o = ROOT.TObject(); ROOT.SetOwnership( o, False ) # True to own, False to release; 19.1.6.2 Memory Management by Hand; If needed, you can explicitly destroy a ROOT object that you own through its associated TClass:; myobject.IsA().Destructor(myobject); which will send out the deletion notification to the system (thus you do not need to care anymore at this point about Python reference counting, the object will go, even if it’s reference count it non-zero), and free the memory.; 19.1.7 Performance; The performance of PyROOT when programming with ROOT in Python is similar to that of Cling. Differences occur mainly because of differences in the respective languages: C++ is much harder to parse, but once parsed, it is much easier to optimize. Consequently, individual calls to ROOT are typically faster from PyROOT, whereas loops are typically slower.; When programming in Python, the modus operandi is to consider performance generally “good enough” on the outset, and when it turns out that, it is not good enough; the performance critical part is converted into C/C++ in an extension module. The school of thought where pre-mature optimization is the root of all evil should find this way of working very satisfying. In addition, if you look at their history, you will see that many of the standard Python modules have followed this path.; Your code should always make maximum use of ROOT facilities; such that most of the time is spending in compiled code. This goes even for very simple things: e.g. do not compute invariant masses in Python, use TLorentzVector instead. Moreover, before you start optimizing, make sure that you have run a profiler to find out",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1062996,optimiz,optimize,1062996,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['optimiz'],['optimize']
Performance,"nt status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Static Protected Attributes inherited from RooAbsPdf; static TString _normRangeOverride;  ; static Int_t _verboseEval = 0;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include </home/sftnight/build/workspace/root-makedoc-master/rootspi/rdoc/src/master/roofit/roofitcore/src/RooNormalizedPdf.h>. Inheritance diagram for RooNormalizedPdf:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RooNormalizedPdf() [1/2]. RooNormalizedPdf::RooNormalizedPdf ; (; RooAbsPdf & ; pdf, . RooArgSet const & ; normSet . ). inline . Definition at line 21 of file RooNormalizedPdf.h. ◆ RooNormalizedPdf() [2/2]. RooNormalizedPdf::RooNormalizedPdf ; (; const RooNormalizedPdf & ; other, . const char * ; name . ). inline . Definition at line 34 of file RooNormalizedPdf.h. Member Function Documentation. ◆ analyticalIntegralWN(). double RooNormalizedPdf::analyticalIntegralWN ; (; Int_t ; code, . const RooArg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooNormalizedPdf.html:72722,cache,cache,72722,doc/master/classRooNormalizedPdf.html,https://root.cern,https://root.cern/doc/master/classRooNormalizedPdf.html,1,['cache'],['cache']
Performance,"nt status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Static Protected Attributes inherited from RooAbsPdf; static TString _normRangeOverride;  ; static Int_t _verboseEval = 0;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <Roo2DKeysPdf.h>. Inheritance diagram for Roo2DKeysPdf:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ Roo2DKeysPdf() [1/2]. Roo2DKeysPdf::Roo2DKeysPdf ; (; const char * ; name, . const char * ; title, . RooAbsReal & ; xx, . RooAbsReal & ; yy, . RooDataSet & ; data, . TString ; options = ""a"", . double ; widthScaleFactor = 1.0 . ). Constructor. ; Parameters. [in]name; [in]title; [in]xx; [in]yy; [in]data; [in]options; [in]widthScaleFactor. Definition at line 49 of file Roo2DKeysPdf.cxx. ◆ Roo2DKeysPdf() [2/2]. Roo2DKeysPdf::Roo2DKeysPdf ; (; const Roo2DKeysPdf & ; other, . const char * ; name = nullptr . ). Copy constructor. ; Parameters. [in]other; [in]name. Definition at line 65 of file Roo2DKeysPdf.cx",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRoo2DKeysPdf.html:75843,cache,cache,75843,doc/master/classRoo2DKeysPdf.html,https://root.cern,https://root.cern/doc/master/classRoo2DKeysPdf.html,1,['cache'],['cache']
Performance,"nt status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Static Protected Attributes inherited from RooAbsPdf; static TString _normRangeOverride;  ; static Int_t _verboseEval = 0;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooBernstein.h>. Inheritance diagram for RooBernstein:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RooBernstein() [1/3]. RooBernstein::RooBernstein ; (; ). default . ◆ RooBernstein() [2/3]. RooBernstein::RooBernstein ; (; const char * ; name, . const char * ; title, . RooAbsRealLValue & ; _x, . const RooArgList & ; _coefList . ). Definition at line 44 of file RooBernstein.cxx. ◆ RooBernstein() [3/3]. RooBernstein::RooBernstein ; (; const RooBernstein & ; other, . const char * ; name = nullptr . ). Definition at line 50 of file RooBernstein.cxx. Member Function Documentation. ◆ analyticalIntegral(). double RooBernstein::analyticalIntegral ; (; Int_t ; code, . const char * ; rangeName = nullptr . ); ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooBernstein.html:74130,cache,cache,74130,doc/master/classRooBernstein.html,https://root.cern,https://root.cern/doc/master/classRooBernstein.html,1,['cache'],['cache']
Performance,"nt status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Static Protected Attributes inherited from RooAbsPdf; static TString _normRangeOverride;  ; static Int_t _verboseEval = 0;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooBinSamplingPdf.h>. Inheritance diagram for RooBinSamplingPdf:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RooBinSamplingPdf() [1/3]. RooBinSamplingPdf::RooBinSamplingPdf ; (; ). inline . Definition at line 31 of file RooBinSamplingPdf.h. ◆ RooBinSamplingPdf() [2/3]. RooBinSamplingPdf::RooBinSamplingPdf ; (; const char * ; name, . const char * ; title, . RooAbsRealLValue & ; observable, . RooAbsPdf & ; inputPdf, . double ; epsilon = 1.E-4 . ). Construct a new RooBinSamplingPdf. ; Parameters. [in]nameA name to identify this object. ; [in]titleTitle (for e.g. plotting) ; [in]observableObservable to integrate over (the one that is binned). ; [in]inputPdfA PDF whose bins should be sampled with higher",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooBinSamplingPdf.html:77500,cache,cache,77500,doc/master/classRooBinSamplingPdf.html,https://root.cern,https://root.cern/doc/master/classRooBinSamplingPdf.html,1,['cache'],['cache']
Performance,"nt status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Static Protected Attributes inherited from RooAbsPdf; static TString _normRangeOverride;  ; static Int_t _verboseEval = 0;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooChebychev.h>. Inheritance diagram for RooChebychev:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RooChebychev() [1/3]. RooChebychev::RooChebychev ; (; ). default . ◆ RooChebychev() [2/3]. RooChebychev::RooChebychev ; (; const char * ; name, . const char * ; title, . RooAbsReal & ; _x, . const RooArgList & ; _coefList . ). Constructor. ; Definition at line 45 of file RooChebychev.cxx. ◆ RooChebychev() [3/3]. RooChebychev::RooChebychev ; (; const RooChebychev & ; other, . const char * ; name = nullptr . ). Definition at line 56 of file RooChebychev.cxx. Member Function Documentation. ◆ analyticalIntegral(). double RooChebychev::analyticalIntegral ; (; Int_t ; code, . const char * ; rangeName = null",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooChebychev.html:73319,cache,cache,73319,doc/master/classRooChebychev.html,https://root.cern,https://root.cern/doc/master/classRooChebychev.html,1,['cache'],['cache']
Performance,"nt status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Static Protected Attributes inherited from RooAbsPdf; static TString _normRangeOverride;  ; static Int_t _verboseEval = 0;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooChiSquarePdf.h>. Inheritance diagram for RooChiSquarePdf:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RooChiSquarePdf() [1/3]. RooChiSquarePdf::RooChiSquarePdf ; (; ). Definition at line 31 of file RooChiSquarePdf.cxx. ◆ RooChiSquarePdf() [2/3]. RooChiSquarePdf::RooChiSquarePdf ; (; const char * ; name, . const char * ; title, . RooAbsReal & ; x, . RooAbsReal & ; ndof . ). Definition at line 37 of file RooChiSquarePdf.cxx. ◆ RooChiSquarePdf() [3/3]. RooChiSquarePdf::RooChiSquarePdf ; (; const RooChiSquarePdf & ; other, . const char * ; name = nullptr . ). Definition at line 47 of file RooChiSquarePdf.cxx. Member Function Documentation. ◆ analyticalIntegral(). double RooChiSquarePdf::analyticalIn",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooChiSquarePdf.html:73089,cache,cache,73089,doc/master/classRooChiSquarePdf.html,https://root.cern,https://root.cern/doc/master/classRooChiSquarePdf.html,1,['cache'],['cache']
Performance,"nt status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Static Protected Attributes inherited from RooAbsPdf; static TString _normRangeOverride;  ; static Int_t _verboseEval = 0;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooCrystalBall.h>. Inheritance diagram for RooCrystalBall:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RooCrystalBall() [1/5]. RooCrystalBall::RooCrystalBall ; (; ). inline . Definition at line 16 of file RooCrystalBall.h. ◆ RooCrystalBall() [2/5]. RooCrystalBall::RooCrystalBall ; (; const char * ; name, . const char * ; title, . RooAbsReal & ; x, . RooAbsReal & ; x0, . RooAbsReal & ; sigmaL, . RooAbsReal & ; sigmaR, . RooAbsReal & ; alphaL, . RooAbsReal & ; nL, . RooAbsReal & ; alphaR, . RooAbsReal & ; nR . ). Creates the fully parametrized crystal ball shape with asymmetric Gaussian core and asymmetric tails. ; Parameters. nameName that identifies the PDF in computations. ; titleTitle for plottin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCrystalBall.html:74873,cache,cache,74873,doc/master/classRooCrystalBall.html,https://root.cern,https://root.cern/doc/master/classRooCrystalBall.html,1,['cache'],['cache']
Performance,"nt status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Static Protected Attributes inherited from RooAbsPdf; static TString _normRangeOverride;  ; static Int_t _verboseEval = 0;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooGExpModel.h>. Inheritance diagram for RooGExpModel:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Enumeration Documentation. ◆ Type. enum RooGExpModel::Type. EnumeratorNormal ; Flipped . Definition at line 28 of file RooGExpModel.h. Constructor & Destructor Documentation. ◆ RooGExpModel() [1/6]. RooGExpModel::RooGExpModel ; (; ). default . ◆ RooGExpModel() [2/6]. RooGExpModel::RooGExpModel ; (; const char * ; name, . const char * ; title, . RooAbsRealLValue & ; xIn, . RooAbsReal & ; meanIn, . RooAbsReal & ; sigmaIn, . RooAbsReal & ; rlifeIn, . RooAbsReal & ; meanSF, . RooAbsReal & ; sigmaSF, . RooAbsReal & ; rlifeSF, . bool ; nlo = false, . Type ; type = Normal . ). Create a Gauss (x) Exp model with mean, sigma and tau parameters a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooGExpModel.html:77705,cache,cache,77705,doc/master/classRooGExpModel.html,https://root.cern,https://root.cern/doc/master/classRooGExpModel.html,1,['cache'],['cache']
Performance,"nt status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Static Protected Attributes inherited from RooAbsPdf; static TString _normRangeOverride;  ; static Int_t _verboseEval = 0;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooGaussModel.h>. Inheritance diagram for RooGaussModel:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RooGaussModel() [1/5]. RooGaussModel::RooGaussModel ; (; ). default . ◆ RooGaussModel() [2/5]. RooGaussModel::RooGaussModel ; (; const char * ; name, . const char * ; title, . RooAbsRealLValue & ; x, . RooAbsReal & ; mean, . RooAbsReal & ; sigma . ). Definition at line 89 of file RooGaussModel.cxx. ◆ RooGaussModel() [3/5]. RooGaussModel::RooGaussModel ; (; const char * ; name, . const char * ; title, . RooAbsRealLValue & ; x, . RooAbsReal & ; mean, . RooAbsReal & ; sigma, . RooAbsReal & ; msSF . ). Definition at line 97 of file RooGaussModel.cxx. ◆ RooGaussModel() [4/5]. RooGaussModel::RooGaussModel",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooGaussModel.html:75896,cache,cache,75896,doc/master/classRooGaussModel.html,https://root.cern,https://root.cern/doc/master/classRooGaussModel.html,1,['cache'],['cache']
Performance,"nt status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Static Protected Attributes inherited from RooAbsPdf; static TString _normRangeOverride;  ; static Int_t _verboseEval = 0;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooJohnson.h>. Inheritance diagram for RooJohnson:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Enumeration Documentation. ◆ AnaInt_t. enum RooJohnson::AnaInt_t. private . EnumeratorkMass ; kMean ; kLambda ; kGamma ; kDelta . Definition at line 46 of file RooJohnson.h. Constructor & Destructor Documentation. ◆ RooJohnson() [1/3]. RooJohnson::RooJohnson ; (; ). inline . Definition at line 26 of file RooJohnson.h. ◆ RooJohnson() [2/3]. RooJohnson::RooJohnson ; (; const char * ; name, . const char * ; title, . RooAbsReal & ; mass, . RooAbsReal & ; mu, . RooAbsReal & ; lambda, . RooAbsReal & ; gamma, . RooAbsReal & ; delta, . double ; massThreshold = -std::numeric_limits<double>::max() . ). Construct a new Johnson PDF. ; Parameters. name",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooJohnson.html:74024,cache,cache,74024,doc/master/classRooJohnson.html,https://root.cern,https://root.cern/doc/master/classRooJohnson.html,1,['cache'],['cache']
Performance,"nt status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Static Protected Attributes inherited from RooAbsPdf; static TString _normRangeOverride;  ; static Int_t _verboseEval = 0;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooNovosibirsk.h>. Inheritance diagram for RooNovosibirsk:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RooNovosibirsk() [1/3]. RooNovosibirsk::RooNovosibirsk ; (; ). inline . Definition at line 31 of file RooNovosibirsk.h. ◆ RooNovosibirsk() [2/3]. RooNovosibirsk::RooNovosibirsk ; (; const char * ; name, . const char * ; title, . RooAbsReal & ; _x, . RooAbsReal & ; _peak, . RooAbsReal & ; _width, . RooAbsReal & ; _tail . ). Definition at line 40 of file RooNovosibirsk.cxx. ◆ RooNovosibirsk() [3/3]. RooNovosibirsk::RooNovosibirsk ; (; const RooNovosibirsk & ; other, . const char * ; name = nullptr . ). Definition at line 55 of file RooNovosibirsk.cxx. Member Function Documentation. ◆ analyticalInteg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooNovosibirsk.html:73117,cache,cache,73117,doc/master/classRooNovosibirsk.html,https://root.cern,https://root.cern/doc/master/classRooNovosibirsk.html,1,['cache'],['cache']
Performance,"nt status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Static Protected Attributes inherited from RooAbsPdf; static TString _normRangeOverride;  ; static Int_t _verboseEval = 0;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooProdPdf.h>. Inheritance diagram for RooProdPdf:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RooProdPdf() [1/7]. RooProdPdf::RooProdPdf ; (; ). Default constructor. ; Definition at line 82 of file RooProdPdf.cxx. ◆ RooProdPdf() [2/7]. RooProdPdf::RooProdPdf ; (; const char * ; name, . const char * ; title, . RooAbsPdf & ; pdf1, . RooAbsPdf & ; pdf2, . double ; cutOff = 0.0 . ). Constructor with 2 PDFs (most frequent use case). ; The optional cutOff parameter can be used as a speed optimization if one or more of the PDF have sizable regions with very small values, which would pull the entire product of PDFs to zero in those regions.; After each PDF multiplication, the running product is compared w",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooProdPdf.html:80081,cache,cache,80081,doc/master/classRooProdPdf.html,https://root.cern,https://root.cern/doc/master/classRooProdPdf.html,1,['cache'],['cache']
Performance,"nt status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Static Protected Attributes inherited from RooAbsPdf; static TString _normRangeOverride;  ; static Int_t _verboseEval = 0;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooTruthModel.h>. Inheritance diagram for RooTruthModel:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RooTruthModel() [1/3]. RooTruthModel::RooTruthModel ; (; ). default . ◆ RooTruthModel() [2/3]. RooTruthModel::RooTruthModel ; (; const char * ; name, . const char * ; title, . RooAbsRealLValue & ; x . ). Constructor of a truth resolution model, i.e. a delta function in observable 'xIn'. ; Definition at line 89 of file RooTruthModel.cxx. ◆ RooTruthModel() [3/3]. RooTruthModel::RooTruthModel ; (; const RooTruthModel & ; other, . const char * ; name = nullptr . ). inline . Definition at line 26 of file RooTruthModel.h. Member Function Documentation. ◆ analyticalIntegral(). double RooTruthModel::analyti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooTruthModel.html:75163,cache,cache,75163,doc/master/classRooTruthModel.html,https://root.cern,https://root.cern/doc/master/classRooTruthModel.html,1,['cache'],['cache']
Performance,"nt status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Static Protected Attributes inherited from RooAbsPdf; static TString _normRangeOverride;  ; static Int_t _verboseEval = 0;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooWrapperPdf.h>. Inheritance diagram for RooWrapperPdf:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RooWrapperPdf() [1/3]. RooWrapperPdf::RooWrapperPdf ; (; ). inline . Definition at line 27 of file RooWrapperPdf.h. ◆ RooWrapperPdf() [2/3]. RooWrapperPdf::RooWrapperPdf ; (; const char * ; name, . const char * ; title, . RooAbsReal & ; inputFunction, . bool ; selfNormalized = false . ). inline . Construct a new RooWrapperPdf. ; Parameters. [in]nameA name to identify this object. ; [in]titleTitle (for e.g. plotting) ; [in]inputFunctionAny RooAbsReal that should be converted into a PDF. Although it's possible ; [in]selfNormalizedThe return value the RooAbsPdf::selfNormalized() function for the wrappe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooWrapperPdf.html:73489,cache,cache,73489,doc/master/classRooWrapperPdf.html,https://root.cern,https://root.cern/doc/master/classRooWrapperPdf.html,1,['cache'],['cache']
Performance,"nt status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Static Protected Attributes inherited from RooAbsPdf; static TString _normRangeOverride;  ; static Int_t _verboseEval = 0;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . Inheritance diagram for PdfWrapper:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ PdfWrapper() [1/2]. PdfWrapper::PdfWrapper ; (; RooAbsReal & ; f, . RooAbsReal * ; coef, . bool ; expEvMode = false, . RooAbsPdf * ; expPdf = nullptr . ). inline . Definition at line 7165 of file xRooNode.cxx. ◆ ~PdfWrapper(). PdfWrapper::~PdfWrapper ; (; ). inlineoverride . Definition at line 7184 of file xRooNode.cxx. ◆ PdfWrapper() [2/2]. PdfWrapper::PdfWrapper ; (; const PdfWrapper & ; other, . const char * ; name = nullptr . ). inline . Definition at line 7185 of file xRooNode.cxx. Member Function Documentation. ◆ binBoundaries(). std::list< double > * PdfWrapper::binBoundaries ; (; RooAbsRealLValue & ; obs, . double ; xlo, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classPdfWrapper.html:72845,cache,cache,72845,doc/master/classPdfWrapper.html,https://root.cern,https://root.cern/doc/master/classPdfWrapper.html,1,['cache'],['cache']
Performance,"nt status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Static Protected Attributes inherited from RooAbsPdf; static TString _normRangeOverride;  ; static Int_t _verboseEval = 0;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . Inheritance diagram for RooFixedProdPdf:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RooFixedProdPdf() [1/2]. RooFixedProdPdf::RooFixedProdPdf ; (; std::unique_ptr< RooProdPdf > && ; prodPdf, . RooArgSet const & ; normSet . ). inline . Definition at line 2320 of file RooProdPdf.cxx. ◆ RooFixedProdPdf() [2/2]. RooFixedProdPdf::RooFixedProdPdf ; (; const RooFixedProdPdf & ; other, . const char * ; name = nullptr . ). inline . Definition at line 2326 of file RooProdPdf.cxx. Member Function Documentation. ◆ analyticalIntegral(). double RooFixedProdPdf::analyticalIntegral ; (; Int_t ; code, . const char * ; rangeName = nullptr . ); const. inlineoverridevirtual . Implements the actual analytical integral(s) advert",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooFixedProdPdf.html:73077,cache,cache,73077,doc/master/classRooFixedProdPdf.html,https://root.cern,https://root.cern/doc/master/classRooFixedProdPdf.html,1,['cache'],['cache']
Performance,"nt status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Static Protected Attributes inherited from RooAbsPdf; static TString _normRangeOverride;  ; static Int_t _verboseEval = 0;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . Inheritance diagram for xRooProjectedPdf:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Function Documentation. ◆ clone(). TObject * xRooProjectedPdf::clone ; (; const char * ; newname); const. inlineoverridevirtual . Reimplemented from RooProjectedPdf.; Definition at line 7152 of file xRooNode.cxx. ◆ evaluate(). double xRooProjectedPdf::evaluate ; (; ); const. inlineoverrideprotectedvirtual . Evaluate projected p.d.f. ; Reimplemented from RooProjectedPdf.; Definition at line 7155 of file xRooNode.cxx. ◆ expectedEvents(). double xRooProjectedPdf::expectedEvents ; (; const RooArgSet * ; nset); const. inlineoverridevirtual . Return expected number of events to be used in calculation of extended likelihood. ; Return expected number of events from ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classxRooProjectedPdf.html:73920,cache,cache,73920,doc/master/classxRooProjectedPdf.html,https://root.cern,https://root.cern/doc/master/classxRooProjectedPdf.html,1,['cache'],['cache']
Performance,"nt values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; TF1*func; RooListProxyolist; RooListProxyplist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooTFnBinding.html:32500,cache,cache,32500,root/html530/RooTFnBinding.html,https://root.cern,https://root.cern/root/html530/RooTFnBinding.html,1,['cache'],['cache']
Performance,"nt values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_t_intOrderInterpolation order; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Double_t_totVolume! Total volume of space (product of ranges of observables); Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Bool_t_unitNorm! Assume contents is unit normalized (for use as pdf cache); Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDir",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooHistFunc.html:32610,cache,cache,32610,root/html530/RooHistFunc.html,https://root.cern,https://root.cern/root/html530/RooHistFunc.html,1,['cache'],['cache']
Performance,"nt with ScaleType RooAbsReal::RelativeExpected has to be passed, e.g. pdf.plotOn(frame, VisualizeError(fitResult), Normalization(1.0, RooAbsReal::RelativeExpected));; RooAbsReal::RelativeExpected@ RelativeExpectedDefinition RooAbsReal.h:276. VisualizeError(const RooFitResult& fitres, const RooArgSet& param, double Z=1, bool linearMethod=true) Visualize the uncertainty on the subset of parameters 'param', as given in fitres, at 'Z' sigma . Reimplemented from RooAbsReal.; Reimplemented in RooSimultaneous, and RooSimultaneous.; Definition at line 1937 of file RooAbsPdf.cxx. ◆ prepareMultiGen(). RooAbsPdf::prepareMultiGen ; (; const RooArgSet & ; whatVars, . const RooCmdArg & ; arg1 = {}, . const RooCmdArg & ; arg2 = {}, . const RooCmdArg & ; arg3 = {}, . const RooCmdArg & ; arg4 = {}, . const RooCmdArg & ; arg5 = {}, . const RooCmdArg & ; arg6 = {} . ). Prepare GenSpec configuration object for efficient generation of multiple datasets from identical specification. ; NoteThis method does not perform any generation. To generate according to generations specification call RooAbsPdf::generate(RooAbsPdf::GenSpec&) const. Details copied from RooAbsPdf::generate():; Generate the specified number of events or expectedEvents() if not specified. Parameters. [in]whatVarsChoose variables in which to generate events. Variables not listed here will remain constant and not be used for event generation. ; [in]arg1,arg2,arg3,arg4,arg5,arg6Optional RooCmdArg() to change behaviour of generate(). . ReturnsRooDataSet *, owned by caller.; Any variables of this PDF that are not in whatVars will use their current values and be treated as fixed parameters. Returns zero in case of an error. Type of CmdArg Effect on generate . Name(const char* name) Name of the output dataset . Verbose(bool flag) Print informational messages during event generation . NumEvents(int nevt) Generate specified number of events . Extended() If no number of events to be generated is given, use expected number of events ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsPdf.html:146585,perform,perform,146585,doc/master/classRooAbsPdf.html,https://root.cern,https://root.cern/doc/master/classRooAbsPdf.html,1,['perform'],['perform']
Performance,"nt! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManagerRooAbsCachedReal::_cacheMgr! The cache manager; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Int_tRooAbsCachedReal::_ipOrderInterpolation order for cache histograms ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsSelfCachedReal.html:34874,cache,cache,34874,root/html534/RooAbsSelfCachedReal.html,https://root.cern,https://root.cern/root/html534/RooAbsSelfCachedReal.html,21,"['Cache', 'cache']","['Cached', 'cache']"
Performance,"nt(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooBifurGauss&operator=(const RooBifurGauss&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooBifurGauss.html:22902,optimiz,optimizeCacheMode,22902,root/html602/RooBifurGauss.html,https://root.cern,https://root.cern/root/html602/RooBifurGauss.html,8,['optimiz'],['optimizeCacheMode']
Performance,"nt(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooEfficiency&operator=(const RooEfficiency&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooEfficiency.html:23226,optimiz,optimizeCacheMode,23226,root/html602/RooEfficiency.html,https://root.cern,https://root.cern/root/html602/RooEfficiency.html,8,['optimiz'],['optimizeCacheMode']
Performance,"nt(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooFFTConvPdf&operator=(const RooFFTConvPdf&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooFFTConvPdf.html:27741,optimiz,optimizeCacheMode,27741,root/html602/RooFFTConvPdf.html,https://root.cern,https://root.cern/root/html602/RooFFTConvPdf.html,8,['optimiz'],['optimizeCacheMode']
Performance,"nt(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooGenericPdf&operator=(const RooGenericPdf&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooGenericPdf.html:23619,optimiz,optimizeCacheMode,23619,root/html602/RooGenericPdf.html,https://root.cern,https://root.cern/root/html602/RooGenericPdf.html,8,['optimiz'],['optimizeCacheMode']
Performance,"nt(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooNumConvPdf&operator=(const RooNumConvPdf&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooNumConvPdf.html:25260,optimiz,optimizeCacheMode,25260,root/html602/RooNumConvPdf.html,https://root.cern,https://root.cern/root/html602/RooNumConvPdf.html,8,['optimiz'],['optimizeCacheMode']
Performance,"nt(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooPolynomial&operator=(const RooPolynomial&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooPolynomial.html:23082,optimiz,optimizeCacheMode,23082,root/html602/RooPolynomial.html,https://root.cern,https://root.cern/root/html602/RooPolynomial.html,8,['optimiz'],['optimizeCacheMode']
Performance,"nt(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooRealSumPdf&operator=(const RooRealSumPdf&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooRealSumPdf.html:23404,optimiz,optimizeCacheMode,23404,root/html602/RooRealSumPdf.html,https://root.cern,https://root.cern/root/html602/RooRealSumPdf.html,8,['optimiz'],['optimizeCacheMode']
Performance,"nt) const;  transform gradient vector (external -> internal) at internal point x ;  ; void InvStepTransformation (const double *x, const double *sext, double *sint) const;  inverse transformation for steps (external -> internal) at external point x ;  ; void InvTransformation (const double *xext, double *xint) const;  inverse transformation (external -> internal) ;  ; void MatrixTransformation (const double *x, const double *covInt, double *covExt) const;  transform covariance matrix (internal -> external) at internal point x use row storages for matrices m(i,j) = rep[ i * dim + j] ;  ; unsigned int NDim () const override;  Retrieve the dimension of the function. ;  ; unsigned int NTot () const;  ; const IMultiGradFunction * OriginalFunction () const;  ; const double * Transformation (const double *x) const;  transform from internal to external result is cached also inside the class ;  ; void Transformation (const double *xint, double *xext) const;  transform from internal to external ;  ;  Public Member Functions inherited from ROOT::Math::IGradientFunctionMultiDimTempl< T >; T Derivative (const T *x, unsigned int icoord, T *previous_grad, T *previous_g2, T *previous_gstep) const;  In some cases, the derivative algorithm will use information from the previous step, these can be passed in with this overload. ;  ; T Derivative (const T *x, unsigned int icoord=0) const;  Return the partial derivative with respect to the passed coordinate. ;  ; virtual void FdF (const T *x, T &f, T *df) const;  Optimized method to evaluate at the same time the function value and derivative at a point x. ;  ; virtual void Gradient (const T *x, T *grad) const;  Evaluate all the vector of function derivatives (gradient) at a point x. ;  ; virtual void GradientWithPrevResult (const T *x, T *grad, T *previous_grad, T *previous_g2, T *previous_gstep) const;  In some cases, the gradient algorithm will use information from the previous step, these can be passed in with this overload. ;  ; bool",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1MinimTransformFunction.html:2805,cache,cached,2805,doc/master/classROOT_1_1Math_1_1MinimTransformFunction.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1MinimTransformFunction.html,1,['cache'],['cached']
Performance,"nt.; [#1] INFO:NumericIntegration -- RooRealIntegral::init(Tpsi_CONV_Rpsi_CACHE_Obs[cpsi]_NORM_cpsi_Int[cpsi]) using numeric integrator RooIntegrator1D to calculate Int(cpsi); [#1] INFO:Caching -- RooAbsCachedPdf::getCache(Mf) creating new cache 0x5569d79e4210 with pdf Tpsi_CONV_Rpsi_CACHE_Obs[cpsi]_NORM_cpsi for nset (cpsi) with code 0 from preexisting content.; [#1] INFO:NumericIntegration -- RooRealIntegral::init(Tpsi_CONV_Rpsi_CACHE_Obs[cpsi]_NORM_cpsi_Int[cpsi]) using numeric integrator RooIntegrator1D to calculate Int(cpsi); [#1] INFO:Caching -- RooAbsCachedPdf::getCache(Mf) creating new cache 0x5569d79e4210 with pdf Tpsi_CONV_Rpsi_CACHE_Obs[cpsi]_NORM_cpsi for nset (cpsi) with code 0 from preexisting content.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(Mf_over_Mf_Int[cpsi]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_Mf_over_Mf_Int[cpsi]_MfData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(Mf) creating new cache 0x5569d7a58030 with pdf Tpsi_CONV_Rpsi_CACHE_Obs[cpsi] for nset () with code 1 from preexisting content.; [#1] INFO:NumericIntegration -- RooRealIntegral::init(Mf_Int[cpsi]) using numeric integrator RooIntegrator1D to calculate Int(cpsi); [#1] INFO:NumericIntegration -- RooRealIntegral::init(Tpsi_Int[psi]) using numeric integrator RooIntegrator1D to calculate Int(psi); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(Tpsi_Int[psi]) using numeric integrator RooIntegrator1D to calculate Int(psi); [#1] INFO:Caching -- RooAbsCachedPdf::getCache(Mf) creating new cache 0x5569d7a58030 with pdf Tpsi_CONV_Rpsi_CACHE_Obs[cpsi]_NORM_cpsi for nset (cpsi) with code 0; [#1] INFO:NumericIntegration -- RooRealIntegral::init(Tpsi_CONV",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf210__angularconv_8C.html:9661,optimiz,optimization,9661,doc/master/rf210__angularconv_8C.html,https://root.cern,https://root.cern/doc/master/rf210__angularconv_8C.html,2,"['cache', 'optimiz']","['cache', 'optimization']"
Performance,"nt;; 703 while ((element = (TStreamerElement*) next())) {; 704 if (element->TestBit(TStreamerElement::kCache)) {; 705 element->SetOffset(infoalloc->GetOffset(element->GetName()));; 706 }; 707 }; 708 }; 709 ; 710 TStreamerElement *el = new TStreamerArtificial(""@@alloc"","""", 0, TStreamerInfo::kCacheNew, allocClass->GetName());; 711 R__TObjArray_InsertAt( fElements, el, 0 );; 712 ; 713 el = new TStreamerArtificial(""@@dealloc"","""", 0, TStreamerInfo::kCacheDelete, allocClass->GetName());; 714 fElements->Add( el );; 715 }; 716 }; 717 ; 718 //; 719 // Make a more compact version.; 720 //; 721 Compile();; 722 fIsBuilt = kTRUE;; 723}; 724 ; 725////////////////////////////////////////////////////////////////////////////////; 726/// Check if built and consistent with the class dictionary.; 727/// This method is called by TFile::ReadStreamerInfo.; 728 ; 729void TStreamerInfo::BuildCheck(TFile *file /* = 0 */, Bool_t load /* = kTRUE */); 730{; 731 R__LOCKGUARD(gInterpreterMutex);; 732 ; 733 fClass = TClass::GetClass(GetName(), load);; 734 if (!fClass) {; 735 // fClassVersion should have been a Version_t and/or Version_t; 736 // should have been an Int_t. Changing the on-file format; 737 // of the StreamerInfo is 'hard' (for forward compatibility), so; 738 // leave it as is for now.; 739 fClass = new TClass(GetName(), (Version_t)fClassVersion);; 740 ; 741 // Case of a custom collection (the user provided a CollectionProxy; 742 // for a class that is not an STL collection).; 743 if (GetElements()->GetEntriesFast() == 1) {; 744 TObject *element = GetElements()->UncheckedAt(0);; 745 Bool_t isstl = element && strcmp(""This"",element->GetName())==0;; 746 if (isstl) {; 747 if (element->GetTitle()[0] == '<') {; 748 // We know the content.; 749 TString content = element->GetTitle();; 750 Int_t level = 1;; 751 for(Int_t c = 1; c < content.Length(); ++c) {; 752 if (content[c] == '<') ++level;; 753 else if (content[c] == '>') --level;; 754 if (level == 0) {; 755 content.Remove(c+1);; 756 break;;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:26755,load,load,26755,doc/master/TStreamerInfo_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html,2,['load'],['load']
Performance,"nt>&); virtual voidoperModeHook(); virtual voidRooAbsCache::optimizeCacheMode(const RooArgSet&, RooArgSet&, RooLinkedList&); virtual voidprintCompactTreeHook(ostream&, const char*); virtual Bool_tredirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidreset(); Int_tsetObj(const RooArgSet* nset, RooAbsCacheElement* obj, const TNamed* isetRangeName = 0); Int_tsetObj(const RooArgSet* nset, const RooArgSet* iset, RooAbsCacheElement* obj, const TNamed* isetRangeName = 0); virtual voidShowMembers(TMemberInspector& insp); voidsterilize(); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; protected:. Int_t_lastIndexLast slot accessed; Int_t_maxSizeMaximum size; RooNormSetCache*_nsetCache! Normalization/Integration set manager; RooAbsCacheElement**_object! Payload; RooAbsArg*RooAbsCache::_ownerPointer to owning RooAbsArg; Int_t_sizeActual use. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void RooCacheManager<T> reset(); Clear the cache. void RooCacheManager<T> sterilize(); Clear the cache payload but retain slot mapping w.r.t to; normalization and integration sets. Int_t RooCacheManager<T> setObj(const RooArgSet* nset, const RooArgSet* iset, RooAbsCacheElement* obj, const TNamed* isetRangeName = 0); Insert payload object 'obj' in cache indexed on nset,iset and isetRangeName. T* RooCacheManager<T> getObj(const RooArgSet* nset, const RooArgSet* iset, Int_t* sterileIdx = 0, const TNamed* isetRangeName = 0); Retrieve payload object indexed on nset,uset amd isetRangeName; If sterileIdx is not null, it is set to the index of the sterile; slot in cacse such a slot is recycled. T* RooCacheManager<T> getObjByIndex(Int_t index) const; Retrieve payload object by slot index. const RooNameSet* RooCacheManager<T> nameSet1ByIndex(Int_t index) const; Retrieve RooNameSet associated with slot at given index. const RooNameSet* RooCacheManager<T> nameSet2ByIndex(Int_t index) const; Retrieve RooNameSe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooCacheManager_RooAbsCacheElement_.html:3249,cache,cache,3249,root/html528/RooCacheManager_RooAbsCacheElement_.html,https://root.cern,https://root.cern/root/html528/RooCacheManager_RooAbsCacheElement_.html,1,['cache'],['cache']
Performance,"ntIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMemberInspector& insp) const; RooAbsMoment*RooAbsReal::sigma(RooRealVar& obs); RooAbsMoment*RooAbsReal::sigma(RooRealVar& obs, const RooArgSet& nset); virtual Int_tTNamed::Sizeof() const; RooNumGenConfig*RooAbsPdf::specialGeneratorConfig() const; RooNumGenConfig*RooAbsPdf::specialGeneratorConfig(Bool_t createOnTheFly); RooNumIntConfig*RooAbsReal::specialIntegratorConfig() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig(Bool_t createOnTheFly); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); const map<string,string>&RooAbsArg::stringAttributes() const; RooAbsPdf*sumPdf(const RooArgSet* nset); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual Bool_tRooAbsPdf::traceEvalHook(Double_t value) const; Bool_tRooAbsPdf::traceEvalPdf(Double_t value) const; const set<string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); voiduseHorizontalMorphing(bool val); TIterator*RooAbsArg::valueClientIterator() const; RooFIterRooAbsArg::valueClientMIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); static intRooAbsPdf::verboseEval(); static voidRooAbsPdf::verboseEval(Int_t stat); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; voidRooAbsArg::wireAllCaches(); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidRooAbsReal::writeToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooMomentMorph.html:31720,cache,cache,31720,root/html602/RooMomentMorph.html,https://root.cern,https://root.cern/root/html602/RooMomentMorph.html,4,['cache'],['cache']
Performance,"ntLevel(-1), SumW2Error(false))};; fit2->Print();; disableBinIntegrator(expo);; ; // Power law example; // -----------------; ; // Let's not look at another example: a power law \f[x^a\f].; RooRealVar a{""a"", ""a"", -0.3, -5.0, 5.0};; RooPowerSum powerlaw{""powerlaw"", ""powerlaw"", x, RooConst(1.0), a};; std::unique_ptr<RooAbsData> powerlawData{generateBinnedAsimov(powerlaw, x, 10000)};; ; // Again, if you do a vanilla fit, you'll get a bias; std::unique_ptr<RooFitResult> fit3{powerlaw.fitTo(*powerlawData, Save(), PrintLevel(-1), SumW2Error(false))};; fit3->Print();; ; // This time, the bias is not the same factor in each bin! This means our; // trick by sampling the integral in the same way doesn't cancel out the; // bias completely. The average bias is canceled, but there are per-bin; // biases that remain. Still, this method has some value: it is cheaper than; // rigurously correcting the bias by integrating the pdf in each bin. So if; // you know your per-bin bias variations are small or performance is an; // issue, this approach can be sufficient.; enableBinIntegrator(powerlaw, x.numBins());; std::unique_ptr<RooFitResult> fit4{powerlaw.fitTo(*powerlawData, Save(), PrintLevel(-1), SumW2Error(false))};; fit4->Print();; disableBinIntegrator(powerlaw);; ; // To get rid of the binning effects in the general case, one can use the; // IntegrateBins() command argument. Now, the pdf is not evaluated at the; // bin centers, but numerically integrated over each bin and divided by the; // bin width. The parameter for IntegrateBins() is the required precision; // for the numeric integrals. This is computationally expensive, but the; // bias is now not a problem anymore.; std::unique_ptr<RooFitResult> fit5{; powerlaw.fitTo(*powerlawData, IntegrateBins(1e-3), Save(), PrintLevel(-1), SumW2Error(false))};; fit5->Print();; ; // Improving numerical stability; // -----------------------------; ; // There is one more problem with binned fits that is related to the binning; // effects beca",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf614__binned__fit__problems_8C.html:5004,perform,performance,5004,doc/master/rf614__binned__fit__problems_8C.html,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8C.html,1,['perform'],['performance']
Performance,ntListValue ; RooAICRegistryRooAbsAnaConvPdf::_codeReg! Registry of analytical integration codes; RooObjCacheManagerRooAbsAnaConvPdf::_coefNormMgrCoefficient normalization manager; RooArgSet*RooAbsAnaConvPdf::_convNormSet! Subset of last normalization that applies to convolutions; RooListProxyRooAbsAnaConvPdf::_convSetSet of (resModel (x) basisFunc) convolution objects; TIterator*RooAbsAnaConvPdf::_convSetIter! Iterator over _convNormSet; RooRealVar*RooAbsAnaConvPdf::_convVar! Convolution variable; RooRealProxy_delMistag; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooRealProxy_dm; RooRealProxy_effRatio; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; Double_t_genB0Frac; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsAnaConvPdf::_isCopy; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; RooResolutionModel*RooAbsAnaConvPdf::_model! Original resolution model; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; RooArgSet*,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooBCPEffDecay.html:38686,cache,cache,38686,root/html526/RooBCPEffDecay.html,https://root.cern,https://root.cern/root/html526/RooBCPEffDecay.html,1,['cache'],['cache']
Performance,ntListValue ; RooAICRegistryRooAbsAnaConvPdf::_codeReg! Registry of analytical integration codes; RooObjCacheManagerRooAbsAnaConvPdf::_coefNormMgrCoefficient normalization manager; RooArgSet*RooAbsAnaConvPdf::_convNormSet! Subset of last normalization that applies to convolutions; RooListProxyRooAbsAnaConvPdf::_convSetSet of (resModel (x) basisFunc) convolution objects; TIterator*RooAbsAnaConvPdf::_convSetIter! Iterator over _convNormSet; RooRealVar*RooAbsAnaConvPdf::_convVar! Convolution variable; RooRealProxy_delMistag; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooRealProxy_dm; RooRealProxy_effRatio; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; Double_t_genB0Frac; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsAnaConvPdf::_isCopy; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; RooResolutionModel*RooAbsAnaConvPdf::_model! Original resolution model; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRoo,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooBCPEffDecay.html:39260,cache,cache,39260,root/html528/RooBCPEffDecay.html,https://root.cern,https://root.cern/root/html528/RooBCPEffDecay.html,3,['cache'],['cache']
Performance,"ntMacroName() << std::endl;; std::cout << "" TCint::GetTopLevelMacroName() returns "" <<; TCint::GetTopLevelMacroName() << std::endl;; std::cout << "" Now calling inclfunc..."" << std::endl;; inclfunc();; }. Running mymacro.C will print:. root [0] .x mymacro.C; In mymacro.C; TCint::GetCurrentMacroName() returns ./mymacro.C; TCint::GetTopLevelMacroName() returns ./mymacro.C; Now calling inclfunc...; In inclfile.h; TCint::GetCurrentMacroName() returns inclfile.h; TCint::GetTopLevelMacroName() returns ./mymacro.C. const char * TypeName(const char* typeDesc); Return the absolute type of typeDesc.; E.g.: typeDesc = ""class TNamed**"", returns ""TNamed"".; You need to use the result immediately before it is being overwritten. Int_t LoadLibraryMap(const char* rootmapfile = 0); Load map between class and library. If rootmapfile is specified a; specific rootmap file can be added (typically used by ACLiC).; In case of error -1 is returned, 0 otherwise.; Cint uses this information to automatically load the shared library; for a class (autoload mechanism).; See also the AutoLoadCallback() method below. Int_t RescanLibraryMap(); Scan again along the dynamic path for library maps. Entries for the loaded; shared libraries are unloaded first. This can be useful after reseting; the dynamic path through TSystem::SetDynamicPath(); In case of error -1 is returned, 0 otherwise. Int_t ReloadAllSharedLibraryMaps(); Reload the library map entries coming from all the loaded shared libraries,; after first unloading the current ones.; In case of error -1 is returned, 0 otherwise. Int_t UnloadAllSharedLibraryMaps(); Unload the library map entries coming from all the loaded shared libraries.; Returns 0 if succesful. Int_t UnloadLibraryMap(const char* library); Unload library map entries coming from the specified library.; Returns -1 in case no entries for the specified library were found,; 0 otherwise. Int_t AutoLoad(const char* classname); Load library containing the specified class. Returns 0 in case",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TCint.html:27666,load,load,27666,root/html526/TCint.html,https://root.cern,https://root.cern/root/html526/TCint.html,5,['load'],['load']
Performance,"ntMacroName() << std::endl;; std::cout << "" TCint::GetTopLevelMacroName() returns "" <<; TCint::GetTopLevelMacroName() << std::endl;; std::cout << "" Now calling inclfunc..."" << std::endl;; inclfunc();; }. Running mymacro.C will print:. root [0] .x mymacro.C; In mymacro.C; TCint::GetCurrentMacroName() returns ./mymacro.C; TCint::GetTopLevelMacroName() returns ./mymacro.C; Now calling inclfunc...; In inclfile.h; TCint::GetCurrentMacroName() returns inclfile.h; TCint::GetTopLevelMacroName() returns ./mymacro.C. const char * TypeName(const char* typeDesc); Return the absolute type of typeDesc.; E.g.: typeDesc = ""class TNamed**"", returns ""TNamed"".; You need to use the result immediately before it is being overwritten. Int_t LoadLibraryMap(const char* rootmapfile = 0); Load map between class and library. If rootmapfile is specified a; specific rootmap file can be added (typically used by ACLiC).; In case of error -1 is returned, 0 otherwise.; Cint uses this information to automatically load the shared library; for a class (autoload mechanism).; See also the AutoLoadCallback() method below. Int_t RescanLibraryMap(); Scan again along the dynamic path for library maps. Entries for the loaded; shared libraries are unloaded first. This can be useful after reseting; the dynamic path through TSystem::SetDynamicPath(); In case of error -1 is returned, 0 otherwise. Int_t ReloadAllSharedLibraryMaps(); Reload the library map entries coming from all the loaded shared libraries,; after first unloading the current ones.; In case of error -1 is returned, 0 otherwise. Int_t UnloadAllSharedLibraryMaps(); Unload the library map entries coming from all the loaded shared libraries.; Returns 0 if successful. Int_t UnloadLibraryMap(const char* library); Unload library map entries coming from the specified library.; Returns -1 in case no entries for the specified library were found,; 0 otherwise. Int_t SetClassSharedLibs(const char* cls, const char* libs); Register the autoloading information fo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TCint.html:29183,load,load,29183,root/html534/TCint.html,https://root.cern,https://root.cern/root/html534/TCint.html,2,['load'],['load']
Performance,"ntTree(ostream& os, TString indent = """") const; Print object tree structure. void printAttribList(ostream& os) const; Print the attribute list. void attachDataSet(const RooAbsData& set); Replace server nodes with names matching the dataset variable names; with those data set variables, making this PDF directly dependent on the dataset. void attachDataStore(const RooAbsDataStore& set); Replace server nodes with names matching the dataset variable names; with those data set variables, making this PDF directly dependent on the dataset. Int_t Compare(const TObject* other) const; Utility function used by TCollection::Sort to compare contained TObjects; We implement comparison by name, resulting in alphabetical sorting by object name. void printDirty(Bool_t depth = kTRUE) const; Print information about current value dirty state information.; If depth flag is true, information is recursively printed for; all nodes in this arg tree. void optimizeCacheMode(const RooArgSet& observables); Activate cache mode optimization with given definition of observables.; The cache operation mode of all objects in the expression tree will; modified such that all nodes that depend directly or indirectly on; any of the listed observables will be set to ADirty, as they are; expected to change every time. This save change tracking overhead for; nodes that are a priori known to change every time. void optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Activate cache mode optimization with given definition of observables.; The cache operation mode of all objects in the expression tree will; modified such that all nodes that depend directly or indirectly on; any of the listed observables will be set to ADirty, as they are; expected to change every time. This save change tracking overhead for; nodes that are a priori known to change every time. Bool_t findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Find branch nodes with all-c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsArg.html:29197,optimiz,optimizeCacheMode,29197,root/html526/RooAbsArg.html,https://root.cern,https://root.cern/root/html526/RooAbsArg.html,30,"['cache', 'optimiz']","['cache', 'optimization', 'optimizeCacheMode']"
Performance,"ntVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar etaval). Change Eta - CylindricalEta3D coordinates only. { fCoordinates.SetEta(etaval); return *this;}. Scalar Dot( const DisplacementVector3D<OtherCoords,Tag> & v); ------ Operations combining two vectors ------; -- need to have the specialized version in order to avoid. Return the scalar (dot) product of two displacement vectors.; It is possible to perform the product for any type of vector coordinates,; 	 but they must have the same coordinate system tag. Scalar Dot( const OtherVector & v). Return the scalar (dot) product of two vectors.; It is possible to perform the product for any classes; implementing x(), y() and z() member functions. DisplacementVector3D Cross( const DisplacementVector3D<OtherCoords,Tag> & v). Return vector (cross) product of two displacement vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any type of vector coordinates,; 	 but they must have the same coordinate system tag. DisplacementVector3D Cross( const OtherVector & v). Return vector (cross) product of two vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any classes; implementing X(), Y() and Z() member functions. DisplacementVector3D & operator*=(ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a). multiply this vector by a scalar quantity. DisplacementVector3D & operator/=(ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a). divide this vector by a scalar quantity. return operator*( Scalar(-1) ). DisplacementVector3D operator/(ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a) const. Division of a vector with a real number. Scalar x() const; Methods providing limited backward",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_double__-p1DefaultCoordinateSystemTag_.html:23192,perform,perform,23192,root/html528/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_double__-p1DefaultCoordinateSystemTag_.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_double__-p1DefaultCoordinateSystemTag_.html,4,['perform'],['perform']
Performance,"ntVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar etaval). Change Eta - CylindricalEta3D coordinates only. { fCoordinates.SetEta(etaval); return *this;}. Scalar Dot( const DisplacementVector3D<OtherCoords,Tag> & v); ------ Operations combining two vectors ------; -- need to have the specialized version in order to avoid. Return the scalar (dot) product of two displacement vectors.; It is possible to perform the product for any type of vector coordinates,; 	 but they must have the same coordinate system tag. Scalar Dot( const OtherVector & v). Return the scalar (dot) product of two vectors.; It is possible to perform the product for any classes; implementing x(), y() and z() member functions. DisplacementVector3D Cross( const DisplacementVector3D<OtherCoords,Tag> & v). Return vector (cross) product of two displacement vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any type of vector coordinates,; 	 but they must have the same coordinate system tag. DisplacementVector3D Cross( const OtherVector & v). Return vector (cross) product of two vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any classes; implementing X(), Y() and Z() member functions. DisplacementVector3D & operator*=(ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a). multiply this vector by a scalar quantity. DisplacementVector3D & operator/=(ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a). divide this vector by a scalar quantity. return operator*(ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a) const. DisplacementVector3D operator/(ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_double__-p1DefaultCoordinateSystemTag_.html:23192,perform,perform,23192,root/html526/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_double__-p1DefaultCoordinateSystemTag_.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_double__-p1DefaultCoordinateSystemTag_.html,1,['perform'],['perform']
Performance,"nt_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag); 1973{; 1974 Double_t cu,fu,fobs,fsub;; 1975 Double_t dersum[100];; 1976 Double_t x[3];; 1977 Int_t icu;; 1978 ; 1979 TH1 *hfit = (TH1*)GetObjectFit();; 1980 TF1 *f1 = (TF1*)GetUserFunc();; 1981 Int_t nd = hfit->GetDimension();; 1982 Int_t j;; 1983 Double_t *zik = GetZ();; 1984 Double_t *pl0 = GetPL0();; 1985 ; 1986 Double_t *df=new Double_t[npar];; 1987 ; 1988 npar = f1->GetNpar();; 1989 SetParNumber(npar);; 1990 if(flag == 9) {delete [] df; return;}; 1991 if (flag == 2) for (j=0;j<npar;j++) dersum[j] = gin[j] = 0;; 1992 f1->InitArgs(x,u);; 1993 f = 0;; 1994 ; 1995 Int_t npfit = 0;; 1996 Double_t *cache = fCache;; 1997 for (Int_t i=0;i<fNpoints;i++) {; 1998 if (nd > 2) x[2] = cache[4];; 1999 if (nd > 1) x[1] = cache[3];; 2000 x[0] = cache[2];; 2001 cu = cache[0];; 2002 TF1::RejectPoint(kFALSE);; 2003 if (nd < 2) {; 2004 fu = f1->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3])/cache[3];; 2005 } else if (nd < 3) {; 2006 fu = ((TF2*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5])/(cache[3]*cache[5]);; 2007 } else {; 2008 fu = ((TF3*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5],cache[6] - 0.5*cache[7],cache[6] + 0.5*cache[7])/(cache[3]*cache[5]*cache[7]);; 2009 }; 2010 if (TF1::RejectedPoint()) {cache += fPointSize; continue;}; 2011 if (flag == 2) {; 2012 for (j=0;j<npar;j++) {; 2013 dersum[j] += 1; //should be the derivative; 2014 //grad[j] += dersum[j]*(fu-cu)/eu; dersum[j] = 0;; 2015 }; 2016 }; 2017 if (fu < 1.e-9) fu = 1.e-9;; 2018 icu = Int_t(cu);; 2019 fsub = -fu +icu*TMath::Log(fu);; 2020 fobs = GetSumLog(icu);; 2021 fsub -= fobs;; 2022 Derivatives(df,x);; 2023 int n=0;; 2024 // Here we need gradients of Log likelihood function; 2025 //; 2026 for (j=0;j<npar;j++) {; 2027 if (pl0[j]>0){; 2028 df[n] = df[j]*(icu/fu-1);; 2029 gin[j] -= df[n];; 2030 n++;; 2031 }; 203",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFumili_8cxx_source.html:58086,cache,cache,58086,doc/master/TFumili_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html,3,['cache'],['cache']
Performance,"nt_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t bytesDefinition TGWin32VirtualXProxy.cxx:245. if option = ""a"" the list of blocks in the cache is printed see also class TTreePerfStats.; if option contains 'cachedbranches', the list of branches being cached is printed. . Reimplemented from TFileCacheRead.; Reimplemented in TTreeCacheUnzip.; Definition at line 1899 of file TTreeCache.cxx. ◆ ProcessMiss(). bool TTreeCache::ProcessMiss ; (; Long64_t ; pos, . int ; len . ). private . ! Given a file read not in the miss cache, handle (possibly) loading the data. ; Process a cache miss; (pos, len) isn't in the buffer.; The first time we have a miss, we buffer as many baskets we can (up to the maximum size of the TTreeCache) in memory from all branches that are not in the prefetch list.; Subsequent times, we fetch all the buffers corresponding to branches that had previously seen misses. If it turns out the (pos, len) isn't in the list of branches, we treat this as if it was the first miss.; Returns true if we were able to pull the data into the miss cache. ; Definition at line 863 of file TTreeCache.cxx. ◆ ReadBuffer(). Int_t TTreeCache::ReadBuffer ; (; char * ; buf, . Long64_t ; pos, . Int_t ; len . ). overridevirtual . Read buffer at position pos if the request is in the list of prefetched blocks read from fBuffer. ; Otherwise try to fill the cache from the list of selected branches, and recheck if pos is now in the list. Returns:; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache. This function overloads TFileCacheRead::ReadBuffer. . Reim",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCache.html:45873,cache,cache,45873,doc/v632/classTTreeCache.html,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html,2,['cache'],['cache']
Performance,"nt_t buffsize=16000)TTreevirtual; SetBit(UInt_t f, Bool_t set)TObject; SetBit(UInt_t f)TObjectinline; SetBranchAddress(const char *bname, void *add, TBranch **ptr=nullptr)TTreevirtual; SetBranchAddress(const char *bname, void *add, TClass *realClass, EDataType datatype, bool isptr)TTreevirtual; SetBranchAddress(const char *bname, void *add, TBranch **ptr, TClass *realClass, EDataType datatype, bool isptr)TTreevirtual; SetBranchAddress(const char *bname, T **add, TBranch **ptr=nullptr)TTreeinline; SetBranchAddress(const char *bname, T *add, TBranch **ptr=nullptr)TTreeinline; SetBranchAddressImp(TBranch *branch, void *addr, TBranch **ptr)TTreeprotected; SetBranchStatus(const char *bname, bool status=true, UInt_t *found=nullptr)TTreevirtual; SetBranchStyle(Int_t style=1)TTreestatic; SetCacheEntryRange(Long64_t first, Long64_t last)TTreevirtual; SetCacheLearnEntries(Int_t n=10)TTreevirtual; SetCacheSize(Long64_t cachesize=-1)TTreevirtual; SetCacheSizeAux(bool autocache=true, Long64_t cacheSize=0)TTreeprotected; SetChainOffset(Long64_t offset=0)TTreeinlinevirtual; SetCircular(Long64_t maxEntries)TTreevirtual; SetClusterPrefetch(bool enabled)TTreeinlinevirtual; SetDebug(Int_t level=1, Long64_t min=0, Long64_t max=9999999)TTreevirtual; SetDefaultEntryOffsetLen(Int_t newdefault, bool updateExisting=false)TTreevirtual; SetDirectory(TDirectory *dir)TTreevirtual; SetDrawOption(Option_t *option="""")TObjectvirtual; SetDtorOnly(void *obj)TObjectstatic; SetEntries(Long64_t n=-1)TTreevirtual; SetEntryList(TEntryList *list, Option_t *opt="""")TTreevirtual; SetEstimate(Long64_t nentries=1000000)TTreevirtual; SetEventList(TEventList *list)TTreevirtual; SetFileNumber(Int_t number=0)TTreevirtual; SetFillAttributes()TAttFillvirtual; SetFillColor(Color_t fcolor)TAttFillinlinevirtual; SetFillColorAlpha(Color_t fcolor, Float_t falpha)TAttFillvirtual; SetFillStyle(Style_t fstyle)TAttFillinlinevirtual; SetImplicitMT(bool enabled)TTreeinlinevirtual; SetIOFeatures(const ROOT::TIOFeatures &)TTree; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTNtuple-members.html:21799,cache,cacheSize,21799,doc/master/classTNtuple-members.html,https://root.cern,https://root.cern/doc/master/classTNtuple-members.html,2,['cache'],['cacheSize']
Performance,"nt_t bufsize = 0) const; virtual voidwriteToStream(ostream& os, Bool_t compact) const. protected:. voidRooAbsArg::attachToStore(RooAbsDataStore& store); virtual voidattachToTree(TTree& t, Int_t bufSize = 32000); virtual voidattachToVStore(RooVectorDataStore&); TStringRooAbsArg::cleanBranchName() const; virtual voidcopyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE, Bool_t setValDiry = kTRUE); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual TStringevaluate() const; virtual voidfillTreeBranch(TTree& t); virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; voidRooAbsArg::graphVizAddConnections(set<pair<RooAbsArg*,RooAbsArg*> >&); Bool_tRooAbsArg::inhibitDirty() const; virtual Bool_tisValid() const; virtual Bool_tisValidString(const char*, Bool_t printError = kFALSE) const; voidTObject::MakeZombie(); Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); voidRooAbsArg::printAttribList(ostream& os) const; voidRooAbsArg::registerProxy(RooArgProxy& proxy); voidRooAbsArg::registerProxy(RooSetProxy& proxy); voidRooAbsArg::registerProxy(RooListProxy& proxy); voidRooAbsArg::setProxyNormSet(const RooArgSet* nset); voidRooAbsArg::setShapeDirty(const RooAbsArg* source) const; virtual voidsetTreeBranchStatus(TTree& t, Bool_t active); voidRooAbsArg::setValueDirty(const RooAbsArg* source) const; virtual voidsyncCache(const RooArgSet* nset = 0); const char*traceEval() const; virtual Bool_ttraceEvalHook(const char* value) const; voidRooAbsArg::unRegisterProxy(RooArgProxy& proxy); voidRooAbsArg::unRegisterProxy(RooSetProxy& proxy); voidRooAbsArg::unRegisterProxy(RooListProxy& proxy). Data Members; public:. static RooAbsArg::OperModeRooAbsArg::AClean; static RooAbsArg::OperModeRoo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsString.html:17114,optimiz,optimizeDirtyHook,17114,root/html602/RooAbsString.html,https://root.cern,https://root.cern/root/html602/RooAbsString.html,4,['optimiz'],['optimizeDirtyHook']
Performance,"nt_t cachesize = 10000000; //10 MBytes; T->SetCacheSize(cachesize); //<<<; T->SetCacheLearnEntries(5); //<<< we can take the decision after 5 entries; TBranch *b1 = T->GetBranch(""branch1"");; TBranch *b2 = T->GetBranch(""branch2"");; for (Long64_t i=0;i<nentries;i++) {; T->LoadTree(i);; b1->GetEntry(i);; if (some condition not met) continue;; b2->GetEntry(i);; //at this point we may call a user function where a few more branches; //will be read conditionally. These branches will be put in the cache; //if they have been used in the first 10 entries; if (some condition not met) continue;; //here we read the full event only in some rare cases.; //there is no point in caching the other branches as it might be; //more economical to read only the branch buffers really used.; T->GetEntry(i);; .. process the rare but interesting cases.; ... here you process your entry; }; --. SPECIAL CASES WHERE TreeCache should not be activated. When reading only a small fraction of all entries such that not all branch; buffers are read, it might be faster to run without a cache. HOW TO VERIFY That the TreeCache has been used and check its performance. Once your analysis loop has terminated, you can access/print the number; of effective system reads for a given file with a code like; (where TFile* f is a pointer to your file). printf(""Reading %lld bytes in %d transactions\n"",f->GetBytesRead(), f->GetReadCalls());. Function Members (Methods); public:. TTreeCache(); TTreeCache(TTree* tree, Int_t buffersize = 0); virtual~TTreeCache(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddBranch(TBranch* b, Bool_t subbranches = kFALSE); virtual voidAddBranch(const char* branch, Bool_t subbranches = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreeCache.html:8639,cache,cache,8639,root/html528/TTreeCache.html,https://root.cern,https://root.cern/root/html528/TTreeCache.html,4,['cache'],['cache']
Performance,"nt_t cachesize = 10000000; //10 MBytes; T->SetCacheSize(cachesize); //<<<; T->SetCacheLearnEntries(5); //<<< we can take the decision after 5 entries; TBranch *b1 = T->GetBranch(""branch1"");; TBranch *b2 = T->GetBranch(""branch2"");; for (Long64_t i=0;i<nentries;i++) {; T->LoadTree(i);; b1->GetEntry(i);; if (some condition not met) continue;; b2->GetEntry(i);; //at this point we may call a user function where a few more branches; //will be read conditionally. These branches will be put in the cache; //if they have been used in the first 10 entries; if (some condition not met) continue;; //here we read the full event only in some rare cases.; //there is no point in caching the other branches as it might be; //more economical to read only the branch buffers really used.; T->GetEntry(i);; .. process the rare but interesting cases.; ... here you process your entry; }; --. SPECIAL CASES WHERE TreeCache should not be activated. When reading only a small fraction of all entries such that not all branch; buffers are read, it might be faster to run without a cache. HOW TO VERIFY That the TreeCache has been used and check its performance. Once your analysis loop has terminated, you can access/print the number; of effective system reads for a given file with a code like; (where TFile* f is a pointer to your file). printf(""Reading %lld bytes in %d transactions\n"",f->GetBytesRead(), f->GetReadCalls());. Function Members (Methods); public:. TTreeCache(); TTreeCache(TTree* tree, Int_t buffersize = 0); virtual~TTreeCache(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddBranch(TBranch* b, Bool_t subgbranches = kFALSE); virtual voidAddBranch(const char* branch, Bool_t subbranches = kFALSE); virtual voidTFileCacheRead::AddNoCacheBytesRead(Long64_t len); virtual voidTFileCacheRead::AddNoCacheReadCalls(Int_t reads); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::Class",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTreeCache.html:8867,cache,cache,8867,root/html534/TTreeCache.html,https://root.cern,https://root.cern/root/html534/TTreeCache.html,2,['cache'],['cache']
Performance,"nt_t cachesize = 10000000; //10 MBytes; T->SetCacheSize(cachesize); //<<<; T->SetCacheLearnEntries(5); //<<< we can take the decision after 5 entries; TBranch *b1 = T->GetBranch(""branch1"");; TBranch *b2 = T->GetBranch(""branch2"");; for (Long64_t i=0;i<nentries;i++) {; T->LoadTree(i);; b1->GetEntry(i);; if (some condition not met) continue;; b2->GetEntry(i);; //at this point we may call a user function where a few more branches; //will be read conditionally. These branches will be put in the cache; //if they have been used in the first 10 entries; if (some condition not met) continue;; //here we read the full event only in some rare cases.; //there is no point in caching the other branches as it might be; //more economical to read only the branch buffers really used.; T->GetEntry(i);; .. process the rare but interesting cases.; ... here you process your entry; }; --. SPECIAL CASES WHERE TreeCache should not be activated. When reading only a small fraction of all entries such that not all branch; buffers are read, it might be faster to run without a cache. HOW TO VERIFY That the TreeCache has been used and check its performance. Once your analysis loop has terminated, you can access/print the number; of effective system reads for a given file with a code like; (where TFile* f is a pointer to your file). printf(""Reading %lld bytes in %d transactions\n"",f->GetBytesRead(), f->GetReadCalls());. Function Members (Methods); public:. virtual~TTreeCache(); voidTObject::AbstractMethod(const char* method) const; virtual Int_tAddBranch(TBranch* b, Bool_t subgbranches = kFALSE); virtual Int_tAddBranch(const char* branch, Bool_t subbranches = kFALSE); virtual voidTFileCacheRead::AddNoCacheBytesRead(Long64_t len); virtual voidTFileCacheRead::AddNoCacheReadCalls(Int_t reads); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TTreeCache.html:8944,cache,cache,8944,root/html604/TTreeCache.html,https://root.cern,https://root.cern/root/html604/TTreeCache.html,2,['cache'],['cache']
Performance,"nt_t cachesize = 10000000; //10 MBytes; T->SetCacheSize(cachesize); //<<<; T->SetCacheLearnEntries(5); //<<< we can take the decision after 5 entries; TBranch *b1 = T->GetBranch(""branch1"");; TBranch *b2 = T->GetBranch(""branch2"");; for (Long64_t i=0;i<nentries;i++) {; T->LoadTree(i);; b1->GetEntry(i);; if (some condition not met) continue;; b2->GetEntry(i);; //at this point we may call a user function where a few more branches; //will be read conditionally. These branches will be put in the cache; //if they have been used in the first 10 entries; if (some condition not met) continue;; //here we read the full event only in some rare cases.; //there is no point in caching the other branches as it might be; //more economical to read only the branch buffers really used.; T->GetEntry(i);; .. process the rare but interesting cases.; ... here you process your entry; }; --. SPECIAL CASES WHERE TreeCache should not be activated. When reading only a small fraction of all entries such that not all branch; buffers are read, it might be faster to run without a cache. HOW TO VERIFY That the TreeCache has been used and check its performance. Once your analysis loop has terminated, you can access/print the number; of effective system reads for a given file with a code like; (where TFile* f is a pointer to your file). printf(""Reading %lld bytes in %d transactions\n"",f->GetBytesRead(), f->GetReadCalls());. Function Members (Methods); public:. virtual~TTreeCache(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddBranch(TBranch* b, Bool_t subgbranches = kFALSE); virtual voidAddBranch(const char* branch, Bool_t subbranches = kFALSE); virtual voidTFileCacheRead::AddNoCacheBytesRead(Long64_t len); virtual voidTFileCacheRead::AddNoCacheReadCalls(Int_t reads); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); vir",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTreeCache.html:8891,cache,cache,8891,root/html602/TTreeCache.html,https://root.cern,https://root.cern/root/html602/TTreeCache.html,2,['cache'],['cache']
Performance,"nt_t depbuilt = !gSystem->Exec(touch);; 2695 if (depbuilt) depbuilt = !gSystem->Exec(builddep);; 2696 if (depbuilt) depbuilt = !gSystem->Exec(adddictdep);; 2697 if (depbuilt) depbuilt = !gSystem->Exec(addversiondep);; 2698 ; 2699 if (!depbuilt) {; 2700 ::Warning(""ACLiC"",""Failed to generate the dependency file for %s"",; 2701 library.Data());; 2702 } else {; 2703#ifdef WIN32; 2704 gSystem->Unlink(stderrfile);; 2705#endif; 2706 gSystem->Unlink(bakdepfilename);; 2707 }; 2708}; 2709 ; 2710////////////////////////////////////////////////////////////////////////////////; 2711/// This method compiles and loads a shared library containing; 2712/// the code from the file ""filename"".; 2713///; 2714/// The return value is true (1) in case of success and false (0); 2715/// in case of error.; 2716///; 2717/// The possible options are:; 2718/// - k : keep the shared library after the session end.; 2719/// - f : force recompilation.; 2720/// - g : compile with debug symbol; 2721/// - O : optimized the code; 2722/// - c : compile only, do not attempt to load the library.; 2723/// - s : silence all informational output; 2724/// - v : output all information output; 2725/// - d : debug ACLiC, keep all the output files.; 2726/// - - : if buildir is set, use a flat structure (see buildir below); 2727///; 2728/// If library_specified is specified, CompileMacro generates the file; 2729/// ""library_specified"".soext where soext is the shared library extension for; 2730/// the current platform.; 2731///; 2732/// If build_dir is specified, it is used as an alternative 'root' for the; 2733/// generation of the shared library. The library is stored in a sub-directories; 2734/// of 'build_dir' including the full pathname of the script unless a flat; 2735/// directory structure is requested ('-' option). With the '-' option the libraries; 2736/// are created directly in the directory 'build_dir'; in particular this means that; 2737/// 2 scripts with the same name in different source directory will",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8cxx_source.html:87969,optimiz,optimized,87969,doc/master/TSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html,2,"['load', 'optimiz']","['load', 'optimized']"
Performance,"nt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; const char*TApplication::WorkingDirectory() const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. static Int_tTQObject::CheckConnectArgs(TQObject* sender, TClass* sender_class, const char* signal, TClass* receiver_class, const char* slot); static voidTApplication::Close(TApplication* app); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual void*TQObject::GetSender(); virtual const char*TQObject::GetSenderClassName() const; virtual voidTApplication::Help(const char* line); virtual voidTApplication::LoadGraphicsLibs(); virtual voidTApplication::MakeBatch(); voidTObject::MakeZombie(); static TApplication*TApplication::Open(const char* url, Int_t debug, const char* script); static Int_tTApplication::ParseRemoteLine(const char* ln, TString& hostdir, TString& user, Int_t& dbg, TString& script); virtual Long_tTApplication::ProcessRemote(const char* line, Int_t* error = 0); voidTApplication::SetSignalHandler(TSignalHandler* sh). private:. Int_tBroadcast(const TMessage& mess); Int_tBroadcast(Int_t kind, Int_t type = kRRT_Undef); Int_tBroadcast(const char* mess, Int_t kind = kMESS_STRING, Int_t type = kRRT_Undef); Int_tBroadcastObject(const TObject* obj, Int_t kind = kMESS_OBJECT); Int_tBroadcastRaw(const void* buffer, Int_t length); Bool_tCheckFile(const char* file, Long_t modtime); Int_tCollect(Long_t timeout = -1); Int_tCollectInput()",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TApplicationRemote.html:11090,Load,LoadGraphicsLibs,11090,root/html532/TApplicationRemote.html,https://root.cern,https://root.cern/root/html532/TApplicationRemote.html,2,['Load'],['LoadGraphicsLibs']
Performance,"nt_t fNProcessIDsNumber of TProcessID written to this file.Definition TFile.h:88; TFile::fWrittenInt_t fWrittenNumber of objects written so far.Definition TFile.h:87; TFile::GetRecordHeaderInt_t GetRecordHeader(char *buf, Long64_t first, Int_t maxbytes, Int_t &nbytes, Int_t &objlen, Int_t &keylen)Read the logical record header starting at a certain postion.Definition TFile.cxx:1301; TFile::ReadBuffervirtual Bool_t ReadBuffer(char *buf, Int_t len)Read a buffer from the file.Definition TFile.cxx:1770; TFile::GetCompressionFactorFloat_t GetCompressionFactor()Return the file compression factor.Definition TFile.cxx:1202; TFile::SysWritevirtual Int_t SysWrite(Int_t fd, const void *buf, Int_t len)Interface to system write. All arguments like in POSIX write().Definition TFile.cxx:4514; TFile::GetFileReadCallsstatic Int_t GetFileReadCalls()Static function returning the total number of read calls from all files.Definition TFile.cxx:4591; TFile::GetCacheReadTFileCacheRead * GetCacheRead(const TObject *tree=nullptr) constReturn a pointer to the current read cache.Definition TFile.cxx:1262; TFile::GetOptionOption_t * GetOption() const overrideDefinition TFile.h:240; TFile::fgAsyncOpenRequestsstatic TList * fgAsyncOpenRequestsDefinition TFile.h:122; TFreeService class for TFile.Definition TFree.h:27; TFree::GetLastLong64_t GetLast() constDefinition TFree.h:41; TFree::SizeofInt_t Sizeof() constreturn number of bytes occupied by this TFree on permanent storageDefinition TFree.cxx:184; TFree::ReadBuffervirtual void ReadBuffer(char *&buffer)Decode one free structure from input buffer.Definition TFree.cxx:167; TFree::GetFirstLong64_t GetFirst() constDefinition TFree.h:40; TFree::FillBuffervirtual void FillBuffer(char *&buffer)Encode fre structure into output buffer.Definition TFree.cxx:109; TFree::AddFreeTFree * AddFree(TList *lfree, Long64_t first, Long64_t last)Add a new free segment to the list of free segments.Definition TFree.cxx:67; TGlobalMappedFunction::MakeFunctorstatic void ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:231274,cache,cache,231274,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,1,['cache'],['cache']
Performance,"nt_t fNProcessIDsNumber of TProcessID written to this file.Definition TFile.h:88; TFile::fWrittenInt_t fWrittenNumber of objects written so far.Definition TFile.h:87; TFile::GetRecordHeaderInt_t GetRecordHeader(char *buf, Long64_t first, Int_t maxbytes, Int_t &nbytes, Int_t &objlen, Int_t &keylen)Read the logical record header starting at a certain postion.Definition TFile.cxx:1301; TFile::ReadBuffervirtual Bool_t ReadBuffer(char *buf, Int_t len)Read a buffer from the file.Definition TFile.cxx:1770; TFile::GetCompressionFactorFloat_t GetCompressionFactor()Return the file compression factor.Definition TFile.cxx:1202; TFile::SysWritevirtual Int_t SysWrite(Int_t fd, const void *buf, Int_t len)Interface to system write. All arguments like in POSIX write().Definition TFile.cxx:4514; TFile::GetFileReadCallsstatic Int_t GetFileReadCalls()Static function returning the total number of read calls from all files.Definition TFile.cxx:4591; TFile::GetCacheReadTFileCacheRead * GetCacheRead(const TObject *tree=nullptr) constReturn a pointer to the current read cache.Definition TFile.cxx:1262; TFile::GetOptionOption_t * GetOption() const overrideDefinition TFile.h:240; TFile::fgAsyncOpenRequestsstatic TList * fgAsyncOpenRequestsDefinition TFile.h:122; TFreeService class for TFile.Definition TFree.h:27; TKeyBook space in a file, create I/O buffers, to fill them, (un)compress them.Definition TKey.h:28; TListA doubly linked list.Definition TList.h:38; TMapTMap implements an associative array of (key,value) pairs using a THashTable for efficient retrieval ...Definition TMap.h:40; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::MayNotUsevoid MayNotUse(const char *method) constUse this method to signal that a method (defined in a base",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8h_source.html:49565,cache,cache,49565,doc/master/TFile_8h_source.html,https://root.cern,https://root.cern/doc/master/TFile_8h_source.html,1,['cache'],['cache']
Performance,"nt_t fgAscentstring ascent, used to compute Y alignmentDefinition TTF.h:75; TTF::fgWidthstatic Int_t fgWidthstring width, used to compute X alignmentDefinition TTF.h:92; TTF::fgInitstatic Bool_t fgInittrue if the Init has been calledDefinition TTF.h:85; TTF::fgCurFontIdxstatic Int_t fgCurFontIdxcurrent font indexDefinition TTF.h:78; TTF::fgSymbItaFontIdxstatic Int_t fgSymbItaFontIdxSymbol italic font index.Definition TTF.h:79; TTF::Cleanupstatic void Cleanup()Cleanup. Is called by the gCleanupTTF destructor.Definition TTF.cxx:82; TTF::ComputeTrailingBlanksWidthstatic void ComputeTrailingBlanksWidth(Int_t n)Compute the trailing blanks width.Definition TTF.cxx:133; TTF::~TTFvirtual ~TTF()Cleanup TTF environment.Definition TTF.cxx:57; TTF::GetWidthstatic Int_t GetWidth()Definition TTF.cxx:622; TTF::GetBoxstatic const FT_BBox & GetBox()Definition TTF.cxx:657; TTF::fgFontNamestatic char * fgFontName[kTTMaxFonts]font nameDefinition TTF.h:81; TTF::fgLibrarystatic FT_Library fgLibraryFreeType font library.Definition TTF.h:87; TTF::fgNumGlyphsstatic Int_t fgNumGlyphsnumber of glyphs in the stringDefinition TTF.h:88; TTF::fgRotMatrixstatic FT_Matrix * fgRotMatrixrotation matrixDefinition TTF.h:89; TTF::fgKerningstatic Bool_t fgKerninguse kerning (true by default)Definition TTF.h:86; TTF::fgTBlankWstatic Int_t fgTBlankWtrailing blanks widthDefinition TTF.h:91; TTF::GetHintingstatic Bool_t GetHinting()Definition TTF.cxx:594; TTF::GetSmoothingstatic Bool_t GetSmoothing()Definition TTF.cxx:608; TTF::fgFontCountstatic Int_t fgFontCountnumber of fonts loadedDefinition TTF.h:80; TTF::GetRotMatrixstatic FT_Matrix * GetRotMatrix()Definition TTF.cxx:643; TTF::fgCBoxstatic FT_BBox fgCBoxstring control boxDefinition TTF.h:76; bool; int; unsigned int; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16. graf2dgrafincTTF.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:18 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTF_8h_source.html:10818,load,loadedDefinition,10818,doc/master/TTF_8h_source.html,https://root.cern,https://root.cern/doc/master/TTF_8h_source.html,1,['load'],['loadedDefinition']
Performance,"nt_t i = 0; i < ndim; ++i) {; 609 auto maxIndex = 0;; 610 if (isStdArray) maxIndex = maxIndices[i];; 611 else maxIndex = dm->GetMaxIndex(i);; 612 element->SetMaxIndex(i, maxIndex);; 613 }; 614 element->SetArrayDim(ndim);; 615 // If the datamember was a int[4] this is 4, if double[3][2] 3*2=6; 616 Int_t narr = element->GetArrayLength();; 617 if (!narr) {; 618 narr = 1;; 619 }; 620 element->SetSize(dsize*narr);; 621 element->SetStreamer(streamer);; 622 if (!streamer) {; 623 Int_t k = element->GetType();; 624 if (k == kStreamer) {; 625 // if ((k == kSTL) || (k == kSTL + kOffsetL) || (k == kStreamer) || (k == kStreamLoop)); 626 // This is odd. Either we need to update the doc for TVirtualStreamerInfo::kNoType; 627 // or change this value.; 628 element->SetType(TVirtualStreamerInfo::kNoType);; 629 }; 630 }; 631 ; 632 if ( !wasCompiled && (rules && rules.HasRuleWithSource( element->GetName(), kTRUE )) ) {; 633 needAllocClass = kTRUE;; 634 ; 635 // If this is optimized to re-use TStreamerElement(s) in case of variable renaming,; 636 // then we must revisit the code in TBranchElement::InitInfo that recalculate the; 637 // fID (i.e. the index of the TStreamerElement to be used for streaming).; 638 ; 639 TStreamerElement *cached = element;; 640 // Now that we are caching the unconverted element, we do not assign it to the real type even if we could have!; 641 if (element->GetNewType()>0 /* intentionally not including base class for now */; 642 && rules && !rules.HasRuleWithTarget( element->GetName(), kTRUE ) ); 643 {; 644 TStreamerElement *copy = (TStreamerElement*)element->Clone();; 645 fElements->Add(copy);; 646 copy->SetBit(TStreamerElement::kRepeat);; 647 cached = copy;; 648 ; 649 // Warning(""BuildOld"",""%s::%s is not set from the version %d of %s (You must add a rule for it)\n"",GetName(), element->GetName(), GetClassVersion(), GetName() );; 650 } else {; 651 // If the element is just cached and not repeat, we need to inject an element; 652 // to insure the writing.; 653 T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:22889,optimiz,optimized,22889,doc/master/TStreamerInfo_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html,1,['optimiz'],['optimized']
Performance,"nt_t len). Int_t ReadBufferPrefetch(char* buf, Long64_t pos, Int_t len). Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos if the request is in the list of; prefetched blocks read from fBuffer.; Otherwise try to fill the cache from the list of selected branches,; and recheck if pos is now in the list.; Returns; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache.; This function overloads TFileCacheRead::ReadBuffer. void ResetCache(); This will simply clear the cache. Int_t SetBufferSize(Int_t buffersize); Change the underlying buffer size of the cache.; If the change of size means some cache content is lost, or if the buffer; is now larger, setup for a cache refill the next time there is a read; Returns 0 if the buffer content is still available; 1 if some or all of the buffer content has been made unavailable; -1 on error. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void SetFile(TFile* file, TFile::ECacheAction action = TFile::kDisconnect); Overload to make sure that the object specific. void SetLearnEntries(Int_t n = 10); Static function to set the number of entries to be used in learning mode; The default value for n is 10. n must be >= 1. void SetLearnPrefill(TTreeCache::EPrefillType type = kNoPrefill); Set whether the learning period is started with a prefilling of the; cache and which type of prefilling is used.; The two value currently supported are:; TTreeCache::kNoPrefill disable the prefilling; TTreeCache::kAllBranches fill the cache with baskets from all branches.; The default prefilling behavior can be controlled by setting; TTreeCache.Prefill or the environment variable ROOT_TTREECACHE_PREFILL. void StartLearningPhase(); The name should be enough to explain the method.; The only additional comments is that the cache is cleaned befo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TTreeCache.html:26257,optimiz,optimize,26257,root/html604/TTreeCache.html,https://root.cern,https://root.cern/root/html604/TTreeCache.html,2,['optimiz'],['optimize']
Performance,"nt_t maxSize = 10, Bool_t clearCacheOnServerRedirect = kTRUE); Constructor of object cache manager for given owner. If clearCacheOnServerRedirect is true; all cache elements will be cleared when a server redirect is intercepted by the cache manager.; This is the default strategy and should only be overridden when you really understand; what you're doing as properly implementing server redirect in cache elements can get very; complicated, especially if there are (cyclical) reference back to the owning object. RooObjCacheManager(const RooObjCacheManager& other, RooAbsArg* owner = 0); Copy constructor. ~RooObjCacheManager(); Destructor. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Intercept server redirect calls. If clearOnRedirect was set, sterilize; the cache (i.e. keep the structure but delete all contents). If not; forward serverRedirect to cache elements. void operModeHook(); Intercept changes to cache operation mode and forward to cache elements. void optimizeCacheMode(const RooArgSet& , RooArgSet& , RooLinkedList& ); Intercept calls to perform automatic optimization of cache mode operation.; Forward calls to existing cache elements and save configuration of; cache mode optimization so that it can be applied on new cache elements; upon insertion. void insertObjectHook(RooAbsCacheElement& ); Set owner link on all object inserted into cache.; Also if cache mode optimization was requested, apply; it now to cache element being inserted. void printCompactTreeHook(ostream& , const char* ); Add details on cache contents when printing in tree mode. void findConstantNodes(const RooArgSet& , RooArgSet& , RooLinkedList& ); If clearOnRedirect is false, forward constant term optimization calls to; cache elements. » Last changed: Mon Dec 7 13:48:35 2009 » Last generated: 2009-12-07 13:48; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooObjCacheManager.html:4610,optimiz,optimizeCacheMode,4610,root/html526/RooObjCacheManager.html,https://root.cern,https://root.cern/root/html526/RooObjCacheManager.html,15,"['cache', 'optimiz', 'perform']","['cache', 'optimization', 'optimizeCacheMode', 'perform']"
Performance,"nt_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. TGeoNodeCache(const TGeoNodeCache&); TGeoNodeCache&operator=(const TGeoNodeCache&). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. Int_tfCurrentIDunique ID of current node; Int_tfGeoCacheMaxLevelsmaximum supported number of levels; Int_tfGeoCacheStackSizemaximum size of the stack; Int_tfGeoInfoStackSizemaximum size of the stack of info states; Int_tfIdBranch[100]current branch of indices; Int_tfIndexindex in array of ID's; TGeoStateInfo**fInfoBranchcurrent branch of nodes; Int_tfInfoLevelcurrent level in the stack; Int_tfLevellevel in the current branch; TGeoHMatrix**fMPBpre-built matrices; TGeoHMatrix*fMatrix! current matrix; TGeoHMatrix**fMatrixBranchcurrent branch of global matrices; TGeoNode*fNode! current node; TGeoNode**fNodeBranchcurrent branch of nodes; Int_t*fNodeIdArray! array of node id's; TGeoStateInfo*fPWInfo! State info for the parallel world; TStringfPathpath for current branch; TObjArray*fStackstack of cache states; Int_tfStackLevelcurrent level in the stack; TGeoNode*fToptop node. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoNodeCache(); Dummy constructor. TGeoNodeCache(TGeoNode* top, Bool_t nodeid = kFALSE, Int_t capacity = 30); Default constructor. ~TGeoNodeCache(); Destructor. void BuildIdArray(); Builds node id array. void BuildInfoBranch(); Bulds info branch. Navigation is possible only after this step. TGeoStateInfo * GetMakePWInfo(Int_t nd); Get the PW info, if none create one. void CdNode(Int_t nodeid); Change current path to point to the node having this id.; Node id has",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoNodeCache.html:7657,cache,cache,7657,root/html534/TGeoNodeCache.html,https://root.cern,https://root.cern/root/html534/TGeoNodeCache.html,2,['cache'],['cache']
Performance,"nt_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  ;  Public Member Functions inherited from RooPrintable;  RooPrintable ();  ; virtual ~RooPrintable ();  ; virtual StyleOption defaultPrintStyle (Option_t *opt) const;  ; virtual void printExtras (std::ostream &os) const;  Interface to print extras of object. ;  ; virtual void printStream (std::ostream &os, Int_t contents, StyleOption style, TString indent="""") const;  Print description of object on ostream, printing contents set by contents integer, which is interpreted as an OR of 'enum ContentsOptions' values and in the style given by 'enum StyleOption'. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Int_t getCacheAllNumeric ();  Return minimum dimensions of numeric integration for which values are cached. ;  ; static void setCacheAllNumeric (Int_t ndim);  Global switch to cache all integral values that integrate at least ndim dimensions numerically. ;  ;  Static Public Member Functions inherited from RooAbsReal; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static void clearEvalErrorLog ();  Clear the stack of evaluation error messages. ;  ; static const char * DeclFileName ();  ; static RooNumIntConfig * defaultIntegratorConfig ();  Returns the default numeric integration configuration for all RooAbsReals. ;  ; static std::map< constRooAbsArg *, std::pair< std::string, std::list< RooAbsReal::EvalError > > >::iterator evalErrorIter ();  ; static ErrorLoggingMode evalErrorLoggingMode ();  Return current evaluation error logging mode. ;  ; static bool hideOffset ();  ; st",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooRealIntegral.html:46344,cache,cached,46344,doc/master/classRooRealIntegral.html,https://root.cern,https://root.cern/doc/master/classRooRealIntegral.html,1,['cache'],['cached']
Performance,"nt_t resetValue = 10); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Bool_tRooAbsPdf::selfNormalized() const; TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidsetAnaIntZ(Double_t z); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsPdf::setGeneratorConfig(); voidRooAbsPdf::setGeneratorConfig(const RooNumGenConfig& config); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); voidRooAbsPdf::setNormRange(const char* rangeName); voidRooAbsPdf::setNormRangeOverride(const char* rangeName); voidRooAbsPdf::setNormValueCaching(Int_t minNumIntDim, Int_t ipOrder = 2); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsPdf::setTraceCounter(Int_t value, Bool_t allNodes = kFAL",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooMultiVarGaussian.html:28442,cache,cache,28442,root/html532/RooMultiVarGaussian.html,https://root.cern,https://root.cern/root/html532/RooMultiVarGaussian.html,2,['cache'],['cache']
Performance,"nt_t row_upb, Int_t col_lwb, Int_t col_upb, Int_t = -1); Set size of the matrix to [row_lwb:row_upb] x [col_lwb:col_upb]; New dynamic elemenst are created, the overlapping part of the old ones are; copied to the new structures, then the old elements are deleted. Double_t TMatrixT<Element> Determinant() const; Return the matrix determinant. void TMatrixT<Element> Determinant(Double_t& d1, Double_t& d2) const; Return the matrix determinant as d1,d2 where det = d1*TMath::Power(2.0,d2). TMatrixT<Element> &TMatrixT<Element> Invert(Double_t* det = 0); Invert the matrix and calculate its determinant. TMatrixT<Element> &TMatrixT<Element> InvertFast(Double_t* det = 0); Invert the matrix and calculate its determinant, however upto (6x6); a fast Cramer inversion is used . TMatrixT<Element> &TMatrixT<Element> Transpose(const TMatrixT<float>& source); Transpose matrix source. TMatrixT<Element> &TMatrixT<Element> Rank1Update(const TVectorT<float>& v, float alpha = 1.0); Perform a rank 1 operation on matrix A:; A += alpha * v * v^T. TMatrixT<Element> &TMatrixT<Element> Rank1Update(const TVectorT<float>& v1, const TVectorT<float>& v2, float alpha = 1.0); Perform a rank 1 operation on matrix A:; A += alpha * v1 * v2^T. Element TMatrixT<Element> Similarity(const TVectorT<float>& v) const; Calculate scalar v * (*this) * v^T. TMatrixT<Element> &TMatrixT<Element> NormByColumn(const TVectorT<float>& v, Option_t* option = ""D""); Multiply/divide matrix columns by a vector:; option:; ""D"" : b(i,j) = a(i,j)/v(i) i = 0,fNrows-1 (default); else : b(i,j) = a(i,j)*v(i). TMatrixT<Element> &TMatrixT<Element> NormByRow(const TVectorT<float>& v, Option_t* option = ""D""); Multiply/divide matrix rows with a vector:; option:; ""D"" : b(i,j) = a(i,j)/v(j) i = 0,fNcols-1 (default); else : b(i,j) = a(i,j)*v(j). TMatrixT<Element> &TMatrixT<Element> operator=(const TMatrixT<Element> &source); Assignment operator. TMatrixT<Element> &TMatrixT<Element> operator=(const TMatrixTSym<Element> &source); Assignment opera",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMatrixT_float_.html:20130,Perform,Perform,20130,root/html532/TMatrixT_float_.html,https://root.cern,https://root.cern/root/html532/TMatrixT_float_.html,1,['Perform'],['Perform']
Performance,"nt_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e, xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e, xc,xw,yc,yw; -3D : bc,e, xc,xw,yc,yw,zc,zw. void FitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e, xc (bin content, error, x of center of bin); -2D : bc,e, xc,yc; -3D : bc,e, xc,yc,zc. void FitLikelihoodI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e, xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e, xc,xw,yc,yw; -3D : bc,e, xc,xw,yc,yw,zc,zw. TFitter(const TFitter& ). TFitter& operator=(const TFitter& ). TMinuit * GetMinuit() const; {return fMinuit;}. » Author: Rene Brun 31/08/99 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/minuit:$Id$ » Last generated: 2015-03-13 19:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TFitter.html:17033,cache,cache,17033,root/html534/TFitter.html,https://root.cern,https://root.cern/root/html534/TFitter.html,2,['cache'],['cache']
Performance,"nt_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e, xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e, xc,xw,yc,yw; -3D : bc,e, xc,xw,yc,yw,zc,zw. void FitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e, xc (bin content, error, x of center of bin); -2D : bc,e, xc,yc; -3D : bc,e, xc,yc,zc. void FitLikelihoodI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e, xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e, xc,xw,yc,yw; -3D : bc,e, xc,xw,yc,yw,zc,zw. TFitter(const TFitter& ). TFitter& operator=(const TFitter& ). TMinuit * GetMinuit() const; {return fMinuit;}. » Author: Rene Brun 31/08/99 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/minuit:$Id$ » Last generated: 2015-06-02 15:48; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TFitter.html:17606,cache,cache,17606,root/html604/TFitter.html,https://root.cern,https://root.cern/root/html604/TFitter.html,2,['cache'],['cache']
Performance,"nt_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e, xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e, xc,xw,yc,yw; -3D : bc,e, xc,xw,yc,yw,zc,zw. void FitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e, xc (bin content, error, x of center of bin); -2D : bc,e, xc,yc; -3D : bc,e, xc,yc,zc. void FitLikelihoodI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e, xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e, xc,xw,yc,yw; -3D : bc,e, xc,xw,yc,yw,zc,zw. TFitter(const TFitter& ). TFitter& operator=(const TFitter& ). TMinuit * GetMinuit() const; {return fMinuit;}. » Author: Rene Brun 31/08/99 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/minuit:$Id$ » Last generated: 2015-06-30 14:49; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TFitter.html:17606,cache,cache,17606,root/html602/TFitter.html,https://root.cern,https://root.cern/root/html602/TFitter.html,2,['cache'],['cache']
Performance,"nt_t& npari, Int_t& nparx, Int_t& istat); Returns concerning the current status of the minimization; *-* =========================================================; *-* User-called; *-* Namely, it returns:; *-* FMIN: the best function value found so far; *-* FEDM: the estimated vertical distance remaining to minimum; *-* ERRDEF: the value of UP defining parameter uncertainties; *-* NPARI: the number of currently variable parameters; *-* NPARX: the highest (external) parameter number defined by user; *-* ISTAT: a status integer indicating how good is the covariance; *-* matrix: 0= not calculated at all; *-* 1= approximation only, not accurate; *-* 2= full matrix, but forced positive-definite; *-* 3= full accurate covariance matrix; *. void mntiny(Double_t epsp1, Double_t& epsbak); To find the machine precision*-*-*-*-*-*-*-; *-* =============================; *-* Compares its argument with the value 1.0, and returns; *-* the value .TRUE. if they are equal. To find EPSMAC; *-* safely by foiling the Fortran optimizer; *. Bool_t mnunpt(TString& cfname); -*-*Returns .TRUE. if CFNAME contains unprintable characters; *-* ========================================================; *. void mnvert(Double_t* a, Int_t l, Int_t m, Int_t n, Int_t& ifail); Inverts a symmetric matrix*-; *-* ==========================; *-* inverts a symmetric matrix. matrix is first scaled to; *-* have all ones on the diagonal (equivalent to change of units); *-* but no pivoting is done since matrix is positive-definite.; *. void mnwarn(const char* copt, const char* corg, const char* cmes); Prints Warning messages*-*-; *-* =======================; *-* If COPT='W', CMES is a WARning message from CORG.; *-* If COPT='D', CMES is a DEBug message from CORG.; *-* If SET WARnings is in effect (the default), this routine; *-* prints the warning message CMES coming from CORG.; *-* If SET NOWarnings is in effect, the warning message is; *-* stored in a circular buffer of length kMAXMES.; *-* If called with CORG=",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMinuit.html:55523,optimiz,optimizer,55523,root/html528/TMinuit.html,https://root.cern,https://root.cern/root/html528/TMinuit.html,8,['optimiz'],['optimizer']
Performance,"nt_tReOpen(Option_t* mode); virtual voidTDirectoryFile::ResetAfterMerge(TFileMergeInfo*); voidTObject::ResetBit(UInt_t f); virtual voidResetErrno() const; virtual voidTDirectoryFile::rmdir(const char* name); virtual voidTDirectoryFile::Save(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tTDirectoryFile::SaveObjectAs(const TObject* obj, const char* filename = """", Option_t* option = """") const; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTDirectoryFile::SaveSelf(Bool_t force = kFALSE); virtual voidSeek(Long64_t offset, TFile::ERelativeTo pos = kBeg); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTDirectoryFile::SetBufferSize(Int_t bufsize); static Bool_tSetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); virtual voidSetCacheRead(TFileCacheRead* cache); virtual voidSetCacheWrite(TFileCacheWrite* cache); virtual voidSetCompressionAlgorithm(Int_t algorithm = 0); virtual voidSetCompressionLevel(Int_t level = 1); virtual voidSetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetEND(Long64_t last); static voidSetFileBytesRead(Long64_t bytes = 0); static voidSetFileBytesWritten(Long64_t bytes = 0); static voidSetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); static Bool_tSetOnlyStaged(Bool_t onlystaged); static UInt_tSetOpenTimeout(UInt_t timeout); virtual voidSetOption(Option_t* option = "">""); static voidSetReadaheadSize(Int_t bufsize = 256000); virtua",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TFile.html:13308,cache,cache,13308,root/html532/TFile.html,https://root.cern,https://root.cern/root/html532/TFile.html,2,['cache'],['cache']
Performance,"nt_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); RooAbsReal&pdf() const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooNumConvolution.html:21715,optimiz,optimizeCacheMode,21715,root/html534/RooNumConvolution.html,https://root.cern,https://root.cern/root/html534/RooNumConvolution.html,2,['optimiz'],['optimizeCacheMode']
Performance,"nt_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); RooArgSetparameters() const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooChangeTracker.html:19970,optimiz,optimizeCacheMode,19970,root/html534/RooChangeTracker.html,https://root.cern,https://root.cern/root/html534/RooChangeTracker.html,2,['optimiz'],['optimizeCacheMode']
Performance,"nt_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); const RooArgList&paramList() const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*plotSamplingHint(RooAbsRealLValue& obs, Double_t xlo, Double_t xhi) const; vi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ParamHistFunc.html:19897,optimiz,optimizeCacheMode,19897,root/html534/ParamHistFunc.html,https://root.cern,https://root.cern/root/html534/ParamHistFunc.html,6,['optimiz'],['optimizeCacheMode']
Performance,"nt_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/Roo1DMomentMorphFunction.html:19501,optimiz,optimizeCacheMode,19501,root/html534/Roo1DMomentMorphFunction.html,https://root.cern,https://root.cern/root/html534/Roo1DMomentMorphFunction.html,100,['optimiz'],['optimizeCacheMode']
Performance,"nt_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*plotSamplingHint(RooAbsRealLValue& obs, Double_t xlo, Double_t xhi) const; virtual RooPlot*RooAbsReal::plotSliceO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooHistFunc.html:19642,optimiz,optimizeCacheMode,19642,root/html534/RooHistFunc.html,https://root.cern,https://root.cern/root/html534/RooHistFunc.html,4,['optimiz'],['optimizeCacheMode']
Performance,"nt_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAddition.html:19718,optimiz,optimizeCacheMode,19718,root/html534/RooAddition.html,https://root.cern,https://root.cern/root/html534/RooAddition.html,4,['optimiz'],['optimizeCacheMode']
Performance,"nt_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Int_tRooAbsMoment::order() const; Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooFirstMoment.html:19628,optimiz,optimizeCacheMode,19628,root/html534/RooFirstMoment.html,https://root.cern,https://root.cern/root/html534/RooFirstMoment.html,6,['optimiz'],['optimizeCacheMode']
Performance,"nt_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Int_torder() const; Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*Ro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsMoment.html:19382,optimiz,optimizeCacheMode,19382,root/html534/RooAbsMoment.html,https://root.cern,https://root.cern/root/html534/RooAbsMoment.html,4,['optimiz'],['optimizeCacheMode']
Performance,"nt_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoTubeEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for tube editor. ~TGeoTubeEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected object. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Perform name change. void DoApply(); Slot for applying modifications. void DoModified(); Slot for signaling modifications. void DoUndo(); Slot for undoing last operation. void DoRmin(); Slot for rmin. void DoRmax(); Slot for rmax. void DoDz(); Slot for dz. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoTubeEditor.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-11-03 20:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoTubeEditor.html:21197,Perform,Perform,21197,root/html532/TGeoTubeEditor.html,https://root.cern,https://root.cern/root/html532/TGeoTubeEditor.html,1,['Perform'],['Perform']
Performance,"nt_t ; num_points). private . Definition at line 138 of file ROCCurve.cxx. ◆ GetEffSForEffB(). Double_t TMVA::ROCCurve::GetEffSForEffB ; (; Double_t ; effB, . const UInt_t ; num_points = 41 . ). Calculate the signal efficiency (sensitivity) for a given background efficiency (sensitivity). ; Parameters. effBBackground efficiency for which to calculate signal efficiency. ; num_pointsNumber of points used for the underlying histogram. The number of bins will be num_points - 1. . Definition at line 217 of file ROCCurve.cxx. ◆ GetMvas(). const std::vector< std::tuple< Float_t, Float_t, Bool_t > > TMVA::ROCCurve::GetMvas ; (; ); const. inline . Definition at line 68 of file ROCCurve.h. ◆ GetROCCurve(). TGraph * TMVA::ROCCurve::GetROCCurve ; (; const UInt_t ; num_points = 100). Returns a new TGraph containing the ROC curve. ; Sensitivity is on the x-axis, specificity on the y-axis.; Parameters. num_pointsGranularity of the resulting curve. The curve will be subdivided into num_points - 1 regions where the performance of the classifier is sampled. Larger number means more accurate, but more costly, evaluation. . Definition at line 274 of file ROCCurve.cxx. ◆ GetROCIntegral(). Double_t TMVA::ROCCurve::GetROCIntegral ; (; const UInt_t ; num_points = 41). Calculates the ROC integral (AUC) ; Parameters. num_pointsGranularity of the resulting curve used for integration. The curve will be subdivided into num_points - 1 regions where the performance of the classifier is sampled. Larger number means more accurate, but more costly, evaluation. . Definition at line 248 of file ROCCurve.cxx. ◆ Log(). TMVA::MsgLogger & TMVA::ROCCurve::Log ; (; ); const. private . Definition at line 128 of file ROCCurve.cxx. Member Data Documentation. ◆ fGraph. TGraph* TMVA::ROCCurve::fGraph. private . Definition at line 73 of file ROCCurve.h. ◆ fLogger. MsgLogger* TMVA::ROCCurve::fLogger. mutableprivate . ! message logger ; Definition at line 70 of file ROCCurve.h. ◆ fMva. std::vector<std::tuple<Float_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1ROCCurve.html:4360,perform,performance,4360,doc/master/classTMVA_1_1ROCCurve.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1ROCCurve.html,1,['perform'],['performance']
Performance,"nt_t SetBufferSize (Long64_t buffersize) override;  Change the underlying buffer size of the cache. ;  ; void SetEntryRange (Long64_t emin, Long64_t emax) override;  Set the minimum and maximum entry number to be processed this information helps to optimize the number of baskets to read when prefetching the branch buffers. ;  ; void SetUnzipBufferSize (Long64_t bufferSize);  Sets the size for the unzipping cache... by default it should be two times the size of the prefetching cache. ;  ; void SetUnzipGroupSize (Int_t groupSize);  ; void StopLearningPhase () override;  It's the same as TTreeCache::StopLearningPhase but we guarantee that we start the unzipping just after getting the buffers. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; Int_t UnzipBuffer (char **dest, char *src);  Unzips a ROOT specific buffer... by reading the header at the beginning. ;  ; Int_t UnzipCache (Int_t index);  This inflates a basket in the cache. ;  ; void UpdateBranches (TTree *tree) override;  update pointer to current Tree and recompute pointers to the branches in the cache ;  ;  Public Member Functions inherited from TTreeCache;  TTreeCache ();  Default Constructor. ;  ;  TTreeCache (TTree *tree, Int_t buffersize=0);  Constructor. ;  ;  ~TTreeCache () override;  Destructor. (in general called by the TFile destructor) ;  ; virtual void Disable ();  ; virtual Int_t DropBranch (const char *branch, bool subbranches=false);  Remove a branch to the list of branches to be stored in the cache this is to be used by user (thats why we pass the name of the branch). ;  ; virtual Int_t DropBranch (TBranch *b, bool subbranches=false);  Remove a branch to the list of branches to be stored in the cache this function is called by TBranch::GetBasket. ;  ; virtual void Enable ();  ; const TObjArray * GetCachedBranches () const;  ; EPrefillType GetConfiguredPrefillType () const;  Return the desired prefill",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeCacheUnzip.html:4166,cache,cache,4166,doc/master/classTTreeCacheUnzip.html,https://root.cern,https://root.cern/doc/master/classTTreeCacheUnzip.html,1,['cache'],['cache']
Performance,"nt_width = 20;; int bin_print_width = 12;; Get the Data Histogram for this channel. void PrintModelAndData(RooDataSet* data); Loop over all channels and print model; (including all samples) and compare; it to the supplied dataset. void PrintParameters(bool IncludeConstantParams = false). void PrintChannelParameters(const string& channel, bool IncludeConstantParams = false); Get the list of parameters. void PrintSampleParameters(const string& channel, const string& sample, bool IncludeConstantParams = false); Get the list of parameters. double GetBinValue(int bin, const string& channel); Get the total bin height for the ith bin (ROOT indexing convention); in channel 'channel'; (Could be optimized, it uses an intermediate histogram for now...). double GetBinValue(int bin, const string& channel, const string& sample); Get the total bin height for the ith bin (ROOT indexing convention); in channel 'channel'; (This will be slow if you plan on looping over it.; Could be optimized, it uses an intermediate histogram for now...). std::map< std::string, RooAbsReal*> GetSampleFunctionMap(const string& channel); Get a map of strings to function pointers,; which each function cooresponds to a sample. RooAbsReal* SampleFunction(const string& channel, const string& sample); Return the function object pointer cooresponding; to a particular sample in a particular channel. RooArgSet* GetObservableSet(const string& channel); Get the observables for a particular channel. TH1* GetSampleHist(const string& channel, const string& sample, const string& name = """"); Get a histogram of the expected values for; a particular sample in a particular channel; Give a name, or a default one will be used. TH1* GetChannelHist(const string& channel, const string& name = """"); Get a histogram of the total expected value; per bin for this channel; Give a name, or a default one will be used. std::vector< std::string > GetChannelSampleList(const string& channel). THStack* GetChannelStack(const string& channe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStats__HistFactory__HistFactoryNavigation.html:5834,optimiz,optimized,5834,root/html534/RooStats__HistFactory__HistFactoryNavigation.html,https://root.cern,https://root.cern/root/html534/RooStats__HistFactory__HistFactoryNavigation.html,6,['optimiz'],['optimized']
Performance,"ntag, const char* monid, const char* monsubid, const char* option); TMonaLisaWriter&operator=(const TMonaLisaWriter&); Bool_tSendFileCheckpoint(TFile* file). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; TList*TVirtualMonitoringWriter::fTmpOpenPhasesTo store open phases when there is not yet an object. private:. ApMon*fApmon! connection to MonaLisa; TStopwatchfFileStopwatchtime measurements for data access throughputs; TStringfHostname! hostname of MonaLisa server; Bool_tfInitializedtrue if initialized; TStringfJobId! job id; Double_tfLastFCloseSendTimeIn order not to flood ML servers; time_tfLastProgressTimetimestamp of the last send command for player process; Double_tfLastRWSendTimetimestamp of the last send command for file reads/writes; map<UInt_t,MonitoredTFileInfo*>*fMonInfoRepo! repo to gather per-file-instance mon info;; Int_tfPid! process id; Int_tfReportIntervalinterval after which to send the latest value; TStopwatchfStopwatchcpu and time measurement for job and proc status; TStringfSubJobId! sub job id; Bool_tfVerboseverbocity. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMonaLisaWriter(const char* monserver, const char* montag, const char* monid = 0, const char* monsubid = 0, const char* option = """"); Create MonaLisa write object. void Init(const char* monserver, const char* montag, const char* monid, const char* monsubid, const char* option); Creates a TMonaLisaWriter object to send monitoring information to a; MonaLisa server using the MonaLisa ApMon package (libapmoncpp.so/UDP; packets). The MonaLisa ApMon library for C++ can be downloaded at; http://monalisa.cacr.caltech.edu/monalisa__Download",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMonaLisaWriter.html:8420,throughput,throughputs,8420,root/html530/TMonaLisaWriter.html,https://root.cern,https://root.cern/root/html530/TMonaLisaWriter.html,3,['throughput'],['throughputs']
Performance,"ntaining on output the fit resultDefinition Fitter.h:564; ROOT::Fit::Fitter::IGradModelFunction_vROOT::Math::IParamMultiGradFunction IGradModelFunction_vDefinition Fitter.h:89; ROOT::Fit::Fitter::LikelihoodFitbool LikelihoodFit(const std::shared_ptr< BinData > &data, bool extended=true, const ROOT::EExecutionPolicy &executionPolicy=ROOT::EExecutionPolicy::kSequential)Binned Likelihood fit using a shared_ptr for NOT copying the input data.Definition Fitter.h:212; ROOT::Fit::Fitter::fResultstd::shared_ptr< ROOT::Fit::FitResult > fResult! pointer to the object containing the result of the fitDefinition Fitter.h:568; ROOT::Fit::Fitter::GetDataFromFCNbool GetDataFromFCN()internal functions to get data set and model function from FCN useful for fits done with customized F...Definition Fitter.h:584; ROOT::Fit::Fitter::IGradModelFunctionROOT::Math::IParamMultiGradFunction IGradModelFunctionDefinition Fitter.h:91; ROOT::Fit::Fitter::CalculateMinosErrorsbool CalculateMinosErrors()perform an error analysis on the result using MINOS To be called only after fitting and when a minimi...Definition Fitter.cxx:593; ROOT::Fit::Fitter::FitterFitter(const Fitter &)=deleteCopy constructor (disabled, class is not copyable); ROOT::Fit::Fitter::DoUpdateMinimizerOptionsbool DoUpdateMinimizerOptions(bool canDifferentMinim=true)Definition Fitter.cxx:763; ROOT::Fit::Fitter::Fitbool Fit(const Data &data, const Function &func, const ROOT::EExecutionPolicy &executionPolicy=ROOT::EExecutionPolicy::kSequential)fit a data set using any generic model function If data set is binned a least square fit is performed...Definition Fitter.h:144; ROOT::Fit::Fitter::Fitbool Fit(const UnBinData &data, bool extended=false, const ROOT::EExecutionPolicy &executionPolicy=ROOT::EExecutionPolicy::kSequential)Fit an un-binned data set using the negative log-likelihood method.Definition Fitter.h:188; ROOT::Fit::Fitter::SetFunctionvoid SetFunction(const IModelFunction &func, bool useGradient=false)Set the fitted functi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Fitter_8h_source.html:38199,perform,perform,38199,doc/master/Fitter_8h_source.html,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html,1,['perform'],['perform']
Performance,"ntaining the class declaration ; Definition at line 81 of file TEnum.h. ◆ GetClass(). TClass * TEnum::GetClass ; (; ); const. inline . Definition at line 62 of file TEnum.h. ◆ GetConstant(). const TEnumConstant * TEnum::GetConstant ; (; const char * ; name); const. inline . Definition at line 64 of file TEnum.h. ◆ GetConstants(). const TSeqCollection * TEnum::GetConstants ; (; ); const. inline . Definition at line 63 of file TEnum.h. ◆ GetDeclId(). TDictionary::DeclId_t TEnum::GetDeclId ; (; ); const. Definition at line 146 of file TEnum.cxx. ◆ GetEnum() [1/2]. TEnum * TEnum::GetEnum ; (; const char * ; enumName, . ESearchAction ; sa = kALoadAndInterpLookup . ). static . Static function to retrieve enumerator from the ROOT's typesystem. ; It has no side effect, except when the load flag is true. In this case, the load of the library containing the scope of the enumerator is attempted. There are two top level code paths: the enumerator is scoped or isn't. If it is not, a lookup in the list of global enums is performed. If it is, two lookups are carried out for its scope: one in the list of classes and one in the list of protoclasses. If a scope with the desired name is found, the enum is searched. If the scope is not found, and the load flag is true, the aforementioned two steps are performed again after an autoload attempt with the name of the scope as key is tried out. If the interpreter lookup flag is false, the ListOfEnums objects are not treated as such, but rather as THashList objects. This prevents any flow of information from the interpreter into the ROOT's typesystem: a snapshot of the typesystem status is taken. ; Definition at line 209 of file TEnum.cxx. ◆ GetEnum() [2/2]. TEnum * TEnum::GetEnum ; (; const std::type_info & ; ti, . ESearchAction ; sa = kALoadAndInterpLookup . ). static . Definition at line 175 of file TEnum.cxx. ◆ GetQualifiedName(). const char * TEnum::GetQualifiedName ; (; ); const. inline . Definition at line 77 of file TEnum.h. ◆ GetUnde",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTEnum.html:17502,perform,performed,17502,doc/v632/classTEnum.html,https://root.cern,https://root.cern/doc/v632/classTEnum.html,2,['perform'],['performed']
Performance,"ntains the word 'fast' and nentries is -1, the cloning will be done without unzipping or unstreaming the baskets (i.e., a direct copy of the raw bytes on disk).; When 'fast' is specified, 'option' can also contain a sorting order for the baskets in the output file.; There are currently 3 supported sorting order:. SortBasketsByOffset (the default); SortBasketsByBranch; SortBasketsByEntry. When using SortBasketsByOffset the baskets are written in the output file in the same order as in the original file (i.e. the baskets are sorted by their offset in the original file; Usually this also means that the baskets are sorted by the index/number of the last entry they contain); When using SortBasketsByBranch all the baskets of each individual branches are stored contiguously. This tends to optimize reading speed when reading a small number (1->5) of branches, since all their baskets will be clustered together instead of being spread across the file. However it might decrease the performance when reading more branches (or the full entry).; When using SortBasketsByEntry the baskets with the lowest starting entry are written first. (i.e. the baskets are sorted by the index/number of the first entry they contain). This means that on the file the baskets will be in the order in which they will be needed when reading the whole tree sequentially.; For examples of CloneTree, see tutorials:. copytree.C: A macro to copy a subset of a TTree to a new TTree. The input file has been generated by the program in $ROOTSYS/test/Event with: Event 1000 1 1 1; copytree2.C: A macro to copy a subset of a TTree to a new TTree. One branch of the new Tree is written to a separate file. The input file has been generated by the program in $ROOTSYS/test/Event with: Event 1000 1 1 1 . Reimplemented in TNtuple.; Definition at line 3139 of file TTree.cxx. ◆ CopyAddresses(). void TTree::CopyAddresses ; (; TTree * ; tree, . bool ; undo = false . ). virtual . Set branch addresses of passed tree equal to ours",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTree.html:105496,perform,performance,105496,doc/v632/classTTree.html,https://root.cern,https://root.cern/doc/v632/classTTree.html,2,['perform'],['performance']
Performance,"ntation of this file. 1/// \file; 2/// \ingroup tutorial_tmva; 3/// \notebook -nodraw; 4/// This macro provides a simple example for the training and testing of the TMVA; 5/// multiclass classification; 6/// - Project : TMVA - a Root-integrated toolkit for multivariate data analysis; 7/// - Package : TMVA; 8/// - Root Macro: TMVAMulticlass; 9///; 10/// \macro_output; 11/// \macro_code; 12/// \author Andreas Hoecker; 13 ; 14#include <cstdlib>; 15#include <iostream>; 16#include <map>; 17#include <string>; 18 ; 19#include ""TFile.h""; 20#include ""TTree.h""; 21#include ""TString.h""; 22#include ""TSystem.h""; 23#include ""TROOT.h""; 24 ; 25 ; 26#include ""TMVA/Tools.h""; 27#include ""TMVA/Factory.h""; 28#include ""TMVA/DataLoader.h""; 29#include ""TMVA/TMVAMultiClassGui.h""; 30 ; 31 ; 32using namespace TMVA;; 33 ; 34void TMVAMulticlass( TString myMethodList = """" ); 35{; 36 ; 37 // This loads the library; 38 TMVA::Tools::Instance();; 39 ; 40 // to get access to the GUI and all tmva macros; 41 //; 42 // TString tmva_dir(TString(gRootDir) + ""/tmva"");; 43 // if(gSystem->Getenv(""TMVASYS"")); 44 // tmva_dir = TString(gSystem->Getenv(""TMVASYS""));; 45 // gROOT->SetMacroPath(tmva_dir + ""/test/:"" + gROOT->GetMacroPath() );; 46 // gROOT->ProcessLine("".L TMVAMultiClassGui.C"");; 47 ; 48 ; 49 //---------------------------------------------------------------; 50 // Default MVA methods to be trained + tested; 51 std::map<std::string,int> Use;; 52 Use[""MLP""] = 1;; 53 Use[""BDTG""] = 1;; 54#ifdef R__HAS_TMVAGPU; 55 Use[""DL_CPU""] = 1;; 56 Use[""DL_GPU""] = 1;; 57#else; 58 Use[""DL_CPU""] = 1;; 59 Use[""DL_GPU""] = 0;; 60#endif; 61 Use[""FDA_GA""] = 0;; 62 Use[""PDEFoam""] = 1;; 63 ; 64 //---------------------------------------------------------------; 65 ; 66 std::cout << std::endl;; 67 std::cout << ""==> Start TMVAMulticlass"" << std::endl;; 68 ; 69 if (myMethodList != """") {; 70 for (std::map<std::string,int>::iterator it = Use.begin(); it != Use.end(); it++) it->second = 0;; 71 ; 72 std::vector<TString> mlist = TMVA::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAMulticlass_8C_source.html:1046,load,loads,1046,doc/master/TMVAMulticlass_8C_source.html,https://root.cern,https://root.cern/doc/master/TMVAMulticlass_8C_source.html,1,['load'],['loads']
Performance,ntation. ◆ RooAbsCachedPdf. friend class RooAbsCachedPdf. friend . Definition at line 109 of file RooHistPdf.h. ◆ RooHistFunc. friend class RooHistFunc. friend . Definition at line 124 of file RooHistPdf.h. Member Data Documentation. ◆ _cdfBoundaries. bool RooHistPdf::_cdfBoundaries = false. protected . Use boundary conditions for CDFs. ; Definition at line 118 of file RooHistPdf.h. ◆ _codeReg. RooAICRegistry RooHistPdf::_codeReg. mutableprotected . ! Auxiliary class keeping tracking of analytical integration code ; Definition at line 116 of file RooHistPdf.h. ◆ _dataHist. RooDataHist* RooHistPdf::_dataHist = nullptr. protected . Unowned pointer to underlying histogram. ; Definition at line 114 of file RooHistPdf.h. ◆ _histObsList. RooArgSet RooHistPdf::_histObsList. protected . List of observables defining dimensions of histogram. ; Definition at line 112 of file RooHistPdf.h. ◆ _intOrder. Int_t RooHistPdf::_intOrder = 0. protected . Interpolation order. ; Definition at line 117 of file RooHistPdf.h. ◆ _ownedDataHist. std::unique_ptr<RooDataHist> RooHistPdf::_ownedDataHist. protected . ! Owned pointer to underlying histogram ; Definition at line 115 of file RooHistPdf.h. ◆ _pdfObsList. RooSetProxy RooHistPdf::_pdfObsList. protected . List of observables mapped onto histogram observables. ; Definition at line 113 of file RooHistPdf.h. ◆ _totVolume. double RooHistPdf::_totVolume = 0.0. mutableprotected . ! Total volume of space (product of ranges of observables) ; Definition at line 119 of file RooHistPdf.h. ◆ _unitNorm. bool RooHistPdf::_unitNorm = false. protected . Assume contents is unit normalized (for use as pdf cache) ; Definition at line 120 of file RooHistPdf.h. Libraries for RooHistPdf:. [legend]; The documentation for this class was generated from the following files:; roofit/roofitcore/inc/RooHistPdf.h; roofit/roofitcore/src/RooHistPdf.cxx. RooHistPdf. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:56 (GVA Time) using Doxygen 1.9.8   ; . ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooHistPdf.html:90988,cache,cache,90988,doc/master/classRooHistPdf.html,https://root.cern,https://root.cern/doc/master/classRooHistPdf.html,1,['cache'],['cache']
Performance,"nted from TDirectory.; Reimplemented in TSQLFile, and TXMLFile.; Definition at line 1698 of file TFile.cxx. ◆ Print(). void TFile::Print ; (; Option_t * ; option = """"); const. overridevirtual . Print all objects in the file. ; Reimplemented from TDirectory.; Reimplemented in TSQLFile, TXMLFile, TNetFile, and TMemFile.; Definition at line 1706 of file TFile.cxx. ◆ ReadBuffer() [1/2]. Bool_t TFile::ReadBuffer ; (; char * ; buf, . Int_t ; len . ). virtual . Read a buffer from the file. ; This is the basic low level read operation. Returns kTRUE in case of failure. ; Reimplemented in TSQLFile, TXMLFile, TDavixFile, TDCacheFile, TNetFile, TWebFile, and TNetXNGFile.; Definition at line 1770 of file TFile.cxx. ◆ ReadBuffer() [2/2]. Bool_t TFile::ReadBuffer ; (; char * ; buf, . Long64_t ; pos, . Int_t ; len . ). virtual . Read a buffer from the file at the offset 'pos' in the file. ; Returns kTRUE in case of failure. Compared to ReadBuffer(char*, Int_t), this routine does not change the cursor on the physical file representation (fD) if the data is in this TFile's cache. ; Reimplemented in TSQLFile, TXMLFile, TDavixFile, TDCacheFile, TNetFile, TWebFile, and TNetXNGFile.; Definition at line 1720 of file TFile.cxx. ◆ ReadBufferAsync(). Bool_t TFile::ReadBufferAsync ; (; Long64_t ; offs, . Int_t ; len . ). virtual . Reimplemented in TDavixFile.; Definition at line 5208 of file TFile.cxx. ◆ ReadBuffers(). Bool_t TFile::ReadBuffers ; (; char * ; buf, . Long64_t * ; pos, . Int_t * ; len, . Int_t ; nbuf . ). virtual . Read the nbuf blocks described in arrays pos and len. ; The value pos[i] is the seek position of block i of length len[i]. Note that for nbuf=1, this call is equivalent to TFile::ReafBuffer. This function is overloaded by TNetFile, TWebFile, etc. Returns kTRUE in case of failure. ; Reimplemented in TDavixFile, TDCacheFile, TNetFile, TS3WebFile, TWebFile, and TNetXNGFile.; Definition at line 1821 of file TFile.cxx. ◆ ReadBufferViaCache(). Int_t TFile::ReadBufferViaCach",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFile.html:86418,cache,cache,86418,doc/master/classTFile.html,https://root.cern,https://root.cern/doc/master/classTFile.html,1,['cache'],['cache']
Performance,"nted from TSelector.; Definition at line 48 of file TSelHandleDataSet.h. ◆ Process(). Bool_t TSelHandleDataSet::Process ; (; Long64_t ; entry). overridevirtual . The Process() function is called for each entry in the tree (or possibly keyed object in the case of PROOF) to be processed. ; The entry argument specifies which entry in the currently loaded tree is to be processed. It can be passed to either TTree::GetEntry() or TBranch::GetEntry() to read either all or the required parts of the data. When processing keyed objects with PROOF, the object is already loaded and is available via the fObject pointer.; This function should contain the ""body"" of the analysis. It can contain simple or elaborate selection criteria, run algorithms on the data of the event and typically fill histograms. ; Reimplemented from TSelector.; Definition at line 165 of file TSelHandleDataSet.cxx. ◆ ReleaseCache(). void TSelHandleDataSet::ReleaseCache ; (; const char * ; fn). private . Release the memory cache associated with file 'fn'. ; Definition at line 74 of file TSelHandleDataSet.cxx. ◆ RemoveFile(). void TSelHandleDataSet::RemoveFile ; (; const char * ; fn). private . Physically remove the file 'fn'. ; Definition at line 109 of file TSelHandleDataSet.cxx. ◆ SetInputList(). void TSelHandleDataSet::SetInputList ; (; TList * ; input). inlineoverridevirtual . Reimplemented from TSelector.; Definition at line 52 of file TSelHandleDataSet.h. ◆ SetObject(). void TSelHandleDataSet::SetObject ; (; TObject * ; obj). inlineoverridevirtual . Reimplemented from TSelector.; Definition at line 51 of file TSelHandleDataSet.h. ◆ SetOption(). void TSelHandleDataSet::SetOption ; (; const char * ; option). inlineoverridevirtual . Reimplemented from TSelector.; Definition at line 50 of file TSelHandleDataSet.h. ◆ SlaveBegin(). void TSelHandleDataSet::SlaveBegin ; (; TTree * ; ). overridevirtual . Init the type from the input parameters. ; Reimplemented from TSelector.; Definition at line 42 of file TSelHa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSelHandleDataSet.html:16733,cache,cache,16733,doc/master/classTSelHandleDataSet.html,https://root.cern,https://root.cern/doc/master/classTSelHandleDataSet.html,1,['cache'],['cache']
Performance,"ntegral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; RooRealProxy_t; RooCategoryProxy_tag; RooRealProxy_tau; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; RooBCPEffDecay::DecayType_type; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooBCPEffDecay.html:41031,cache,cache,41031,root/html526/RooBCPEffDecay.html,https://root.cern,https://root.cern/root/html526/RooBCPEffDecay.html,2,['cache'],['cache']
Performance,"ntegral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; RooRealProxy_t; RooCategoryProxy_tag; RooRealProxy_tau; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; RooBCPGenDecay::DecayType_type; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooBCPGenDecay.html:40890,cache,cache,40890,root/html526/RooBCPGenDecay.html,https://root.cern,https://root.cern/root/html526/RooBCPGenDecay.html,2,['cache'],['cache']
Performance,"ntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attributes() const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsOptTestStatistic::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooChi2Var.html:2257,Cache,CacheModeRooAbsArg,2257,root/html602/RooChi2Var.html,https://root.cern,https://root.cern/root/html602/RooChi2Var.html,4,['Cache'],['CacheModeRooAbsArg']
Performance,"ntegral; Int_t_numPdfNumber of registered PDFs; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooObjCacheManager_partIntMgrComponent normalization manager; TList_pdfProxyListList of PDF proxies (named after applicable category state); Int_tRooAbsReal::_plotBinsNumber of plot bins; const TNamed*_plotCoefNormRange; RooSetProxy_plotCoefNormSet; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooSimultaneous.html:45521,cache,cache,45521,root/html602/RooSimultaneous.html,https://root.cern,https://root.cern/root/html602/RooSimultaneous.html,4,['cache'],['cache']
Performance,"ntegral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooRealProxy_pdfInput p.d.f; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; const TNamed*_rangeNameName of subset range; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooExtendPdf(); Default constructor. RooExtendPdf(const char* name, const c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooExtendPdf.html:44055,cache,cache,44055,root/html602/RooExtendPdf.html,https://root.cern,https://root.cern/root/html602/RooExtendPdf.html,8,['cache'],['cache']
Performance,"ntegration codes; set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManager_cacheMgrThe cache manager; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Int_t_ipOrderInterpolation order for cache histograms ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsCachedReal.html:31469,cache,cache,31469,root/html526/RooAbsCachedReal.html,https://root.cern,https://root.cern/root/html526/RooAbsCachedReal.html,3,['cache'],['cache']
Performance,"ntegration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooRealProxy_offsetOffset of transformation; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooRealProxy_slopeSlope of transformation; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; RooRealProxy_varInput observable; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooLinearVar.html:38014,cache,cache,38014,root/html532/RooLinearVar.html,https://root.cern,https://root.cern/root/html532/RooLinearVar.html,2,['cache'],['cache']
Performance,"ntegration) is implemented. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; This function forces RooRealIntegral to offer all integration dependents; to RooAbsAnaConvPdf::getAnalyticalIntegralWN() for consideration for; internal integration, if RooRealIntegral considers this to be unsafe (e.g. due; to hidden Jacobian terms). RooAbsAnaConvPdf will not attempt to actually integrate all these dependents; but feed them to the resolution models integration interface, which will; make the final determination on how to integrate these dependents. Double_t getCoefNorm(Int_t coefIdx, const RooArgSet* nset, const TNamed* rangeName) const; Returns the normalization integral value of the coefficient with number coefIdx over normalization; set nset in range rangeName. void makeCoefVarList(RooArgList& ) const; Build complete list of coefficient variables. RooArgSet* coefVars(Int_t coefIdx) const; Return set of parameters with are used exclusively by the coefficient functions. void printMultiline(ostream& stream, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Print info about this object to the specified stream. In addition to the info; from RooAbsPdf::printStream() we add:. Verbose : detailed information on convolution integrals. void setCacheAndTrackHints(RooArgSet& ); Label OK'ed components with cache-and-track. Double_t getCoefNorm(Int_t coefIdx, const RooArgSet& nset, const char* rangeName) const; Coefficient normalization access. return getCoefNorm(coefIdx,&nset,rangeName); Returns normalization integral for coefficient coefIdx for observables nset in range rangeNae. Double_t coefficient(Int_t basisIndex) const. RooArgSet* parseIntegrationRequest(const RooArgSet& intSet, Int_t& coefCode, RooArgSet* analVars = 0) const. » Last changed: Sat Sep 5 16:39:52 2015 » Last generated: 2015-09-05 16:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsAnaConvPdf.html:51475,cache,cache-and-track,51475,root/html534/RooAbsAnaConvPdf.html,https://root.cern,https://root.cern/root/html534/RooAbsAnaConvPdf.html,2,['cache'],['cache-and-track']
Performance,"nter the name of the tree to add. On the right are the leaves or variables in the tree. You can double click on any leaf to a histogram it.; The toolbar in the upper part can be used for user commands, changing the drawing option and the histogram name. The lower part contains three picture buttons that draw a histogram, stop the current command, and refresh the tree.; The three check buttons toggle the following:; Hist- the histogram drawing mode;; Scan- enables redirecting of TTree::Scancommand in an ASCII file;; Rec - enables recording of the last issued command. To draw more than one dimension you can drag and drop any leaf to the X,Y,Z boxes"". Then push the Draw button, witch is marked with the purple icon on the bottom left.; All commands can be interrupted at any time by pressing this button.; The method TTree::Refresh is called by pressing the refresh button in TTreeViewer. It redraws the current exposed expression. Calling TTree::Refresh is useful when a tree is produced by a writer process and concurrently analyzed by one or more readers.; To add a cut/weight to the histogram, enter an expression in the “cut box”. The cut box is the one with the scissor icon. Below them there are two text widgets for specifying the input and output event lists. A Tree Viewer session is made by the list of user-defined expressions and cuts, applying to a specified tree. A session can be saved using File / SaveSource menu or the SaveSource method from the context menu of the right panel. This will create a macro having as default name treeviewer.C that can be ran at any time to reproduce the session.; Besides the list of user-defined expressions, a session may contain a list of RECORDS. A record can be produced in the following way: dragging leaves/expression on X/Y/Z; changing drawing options; clicking the RED button on the bottom when happy with the histogram; NOTE that just double clicking a leaf will not produce a record: the histogram must be produced when clicking the D",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:527341,concurren,concurrently,527341,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['concurren'],['concurrently']
Performance,"nter type; TTree*fLastTreeTTree containing the last entry read; Int_tfMemberOffset; Int_tfOffsetOffset inside the object; ROOT::TBranchProxy*fParentProxy to a parent object; Long64_tfReadLast entry read; void*fWherememory location of the data. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBranchProxy(); Constructor. TBranchProxy(ROOT::TBranchProxyDirector* boss, const char* top, const char* name = 0); Constructor. TBranchProxy(ROOT::TBranchProxyDirector* boss, const char* top, const char* name, const char* membername); Constructor. TBranchProxy(ROOT::TBranchProxyDirector* boss, ROOT::TBranchProxy* parent, const char* membername, const char* top = 0, const char* name = 0); Constructor. TBranchProxy(ROOT::TBranchProxyDirector* boss, TBranch* branch, const char* membername); Constructor. ~TBranchProxy(); Typical Destructor. void Reset(); Completely reset the object. void Print(); Display the content of the object. Bool_t Setup(); Initialize/cache the necessary information. TBranchProxy(). TBranchProxy* GetProxy(); { return this; }. const char* GetBranchName() const; { return fBranchName; }. Bool_t IsInitialized(). Bool_t IsaPointer() const. Bool_t Read(). Bool_t ReadEntries(). TClass * GetClass(). void* GetWhere() const; { return fWhere; }. TVirtualCollectionProxy * GetCollection(); { return fCollection; }. void * GetStart(UInt_t = 0); protected:. void * GetClaStart(UInt_t i = 0); return the address of the start of the object being proxied. Assumes; that Setup() has been called. Assumes the object containing this data; member is held in TClonesArray. void * GetStlStart(UInt_t i = 0); return the address of the start of the object being proxied. Assumes; that Setup() has been called. Assumes the object containing this data; member is held in STL Collection. Int_t GetOffset(); { return fOffset; }. TImpProxy & operator=(const ROOT::TBranchProxy& ). » Author: Philippe Canal 01/06/2004 » Copyright (C) 1995-2004, Rene Brun and Fon",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__TBranchProxy.html:3395,cache,cache,3395,root/html602/ROOT__TBranchProxy.html,https://root.cern,https://root.cern/root/html602/ROOT__TBranchProxy.html,4,['cache'],['cache']
Performance,"nterface functions, which have a sensible default implementation. ; Definition at line 29 of file RooObjCacheManager.h. Public Member Functions;  RooObjCacheManager (const RooObjCacheManager &other, RooAbsArg *owner=nullptr);  Copy constructor. ;  ;  RooObjCacheManager (RooAbsArg *owner=nullptr, Int_t maxSize=2, bool clearCacheOnServerRedirect=true, bool allowOptimize=false);  Constructor of object cache manager for given owner. ;  ;  ~RooObjCacheManager () override;  Destructor. ;  ; void findConstantNodes (const RooArgSet &, RooArgSet &, RooLinkedList &) override;  If clearOnRedirect is false, forward constant term optimization calls to cache elements. ;  ; void insertObjectHook (RooAbsCacheElement &) override;  Set owner link on all object inserted into cache. ;  ; TClass * IsA () const override;  ; void operModeHook () override;  Intercept changes to cache operation mode and forward to cache elements. ;  ; void optimizeCacheMode (const RooArgSet &, RooArgSet &, RooLinkedList &) override;  Intercept calls to perform automatic optimization of cache mode operation. ;  ; void printCompactTreeHook (std::ostream &, const char *) override;  Add details on cache contents when printing in tree mode. ;  ; bool redirectServersHook (const RooAbsCollection &, bool, bool, bool) override;  Intercept server redirect calls. ;  ; void setClearOnRedirect (bool flag);  ; void sterilize () override;  Clear the cache payload but retain slot mapping w.r.t to normalization and integration sets. ;  ; void Streamer (TBuffer &) override;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from RooCacheManager< RooAbsCacheElement >;  RooCacheManager (const RooCacheManager &other, RooAbsArg *owner=nullptr);  Copy constructor. ;  ;  RooCacheManager (Int_t maxSize=2);  Constructor for simple caches without RooAbsArg payload. ;  ;  RooCacheManager (RooAbsArg *owner, Int_t maxSize=2);  Constructor for simple caches with RooAbsArg derived payloa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooObjCacheManager.html:1713,optimiz,optimizeCacheMode,1713,doc/master/classRooObjCacheManager.html,https://root.cern,https://root.cern/doc/master/classRooObjCacheManager.html,4,"['cache', 'optimiz', 'perform']","['cache', 'optimization', 'optimizeCacheMode', 'perform']"
Performance,"nterface to the Principal Components Analysis class. Create an instance of TPrincipal; Fill it with the selected variables; if option ""n"" is specified, the TPrincipal object is filled with; normalized variables.; If option ""p"" is specified, compute the principal components; If option ""p"" and ""d"" print results of analysis; If option ""p"" and ""h"" generate standard histograms; If option ""p"" and ""c"" generate code of conversion functions; return a pointer to the TPrincipal object. It is the user responsibility; to delete this object.; The option default value is ""np"". See TTreePlayer::DrawSelect for explanation of the other parameters. Long64_t Process(const char* filename, Option_t* option, Long64_t nentries, Long64_t firstentry); Process this tree executing the TSelector code in the specified filename.; The return value is -1 in case of error and TSelector::GetStatus() in; in case of success. The code in filename is loaded (interpreted or compiled, see below),; filename must contain a valid class implementation derived from TSelector,; where TSelector has the following member functions:. Begin(): called every time a loop on the tree starts,; a convenient place to create your histograms.; SlaveBegin(): called after Begin(), when on PROOF called only on the; slave servers.; Process(): called for each event, in this function you decide what; to read and fill your histograms.; SlaveTerminate: called at the end of the loop on the tree, when on PROOF; called only on the slave servers.; Terminate(): called at the end of the loop on the tree,; a convenient place to draw/fit your histograms. If filename is of the form file.C, the file will be interpreted.; If filename is of the form file.C++, the file file.C will be compiled; and dynamically loaded.; If filename is of the form file.C+, the file file.C will be compiled; and dynamically loaded. At next call, if file.C is older than file.o; and file.so, the file.C is not compiled, only file.so is loaded. NOTE1; It may be more intere",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreePlayer.html:48856,load,loaded,48856,root/html528/TTreePlayer.html,https://root.cern,https://root.cern/root/html528/TTreePlayer.html,10,['load'],['loaded']
Performance,"nterface. ;  ; virtual ~TSystem ();  Delete the OS interface. ;  ; virtual void AddIncludePath (const char *includePath);  Add a directory to the already set include path. ;  ; virtual void AddLinkedLibs (const char *linkedLib);  Add linkedLib to already set linked libs. ;  ; virtual void AddStdExceptionHandler (TStdExceptionHandler *eh);  Add an exception handler to list of system exception handlers. ;  ; virtual const char * BaseName (const char *pathname);  Base name of a file name. Base name of /user/root is root. ;  ; void Beep (Int_t freq=-1, Int_t duration=-1, Bool_t setDefault=kFALSE);  Beep for duration milliseconds with a tone of frequency freq. ;  ; Bool_t cd (const char *path);  ; virtual void CleanCompiledMacros ();  Remove the shared libs produced by the CompileMacro() function, together with their rootmaps, linkdefs, and pcms (and some more on Windows). ;  ; virtual int CompileMacro (const char *filename, Option_t *opt="""", const char *library_name="""", const char *build_dir="""", UInt_t dirmode=0);  This method compiles and loads a shared library containing the code from the file ""filename"". ;  ; virtual char * ConcatFileName (const char *dir, const char *name);  Concatenate a directory and a file name. User must delete returned string. ;  ; virtual const char * DirName (const char *pathname);  Return the directory name in pathname. ;  ; char * DynamicPathName (const char *lib, Bool_t quiet=kFALSE);  Find a dynamic library called lib using the system search paths. ;  ; virtual void ExitLoop ();  Exit from event loop. ;  ; virtual EAclicMode GetAclicMode () const;  AclicMode indicates whether the library should be built in debug mode or optimized. ;  ; virtual Int_t GetAclicProperties () const;  Return the ACLiC properties field. ;  ; void GetBeepDefaults (Int_t &freq, Int_t &duration) const;  ; virtual const char * GetBuildArch () const;  Return the build architecture. ;  ; virtual const char * GetBuildCompiler () const;  Return the build compiler. ;  ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMacOSXSystem.html:13808,load,loads,13808,doc/master/classTMacOSXSystem.html,https://root.cern,https://root.cern/doc/master/classTMacOSXSystem.html,2,['load'],['loads']
Performance,"nterleaving strategy rather than N-wise split for partioning of dataset for multiprocessor-split; Int_t_nCPUNumber of processors to use in parallel calculation mode; Int_t_nEventsTotal number of events in test statistic calculation; Int_t_nGofNumber of sub-contexts ; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; Int_t_numSetsTotal number of partitions in parallel calculation mode; Double_t_offset! Offset; Double_t_offsetCarry! avoids loss of precision; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooSetProxy_paramSetParameters of the test statistic (=parameters of the input function); Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; const RooArgSet*_projDepsPointer to set with projected observables; RooRefArrayRooAbsArg::_proxyListlist of proxies; string_rangeNameName of range in which to calculate test statistic; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Int_t_setNumPartition number of this instance in parallel calculation mode; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; Int_t_simCountTotal number of component p.d.f.s in RooSimultaneous (if any); RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; Bool_t_splitRangeSplit rangeName in RooSimultaneous index labels if true; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsTestStatistic.html:37764,cache,cache,37764,root/html534/RooAbsTestStatistic.html,https://root.cern,https://root.cern/root/html534/RooAbsTestStatistic.html,2,['cache'],['cache']
Performance,"nternal::RPageSource::GetType ; (; ). inlinefinalvirtual . Whether the concrete implementation is a sink or a source. ; Implements ROOT::Experimental::Internal::RPageStorage.; Definition at line 713 of file RPageStorage.hxx. ◆ LoadClusters(). virtual std::vector< std::unique_ptr< RCluster > > ROOT::Experimental::Internal::RPageSource::LoadClusters ; (; std::span< RCluster::RKey > ; clusterKeys). pure virtual . Populates all the pages of the given cluster ids and columns; it is possible that some columns do not contain any pages. ; The page source may load more columns than the minimal necessary set from columns. To indicate which columns have been loaded, LoadClusters()must mark them withSetColumnAvailable(). That includes the ones from thecolumnsthat don't have pages; otherwise subsequent requests for the cluster would assume an incomplete cluster and trigger loading again. LoadClusters()` is typically called from the I/O thread of a cluster pool, i.e. the method runs concurrently to other methods of the page source. ; Implemented in ROOT::Experimental::Internal::RPageSourceFriends, ROOT::Experimental::Internal::RPageSourceDaos, and ROOT::Experimental::Internal::RPageSourceFile. ◆ LoadPage() [1/2]. ROOT::Experimental::Internal::RPageRef ROOT::Experimental::Internal::RPageSource::LoadPage ; (; ColumnHandle_t ; columnHandle, . NTupleSize_t ; globalIndex . ). virtual . Allocates and fills a page that contains the index-th element. ; The default implementation searches the page and calls LoadPageImpl(). Returns a default-constructed RPage for suppressed columns. ; Reimplemented in ROOT::Experimental::Internal::RPageSourceFriends.; Definition at line 319 of file RPageStorage.cxx. ◆ LoadPage() [2/2]. ROOT::Experimental::Internal::RPageRef ROOT::Experimental::Internal::RPageSource::LoadPage ; (; ColumnHandle_t ; columnHandle, . RClusterIndex ; clusterIndex . ). virtual . Another version of LoadPage that allows to specify cluster-relative indexes. ; Returns a default-const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1Internal_1_1RPageSource.html:14661,concurren,concurrently,14661,doc/master/classROOT_1_1Experimental_1_1Internal_1_1RPageSource.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1Internal_1_1RPageSource.html,1,['concurren'],['concurrently']
Performance,"nterpreter interface. void ClearFileBusy(); Reset CINT internal state in case a previous action was not correctly; terminated by G__init_cint() and G__dlmod(). void ClearStack(); Delete existing temporary values. Int_t InitializeDictionaries(); Initialize all registered dictionaries. Normally this is already done; by G__init_cint() and G__dlmod(). void EnableAutoLoading(); Enable the automatic loading of shared libraries when a class; is used that is stored in a not yet loaded library. Uses the; information stored in the class/library map (typically; $ROOTSYS/etc/system.rootmap). void EndOfLineAction(); It calls a ""fantom"" method to synchronize user keyboard input; and ROOT prompt line. Bool_t IsLoaded(const char* filename) const; Return true if the file has already been loaded by cint. Int_t Load(const char* filenam, Bool_t system = kFALSE); Load a library file in CINT's memory.; if 'system' is true, the library is never unloaded. void LoadMacro(const char* filename, TInterpreter::EErrorCode* error = 0); Load a macro file in CINT's memory. Long_t ProcessLine(const char* line, TInterpreter::EErrorCode* error = 0); Let CINT process a command line.; If the command is executed and the result of G__process_cmd is 0,; the return value is the int value corresponding to the result of the command; (float and double return values will be truncated). Long_t ProcessLineAsynch(const char* line, TInterpreter::EErrorCode* error = 0); Let CINT process a command line asynch. Long_t ProcessLineSynch(const char* line, TInterpreter::EErrorCode* error = 0); Let CINT process a command line synchronously, i.e we are waiting; it will be finished. Long_t Calc(const char* line, TInterpreter::EErrorCode* error = 0); Directly execute an executable statement (e.g. ""func()"", ""3+5"", etc.; however not declarations, like ""Int_t x;""). void PrintIntro(); Print CINT introduction and help message. void SetGetline(const char *(*)(const char* prompt) getlineFunc, void (*)(const char* line) histaddFunc); ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TCint.html:20768,Load,LoadMacro,20768,root/html532/TCint.html,https://root.cern,https://root.cern/root/html532/TCint.html,4,['Load'],"['Load', 'LoadMacro']"
Performance,"ntext*RooAbsPdf::binnedGenContext(const RooArgSet& vars, Bool_t verbose = kFALSE) const; virtual const char*RooAbsCachedPdf::binningName() const; TStringRooAbsCachedPdf::cacheNameSuffix(const RooArgSet& nset) const; RooFitResult*RooAbsReal::chi2FitDriver(RooAbsReal& fcn, RooLinkedList& cmdList); TStringRooAbsArg::cleanBranchName() const; voidRooAbsCachedPdf::clearCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; virtual voidRooAbsReal::copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE, Bool_t setValDirty = kTRUE); virtual RooAbsCachedPdf::PdfCacheElem*createCache(const RooArgSet* nset) const; RooAbsReal*RooAbsReal::createIntObj(const RooArgSet& iset, const RooArgSet* nset, const RooNumIntConfig* cfg, const char* rangeName) const; voidRooAbsCachedPdf::disableCache(Bool_t flag); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual Double_tevaluate() const; virtual voidfillCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; virtual voidRooAbsReal::fillTreeBranch(TTree& t); voidRooAbsReal::findInnerMostIntegration(const RooArgSet& allObs, RooArgSet& innerObs, const char* rangeName) const; virtual RooAbsGenContext*RooAbsPdf::genContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE) const; RooDataSet*RooAbsPdf::generate(RooAbsGenContext& context, const RooArgSet& whatVars, const RooDataSet* prototype, Double_t nEvents, Bool_t verbose, Bool_t randProtoOrder, Bool_t resampleProto, Bool_t skipInit = kFALSE, Bool_t extended = kFALSE) const; RooAbsCachedPdf::PdfCacheElem*RooAbsCachedPdf::getCache(const RooArgSet* nset, Bool_t recalculate = kTRUE) const; virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; static voidRooAbsReal::globalSelectComp(Bool_t flag); voidRooAbsArg::grap",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooIntegralMorph.html:37992,cache,cache,37992,root/html534/RooIntegralMorph.html,https://root.cern,https://root.cern/root/html534/RooIntegralMorph.html,6,['cache'],['cache']
Performance,"ntext, const RooArgSet& whatVars, const RooDataSet* prototype, Int_t nEvents, Bool_t verbose, Bool_t randProtoOrder, Bool_t resampleProto) const; virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; static voidRooAbsReal::globalSelectComp(Bool_t flag); voidRooAbsArg::graphVizAddConnections(set<std::pair<RooAbsArg*,RooAbsArg*> >&); static Bool_tRooAbsArg::inhibitDirty(); TStringRooAbsReal::integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset = 0, const char* rangeName = 0, Bool_t omitEmpty = kFALSE) const; Bool_tRooAbsReal::isSelectedComp() const; virtual Bool_tRooAbsReal::isValid() const; virtual Bool_tRooAbsReal::isValidReal(Double_t value, Bool_t printError = kFALSE) const; voidRooAbsReal::makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; voidTObject::MakeZombie(); Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c, const RooArgProxy& d) const; Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooArgSet& params, Bool_t showConstants = kFALSE, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/Roo2DKeysPdf.html:32892,optimiz,optimizeDirtyHook,32892,root/html526/Roo2DKeysPdf.html,https://root.cern,https://root.cern/root/html526/Roo2DKeysPdf.html,150,['optimiz'],['optimizeDirtyHook']
Performance,"ntext::_prototypePointer to prototype dataset; TIterator*_proxyIterIterator over pdf proxies; RooArgSet*RooAbsGenContext::_theEventPointer to observable event being generated; Bool_tRooAbsGenContext::_verboseVerbose messaging?; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooSimGenContext(const RooSimultaneous& model, const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t _verbose = kFALSE); Constructor of specialized generator context for RooSimultaneous p.d.f.s. This; context creates a dedicated context for each component p.d.f.s and delegates; generation of events to the appropriate component generator context. ~RooSimGenContext(); Destructor. Delete all owned subgenerator contexts. void attach(const RooArgSet& params); Attach the index category clone to the given event buffer. void initGenerator(const RooArgSet& theEvent); Perform one-time initialization of generator context. RooDataSet* createDataSet(const char* name, const char* title, const RooArgSet& obs); Create an empty dataset to hold the events that will be generated. void generateEvent(RooArgSet& theEvent, Int_t remaining); Generate event appropriate for current index state.; The index state is taken either from the prototype; or is generated from the fraction threshold table. void updateFractions(); No action needed if we have a proto index. void setProtoDataOrder(Int_t* lut); Set the traversal order of the prototype data to that in the; given lookup table. This information is passed to all; component generator contexts. void printMultiline(ostream& os, Int_t content, Bool_t verbose = kFALSE, TString indent = """") const; Detailed printing interface. RooSimGenContext(const RooSimultaneous& model, const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t _verbose = kFALSE). » Last changed: Thu Nov 3 20:09:15 2011 »",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooSimGenContext.html:9804,Perform,Perform,9804,root/html532/RooSimGenContext.html,https://root.cern,https://root.cern/root/html532/RooSimGenContext.html,1,['Perform'],['Perform']
Performance,"ntext::_prototypePointer to prototype dataset; TIterator*_proxyIterIterator over pdf proxies; RooArgSet*RooAbsGenContext::_theEventPointer to observable event being generated; Bool_tRooAbsGenContext::_verboseVerbose messaging?; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooSimGenContext(const RooSimultaneous& model, const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t _verbose = kFALSE); Constructor of specialized generator context for RooSimultaneous p.d.f.s. This; context creates a dedicated context for each component p.d.f.s and delegates; generation of events to the appropriate component generator context. ~RooSimGenContext(); Destructor. Delete all owned subgenerator contexts. void attach(const RooArgSet& params); Attach the index category clone to the given event buffer. void initGenerator(const RooArgSet& theEvent); Perform one-time initialization of generator context. RooDataSet* createDataSet(const char* name, const char* title, const RooArgSet& obs); Create an empty dataset to hold the events that will be generated. void generateEvent(RooArgSet& theEvent, Int_t remaining); Generate event appropriate for current index state.; The index state is taken either from the prototype; or is generated from the fraction threshold table. void updateFractions(); No action needed if we have a proto index. void setProtoDataOrder(Int_t* lut); Set the traversal order of the prototype data to that in the; given lookup table. This information is passed to all; component generator contexts. void printMultiline(ostream& os, Int_t content, Bool_t verbose = kFALSE, TString indent = """") const; Detailed printing interface. RooSimGenContext(const RooSimultaneous& model, const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t _verbose = kFALSE). » Last changed: Tue Jun 2 15:33:47 2015 »",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooSimGenContext.html:10933,Perform,Perform,10933,root/html604/RooSimGenContext.html,https://root.cern,https://root.cern/root/html604/RooSimGenContext.html,1,['Perform'],['Perform']
Performance,"ntext::_prototypePointer to prototype dataset; TIterator*_proxyIterIterator over pdf proxies; RooArgSet*RooAbsGenContext::_theEventPointer to observable event being generated; Bool_tRooAbsGenContext::_verboseVerbose messaging?; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooSimGenContext(const RooSimultaneous& model, const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t _verbose = kFALSE); Constructor of specialized generator context for RooSimultaneous p.d.f.s. This; context creates a dedicated context for each component p.d.f.s and delegates; generation of events to the appropriate component generator context. ~RooSimGenContext(); Destructor. Delete all owned subgenerator contexts. void attach(const RooArgSet& params); Attach the index category clone to the given event buffer. void initGenerator(const RooArgSet& theEvent); Perform one-time initialization of generator context. RooDataSet* createDataSet(const char* name, const char* title, const RooArgSet& obs); Create an empty dataset to hold the events that will be generated. void generateEvent(RooArgSet& theEvent, Int_t remaining); Generate event appropriate for current index state.; The index state is taken either from the prototype; or is generated from the fraction threshold table. void updateFractions(); No action needed if we have a proto index. void setProtoDataOrder(Int_t* lut); Set the traversal order of the prototype data to that in the; given lookup table. This information is passed to all; component generator contexts. void printMultiline(ostream& os, Int_t content, Bool_t verbose = kFALSE, TString indent = """") const; Detailed printing interface. RooSimGenContext(const RooSimultaneous& model, const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t _verbose = kFALSE). » Last changed: Tue Jun 30 14:35:43 2015 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooSimGenContext.html:10933,Perform,Perform,10933,root/html602/RooSimGenContext.html,https://root.cern,https://root.cern/root/html602/RooSimGenContext.html,1,['Perform'],['Perform']
Performance,"ntext::_prototypePointer to prototype dataset; TIterator*_proxyIterIterator over pdf proxies; RooArgSet*RooAbsGenContext::_theEventPointer to observable event being generated; Bool_tRooAbsGenContext::_verboseVerbose messaging?; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooSimGenContext(const RooSimultaneous& model, const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t _verbose = kFALSE); Constructor of specialized generator context for RooSimultaneous p.d.f.s. This; context creates a dedicated context for each component p.d.f.s and delegates; generation of events to the appropriate component generator context. ~RooSimGenContext(); Destructor. Delete all owned subgenerator contexts. void attach(const RooArgSet& params); Attach the index category clone to the given event buffer. void initGenerator(const RooArgSet& theEvent); Perform one-time initialization of generator context. RooDataSet* createDataSet(const char* name, const char* title, const RooArgSet& obs); Create an empty dataset to hold the events that will be generated. void generateEvent(RooArgSet& theEvent, Int_t remaining); Generate event appropriate for current index state.; The index state is taken either from the prototype; or is generated from the fraction threshold table. void updateFractions(); No action needed if we have a proto index. void setProtoDataOrder(Int_t* lut); Set the traversal order of the prototype data to that in the; given lookup table. This information is passed to all; component generator contexts. void printMultiline(ostream& os, Int_t content, Bool_t verbose = kFALSE, TString indent = """") const; Detailed printing interface. RooSimGenContext(const RooSimultaneous& model, const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t _verbose = kFALSE). » Last changed: Tue Mar 10 17:19:07 2015 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooSimGenContext.html:9919,Perform,Perform,9919,root/html534/RooSimGenContext.html,https://root.cern,https://root.cern/root/html534/RooSimGenContext.html,1,['Perform'],['Perform']
Performance,"ntextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. const TGClient*fClientclient for which we keep icon pool; TStringfPathicon search path; THashTable*fPicListhash table containing the icons. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGPicturePool(const TGPicturePool& ); copy constructor. TGPicturePool& operator=(const TGPicturePool& ); assignment operator. const TGPicture * GetPicture(const char* name); Get a picture from the picture pool. Picture must be freed using; TGPicturePool::FreePicture(). If picture is not found 0 is returned. const TGPicture * GetPicture(const char* name, UInt_t new_width, UInt_t new_height); Get picture with specified size from pool (picture will be scaled if; necessary). Picture must be freed using TGPicturePool::FreePicture(). If; picture is not found 0 is returned. const TGPicture * GetPicture(const char* name, Pixmap_t pxmap, Pixmap_t mask = 0); Get picture with specified pixmap and mask from pool.; Picture must be freed using TGPicturePool::FreePicture().; If picture is not found 0 is returned. const TGPicture * GetPicture(const char* name, char** xpm); Create picture from XPM data.; Picture must be freed using TGPicturePool::FreePicture().; If picture creation failed 0 is returned. void FreePicture(const TGPicture* pic); Remove picture from cache if nobody is using it anymore. ~TGPicturePool(); Delete picture cache. void Print(Option_t* option = """") const; List all pictures in the pool. TGPicturePool(const TGPicturePool& ). const char * GetPath() const; { return fPath; }. » Author: Fons Rademakers 01/01/98 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ » Last generated: 2015-03-13 19:27; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGPicturePool.html:7018,cache,cache,7018,root/html534/TGPicturePool.html,https://root.cern,https://root.cern/root/html534/TGPicturePool.html,4,['cache'],['cache']
Performance,"ntf(hf,""inline %s::~%s() {\n"",classname.Data(),classname.Data());; 1905 fprintf(hf,"" // destructor. Clean up helpers.\n"");; 1906 fprintf(hf,""\n"");; 1907 fprintf(hf,""}\n"");; 1908 fprintf(hf,""\n"");; 1909 fprintf(hf,""inline void %s::Init(TTree *tree)\n"",classname.Data());; 1910 fprintf(hf,""{\n"");; 1911 fprintf(hf,""// Set branch addresses\n"");; 1912 fprintf(hf,"" if (tree == 0) return;\n"");; 1913 fprintf(hf,"" fChain = tree;\n"");; 1914 fprintf(hf,"" fDirector.SetTree(fChain);\n"");; 1915 fprintf(hf,"" if (htemp == 0) {\n"");; 1916 fprintf(hf,"" htemp = fDirector.CreateHistogram(GetOption());\n"");; 1917 if (cutfilename) {; 1918 fprintf(hf,"" htemp->SetTitle(\""%s {%s}\"");\n"",fScript.Data(),fCutScript.Data());; 1919 } else {; 1920 fprintf(hf,"" htemp->SetTitle(\""%s\"");\n"",fScript.Data());; 1921 }; 1922 fprintf(hf,"" fObject = htemp;\n"");; 1923 fprintf(hf,"" }\n"");; 1924 fprintf(hf,""}\n"");; 1925 fprintf(hf,""\n"");; 1926 fprintf(hf,""bool %s::Notify()\n"",classname.Data());; 1927 fprintf(hf,""{\n"");; 1928 fprintf(hf,"" // Called when loading a new file.\n"");; 1929 fprintf(hf,"" // Get branch pointers.\n"");; 1930 fprintf(hf,"" fDirector.SetTree(fChain);\n"");; 1931 fprintf(hf,"" %s_Notify();\n"",scriptfunc.Data());; 1932 fprintf(hf,"" \n"");; 1933 fprintf(hf,"" return true;\n"");; 1934 fprintf(hf,""}\n"");; 1935 fprintf(hf,"" \n"");; 1936 ; 1937 // generate code for class member function Begin; 1938 fprintf(hf,""\n"");; 1939 fprintf(hf,""inline void %s::Begin(TTree *tree)\n"",classname.Data());; 1940 fprintf(hf,""{\n"");; 1941 fprintf(hf,"" // The Begin() function is called at the start of the query.\n"");; 1942 fprintf(hf,"" // When running with PROOF Begin() is only called on the client.\n"");; 1943 fprintf(hf,"" // The tree argument is deprecated (on PROOF 0 is passed).\n"");; 1944 fprintf(hf,""\n"");; 1945 fprintf(hf,"" TString option = GetOption();\n"");; 1946 fprintf(hf,"" %s_Begin(tree);\n"",scriptfunc.Data());; 1947 fprintf(hf,""\n"");; 1948 fprintf(hf,""}\n"");; 1949 ; 1950 // generate code for class member function S",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTreeProxyGenerator_8cxx_source.html:73068,load,loading,73068,doc/master/TTreeProxyGenerator_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTreeProxyGenerator_8cxx_source.html,1,['load'],['loading']
Performance,"ntial"");; m.AddLine(""from tensorflow.keras.optimizers import Adam"");; m.AddLine(""from tensorflow.keras.layers import Input, Dense, Dropout, Flatten, SimpleRNN, GRU, LSTM, Reshape, ""; ""BatchNormalization"");; m.AddLine("""");; m.AddLine(""model = Sequential() "");; m.AddLine(""model.add(Reshape((10, 30), input_shape = (10*30, )))"");; // add recurrent neural network depending on type / Use option to return the full output; if (rnn_types[i] == ""LSTM""); m.AddLine(""model.add(LSTM(units=10, return_sequences=True) )"");; else if (rnn_types[i] == ""GRU""); m.AddLine(""model.add(GRU(units=10, return_sequences=True) )"");; else; m.AddLine(""model.add(SimpleRNN(units=10, return_sequences=True) )"");; ; // m.AddLine(""model.add(BatchNormalization())"");; m.AddLine(""model.add(Flatten())""); // needed if returning the full time output sequence; m.AddLine(""model.add(Dense(64, activation = 'tanh')) "");; m.AddLine(""model.add(Dense(2, activation = 'sigmoid')) "");; m.AddLine(; ""model.compile(loss = 'binary_crossentropy', optimizer = Adam(learning_rate = 0.001), weighted_metrics = ['accuracy'])"");; m.AddLine(TString::Format(""modelName = '%s'"", modelName.Data()));; m.AddLine(""model.save(modelName)"");; m.AddLine(""model.summary()"");; ; m.SaveSource(""make_rnn_model.py"");; // execute python script to make the model; auto ret = (TString *)gROOT->ProcessLine(""TMVA::Python_Executable()"");; TString python_exe = (ret) ? *(ret) : ""python"";; gSystem->Exec(python_exe + "" make_rnn_model.py"");; ; if (gSystem->AccessPathName(modelName)) {; Warning(""TMVA_RNN_Classification"", ""Error creating Keras recurrent model file - Skip using Keras"");; useKeras = false;; } else {; // book PyKeras method only if Keras model could be created; Info(""TMVA_RNN_Classification"", ""Booking Keras %s model"", rnn_types[i].c_str());; factory->BookMethod(dataloader, TMVA::Types::kPyKeras,; TString::Format(""PyKeras_%s"", rnn_types[i].c_str()),; TString::Format(""!H:!V:VarTransform=None:FilenameModel=%s:tf.keras:""; ""FilenameTrainedModel=%s:GpuOption",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__RNN__Classification_8C.html:69651,optimiz,optimizer,69651,doc/master/TMVA__RNN__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8C.html,1,['optimiz'],['optimizer']
Performance,"nting moment of function of given order. ;  ; virtual double offset () const;  ; bool operator== (const RooAbsArg &other) const override;  Equality operator when comparing to another RooAbsArg. ;  ; bool operator== (double value) const;  Equality operator comparing to a double. ;  ; virtual std::list< double > * plotSamplingHint (RooAbsRealLValue &obs, double xlo, double xhi) const;  Interface for returning an optional hint for initial sampling points when constructing a curve projected on observable obs. ;  ; virtual void preferredObservableScanOrder (const RooArgSet &obs, RooArgSet &orderedObs) const;  Interface method for function objects to indicate their preferred order of observables for scanning their values into a (multi-dimensional) histogram or RooDataSet. ;  ; void printValue (std::ostream &os) const override;  Print object value. ;  ; bool readFromStream (std::istream &is, bool compact, bool verbose=false) override;  Read object contents from stream (dummy for now) ;  ; void selectComp (bool flag);  ; void setCachedValue (double value, bool notifyClients=true) final;  Overwrite the value stored in this object's cache. ;  ; virtual bool setData (RooAbsData &, bool=true);  ; void setIntegratorConfig ();  Remove the specialized numeric integration configuration associated with this object. ;  ; void setIntegratorConfig (const RooNumIntConfig &config);  Set the given integrator configuration as default numeric integration configuration for this object. ;  ; void setParameterizeIntegral (const RooArgSet &paramVars);  ; void setPlotLabel (const char *label);  Set the label associated with this variable. ;  ; void setUnit (const char *unit);  ; RooAbsMoment * sigma (RooRealVar &obs);  ; RooAbsMoment * sigma (RooRealVar &obs, const RooArgSet &nset);  ; RooNumIntConfig * specialIntegratorConfig () const;  Returns the specialized integrator configuration for this RooAbsReal. ;  ; RooNumIntConfig * specialIntegratorConfig (bool createOnTheFly);  Returns the special",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooGaussModel.html:29045,cache,cache,29045,doc/master/classRooGaussModel.html,https://root.cern,https://root.cern/doc/master/classRooGaussModel.html,5,['cache'],['cache']
Performance,"ntinue;; 1258 ; 1259 if (GlobalIndex && KnownModuleFileNames.count(FullASTFilePath)); 1260 continue;; 1261 ; 1262 if (M->IsUnimportable); 1263 continue;; 1264 ; 1265 if (GlobalIndex); 1266 LoadModule(M->Name, clingInterp);; 1267 else {; 1268 // FIXME: We may be able to remove those checks as cling::loadModule; 1269 // checks if a module was alredy loaded.; 1270 if (std::find(CoreModules.begin(), CoreModules.end(), M->Name) != CoreModules.end()); 1271 continue; // This is a core module which was already loaded.; 1272 ; 1273 // Load system modules now and delay the other modules after we have; 1274 // loaded all system ones.; 1275 if (M->IsSystem); 1276 LoadModule(M->Name, clingInterp);; 1277 else; 1278 PendingModules.push_back(M->Name);; 1279 }; 1280 }; 1281 LoadModules(PendingModules, clingInterp);; 1282 }; 1283 ; 1284 // Check that the gROOT macro was exported by any core module.; 1285 assert(clingInterp.getMacro(""gROOT"") && ""Couldn't load gROOT macro?"");; 1286 ; 1287 // `ERROR` and `PI` are from loading R related modules, which conflict with; 1288 // user's code.; 1289 clingInterp.declare(R""CODE(; 1290#ifdef PI; 1291# undef PI; 1292#endif; 1293#ifdef ERROR; 1294# undef ERROR; 1295#endif; 1296 )CODE"");; 1297}; 1298 ; 1299static void RegisterPreIncludedHeaders(cling::Interpreter &clingInterp); 1300{; 1301 std::string PreIncludes;; 1302 bool hasCxxModules = clingInterp.getCI()->getLangOpts().Modules;; 1303 ; 1304 // For the list to also include string, we have to include it now.; 1305 // rootcling does parts already if needed, e.g. genreflex does not want using; 1306 // namespace std.; 1307 if (IsFromRootCling()) {; 1308 PreIncludes += ""#include \""RtypesCore.h\""\n"";; 1309 } else {; 1310 if (!hasCxxModules); 1311 PreIncludes += ""#include \""Rtypes.h\""\n"";; 1312 ; 1313 PreIncludes += gClassDefInterpMacro + ""\n""; 1314 + gInterpreterClassDef + ""\n""; 1315 ""#undef ClassImp\n""; 1316 ""#define ClassImp(X);\n"";; 1317 }; 1318 if (!hasCxxModules); 1319 PreIncludes += ""#include <s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:46523,load,load,46523,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,2,['load'],"['load', 'loading']"
Performance,"ntral, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooJeffreysPrior&operator=(const RooJeffreysPrior&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); const RooArgList&paramList() const; virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooJeffreysPrior.html:22883,optimiz,optimizeCacheMode,22883,root/html602/RooJeffreysPrior.html,https://root.cern,https://root.cern/root/html602/RooJeffreysPrior.html,8,['optimiz'],['optimizeCacheMode']
Performance,"ntries = -1, Long64_t firstentry = 0); Execute the specified drawing action on a data set (TDSet).; Event- or Entry-lists should be set in the data set object using; TDSet::SetEntryList.; Returns -1 in case of error or number of selected events otherwise. Long64_t Process(TDSet* dset, const char* sel, Option_t* o = """", Long64_t nent = -1, Long64_t fst = 0); Process a data set (TDSet) using the specified selector (.C) file.; Entry- or event-lists should be set in the data set object using; TDSet::SetEntryList.; The return value is -1 in case of error and TSelector::GetStatus() in; in case of success. Int_t CreateSymLinks(TList* files, TList* wrks = 0); Create in each worker sandbox symlinks to the files in the list; Used to make the cache information available to workers. Int_t InitDataSetManager(); Initialize the dataset manager from directives or from defaults; Return 0 on success, -1 on failure. void ShowCache(Bool_t all = kFALSE); List contents of file cache. If all is true show all caches also on; slaves. If everything is ok all caches are to be the same. void ClearCache(const char* file = 0); Remove files from all file caches. Int_t Load(const char* macro, Bool_t notOnClient = kFALSE, Bool_t uniqueOnly = kTRUE, TList* wrks = 0); Copy the specified macro in the cache directory. The macro file is; uploaded if new or updated. If existing, the corresponding header; basename(macro).h or .hh, is also uploaded. For the other arguments; see TProof::Load().; Returns 0 in case of success and -1 in case of error. Int_t CopyMacroToCache(const char* macro, Int_t headerRequired = 0, TSelector** selector = 0, Int_t opt = 0, TList* wrks = 0); Copy a macro, and its possible associated .h[h] file,; to the cache directory, from where the workers can get the file.; If headerRequired is 1, return -1 in case the header is not found.; If headerRequired is 0, try to copy header too.; If headerRequired is -1, don't look for header, only copy macro.; If the selector pionter is not 0, co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofLite.html:31296,cache,caches,31296,root/html534/TProofLite.html,https://root.cern,https://root.cern/root/html534/TProofLite.html,4,['cache'],['caches']
Performance,"ntries = 1000000000, Long64_t firstentry = 0)MENU ; virtual Bool_tTTree::SetAlias(const char* aliasName, const char* aliasFormula); virtual voidSetAutoDelete(Bool_t autodel = kTRUE); virtual voidTTree::SetAutoFlush(Long64_t autof = -30000000); virtual voidTTree::SetAutoSave(Long64_t autos = -300000000); virtual voidTTree::SetBasketSize(const char* bname, Int_t buffsize = 16000); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual Int_tSetBranchAddress(const char* bname, void* add, TClass* realClass, EDataType datatype, Bool_t isptr); virtual Int_tSetBranchAddress(const char* bname, void* add, TBranch** ptr, TClass* realClass, EDataType datatype, Bool_t isptr); virtual voidSetBranchStatus(const char* bname, Bool_t status = 1, UInt_t* found = 0); static voidTTree::SetBranchStyle(Int_t style = 1); virtual voidTTree::SetCacheEntryRange(Long64_t first, Long64_t last); virtual voidTTree::SetCacheLearnEntries(Int_t n = 10); virtual voidSetCacheSize(Long64_t cacheSize); virtual voidTTree::SetChainOffset(Long64_t offset = 0); virtual voidTTree::SetCircular(Long64_t maxEntries); virtual voidTTree::SetDebug(Int_t level = 1, Long64_t min = 0, Long64_t max = 9999999)MENU ; virtual voidTTree::SetDefaultEntryOffsetLen(Int_t newdefault, Bool_t updateExisting = kFALSE); virtual voidSetDirectory(TDirectory* dir); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual Long64_tTTree::SetEntries(Long64_t n = -1); virtual voidSetEntryList(TEntryList* elist, Option_t* opt = """"); virtual voidSetEntryListFile(const char* filename = """", Option_t* opt = """"); virtual voidTTree::SetEstimate(Long64_t nentries = 1000000); virtual voidSetEventList(TEventList* evlist); virtual voidTTree::SetFileNumber(Int_t number = 0); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillColorAlpha(Color_t fcolor, Float_t falpha); virtual voidTAttFil",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TChain.html:16363,cache,cacheSize,16363,root/html534/TChain.html,https://root.cern,https://root.cern/root/html534/TChain.html,2,['cache'],['cacheSize']
Performance,ntries to estimate histogram limits; 103 Long64_t *fClusterRangeEnd; ///<[fNClusterRange] Last entry of a cluster range.; 104 Long64_t *fClusterSize; ///<[fNClusterRange] Number of entries in each cluster for a given range.; 105 Long64_t fCacheSize; ///<! Maximum size of file buffers; 106 Long64_t fChainOffset; ///<! Offset of 1st entry of this Tree in a TChain; 107 Long64_t fReadEntry; ///<! Number of the entry being processed; 108 std::atomic<Long64_t> fTotalBuffers; ///<! Total number of bytes in branch buffers; 109 Int_t fPacketSize; ///<! Number of entries in one packet for parallel root; 110 Int_t fNfill; ///<! Local for EntryLoop; 111 Int_t fDebug; ///<! Debug level; 112 Long64_t fDebugMin; ///<! First entry number to debug; 113 Long64_t fDebugMax; ///<! Last entry number to debug; 114 TIOFeatures fIOFeatures{0}; ///< IO features to define for newly-written baskets and branches.; 115 Int_t fMakeClass; ///<! not zero when processing code generated by MakeClass; 116 Int_t fFileNumber; ///<! current file number (if file extensions); 117 /// Object to be notified when loading a Tree.; 118 /// TTree::LoadTree() and TChain::LoadTree() will call fNotify->Notify().; 119 /// Usually points to a TNotifyLink if this is a TChain.; 120 TObject *fNotify; //!; 121 TDirectory *fDirectory; ///<! Pointer to directory holding this tree; 122 TObjArray fBranches; ///< List of Branches; 123 TObjArray fLeaves; ///< Direct pointers to individual branch leaves; 124 TList *fAliases; ///< List of aliases for expressions based on the tree branches.; 125 TEventList *fEventList; ///<! Pointer to event selection list (if one); 126 TEntryList *fEntryList; ///<! Pointer to event selection list (if one); 127 TArrayD fIndexValues; ///< Sorted index values; 128 TArrayI fIndex; ///< Index of sorted values; 129 TVirtualIndex *fTreeIndex; ///< Pointer to the tree Index (if any); 130 TList *fFriends; ///< pointer to list of friend elements; 131 TList *fExternalFriends; ///<! List of TFriendsElement ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8h_source.html:4939,load,loading,4939,doc/master/TTree_8h_source.html,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html,1,['load'],['loading']
Performance,"ntries. ; Returns-1 in case of error or number of selected events in case of success.; This function accepts TCut objects as arguments. Useful to use the string operator +; Example:; ntuple.Draw(""x"",cut1+cut2+cut3);. Reimplemented in TChain, and TProofChain.; Definition at line 3855 of file TTree.cxx. ◆ Draw() [3/3]. void TTree::Draw ; (; Option_t * ; option). inlineoverridevirtual . Default Draw method for all objects. ; Reimplemented from TObject.; Definition at line 431 of file TTree.h. ◆ DropBaskets(). void TTree::DropBaskets ; (; ). virtual . Remove some baskets from memory. ; Definition at line 4518 of file TTree.cxx. ◆ DropBranchFromCache() [1/2]. Int_t TTree::DropBranchFromCache ; (; const char * ; bname, . bool ; subbranches = false . ). virtual . Remove the branch with name 'bname' from the Tree cache. ; If bname=""*"" all branches are removed from the cache. if subbranches is true all the branches of the subbranches are also removed from the cache.; Returns:; 0 branch dropped or not in cache; -1 on error . Definition at line 1142 of file TTree.cxx. ◆ DropBranchFromCache() [2/2]. Int_t TTree::DropBranchFromCache ; (; TBranch * ; b, . bool ; subbranches = false . ). virtual . Remove the branch b from the Tree cache. ; if subbranches is true all the branches of the subbranches are also removed from the cache.; Returns:; 0 branch dropped or not in cache; -1 on error . Definition at line 1181 of file TTree.cxx. ◆ DropBuffers(). void TTree::DropBuffers ; (; Int_t ; nbytes). virtual . Drop branch buffers to accommodate nbytes below MaxVirtualsize. ; Definition at line 4531 of file TTree.cxx. ◆ EnableCache(). bool TTree::EnableCache ; (; ). Enable the TTreeCache unless explicitly disabled for this TTree by a prior call to SetCacheSize(0). ; If the environment variable ROOT_TTREECACHE_SIZE or the rootrc config TTreeCache.Size has been set to zero, this call will over-ride them with a value of 1.0 (i.e. use a cache size to hold 1 cluster); Return true if there is a ca",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTree.html:137472,cache,cache,137472,doc/v632/classTTree.html,https://root.cern,https://root.cern/doc/v632/classTTree.html,2,['cache'],['cache']
Performance,"ntries[i].file_name);; 9716 }; 9717 mg_free(data.entries);; 9718 }; 9719 ; 9720 mg_printf(conn, ""%s"", ""</table></pre></body></html>"");; 9721 conn->status_code = 200;; 9722}; 9723#endif /* NO_FILESYSTEMS */; 9724 ; 9725 ; 9726/* Send len bytes from the opened file to the client. */; 9727static void; 9728send_file_data(struct mg_connection *conn,; 9729 struct mg_file *filep,; 9730 int64_t offset,; 9731 int64_t len); 9732{; 9733 char buf[MG_BUF_LEN];; 9734 int to_read, num_read, num_written;; 9735 int64_t size;; 9736 ; 9737 if (!filep || !conn) {; 9738 return;; 9739 }; 9740 ; 9741 /* Sanity check the offset */; 9742 size = (filep->stat.size > INT64_MAX) ? INT64_MAX; 9743 : (int64_t)(filep->stat.size);; 9744 offset = (offset < 0) ? 0 : ((offset > size) ? size : offset);; 9745 ; 9746 if (len > 0 && filep->access.fp != NULL) {; 9747 /* file stored on disk */; 9748#if defined(__linux__); 9749 /* sendfile is only available for Linux */; 9750 if ((conn->ssl == 0) && (conn->throttle == 0); 9751 && (!mg_strcasecmp(conn->dom_ctx->config[ALLOW_SENDFILE_CALL],; 9752 ""yes""))) {; 9753 off_t sf_offs = (off_t)offset;; 9754 ssize_t sf_sent;; 9755 int sf_file = fileno(filep->access.fp);; 9756 int loop_cnt = 0;; 9757 ; 9758 do {; 9759 /* 2147479552 (0x7FFFF000) is a limit found by experiment on; 9760 * 64 bit Linux (2^31 minus one memory page of 4k?). */; 9761 size_t sf_tosend =; 9762 (size_t)((len < 0x7FFFF000) ? len : 0x7FFFF000);; 9763 sf_sent =; 9764 sendfile(conn->client.sock, sf_file, &sf_offs, sf_tosend);; 9765 if (sf_sent > 0) {; 9766 len -= sf_sent;; 9767 offset += sf_sent;; 9768 } else if (loop_cnt == 0) {; 9769 /* This file can not be sent using sendfile.; 9770 * This might be the case for pseudo-files in the; 9771 * /sys/ and /proc/ file system.; 9772 * Use the regular user mode copy code instead. */; 9773 break;; 9774 } else if (sf_sent == 0) {; 9775 /* No error, but 0 bytes sent. May be EOF? */; 9776 return;; 9777 }; 9778 loop_cnt++;; 9779 ; 9780 } while ((len > 0) && (sf_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:279213,throttle,throttle,279213,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['throttle'],['throttle']
Performance,"ntries[i].file_name);; 9717 }; 9718 mg_free(data.entries);; 9719 }; 9720 ; 9721 mg_printf(conn, ""%s"", ""</table></pre></body></html>"");; 9722 conn->status_code = 200;; 9723}; 9724#endif /* NO_FILESYSTEMS */; 9725 ; 9726 ; 9727/* Send len bytes from the opened file to the client. */; 9728static void; 9729send_file_data(struct mg_connection *conn,; 9730 struct mg_file *filep,; 9731 int64_t offset,; 9732 int64_t len); 9733{; 9734 char buf[MG_BUF_LEN];; 9735 int to_read, num_read, num_written;; 9736 int64_t size;; 9737 ; 9738 if (!filep || !conn) {; 9739 return;; 9740 }; 9741 ; 9742 /* Sanity check the offset */; 9743 size = (filep->stat.size > INT64_MAX) ? INT64_MAX; 9744 : (int64_t)(filep->stat.size);; 9745 offset = (offset < 0) ? 0 : ((offset > size) ? size : offset);; 9746 ; 9747 if (len > 0 && filep->access.fp != NULL) {; 9748 /* file stored on disk */; 9749#if defined(__linux__); 9750 /* sendfile is only available for Linux */; 9751 if ((conn->ssl == 0) && (conn->throttle == 0); 9752 && (!mg_strcasecmp(conn->dom_ctx->config[ALLOW_SENDFILE_CALL],; 9753 ""yes""))) {; 9754 off_t sf_offs = (off_t)offset;; 9755 ssize_t sf_sent;; 9756 int sf_file = fileno(filep->access.fp);; 9757 int loop_cnt = 0;; 9758 ; 9759 do {; 9760 /* 2147479552 (0x7FFFF000) is a limit found by experiment on; 9761 * 64 bit Linux (2^31 minus one memory page of 4k?). */; 9762 size_t sf_tosend =; 9763 (size_t)((len < 0x7FFFF000) ? len : 0x7FFFF000);; 9764 sf_sent =; 9765 sendfile(conn->client.sock, sf_file, &sf_offs, sf_tosend);; 9766 if (sf_sent > 0) {; 9767 len -= sf_sent;; 9768 offset += sf_sent;; 9769 } else if (loop_cnt == 0) {; 9770 /* This file can not be sent using sendfile.; 9771 * This might be the case for pseudo-files in the; 9772 * /sys/ and /proc/ file system.; 9773 * Use the regular user mode copy code instead. */; 9774 break;; 9775 } else if (sf_sent == 0) {; 9776 /* No error, but 0 bytes sent. May be EOF? */; 9777 return;; 9778 }; 9779 loop_cnt++;; 9780 ; 9781 } while ((len > 0) && (sf_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:279245,throttle,throttle,279245,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['throttle'],['throttle']
Performance,"ntry #index; See also Next() for a faster alternative. Long64_t GetEntryAndTree(Int_t index, Int_t& treenum); return the entry corresponding to the index parameter and the; number of the tree, where this entry is. Long64_t GetEntries(); Returns the total number of entries in the list.; If some lists have not been loaded, loads them. Long64_t Next(); Returns the next entry in the list.; Faster than GetEntry(). Int_t LoadList(Int_t listnumber); Loads the list #listnumber; This is the only function that can modify fCurrent and fFile data members. void Print(const Option_t* option = """") const; Print info about this list. TEntryListFromFile(const TEntryListFromFile& ). TEntryListFromFile & operator=(const TEntryListFromFile& ). void Add(const TEntryList* ); {}. Int_t Contains(Long64_t , TTree* ); {return 0;}. Bool_t Enter(Long64_t , TTree* ); {return 0;}. TEntryList * GetCurrentList() const; { return fCurrent; }. TEntryList * GetEntryList(const char* , const char* , Option_t* ); {return 0;}. Long64_t GetEntriesFast() const; { return fN; }. Long64_t GetN() const; { return fN; }. const char * GetTreeName() const; { return fTreeName.Data(); }. const char * GetFileName() const; { return fFileName.Data(); }. Int_t GetTreeNumber() const; { return fTreeNumber; }. Int_t Merge(TCollection* ); { return 0; }. void OptimizeStorage(); {}. Bool_t Remove(Long64_t , TTree* ); { return 0; }. void SetTree(const TTree* ); {}. void SetTree(const char* , const char* ); {}. void SetFileNames(TObjArray* names); { fFileNames = names; }. void SetTreeNumber(Int_t index); { fTreeNumber=index; }. void SetNFiles(Int_t nfiles); { fNFiles = nfiles; }. void Subtract(const TEntryList* ); {}. » Author: Anna Kreshuk 17/03/2007 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id$ » Last generated: 2015-06-02 15:42; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TEntryListFromFile.html:12420,Optimiz,OptimizeStorage,12420,root/html604/TEntryListFromFile.html,https://root.cern,https://root.cern/root/html604/TEntryListFromFile.html,1,['Optimiz'],['OptimizeStorage']
Performance,"ntry #index; See also Next() for a faster alternative. Long64_t GetEntryAndTree(Int_t index, Int_t& treenum); return the entry corresponding to the index parameter and the; number of the tree, where this entry is. Long64_t GetEntries(); Returns the total number of entries in the list.; If some lists have not been loaded, loads them. Long64_t Next(); Returns the next entry in the list.; Faster than GetEntry(). Int_t LoadList(Int_t listnumber); Loads the list #listnumber; This is the only function that can modify fCurrent and fFile data members. void Print(const Option_t* option = """") const; Print info about this list. TEntryListFromFile(const TEntryListFromFile& ). TEntryListFromFile & operator=(const TEntryListFromFile& ). void Add(const TEntryList* ); {}. Int_t Contains(Long64_t , TTree* ); {return 0;}. Bool_t Enter(Long64_t , TTree* ); {return 0;}. TEntryList * GetCurrentList() const; { return fCurrent; }. TEntryList * GetEntryList(const char* , const char* , Option_t* ); {return 0;}. Long64_t GetEntriesFast() const; { return fN; }. Long64_t GetN() const; { return fN; }. const char * GetTreeName() const; { return fTreeName.Data(); }. const char * GetFileName() const; { return fFileName.Data(); }. Int_t GetTreeNumber() const; { return fTreeNumber; }. Int_t Merge(TCollection* ); { return 0; }. void OptimizeStorage(); {}. Bool_t Remove(Long64_t , TTree* ); { return 0; }. void SetTree(const TTree* ); {}. void SetTree(const char* , const char* ); {}. void SetFileNames(TObjArray* names); { fFileNames = names; }. void SetTreeNumber(Int_t index); { fTreeNumber=index; }. void SetNFiles(Int_t nfiles); { fNFiles = nfiles; }. void Subtract(const TEntryList* ); {}. » Author: Anna Kreshuk 17/03/2007 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id$ » Last generated: 2015-06-30 14:43; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEntryListFromFile.html:12420,Optimiz,OptimizeStorage,12420,root/html602/TEntryListFromFile.html,https://root.cern,https://root.cern/root/html602/TEntryListFromFile.html,1,['Optimiz'],['OptimizeStorage']
Performance,"ntry=0)=0; TVirtualTreePlayer::SetEstimatevirtual void SetEstimate(Long64_t n)=0; TVirtualTreePlayer::TreePlayerstatic TVirtualTreePlayer * TreePlayer(TTree *obj)Static function returning a pointer to a Tree player.Definition TVirtualTreePlayer.cxx:35; TVirtualTreePlayer::MakeClassvirtual Int_t MakeClass(const char *classname, const char *option)=0; TVirtualTreePlayer::Fitvirtual Int_t Fit(const char *formula, const char *varexp, const char *selection, Option_t *option, Option_t *goption, Long64_t nentries, Long64_t firstentry)=0; double; int; unsigned int; lineTLine * lineDefinition entrylistblock_figure1.C:235; nconst Int_t nDefinition legend1.C:16; ROOT::DetailSpecial implementation of ROOT::RRangeCast for TCollection, including a check that the cast target ty...Definition TObject.h:387; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; ROOT::IsImplicitMTEnabledBool_t IsImplicitMTEnabled()Returns true if the implicit multi-threading in ROOT is enabled.Definition TROOT.cxx:570; ROOT::ESTLTypeESTLTypeDefinition ESTLType.h:28; ROOT::kSTLmap@ kSTLmapDefinition ESTLType.h:33; ROOT::kSTLmultimap@ kSTLmultimapDefinition ESTLType.h:34; ROOT::CallRecursiveRemoveIfNeededvoid CallRecursiveRemoveIfNeeded(TObject &obj)call RecursiveRemove for obj if gROOT is valid and obj.TestBit(kMustCleanup) is true.Definition TROOT.h:395; ROOT::ToHumanReadableSizevoid ToHumanReadableSize(value_type bytes, Bool_t si, Double_t *coeff, const char **units)Return the size expressed in 'human readable' format.Definition StringConv.hxx:38; ROOT::FromHumanReadableSizeEFromHumanReadableSize FromHumanReadableSize(std::string_view str, T &value)Convert strings like the following into byte counts 5MB, 5 MB, 5M, 3.7GB, 123b, 456kB,...Definition StringConv.hxx:86; ROOT::EFromHumanReadableSize::kParseFail@ kParseFail; ROOT::EFromHumanReadableSize::kOverflow@ kOverflow; TMath::MaxShort_t Max(Short_t a, Short_t b)R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:472552,multi-thread,multi-threading,472552,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['multi-thread'],['multi-threading']
Performance,"ntryList is set, this function is equivalent to SetEntry().; Parameters. entryEntry number of the TChain's current TTree. This is the entry number passed for instance by TSelector::Process(entry), i.e. within TSelector::Process() always use SetLocalEntry() and not SetEntry()! . Returnsthe entry's read status, i.e. whether the entry is available. ; Definition at line 235 of file TTreeReader.h. ◆ SetProxies(). bool TTreeReader::SetProxies ; (; ). protected . Tell readers we now have a tree. ; fValues gets insertions during this loop (when parametrized arrays are read), invalidating iterators. Use old-school counting instead. ; Definition at line 376 of file TTreeReader.cxx. ◆ SetTree() [1/3]. void TTreeReader::SetTree ; (; const char * ; keyname, . TDirectory * ; dir, . TEntryList * ; entryList = nullptr . ). Set (or update) the which tree to read from, passing the name of a tree in a directory. ; Parameters. keyname- name of the tree in dir ; dir- the TDirectory to load keyname from (or gDirectory if nullptr) ; entryList- the TEntryList to attach to the TTreeReader. . Definition at line 846 of file TTreeReader.cxx. ◆ SetTree() [2/3]. void TTreeReader::SetTree ; (; const char * ; keyname, . TEntryList * ; entryList = nullptr . ). inline . Definition at line 198 of file TTreeReader.h. ◆ SetTree() [3/3]. void TTreeReader::SetTree ; (; TTree * ; tree, . TEntryList * ; entryList = nullptr . ). Set (or update) the which tree to read from. ; tree can be a TTree or a TChain. ; Definition at line 806 of file TTreeReader.cxx. ◆ Streamer(). void TTreeReader::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void TTreeReader::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 356 of file TTreeReader.h. ◆ WarnIfFriendsHaveMoreEntries(). void TTreeReader::WarnIfFriendsHaveMoreEntries ; (; ). private . Definition at line 440 of file TTreeReader.cxx. Friend",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeReader.html:34140,load,load,34140,doc/master/classTTreeReader.html,https://root.cern,https://root.cern/doc/master/classTTreeReader.html,1,['load'],['load']
Performance,"nts (in RooFit jargon, ""if the pdf can be extended"").; Passing Extended(true) when the the pdf makes no prediction on the expected number of events will result in error messages, and the chi2 will fall back to the total data weight to scale the normalized pdf.; There are cases where the fit must be done in extended mode. This happens for example when you have a RooAddPdf where the coefficients represent component yields. If the fit is not extended, these coefficients will not be well-defined, as the RooAddPdf always normalizes itself. If you pass Extended(false) in such a case, an error will be printed and you'll most likely get garbage results. . Range(const char* name) Fit only data inside range with given name . Range(double lo, double hi) Fit only data inside given range. A range named ""fit"" is created on the fly on all observables. Multiple comma separated range names can be specified. . NumCPU(int num) Parallelize NLL calculation on num CPUs . Optimize(bool flag) Activate constant term optimization (on by default) . IntegrateBins() Integrate PDF within each bin. This sets the desired precision. Options to control flow of fit procedure . InitialHesse(bool flag) Flag controls if HESSE before MIGRAD as well, off by default . Hesse(bool flag) Flag controls if HESSE is run after MIGRAD, on by default . Minos(bool flag) Flag controls if MINOS is run after HESSE, on by default . Minos(const RooArgSet& set) Only run MINOS on given subset of arguments . Save(bool flag) Flag controls if RooFitResult object is produced and returned, off by default . Strategy(Int_t flag) Set Minuit strategy (0 through 2, default is 1). Options to control informational output . Verbose(bool flag) Flag controls if verbose output is printed (NLL, parameter changes during fit . Timer(bool flag) Time CPU and wall clock consumption of fit steps, off by default . PrintLevel(Int_t level) Set Minuit print level (-1 through 3, default is 1). At -1 all RooFit informational messages are suppressed as",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAbsReal.html:70831,optimiz,optimization,70831,doc/v632/classRooAbsReal.html,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html,2,['optimiz'],['optimization']
Performance,nts ; Definition at line 99 of file RooAddModel.h. ◆ _coefErrCount. Int_t RooAddModel::_coefErrCount. mutableprotected . ! Coefficient error counter ; Definition at line 125 of file RooAddModel.h. ◆ _coefList. RooListProxy RooAddModel::_coefList. protected . List of coefficients. ; Definition at line 119 of file RooAddModel.h. ◆ _haveLastCoef. bool RooAddModel::_haveLastCoef = false. protected . Flag indicating if last PDFs coefficient was supplied in the constructor. ; Definition at line 122 of file RooAddModel.h. ◆ _intCacheMgr. RooObjCacheManager RooAddModel::_intCacheMgr. mutableprotected . ! Manager of cache with integrals ; Definition at line 114 of file RooAddModel.h. ◆ _ownedComps. RooArgSet RooAddModel::_ownedComps. mutableprotected . ! Owned components ; Definition at line 127 of file RooAddModel.h. ◆ _pdfList. RooListProxy RooAddModel::_pdfList. protected . List of component PDFs. ; Definition at line 118 of file RooAddModel.h. ◆ _projCacheMgr. RooObjCacheManager RooAddModel::_projCacheMgr. mutableprotected . ! Manager of cache with coefficient projections and transformations ; Definition at line 102 of file RooAddModel.h. ◆ _refCoefNorm. RooSetProxy RooAddModel::_refCoefNorm. mutableprotected . ! Reference observable set for coefficient interpretation ; Definition at line 96 of file RooAddModel.h. ◆ _refCoefRangeName. TNamed* RooAddModel::_refCoefRangeName = nullptr. mutableprotected . ! Reference range name for coefficient interpretation ; Definition at line 97 of file RooAddModel.h. ◆ _snormList. RooArgList* RooAddModel::_snormList {nullptr}. mutableprotected . ! List of supplemental normalization factors ; Definition at line 120 of file RooAddModel.h. Libraries for RooAddModel:. [legend]; The documentation for this class was generated from the following files:; roofit/roofitcore/inc/RooAddModel.h; roofit/roofitcore/src/RooAddModel.cxx. RooAddModel. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:43 (GVA Time) using Doxygen 1.9.8   ; . ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAddModel.html:92615,cache,cache,92615,doc/master/classRooAddModel.html,https://root.cern,https://root.cern/doc/master/classRooAddModel.html,1,['cache'],['cache']
Performance,"nts TBuffer.; Reimplemented in TBufferSQL.; Definition at line 307 of file TBufferFile.h. ◆ WriteLong(). void TBufferFile::WriteLong ; (; Long_t ; l). inlineoverridevirtual . Implements TBuffer.; Reimplemented in TBufferSQL.; Definition at line 321 of file TBufferFile.h. ◆ WriteLong64(). void TBufferFile::WriteLong64 ; (; Long64_t ; l). inlineoverridevirtual . Implements TBuffer.; Reimplemented in TBufferSQL.; Definition at line 335 of file TBufferFile.h. ◆ WriteObjectClass(). void TBufferFile::WriteObjectClass ; (; const void * ; actualObjectStart, . const TClass * ; actualClass, . Bool_t ; cacheReuse . ). overrideprotectedvirtual . Write object to I/O buffer. ; This function assumes that the value of 'actualObjectStart' is the actual start of the object of class 'actualClass' If 'cacheReuse' is true (default) upon seeing an object address a second time, we record the offset where its was written the first time rather than streaming the object a second time. If 'cacheReuse' is false, we always stream the object. This allows the (re)use of temporary object to store different data in the same buffer. ; Implements TBufferIO.; Definition at line 2658 of file TBufferFile.cxx. ◆ WriteShort(). void TBufferFile::WriteShort ; (; Short_t ; s). inlineoverridevirtual . Implements TBuffer.; Reimplemented in TBufferSQL.; Definition at line 293 of file TBufferFile.h. ◆ WriteStdString() [1/3]. void TBufferFile::WriteStdString ; (; const std::string * ; s). overridevirtual . Write std::string to TBuffer. ; Implements TBuffer.; Reimplemented in TBufferSQL, and TBufferSQL.; Definition at line 262 of file TBufferFile.cxx. ◆ WriteStdString() [2/3]. virtual void TBuffer::WriteStdString ; (; const std::string * ; s). virtual . Implements TBuffer.; Reimplemented in TBufferSQL, and TBufferSQL. ◆ WriteStdString() [3/3]. virtual void TBuffer::WriteStdString ; (; std::string & ; s). inlinevirtual . Reimplemented from TBuffer.; Reimplemented in TBufferSQL.; Definition at line 312 of file TBuffe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBufferFile.html:92723,cache,cacheReuse,92723,doc/master/classTBufferFile.html,https://root.cern,https://root.cern/doc/master/classTBufferFile.html,1,['cache'],['cacheReuse']
Performance,"nts for the classes used in the script. Once you did that, you can build and load a shared library containing your script. To load it use the command .L and append the file name with a +.; root[] .L MyScript.C+; The + option generates the shared library and names it by taking the name of the file “filename” but replacing the dot before the extension by an underscore and by adding the shared library extension for the current platform. For example on most platforms, hsimple.cxx will generate hsimple_cxx.so.; The + command rebuild the library only if the script or any of the files it includes are newer than the library. When checking the timestamp, ACLiC generates a dependency file which name is the same as the library name, just replacing the ‘so’ extension by the extension ‘d’. For example on most platforms, hsimple.cxx will generate hsimple_cxx.d.; To ensure that the shared library is rebuilt you can use the ++ syntax:; root[] .L MyScript.C++; To build, load, and execute the function with the same name as the file you can use the .x command. This is the same as executing a named script; you can also provide parameters. The only difference is you need to append a + or a ++.; root[] .x MyScript.C+(4000); Creating shared library /home/./MyScript_C.so; You can select whether the script in compiled with debug symbol or with optimization by appending the letter ‘g’ or ‘O’ after the ‘+’ or ‘++’. Without the specification, the script is compiled with the same level of debugging symbol and optimization as the currently running ROOT executable. For example:; root[] .L MyScript.C++g; will compile MyScript.C with debug symbols; usually this means giving the -g option to compiler.; root[] .L MyScript.C++O; will compile MyScript.C with optimizations; usually this means giving the -O option to compiler. The syntax:; root[] .L MyScript.C++; is using the default optimization level. The initial default is to compile with the same level of optimization as the root executable itself. T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:269870,load,load,269870,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['load'],['load']
Performance,nts that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooAICRegistryRooAbsAnaConvPdf::_codeReg! Registry of analytical integration codes; RooObjCacheManagerRooAbsAnaConvPdf::_coefNormMgrCoefficient normalization manager; RooArgSet*RooAbsAnaConvPdf::_convNormSet! Subset of last normalization that applies to convolutions; RooListProxyRooAbsAnaConvPdf::_convSetSet of (resModel (x) basisFunc) convolution objects; TIterator*RooAbsAnaConvPdf::_convSetIter! Iterator over _convNormSet; RooRealVar*RooAbsAnaConvPdf::_convVar! Convolution variable; RooRealProxy_correctQ; RooRealProxy_delC; RooRealProxy_delS; RooRealProxy_delW; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooRealProxy_dm; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; Double_t_genB0Frac; Double_t_genRhoPlusFrac; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsAnaConvPdf::_isCopy; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooNonCPEigenDecay.html:39219,cache,cache,39219,root/html526/RooNonCPEigenDecay.html,https://root.cern,https://root.cern/root/html526/RooNonCPEigenDecay.html,5,['cache'],['cache']
Performance,"nts!total number of events to be processed; TList*fOutput!Saved pointer to the output list ; TH1D*fPacketsHist!histogram of packets processed per slave; TPerfEvent*fPerfEvent!TPerfEvent used to fill tree; TH2D*fProcTimeHist!histogram of real time spent processing packets; Int_tfSlaves!number of active slaves; Long64_tfTotBytesRead!total bytes read on all slaves; Double_tfTotCpuTime!total cpu time of all slaves; Long64_tfTotEvents!total number of events processed; TTree*fTrace!TTree with trace events; TTimeStampfTzero!start time of this run; static Long_tfgResMemMax! Max resident memory used by this process; static Long_tfgVirtMemMax! Max virtual memory used by this process. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPerfStats(TList* input, TList* output); Normal constructor. void SimpleEvent(TVirtualPerfStats::EEventType type); Simple event. void PacketEvent(const char* slave, const char* slavename, const char* filename, Long64_t eventsprocessed, Double_t latency, Double_t proctime, Double_t cputime, Long64_t bytesRead); Packet event.; See WriteQueryLog for the descripition of the structure sent for monitoring; when fMonitorPerPacket is kTRUE. void FileEvent(const char* slave, const char* slavename, const char* nodename, const char* filename, Bool_t isStart); File event. void FileOpenEvent(TFile* file, const char* filename, Double_t start); Open file event. void FileReadEvent(TFile* file, Int_t len, Double_t start); Read file event. void FileUnzipEvent(TFile* file, Long64_t pos, Double_t start, Int_t complen, Int_t objlen); Record TTree file unzip event.; start is the TimeStamp before unzip; pos is where in the file the compressed buffer came from; complen is the length of the compressed buffer; objlen is the length of the de-compressed buffer. void RateEvent(Double_t proctime, Double_t deltatime, Long64_t eventsprocessed, Long64_t bytesRead); Rate event. void SetBytesRead(Long64_t num); Set number of bytes read. Long6",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TPerfStats.html:8338,latency,latency,8338,root/html530/TPerfStats.html,https://root.cern,https://root.cern/root/html530/TPerfStats.html,1,['latency'],['latency']
Performance,"nts, Double_t offset, Double_t scale, UInt_t seed = 100); {; TRandom3 rng(seed);; Float_t x = 0;; Float_t y = 0;; UInt_t eventID = 0;; ; TTree *data = new TTree();; data->Branch(""x"", &x, ""x/F"");; data->Branch(""y"", &y, ""y/F"");; data->Branch(""eventID"", &eventID, ""eventID/I"");; ; for (Int_t n = 0; n < nPoints; ++n) {; x = rng.Gaus(offset, scale);; y = rng.Gaus(offset, scale);; ; // For our simple example it is enough that the id's are uniformly; // distributed and independent of the data.; ++eventID;; ; data->Fill();; }; ; // Important: Disconnects the tree from the memory locations of x and y.; data->ResetBranchAddresses();; return data;; }; ; int TMVACrossValidation(bool useRandomSplitting = false); {; // This loads the library; TMVA::Tools::Instance();; ; // --------------------------------------------------------------------------; ; // Load the data into TTrees. If you load data from file you can use a; // variant of; // ```; // TString filename = ""/path/to/file"";; // TFile * input = TFile::Open( filename );; // TTree * signalTree = (TTree*)input->Get(""TreeName"");; // ```; TTree *sigTree = genTree(1000, 1.0, 1.0, 100);; TTree *bkgTree = genTree(1000, -1.0, 1.0, 101);; ; // Create a ROOT output file where TMVA will store ntuples, histograms, etc.; TString outfileName(""TMVACV.root"");; TFile *outputFile = TFile::Open(outfileName, ""RECREATE"");; ; // DataLoader definitions; We declare variables in the tree so that TMVA can; // find them. For more information see TMVAClassification tutorial.; TMVA::DataLoader *dataloader = new TMVA::DataLoader(""datasetcv"");; ; // Data variables; dataloader->AddVariable(""x"", 'F');; dataloader->AddVariable(""y"", 'F');; ; // Spectator used for split; dataloader->AddSpectator(""eventID"", 'I');; ; // NOTE: Currently TMVA treats all input variables, spectators etc as; // floats. Thus, if the absolute value of the input is too large; // there can be precision loss. This can especially be a problem for; // cross validation with large event numbers",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVACrossValidation_8C.html:19984,load,load,19984,doc/master/TMVACrossValidation_8C.html,https://root.cern,https://root.cern/doc/master/TMVACrossValidation_8C.html,1,['load'],['load']
Performance,"nts. ;  ; bool clearObj (Int_t uniqueID);  Clear cache element with given unique ID Retrieve payload object of cache element with given unique ID. ;  ; bool empty () const;  ; const TObject * getObj (Int_t uniqueID);  Retrieve payload object of cache element with given unique ID. ;  ; void importCacheObjects (RooExpensiveObjectCache &other, const char *ownerName, bool verbose=false);  ; TClass * IsA () const override;  ; void print () const;  ; bool registerObject (const char *ownerName, const char *objectName, TObject &cacheObject, const RooArgSet &params);  Register object associated with given name and given associated parameters with given values in cache. ;  ; const TObject * retrieveObject (const char *name, TClass *tclass, const RooArgSet &params);  Retrieve object from cache that was registered under given name with given parameters, if current parameter values match those that were stored in the registry for this object. ;  ; bool setObj (Int_t uniqueID, TObject *obj);  Place new payload object in cache element with given unique ID. ;  ; Int_t size () const;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooExpensiveObjectCache.html:1959,cache,cache,1959,doc/master/classRooExpensiveObjectCache.html,https://root.cern,https://root.cern/doc/master/classRooExpensiveObjectCache.html,1,['cache'],['cache']
Performance,"ntsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. set<std::string>_boolAttribBoolean attributes; set<std::string>_boolAttribTransient! Transient boolean attributes (not copied in ctor); deque<RooAbsCache*>_cacheListlist of caches; RooRefCountList_clientListlist of client objects; RooRefCountList_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountList_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*_clientShapeIter! Iterator over _clientListShape ; TIterator*_clientValueIter! Iterator over _clientListValue ; Bool_t_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*_eocachePointer to global cache manager for any expensive components created by this object; static Bool_t_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; static Bool_t_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; static Int_tRooPrintable::_nameLength; RooAbsArg::OperMode_operModeDirty state propagation mode; RooArgSet*_ownedComponents! Set of owned component; Bool_t_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TList_proxyListlist of proxies; RooRefCountList_serverListlist of server objects; Bool_t_shapeDirtyFlag set if value needs recalculating because input shapes modified; map<std::string,std::string>_stringAttribString attributes; Bool_t_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_t_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsArg(); Destructor. void setDirtyInhibit(Bool_t flag); Control global dirty inhibit mode. When set to tru",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsArg.html:15926,cache,caches,15926,root/html526/RooAbsArg.html,https://root.cern,https://root.cern/root/html526/RooAbsArg.html,6,['cache'],"['cache', 'caches']"
Performance,ntsOptionRooPrintable::kTitle; static RooPrintable::StyleOptionRooPrintable::kTreeStructure; static RooPrintable::ContentsOptionRooPrintable::kValue; static RooPrintable::StyleOptionRooPrintable::kVerbose; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. set<string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_tRooAbsCategory::_byteValue! Transient cache for byte values from tree branches; deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; TIterator*_catIter! Iterator over set of input categories; RooSetProxy_catSetSet of input category; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Bool_tRooAbsArg::_isConstant! Cached isConstant status; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxy,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooSuperCategory.html:23441,cache,cache,23441,root/html602/RooSuperCategory.html,https://root.cern,https://root.cern/root/html602/RooSuperCategory.html,14,"['Cache', 'cache']","['Cached', 'cache', 'caches']"
Performance,"nty based on the variations.; # No computation graph was triggered yet, we trigger the computation graph for all histograms at once now,; # by calling 'histos_mc[""nominal""].GetXaxis()'.; # Note, in this case the uncertainties are symmetric.; for i in range(0, histos_mc[""nominal""].GetXaxis().GetNbins()):; (; histos_mc[""nominal""].SetBinError(; i, (histos_mc[""weight:up""].GetBinContent(i) - histos_mc[""nominal""].GetBinContent(i)); ); ); ; # Make the plot of the data, individual MC contributions and the total MC scale factor systematic variations.; ; # Set styles; ROOT.gROOT.SetStyle(""ATLAS""); ; # Create canvas with pad; c1 = ROOT.TCanvas(""c"", """", 600, 600); pad = ROOT.TPad(""upper_pad"", """", 0, 0, 1, 1); pad.SetTickx(False); pad.SetTicky(False); pad.Draw(); pad.cd(); ; # Draw stack with MC contributions; stack = ROOT.THStack(); ; # Retrieve values of the data and MC histograms in order to plot them.; # Draw cloned histograms to preserve graphics when original objects goes out of scope; # Note: GetValue() action operation is performed after all lazy actions of the RDF were defined first.; h_data = histos[0].GetValue().Clone(); h_higgs = histos[1].GetValue().Clone(); h_zz = histos[2].GetValue().Clone(); h_other = histos[3].GetValue().Clone(); ; for h, color in zip([h_other, h_zz, h_higgs], [ROOT.kViolet - 9, ROOT.kAzure - 9, ROOT.kRed + 2]):; h.SetLineWidth(1); h.SetLineColor(1); h.SetFillColor(color); stack.Add(h); ; stack.Draw(""HIST""); stack.GetXaxis().SetLabelSize(0.04); stack.GetXaxis().SetTitleSize(0.045); stack.GetXaxis().SetTitleOffset(1.3); stack.GetXaxis().SetTitle(""m_{4l}^{H#rightarrow ZZ} [GeV]""); stack.GetYaxis().SetLabelSize(0.04); stack.GetYaxis().SetTitleSize(0.045); stack.GetYaxis().SetTitle(""Events""); stack.SetMaximum(35); stack.GetYaxis().ChangeLabel(1, -1, 0); ; # Draw MC scale factor and variations; histos_mc[""nominal""].SetFillColor(ROOT.kBlack); histos_mc[""nominal""].SetFillStyle(3254); h_nominal = histos_mc[""nominal""].DrawClone(""E2 same""); histos_mc[""weig",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/df106__HiggsToFourLeptons_8py.html:9312,perform,performed,9312,doc/master/df106__HiggsToFourLeptons_8py.html,https://root.cern,https://root.cern/doc/master/df106__HiggsToFourLeptons_8py.html,1,['perform'],['performed']
Performance,"nu::TContextMenu ; (; ). private . ◆ TContextMenu() [3/3]. TContextMenu::TContextMenu ; (; const char * ; name, . const char * ; title = ""Context sensitive popup menu"" . ). Create a context menu. ; Definition at line 59 of file TContextMenu.cxx. ◆ ~TContextMenu(). TContextMenu::~TContextMenu ; (; ). virtual . Destroy a context menu. ; Definition at line 76 of file TContextMenu.cxx. Member Function Documentation. ◆ Action() [1/5]. void TContextMenu::Action ; (; TClassMenuItem * ; menuitem). virtual . Action to be performed when this menu item is selected. ; If the selected method requires arguments we popup an automatically generated dialog, otherwise the method is directly executed. ; Definition at line 116 of file TContextMenu.cxx. ◆ Action() [2/5]. void TContextMenu::Action ; (; TMethod * ; method). inline . Definition at line 74 of file TContextMenu.h. ◆ Action() [3/5]. void TContextMenu::Action ; (; TObject * ; object, . TMethod * ; method . ). virtual . Action to be performed when this menu item is selected. ; If the selected method requires arguments we popup an automatically generated dialog, otherwise the method is directly executed. ; Definition at line 93 of file TContextMenu.cxx. ◆ Action() [4/5]. void TContextMenu::Action ; (; TObject * ; object, . TToggle * ; toggle . ). virtual . Action to be performed when this toggle menu item is selected. ; Definition at line 211 of file TContextMenu.cxx. ◆ Action() [5/5]. void TContextMenu::Action ; (; TToggle * ; toggle). inline . Definition at line 75 of file TContextMenu.h. ◆ Class(). static TClass * TContextMenu::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TContextMenu::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TContextMenu::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 104 of file TContextMenu.h. ◆ CreateArgumentTitle(). const char * TContextMenu::Cr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTContextMenu.html:15887,perform,performed,15887,doc/master/classTContextMenu.html,https://root.cern,https://root.cern/doc/master/classTContextMenu.html,1,['perform'],['performed']
Performance,"nu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. static RooExpensiveObjectCache*_instance!; map<TString,ExpensiveObject*>_map; Int_t_nextUID. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooExpensiveObjectCache(); Constructor. RooExpensiveObjectCache(const RooExpensiveObjectCache& ); Copy constructor. ~RooExpensiveObjectCache(); Destructor. RooExpensiveObjectCache& instance(); Return reference to singleton instance. void cleanup(); Static function called by RooSentinel atexit() handler to cleanup at end of program. Bool_t registerObject(const char* ownerName, const char* objectName, TObject& cacheObject, const RooArgSet& params); Register object associated with given name and given associated parameters with given values in cache.; The cache will take _ownership_of_object_ and is indexed under the given name (which does not; need to be the name of cacheObject and with given set of dependent parameters with validity for the; current values of those parameters. It can be retrieved later by callin retrieveObject(). Bool_t registerObject(const char* ownerName, const char* objectName, TObject& cacheObject, TIterator* parIter); Register object associated with given name and given associated parameters with given values in cache.; The cache will take _ownership_of_object_ and is indexed under the given name (which does not; need to be the name of cacheObject and with given set of dependent parameters with validity for the; current values of those parameters. It can be retrieved later by callin retrieveObject(). const TObject* retrieveObject(const char* name, TClass* tclass, const RooArgSet& params); Retrieve object from cache that was registered under given name with given parameters, _if_; current parameter values match those that were stored in the registry for this object.; The return object is owned by the cache instance. const ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooExpensiveObjectCache.html:6852,cache,cache,6852,root/html526/RooExpensiveObjectCache.html,https://root.cern,https://root.cern/root/html526/RooExpensiveObjectCache.html,2,['cache'],"['cache', 'cacheObject']"
Performance,"nu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. static RooExpensiveObjectCache*_instance!; map<TString,ExpensiveObject*>_map; Int_t_nextUID. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooExpensiveObjectCache(); Constructor. RooExpensiveObjectCache(const RooExpensiveObjectCache& ); Copy constructor. ~RooExpensiveObjectCache(); Destructor. RooExpensiveObjectCache& instance(); Return reference to singleton instance. void cleanup(); Static function called by RooSentinel atexit() handler to cleanup at end of program. Bool_t registerObject(const char* ownerName, const char* objectName, TObject& cacheObject, const RooArgSet& params); Register object associated with given name and given associated parameters with given values in cache.; The cache will take _ownership_of_object_ and is indexed under the given name (which does not; need to be the name of cacheObject and with given set of dependent parameters with validity for the; current values of those parameters. It can be retrieved later by callin retrieveObject(). Bool_t registerObject(const char* ownerName, const char* objectName, TObject& cacheObject, TIterator* paramIter); Register object associated with given name and given associated parameters with given values in cache.; The cache will take _ownership_of_object_ and is indexed under the given name (which does not; need to be the name of cacheObject and with given set of dependent parameters with validity for the; current values of those parameters. It can be retrieved later by callin retrieveObject(). const TObject* retrieveObject(const char* name, TClass* tclass, const RooArgSet& params); Retrieve object from cache that was registered under given name with given parameters, _if_; current parameter values match those that were stored in the registry for this object.; The return object is owned by the cache instance. cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooExpensiveObjectCache.html:6838,cache,cache,6838,root/html528/RooExpensiveObjectCache.html,https://root.cern,https://root.cern/root/html528/RooExpensiveObjectCache.html,12,['cache'],"['cache', 'cacheObject']"
Performance,"nuit is possible to set the maximum number of function calls, but not the maximum number of iterations. The Strategy and the Precision options apply instead only for Minuit (and Minuit2).; The class supports also setting global default values for the options, by using the static functions MinimizerOptions::SetDefault... (for example MinimizerOptions::SetDefaultPrintLevel(int )). The static functions can be also used to set the minimizer options when using TH1::Fit or TGraph::Fit. The list of the current option values can be inspected by using MinimizerOptions::Print.; ROOT::Math::MinimizerOptions() opt;; // print the default minimizer option values; opt.Print();; In addition it is possible to provide extra options which might apply for a particular minimizer MinimizerOptions::SetExtraOptions(const IOptions & ). See the documentation of the particular minimizer to use for the list of possible additional options available.; 5.7.5 Performing the Fit; Here we have now all the required input ingredients for the fit, the data and the function to fit. Depending on these we have now several different way to perform the fit, using the corresponding methods of the ROOT::Fit::Fitter class and depending on the type of input data.; 5.7.5.1 Available fit methods. Least-square fit: Fitter::LeastSquare(const BinData & ) or Fitter::Fit(const Bindata &). It requires the user to pass a BinData object. It should be used when the data values follow a Gaussian distribution. This fit method is implemented using the class ROOT::Fit::Chi2FCN.; Binned Likelihood fit : Fitter::LikelihoodFit(const Bindata & ). The user needs to pass a BinData object. It should be used when the data values follow a Poisson or a multinomial distribution. The Poisson case (extended fit) is the default and in this case the function normalization is also fit to the data. The Multi-nominal case can be selected by passing the optional extended boolean flag as false. This method is implemented by the class ROOT::Fit::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:206447,Perform,Performing,206447,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['Perform'],['Performing']
Performance,"num TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. TList*fClaimslist of claims we manage; TStringfPoolthe condor pool to be accessed; TCondor::EStatefStateour claim state; Bool_tfValidaccess to Condor. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TCondor(const char* pool = """"); Create Condor interface object. Uses Condor apps since there is no; API yet. ~TCondor(); Cleanup Condor interface. void Print(Option_t* option = """") const; Print master status. TCondorSlave * ClaimVM(const char* vm, const char* cmd); Claim a VirtualMachine for PROOF usage. TList * GetVirtualMachines() const; Get the names of the virtual machines in the pool.; Return a TList of TObjString or 0 in case of failure. TList * Claim(Int_t n, const char* cmd); Claim n virtual machines; This function figures out the image and performance index before returning; the list of condor slaves. TCondorSlave * Claim(const char* vmname, const char* cmd); Claim virtual machine with name vmname; This function does not figure out the image and performance index before; returning the condor slave. Bool_t SetState(TCondor::EState state); Set the state of workers. Bool_t Suspend(); Suspend worker. Bool_t Resume(); Resume worker. Bool_t Release(); Release worker. Bool_t GetVmInfo(const char* vm, TString& image, Int_t& perfidx) const; Get info about worker status. TString GetImage(const char* host) const; Get image of the worker. TCondor(const char* pool = """"). Bool_t IsValid() const; { return fValid; }. EState GetState() const; {return fState;}. » Author: Maarten Ballintijn 06/12/03 » Copyright (C) 1995-2003, Rene Brun and Fons Rademakers. *; » Last changed: root/proof:$Id: TCondor.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:02; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TCondor.html:6666,perform,performance,6666,root/html528/TCondor.html,https://root.cern,https://root.cern/root/html528/TCondor.html,1,['perform'],['performance']
Performance,"num TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. TList*fClaimslist of claims we manage; TStringfPoolthe condor pool to be accessed; TCondor::EStatefStateour claim state; Bool_tfValidaccess to Condor. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TCondor(const char* pool = """"); Create Condor interface object. Uses Condor apps since there is no; API yet. ~TCondor(); Cleanup Condor interface. void Print(Option_t* option = """") const; Print master status. TCondorSlave * ClaimVM(const char* vm, const char* cmd); Claim a VirtualMachine for PROOF usage. TList * GetVirtualMachines() const; Get the names of the virtual machines in the pool.; Return a TList of TObjString or 0 in case of failure. TList * Claim(Int_t n, const char* cmd); Claim n virtual machines; This function figures out the image and performance index before returning; the list of condor slaves. TCondorSlave * Claim(const char* vmname, const char* cmd); Claim virtual machine with name vmname; This function does not figure out the image and performance index before; returning the condor slave. Bool_t SetState(TCondor::EState state); Set the state of workers. Bool_t Suspend(); Suspend worker. Bool_t Resume(); Resume worker. Bool_t Release(); Release worker. Bool_t GetVmInfo(const char* vm, TString& image, Int_t& perfidx) const; Get info about worker status. TString GetImage(const char* host) const; Get image of the worker. TCondor(const char* pool = """"). Bool_t IsValid() const; { return fValid; }. EState GetState() const; {return fState;}. » Author: Maarten Ballintijn 06/12/03 » Copyright (C) 1995-2003, Rene Brun and Fons Rademakers. *; » Last changed: root/proof:$Id: TCondor.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-07-04 15:25; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TCondor.html:6735,perform,performance,6735,root/html530/TCondor.html,https://root.cern,https://root.cern/root/html530/TCondor.html,1,['perform'],['performance']
Performance,"num TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. TList*fClaimslist of claims we manage; TStringfPoolthe condor pool to be accessed; TCondor::EStatefStateour claim state; Bool_tfValidaccess to Condor. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TCondor(const char* pool = """"); Create Condor interface object. Uses Condor apps since there is no; API yet. ~TCondor(); Cleanup Condor interface. void Print(Option_t* option = """") const; Print master status. TCondorSlave * ClaimVM(const char* vm, const char* cmd); Claim a VirtualMachine for PROOF usage. TList * GetVirtualMachines() const; Get the names of the virtual machines in the pool.; Return a TList of TObjString or 0 in case of failure. TList * Claim(Int_t n, const char* cmd); Claim n virtual machines; This function figures out the image and performance index before returning; the list of condor slaves. TCondorSlave * Claim(const char* vmname, const char* cmd); Claim virtual machine with name vmname; This function does not figure out the image and performance index before; returning the condor slave. Bool_t SetState(TCondor::EState state); Set the state of workers. Bool_t Suspend(); Suspend worker. Bool_t Resume(); Resume worker. Bool_t Release(); Release worker. Bool_t GetVmInfo(const char* vm, TString& image, Int_t& perfidx) const; Get info about worker status. TString GetImage(const char* host) const; Get image of the worker. TCondor(const char* pool = """"). Bool_t IsValid() const; { return fValid; }. EState GetState() const; {return fState;}. » Author: Maarten Ballintijn 06/12/03 » Copyright (C) 1995-2003, Rene Brun and Fons Rademakers. *; » Last changed: root/proof:$Id: TCondor.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-11-03 20:11; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TCondor.html:6735,perform,performance,6735,root/html532/TCondor.html,https://root.cern,https://root.cern/root/html532/TCondor.html,2,['perform'],['performance']
Performance,"num  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . #include <TProofBench.h>. Inheritance diagram for TProofBench:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TProofBench(). TProofBench::TProofBench ; (; const char * ; url, . const char * ; outfile = ""<default>"", . const char * ; proofopt = 0 . ). Constructor: check PROOF and load selectors PAR. ; Definition at line 184 of file TProofBench.cxx. ◆ ~TProofBench(). TProofBench::~TProofBench ; (; ). override . Destructor. ; Definition at line 247 of file TProofBench.cxx. Member Function Documentation. ◆ AssertFittingFun(). void TProofBench::AssertFittingFun ; (; Double_t ; mi, . Double_t ; mx . ). staticprotected . Make sure that the fitting functions are defined. ; Definition at line 696 of file TProofBench.cxx. ◆ Class(). static TClass * TProofBench::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TProofBench::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TProofBench::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 143 of file TProofBench.h. ◆ CloseOutFile(). void TProofBench::CloseOutFile ; (; ). Close output file. ; Definition at line 326 of file TProofBench.cxx. ◆ CopyDataSet(). Int_t TProofBench::Cop",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofBench.html:14694,load,load,14694,doc/master/classTProofBench.html,https://root.cern,https://root.cern/doc/master/classTProofBench.html,1,['load'],['load']
Performance,"number of blocks prefetched; ( it could be more than 1 if we read the same block from the cache more; than once ); Note: This should eb used at the end of the processing or we will; get uncomplete stats. Double_t GetEfficiencyRel() const; This will indicate a sort of relative efficiency... a ratio of the; reads found in the cache to the number of reads so far. Int_t GetLearnEntries(); static function returning the number of entries used to train the cache; see SetLearnEntries. void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; see also class TTreePerfStats.; if option contains 'cachedbranches', the list of branches being; cached is printed. Int_t ReadBufferNormal(char* buf, Long64_t pos, Int_t len). Int_t ReadBufferPrefetch(char* buf, Long64_t pos, Int_t len). Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos if the request is in the list of; prefetched blocks read from fBuffer.; Otherwise try to fill the cache from the list of selected branches,; and recheck if pos is now in the list.; Returns; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache.; This function overloads TFileCacheRead::ReadBuffer. void ResetCache(); This will simply clear the cache. Int_t SetBufferSize(Int_t buffersize); Change the underlying buffer size of the cache.; If the change of size means some cache content is lost, or if the buffer; is now larger, setup for a c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TTreeCache.html:24967,cache,cache,24967,root/html604/TTreeCache.html,https://root.cern,https://root.cern/root/html604/TTreeCache.html,2,['cache'],['cache']
Performance,"number of blocks prefetched; ( it could be more than 1 if we read the same block from the cache more; than once ); Note: This should eb used at the end of the processing or we will; get uncomplete stats. Double_t GetEfficiencyRel() const; This will indicate a sort of relative efficiency... a ratio of the; reads found in the cache to the number of reads so far. Int_t GetLearnEntries(); static function returning the number of entries used to train the cache; see SetLearnEntries. void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; see also class TTreePerfStats.; if option contains 'cachedbranches', the list of branches being; cached is printed. Int_t ReadBufferNormal(char* buf, Long64_t pos, Int_t len). Int_t ReadBufferPrefetch(char* buf, Long64_t pos, Int_t len). Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos if the request is in the list of; prefetched blocks read from fBuffer.; Otherwise try to fill the cache from the list of selected branches,; and recheck if pos is now in the list.; Returns; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache.; This function overloads TFileCacheRead::ReadBuffer. void ResetCache(); This will simply clear the cache. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTreeCache.html:24635,cache,cache,24635,root/html602/TTreeCache.html,https://root.cern,https://root.cern/root/html602/TTreeCache.html,2,['cache'],['cache']
Performance,"number of blocks prefetched; ( it could be more than 1 if we read the same block from the cache more; than once ); Note: This should eb used at the end of the processing or we will; get uncomplete stats. Double_t GetEfficiencyRel() const; This will indicate a sort of relative efficiency... a ratio of the; reads found in the cache to the number of reads so far. Int_t GetLearnEntries(); static function returning the number of entries used to train the cache; see SetLearnEntries. void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; see also class TTreePerfStats.; if option contains 'cachedbranches', the list of branches being; cached is printed. Int_t ReadBufferNormal(char* buf, Long64_t pos, Int_t len). Int_t ReadBufferPrefetch(char* buf, Long64_t pos, Int_t len). Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos.; If pos is in the list of prefetched blocks read from fBuffer.; Otherwise try to fill the cache from the list of selected branches,; and recheck if pos is now in the list.; Returns; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache.; This function overloads TFileCacheRead::ReadBuffer. void ResetCache(); This will simply clear the cache. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the br",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTreeCache.html:24018,cache,cache,24018,root/html534/TTreeCache.html,https://root.cern,https://root.cern/root/html534/TTreeCache.html,2,['cache'],['cache']
Performance,"number of entries is small ( <5); - the estimated bin error is extremely small compared to the bin content; (see TProfile::GetBinError). Int_t BufferEmpty(Int_t action = 0); Fill histogram with all entries in the buffer.; action = -1 histogram is reset and refilled from the buffer (called by THistPainter::Paint); action = 0 histogram is filled from the buffer; action = 1 histogram is filled and buffer is deleted; The buffer is automatically deleted when the number of entries; in the buffer is greater than the number of entries in the histogram. Int_t BufferFill(Double_t x, Double_t y, Double_t w); accumulate arguments in buffer. When buffer is full, empty the buffer; fBuffer[0] = number of entries in buffer; fBuffer[1] = w of first entry; fBuffer[2] = x of first entry; fBuffer[3] = y of first entry. void Copy(TObject& hnew) const; -*-*-*Copy a Profile histogram to a new profile histogram; *-* ===================================================. void Divide(TF1* h1, Double_t c1 = 1); Performs the operation: this = this/(c1*f1). void Divide(const TH1* h1); Divide this profile by h1*-*-; *-* =========================. this = this/h1; This function accepts to divide a TProfile by a histogram. void Divide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """"); -*-*Replace contents of this profile by the division of h1 by h2; *-* ============================================================. this = c1*h1/(c2*h2). TH1 * DrawCopy(Option_t* option = """") const; Draw a copy of this profile histogram*-*-*-*-; *-* =====================================. Int_t Fill(Double_t x, Double_t y); -*-*-*Fill a Profile histogram (no weights); *-* =====================================. Int_t Fill(const char* namex, Double_t y); Fill a Profile histogram (no weights). Int_t Fill(Double_t x, Double_t y, Double_t w); -*-*-*Fill a Profile histogram with weights; *-* =====================================. Int_t Fill(const char* namex, Double_t y, Double_t w); Fill a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TProfile.html:32578,Perform,Performs,32578,root/html532/TProfile.html,https://root.cern,https://root.cern/root/html532/TProfile.html,1,['Perform'],['Performs']
Performance,"number of numerically integrated dimensions to activate normalization value caching; Int_t_nBins; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInter",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooParametricStepFunction.html:40506,cache,cache,40506,root/html532/RooParametricStepFunction.html,https://root.cern,https://root.cern/root/html532/RooParametricStepFunction.html,2,['cache'],['cache']
Performance,"number of slaves as described in the config file. ;  ; Int_t GetNumberOfUniqueSlaves () const;  Return number of unique slaves, i.e. ;  ; Int_t GetQueryReference (Int_t qry, TString &ref);  Get reference for the qry-th query in fQueries (as displayed by ShowQueries). ;  ; Int_t GoMoreParallel (Int_t nWorkersToAdd);  Add nWorkersToAdd workers to current list of workers. ;  ; Int_t GoParallel (Int_t nodes, Bool_t accept=kFALSE, Bool_t random=kFALSE);  Go in parallel mode with at most ""nodes"" slaves. ;  ; Int_t HandleInputMessage (TSlave *wrk, TMessage *m, Bool_t deactonfail=kFALSE);  Analyze the received message. ;  ; void HandleSubmerger (TMessage *mess, TSlave *sl);  Process a message of type kPROOF_SUBMERGER. ;  ; void Interrupt (EUrgent type, ESlaves list=kActive);  Send interrupt to master or slave servers. ;  ; void InterruptCurrentMonitor ();  If in active in a monitor set ready state. ;  ; Bool_t IsEndMaster () const;  ; Bool_t IsSync () const;  ; Int_t LoadPackage (const char *package, Bool_t notOnClient=kFALSE, TList *loadopts=0, TList *workers=0);  Load specified package. ;  ; void MarkBad (TSlave *wrk, const char *reason=0);  Add a bad slave server to the bad slave list and remove it from the active list and from the two monitor objects. ;  ; void MarkBad (TSocket *s, const char *reason=0);  Add slave with socket s to the bad slave list and remove if from the active list and from the two monitor objects. ;  ; Int_t ModifyWorkerLists (const char *ord, Bool_t add, Bool_t save);  Modify the worker active/inactive list by making the worker identified by the ordinal number 'ord' active (add == TRUE) or inactive (add == FALSE). ;  ; void NotifyLogMsg (const char *msg, const char *sfx=""\n"");  Notify locally 'msg' to the appropriate units (file, stdout, window) If defined, 'sfx' is added after 'msg' (typically a line-feed);. ;  ; void operator= (const TProof &);  ; void ParseConfigField (const char *config);  The config file field may contain special instructions ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProof.html:50493,load,loadopts,50493,doc/master/classTProof.html,https://root.cern,https://root.cern/doc/master/classTProof.html,1,['load'],['loadopts']
Performance,"number of specified fit bins 'get/setBins()'.; # Category dimensions of binned datasets get one bin per defined category; # state; x.setBins(10); y.setBins(10); dh = ROOT.RooDataHist(""dh"", ""binned version of d"", {x, y}, d); dh.Print(""v""); ; yframe = y.frame(Bins=10, Title=""Operations on binned datasets""); dh.plotOn(yframe) # plot projection of 2D binned data on y; ; # Examine the statistics of a binned dataset; print("">> number of bins in dh : "", dh.numEntries()); print("">> sum of weights in dh : "", dh.sum(False)); # accounts for bin volume; print("">> integral over histogram: "", dh.sum(True)); ; # Locate a bin from a set of coordinates and retrieve its properties; x.setVal(0.3); y.setVal(20.5); print("">> retrieving the properties of the bin enclosing coordinate (x,y) = (0.3,20.5) bin center:""); # load bin center coordinates in internal buffer; dh.get({x, y}).Print(""v""); print("" weight = "", dh.weight()) # return weight of last loaded coordinates; ; # Reduce the 2-dimensional binned dataset to a 1-dimensional binned dataset; #; # All reduce() methods are interfaced in RooAbsData. All reduction techniques; # demonstrated on unbinned datasets can be applied to binned datasets as; # well.; print("">> Creating 1-dimensional projection on y of dh for bins with x>0""); dh2 = dh.reduce({y}, ""x>0""); dh2.Print(""v""); ; # Add dh2 to yframe and redraw; dh2.plotOn(yframe, LineColor=""r"", MarkerColor=""r""); ; # Saving and loading from file; # -------------------------------------------------------; ; # Datasets can be persisted with ROOT I/O; print(""\n >> Persisting d via ROOT I/O""); f = ROOT.TFile(""rf402_datahandling.root"", ""RECREATE""); d.Write(); f.ls(); ; # To read back in future session:; # > ROOT.TFile f(""rf402_datahandling.root""); # > d = (ROOT.RooDataSet*) f.FindObject(""d""); ; c = ROOT.TCanvas(""rf402_datahandling"", ""rf402_datahandling"", 600, 600); ROOT.gPad.SetLeftMargin(0.15); yframe.GetYaxis().SetTitleOffset(1.4); yframe.Draw(); ; c.SaveAs(""rf402_datahandling.png""); typeOption",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf402__datahandling_8py.html:4317,load,loaded,4317,doc/master/rf402__datahandling_8py.html,https://root.cern,https://root.cern/doc/master/rf402__datahandling_8py.html,1,['load'],['loaded']
Performance,"numbers in the list.; tree.Draw("">>yplus"", ""y>0"", ""entrylist""); will create a TEntryList object names ""yplus"" in the current directory. By default, the specified entry list is reset.; To continue to append data to an existing list, use ""+"" in front; of the list name;; tree.Draw("">>+yplus"",""y>0""); will not reset yplus, but will enter the selected entries at the end; of the existing list. Using a TEventList or a TEntryList as Input. Once a TEventList or a TEntryList object has been generated, it can be used as input; for TTree::Draw. Use TTree::SetEventList or TTree::SetEntryList to set the; current event list; Example1:; TEventList *elist = (TEventList*)gDirectory->Get(""yplus"");; tree->SetEventList(elist);; tree->Draw(""py"");; Example2:; TEntryList *elist = (TEntryList*)gDirectory->Get(""yplus"");; tree->SetEntryList(elist);; tree->Draw(""py"");; If a TEventList object is used as input, a new TEntryList object is created; inside the SetEventList function. In case of a TChain, all tree headers are loaded; for this transformation. This new object is owned by the chain and is deleted; with it, unless the user extracts it by calling GetEntryList() function.; See also comments to SetEventList() function of TTree and TChain. If arrays are used in the selection critera, the entry entered in the; list are all the entries that have at least one element of the array that; satisfy the selection.; Example:; tree.Draw("">>pyplus"",""fTracks.fPy>0"");; tree->SetEventList(pyplus);; tree->Draw(""fTracks.fPy"");; will draw the fPy of ALL tracks in event with at least one track with; a positive fPy. To select only the elements that did match the original selection; use TEventList::SetReapplyCut or TEntryList::SetReapplyCut.; Example:; tree.Draw("">>pyplus"",""fTracks.fPy>0"");; pyplus->SetReapplyCut(kTRUE);; tree->SetEventList(pyplus);; tree->Draw(""fTracks.fPy"");; will draw the fPy of only the tracks that have a positive fPy. Note: Use tree->SetEventList(0) if you do not want use the list as input. H",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTree.html:79133,load,loaded,79133,root/html528/TTree.html,https://root.cern,https://root.cern/root/html528/TTree.html,2,['load'],['loaded']
Performance,"numbers in the list.; tree.Draw("">>yplus"", ""y>0"", ""entrylist""); will create a TEntryList object names ""yplus"" in the current directory. By default, the specified entry list is reset.; To continue to append data to an existing list, use ""+"" in front; of the list name;; tree.Draw("">>+yplus"",""y>0""); will not reset yplus, but will enter the selected entries at the end; of the existing list. Using a TEventList or a TEntryList as Input. Once a TEventList or a TEntryList object has been generated, it can be used as input; for TTree::Draw. Use TTree::SetEventList or TTree::SetEntryList to set the; current event list; Example1:; TEventList *elist = (TEventList*)gDirectory->Get(""yplus"");; tree->SetEventList(elist);; tree->Draw(""py"");; Example2:; TEntryList *elist = (TEntryList*)gDirectory->Get(""yplus"");; tree->SetEntryList(elist);; tree->Draw(""py"");; If a TEventList object is used as input, a new TEntryList object is created; inside the SetEventList function. In case of a TChain, all tree headers are loaded; for this transformation. This new object is owned by the chain and is deleted; with it, unless the user extracts it by calling GetEntryList() function.; See also comments to SetEventList() function of TTree and TChain. If arrays are used in the selection critera, the event entered in the; list are all the event that have at least one element of the array that; satisfy the selection.; Example:; tree.Draw("">>pyplus"",""fTracks.fPy>0"");; tree->SetEventList(pyplus);; tree->Draw(""fTracks.fPy"");; will draw the fPy of ALL tracks in event with at least one track with; a positive fPy. To select only the elements that did match the original selection; use TEventList::SetReapplyCut.; Example:; tree.Draw("">>pyplus"",""fTracks.fPy>0"");; pyplus->SetReapplyCut(kTRUE);; tree->SetEventList(pyplus);; tree->Draw(""fTracks.fPy"");; will draw the fPy of only the tracks that have a positive fPy. Note: Use tree->SetEventList(0) if you do not want use the list as input. How to obtain more info from TTr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreePlayer.html:35525,load,loaded,35525,root/html528/TTreePlayer.html,https://root.cern,https://root.cern/root/html528/TTreePlayer.html,1,['load'],['loaded']
Performance,"numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Bool_t_disableCacheFlag to run object in passthrough (= non-caching mode). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsCachedPdf(); Destructor. Double_t getValV(const RooArgSet* set = 0) const; Implementation of getVal() overriding default implementation; of RooAbsPdf. Return normalized value stored in cache p.d.f; rather than return value of evaluate() which is undefined; for RooAbsCachedPdf. RooAbsPdf* getCachePdf(const RooArgSet* nset = 0) const; Return pointer to RooHistPdf cache pdf for given choice of observables. RooDataHist* getCacheHist(const RooArgSet* nset = 0) const; Return pointer to RooDataHist cache histogram for given choice of observables. void clearCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; Mark all bins of given cache as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct string with unique suffix for cache objects based on; observable names that define cache configuration. void setInterpolationOrder(Int_t order); Change the interpolation order that is used in RooHistPdf cache; representation smoothing the RooDataHist shapes. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force RooRealIntegral to offer all our actual observable for internal; integration. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertises internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Double_t analyticalIntegralWN(Int_t code, const RooArg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsCachedPdf.html:44070,cache,cache,44070,root/html532/RooAbsCachedPdf.html,https://root.cern,https://root.cern/root/html532/RooAbsCachedPdf.html,1,['cache'],['cache']
Performance,"numthreads' might not have any effect.; NoteUse DisableImplicitMT() to disable multi-threading (some locks will remain in place as described in EnableThreadSafety()). EnableImplicitMT(1) creates a thread-pool of size 1. ; Definition at line 527 of file TROOT.cxx. ◆ EnableThreadSafety(). void ROOT::EnableThreadSafety ; (; ). Enable support for multi-threading within the ROOT code in particular, enables the global mutex to make ROOT thread safe/aware. ; Enables the global mutex to make ROOT thread safe/aware.; The following becomes safe:; concurrent construction and destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); concurrent usage of different ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; concurrent calls to the interpreter through gInterpreter; concurrent loading of ROOT plug-ins. In addition, gDirectory, gFile and gPad become a thread-local variable. In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents. gFile and gPad default to nullptr, as it is for single-thread programs.; The ROOT graphics subsystem is not made thread-safe by this method. In particular drawing or printing different canvases from different threads (and analogous operations such as invoking Draw on a TObject) is not thread-safe.; Note that there is no DisableThreadSafety(). ROOT's thread-safety features cannot be disabled once activated. ; Definition at line 493 of file TROOT.cxx. ◆ FindEndSymbol(). static std::string::size_type ROOT::FindEndSymbol ; (; std::string & ; command). static . Definition at line 62 of file RConversionRuleParser.cxx. ◆ FromHumanReadableSize() [1/2]. template<typename T > . EFromHumanReadableSize ROOT::FromHumanReadableSize ; (; ROOT::Internal::T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v628/namespaceROOT.html:26798,concurren,concurrent,26798,doc/v628/namespaceROOT.html,https://root.cern,https://root.cern/doc/v628/namespaceROOT.html,3,"['concurren', 'load']","['concurrent', 'loading']"
Performance,"nup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TList*fAllPubDataall public data members (including from base classes); TList*fAllPubMethodall public methods (including from base classes); TList*fBaselinked list for base classes; Int_tfCanSplit!Indicates whether this class can be split or not.; UInt_tfCheckSumchecksum of data members and base classes; ClassInfo_t*fClassInfopointer to CINT class info class; TList*fClassMenuListlist of class menu items; Version_tfClassVersionClass version Identifier; TVirtualCollectionProxy*fCollectionProxyCollection interface; TStringfContextMenuTitlecontext menu title; map<std::string,TObjArray*>*fConversionStreamerInfoArray of the streamer infos derived from another class.; TVirtualStreamerInfo*fCurrentInfo!cached current streamer info.; TList*fDatalinked list for data members; Short_tfDeclFileLineline of class declaration; const char*fDeclFileNamename of class declaration file; void*fDeletepointer to a function deleting one object.; void*fDeleteArraypointer to a function deleting an array of objects.; void*fDestructorpointer to a function call an object's destructor.; void*fDirAutoAddpointer which implements the Directory Auto Add feature for this class.']'; IsAGlobalFunc_tfGlobalIsApointer to a global IsA function.; Short_tfImplFileLineline of class implementation; const char*fImplFileNamename of class implementation file; UInt_tfInstanceCountnumber of instances of this class; void*fInterShowMembersInterpreter call setup for ShowMembers; TVirtualIsAProxy*fIsA!pointer to the class's IsA proxy.; TMethodCall*fIsAMethod!saved info to call a IsA member function; Bool_tfIsOffsetStreamerSet!saved remember if fOffsetStreamer has been set.; TVirtualStreamerInfo*fLastReadInfo!cached streamer i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TClass.html:15667,cache,cached,15667,root/html534/TClass.html,https://root.cern,https://root.cern/root/html534/TClass.html,2,['cache'],['cached']
Performance,"nup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TList*fAllPubDataall public data members (including from base classes); TList*fAllPubMethodall public methods (including from base classes); TList*fBaselinked list for base classes; Int_tfCanSplit!Indicates whether this class can be split or not.; UInt_tfCheckSumchecksum of data members and base classes; ClassInfo_t*fClassInfopointer to CINT class info class; TList*fClassMenuListlist of class menu items; Version_tfClassVersionClass version Identifier; TVirtualCollectionProxy*fCollectionProxyCollection interface; TStringfContextMenuTitlecontext menu title; map<std::string,TObjArray*>*fConversionStreamerInfoArray of the streamer infos derived from another class.; TVirtualStreamerInfo*fCurrentInfo!cached current streamer info.; TList*fDatalinked list for data members; Short_tfDeclFileLineline of class declaration; const char*fDeclFileNamename of class declaration file; void*fDeletepointer to a function deleting one object.; void*fDeleteArraypointer to a function deleting an array of objects.; void*fDestructorpointer to a function call an object's destructor.; void*fDirAutoAddpointer which implements the Directory Auto Add feature for this class.']'; IsAGlobalFunc_tfGlobalIsApointer to a global IsA function.; Short_tfImplFileLineline of class implementation; const char*fImplFileNamename of class implementation file; UInt_tfInstanceCountnumber of instances of this class; void*fInterShowMembersInterpreter call setup for ShowMembers; TVirtualIsAProxy*fIsA!pointer to the class's IsA proxy.; TMethodCall*fIsAMethod!saved info to call a IsA member function; Bool_tfIsOffsetStreamerSet!saved remember if fOffsetStreamer has been set.; void*fMergepointer to a function implementing Mergin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TClass.html:14746,cache,cached,14746,root/html530/TClass.html,https://root.cern,https://root.cern/root/html530/TClass.html,3,['cache'],['cached']
Performance,"nus variable matching wgtName if specified. RooRealVar* weightVar(const RooArgSet& allVars, const char* wgtName = 0); Utility function for constructors; Return pointer to weight variable if it is defined. void attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); Initialize cache of dataset: attach variables of cache ArgSet; to the corresponding TTree branches. RooTreeDataStore(const RooTreeDataStore& other, const char* newname = 0). RooTreeDataStore(const RooTreeDataStore& other, const RooArgSet& vars, const char* newname = 0). ~RooTreeDataStore(); Destructor. void initialize(); One-time initialization common to all constructor forms. Attach; variables of internal ArgSet to the corresponding TTree branches. void createTree(const char* name, const char* title); Create TTree object that lives in memory, independent of current; location of gDirectory. void loadValues(const TTree* t, const RooFormulaVar* select = 0, const char* rangeName = 0, Int_t nStart = 0, Int_t nStop = 2000000000); Load values from tree 't' into this data collection, optionally; selecting events using 'select' RooFormulaVar. The source tree 't' is first clone as not disturb its branch; structure when retrieving information from it. void loadValues(const RooAbsDataStore* tds, const RooFormulaVar* select = 0, const char* rangeName = 0, Int_t nStart = 0, Int_t nStop = 2000000000); Load values from dataset 't' into this data collection, optionally; selecting events using 'select' RooFormulaVar. Bool_t valid() const; Return true if currently loaded coordinate is considered valid within; the current range definitions of all observables. Int_t fill(); Interface function to TTree::Fill. const RooArgSet* get(Int_t index) const; Load the n-th data point (n='index') in memory; and return a pointer to the internal RooArgSet; holding its coordinates. Double_t weight(Int_t index) const; Return the weight of the n-th data point (n='index') in memory. Double_t weight() const; Return the weight of th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooTreeDataStore.html:13451,load,loadValues,13451,root/html528/RooTreeDataStore.html,https://root.cern,https://root.cern/root/html528/RooTreeDataStore.html,14,"['Load', 'load']","['Load', 'loadValues']"
Performance,"nvPdf::cacheObservables ; (; ); const. inline . Definition at line 39 of file RooFFTConvPdf.h. ◆ calcParams(). void RooFFTConvPdf::calcParams ; (; ). protected . (Re)calculate effective parameters of this p.d.f. ; Definition at line 957 of file RooFFTConvPdf.cxx. ◆ Class(). static TClass * RooFFTConvPdf::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooFFTConvPdf::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooFFTConvPdf::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 124 of file RooFFTConvPdf.h. ◆ clone(). TObject * RooFFTConvPdf::clone ; (; const char * ; newname); const. inlineoverridevirtual . Implements RooAbsArg.; Definition at line 34 of file RooFFTConvPdf.h. ◆ createCache(). RooFFTConvPdf::PdfCacheElem * RooFFTConvPdf::createCache ; (; const RooArgSet * ; nset); const. overrideprotectedvirtual . Return specialized cache subclass for FFT calculations. ; Reimplemented from RooAbsCachedPdf.; Definition at line 342 of file RooFFTConvPdf.cxx. ◆ DeclFileName(). static const char * RooFFTConvPdf::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 124 of file RooFFTConvPdf.h. ◆ evaluate(). double RooFFTConvPdf::evaluate ; (; ); const. inlineoverrideprotectedvirtual . Evaluate this PDF / function / constant. Needs to be overridden by all derived classes. ; Implements RooAbsReal.; Definition at line 96 of file RooFFTConvPdf.h. ◆ fillCacheObject(). void RooFFTConvPdf::fillCacheObject ; (; RooAbsCachedPdf::PdfCacheElem & ; cache); const. overrideprotectedvirtual . Fill the contents of the cache the FFT convolution output. ; Implements RooAbsCachedPdf.; Definition at line 479 of file RooFFTConvPdf.cxx. ◆ fillCacheSlice(). void RooFFTConvPdf::fillCacheSlice ; (; FFTCacheElem & ; cache, . const RooArgSet & ; slicePosition . ); const. protected . Fill a sli",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooFFTConvPdf.html:89764,cache,cache,89764,doc/master/classRooFFTConvPdf.html,https://root.cern,https://root.cern/doc/master/classRooFFTConvPdf.html,1,['cache'],['cache']
Performance,"nvPdf::getCoefNorm(Int_t coefIdx, const RooArgSet* nset, const TNamed* rangeName) const; virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; static voidRooAbsReal::globalSelectComp(Bool_t flag); voidRooAbsArg::graphVizAddConnections(set<std::pair<RooAbsArg*,RooAbsArg*> >&); Bool_tRooAbsArg::inhibitDirty() const; TStringRooAbsReal::integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset = 0, const char* rangeName = 0, Bool_t omitEmpty = kFALSE) const; Bool_tRooAbsReal::isSelectedComp() const; virtual Bool_tRooAbsReal::isValid() const; virtual Bool_tRooAbsReal::isValidReal(Double_t value, Bool_t printError = kFALSE) const; voidRooAbsAnaConvPdf::makeCoefVarList(RooArgList&) const; voidRooAbsReal::makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; voidTObject::MakeZombie(); Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c, const RooArgProxy& d) const; Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooArgSet& params, Bool_t showConstants = kFALSE, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooBCPEffDecay.html:36733,optimiz,optimizeDirtyHook,36733,root/html534/RooBCPEffDecay.html,https://root.cern,https://root.cern/root/html534/RooBCPEffDecay.html,12,['optimiz'],['optimizeDirtyHook']
Performance,"nvas functionality for specified period of time Required when canvas used not from the main thread. ;  ; void SetClearOnClose (const std::shared_ptr< void > &) final;  Set handle to window which will be cleared when connection is closed. ;  ;  Public Member Functions inherited from ROOT::Experimental::Internal::RVirtualCanvasPainter; virtual ~RVirtualCanvasPainter ();  Default destructor. ;  . Private Types; typedef std::vector< Detail::RMenuItem > MenuItemsVector;  . Private Member Functions;  RCanvasPainter (const RCanvasPainter &)=delete;  Disable copy construction. ;  ; void CancelCommands (unsigned connid=0);  Cancel command execution on provided connection All commands are cancelled, when connid === 0. ;  ; void CancelUpdates ();  Cancel all pending Canvas::Update() ;  ; void CheckDataToSend ();  Check if canvas need to send data to the clients. ;  ; std::string CreateSnapshot (RDrawable::RDisplayContext &ctxt);  Create JSON representation of data, which should be send to the clients Here server-side painting is performed - each drawable adds own elements in so-called display list, which transferred to the clients. ;  ; void CreateWindow ();  Create web window for canvas. ;  ; std::shared_ptr< RDrawable > FindPrimitive (const RCanvas &can, const std::string &id, const RPadBase **subpad=nullptr);  Find drawable in the canvas with specified id Used to communicate with the clients, which does not have any pointer. ;  ; void FrontCommandReplied (const std::string &reply);  Process reply on the currently active command. ;  ; RCanvasPainter & operator= (const RCanvasPainter &)=delete;  Disable assignment. ;  ; void ProcessData (unsigned connid, const std::string &arg);  Process data from the client. ;  ; void SaveCreatedFile (std::string &reply);  Method called when GUI sends file to save on local disk File data coded with base64 coding beside SVG format. ;  . Private Attributes; RCanvas & fCanvas;  ! Canvas we are painting, *this will be owned by canvas ;  ; std::li",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RCanvasPainter.html:2982,perform,performed,2982,doc/master/classROOT_1_1Experimental_1_1RCanvasPainter.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RCanvasPainter.html,1,['perform'],['performed']
Performance,"nvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. static const TGPicture*TEveElement::fgListTreeIcons[9]; static const TGPicture*TEveElement::fgRnrIcons[4]. protected:. TEveCaloLego::E2DMode_ef2DMode; Bool_tTEveCaloViz::fAutoRangeset eta phi limits on DataChanged(); Bool_tfAutoRebin; Float_t*TAttBBox::fBBox! Dynamic Float_t[6] X(min,max), Y(min,max), Z(min,max); Float_tTEveCaloViz::fBarrelRadiusbarrel raidus in cm; TEveCaloLego::EBoxMode_efBoxModeadditional scale info; UChar_tTEveElement::fCSCBits; Bool_tTEveElement::fCanEditMainColorAllow editing of main color.; Bool_tTEveElement::fCanEditMainTransAllow editing of main transformation.; Bool_tTEveElement::fCanEditMainTransparencyAllow editing of main transparency.; Bool_tTEveCaloViz::fCellIdCacheOKdata cell ids cache state; vector<TEveCaloData::CellId_t,allocator<TEveCaloData::CellId_t> >fCellList; Int_tfCellPixelFontSize; UChar_tTEveElement::fChangeBits!; list<TEveElement*>TEveElement::fChildrenList of children.; TEveCompound*TEveElement::fCompoundCompound this object belongs to.; TEveCaloData*TEveCaloViz::fDataevent data reference; Int_tTEveElement::fDenyDestroy! Deny-destroy count.; Bool_tTEveElement::fDestroyOnZeroRefCntAuto-destruct when ref-count reaches zero.; Char_tTEveElement::fDestructing!; Bool_tfDrawHPlane; Int_tfDrawNumberCellPixels; Float_tTEveCaloViz::fEndCapPosBbackward end cap z coordinate in cm (should be < 0); Float_tTEveCaloViz::fEndCapPosFforward end cap z coordinate in cm; Double_tTEveCaloViz::fEtaMax; Double_tTEveCaloViz::fEtaMin; Float_tfFixedHeightValIn2DMode1% of whole height; Color_tfFontColor; Color_tfGridColor; Float_tfHPlaneVal; Bool_tfHasFixedHeightIn2DMode; Bool_tTEveElement::fHighlighted!; Short_tTEveElement::fImpliedHighlighted!; Short_tTEveElement::fImpliedSelected!; set<TEveElement::TEveListTreeInfo,less<TEveElement::TEveListTreeInfo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TEveCaloLego.html:22373,cache,cache,22373,root/html534/TEveCaloLego.html,https://root.cern,https://root.cern/root/html534/TEveCaloLego.html,2,['cache'],['cache']
Performance,"nvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. static const TGPicture*TEveElement::fgListTreeIcons[9]; static const TGPicture*TEveElement::fgRnrIcons[4]. protected:. TEveCaloLego::E2DMode_ef2DMode; Bool_tTEveCaloViz::fAutoRangeset eta phi limits on DataChanged(); Bool_tfAutoRebin; Float_t*TAttBBox::fBBox! Dynamic Float_t[6] X(min,max), Y(min,max), Z(min,max); Float_tTEveCaloViz::fBarrelRadiusbarrel raidus in cm; TEveCaloLego::EBoxMode_efBoxModeadditional scale info; UChar_tTEveElement::fCSCBits; Bool_tTEveElement::fCanEditMainColorAllow editing of main color.; Bool_tTEveElement::fCanEditMainTransAllow editing of main transformation.; Bool_tTEveElement::fCanEditMainTransparencyAllow editing of main transparency.; Bool_tTEveCaloViz::fCellIdCacheOKdata cell ids cache state; vector<TEveCaloData::CellId_t,allocator<TEveCaloData::CellId_t> >fCellList; Int_tfCellPixelFontSize; UChar_tTEveElement::fChangeBits!; list<TEveElement*>TEveElement::fChildrenList of children.; TEveCompound*TEveElement::fCompoundCompound this object belongs to.; TEveCaloData*TEveCaloViz::fDataevent data reference; Int_tTEveElement::fDenyDestroy! Deny-destroy count.; Bool_tTEveElement::fDestroyOnZeroRefCntAuto-destruct when ref-count reaches zero.; Char_tTEveElement::fDestructing!; Bool_tfDrawHPlane; Int_tfDrawNumberCellPixels; Float_tTEveCaloViz::fEndCapPosend cap z coordinate in cm; Double_tTEveCaloViz::fEtaMax; Double_tTEveCaloViz::fEtaMin; Float_tfFixedHeightValIn2DMode1% of whole height; Color_tfFontColor; Color_tfGridColor; Float_tfHPlaneVal; Bool_tfHasFixedHeightIn2DMode; Bool_tTEveElement::fHighlighted!; Short_tTEveElement::fImpliedHighlighted!; Short_tTEveElement::fImpliedSelected!; set<TEveElement::TEveListTreeInfo,less<TEveElement::TEveListTreeInfo>,allocator<TEveElement::TEveListTreeInfo> >TEveElement::fItems! Set of list-tree-items.; Col",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEveCaloLego.html:21818,cache,cache,21818,root/html528/TEveCaloLego.html,https://root.cern,https://root.cern/root/html528/TEveCaloLego.html,4,['cache'],['cache']
Performance,"ny user class. This fixes [ROOT-7972].; Reduce autoparse occasions by autoloading libraries also based on their type_info-derived name, instead of only their normalized name.; Improve TClassEdit’s handling of STL’s default allocator, in particular for std::map ROOT-8048. Dictionaries. Add the -noIncludePaths and –noIncludePaths to rootcling and genereflex respectively to avoid storing in the dictionaries the include paths passed with the “-I” switch. ROOT will rely on ROOT_INCLUDE_PATH only at runtime to find headers. I/O. Resolve an issue when space is freed in a large ROOT file and a TDirectory is updated and stored the lower (less than 2GB) freed portion of the file [ROOT-8055]. TTree. Do not automatically setup read cache during TTree::Fill(). This fixes [ROOT-8031]. Fast Cloning. Added a cache specifically for the fast option of the TTreeCloner to significantly reduce the run-time when fast-cloning remote files to address [ROOT-5078].; The new cache can be controlled from the TTreeCloner, TTree::CopyEntries or hadd interfaces.; The new cache is enabled by default.; To update the size of the cache or disable it:; From TTreeCloner use: TTreeCloner::SetCacheSize; From TTree::CopyEntries add to the option string ""cachesize=SIZE""; From hadd, use the command line option -cachesize SIZE; SIZE should be given in number bytes and can be expressed in ‘human readable form’ (number followed by size unit like MB, MiB, GB or GiB, etc. or SIZE can be set zero to disable the cache. Release 6.04/18; Published on 2016-06-22.; Core. Fix the validity of TRef after the first ProcessID is full. TTree. Properly handle the last element of arrays in the TTreeFormula functions MinIf and MaxIf ROOT-7258. Bugs and issues fixed. [ROOT-6923] - Memory leak with circular TTree; [ROOT-7258] - MinIf and MaxIf TTreeFormula functions ignore last element; [ROOT-7867] - memprobe script is broken when using CMake; [ROOT-8066] - problems creating dictionaries in pyROOT; [ROOT-8068] - Fix file flags f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v604/release-notes.html:38840,cache,cache,38840,doc/v604/release-notes.html,https://root.cern,https://root.cern/doc/v604/release-notes.html,1,['cache'],['cache']
Performance,"ny). ClassStreamerFunc_t GetStreamerFunc() const; Get a wrapper/accessor function around this class custom streamer (member function). TVirtualIsAProxy* GetIsAProxy() const; Return the proxy implementing the IsA functionality. TClass * GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE); Static method returning pointer to TClass of the specified class name.; If load is true an attempt is made to obtain the class by loading; the appropriate shared library (directed by the rootmap file).; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members); Returns 0 in case class is not found. THashTable * GetClassShortTypedefHash(); Return the class' names massaged with TClassEdit::ShortType with kDropStlDefault. TClass * GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE); Return pointer to class with name. VoidFuncPtr_t GetDict(const char* cname); Return a pointer to the dictionary loading function generated by; rootcint. VoidFuncPtr_t GetDict(const type_info& info); Return a pointer to the dictionary loading function generated by; rootcint. TDataMember * GetDataMember(const char* datamember) const; Return pointer to datamember object with name ""datamember"". Long_t GetDataMemberOffset(const char* membername) const; return offset for member name. name can be a data member in; the class itself, one of its base classes, or one member in; one of the aggregated classes. In case of an emulated class, the list of emulated TRealData is built. TRealData* GetRealData(const char* name) const; -- Return pointer to TRealData element with name ""name"". Name can be a data member in the class itself,; one of its base classes, or a member in; one of the aggregated classes. In case of an emulated class, the list of emulated TRealData is built. const char * GetSharedLibs(); Get the list of shared libraries containing the code for class cls.; The first library in t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TClass.html:27385,load,loading,27385,root/html528/TClass.html,https://root.cern,https://root.cern/root/html528/TClass.html,6,['load'],['loading']
Performance,"o (CpuInfo_t *info, Int_t sampleTime=1000) const;  Returns cpu load average and load info into the CpuInfo_t structure. ;  ; virtual Int_t GetCryptoRandom (void *buf, Int_t len);  Return cryptographic random number Fill provided buffer with random values Returns number of bytes written to buffer or -1 in case of error. ;  ; virtual TString GetDirName (const char *pathname);  Return the directory name in pathname. ;  ; virtual void * GetDirPtr () const;  ; virtual const char * GetDynamicPath ();  Return the dynamic path (used to find shared libraries). ;  ; virtual Int_t GetEffectiveGid ();  Returns the effective group id. ;  ; virtual Int_t GetEffectiveUid ();  Returns the effective user id. ;  ; virtual const char * Getenv (const char *env);  Get environment variable. ;  ; virtual const char * GetError ();  Return system error string. ;  ; const char * GetErrorStr () const;  ; virtual const char * GetFlagsDebug () const;  Return the debug flags. ;  ; virtual const char * GetFlagsOpt () const;  Return the optimization flags. ;  ; virtual Int_t GetFPEMask ();  Return the bitmap of conditions that trigger a floating point exception. ;  ; virtual TString GetFromPipe (const char *command);  Execute command and return output in TString. ;  ; virtual int GetFsInfo (const char *path, Long_t *id, Long_t *bsize, Long_t *blocks, Long_t *bfree);  Get info about a file system: fs type, block size, number of blocks, number of free blocks. ;  ; virtual Int_t GetGid (const char *group=nullptr);  Returns the group's id. If group = 0, returns current user's group. ;  ; virtual UserGroup_t * GetGroupInfo (const char *group=nullptr);  Returns all group info in the UserGroup_t structure. ;  ; virtual UserGroup_t * GetGroupInfo (Int_t gid);  Returns all group info in the UserGroup_t structure. ;  ; virtual std::string GetHomeDirectory (const char *userName=nullptr) const;  Return the user's home directory. ;  ; virtual TInetAddress GetHostByName (const char *server);  Get Internet Proto",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDavixSystem.html:7507,optimiz,optimization,7507,doc/master/classTDavixSystem.html,https://root.cern,https://root.cern/doc/master/classTDavixSystem.html,2,['optimiz'],['optimization']
Performance,"o LogNormal distribution. void AddUniformSyst(string syst); set constraint term for given systematic to uniform distribution. void AddNoSyst(string syst); define given systematics to have no external constraint. bool HasChannel(string ); is the given channel part of this measurement. RooStats::HistFactory::Channel& GetChannel(string ); get channel with given name from this measurement; throws an exception in case the channel is not found. void PrintTree(ostream& = std::cout); print information about measurement object in tree-like structure to given stream. void PrintXML(string Directory = """", string NewOutputPrefix = """"); create XML files for this measurement in the given directory; XML files can be configured with a different output prefix. void writeToFile(TFile* file); A measurement, once fully configured, can be saved into a ROOT; file. This will persitify the Measurement object, along with any; channels and samples that have been added to it. It can then be; loaded, potentially modified, and used to create new models. std::string GetDirPath(TDirectory* dir); Return the directory's path,; stripped of unnecessary prefixes. void CollectHistograms(); The most common way to add histograms to channels is to have them; stored in ROOT files and to give HistFactory the location of these; files. This means providing the path to the ROOT file and the path; and name of the histogram within that file. When providing these; in a script, HistFactory doesn't load the histogram from the file; right away. Instead, once all such histograms have been supplied,; one should run this method to open all ROOT files and to copy and; save all necessary histograms. Measurement(); Measurement( const Measurement& other ); // Copy. Measurement(const char* Name, const char* Title = """"). void SetOutputFilePrefix(const string& prefix); set output prefix. { fOutputFilePrefix = prefix; }. std::string GetOutputFilePrefix(); retrieve prefix for output files. { return fOutputFilePrefix; }. void SetP",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooStats__HistFactory__Measurement.html:11082,load,loaded,11082,root/html602/RooStats__HistFactory__Measurement.html,https://root.cern,https://root.cern/root/html602/RooStats__HistFactory__Measurement.html,4,['load'],['loaded']
Performance,"o LogNormal distribution. void AddUniformSyst(string syst); set constraint term for given systematic to uniform distribution. void AddNoSyst(string syst); define given systematics to have no external constraint. bool HasChannel(string ); is the given channel part of this measurement. RooStats::HistFactory::Channel& GetChannel(string ); get channel with given name from this measurement; throws an exception in case the channel is not found. void PrintTree(ostream& = std::cout); print information about measurement object in tree-like structure to given stream. void PrintXML(string Directory = """", string NewOutputPrefix = """"); create XML files for this measurement in the given directory; XML files can be configured with a different output prefix. void writeToFile(TFile* file); A measurement, once fully configured, can be saved into a ROOT; file. This will persitify the Measurement object, along with any; channels and samples that have been added to it. It can then be; loaded, potentially modified, and used to create new models. std::string GetDirPath(TDirectory* dir); Return the directory's path,; stripped of unnecessary prefixes. void CollectHistograms(); The most common way to add histograms to channels is to have them; stored in ROOT files and to give HistFactory the location of these; files. This means providing the path to the ROOT file and the path; and name of the histogram within that file. When providing these; in a script, HistFactory doesn't load the histogram from the file; right away. Instead, once all such histograms have been supplied,; one should run this method to open all ROOT files and to copy and; save all necessary histograms. Measurement(); Measurement( const Measurement& other ); // Copy. void SetOutputFilePrefix(const string& prefix); set output prefix. { fOutputFilePrefix = prefix; }. std::string GetOutputFilePrefix(); retrieve prefix for output files. { return fOutputFilePrefix; }. void SetPOI(const string& POI); insert PoI at beginning of vecto",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStats__HistFactory__Measurement.html:10520,load,loaded,10520,root/html534/RooStats__HistFactory__Measurement.html,https://root.cern,https://root.cern/root/html534/RooStats__HistFactory__Measurement.html,2,['load'],['loaded']
Performance,"o TGLPysicalShape that need to be notified; when the shape is destroyed.; Could also deliver 'change' notifications. Function Members (Methods); public:. virtual~TGLPShapeRef(); static TClass*Class(); TGLPhysicalShape*GetPShape() const; virtual TClass*IsA() const; virtual voidPShapeModified(); virtual voidSetPShape(TGLPhysicalShape* shape); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TGLPShapeRef(); TGLPShapeRef(TGLPhysicalShape* shape). private:. TGLPShapeRef&operator=(const TGLPShapeRef&); TGLPShapeRef(const TGLPShapeRef&). Data Members; protected:. TGLPhysicalShape*fPShapePointer to referenced physical shape. private:. TGLPShapeRef*fNextPSRefInternal pointer to the next reference (used by TGLPhysicalShape directly). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLPShapeRef(); Default contructor. TGLPShapeRef(TGLPhysicalShape* shape); Constructor with known shape - reference it. ~TGLPShapeRef(); Destructor - unreference the shape if set. void SetPShape(TGLPhysicalShape* shape); Set the shape. Unreference the old and reference the new.; This is virtual so that sub-classes can perform other tasks; on change. This function should be called first from there. This is also called from destructor of the refereced physical; shape with 0 argument. void PShapeModified(); This is called from physical shape when it is modified.; Sub-classes can override and take appropriate action. TGLPShapeRef(const TGLPShapeRef& ). TGLPShapeRef& operator=(const TGLPShapeRef& ). TGLPhysicalShape * GetPShape() const; { return fPShape; }. » Author: Matevz Tadel, Feb 2007 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id$ » Last generated: 2015-06-02 15:52; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGLPShapeRef.html:1551,perform,perform,1551,root/html604/TGLPShapeRef.html,https://root.cern,https://root.cern/root/html604/TGLPShapeRef.html,2,['perform'],['perform']
Performance,"o TGLPysicalShape that need to be notified; when the shape is destroyed.; Could also deliver 'change' notifications. Function Members (Methods); public:. virtual~TGLPShapeRef(); static TClass*Class(); TGLPhysicalShape*GetPShape() const; virtual TClass*IsA() const; virtual voidPShapeModified(); virtual voidSetPShape(TGLPhysicalShape* shape); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TGLPShapeRef(); TGLPShapeRef(TGLPhysicalShape* shape). private:. TGLPShapeRef&operator=(const TGLPShapeRef&); TGLPShapeRef(const TGLPShapeRef&). Data Members; protected:. TGLPhysicalShape*fPShapePointer to referenced physical shape. private:. TGLPShapeRef*fNextPSRefInternal pointer to the next reference (used by TGLPhysicalShape directly). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLPShapeRef(); Default contructor. TGLPShapeRef(TGLPhysicalShape* shape); Constructor with known shape - reference it. ~TGLPShapeRef(); Destructor - unreference the shape if set. void SetPShape(TGLPhysicalShape* shape); Set the shape. Unreference the old and reference the new.; This is virtual so that sub-classes can perform other tasks; on change. This function should be called first from there. This is also called from destructor of the refereced physical; shape with 0 argument. void PShapeModified(); This is called from physical shape when it is modified.; Sub-classes can override and take appropriate action. TGLPShapeRef(const TGLPShapeRef& ). TGLPShapeRef& operator=(const TGLPShapeRef& ). TGLPhysicalShape * GetPShape() const; { return fPShape; }. » Author: Matevz Tadel, Feb 2007 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id$ » Last generated: 2015-06-30 14:53; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGLPShapeRef.html:1551,perform,perform,1551,root/html602/TGLPShapeRef.html,https://root.cern,https://root.cern/root/html602/TGLPShapeRef.html,2,['perform'],['perform']
Performance,"o a key symbol (according to the modifiers specified in...Definition TGWin32VirtualXProxy.cxx:285; TGWin32VirtualXProxy::GetParentWindow_t GetParent(Window_t id) const overridemight be thread unsafe (?)Definition TGWin32VirtualXProxy.cxx:274; TGWin32VirtualXProxy::SendEventvoid SendEvent(Window_t id, Event_t *ev) overrideSend event ev to window id.Definition TGWin32VirtualXProxy.cxx:320; TGWin32VirtualXProxy::GetCurrentWindowWindow_t GetCurrentWindow() const overrideReturn a pointer to the current window.Definition TGWin32VirtualXProxy.cxx:336; TGWin32VirtualXProxy::EventsPendingInt_t EventsPending() overrideReturn number of pending events.Definition TGWin32VirtualXProxy.cxx:296; TGWin32VirtualXProxy::IsCmdThreadBool_t IsCmdThread() const overrideReturn kTRUE if we are inside cmd/server thread.Definition TGWin32VirtualXProxy.cxx:328; TGWin32VirtualXProxy::RealObjectstatic TVirtualX * RealObject()Definition TGWin32VirtualXProxy.cxx:32; TGWin32VirtualXProxy::NextEventvoid NextEvent(Event_t &event) overrideProcess next event in the queue - if any.Definition TGWin32VirtualXProxy.cxx:304; TPointDefinition TPoint.h:31; TStringBasic string class.Definition TString.h:139; TVirtualXSemi-Abstract base class defining a generic interface to the underlying, low level,...Definition TVirtualX.h:46; TVirtualX::IsCmdThreadvirtual Bool_t IsCmdThread() constDefinition TVirtualX.h:328; TVirtualX::LookupStringvirtual void LookupString(Event_t *event, char *buf, Int_t buflen, UInt_t &keysym)Converts the keycode from the event structure to a key symbol (according to the modifiers specified i...Definition TVirtualX.cxx:2009; TVirtualX::SendEventvirtual void SendEvent(Window_t id, Event_t *ev)Specifies the event ""ev"" is to be sent to the window ""id"".Definition TVirtualX.cxx:1623; TVirtualX::GetCurrentWindowvirtual Window_t GetCurrentWindow() constpointer to the current internal window used in canvas graphicsDefinition TVirtualX.cxx:2341; TVirtualX::NextEventvirtual void NextEvent(Event_t &ev",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGWin32VirtualXProxy_8cxx_source.html:95011,queue,queue,95011,doc/master/TGWin32VirtualXProxy_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGWin32VirtualXProxy_8cxx_source.html,1,['queue'],['queue']
Performance,"o a single value (Reduce). ; Parameters. funcFunction to be executed. ; nTimesNumber of times function should be called. . ReturnsA vector with the results of the function calls. ; Parameters. redfuncReduction function to combine the results of the calls to func. Must return the same type as func. . ReturnsA value result of ""reducing"" the vector returned by the Map operation into a single object. ; Definition at line 482 of file TThreadExecutor.hxx. ◆ MapReduce() [8/8]. template<class F , class R , class Cond > . auto ROOT::TThreadExecutor::MapReduce ; (; F ; func, . unsigned ; nTimes, . R ; redfunc, . unsigned ; nChunks . ); -> InvokeResult_t<F>. Execute a function in parallel over the elements of a vector (Map) and accumulate the results into a single value (Reduce). ; Benefits from partial reduction into nChunks intermediate results.; Benefits from partial reduction into nChunks intermediate results if the execution policy is multithreaded. Otherwise, it ignores the nChunks argument and performs a normal MapReduce operation.; Parameters. funcFunction to be executed. Must take an element of the sequence passed as second argument as a parameter. ; nTimesNumber of times function should be called. ; redfuncReduction function to combine the results of the calls to func into partial results, and these into a final result. Must return the same type as func and should be callable with const std::vector<T> where T is the output of func. ; nChunksNumber of chunks to split the input data for processing. . ReturnsA value result of ""reducing"" the vector returned by the Map operation into a single object. ; Definition at line 493 of file TThreadExecutor.hxx. ◆ operator=(). TThreadExecutor & ROOT::TThreadExecutor::operator= ; (; const TThreadExecutor & ; ). delete . ◆ ParallelFor(). void ROOT::TThreadExecutor::ParallelFor ; (; unsigned ; start, . unsigned ; end, . unsigned ; step, . const std::function< void(unsigned int i)> & ; f . ). private . Execute a function in parallel o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1TThreadExecutor.html:31555,perform,performs,31555,doc/v632/classROOT_1_1TThreadExecutor.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1TThreadExecutor.html,2,['perform'],['performs']
Performance,"o a static char array in TROOT.; If this function is called in a loop or recursively, it is the; user's responsability to copy this string in their area. TClass * FindSTLClass(const char* name, Bool_t load, Bool_t silent = kFALSE) const; return a TClass object corresponding to 'name' assuming it is an STL container.; In particular we looking for possible alternative name (default template; parameter, typedefs template arguments, typedefed name). TClass * GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE) const; Return pointer to class with name. Obsolete, use TClass::GetClass directly. TClass * GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE) const; Return pointer to class from its name. Obsolete, use TClass::GetClass directly; See TClass::GetClass. TColor * GetColor(Int_t color) const; Return address of color with index color. TCanvas * MakeDefCanvas() const; Return a default canvas. TDataType * GetType(const char* name, Bool_t load = kFALSE) const; Return pointer to type with name. TFile * GetFile(const char* name) const; Return pointer to file with name. TStyle * GetStyle(const char* name) const; Return pointer to style with name. TObject * GetFunction(const char* name) const; Return pointer to function with name. TFunctionTemplate * GetFunctionTemplate(const char* name). TGlobal * GetGlobal(const char* name, Bool_t load = kFALSE) const; Return pointer to global variable by name. If load is true force; reading of all currently defined globals from CINT (more expensive). TGlobal * GetGlobal(const TObject* obj, Bool_t load = kFALSE) const; Return pointer to global variable with address addr. TListOfFunctions * GetGlobalFunctions(); Internal routine returning, and creating if necessary, the list; of global function. TCollection * GetListOfFunctionOverloads(const char* name) const; Return the collection of functions named ""name"". TFunction * GetGlobalFunction(const char* name, const char* params = 0, Bool_t load = k",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TROOT.html:26364,load,load,26364,root/html602/TROOT.html,https://root.cern,https://root.cern/root/html602/TROOT.html,4,['load'],['load']
Performance,"o activate normalization value caching; TVectorD*_mref; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; TIterator*_pdfItr!; RooListProxy_pdfList; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; RooMomentMorph::Setting_setting; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooMomentMorph.html:40018,cache,cache,40018,root/html532/RooMomentMorph.html,https://root.cern,https://root.cern/root/html532/RooMomentMorph.html,2,['cache'],['cache']
Performance,"o be a streamerinfo object in the record for that class. In this way, each class is recursively decomposed into its atomic elements, each of which is a simple type (e.g. ""int""). A ""long"" or ""unsigned long"" member is always written as an 8 byte quantity, even if it occupies only 4 bytes in memory.; A data member of a class is marked transient on the line of its declaration by a comment beginning with ""//!"". Such members are not written to disk, nor is there any streamerinfo for such a member.; A data member that is a C++ pointer (not to be confused with ""pointers to persistent; objects"" described below) is never written to disk as a pointer value. If it is a pointer to an object, the object itself (or 0 (4 bytes) if the pointer value is NULL) is written. If the declaration line has a comment beginning with ""//->"", this indicates that the pointer value will never be null, which allows a performance optimization. Another optimization is that if two or more pointers pointing to the same object are streamed in the same I/O operation, the object is written only once. The remaining pointers reference the object through a unique object identifier. This saves space and avoids the infinite loop that might otherwise arise if the directed graph of object instance pointer references contains a cycle.; If a data member is a pointer to a simple type, the Streamer presumes it is an array, with the dimension defined in a comment of the form ""//[<length>]"", where length is either an integer constant or a variable that is an integer data member of the class. If a variable is used, it must be defined ahead of its use or in a base class.; The above describes the function of the StreamerInfo record in decomposing a self-identifying object if the user uses the streamer generated by ""rootcint"". There are two reasons why a user may need to write a specialized streamer for a class. One reason is that it may be necessary to execute some code before or after data is read or written, for exampl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rootio.html:8578,optimiz,optimization,8578,doc/master/rootio.html,https://root.cern,https://root.cern/doc/master/rootio.html,1,['optimiz'],['optimization']
Performance,"o be available.; 261 mutable std::atomic<Bool_t> fIsOffsetStreamerSet; //!saved remember if fOffsetStreamer has been set.; 262 mutable std::atomic<Bool_t> fVersionUsed; //!Indicates whether GetClassVersion has been called; 263 ; 264 enum class ERuntimeProperties : UChar_t {; 265 kNotInitialized = 0,; 266 kSet = BIT(0),; 267 // kInconsistent when kSet & !kConsistent.; 268 kConsistentHash = BIT(1); 269 };; 270 friend bool operator&(UChar_t l, ERuntimeProperties r) {; 271 return l & static_cast<UChar_t>(r);; 272 }; 273 mutable std::atomic<UChar_t> fRuntimeProperties; //! Properties that can only be evaluated at run-time; 274 ; 275 mutable Longptr_t fOffsetStreamer; //!saved info to call Streamer; 276 Int_t fStreamerType; //!cached of the streaming method to use; 277 EState fState; //!Current 'state' of the class (Emulated,Interpreted,Loaded); 278 mutable std::atomic<TVirtualStreamerInfo*> fCurrentInfo; //!cached current streamer info.; 279 mutable std::atomic<TVirtualStreamerInfo*> fLastReadInfo; //!cached streamer info used in the last read.; 280 TVirtualRefProxy *fRefProxy; //!Pointer to reference proxy if this class represents a reference; 281 ROOT::Detail::TSchemaRuleSet *fSchemaRules; //! Schema evolution rules; 282 ; 283 typedef void (*StreamerImpl_t)(const TClass* pThis, void *obj, TBuffer &b, const TClass *onfile_class);; 284#ifdef R__NO_ATOMIC_FUNCTION_POINTER; 285 mutable StreamerImpl_t fStreamerImpl; //! Pointer to the function implementing streaming for this class; 286#else; 287 mutable std::atomic<StreamerImpl_t> fStreamerImpl; //! Pointer to the function implementing streaming for this class; 288#endif; 289 ; 290 Bool_t CanSplitBaseAllow();; 291 TListOfFunctions *GetMethodList();; 292 TMethod *GetClassMethod(Longptr_t faddr);; 293 TMethod *FindClassOrBaseMethodWithId(DeclId_t faddr);; 294 Int_t GetBaseClassOffsetRecurse(const TClass *toBase);; 295 void Init(const char *name, Version_t cversion, const std::type_info *info,; 296 TVirtualIsAProxy *isa,; 297 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8h_source.html:12806,cache,cached,12806,doc/master/TClass_8h_source.html,https://root.cern,https://root.cern/doc/master/TClass_8h_source.html,2,['cache'],['cached']
Performance,"o be grouped and handled together, for different possible reasons. One of these is that the structure has to be replicated in several parts of the geometry, or it may simply happen that they really represent a single object, too complex to be described by a primitive shape.; Usually handling structures like these can be easily done by positioning all components in the same container volume, then positioning the container itself. However, there are many practical cases when defining such a container is not straightforward or even possible without generating overlaps with the rest of the geometry. There are few ways out of this:. Defining the container for the structure as ""overlapping"" (see also ""Overlapping Volumes""); Representing the container as a composite shape - the Boolean union of all components (see also ""Composite Shapes""); Using an assembly volume - this will be described in the following. The first two approaches have the disadvantage of penalizing the navigation performance with a factor increasing more than linear of the number of components in the structure. The best solution is the third one because it uses all volume-related navigation optimizations. The class TGeoVolumeAssembly represents an assembly volume. Its shape is represented by TGeoShapeAssembly class that is the union of all components. It uses volume voxelization to perform navigation tasks.; An assembly volume creates a hierarchical level and it geometrically insulates the structure from the rest (as a normal volume). Physically, a point that is INSIDE a TGeoShapeAssembly is always inside one of the components, so a TGeoVolumeAssembly does not need to have a medium. Due to the self-containment of assemblies, they are very practical to use when a container is hard to define due to possible overlaps during positioning. For instance, it is very easy creating honeycomb structures. A very useful example for creating and using assemblies can be found at: assembly.C.; Creation of an assembly is ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:51338,perform,performance,51338,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['perform'],['performance']
Performance,"o be used ; map<TString,TMVA::Interval*>fTuneParametersparameters included in the tuning; map<TString,Double_t>fTunedParametersparameters included in the tuning. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; OptimizeConfigParameters(TMVA::MethodBase *const method, map<TString,TMVA::Interval*> tuneParameters, TString fomType = ""Separation"", TString optimizationType = ""GA""); Constructor which sets either ""Classification or Regression"". ~OptimizeConfigParameters(); the destructor (delete the OptimizeConfigParameters, store the graph and .. delete it). std::map<TString,Double_t> optimize(). std::vector< int > GetScanIndices(int val, vector<int> base); helper function to scan through the all the combinations in the; parameter space. void optimizeScan(); do the actual optimization using a simple scan method,; i.e. calcualte the FOM for; different tuning paraemters and remember which one is; gave the best FOM. void optimizeFit(); ranges (intervals) in which the fit varies the parameters. Double_t EstimatorFunction(vector<Double_t>& ); return the estimator (from current FOM) for the fitting interface. Double_t GetFOM(); Return the Figure of Merit (FOM) used in the parameter; optimization process. void GetMVADists(); fill the private histograms with the mva distributinos for sig/bkg. Double_t GetSeparation(); return the searation between the signal and background; MVA ouput distribution. Double_t GetROCIntegral(); calculate the area (integral) under the ROC curve as a; overall quality measure of the classification. makeing pdfs out of the MVA-ouput distributions doesn't work; reliably for cases where the MVA-ouput isn't a smooth distribution.; this happens ""frequently"" in BDTs for example when the number of; trees is small resulting in only some discrete possible MVA ouput values.; (I still leave the code here, but use this with care!!! The default; however is to use the distributions!!!. Double_t GetSigEffAtBkgEff(Double_t bkgEff ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__OptimizeConfigParameters.html:3436,optimiz,optimizeFit,3436,root/html534/TMVA__OptimizeConfigParameters.html,https://root.cern,https://root.cern/root/html534/TMVA__OptimizeConfigParameters.html,2,['optimiz'],['optimizeFit']
Performance,"o control granularity of the; binning of the cache histogram set the desired properties in the; binning named ""cache"" in the observables of the function.; If the fixed set of cache observables does not match the observables; defined in the use context of the p.d.f the cache is still filled; completely. Ee.g. when it is specified to cache x and p and only x; is a observable in the given use context the cache histogram will; store sampled values for all values of observable x and parameter p.; In such a mode of operation the cache will also not be recalculated; if the observable p changes. RooCachedReal(const RooCachedReal& other, const char* name = 0); Copy constructor. ~RooCachedReal(); Destructor. RooAbsCachedReal::FuncCacheElem* createCache(const RooArgSet* nset) const; Interface function to create an internal cache object that represent; each cached function configuration. This interface allows to create and; return a class derived from RooAbsCachedReal::FuncCacheElem so that; a derived class fillCacheObject implementation can utilize extra functionality; defined in such a derived cache class. void fillCacheObject(RooAbsCachedReal::FuncCacheElem& cacheFunc) const. RooArgSet* actualObservables(const RooArgSet& nset) const; If this pdf is operated with a fixed set of observables, return; the subset of the fixed observables that are actual dependents; of the external input p.d.f. If this p.d.f is operated without; a fixed set of cache observables, return the actual observables; of the external input p.d.f given the choice of observables defined; in nset. RooArgSet* actualParameters(const RooArgSet& nset) const; If this p.d.f is operated with a fixed set of observables, return; all variables of the external input p.d.f that are not one of; the cache observables. If this p.d.f is operated in automatic mode,; return the parameters of the external input p.d.f. void operModeHook(). RooCachedReal(); coverity[UNINIT_CTOR]. TObject* clone(const char* newname) const; { return",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooCachedReal.html:40304,cache,cache,40304,root/html604/RooCachedReal.html,https://root.cern,https://root.cern/root/html604/RooCachedReal.html,2,['cache'],['cache']
Performance,"o control granularity of the; binning of the cache histogram set the desired properties in the; binning named ""cache"" in the observables of the function.; If the fixed set of cache observables does not match the observables; defined in the use context of the p.d.f the cache is still filled; completely. Ee.g. when it is specified to cache x and p and only x; is a observable in the given use context the cache histogram will; store sampled values for all values of observable x and parameter p.; In such a mode of operation the cache will also not be recalculated; if the observable p changes. RooCachedReal(const RooCachedReal& other, const char* name = 0); Copy constructor. ~RooCachedReal(); Destructor. RooAbsCachedReal::FuncCacheElem* createCache(const RooArgSet* nset) const; Interface function to create an internal cache object that represent; each cached function configuration. This interface allows to create and; return a class derived from RooAbsCachedReal::FuncCacheElem so that; a derived class fillCacheObject implementation can utilize extra functionality; defined in such a derived cache class. void fillCacheObject(RooAbsCachedReal::FuncCacheElem& cacheFunc) const; Update contents of cache histogram by resampling the input function. RooArgSet* actualObservables(const RooArgSet& nset) const; If this pdf is operated with a fixed set of observables, return; the subset of the fixed observables that are actual dependents; of the external input p.d.f. If this p.d.f is operated without; a fixed set of cache observables, return the actual observables; of the external input p.d.f given the choice of observables defined; in nset. RooArgSet* actualParameters(const RooArgSet& nset) const; If this p.d.f is operated with a fixed set of observables, return; all variables of the external input p.d.f that are not one of; the cache observables. If this p.d.f is operated in automatic mode,; return the parameters of the external input p.d.f. void operModeHook(). RooCachedReal(); cover",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooCachedReal.html:38806,cache,cache,38806,root/html534/RooCachedReal.html,https://root.cern,https://root.cern/root/html534/RooCachedReal.html,4,['cache'],['cache']
Performance,"o copies of the tree headers; are saved. void tree3AddBranch(){; TFile f(""tree3.root"", ""update"");. Float_t new_v;; TTree *t3 = (TTree*)f->Get(""t3"");; TBranch *newBranch = t3->Branch(""new_v"", &new_v, ""new_v/F"");. //read the number of entries in the t3; Long64_t nentries = t3->GetEntries();. for (Long64_t i = 0; i < nentries; i++){; new_v= gRandom->Gaus(0, 1);; newBranch->Fill();; }; // save only the new version of the tree; t3->Write("""", TObject::kOverwrite);; }; Adding a branch is often not possible because the tree is in a read-only; file and you do not have permission to save the modified tree with the; new branch. Even if you do have the permission, you risk losing the; original tree with an unsuccessful attempt to save the modification.; Since trees are usually large, adding a branch could extend it over the; 2GB limit. In this case, the attempt to write the tree fails, and the; original data is erased.; In addition, adding a branch to a tree enlarges the tree and increases; the amount of memory needed to read an entry, and therefore decreases; the performance. For these reasons, ROOT offers the concept of friends for trees (and chains).; We encourage you to use TTree::AddFriend rather than adding a branch manually. /*. */. A simple example with histograms and a tree*-*-*-; *-* ===========================================. This program creates :; - a one dimensional histogram; - a two dimensional histogram; - a profile histogram; - a tree. These objects are filled with some random numbers and saved on a file. -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*. #include ""TFile.h""; #include ""TH1.h""; #include ""TH2.h""; #include ""TProfile.h""; #include ""TRandom.h""; #include ""TTree.h"". //______________________________________________________________________________; main(int argc, char **argv); {; // Create a new ROOT binary machine independent file.; // Note that this file may contain any kind of ROOT objects, histograms,trees; // pictures, graphics ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTree.html:8282,perform,performance,8282,root/html528/TTree.html,https://root.cern,https://root.cern/root/html528/TTree.html,10,['perform'],['performance']
Performance,"o describe 3D objects (""shapes""); filled /added by negotiation with viewer via TVirtualViewer3D. Together these allow clients to publish objects to any one of the 3D viewers (currently OpenGL/x3d,TPad), free of viewer specific drawing code. They allow our simple x3d viewer, and considerably more sophisticated OpenGL one to both work with both geometry libraries (g3d and geom) efficiently.; Publishing to a viewer consists of the following steps:. Create / obtain viewer handle; Begin scene on viewer; Fill mandatory parts of TBuffer3D describing object; Add to viewer; Fill optional parts of TBuffer3D if requested by viewer, and add again ... repeat 3/4/5 as required; End scene on viewer. Creating / Obtaining Viewer; Create/obtain the viewer handle via local/global pad - the viewer is always bound to a TPad object at present [This may be removed as a restriction in the future] . You should perform the publishing to the viewer described below in the Paint() method of the object you attach to the pad (via Draw()) TVirtualViewer3D * v = gPad->GetViewer3D(""xxxx"");; gPad#define gPadDefinition TVirtualPad.h:308; TVirtualViewer3DAbstract 3D shapes viewer.Definition TVirtualViewer3D.h:34; v@ vDefinition rootcling_impl.cxx:3699; "" xxxx"" is viewer type: OpenGL ""ogl"", X3D ""x3d"" or Pad ""pad"" (default). The viewer is created via the plugin manager, attached to pad, and the interface returned. Begin / End Scene; Objects must be added to viewer between BeginScene/EndScene calls e.g. v->BeginScene();; .....; v->AddObject(....);; v->AddObject(....);; .....; v->EndScene();; The BeginScene call will cause the viewer to suspend redraws etc, and after the EndScene the viewer will reset the camera to frame the new scene and redraw. [x3d viewer does not support changing of scenes - objects added after the first Open/CloseScene pair will be ignored.]. Filling TBuffer3D and Adding to Viewer; The viewers behind the TVirtualViewer3D interface differ greatly in their capabilities e.g. Some know ho",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTVirtualViewer3D.html:1601,perform,perform,1601,doc/master/classTVirtualViewer3D.html,https://root.cern,https://root.cern/doc/master/classTVirtualViewer3D.html,1,['perform'],['perform']
Performance,"o describe the Value_type or the key_type of an STL container.Definition TGenCollectionProxy.h:60; TGenCollectionProxy::Value::DeleteItemvoid DeleteItem(void *ptr)Definition TGenCollectionProxy.cxx:518; TGenCollectionProxy::Value::fCaseUInt_t fCasetype of data of Value_typeDefinition TGenCollectionProxy.h:64; TGenCollectionProxy::Value::fTypeTClassRef fTypeTClass reference of Value_type in collection.Definition TGenCollectionProxy.h:66; TGenCollectionProxy::Value::fPropertiesUInt_t fPropertiesAdditional properties of the value type (kNeedDelete)Definition TGenCollectionProxy.h:65; TGenCollectionProxy::Value::fSizesize_t fSizefSize of the contained objectDefinition TGenCollectionProxy.h:68; TGenCollectionProxy::Value::fDeleteROOT::DelFunc_t fDeleteMethod cache for containee delete.Definition TGenCollectionProxy.h:63; TGenCollectionProxy::Value::fDtorROOT::DesFunc_t fDtorMethod cache for containee destructor.Definition TGenCollectionProxy.h:62; TGenCollectionProxy::Value::fCtorROOT::NewFunc_t fCtorMethod cache for containee constructor.Definition TGenCollectionProxy.h:61; TGenCollectionProxy::Value::ValueValue(const std::string &info, Bool_t silent, size_t hint_pair_offset=0, size_t hint_pair_size=0)Constructor.Definition TGenCollectionProxy.cxx:316; TGenCollectionProxy::Value::fKindEDataType fKindkind of ROOT-fundamental typeDefinition TGenCollectionProxy.h:67; TGenCollectionProxy::Value::IsValidBool_t IsValid()Return true if the Value has been properly initialized.Definition TGenCollectionProxy.cxx:511; TGenCollectionProxy__SlowIteratorDefinition TGenCollectionProxy.cxx:1454; TGenCollectionProxy__SlowIterator::fProxyTVirtualCollectionProxy * fProxyDefinition TGenCollectionProxy.cxx:1455; TGenCollectionProxy__SlowIterator::fIndexUInt_t fIndexDefinition TGenCollectionProxy.cxx:1456; TGenCollectionProxy__SlowIterator::TGenCollectionProxy__SlowIteratorTGenCollectionProxy__SlowIterator(TVirtualCollectionProxy *proxy)Definition TGenCollectionProxy.cxx:1457; vecDefinition c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:98272,cache,cache,98272,doc/master/TGenCollectionProxy_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html,1,['cache'],['cache']
Performance,"o execution will be stopped; TStopwatchfLatencymeasures latency of packet requests; FILE*fLogFilelog file; Int_tfLogFileDeslog file descriptor; Int_tfLogLeveldebug logging level; Bool_tfMasterServtrue if we are a master server; Long64_tfMaxBoxSizeMax size of the sandbox; Int_tfMaxQueriesMax number of queries fully kept; Int_tfMergedWorkersNumber of workers merged; TMonitor*fMergingMonitorMonitor for merging sockets; TServerSocket*fMergingSocketSocket used for merging outputs if submerger; Long64_tfMsgSizeHWMHigh-Water-Mark on the size of messages with results; Int_tfNcmdcommand history number; TStringfOrdinalslave ordinal number; TStringfPackageDirdirectory containing packages and user libs; TProofLockPath*fPackageLockpackage dir locker; TVirtualProofPlayer*fPlayeractual player; TStringfPrefixPrefix identifying the node; TProof*fProofPROOF talking to slave servers; Int_tfProtocolprotocol version number; TQueryResultManager*fQMgrQuery-result manager; TMutex*fQMtxTo protect async msg queue; TStringfQueryDirdirectory containing query results and status; TProofLockPath*fQueryLockquery dir locker; Int_tfQuerySeqNumsequential number of the current or last query; TList*fQueuedMsglist of messages waiting to be processed; Float_tfRealTimereal time spent executing commands; Bool_tfRealTimeLogTRUE if log messages should be send back in real-time; TReaperTimer*fReaperTimerTimer used to control children state; Bool_tfSendLogToMasterOn workers, controls logs sending to master; TStringfServiceservice we are running, either ""proofserv"" or ""proofslave""; TStringfSessionDirdirectory containing session dependent files; TStringfSessionTagtag for the server session; TShutdownTimer*fShutdownTimerTimer used to shutdown out-of-control sessions; TSocket*fSocketsocket connection to client; TStringfTopSessionTagtag for the global session; Int_tfTotSessionsTotal number of PROOF sessions on the cluster ; TStringfUseruser as which we run; TList*fWaitingQuerieslist of TProofQueryResult waiting to ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofServ.html:18774,queue,queue,18774,root/html528/TProofServ.html,https://root.cern,https://root.cern/root/html528/TProofServ.html,1,['queue'],['queue']
Performance,"o factor 1.0). If set to non zero auto cache creation is enabled and both auto created and default sized caches will use the configured factor: 0.0 no automatic cache and greater than 0.0 to enable cache. This value can be overridden by the environment variable ROOT_TTREECACHE_SIZE.; The resource variable TTreeCache.Prefill sets the default TTreeCache prefilling type. The prefill type may be: 0 for no prefilling and 1 to prefill all the branches. It can be overridden by the environment variable ROOT_TTREECACHE_PREFILL; In particular the default can be set back to the same as in version 5 by setting TTreeCache.Size (or ROOT_TTREECACHE_SIZE) and TTreeCache.Prefill (or ROOT_TTREECACHE_PREFILL) both to zero.; TTree methods which are expected to modify a cache, like AddBranchToCache, will attempt to setup a cache of default size if one does not exist, irrespective of whether the auto cache creation is enabled. Additionally several methods giving control of the cache have changed return type from void to Int_t, to be able to return a code to indicate if there was an error.; Usually TTree::SetCacheSize will no longer reset the list of branches to be cached (either set or previously learnt) nor restart the learning phase. The learning phase is restarted when a new cache is created, e.g. after having removed a cache with SetCacheSize(0).; TSelectorDraw; The axis titles in case of a x:y:z plot with the option COLZ were not correct.; TParallelCoordVar; Change the format used to print the variables limit for ||-Coord to %g. It was %6.4f before.; Histogram Libraries; TFormula. New version of the TFormula class based on Cling. Formula expressions are now used to create functions which are passed to Cling to be Just In Time compiled. The expression is therefore compiled using Clang/LLVVM which will give execution time as compiled code and in addition correctness of the result obtained.; This class is not 100% backward compatible with the old TFormula class, which is still available",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v604/release-notes.html:13786,cache,cache,13786,doc/v604/release-notes.html,https://root.cern,https://root.cern/doc/v604/release-notes.html,1,['cache'],['cache']
Performance,"o functions.; See WARNING below about entry.; This method is used by PROOF.; Bool_t TSelector::ProcessCut(Long64_t entry). This method is called; before processing entry. It is the user's responsability to read; the corresponding entry in memory (may be just a partial read).; The function returns kTRUE if the entry must be processed,; kFALSE otherwise. This method is obsolete, use Process().; See WARNING below about entry.; void TSelector::ProcessFill(Long64_t entry). This method is called; for all selected events. User fills histograms in this function.; This method is obsolete, use Process().; See WARNING below about entry.; void TSelector::SlaveTerminate(). This method is called at the end of; the loop on all PROOF worker nodes. In local mode this method is; called on the client too.; void TSelector::Terminate(). This method is called at the end of; the loop on all events. When using PROOF Terminate() is call on; the client only. Typically one performs the fits on the produced; histograms or write the histograms to file in this method. WARNING when a selector is used with a TChain:; in the Process, ProcessCut, ProcessFill function, you must use; the pointer to the current Tree to call GetEntry(entry).; entry is always the local entry number in the current tree.; Assuming that fChain is the pointer to the TChain being processed,; use fChain->GetTree()->GetEntry(entry);. Function Members (Methods); public:. TSelector(); virtual~TSelector(); virtual voidAbort(const char* why, TSelector::EAbort what = kAbortProcess); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBegin(TTree*); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSelector.html:2539,perform,performs,2539,root/html528/TSelector.html,https://root.cern,https://root.cern/root/html528/TSelector.html,2,['perform'],['performs']
Performance,"o handle object notification (the base implementation is no-op). ; Different objects in ROOT use the Notify method for different purposes, in coordination with other objects that call this method at the appropriate time.; For example, TLeaf uses it to load class information; TBranchRef to load contents of referenced branches TBranchRef; most notably, based on Notify, TChain implements a callback mechanism to inform interested parties when it switches to a new sub-tree. ; Reimplemented from TSelector. ◆ Print(). void TSelEventGen::Print ; (; Option_t * ; option = """"); const. overridevirtual . This method must be overridden when a class wants to print itself. ; Reimplemented from TObject.; Definition at line 486 of file TSelEventGen.cxx. ◆ Process(). Bool_t TSelEventGen::Process ; (; Long64_t ; entry). overridevirtual . The Process() function is called for each entry in the tree (or possibly keyed object in the case of PROOF) to be processed. ; The entry argument specifies which entry in the currently loaded tree is to be processed. It can be passed to either TTree::GetEntry() or TBranch::GetEntry() to read either all or the required parts of the data. When processing keyed objects with PROOF, the object is already loaded and is available via the fObject pointer.; This function should contain the ""body"" of the analysis. It can contain simple or elaborate selection criteria, run algorithms on the data of the event and typically fill histograms. ; Reimplemented from TSelector.; Definition at line 326 of file TSelEventGen.cxx. ◆ SetInputList(). void TSelEventGen::SetInputList ; (; TList * ; input). inlineoverridevirtual . Reimplemented from TSelector.; Definition at line 68 of file TSelEventGen.h. ◆ SetObject(). void TSelEventGen::SetObject ; (; TObject * ; obj). inlineoverridevirtual . Reimplemented from TSelector.; Definition at line 67 of file TSelEventGen.h. ◆ SetOption(). void TSelEventGen::SetOption ; (; const char * ; option). inlineoverridevirtual . Reimplemented",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSelEventGen.html:17259,load,loaded,17259,doc/master/classTSelEventGen.html,https://root.cern,https://root.cern/doc/master/classTSelEventGen.html,1,['load'],['loaded']
Performance,o individual branch leaves; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; Int_tTTree::fMakeClass! not zero when processing code generated by MakeClass; Color_tTAttMarker::fMarkerColorMarker color index; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; Int_tTTree::fMaxClusterRange! Memory allocated for the cluster range.; Long64_tTTree::fMaxEntriesMaximum number of entries in case of circular buffers; Long64_tTTree::fMaxEntryLoopMaximum number of entries to process; Long64_tTTree::fMaxVirtualSizeMaximum total size of buffers kept in memory; Int_tTTree::fNClusterRangeNumber of Cluster range in addition to the one defined by 'AutoFlush'; TStringTNamed::fNameobject identifier; Int_tTTree::fNfill! Local for EntryLoop; TObject*TTree::fNotify! Object to be notified when loading a Tree; Int_tfNvarNumber of columns; Int_tTTree::fPacketSize! Number of entries in one packet for parallel root; TVirtualTreePlayer*TTree::fPlayer! Pointer to current Tree player; Long64_tTTree::fReadEntry! Number of the entry being processed; Long64_tTTree::fSavedBytesNumber of autosaved bytes; Int_tTTree::fScanFieldNumber of runs before prompting in Scan; Int_tTTree::fTimerIntervalTimer interval in milliseconds; TStringTNamed::fTitleobject title; Long64_tTTree::fTotBytesTotal number of bytes in all branches before compression; Long64_tTTree::fTotalBuffers! Total number of bytes in branch buffers; TBuffer*TTree::fTransientBuffer! Pointer to the current transient buffer.; TVirtualIndex*TTree::fTreeIndexPointer to the tree Index (if any); Int_tTTree::fUpdateUpdate frequency for EntryLoop; TList*TTree::fUserInfopointer to a list of user objects associated to this Tree; Double_tTTree::fWeightTree weight (see TTree::SetWeight); Long64_tTTree::fZipBytesTotal number of bytes in all branches after compression; static Int_tTTree::fgBranchStyleOld/New branch style; static Long64_tTTree::fgMaxTreeSizeM,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TNtuple.html:23844,load,loading,23844,root/html530/TNtuple.html,https://root.cern,https://root.cern/root/html530/TNtuple.html,6,['load'],['loading']
Performance,"o major and minor number.; Note that this function returns only the entry number, not the data; To read the data corresponding to an entry number, use TTree::GetEntryWithIndex; the BuildIndex function has created a table of Long64_t* of sorted values; corresponding to val = major<<31 + minor;; The function performs binary search in this sorted table.; If it finds a pair that maches val, it returns directly the; index in the table.; If an entry corresponding to major and minor is not found, the function; returns the index of the major,minor pair immediatly lower than the; requested value, ie it will return -1 if the pair is lower than; the first entry in the index. See also GetEntryNumberWithIndex. Long64_t GetEntryNumberWithIndex(Int_t major, Int_t minor = 0) const; Return entry number corresponding to major and minor number.; Note that this function returns only the entry number, not the data; To read the data corresponding to an entry number, use TTree::GetEntryWithIndex; the BuildIndex function has created a table of Long64_t* of sorted values; corresponding to val = major<<31 + minor;; The function performs binary search in this sorted table.; If it finds a pair that maches val, it returns directly the; index in the table, otherwise it returns -1. See also GetEntryNumberWithBestIndex. Int_t GetEntryWithIndex(Int_t major, Int_t minor = 0); Read entry corresponding to major and minor number. The function returns the total number of bytes read.; If the Tree has friend trees, the corresponding entry with; the index values (major,minor) is read. Note that the master Tree; and its friend may have different entry serial numbers corresponding; to (major,minor). TTree* GetFriend(const char* ) const; Return a pointer to the TTree friend whose name or alias is 'friendname. const char* GetFriendAlias(TTree* ) const; If the the 'tree' is a friend, this method returns its alias name. This alias is an alternate name for the tree. It can be used in conjunction with a branch or l",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTree.html:91957,perform,performs,91957,root/html528/TTree.html,https://root.cern,https://root.cern/root/html528/TTree.html,4,['perform'],['performs']
Performance,"o make; ROOT::Math::ParamFunctorTF1::fFunctor! Functor object to wrap any C++ callable object; Double_t*TF1::fGamma!Array gamma.; TH1*TF1::fHistogram!Pointer to histogram used for visualisation; Double_t*TF1::fIntegral![fNpx] Integral of function binned on fNpx bins; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TObjArrayTFormula::fLinearPartsLinear parts if the formula is linear (contains '|' or ""++""); Color_tTAttMarker::fMarkerColorMarker color index; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; Double_tTF1::fMaximumMaximum value for plotting; TMethodCall*TF1::fMethodCall!Pointer to MethodCall in case of interpreted function; Double_tTF1::fMinimumMinimum value for plotting; Int_tTF1::fNDFNumber of degrees of freedom in the fit; Int_tTFormula::fNOperOptimized!Number of operators after optimization; TStringTNamed::fNameobject identifier; TString*TFormula::fNames[fNpar] Array of parameter names; Int_tTFormula::fNconstNumber of constants; Int_tTFormula::fNdimDimension of function (1=1-Dim, 2=2-Dim,etc); Int_tTFormula::fNoperNumber of operators; Int_tTFormula::fNparNumber of parameters; Int_tTF1::fNpfitsNumber of points used in the fit; Int_tTF1::fNpxNumber of points used for the graphical representation; Int_tTF2::fNpyNumber of points along y used for the graphical representation; Int_tfNpzNumber of points along z used for the graphical representation; Int_tTF1::fNsaveNumber of points used to fill array fSave; Int_tTFormula::fNstringNumber of different constants character strings; Int_tTFormula::fNumberformula number identifier; Int_tTFormula::fNvalNumber of different variables in expression; TOperOffset*TFormula::fOperOffset![fNOperOptimized] Offsets of operrands; Int_t*TFormula::fOperOptimized![fNOperOptimized] List of operators. (See documentation for changes made at version 7); G__p2memfuncTFormula::fOptimal!pointer to optimal function; Double_t*TF1::fP",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TF3.html:23709,optimiz,optimization,23709,root/html528/TF3.html,https://root.cern,https://root.cern/root/html528/TF3.html,6,['optimiz'],['optimization']
Performance,"o make; ROOT::Math::ParamFunctorTF1::fFunctor! Functor object to wrap any C++ callable object; Double_t*TF1::fGamma!Array gamma.; TH1*TF1::fHistogram!Pointer to histogram used for visualisation; Double_t*TF1::fIntegral![fNpx] Integral of function binned on fNpx bins; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TObjArrayTFormula::fLinearPartsLinear parts if the formula is linear (contains '|' or ""++""); Color_tTAttMarker::fMarkerColorMarker color index; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; Double_tTF1::fMaximumMaximum value for plotting; TMethodCall*TF1::fMethodCall!Pointer to MethodCall in case of interpreted function; Double_tTF1::fMinimumMinimum value for plotting; Int_tTF1::fNDFNumber of degrees of freedom in the fit; Int_tTFormula::fNOperOptimized!Number of operators after optimization; TStringTNamed::fNameobject identifier; TString*TFormula::fNames[fNpar] Array of parameter names; Int_tTFormula::fNconstNumber of constants; Int_tTFormula::fNdimDimension of function (1=1-Dim, 2=2-Dim,etc); Int_tTFormula::fNoperNumber of operators; Int_tTFormula::fNparNumber of parameters; Int_tTF1::fNpfitsNumber of points used in the fit; Int_tTF1::fNpxNumber of points used for the graphical representation; Int_tTF2::fNpyNumber of points along y used for the graphical representation; Int_tfNpzNumber of points along z used for the graphical representation; Int_tTF1::fNsaveNumber of points used to fill array fSave; Int_tTFormula::fNstringNumber of different constants character strings; Int_tTFormula::fNumberformula number identifier; Int_tTFormula::fNvalNumber of different variables in expression; TOperOffset*TFormula::fOperOffset![fNOperOptimized] Offsets of operrands; Int_t*TFormula::fOperOptimized![fNOperOptimized] List of operators. (See documentation for changes made at version 7); TFormula::TFuncGTFormula::fOptimal!pointer to optimal function; Double_t*TF1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TF3.html:24252,optimiz,optimization,24252,root/html602/TF3.html,https://root.cern,https://root.cern/root/html602/TF3.html,2,['optimiz'],['optimization']
Performance,"o not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Bool_t_disableCacheFlag to run object in passthrough (= non-caching mode). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsCachedReal(); Destructor. Double_t getVal(const RooArgSet* set = 0) const; Implementation of getVal() overriding default implementation; of RooAbsReal. Return value stored in cache p.d.f; rather than return value of evaluate() which is undefined; for RooAbsCachedReal. void clearCacheObject(RooAbsCachedReal::FuncCacheElem& cache) const; Mark all bins as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct unique suffix name for cache p.d.f object. void setInterpolationOrder(Int_t order); Set interpolation order of RooHistFunct representing cache histogram. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Return analytical integration capabilities of the RooHistFunc that corresponds to the set of observables in allVars. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Forward call to implementation in relevant RooHistFunc instance. Bool_t selfNormalized() const; Declares function self normalized. Int_t getInterpolationOrder() const; Set interpolation order in RooHistFuncs that represent cache histograms. Bool_t forceAnalyticalInt(const RooAbsArg& ) const; Force all observables to be offered for internal integration. FuncCacheElem* getCac",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsCachedReal.html:34134,cache,cache,34134,root/html526/RooAbsCachedReal.html,https://root.cern,https://root.cern/root/html526/RooAbsCachedReal.html,3,['cache'],['cache']
Performance,"o not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxypdfProxy to p.d.f being cached. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooCachedPdf(const char* name, const char* title, RooAbsPdf& _pdf); Constructor taking name, title and function to be cached. To control; granularity of the binning of the cache histogram set the desired properties; in the binning named ""cache"" in the observables of the function. The dimensions; of the cache are automatically matched to the number of observables used; in each use context. Multiple cache in different observable may exists; simultanously if the cached p.d.f is used with multiple observable; configurations simultaneously. RooCachedPdf(const char* name, const char* title, RooAbsPdf& _pdf, const RooArgSet& cacheObs); Constructor taking name, title and function to be cached and; fixed choice of variable to cache. To control granularity of the; binning of the cache histogram set the desired properties in the; binning named ""cache"" in the observables of the function.; If the fixed set of cache observables does not match the observables; defined in the use context of the p.d.f the cache is still filled; completely. Ee.g. when it is specified to cache x and p and only x; is a observable in the given use context the cache histogram will; store sampled values for all values of observable x and parameter p.; In such a mode of operation the cache will also not be recalculated; if the observable p changes. RooCac",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCachedPdf.html:46873,cache,cache,46873,root/html602/RooCachedPdf.html,https://root.cern,https://root.cern/root/html602/RooCachedPdf.html,4,['cache'],['cache']
Performance,"o optimise a computation graph, to keep track of cached values, and to invalidate caches. . virtual void optimizeCacheMode (const RooArgSet &observables);  Activate cache mode optimization with given definition of observables. ;  ; virtual void optimizeCacheMode (const RooArgSet &observables, RooArgSet &optNodes, RooLinkedList &processedNodes);  Activate cache mode optimization with given definition of observables. ;  ; bool findConstantNodes (const RooArgSet &observables, RooArgSet &cacheList);  Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; bool findConstantNodes (const RooArgSet &observables, RooArgSet &cacheList, RooLinkedList &processedNodes);  Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; virtual void constOptimizeTestStatistic (ConstOpCode opcode, bool doAlsoTrackingOpt=true);  Interface function signaling a request to perform constant term optimization. ;  ; virtual CacheMode canNodeBeCached () const;  ; virtual void setCacheAndTrackHints (RooArgSet &);  ; bool isShapeDirty () const;  ; bool isValueDirty () const;  ; bool isValueDirtyAndClear () const;  ; bool isValueOrShapeDirtyAndClear () const;  ; void registerCache (RooAbsCache &cache);  Register RooAbsCache with this object. ;  ; void unRegisterCache (RooAbsCache &cache);  Unregister a RooAbsCache. Called from the RooAbsCache destructor. ;  ; Int_t numCaches () const;  Return number of registered caches. ;  ; RooAbsCache * getCache (Int_t index) const;  Return registered cache object by index. ;  ; OperMode operMode () const;  Query the operation mode of this node. ;  ; void setOperMode (OperMode mode, bool recurseADirty=true);  Set the operation mode of this node. ;  ; void setValueDirty ();  Mark the element dirty. This forces a re-evaluation when a value is requested. ;  ; void setShapeDirt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsArg.html:21903,perform,perform,21903,doc/master/classRooAbsArg.html,https://root.cern,https://root.cern/doc/master/classRooAbsArg.html,2,"['optimiz', 'perform']","['optimization', 'perform']"
Performance,"o option. ;  ; void MakeCopyNodes (const TGeoVolume *other);  make a new list of nodes and copy all nodes of other volume inside ;  ; TGeoVolume * MakeReflectedVolume (const char *newname="""") const;  Make a copy of this volume which is reflected with respect to XY plane. ;  ; Bool_t OptimizeVoxels ();  Perform an extensive sampling to find which type of voxelization is most efficient. ;  ; void Paint (Option_t *option="""") override;  paint volume ;  ; void Print (Option_t *option="""") const override;  Print volume info. ;  ; void PrintNodes () const;  print nodes ;  ; void PrintVoxels () const;  Print the voxels for this volume. ;  ; void RandomPoints (Int_t npoints=1000000, Option_t *option="""");  Draw random points in the bounding box of this volume. ;  ; void RandomRays (Int_t nrays=10000, Double_t startx=0, Double_t starty=0, Double_t startz=0, const char *target_vol=nullptr, Bool_t check_norm=kFALSE);  Random raytracing method. ;  ; void Raytrace (Bool_t flag=kTRUE);  Draw this volume with current settings and perform raytracing in the pad. ;  ; void RegisterYourself (Option_t *option="""");  Register the volume and all materials/media/matrices/shapes to the manager. ;  ; void Release ();  ; void RemoveNode (TGeoNode *node);  Remove an existing daughter. ;  ; TGeoNode * ReplaceNode (TGeoNode *nodeorig, TGeoShape *newshape=nullptr, TGeoMatrix *newpos=nullptr, TGeoMedium *newmed=nullptr);  Replace an existing daughter with a new volume having the same name but possibly a new shape, position or medium. ;  ; void ReplayCreation (const TGeoVolume *other);  Recreate the content of the other volume without pointer copying. ;  ; void ResetTransparency (Char_t transparency=-1);  ; void SaveAs (const char *filename="""", Option_t *option="""") const override;  Save geometry having this as top volume as a C++ macro. ;  ; void SavePrimitive (std::ostream &out, Option_t *option="""") override;  Save a primitive as a C++ statement(s) on output stream ""out"". ;  ; void SelectVolume (Bool_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoVolumeMulti.html:17608,perform,perform,17608,doc/master/classTGeoVolumeMulti.html,https://root.cern,https://root.cern/doc/master/classTGeoVolumeMulti.html,1,['perform'],['perform']
Performance,"o pointer in old versions of root. ; In versions of ROOT older than 4.00/03, if a collection (TClonesArray or STL container) was split but the pointer to the collection was zeroed out, nothing was saved. Hence there is no easy way to detect the case. In newer versions, a zero is written so that a 'missing' collection appears to be an empty collection. ; Definition at line 3776 of file TBranchElement.cxx. ◆ IsObjectOwner(). virtual bool TBranchElement::IsObjectOwner ; (; ); const. inlinevirtual . Definition at line 213 of file TBranchElement.h. ◆ Notify(). bool TBranchElement::Notify ; (; ). inlineoverridevirtual . This method must be overridden to handle object notification (the base implementation is no-op). ; Different objects in ROOT use the Notify method for different purposes, in coordination with other objects that call this method at the appropriate time.; For example, TLeaf uses it to load class information; TBranchRef to load contents of referenced branches TBranchRef; most notably, based on Notify, TChain implements a callback mechanism to inform interested parties when it switches to a new sub-tree. ; Reimplemented from TObject.; Definition at line 214 of file TBranchElement.h. ◆ operator=(). TBranchElement & TBranchElement::operator= ; (; const TBranchElement & ; ). privatedelete . ◆ Print(). void TBranchElement::Print ; (; Option_t * ; option = """"); const. overridevirtual . Print TBranch parameters. ; If options contains ""basketsInfo"" print the entry number, location and size of each baskets. ; Reimplemented from TBranch.; Definition at line 3836 of file TBranchElement.cxx. ◆ PrintValue(). void TBranchElement::PrintValue ; (; Int_t ; i); const. Prints values of leaves. ; Definition at line 3928 of file TBranchElement.cxx. ◆ ReadLeavesClones(). void TBranchElement::ReadLeavesClones ; (; TBuffer & ; b). protected . Read leaves into i/o buffers for this branch. ; Case of a TClonesArray (fType == 3). ; Definition at line 4462 of file TBranchElement.cxx. ◆ Re",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBranchElement.html:60034,load,load,60034,doc/master/classTBranchElement.html,https://root.cern,https://root.cern/doc/master/classTBranchElement.html,2,['load'],['load']
Performance,"o signal the threads to start.; Byte_t*fUnzipStatus! [fNSeek] For each blk, tells us if it's unzipped or pending; TThread*fUnzipThread[10]; static Int_tTTreeCache::fgLearnEntriesnumber of entries used for learning mode; static TTreeCacheUnzip::EParUnzipModefgParallelIndicate if we want to activate the parallelism; static Double_tfgRelBuffSizeThis is the percentage of the TTreeCacheUnzip that will be used. private:. char*fCompBuffer; Int_tfCompBufferSize. Class Charts. Inheritance Chart:. TObject. ←; TFileCacheRead. ←; TTreeCache. ←; TTreeCacheUnzip. Function documentation; TTreeCacheUnzip(); Default Constructor. TTreeCacheUnzip(TTree* tree, Int_t buffersize = 0); Constructor. void Init(); Initialization procedure common to all the constructors. ~TTreeCacheUnzip(); destructor. (in general called by the TFile destructor; destructor. (in general called by the TFile destructor). Int_t AddBranch(TBranch* b, Bool_t subbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket; Returns 0 branch added or already included; -1 on error. Int_t AddBranch(const char* branch, Bool_t subbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket; Returns 0 branch added or already included; -1 on error. Bool_t FillBuffer(). Int_t SetBufferSize(Int_t buffersize); Change the underlying buffer size of the cache.; Returns 0 if the buffer content is still available; 1 if some or all of the buffer content has been made unavailable; -1 on error. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void StopLearningPhase(); It's the same as TTreeCache::StopLearningPhase but we guarantee that; we start the unzipping just after getting the buffers. void UpdateBranches(TTree* tree); update pointer t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TTreeCacheUnzip.html:17274,cache,cache,17274,root/html604/TTreeCacheUnzip.html,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html,2,['cache'],['cache']
Performance,"o start; GetEntryRanges() : retrieve from RDataSource a set of ranges of entries that can be processed concurrently; InitSlot() : inform RDataSource that a certain thread is about to start working on a certain range of entries; SetEntry() : inform RDataSource that a certain thread is about to start working on a certain entry; FinalizeSlot() : inform RDataSource that a certain thread finished working on a certain range of entries; Finalize() : inform RDataSource that an event-loop finished. RDataSource implementations must support running multiple event-loops consecutively (although sequentially) on the same dataset.; SetNSlots() is called once per RDataSource object, typically when it is associated to a RDataFrame.; GetColumnReaders() can be called several times, potentially with the same arguments, also in-between event-loops, but not during an event-loop.; GetEntryRanges() will be called several times, including during an event loop, as additional ranges are needed. It will not be called concurrently.; Initialize() and Finalize() are called once per event-loop, right before starting and right after finishing.; InitSlot(), SetEntry(), and FinalizeSlot() can be called concurrently from multiple threads, multiple times per event-loop. Advanced users that plan to implement a custom RDataSource can check out existing implementations, e.g. RCsvDS or RNTupleDS. See the inheritance diagram below for the full list of existing concrete implementations. ; Definition at line 109 of file RDataSource.hxx. Public Member Functions; virtual ~RDataSource ()=default;  ; virtual void Finalize ();  Convenience method called after concluding an event-loop. ;  ; virtual void FinalizeSlot (unsigned int);  Convenience method called at the end of the data processing associated to a slot. ;  ; virtual const std::vector< std::string > & GetColumnNames () const =0;  Returns a reference to the collection of the dataset's column names. ;  ; template<typename T > ; std::vector< T ** > GetColumnR",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDF_1_1RDataSource.html:2137,concurren,concurrently,2137,doc/master/classROOT_1_1RDF_1_1RDataSource.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDF_1_1RDataSource.html,1,['concurren'],['concurrently']
Performance,"o the TH1::Draw() method. Roo1DTable* table(const RooAbsCategory& cat, const char* cuts, const char* /*opts*/); Create and fill a 1-dimensional table for given category column; This functions is the equivalent of plotOn() for category dimensions. The optional cut string expression can be used to select the events to be tabulated; The cut specification may refer to any variable contained in the data set. The option string is currently not used. Bool_t getRange(RooRealVar& var, Double_t& lowest, Double_t& highest, Double_t marginFrac = 0, Bool_t symMode = kFALSE) const; Fill Doubles 'lowest' and 'highest' with the lowest and highest value of; observable 'var' in this dataset. If the return value is kTRUE and error; occurred. void optimizeReadingWithCaching(RooAbsArg& arg, const RooArgSet& cacheList, const RooArgSet& keepObsList); Prepare dataset for use with cached constant terms listed in; 'cacheList' of expression 'arg'. Deactivate tree branches; for any dataset observable that is either not used at all,; or is used exclusively by cached branch nodes. Bool_t allClientsCached(RooAbsArg* , const RooArgSet& ); Utility function that determines if all clients of object 'var'; appear in given list of cached nodes. void checkInit() const. void Draw(Option_t* option = """"); Forward draw command to data store. Bool_t hasFilledCache() const. const TTree* tree() const. RooAbsData* emptyClone(const char* newName = 0, const char* newTitle = 0, const RooArgSet* vars = 0) const. RooAbsDataStore* store(); { return _dstore ; }. const RooAbsDataStore* store(); { return _dstore ; }. void add(const RooArgSet& row, Double_t weight = 1, Double_t weightError = 0); Add one ore more rows of data. const RooArgSet* get() const; Load a given row of data. Double_t weight() const. Bool_t valid() const; { return kTRUE ; }. Double_t sumEntries(const char* cutSpec = 0, const char* cutRange = 0) const. Bool_t isWeighted() const; Do events in dataset have weights?. Bool_t isNonPoissonWeighted() const; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsData.html:34596,cache,cached,34596,root/html526/RooAbsData.html,https://root.cern,https://root.cern/root/html526/RooAbsData.html,1,['cache'],['cached']
Performance,"o to the documentation of this file. 1// @(#)root/io:$Id$; 2// Author: Philippe Canal 05/2010; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#include ""TStreamerInfo.h""; 13#include ""TStreamerInfoActions.h""; 14#include ""TROOT.h""; 15#include ""TStreamerElement.h""; 16#include ""TVirtualMutex.h""; 17#include ""TInterpreter.h""; 18#include ""TError.h""; 19#include ""TVirtualArray.h""; 20#include ""TBufferFile.h""; 21#include ""TBufferText.h""; 22#include ""TMemberStreamer.h""; 23#include ""TClassEdit.h""; 24#include ""TVirtualCollectionIterators.h""; 25#include ""TProcessID.h""; 26#include ""TFile.h""; 27 ; 28static const Int_t kRegrouped = TStreamerInfo::kOffsetL;; 29 ; 30// More possible optimizations:; 31// Avoid call the virtual version of TBuffer::ReadInt and co.; 32// Merge the Reading of the version and the looking up or the StreamerInfo; 33// Avoid if (bytecnt) inside the CheckByteCount routines and avoid multiple (mostly useless nested calls); 34// Try to avoid if statement on onfile class being set (TBufferFile::ReadClassBuffer).; 35 ; 36using namespace TStreamerInfoActions;; 37 ; 38#ifdef _AIX; 39# define INLINE_TEMPLATE_ARGS; 40#else; 41# define INLINE_TEMPLATE_ARGS inline; 42#endif; 43 ; 44 ; 45namespace TStreamerInfoActions; 46{; 47 bool IsDefaultVector(TVirtualCollectionProxy &proxy); 48 {; 49 const auto props = proxy.GetProperties();; 50 const bool isVector = proxy.GetCollectionType() == ROOT::kSTLvector;; 51 const bool hasDefaultAlloc = !(props & TVirtualCollectionProxy::kCustomAlloc);; 52 const bool isEmulated = props & TVirtualCollectionProxy::kIsEmulated;; 53 ; 54 return isEmulated || (isVector && hasDefaultAlloc);; 55 }; 56 ; 57 template <type",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html:1171,optimiz,optimizations,1171,doc/master/TStreamerInfoActions_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html,1,['optimiz'],['optimizations']
Performance,"o use the 'branchname' as if it was a data member; protection against array out-of-bound; ability to use the branch data as object (when the user code is available). For example with Event.root, if Double_t somepx = fTracks.fPx[2];; double; is executed by one of the method of the skeleton, somepx will be updated with the current value of fPx of the 3rd track.; Both macrofilename and the optional cutfilename are expected to be the name of source files which contain at least a free standing function with the signature: x_t macrofilename(); // i.e function with the same name as the file; and y_t cutfilename(); // i.e function with the same name as the file; x_t and y_t needs to be types that can convert respectively to a double and a bool (because the skeleton uses: if (cutfilename()) htemp->Fill(macrofilename());; This 2 functions are run in a context such that the branch names are available as local variables of the correct (read-only) type.; Note that if you use the same 'variable' twice, it is more efficient to 'cache' the value. For example Int_t n = fEventNumber; // Read fEventNumber; if (n<10 || n>10) { ... }; int; nconst Int_t nDefinition legend1.C:16; is more efficient than if (fEventNumber<10 || fEventNumber>10); Access to TClonesArray.; If a branch (or member) is a TClonesArray (let's say fTracks), you can access the TClonesArray itself by using ->: fTracks->GetLast();; However this will load the full TClonesArray object and its content. To quickly read the size of the TClonesArray use (note the dot): fTracks.GetEntries();; This will read only the size from disk if the TClonesArray has been split. To access the content of the TClonesArray, use the [] operator: float px = fTracks[i].fPx; // fPx of the i-th track; Warning:; The variable actually use for access are 'wrapper' around the real data type (to add autoload for example) and hence getting to the data involves the implicit call to a C++ conversion operator. This conversion is automatic in most case. How",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreePlayer.html:33572,cache,cache,33572,doc/master/classTTreePlayer.html,https://root.cern,https://root.cern/doc/master/classTTreePlayer.html,1,['cache'],['cache']
Performance,"o {; 10498 const char *name;; 10499 int request_has_body;; 10500 int response_has_body;; 10501 int is_safe;; 10502 int is_idempotent;; 10503 int is_cacheable;; 10504};; 10505 ; 10506 ; 10507/* https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods */; 10508static const struct mg_http_method_info http_methods[] = {; 10509 /* HTTP (RFC 2616) */; 10510 {""GET"", 0, 1, 1, 1, 1},; 10511 {""POST"", 1, 1, 0, 0, 0},; 10512 {""PUT"", 1, 0, 0, 1, 0},; 10513 {""DELETE"", 0, 0, 0, 1, 0},; 10514 {""HEAD"", 0, 0, 1, 1, 1},; 10515 {""OPTIONS"", 0, 0, 1, 1, 0},; 10516 {""CONNECT"", 1, 1, 0, 0, 0},; 10517 /* TRACE method (RFC 2616) is not supported for security reasons */; 10518 ; 10519 /* PATCH method (RFC 5789) */; 10520 {""PATCH"", 1, 0, 0, 0, 0},; 10521 /* PATCH method only allowed for CGI/Lua/LSP and callbacks. */; 10522 ; 10523 /* WEBDAV (RFC 2518) */; 10524 {""PROPFIND"", 0, 1, 1, 1, 0},; 10525 /* http://www.webdav.org/specs/rfc4918.html, 9.1:; 10526 * Some PROPFIND results MAY be cached, with care,; 10527 * as there is no cache validation mechanism for; 10528 * most properties. This method is both safe and; 10529 * idempotent (see Section 9.1 of [RFC2616]). */; 10530 {""MKCOL"", 0, 0, 0, 1, 0},; 10531 /* http://www.webdav.org/specs/rfc4918.html, 9.1:; 10532 * When MKCOL is invoked without a request body,; 10533 * the newly created collection SHOULD have no; 10534 * members. A MKCOL request message may contain; 10535 * a message body. The precise behavior of a MKCOL; 10536 * request when the body is present is undefined,; 10537 * ... ==> We do not support MKCOL with body data.; 10538 * This method is idempotent, but not safe (see; 10539 * Section 9.1 of [RFC2616]). Responses to this; 10540 * method MUST NOT be cached. */; 10541 ; 10542 /* Methods for write access to files on WEBDAV (RFC 2518) */; 10543 {""LOCK"", 1, 1, 0, 0, 0},; 10544 {""UNLOCK"", 1, 0, 0, 0, 0},; 10545 {""PROPPATCH"", 1, 1, 0, 0, 0},; 10546 ; 10547 /* Unsupported WEBDAV Methods: */; 10548 /* COPY, MOVE (RFC 2518) */; 10549 /* + 1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:302238,cache,cached,302238,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,2,['cache'],"['cache', 'cached']"
Performance,"o {; 10499 const char *name;; 10500 int request_has_body;; 10501 int response_has_body;; 10502 int is_safe;; 10503 int is_idempotent;; 10504 int is_cacheable;; 10505};; 10506 ; 10507 ; 10508/* https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods */; 10509static const struct mg_http_method_info http_methods[] = {; 10510 /* HTTP (RFC 2616) */; 10511 {""GET"", 0, 1, 1, 1, 1},; 10512 {""POST"", 1, 1, 0, 0, 0},; 10513 {""PUT"", 1, 0, 0, 1, 0},; 10514 {""DELETE"", 0, 0, 0, 1, 0},; 10515 {""HEAD"", 0, 0, 1, 1, 1},; 10516 {""OPTIONS"", 0, 0, 1, 1, 0},; 10517 {""CONNECT"", 1, 1, 0, 0, 0},; 10518 /* TRACE method (RFC 2616) is not supported for security reasons */; 10519 ; 10520 /* PATCH method (RFC 5789) */; 10521 {""PATCH"", 1, 0, 0, 0, 0},; 10522 /* PATCH method only allowed for CGI/Lua/LSP and callbacks. */; 10523 ; 10524 /* WEBDAV (RFC 2518) */; 10525 {""PROPFIND"", 0, 1, 1, 1, 0},; 10526 /* http://www.webdav.org/specs/rfc4918.html, 9.1:; 10527 * Some PROPFIND results MAY be cached, with care,; 10528 * as there is no cache validation mechanism for; 10529 * most properties. This method is both safe and; 10530 * idempotent (see Section 9.1 of [RFC2616]). */; 10531 {""MKCOL"", 0, 0, 0, 1, 0},; 10532 /* http://www.webdav.org/specs/rfc4918.html, 9.1:; 10533 * When MKCOL is invoked without a request body,; 10534 * the newly created collection SHOULD have no; 10535 * members. A MKCOL request message may contain; 10536 * a message body. The precise behavior of a MKCOL; 10537 * request when the body is present is undefined,; 10538 * ... ==> We do not support MKCOL with body data.; 10539 * This method is idempotent, but not safe (see; 10540 * Section 9.1 of [RFC2616]). Responses to this; 10541 * method MUST NOT be cached. */; 10542 ; 10543 /* Methods for write access to files on WEBDAV (RFC 2518) */; 10544 {""LOCK"", 1, 1, 0, 0, 0},; 10545 {""UNLOCK"", 1, 0, 0, 0, 0},; 10546 {""PROPPATCH"", 1, 1, 0, 0, 0},; 10547 ; 10548 /* Unsupported WEBDAV Methods: */; 10549 /* COPY, MOVE (RFC 2518) */; 10550 /* + 1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:302271,cache,cached,302271,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,2,['cache'],"['cache', 'cached']"
Performance,"o(). void TFile::ResetErrno ; (; ); const. virtual . Method resetting the errno. ; Reimplemented in TSQLFile, TXMLFile, TDCacheFile, and TMemFile.; Definition at line 1254 of file TFile.cxx. ◆ Seek(). void TFile::Seek ; (; Long64_t ; offset, . ERelativeTo ; pos = kBeg . ). virtual . Seek to a specific position in the file. Pos it either kBeg, kCur or kEnd. ; Reimplemented in TDavixFile, TNetFile, TWebFile, TNetXNGFile, TSQLFile, and TXMLFile.; Definition at line 2274 of file TFile.cxx. ◆ SetCacheFileDir(). Bool_t TFile::SetCacheFileDir ; (; std::string_view ; cachedir, . Bool_t ; operatedisconnected = kTRUE, . Bool_t ; forcecacheread = kFALSE . ). static . Sets the directory where to locally stage/cache remote files. ; If the directory is not writable by us return kFALSE. ; Definition at line 4626 of file TFile.cxx. ◆ SetCacheRead(). void TFile::SetCacheRead ; (; TFileCacheRead * ; cache, . TObject * ; tree = nullptr, . ECacheAction ; action = kDisconnect . ). virtual . Set a pointer to the read cache. ; This relinquishes ownership of the previous cache, so if you do not already have a pointer to the previous cache (and there was a previous cache), you ought to retrieve (and delete it if needed) using: TFileCacheRead *older = myfile->GetCacheRead();; The action specifies how to behave when detaching a cache from the the TFile. If set to (default) kDisconnect, the contents of the cache will be flushed when it is removed from the file, and it will disconnect the cache object from the file. In almost all cases, this is what you want. If you want to disconnect the cache temporarily from this tree and re-attach later to the same fil, you can set action to kDoNotDisconnect. This will allow things like prefetching to continue in the background while it is no longer the default cache for the TTree. Except for a few expert use cases, kDisconnect is likely the correct setting.; WARNING: if action=kDoNotDisconnect, you MUST delete the cache before TFile. ; Definition at line 23",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTFile.html:91947,cache,cache,91947,doc/v632/classTFile.html,https://root.cern,https://root.cern/doc/v632/classTFile.html,2,['cache'],['cache']
Performance,"o) = 0;; 140 virtual void IncrementLevel(TVirtualStreamerInfo* info) = 0;; 141 virtual void SetStreamerElementNumber(TStreamerElement *elem, Int_t comp_type) = 0;; 142 virtual void DecrementLevel(TVirtualStreamerInfo*) = 0;; 143 ; 144 virtual void ClassBegin(const TClass*, Version_t = -1) = 0;; 145 virtual void ClassEnd(const TClass*) = 0;; 146 virtual void ClassMember(const char*, const char * = nullptr, Int_t = -1, Int_t = -1) = 0;; 147 virtual TVirtualStreamerInfo *GetInfo() = 0;; 148 ; 149 virtual TVirtualArray *PeekDataCache() const;; 150 virtual TVirtualArray *PopDataCache();; 151 virtual void PushDataCache(TVirtualArray *);; 152 ; 153 virtual TClass *ReadClass(const TClass *cl = nullptr, UInt_t *objTag = nullptr) = 0;; 154 virtual void WriteClass(const TClass *cl) = 0;; 155 ; 156 virtual TObject *ReadObject(const TClass *cl) = 0;; 157 virtual void WriteObject(const TObject *obj, Bool_t cacheReuse) = 0;; 158 ; 159 template <class T> Int_t WriteObject(const T *objptr, Bool_t cacheReuse = kTRUE);; 160 ; 161 virtual Int_t WriteObjectAny(const void *obj, const TClass *ptrClass, Bool_t cacheReuse = kTRUE) = 0;; 162 ; 163 virtual UShort_t GetPidOffset() const = 0;; 164 virtual void SetPidOffset(UShort_t offset) = 0;; 165 virtual Int_t GetBufferDisplacement() const = 0;; 166 virtual void SetBufferDisplacement() = 0;; 167 virtual void SetBufferDisplacement(Int_t skipped) = 0;; 168 ; 169 // basic types and arrays of basic types; 170 virtual void ReadFloat16 (Float_t *f, TStreamerElement *ele = nullptr) = 0;; 171 virtual void WriteFloat16(Float_t *f, TStreamerElement *ele = nullptr) = 0;; 172 virtual void ReadDouble32 (Double_t *d, TStreamerElement *ele = nullptr) = 0;; 173 virtual void WriteDouble32(Double_t *d, TStreamerElement *ele = nullptr) = 0;; 174 virtual void ReadWithFactor(Float_t *ptr, Double_t factor, Double_t minvalue) = 0;; 175 virtual void ReadWithNbits(Float_t *ptr, Int_t nbits) = 0;; 176 virtual void ReadWithFactor(Double_t *ptr, Double_t factor, Double_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBuffer_8h_source.html:7191,cache,cacheReuse,7191,doc/master/TBuffer_8h_source.html,https://root.cern,https://root.cern/doc/master/TBuffer_8h_source.html,1,['cache'],['cacheReuse']
Performance,"o, we need a limit on how large the I/O buffer can grow during writing. ; Definition at line 67 of file RNTupleWriteOptions.hxx. ◆ fMaxUnzippedPageSize. std::size_t ROOT::Experimental::RNTupleWriteOptions::fMaxUnzippedPageSize = 1024 * 1024. protected . Pages can grow only to the given limit in bytes. ; Definition at line 75 of file RNTupleWriteOptions.hxx. ◆ fPageBufferBudget. std::size_t ROOT::Experimental::RNTupleWriteOptions::fPageBufferBudget = 0. protected . The maximum size that the sum of all page buffers used for writing into a persistent sink are allowed to use. ; If set to zero, RNTuple will auto-adjust the budget based on the value of fApproxZippedClusterSize. If set manually, the size needs to be large enough to hold all initial page buffers. The total amount of memory for writing is larger, e.g. for the additional compressed buffers etc. Use RNTupleModel::EstimateWriteMemoryUsage() for the total estimated memory use for writing. The default values are tuned for a total write memory of around 300 MB per fill context. ; Definition at line 82 of file RNTupleWriteOptions.hxx. ◆ fUseBufferedWrite. bool ROOT::Experimental::RNTupleWriteOptions::fUseBufferedWrite = true. protected . Whether to use buffered writing (with RPageSinkBuf). ; This buffers compressed pages in memory, reorders them to keep pages of the same column adjacent, and coalesces the writes when committing a cluster. ; Definition at line 85 of file RNTupleWriteOptions.hxx. ◆ fUseDirectIO. bool ROOT::Experimental::RNTupleWriteOptions::fUseDirectIO = false. protected . Whether to use Direct I/O for writing. ; Note that this introduces alignment requirements that may very between filesystems and platforms. ; Definition at line 88 of file RNTupleWriteOptions.hxx. ◆ fUseImplicitMT. EImplicitMT ROOT::Experimental::RNTupleWriteOptions::fUseImplicitMT = EImplicitMT::kDefault. protected . Whether to use implicit multi-threading to compress pages. Only has an effect if buffered writing is turned on. ; De",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RNTupleWriteOptions.html:11713,tune,tuned,11713,doc/master/classROOT_1_1Experimental_1_1RNTupleWriteOptions.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RNTupleWriteOptions.html,1,['tune'],['tuned']
Performance,"o, we recommend using gROOT->ProcessLine(). For example, in one script you can use ACLiC to compile and load another script.; gROOT->ProcessLine("".L MyScript.C+""); gROOT->ProcessLine("".L MyScript.C++""); 7.4.2 Setting the Include Path; You can get the include path by typing:; root[] .include; You can append to the include path by typing:; root[] .include $HOME/mypackage/include; In a script you can append to the include path:; gSystem->AddIncludePath("" -I$HOME/mypackage/include ""); You can also overwrite the existing include path:; gSystem->SetIncludePath("" -I$HOME/mypackage/include ""); The $ROOTSYS/include directory is automatically appended to the include path, so you do not have to worry about including it. To add library that should be used during linking of the shared library use something like:; gSystem->AddLinkedLibs(""-L/my/path -lanylib"");; This is especially useful for static libraries. For shared ones you can also simply load them before trying to compile the script:; gSystem->Load(""mydir/mylib"");; ACLiC uses the directive fMakeSharedLibs to create the shared library. If loading the shared library fails, it tries to output a list of missing symbols by creating an executable (on some platforms like OSF, this does not HAVE to be an executable) containing the script. It uses the directive fMakeExe to do so. For both directives, before passing them to TSystem::Exec(), it expands the variables $SourceFiles, $SharedLib, $LibName, $IncludePath, $LinkedLibs, $ExeNameand$ObjectFiles. See SetMakeSharedLib() for more information on those variables. When the file being passed to ACLiC is on a read only file system, ACLiC warns the user and creates the library in a temporary directory:; root[] .L readonly/t.C++; Warning in <ACLiC>: /scratch/aclic/subs/./readonly is not writable!; Warning in <ACLiC>: Output will be written to /tmp; Info in <TUnixSystem::ACLiC>: creating shared library; /tmp//scratch/aclic/subs/./readonly/t_C.so; To select the temporary directory ACLiC lo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:272307,load,load,272307,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,3,"['Load', 'load']","['Load', 'load']"
Performance,"o.; 1914 if (auto DE = FM.getOptionalDirectoryRef(FullPath)) {; 1915 HeaderSearch &HS = PP.getHeaderSearchInfo();; 1916 HeaderSearchOptions &HSOpts = HS.getHeaderSearchOpts();; 1917 const auto &ModPaths = HSOpts.PrebuiltModulePaths;; 1918 bool pathExists = std::find(ModPaths.begin(), ModPaths.end(), FullPath) != ModPaths.end();; 1919 if (!pathExists); 1920 HSOpts.AddPrebuiltModulePath(FullPath);; 1921 // We cannot use HS.lookupModuleMapFile(DE, /*IsFramework*/ false);; 1922 // because its internal call to getFile has CacheFailure set to true.; 1923 // In our case, modulemaps can appear any time due to ACLiC.; 1924 // Code copied from HS.lookupModuleMapFile.; 1925 llvm::SmallString<256> ModuleMapFileName(DE->getName());; 1926 llvm::sys::path::append(ModuleMapFileName, ModuleMapName);; 1927 if (auto FE = FM.getOptionalFileRef(ModuleMapFileName, /*openFile*/ false,; 1928 /*CacheFailure*/ false)) {; 1929 if (!HS.loadModuleMapFile(*FE, /*IsSystem*/ false)); 1930 return true;; 1931 Error(""RegisterPrebuiltModulePath"", ""Could not load modulemap in %s"", ModuleMapFileName.c_str());; 1932 }; 1933 }; 1934 return false;; 1935}; 1936 ; 1937////////////////////////////////////////////////////////////////////////////////; 1938/// List of dicts that have the PCM information already in the PCH.; 1939static const std::unordered_set<std::string> gIgnoredPCMNames = {""libCore"",; 1940 ""libRint"",; 1941 ""libThread"",; 1942 ""libRIO"",; 1943 ""libImt"",; 1944 ""libMultiProc"",; 1945 ""libcomplexDict"",; 1946 ""libdequeDict"",; 1947 ""liblistDict"",; 1948 ""libforward_listDict"",; 1949 ""libvectorDict"",; 1950 ""libmapDict"",; 1951 ""libmultimap2Dict"",; 1952 ""libmap2Dict"",; 1953 ""libmultimapDict"",; 1954 ""libsetDict"",; 1955 ""libmultisetDict"",; 1956 ""libunordered_setDict"",; 1957 ""libunordered_multisetDict"",; 1958 ""libunordered_mapDict"",; 1959 ""libunordered_multimapDict"",; 1960 ""libvalarrayDict"",; 1961 ""G__GenVector32"",; 1962 ""G__Smatrix32""};; 1963 ; 1964static void PrintDlError(const char *dyLibName, const char *mo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:73139,load,loadModuleMapFile,73139,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,2,['load'],"['load', 'loadModuleMapFile']"
Performance,"oAbsArg * ; newOwner, . const RooArgSet & ; cachedVars . ). overridevirtual . Initialize cache of dataset: attach variables of cache ArgSet to the corresponding TTree branches. ; Implements RooAbsDataStore.; Definition at line 982 of file RooVectorDataStore.cxx. ◆ cache(). const RooVectorDataStore * RooVectorDataStore::cache ; (; ); const. inline . Definition at line 171 of file RooVectorDataStore.h. ◆ cacheArgs(). void RooVectorDataStore::cacheArgs ; (; const RooAbsArg * ; owner, . RooArgSet & ; newVarSet, . const RooArgSet * ; nset = nullptr, . bool ; skipZeroWeights = true . ). overridevirtual . Cache given RooAbsArgs: The tree is given direct write access of the args internal cache the args values is pre-calculated for all data points in this data collection. ; Upon a get() call, the internal cache of 'newVar' will be loaded with the precalculated value and it's dirty flag will be cleared. ; Implements RooAbsDataStore.; Definition at line 764 of file RooVectorDataStore.cxx. ◆ cacheOwner(). const RooAbsArg * RooVectorDataStore::cacheOwner ; (; ). inlineoverridevirtual . Implements RooAbsDataStore.; Definition at line 163 of file RooVectorDataStore.h. ◆ catStoreList(). std::vector< CatVector * > & RooVectorDataStore::catStoreList ; (; ). inline . Definition at line 542 of file RooVectorDataStore.h. ◆ changeObservableName(). bool RooVectorDataStore::changeObservableName ; (; const char * ; from, . const char * ; to . ). overridevirtual . Implements RooAbsDataStore.; Definition at line 595 of file RooVectorDataStore.cxx. ◆ Class(). static TClass * RooVectorDataStore::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooVectorDataStore::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooVectorDataStore::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 591 of file RooVectorDataStore.h. ◆ clone() [1/2]. RooAbsDataStore * Ro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooVectorDataStore.html:27649,cache,cacheOwner,27649,doc/master/classRooVectorDataStore.html,https://root.cern,https://root.cern/doc/master/classRooVectorDataStore.html,1,['cache'],['cacheOwner']
Performance,"oAbsArg > compileForNormSet (RooArgSet const &normSet, RooFit::Detail::CompileContext &ctx) const override;  ; RooAbsRealLValue * convVar ();  Retrieve the convolution variable. ;  ; const RooAbsRealLValue * convVar () const;  Retrieve the convolution variable. ;  ; Int_t declareBasis (const char *expression, const RooArgList &params);  Declare a basis function for use in this physics model. ;  ; bool forceAnalyticalInt (const RooAbsArg &dep) const override;  This function forces RooRealIntegral to offer all integration dependents to RooAbsAnaConvPdf::getAnalyticalIntegralWN() for consideration for internal integration, if RooRealIntegral considers this to be unsafe (e.g. ;  ; RooAbsGenContext * genContext (const RooArgSet &vars, const RooDataSet *prototype=nullptr, const RooArgSet *auxProto=nullptr, bool verbose=false) const override;  Create a generator context for this p.d.f. ;  ; Int_t getAnalyticalIntegralWN (RooArgSet &allVars, RooArgSet &analVars, const RooArgSet *normSet, const char *rangeName=nullptr) const override;  Advertise capability to perform (analytical) integrals internally. ;  ; double getCoefNorm (Int_t coefIdx, const RooArgSet &nset, const char *rangeName) const;  ; double getCoefNorm (Int_t coefIdx, const RooArgSet *nset=nullptr, const char *rangeName=nullptr) const;  ; bool isDirectGenSafe (const RooAbsArg &arg) const override;  Return true if it is safe to generate the convolution observable from the internal generator (this is the case if the chosen resolution model is the truth model) ;  ; void printMultiline (std::ostream &stream, Int_t contents, bool verbose=false, TString indent="""") const override;  Print info about this object to the specified stream. ;  ; void setCacheAndTrackHints (RooArgSet &) override;  Label OK'ed components with cache-and-track. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from RooAbsPdf;  RooAbsPdf ();  Default constructor. ;  ;  RooAbsPdf (const char *n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooBMixDecay.html:6141,perform,perform,6141,doc/master/classRooBMixDecay.html,https://root.cern,https://root.cern/doc/master/classRooBMixDecay.html,5,['perform'],['perform']
Performance,"oAbsArg > compileForNormSet (RooArgSet const &normSet, RooFit::Detail::CompileContext &ctx) const override;  ; RooAbsRealLValue * convVar ();  Retrieve the convolution variable. ;  ; const RooAbsRealLValue * convVar () const;  Retrieve the convolution variable. ;  ; Int_t declareBasis (const char *expression, const RooArgList &params);  Declare a basis function for use in this physics model. ;  ; bool forceAnalyticalInt (const RooAbsArg &dep) const override;  This function forces RooRealIntegral to offer all integration dependents to RooAbsAnaConvPdf::getAnalyticalIntegralWN() for consideration for internal integration, if RooRealIntegral considers this to be unsafe (e.g. ;  ; RooAbsGenContext * genContext (const RooArgSet &vars, const RooDataSet *prototype=nullptr, const RooArgSet *auxProto=nullptr, bool verbose=false) const override;  Create a generator context for this p.d.f. ;  ; Int_t getAnalyticalIntegralWN (RooArgSet &allVars, RooArgSet &analVars, const RooArgSet *normSet, const char *rangeName=nullptr) const override;  Advertise capability to perform (analytical) integrals internally. ;  ; virtual Int_t getCoefAnalyticalIntegral (Int_t coef, RooArgSet &allVars, RooArgSet &analVars, const char *rangeName=nullptr) const;  Default implementation of function advertising integration capabilities. ;  ; double getCoefNorm (Int_t coefIdx, const RooArgSet &nset, const char *rangeName) const;  ; double getCoefNorm (Int_t coefIdx, const RooArgSet *nset=nullptr, const char *rangeName=nullptr) const;  ; TClass * IsA () const override;  ; bool isDirectGenSafe (const RooAbsArg &arg) const override;  Return true if it is safe to generate the convolution observable from the internal generator (this is the case if the chosen resolution model is the truth model) ;  ; void printMultiline (std::ostream &stream, Int_t contents, bool verbose=false, TString indent="""") const override;  Print info about this object to the specified stream. ;  ; void setCacheAndTrackHints (RooArgSet &",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsAnaConvPdf.html:5099,perform,perform,5099,doc/master/classRooAbsAnaConvPdf.html,https://root.cern,https://root.cern/doc/master/classRooAbsAnaConvPdf.html,1,['perform'],['perform']
Performance,"oAbsArg > compileForNormSet (RooArgSet const &normSet, RooFit::Detail::CompileContext &ctx) const override;  ; RooAbsRealLValue * convVar ();  Retrieve the convolution variable. ;  ; const RooAbsRealLValue * convVar () const;  Retrieve the convolution variable. ;  ; Int_t declareBasis (const char *expression, const RooArgList &params);  Declare a basis function for use in this physics model. ;  ; bool forceAnalyticalInt (const RooAbsArg &dep) const override;  This function forces RooRealIntegral to offer all integration dependents to RooAbsAnaConvPdf::getAnalyticalIntegralWN() for consideration for internal integration, if RooRealIntegral considers this to be unsafe (e.g. ;  ; RooAbsGenContext * genContext (const RooArgSet &vars, const RooDataSet *prototype=nullptr, const RooArgSet *auxProto=nullptr, bool verbose=false) const override;  Create a generator context for this p.d.f. ;  ; Int_t getAnalyticalIntegralWN (RooArgSet &allVars, RooArgSet &analVars, const RooArgSet *normSet, const char *rangeName=nullptr) const override;  Advertise capability to perform (analytical) integrals internally. ;  ; virtual Int_t getCoefAnalyticalIntegral (Int_t coef, RooArgSet &allVars, RooArgSet &analVars, const char *rangeName=nullptr) const;  Default implementation of function advertising integration capabilities. ;  ; double getCoefNorm (Int_t coefIdx, const RooArgSet &nset, const char *rangeName) const;  ; double getCoefNorm (Int_t coefIdx, const RooArgSet *nset=nullptr, const char *rangeName=nullptr) const;  ; bool isDirectGenSafe (const RooAbsArg &arg) const override;  Return true if it is safe to generate the convolution observable from the internal generator (this is the case if the chosen resolution model is the truth model) ;  ; void printMultiline (std::ostream &stream, Int_t contents, bool verbose=false, TString indent="""") const override;  Print info about this object to the specified stream. ;  ; void setCacheAndTrackHints (RooArgSet &) override;  Label OK'ed components",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooDecay.html:6251,perform,perform,6251,doc/master/classRooDecay.html,https://root.cern,https://root.cern/doc/master/classRooDecay.html,1,['perform'],['perform']
Performance,"oAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidRooAbsPdf::resetErrorCounters(Int_t resetValue = 10); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); virtual Bool_tRooAbsPdf::selfNormalized() const; TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsPdf::setGeneratorConfig(); voidRooAbsPdf::setGeneratorConfig(const RooNumGenConfig& config); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); voidRooAbsPdf::setNormValueCaching(Int_t minNumIntDim, Int_t ipOrder = 2); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsPdf::setTraceCounter(Int_t value, Bool_t allNodes = kFALSE); voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniq",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsAnaConvPdf.html:28712,cache,cache,28712,root/html526/RooAbsAnaConvPdf.html,https://root.cern,https://root.cern/root/html526/RooAbsAnaConvPdf.html,54,['cache'],['cache']
Performance,"oAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidRooAbsPdf::resetErrorCounters(Int_t resetValue = 10); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); virtual Bool_tRooAbsPdf::selfNormalized() const; TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsPdf::setGeneratorConfig(); voidRooAbsPdf::setGeneratorConfig(const RooNumGenConfig& config); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); voidRooAbsPdf::setNormValueCaching(Int_t minNumIntDim, Int_t ipOrder = 2); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidsetOptions(TString options); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsPdf::setTraceCounter(Int_t value, Bool_t allNodes = kFALSE); voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTR",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/Roo2DKeysPdf.html:26977,cache,cache,26977,root/html526/Roo2DKeysPdf.html,https://root.cern,https://root.cern/root/html526/Roo2DKeysPdf.html,1,['cache'],['cache']
Performance,"oAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); voidsetCdfBoundaries(Bool_t flag); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidsetInterpolationOrder(Int_t order); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; virtual voidShowMembers(TMemberInspector& insp); RooMoment*R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooHistFunc.html:22557,cache,cache,22557,root/html528/RooHistFunc.html,https://root.cern,https://root.cern/root/html528/RooHistFunc.html,1,['cache'],['cache']
Performance,"oAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidresetErrorCounters(Int_t resetValue = 10); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); virtual Bool_tselfNormalized() const; TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsPdf::setGeneratorConfig(); voidRooAbsPdf::setGeneratorConfig(const RooNumGenConfig& config); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); voidRooAbsPdf::setNormValueCaching(Int_t minNumIntDim, Int_t ipOrder = 2); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsPdf::setTraceCounter(Int_t value, Bool_t allNodes = kFALSE); voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniq",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAddModel.html:28048,cache,cache,28048,root/html526/RooAddModel.html,https://root.cern,https://root.cern/root/html526/RooAddModel.html,2,['cache'],['cache']
Performance,"oAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidresetErrorCounters(Int_t resetValue = 10); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); virtual Bool_tselfNormalized() const; TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidsetGeneratorConfig(); voidsetGeneratorConfig(const RooNumGenConfig& config); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); voidsetNormValueCaching(Int_t minNumIntDim, Int_t ipOrder = 2); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidsetTraceCounter(Int_t value, Bool_t allNodes = kFALSE); voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsPdf.html:29924,cache,cache,29924,root/html526/RooAbsPdf.html,https://root.cern,https://root.cern/root/html526/RooAbsPdf.html,1,['cache'],['cache']
Performance,"oAbsArg* newCacheOwner, const RooArgSet* newCacheVars, const char* newName = 0); voidcacheValidEntries(); Int_tcalcTreeIndex() const; voidcalculatePartialBinVolume(const RooArgSet& dimSet) const; voidcheckBinBounds() const; Double_tRooAbsData::corrcov(RooRealVar& x, RooRealVar& y, const char* cutSpec, const char* cutRange, Bool_t corr) const; TMatrixDSym*RooAbsData::corrcovMatrix(const RooArgList& vars, const char* cutSpec, const char* cutRange, Bool_t corr) const; RooRealVar*RooAbsData::dataRealVar(const char* methodname, RooRealVar& extVar) const; virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidimportDHistSet(const RooArgList& vars, RooCategory& indexCat, map<std::string,RooDataHist*> dmap, Double_t initWgt); voidimportTH1(const RooArgList& vars, TH1& histo, Double_t initWgt, Bool_t doDensityCorrection); voidimportTH1Set(const RooArgList& vars, RooCategory& indexCat, map<std::string,TH1*> hmap, Double_t initWgt, Bool_t doDensityCorrection); voidinitialize(const char* binningName = 0, Bool_t fillTree = kTRUE); Double_tinterpolateDim(RooRealVar& dim, const RooAbsBinning* binning, Double_t xval, Int_t intOrder, Bool_t correctForBinSize, Bool_t cdfBoundaries); voidTObject::MakeZombie(); virtual voidRooAbsData::optimizeReadingWithCaching(RooAbsArg& arg, const RooArgSet& cacheList, const RooArgSet& keepObsList); virtual RooPlot*RooAbsData::plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsData::PlotOpt o) const; virtual RooPlot*RooAbsData::plotEffOn(RooPlot* frame, const RooAbsCategoryLValue& effCat, RooAbsData::PlotOpt o) const; virtual RooAbsData*reduceEng(const RooArgSet& varSubset, const RooFormulaVar* cutVar, const char* cutRange = 0, Int_t nStart = 0, Int_t nStop = 2000000000, Bool_t copyCache = kTRUE); voidRooDirItem::removeFromDir(TObject* obj); virtual voidRooAbsData::resetCache(); voidsetAllWeights(Double_t value); virtual voidRooAbsData::setArgStatus(const RooArgSet& set, Bool_t active).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooDataHist.html:16429,optimiz,optimizeReadingWithCaching,16429,root/html534/RooDataHist.html,https://root.cern,https://root.cern/root/html534/RooDataHist.html,4,"['cache', 'optimiz']","['cacheList', 'optimizeReadingWithCaching']"
Performance,"oAbsArg.cxx. ◆ redirectServersHook(). bool RooAbsArg::redirectServersHook ; (; const RooAbsCollection & ; newServerList, . bool ; mustReplaceAll, . bool ; nameChange, . bool ; isRecursiveStep . ). virtual . Function that is called at the end of redirectServers(). ; Can be overloaded to inject some class-dependent behavior after server redirection, e.g. resetting of caches. The return value is meant to be an error flag, so in case something goes wrong the function should return true. If you overload this function, don't forget to also call the function of the base class.; See alsoredirectServers() For a detailed explanation of the function parameters. ; Reimplemented in RooAddPdf, RooDerivative, RooProdPdf, RooProfileLL, RooFormulaVar, RooGenericPdf, RooNumConvolution, RooRealIntegral, RooResolutionModel, RooAbsOptTestStatistic, RooAbsTestStatistic, RooAbsPdf, RooAbsReal, and RooProjectedPdf.; Definition at line 1313 of file RooAbsArg.cxx. ◆ registerCache(). void RooAbsArg::registerCache ; (; RooAbsCache & ; cache). Register RooAbsCache with this object. ; This function is called by RooAbsCache constructors for objects that are a datamember of this RooAbsArg. By registering itself the RooAbsArg is aware of all its cache data members and will forward server change and cache mode change calls to the cache objects, which in turn can forward them their contents ; Definition at line 2117 of file RooAbsArg.cxx. ◆ registerProxy() [1/3]. void RooAbsArg::registerProxy ; (; RooArgProxy & ; proxy). protected . Register an RooArgProxy in the proxy list. ; This function is called by owned proxies upon creation. After registration, this arg will forward pointer changes from serverRedirects and updates in cached normalization sets to the proxies immediately after they occur. The proxied argument is also added as value and/or shape server ; Definition at line 1329 of file RooAbsArg.cxx. ◆ registerProxy() [2/3]. void RooAbsArg::registerProxy ; (; RooListProxy & ; proxy). protected . R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsArg.html:91932,cache,cache,91932,doc/master/classRooAbsArg.html,https://root.cern,https://root.cern/doc/master/classRooAbsArg.html,1,['cache'],['cache']
Performance,"oAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; TIterator*_pdfObsIter!; RooSetProxy_pdfObsListList of observables mapped onto histogram observables; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Double_t_totVolume! Total volume of space (product of ranges of observables); Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Bool_t_unitNormAssume contents is unit normalized (for use as pdf cache); Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooHistPdf.html:45303,cache,cache,45303,root/html602/RooHistPdf.html,https://root.cern,https://root.cern/root/html602/RooHistPdf.html,8,['cache'],['cache']
Performance,"oAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; static RooCategory*RooAbsHiddenReal::_dummyBlindState; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooUnblindCPAsymVar.html:33962,cache,cache,33962,root/html534/RooUnblindCPAsymVar.html,https://root.cern,https://root.cern/root/html534/RooUnblindCPAsymVar.html,28,"['Cache', 'cache']","['Cached', 'cache']"
Performance,"oAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooNumConvolution*_conv! Actual convolution calculation; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Bool_t_init! do not persist; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static I",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooNumConvPdf.html:42498,cache,cache,42498,root/html534/RooNumConvPdf.html,https://root.cern,https://root.cern/root/html534/RooNumConvPdf.html,2,['cache'],['cache']
Performance,oAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_t_errorCountNumber of errors remaining to print; static Bool_t_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_t_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_t_negCountNumber of negative probablities remaining to print; RooAbsReal*_norm! Normalization integral (owned by _normMgr); RooObjCacheManager_normMgrThe cache manager; RooArgSet*_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_t_rawValue; Bool_t_selectCompComponent selection flag fo,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsPdf.html:39947,cache,cache,39947,root/html526/RooAbsPdf.html,https://root.cern,https://root.cern/root/html526/RooAbsPdf.html,1,['cache'],['cache']
Performance,oAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_t_errorCountNumber of errors remaining to print; static Bool_t_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_t_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_t_negCountNumber of negative probablities remaining to print; RooAbsReal*_norm! Normalization integral (owned by _normMgr); RooObjCacheManager_normMgrThe cache manager; TString_normRangeNormalization range; static TString_normRangeOverride; RooArgSet*_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsPdf.html:40488,cache,cache,40488,root/html528/RooAbsPdf.html,https://root.cern,https://root.cern/root/html528/RooAbsPdf.html,2,['cache'],['cache']
Performance,"oAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction3Ref<double,double,double,double>funcFunction pointer reference; RooRealProxyxArgument reference; RooRealProxyyArgument reference; RooRealProxyzArgument reference. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void RooCFunction3Ref<VO,VI1,VI2,VI3> Streamer(TBuffer& ); Cust",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooCFunction3Binding_double_double_double_double_.html:35350,cache,cache,35350,root/html534/RooCFunction3Binding_double_double_double_double_.html,https://root.cern,https://root.cern/root/html534/RooCFunction3Binding_double_double_double_double_.html,4,['cache'],['cache']
Performance,"oAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction3Ref<double,unsigned int,double,unsigned int>funcFunction pointer reference; RooRealProxyxArgument reference; RooRealProxyyArgument reference; RooRealProxyzArgument reference. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void RooCFunction3Ref<VO,VI1,VI2,VI3> Streamer(TBuffer& ); Cust",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCFunction3Binding_double_unsigned_int_double_unsigned_int_.html:36958,cache,cache,36958,root/html602/RooCFunction3Binding_double_unsigned_int_double_unsigned_int_.html,https://root.cern,https://root.cern/root/html602/RooCFunction3Binding_double_unsigned_int_double_unsigned_int_.html,8,['cache'],['cache']
Performance,"oAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction3Ref<double,unsigned int,unsigned int,double>funcFunction pointer reference; RooRealProxyxArgument reference; RooRealProxyyArgument reference; RooRealProxyzArgument reference. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void RooCFunction3Ref<VO,VI1,VI2,VI3> Streamer(TBuffer& ); Cust",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCFunction3Binding_double_unsigned_int_unsigned_int_double_.html:36958,cache,cache,36958,root/html602/RooCFunction3Binding_double_unsigned_int_unsigned_int_double_.html,https://root.cern,https://root.cern/root/html602/RooCFunction3Binding_double_unsigned_int_unsigned_int_double_.html,8,['cache'],['cache']
Performance,"oAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxypdfProxy to p.d.f being cached. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooCachedPdf(const char* name, const char* title, RooAbsPdf& _pdf); Constructor taking name, title and function to be cached. To control; granularity of the binning of the cache histogram set the desired properties; in the binning named ""cache"" in the observables of the function. The dimensions; of the cache are automatically matched to the number of observables used; in each use context. Multiple cache in different observable may exists; simultanously if the cached p.d.f is used with multiple observable; configurations simultaneously. RooCachedPdf(const char* name, const char* title, RooAbsPdf& _pdf, const RooArgSet& cacheObs); Constructor taking name, title and function to be cached and; fixed choice of variable to cache. To control granularity of the; binning of the cache histogram set the desired properties in the; binning named ""cache"" in the observables of the function.; If the fixed set of cache observables does not match the observables; defined in the use context of the p.d.f the cache is still filled; completely. Ee.g. when it is specified to cache x and p and only x; is a observable in the given use context the cache histogram will; store sampled values for all values of ob",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCachedPdf.html:46741,cache,cache,46741,root/html602/RooCachedPdf.html,https://root.cern,https://root.cern/root/html602/RooCachedPdf.html,8,['cache'],['cache']
Performance,"oAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); Bool_taddThreshold(Double_t upperLimit, const char* catName, Int_t catIdx = -99999); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooThresholdCategory.html:1802,Cache,CacheModeRooAbsArg,1802,root/html534/RooThresholdCategory.html,https://root.cern,https://root.cern/root/html534/RooThresholdCategory.html,1,['Cache'],['CacheModeRooAbsArg']
Performance,"oAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tanalyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsPdf::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attributes() const; virtual list<Double_t>*binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooHistPdf.html:2041,cache,cacheUniqueSuffix,2041,root/html602/RooHistPdf.html,https://root.cern,https://root.cern/root/html602/RooHistPdf.html,4,['cache'],['cacheUniqueSuffix']
Performance,"oAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMemberInspector& insp) const; RooAbsMoment*RooAbsReal::sigma(RooRealVar& obs); RooAbsMoment*RooAbsReal::sigma(RooRealVar& obs, const RooArgSet& nset); virtual Int_tTNamed::Sizeof() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig(Bool_t createOnTheFly); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); const map<string,string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; const set<string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; RooFIterRooAbsArg::valueClientMIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; voidRooAbsArg::wireAllCaches(); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidRooAbsHiddenReal::writeToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooUnblindCPAsymVar.html:26924,cache,cache,26924,root/html602/RooUnblindCPAsymVar.html,https://root.cern,https://root.cern/root/html602/RooUnblindCPAsymVar.html,16,['cache'],['cache']
Performance,"oAbsArg::setShapeDirty(const RooAbsArg* source) const; virtual voidRooAbsReal::setTreeBranchStatus(TTree& t, Bool_t active); voidRooAbsArg::setValueDirty(const RooAbsArg* source) const; virtual voidRooAbsReal::syncCache(const RooArgSet* set = 0); Double_tRooAbsReal::traceEval(const RooArgSet* set) const; virtual Bool_tRooAbsReal::traceEvalHook(Double_t) const; voidRooAbsArg::unRegisterProxy(RooArgProxy& proxy); voidRooAbsArg::unRegisterProxy(RooSetProxy& proxy); voidRooAbsArg::unRegisterProxy(RooListProxy& proxy). private:. virtual Double_tevaluate() const. Data Members; public:. enum RooAbsReal::ScaleType { Raw; Relative; NumEvent; RelativeExpected; };; enum RooAbsReal::ErrorLoggingMode { PrintErrors; CollectErrors; CountErrors; Ignore; };; enum RooAbsArg::ConstOpCode { Activate; DeActivate; ConfigChange; ValueChange; };; enum RooAbsArg::CacheMode { Always; NotAdvised; Never; };; enum RooAbsArg::OperMode { Auto; AClean; ADirty; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. public:. static map<RooAbsArg*,TRefArray*>RooAbsArg::_ioEvoListtemporary holding list for proxies needed in schema evolution ; static stack<RooAbsArg*>RooAbsArg::_ioReadStackreading stack ; static const UInt_tRooAbsArg::fnv1a32start; static const ULong64_tRooAbsArg::fnv1a64start. protected:. set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooSpHarmonic.html:32302,Cache,CacheMode,32302,root/html534/RooSpHarmonic.html,https://root.cern,https://root.cern/root/html534/RooSpHarmonic.html,1,['Cache'],['CacheMode']
Performance,"oAbsArg::setValueDirty(const RooAbsArg* source) const; virtual voidRooAbsReal::syncCache(const RooArgSet* set = 0); virtual Bool_tRooAbsPdf::syncNormalization(const RooArgSet* dset, Bool_t adjustProxies = kTRUE) const; Double_tRooAbsReal::traceEval(const RooArgSet* set) const; voidRooAbsArg::unRegisterProxy(RooArgProxy& proxy); voidRooAbsArg::unRegisterProxy(RooSetProxy& proxy); voidRooAbsArg::unRegisterProxy(RooListProxy& proxy). private:. Double_tevalAnaInt(const Double_t x) const; virtual Double_tevaluate() const. Data Members; public:. enum RooAbsPdf::ExtendMode { CanNotBeExtended; CanBeExtended; MustBeExtended; };; enum RooAbsReal::ScaleType { Raw; Relative; NumEvent; RelativeExpected; };; enum RooAbsReal::ErrorLoggingMode { PrintErrors; CollectErrors; CountErrors; Ignore; };; enum RooAbsArg::ConstOpCode { Activate; DeActivate; ConfigChange; ValueChange; };; enum RooAbsArg::CacheMode { Always; NotAdvised; Never; };; enum RooAbsArg::OperMode { Auto; AClean; ADirty; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. public:. static map<RooAbsArg*,TRefArray*>RooAbsArg::_ioEvoListtemporary holding list for proxies needed in schema evolution ; static stack<RooAbsArg*>RooAbsArg::_ioReadStackreading stack ; static const UInt_tRooAbsArg::fnv1a32start; static const ULong64_tRooAbsArg::fnv1a64start. protected:. set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRoo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooChebychev.html:37857,Cache,CacheMode,37857,root/html534/RooChebychev.html,https://root.cern,https://root.cern/root/html534/RooChebychev.html,1,['Cache'],['CacheMode']
Performance,"oAbsArg::writeToStream ; (; std::ostream & ; os, . bool ; compact . ); const. pure virtual . Implemented in RooAbsCategory, RooAbsHiddenReal, RooAbsReal, RooAbsRealLValue, RooCategory, RooConstVar, RooErrorVar, RooFormulaVar, RooGenericPdf, RooLinearVar, RooMappedCategory, RooMultiCategory, RooRealVar, RooThresholdCategory, and RooStringVar. Friends And Related Symbol Documentation. ◆ operator<<. std::ostream & operator<< ; (; std::ostream & ; os, . const RooAbsArg & ; arg . ). friend . Ostream operator. ; Definition at line 1666 of file RooAbsArg.cxx. ◆ operator>>. std::istream & operator>> ; (; std::istream & ; is, . RooAbsArg & ; arg . ). friend . Istream operator. ; Definition at line 1675 of file RooAbsArg.cxx. ◆ RooAbsCollection. friend class RooAbsCollection. friend . Definition at line 603 of file RooAbsArg.h. ◆ RooAbsReal. friend class RooAbsReal. friend . Definition at line 600 of file RooAbsArg.h. ◆ RooArgProxy. friend class RooArgProxy. friend . list of caches ; Definition at line 617 of file RooAbsArg.h. ◆ RooCollectionProxy. template<class RooCollection_t > . friend class RooCollectionProxy. friend . Definition at line 619 of file RooAbsArg.h. ◆ RooCompositeDataStore. friend class RooCompositeDataStore. friend . Definition at line 638 of file RooAbsArg.h. ◆ RooDataSet. friend class RooDataSet. friend . Definition at line 641 of file RooAbsArg.h. ◆ RooHistFunc. friend class RooHistFunc. friend . Definition at line 621 of file RooAbsArg.h. ◆ RooHistPdf. friend class RooHistPdf. friend . Definition at line 620 of file RooAbsArg.h. ◆ RooRealIntegral. friend class RooRealIntegral. friend . Definition at line 605 of file RooAbsArg.h. ◆ RooRealMPFE. friend class RooRealMPFE. friend . Definition at line 642 of file RooAbsArg.h. ◆ RooRefArray::Streamer. void RooRefArray::Streamer ; (; TBuffer & ; ). friend . ◆ RooTreeDataStore. friend class RooTreeDataStore. friend . Definition at line 639 of file RooAbsArg.h. ◆ RooVectorDataStore. friend class RooVectorDataStor",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsArg.html:106487,cache,caches,106487,doc/master/classRooAbsArg.html,https://root.cern,https://root.cern/doc/master/classRooAbsArg.html,1,['cache'],['caches']
Performance,"oAbsCacheElement* obj, const TNamed* isetRangeName = 0); Insert payload object 'obj' in cache indexed on nset,iset and isetRangeName. T* RooCacheManager<T> getObj(const RooArgSet* nset, const RooArgSet* iset, Int_t* sterileIdx = 0, const TNamed* isetRangeName = 0); Retrieve payload object indexed on nset,uset amd isetRangeName; If sterileIdx is not null, it is set to the index of the sterile; slot in cacse such a slot is recycled. T* RooCacheManager<T> getObjByIndex(Int_t index) const; Retrieve payload object by slot index. const RooNameSet* RooCacheManager<T> nameSet1ByIndex(Int_t index) const; Retrieve RooNameSet associated with slot at given index. const RooNameSet* RooCacheManager<T> nameSet2ByIndex(Int_t index) const; Retrieve RooNameSet associated with slot at given index. T* getObj(const RooArgSet* nset, Int_t* sterileIndex = 0, const TNamed* isetRangeName = 0); Getter function without integration set. return getObj(const RooArgSet* nset, const RooArgSet* iset, Int_t* sterileIdx, const char* isetRangeName). Int_t setObj(const RooArgSet* nset, RooAbsCacheElement* obj, const TNamed* isetRangeName = 0); Setter function without integration set. Int_t lastIndex() const; Return index of slot used in last get or set operation. Int_t cacheSize() const; Return size of cache. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Interface function to intercept server redirects. void operModeHook(); Interface function to intercept cache operation mode changes. void printCompactTreeHook(ostream& , const char* ); Interface function to cache add contents to output in tree printing mode. void insertObjectHook(RooAbsCacheElement& ); Interface function to perform post-insert operations on cached object. void wireCache(). » Last changed: Sat Jun 20 16:42:22 2015 » Last generated: 2015-06-20 16:42; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooCacheManager_RooAbsCacheElement_.html:4990,cache,cacheSize,4990,root/html534/RooCacheManager_RooAbsCacheElement_.html,https://root.cern,https://root.cern/root/html534/RooCacheManager_RooAbsCacheElement_.html,12,"['cache', 'perform']","['cache', 'cacheSize', 'cached', 'perform']"
Performance,"oAbsCachedPdf::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); Double_tbufferFraction() const; RooFFTConvPdf::BufStratbufferStrategy() const; const RooArgSet&cacheObservables() const; virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooFFTConvPdf.html:6822,cache,cacheUniqueSuffix,6822,root/html534/RooFFTConvPdf.html,https://root.cern,https://root.cern/root/html534/RooFFTConvPdf.html,2,['cache'],['cacheUniqueSuffix']
Performance,"oAbsCachedPdf::getCache(Mf) creating new cache 0x5569d7a23790 with pdf Tpsi_CONV_Rpsi_CACHE_Obs[psi]_NORM_psi for nset (psi) with code 0; [#1] INFO:NumericIntegration -- RooRealIntegral::init(Tpsi_Int[psi]) using numeric integrator RooIntegrator1D to calculate Int(psi); [#1] INFO:Caching -- RooAbsCachedPdf::getCache(Mf) creating new cache 0x5569d7a23790 with pdf Tpsi_CONV_Rpsi_CACHE_Obs[cpsi]_NORM_cpsi for nset (cpsi) with code 0 from preexisting content.; [#1] INFO:NumericIntegration -- RooRealIntegral::init(Tpsi_CONV_Rpsi_CACHE_Obs[cpsi]_NORM_cpsi_Int[cpsi]) using numeric integrator RooIntegrator1D to calculate Int(cpsi); [#1] INFO:Caching -- RooAbsCachedPdf::getCache(Mf) creating new cache 0x5569d79e4210 with pdf Tpsi_CONV_Rpsi_CACHE_Obs[cpsi]_NORM_cpsi for nset (cpsi) with code 0 from preexisting content.; [#1] INFO:NumericIntegration -- RooRealIntegral::init(Tpsi_CONV_Rpsi_CACHE_Obs[cpsi]_NORM_cpsi_Int[cpsi]) using numeric integrator RooIntegrator1D to calculate Int(cpsi); [#1] INFO:Caching -- RooAbsCachedPdf::getCache(Mf) creating new cache 0x5569d79e4210 with pdf Tpsi_CONV_Rpsi_CACHE_Obs[cpsi]_NORM_cpsi for nset (cpsi) with code 0 from preexisting content.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(Mf_over_Mf_Int[cpsi]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_Mf_over_Mf_Int[cpsi]_MfData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(Mf) creating new cache 0x5569d7a58030 with pdf Tpsi_CONV_Rpsi_CACHE_Obs[cpsi] for nset () with code 1 from preexisting content.; [#1] INFO:NumericIntegration -- RooRealIntegral::init(Mf_Int[cpsi]) using numeric integrator RooIntegrator1D to calculate Int(cpsi); [#1] INFO:NumericIntegration -- RooRealIntegral::init(Tpsi_Int[psi]) using numeric integrator RooIntegrator1D to calculate Int(psi); [#",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf210__angularconv_8C.html:9175,cache,cache,9175,doc/master/rf210__angularconv_8C.html,https://root.cern,https://root.cern/doc/master/rf210__angularconv_8C.html,1,['cache'],['cache']
Performance,"oAbsCategoryLValue(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsCategoryLValue.html:1907,Cache,CacheModeRooAbsArg,1907,root/html534/RooAbsCategoryLValue.html,https://root.cern,https://root.cern/root/html534/RooAbsCategoryLValue.html,1,['Cache'],['CacheModeRooAbsArg']
Performance,"oAbsCollection *list, const RooAbsArg *arg=nullptr, bool recurseNonDerived=false) constFill supplied list with all branch nodes of the arg tree starting with ourself as top node.Definition RooAbsArg.cxx:483; RooAbsArg::CloneTObject * Clone(const char *newname=nullptr) const overrideMake a clone of an object using the Streamer facility.Definition RooAbsArg.h:91; RooAbsArg::_serverListRefCountList_t _serverListDefinition RooAbsArg.h:606; RooAbsArg::numCachesInt_t numCaches() constReturn number of registered caches.Definition RooAbsArg.cxx:2136; RooAbsArg::findServerRooAbsArg * findServer(const char *name) constReturn server of this with name name. Returns nullptr if not found.Definition RooAbsArg.h:184; RooAbsArg::operModeOperMode operMode() constQuery the operation mode of this node.Definition RooAbsArg.h:456; RooAbsCacheElement::_ownerRooAbsArg * _owner! Pointer to owning RooAbsArgDefinition RooAbsCacheElement.h:53; RooAbsCachedReal::setInterpolationOrdervoid setInterpolationOrder(Int_t order)Set interpolation order of RooHistFunct representing cache histogram.Definition RooAbsCachedReal.cxx:254; RooAbsCategoryLValueAbstract base class for objects that represent a discrete value that can be set from the outside,...Definition RooAbsCategoryLValue.h:26; RooAbsCollectionAbstract container object that can hold multiple RooAbsArg objects.Definition RooAbsCollection.h:65; RooAbsCollection::removevirtual bool remove(const RooAbsArg &var, bool silent=false, bool matchByNameOnly=false)Remove the specified argument from our list.Definition RooAbsCollection.cxx:656; RooAbsCollection::emptybool empty() constDefinition RooAbsCollection.h:273; RooAbsCollection::addvirtual bool add(const RooAbsArg &var, bool silent=false)Add the specified argument to list.Definition RooAbsCollection.cxx:443; RooAbsCollection::sizeStorage_t::size_type size() constDefinition RooAbsCollection.h:269; RooAbsCollection::firstRooAbsArg * first() constDefinition RooAbsCollection.h:291; RooAbsCollection::co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html:139454,cache,cache,139454,doc/master/RooAbsPdf_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html,1,['cache'],['cache']
Performance,"oAbsData*cacheClone(const RooAbsArg* newCacheOwner, const RooArgSet* newCacheVars, const char* newName = 0); voidcacheValidEntries(); Int_tcalcTreeIndex() const; voidcalculatePartialBinVolume(const RooArgSet& dimSet) const; Double_tRooAbsData::corrcov(RooRealVar& x, RooRealVar& y, const char* cutSpec, const char* cutRange, Bool_t corr) const; TMatrixDSym*RooAbsData::corrcovMatrix(const RooArgList& vars, const char* cutSpec, const char* cutRange, Bool_t corr) const; RooRealVar*RooAbsData::dataRealVar(const char* methodname, RooRealVar& extVar) const; virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidimportDHistSet(const RooArgList& vars, RooCategory& indexCat, map<std::string,RooDataHist*> dmap, Double_t initWgt); voidimportTH1(const RooArgList& vars, TH1& histo, Double_t initWgt, Bool_t doDensityCorrection); voidimportTH1Set(const RooArgList& vars, RooCategory& indexCat, map<std::string,TH1*> hmap, Double_t initWgt, Bool_t doDensityCorrection); voidinitialize(const char* binningName = 0, Bool_t fillTree = kTRUE); Double_tinterpolateDim(RooRealVar& dim, const RooAbsBinning* binning, Double_t xval, Int_t intOrder, Bool_t correctForBinSize, Bool_t cdfBoundaries); voidTObject::MakeZombie(); virtual voidRooAbsData::optimizeReadingWithCaching(RooAbsArg& arg, const RooArgSet& cacheList, const RooArgSet& keepObsList); virtual RooPlot*RooAbsData::plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsData::PlotOpt o) const; virtual RooPlot*RooAbsData::plotEffOn(RooPlot* frame, const RooAbsCategoryLValue& effCat, RooAbsData::PlotOpt o) const; virtual RooAbsData*reduceEng(const RooArgSet& varSubset, const RooFormulaVar* cutVar, const char* cutRange = 0, Int_t nStart = 0, Int_t nStop = 2000000000, Bool_t copyCache = kTRUE); voidRooDirItem::removeFromDir(TObject* obj); virtual voidRooAbsData::resetCache(); voidsetAllWeights(Double_t value); virtual voidRooAbsData::setArgStatus(const RooArgSet& set, Bool_t active).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooDataHist.html:15371,optimiz,optimizeReadingWithCaching,15371,root/html528/RooDataHist.html,https://root.cern,https://root.cern/root/html528/RooDataHist.html,8,"['cache', 'optimiz']","['cacheList', 'optimizeReadingWithCaching']"
Performance,"oAbsData.cxx:323; RooAbsGenContextAbstract base class for generator contexts of RooAbsPdf objects.Definition RooAbsGenContext.h:26; RooAbsGenContext::setExpectedDatavirtual void setExpectedData(bool)Definition RooAbsGenContext.h:65; RooAbsGenContext::generatevirtual RooDataSet * generate(double nEvents=0, bool skipInit=false, bool extendedMode=false)Generate the specified number of events with nEvents>0 and and return a dataset containing the genera...Definition RooAbsGenContext.cxx:130; RooAbsGenContext::isValidbool isValid() constDefinition RooAbsGenContext.h:33; RooAbsGenContext::setProtoDataOrdervirtual void setProtoDataOrder(Int_t *lut)Set the traversal order of prototype data to that in the lookup tables passed as argument.Definition RooAbsGenContext.cxx:319; RooAbsPdf::CacheElemNormalization set with for above integral.Definition RooAbsPdf.h:322; RooAbsPdf::CacheElem::_normstd::unique_ptr< RooAbsReal > _normDefinition RooAbsPdf.h:327; RooAbsPdf::CacheElem::~CacheElem~CacheElem() overrideDestructor of normalization cache element.Definition RooAbsPdf.cxx:2430; RooAbsPdf::GenSpecDefinition RooAbsPdf.h:72; RooAbsPdf::GenSpec::_genContextstd::unique_ptr< RooAbsGenContext > _genContextDefinition RooAbsPdf.h:83; RooAbsPdf::GenSpec::~GenSpecvirtual ~GenSpec(); RooAbsPdf::GenSpec::_whatVarsRooArgSet _whatVarsDefinition RooAbsPdf.h:84; RooAbsPdf::GenSpec::_initbool _initDefinition RooAbsPdf.h:91; RooAbsPdf::GenSpec::_extendedbool _extendedDefinition RooAbsPdf.h:87; RooAbsPdf::GenSpec::_nGenInt_t _nGenDefinition RooAbsPdf.h:86; RooAbsPdf::GenSpec::GenSpecGenSpec()=default; RooAbsPdf::GenSpec::_randProtobool _randProtoDefinition RooAbsPdf.h:88; RooAbsPdf::GenSpec::_resampleProtobool _resampleProtoDefinition RooAbsPdf.h:89; RooAbsPdf::GenSpec::_protoDataRooDataSet * _protoDataDefinition RooAbsPdf.h:85; RooAbsPdfAbstract interface for all probability density functions.Definition RooAbsPdf.h:40; RooAbsPdf::syncNormalizationvirtual bool syncNormalization(const RooArgSet *dse",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html:142120,cache,cache,142120,doc/master/RooAbsPdf_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html,1,['cache'],['cache']
Performance,"oAbsDataStore::_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; Bool_t_ownComps!; RooArgSetRooAbsDataStore::_vars; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooCompositeDataStore(). RooCompositeDataStore(const char* name, const char* title, const RooArgSet& vars, RooCategory& indexCat, map<string,RooAbsDataStore*> inputData); Convert map by label to map by index for more efficient internal use. RooCompositeDataStore(const RooCompositeDataStore& other, const char* newname = 0); Convert map by label to map by index for more efficient internal use. RooCompositeDataStore(const RooCompositeDataStore& other, const RooArgSet& vars, const char* newname = 0); Update index category pointer, if it is contained in input argument vars. ~RooCompositeDataStore(); Destructor. Bool_t valid() const; Return true if currently loaded coordinate is considered valid within; the current range definitions of all observables. void recalculateCache(const RooArgSet* , Int_t , Int_t , Int_t , Bool_t ); Forward recalculate request to all subsets. Bool_t hasFilledCache() const. void forceCacheUpdate(). Int_t fill(); Forward fill request to appropriate subset. Double_t sumEntries() const; Forward fill request to appropriate subset. const RooArgSet* get(Int_t index) const; Load the n-th data point (n='idx') in memory; and return a pointer to the internal RooArgSet; holding its coordinates. Double_t weight() const. Double_t weight(Int_t index) const. Double_t weightError(RooAbsData::ErrorType etype = RooAbsData::Poisson) const. void weightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = RooAbsData::Poisson) const. Bool_t isWeighted() const. void loadValues(const RooAbsDataStore* tds, const RooFormulaVar* select = 0, const char* rangeName = 0, Int_t nStart = 0, Int_t nStop = 2000000000). Bool_t changeObservableName(const char* fro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCompositeDataStore.html:11583,load,loaded,11583,root/html602/RooCompositeDataStore.html,https://root.cern,https://root.cern/root/html602/RooCompositeDataStore.html,4,['load'],['loaded']
Performance,"oAbsMoment::_meanMean (if calculated for central moment); static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooSetProxyRooAbsMoment::_nsetNormalization set (optional); RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Int_tRooAbsMoment::_orderMoment order; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsMoment::_takeRootReturn n-order root of moment; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; RooRealProxyRooAbsMoment::_xObservable; RooRealProxy_xfX*F; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooFirstMoment(); Default constructor. RooFirstM",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooFirstMoment.html:36559,cache,cache,36559,root/html602/RooFirstMoment.html,https://root.cern,https://root.cern/root/html602/RooFirstMoment.html,8,['cache'],['cache']
Performance,"oAbsMoment::_meanMean (if calculated for central moment); static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooSetProxyRooAbsMoment::_nsetNormalization set (optional); RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Int_tRooAbsMoment::_orderMoment order; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsMoment::_takeRootReturn n-order root of moment; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; RooRealProxyRooAbsMoment::_xObservable; RooRealProxy_xfX*F; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooMoment(); Default constructor. RooMoment(cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooMoment.html:36635,cache,cache,36635,root/html602/RooMoment.html,https://root.cern,https://root.cern/root/html602/RooMoment.html,8,['cache'],['cache']
Performance,"oAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; RooSetProxydepsdependents of this p.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooProjectedPdf.html:39907,cache,cache,39907,root/html528/RooProjectedPdf.html,https://root.cern,https://root.cern/root/html528/RooProjectedPdf.html,2,['cache'],['cache']
Performance,"oAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; RooRealProxy_t; RooCategoryProxy_tag; RooRealProxy_tau; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; RooBCPEffDecay::DecayType_type; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooBCPEffDecay.html:41699,cache,cache,41699,root/html528/RooBCPEffDecay.html,https://root.cern,https://root.cern/root/html528/RooBCPEffDecay.html,2,['cache'],['cache']
Performance,"oAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; RooRealProxy_t; RooCategoryProxy_tag; RooRealProxy_tau; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; RooBCPGenDecay::DecayType_type; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooBCPGenDecay.html:41558,cache,cache,41558,root/html528/RooBCPGenDecay.html,https://root.cern,https://root.cern/root/html528/RooBCPGenDecay.html,2,['cache'],['cache']
Performance,"oAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction2Ref<double,double,double>funcFunction pointer reference; RooRealProxyxArgument reference; RooRealProxyyArgument reference.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooCFunction2PdfBinding_double_double_double_.html:42792,cache,cache,42792,root/html534/RooCFunction2PdfBinding_double_double_double_.html,https://root.cern,https://root.cern/root/html534/RooCFunction2PdfBinding_double_double_double_.html,2,['cache'],['cache']
Performance,"oAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; RooRealProxy_t; RooCategoryProxy_tagFlav; RooRealProxy_tau; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; RooBMixDecay::DecayType_type; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooBMixDecay.html:42443,cache,cache,42443,root/html532/RooBMixDecay.html,https://root.cern,https://root.cern/root/html532/RooBMixDecay.html,2,['cache'],['cache']
Performance,"oAbsPdf::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attributes() const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Int_tcalculateBandWidth(Int_t kernel = -999); Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/Roo2DKeysPdf.html:2080,Cache,CacheModeRooAbsArg,2080,root/html602/Roo2DKeysPdf.html,https://root.cern,https://root.cern/root/html602/Roo2DKeysPdf.html,2,['Cache'],['CacheModeRooAbsArg']
Performance,"oAbsPdf::resetErrorCounters(Int_t resetValue = 10); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); virtual Bool_tselfNormalized() const; TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); voidsetCdfBoundaries(Bool_t flag); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsPdf::setGeneratorConfig(); voidRooAbsPdf::setGeneratorConfig(const RooNumGenConfig& config); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidsetInterpolationOrder(Int_t order); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); voidRooAbsPdf::setNormRange(const char* rangeName); voidRooAbsPdf::setNormRangeOverride(const char* rangeName); voidRooAbsPdf::setNormValueCaching(Int_t minNumIntDim, Int_t ipOrder = 2); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsPdf::setTraceCoun",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooHistPdf.html:27438,cache,cache,27438,root/html528/RooHistPdf.html,https://root.cern,https://root.cern/root/html528/RooHistPdf.html,1,['cache'],['cache']
Performance,"oAbsReal& _pdf2, RooAbsReal& _x, RooAbsReal& _alpha, Bool_t cacheAlpha = kFALSE); Constructor with observables x, pdf shapes pdf1 and pdf2 which represent; the shapes at the end points of the interpolation parameter alpha; If doCacheAlpha is true, a two-dimensional cache is constructed in; both alpha and x. RooIntegralMorph(const RooIntegralMorph& other, const char* name = 0); Copy constructor. RooArgSet* actualObservables(const RooArgSet& nset) const; Observable to be cached for given choice of normalization.; Returns the 'x' observable unless doCacheAlpha is set in which; case a set with both x and alpha. RooArgSet* actualParameters(const RooArgSet& nset) const; Parameters of the cache. Returns parameters of both pdf1 and pdf2; and parameter cache, in case doCacheAlpha is not set. const char* inputBaseName() const; Return base name component for cache components in this case; a string encoding the names of both end point p.d.f.s. void fillCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; Fill the cache with the interpolated shape. RooAbsCachedPdf::PdfCacheElem* createCache(const RooArgSet* nset) const; Create and return a derived MorphCacheElem. Double_t evaluate() const; Dummy. void preferredObservableScanOrder(const RooArgSet& obs, RooArgSet& orderedObs) const; Indicate to the RooAbsCachedPdf base class that for the filling of the; cache the traversal of the x should be in the innermost loop, to minimize; recalculation of the one-dimensional internal cache for a fixed value of alpha. RooIntegralMorph(); coverity[UNINIT_CTOR]. TObject* clone(const char* newname) const; { return new RooIntegralMorph(*this,newname); }. virtual ~RooIntegralMorph(); { }. Bool_t selfNormalized() const; P.d.f is self normalized. void setCacheAlpha(Bool_t flag); Activate caching of p.d.f. shape for all values of alpha as well. Bool_t cacheAlpha() const; If true caching of p.d.f for all alpha values is active. » Last changed: Mon Jul 4 15:23:08 2011 » Last generated: 2011-07-04 15",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooIntegralMorph.html:47150,cache,cache,47150,root/html530/RooIntegralMorph.html,https://root.cern,https://root.cern/root/html530/RooIntegralMorph.html,2,['cache'],['cache']
Performance,"oAbsReal& _pdf2, RooAbsReal& _x, RooAbsReal& _alpha, Bool_t cacheAlpha = kFALSE); Constructor with observables x, pdf shapes pdf1 and pdf2 which represent; the shapes at the end points of the interpolation parameter alpha; If doCacheAlpha is true, a two-dimensional cache is constructed in; both alpha and x. RooIntegralMorph(const RooIntegralMorph& other, const char* name = 0); Copy constructor. RooArgSet* actualObservables(const RooArgSet& nset) const; Observable to be cached for given choice of normalization.; Returns the 'x' observable unless doCacheAlpha is set in which; case a set with both x and alpha. RooArgSet* actualParameters(const RooArgSet& nset) const; Parameters of the cache. Returns parameters of both pdf1 and pdf2; and parameter cache, in case doCacheAlpha is not set. const char* inputBaseName() const; Return base name component for cache components in this case; a string encoding the names of both end point p.d.f.s. void fillCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; Fill the cache with the interpolated shape. RooAbsCachedPdf::PdfCacheElem* createCache(const RooArgSet* nset) const; Create and return a derived MorphCacheElem. Double_t evaluate() const; Dummy. void preferredObservableScanOrder(const RooArgSet& obs, RooArgSet& orderedObs) const; Indicate to the RooAbsCachedPdf base class that for the filling of the; cache the traversal of the x should be in the innermost loop, to minimize; recalculation of the one-dimensional internal cache for a fixed value of alpha. RooIntegralMorph(); coverity[UNINIT_CTOR]. TObject* clone(const char* newname) const; { return new RooIntegralMorph(*this,newname); }. virtual ~RooIntegralMorph(); { }. Bool_t selfNormalized() const; P.d.f is self normalized. void setCacheAlpha(Bool_t flag); Activate caching of p.d.f. shape for all values of alpha as well. Bool_t cacheAlpha() const; If true caching of p.d.f for all alpha values is active. » Last changed: Sat Oct 9 06:58:30 2010 » Last generated: 2010-10-09 06",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooIntegralMorph.html:46590,cache,cache,46590,root/html528/RooIntegralMorph.html,https://root.cern,https://root.cern/root/html528/RooIntegralMorph.html,2,['cache'],['cache']
Performance,"oAbsReal& _pdf2, RooAbsReal& _x, RooAbsReal& _alpha, Bool_t cacheAlpha = kFALSE); Constructor with observables x, pdf shapes pdf1 and pdf2 which represent; the shapes at the end points of the interpolation parameter alpha; If doCacheAlpha is true, a two-dimensional cache is constructed in; both alpha and x. RooIntegralMorph(const RooIntegralMorph& other, const char* name = 0); Copy constructor. RooArgSet* actualObservables(const RooArgSet& nset) const; Observable to be cached for given choice of normalization.; Returns the 'x' observable unless doCacheAlpha is set in which; case a set with both x and alpha. RooArgSet* actualParameters(const RooArgSet& nset) const; Parameters of the cache. Returns parameters of both pdf1 and pdf2; and parameter cache, in case doCacheAlpha is not set. const char* inputBaseName() const; Return base name component for cache components in this case; a string encoding the names of both end point p.d.f.s. void fillCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; Fill the cache with the interpolated shape. RooAbsCachedPdf::PdfCacheElem* createCache(const RooArgSet* nset) const; Create and return a derived MorphCacheElem. Double_t evaluate() const; Dummy. void preferredObservableScanOrder(const RooArgSet& obs, RooArgSet& orderedObs) const; Indicate to the RooAbsCachedPdf base class that for the filling of the; cache the traversal of the x should be in the innermost loop, to minimize; recalculation of the one-dimensional internal cache for a fixed value of alpha. RooIntegralMorph(); coverity[UNINIT_CTOR]. TObject* clone(const char* newname) const; { return new RooIntegralMorph(*this,newname); }. virtual ~RooIntegralMorph(); { }. Bool_t selfNormalized() const; P.d.f is self normalized. void setCacheAlpha(Bool_t flag); Activate caching of p.d.f. shape for all values of alpha as well. Bool_t cacheAlpha() const; If true caching of p.d.f for all alpha values is active. » Last changed: Thu Nov 3 20:08:25 2011 » Last generated: 2011-11-03 20",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooIntegralMorph.html:47557,cache,cache,47557,root/html532/RooIntegralMorph.html,https://root.cern,https://root.cern/root/html532/RooIntegralMorph.html,4,['cache'],['cache']
Performance,"oAbsReal& _pdf2, RooAbsReal& _x, RooAbsReal& _alpha, Bool_t cacheAlpha = kFALSE); Constructor with observables x, pdf shapes pdf1 and pdf2 which represent; the shapes at the end points of the interpolation parameter alpha; If doCacheAlpha is true, a two-dimensional cache is constructed in; both alpha and x. RooIntegralMorph(const RooIntegralMorph& other, const char* name = 0); Copy constructor. RooArgSet* actualObservables(const RooArgSet& nset) const; Observable to be cached for given choice of normalization.; Returns the 'x' observable unless doCacheAlpha is set in which; case a set with both x and alpha. RooArgSet* actualParameters(const RooArgSet& nset) const; Parameters of the cache. Returns parameters of both pdf1 and pdf2; and parameter cache, in case doCacheAlpha is not set. const char* inputBaseName() const; Return base name component for cache components in this case; a string encoding the names of both end point p.d.f.s. void fillCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; Fill the cache with the interpolated shape. RooAbsCachedPdf::PdfCacheElem* createCache(const RooArgSet* nset) const; Create and return a derived MorphCacheElem. Double_t evaluate() const; Dummy. void preferredObservableScanOrder(const RooArgSet& obs, RooArgSet& orderedObs) const; Indicate to the RooAbsCachedPdf base class that for the filling of the; cache the traversal of the x should be in the innermost loop, to minimize; recalculation of the one-dimensional internal cache for a fixed value of alpha. RooIntegralMorph(); coverity[UNINIT_CTOR]. TObject* clone(const char* newname) const; { return new RooIntegralMorph(*this,newname); }. virtual ~RooIntegralMorph(); { }. Bool_t selfNormalized() const; P.d.f is self normalized. void setCacheAlpha(Bool_t flag); Activate caching of p.d.f. shape for all values of alpha as well. Bool_t cacheAlpha() const; If true caching of p.d.f for all alpha values is active. » Last changed: Tue Jun 2 15:31:37 2015 » Last generated: 2015-06-02 15",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooIntegralMorph.html:51591,cache,cache,51591,root/html604/RooIntegralMorph.html,https://root.cern,https://root.cern/root/html604/RooIntegralMorph.html,4,['cache'],['cache']
Performance,"oAbsReal& _pdf2, RooAbsReal& _x, RooAbsReal& _alpha, Bool_t cacheAlpha = kFALSE); Constructor with observables x, pdf shapes pdf1 and pdf2 which represent; the shapes at the end points of the interpolation parameter alpha; If doCacheAlpha is true, a two-dimensional cache is constructed in; both alpha and x. RooIntegralMorph(const RooIntegralMorph& other, const char* name = 0); Copy constructor. RooArgSet* actualObservables(const RooArgSet& nset) const; Observable to be cached for given choice of normalization.; Returns the 'x' observable unless doCacheAlpha is set in which; case a set with both x and alpha. RooArgSet* actualParameters(const RooArgSet& nset) const; Parameters of the cache. Returns parameters of both pdf1 and pdf2; and parameter cache, in case doCacheAlpha is not set. const char* inputBaseName() const; Return base name component for cache components in this case; a string encoding the names of both end point p.d.f.s. void fillCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; Fill the cache with the interpolated shape. RooAbsCachedPdf::PdfCacheElem* createCache(const RooArgSet* nset) const; Create and return a derived MorphCacheElem. Double_t evaluate() const; Dummy. void preferredObservableScanOrder(const RooArgSet& obs, RooArgSet& orderedObs) const; Indicate to the RooAbsCachedPdf base class that for the filling of the; cache the traversal of the x should be in the innermost loop, to minimize; recalculation of the one-dimensional internal cache for a fixed value of alpha. RooIntegralMorph(); coverity[UNINIT_CTOR]. TObject* clone(const char* newname) const; { return new RooIntegralMorph(*this,newname); }. virtual ~RooIntegralMorph(); { }. Bool_t selfNormalized() const; P.d.f is self normalized. void setCacheAlpha(Bool_t flag); Activate caching of p.d.f. shape for all values of alpha as well. Bool_t cacheAlpha() const; If true caching of p.d.f for all alpha values is active. » Last changed: Tue Jun 30 14:33:34 2015 » Last generated: 2015-06-30 1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooIntegralMorph.html:51591,cache,cache,51591,root/html602/RooIntegralMorph.html,https://root.cern,https://root.cern/root/html602/RooIntegralMorph.html,4,['cache'],['cache']
Performance,"oAbsReal& _pdf2, RooAbsReal& _x, RooAbsReal& _alpha, Bool_t cacheAlpha = kFALSE); Constructor with observables x, pdf shapes pdf1 and pdf2 which represent; the shapes at the end points of the interpolation parameter alpha; If doCacheAlpha is true, a two-dimensional cache is constructed in; both alpha and x. RooIntegralMorph(const RooIntegralMorph& other, const char* name = 0); Copy constructor. RooArgSet* actualObservables(const RooArgSet& nset) const; Observable to be cached for given choice of normalization.; Returns the 'x' observable unless doCacheAlpha is set in which; case a set with both x and alpha. RooArgSet* actualParameters(const RooArgSet& nset) const; Parameters of the cache. Returns parameters of both pdf1 and pdf2; and parameter cache, in case doCacheAlpha is not set. const char* inputBaseName() const; Return base name component for cache components in this case; a string encoding the names of both end point p.d.f.s. void fillCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; Fill the cache with the interpolated shape. RooAbsCachedPdf::PdfCacheElem* createCache(const RooArgSet* nset) const; Create and return a derived MorphCacheElem. Double_t evaluate() const; Dummy. void preferredObservableScanOrder(const RooArgSet& obs, RooArgSet& orderedObs) const; Indicate to the RooAbsCachedPdf base class that for the filling of the; cache the traversal of the x should be in the innermost loop, to minimize; recalculation of the one-dimensional internal cache for a fixed value of alpha. RooIntegralMorph(); coverity[UNINIT_CTOR]. TObject* clone(const char* newname) const; { return new RooIntegralMorph(*this,newname); }. virtual ~RooIntegralMorph(); { }. Bool_t selfNormalized() const; P.d.f is self normalized. void setCacheAlpha(Bool_t flag); Activate caching of p.d.f. shape for all values of alpha as well. Bool_t cacheAlpha() const; If true caching of p.d.f for all alpha values is active. » Last changed: Tue Mar 10 17:17:24 2015 » Last generated: 2015-03-10 1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooIntegralMorph.html:49908,cache,cache,49908,root/html534/RooIntegralMorph.html,https://root.cern,https://root.cern/root/html534/RooIntegralMorph.html,4,['cache'],['cache']
Performance,"oAbsReal& _pdf2, RooAbsReal& _x, RooAbsReal& _alpha, Bool_t cacheAlpha = kFALSE); Constructor with observables x, pdf shapes pdf1 and pdf2 which represent; the shapes at the end points of the interpolation parameter alpha; If doCacheAlpha is true, a two-dimensional cache is constructed in; both alpha and x. RooIntegralMorph(const RooIntegralMorph& other, const char* name = 0); Copy constructor. RooArgSet* actualObservables(const RooArgSet& nset) const; Observable to be cached for given choice of normalization.; Returns the 'x' observable unless doCacheAlpha is set in which; case a set with both x and alpha. RooArgSet* actualParameters(const RooArgSet& nset) const; Parameters of the cache. Returns parameters of both pdf1 and pdf2; and parameter cache, in case doCacheAlpha is not set. const char* inputBaseName() const; Return base name component for cache components in this case; a string encoding the names of both end point p.d.f.s. void fillCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; Fill the cache with the interpolated shape. RooAbsCachedPdf::PdfCacheElem* createCache(const RooArgSet* nset) const; Create and return a derived MorphCacheElem. Double_t evaluate() const; Dummy. void preferredObservableScanOrder(const RooArgSet& obs, RooArgSet& orderedObs) const; Indicate to the RooAbsCachedPdf base class that for the filling of the; cache the traversal of the x should be in the innermost loop, to minimize; recalculation of the one-dimensional internal cache for a fixed value of alpha. RooIntegralMorph(); {}. TObject* clone(const char* newname) const; { return new RooIntegralMorph(*this,newname); }. virtual ~RooIntegralMorph(); { }. Bool_t selfNormalized() const; P.d.f is self normalized. void setCacheAlpha(Bool_t flag); Activate caching of p.d.f. shape for all values of alpha as well. Bool_t cacheAlpha() const; If true caching of p.d.f for all alpha values is active. » Last changed: Mon Dec 7 13:48:02 2009 » Last generated: 2009-12-07 13:48; This page has ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooIntegralMorph.html:46049,cache,cache,46049,root/html526/RooIntegralMorph.html,https://root.cern,https://root.cern/root/html526/RooIntegralMorph.html,2,['cache'],['cache']
Performance,"oAbsReal** gofArray, Int_t nVal) const; Method to combined test statistic results calculated into partitions into; the global result. This default implementation adds the partition return; values. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); Catch server redirect calls and forward to internal clone of function. void printCompactTreeHook(ostream& os, const char* indent = """"); Catch print hook function and forward to function clone. void constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); Driver function to propagate constant term optimizations in test statistic.; If code Activate is sent, constant term optimization will be executed.; If code Deacivate is sent, any existing constant term optimizations will; be abanoned. If codes ConfigChange or ValueChange are sent, any existing; constant term optimizations will be redone. void optimizeCaching(); This method changes the value caching logic for all nodes that depends on any of the observables; as defined by the given dataset. When evaluating a test statistic constructed from the RooAbsReal; with a dataset the observables are guaranteed to change with every call, thus there is no point; in tracking these changes which result in a net overhead. Thus for observable-dependent nodes,; the evaluation mechanism is changed from being dependent on a 'valueDirty' flag to guaranteed evaluation.; On the dataset side, the observables objects are modified to no longer send valueDirty messages; to their client. void optimizeConstantTerms(Bool_t ); Driver function to activate global constant term optimization.; If activated constant terms are found and cached with the dataset; The operation mode of cached nodes is set to AClean meaning that; their getVal() call will never result in an evaluate call.; Finally the branches in the dataset that correspond to observables; that are exclusively used in constant terms are disabled as; they serve no more ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsOptTestStatistic.html:36346,optimiz,optimizeCaching,36346,root/html526/RooAbsOptTestStatistic.html,https://root.cern,https://root.cern/root/html526/RooAbsOptTestStatistic.html,3,['optimiz'],['optimizeCaching']
Performance,"oAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; TIterator*_obsIter! Iterator over lowSet; RooListProxy_obsSetLow-side variation; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooArgList_ownedListList of owned components; TIterator*_paramIter! Iterator over paramSet; RooListProxy_paramSetinterpolation parameters; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInter",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooJeffreysPrior.html:39179,cache,cache,39179,root/html530/RooJeffreysPrior.html,https://root.cern,https://root.cern/root/html530/RooJeffreysPrior.html,1,['cache'],['cache']
Performance,"oAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManager_cacheMgrThe cache manager ; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Int_t_ipOrderInterpolation order for cache histograms ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsCachedPdf.html:41870,cache,cache,41870,root/html534/RooAbsCachedPdf.html,https://root.cern,https://root.cern/root/html534/RooAbsCachedPdf.html,7,"['Cache', 'cache']","['Cached', 'cache']"
Performance,"oAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Int_tRooAbsCachedReal::_ipOrderInterpolation order for cache histograms ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProx",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooNumCdf.html:33612,cache,cache,33612,root/html530/RooNumCdf.html,https://root.cern,https://root.cern/root/html530/RooNumCdf.html,2,['cache'],['cache']
Performance,"oAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooGenProdProj(); Default constructor. RooGenProdProj(const char* name, const char* title, const RooArgSet& _prodSet, const RooArgSet& _intSet, const R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooGenProdProj.html:35432,cache,cache,35432,root/html534/RooGenProdProj.html,https://root.cern,https://root.cern/root/html534/RooGenProdProj.html,4,['cache'],['cache']
Performance,"oAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooProduct(); Default constructor. ~RooProduct(); Destructor. RooProduct(const char* name, const char* title, const RooArgList& _prodSet); Construct fu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooProduct.html:34843,cache,cache,34843,root/html534/RooProduct.html,https://root.cern,https://root.cern/root/html534/RooProduct.html,4,['cache'],['cache']
Performance,"oAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsRealLValue(); Destructor. Bool_t inRange(Double_t value, const char* rangeName, Double_t* clippedValue = 0) const; Return kTRUE if the input val",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsRealLValue.html:38462,cache,cache,38462,root/html534/RooAbsRealLValue.html,https://root.cern,https://root.cern/root/html534/RooAbsRealLValue.html,4,['cache'],['cache']
Performance,"oAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsSelfCachedReal(); Destructor. void fillCacheObject(RooAbsCachedReal::FuncCacheElem& cache) const; Fill cache with sampling of function as define",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsSelfCachedReal.html:36240,cache,cache,36240,root/html534/RooAbsSelfCachedReal.html,https://root.cern,https://root.cern/root/html534/RooAbsSelfCachedReal.html,4,['cache'],['cache']
Performance,"oAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Bool_t_disableCacheFlag to run object in passthrough (= non-caching mode). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsCachedReal(); Destructor. Double_t getValV(const RooArgSet*",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsCachedReal.html:36055,cache,cache,36055,root/html534/RooAbsCachedReal.html,https://root.cern,https://root.cern/root/html534/RooAbsCachedReal.html,4,['cache'],['cache']
Performance,"oAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. RooListProxy_catListAccept/reject categories; RooListProxy_effFuncListEfficiency functions per category; Bool_t_ignoreNonVisibleIgnore combination of only rejects (since invisible). Class Charts. Inheritance; Inherited Members; Incl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooMultiBinomial.html:35074,cache,cache,35074,root/html534/RooMultiBinomial.html,https://root.cern,https://root.cern/root/html534/RooMultiBinomial.html,4,['cache'],['cache']
Performance,"oAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TIterator*_boundIter! do not persist; RooListProxy_boundaryList; TIterator*_coefIter! do not persist; RooListProxy_coefList; Bool_t_interpolate; RooRealProxy_x. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Func",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStepFunction.html:34977,cache,cache,34977,root/html534/RooStepFunction.html,https://root.cern,https://root.cern/root/html534/RooStepFunction.html,4,['cache'],['cache']
Performance,"oAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; RooCategoryProxyRooAbsHiddenReal::_stateProxy to hiding state category; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; RooRealProxy_valueHolder of the blind value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooUnblindPrecision(); Default constructor. RooUnblindPrecision(const char* name, const char*",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooUnblindPrecision.html:35572,cache,cache,35572,root/html534/RooUnblindPrecision.html,https://root.cern,https://root.cern/root/html534/RooUnblindPrecision.html,4,['cache'],['cache']
Performance,"oAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooArgList_ownedListList of owned components; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; RooListProxy_setset of terms to be summed; TIterator*_setIter! Iterator over set; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAddition(). RooAddition(const char* name, const char* title, const RooArgList& sumSet, Boo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAddition.html:36380,cache,cache,36380,root/html602/RooAddition.html,https://root.cern,https://root.cern/root/html602/RooAddition.html,8,['cache'],['cache']
Performance,"oAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsCachedReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); Bool_tcacheSource() const; virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(),",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooCachedReal.html:2282,cache,cacheUniqueSuffix,2282,root/html534/RooCachedReal.html,https://root.cern,https://root.cern/root/html534/RooCachedReal.html,2,['cache'],['cacheUniqueSuffix']
Performance,"oAdd() constReturn the wrapper around the directory auto add function.Definition TClass.cxx:7554; TClass::BuildRealDatavoid BuildRealData(void *pointer=nullptr, Bool_t isTransient=kFALSE)Build a full list of persistent data members.Definition TClass.cxx:2098; TClass::IsTObjectBool_t IsTObject() constReturn kTRUE is the class inherits from TObject.Definition TClass.cxx:6005; TClass::GetStreamerInfoTVirtualStreamerInfo * GetStreamerInfo(Int_t version=0, Bool_t isTransient=kFALSE) constreturns a pointer to the TVirtualStreamerInfo object for version If the object does not exist,...Definition TClass.cxx:4666; TClass::GetBaseClassOffsetInt_t GetBaseClassOffset(const TClass *toBase, void *address=nullptr, bool isDerivedObject=true)Definition TClass.cxx:2858; TClass::GetCollectionProxyTVirtualCollectionProxy * GetCollectionProxy() constReturn the proxy describing the collection (if any).Definition TClass.cxx:2964; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:3035; TCollection::Classstatic TClass * Class(); TCollection::UseRWLockvirtual bool UseRWLock(Bool_t enable=true)Set this collection to use a RW lock upon access, making it thread safe.Definition TCollection.cxx:761; TCollection::GetSizevirtual Int_t GetSize() constReturn the capacity of the collection, i.e.Definition TCollection.h:184; TDatimeThis class stores the date and time with a precision of one second in an unsigned 32 bit word (950130...Definition TDatime.h:37; TDatime::FillBuffervoid FillBuffer(char *&buffer)Encode Date/Time into buffer, used by I/O system.Definition TDatime.cxx:229; TDatime::AsSQLStringconst char * AsSQLString() constReturn the date & time in SQL compatible string format, like: 1997-01-15 20:16:28.Definition TDatime.cxx:152; TDatime::SizeofInt_t Sizeof() constDefinition TDatime.h:81; TDatime::Streamervirtual void Streamer(TBuffer &)Stream a object o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TDirectoryFile_8cxx_source.html:81937,load,load,81937,doc/master/TDirectoryFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TDirectoryFile_8cxx_source.html,1,['load'],['load']
Performance,"oAddPdf components; set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooArgSetRooAbsOptTestStatistic::_cachedNodes! List of nodes that are cached as constant expressions; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooAbsData*RooAbsTestStatistic::_dataPointer to original input dataset; RooAbsData*RooAbsOptTestStatistic::_dataClonePointer to internal clone if input data; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; static RooArgSet_emptySetSupports named argument constructor; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; RooAbsData::ErrorType_etypeError type store in associated RooDataHist; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooAbsReal*RooAbsTestStatistic::_funcPointer to original input function; RooAbsReal*RooAbsOptTestStatistic::_funcClonePointer to internal clone of input function; RooArgSet*RooAbsOptTestStatistic::_funcCloneSetSet owning all components of internal clone of input function; RooChi2Var::FuncMode_funcModeFunction, P.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooChi2Var.html:35206,cache,cache,35206,root/html532/RooChi2Var.html,https://root.cern,https://root.cern/root/html532/RooChi2Var.html,2,['cache'],['cache']
Performance,"oArgList& xvec, const RooFitResult& fr). RooMultiVarGaussian(const char *name, const char *title,					 const RooArgList& xvec, const TVectorD& mu, const TMatrixDSym& cov). RooMultiVarGaussian(const char *name, const char *title,					 const RooArgList& xvec, const TMatrixDSym& cov). RooMultiVarGaussian(const RooMultiVarGaussian& other, const char* name = 0). void syncMuVec() const. Double_t evaluate() const; Represent observables as vector. Int_t getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; Analytical integral known over all observables. Double_t analyticalIntegral(Int_t code, const char* rangeName = 0) const; Handle full integral here. Int_t getGenerator(const RooArgSet& directVars, RooArgSet& generateVars, Bool_t staticInitOK = kTRUE) const; Special case: generate all observables. void initGenerator(Int_t code); Clear the GenData cache as its content is not invariant under changes in; the mu vector. void generateEvent(Int_t code); Retrieve generator config from cache. void decodeCode(Int_t code, vector<int>& map1, vector<int>& map2) const; Decode analytical integration/generation code into index map of integrated/generated (map2); and non-integrated/generated observables (map1). void blockDecompose(const TMatrixD& input, const vector<int>& map1, const vector<int>& map2, TMatrixDSym& S11, TMatrixD& S12, TMatrixD& S21, TMatrixDSym& S22); Block decomposition of covI according to given maps of observables. RooMultiVarGaussian(); {}. void setAnaIntZ(Double_t z); { _z = z ; }. TObject* clone(const char* newname) const; { return new RooMultiVarGaussian(*this,newname); }. virtual ~RooMultiVarGaussian(); { }. const TMatrixDSym& covarianceMatrix() const; { return _cov ; }. AnaIntData& anaIntData(Int_t code) const. GenData& genData(Int_t code) const. » Last changed: Mon Dec 7 13:48:21 2009 » Last generated: 2009-12-07 13:48; This page has been automatically generated. For comments or suggestions regarding the documentation o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooMultiVarGaussian.html:41516,cache,cache,41516,root/html526/RooMultiVarGaussian.html,https://root.cern,https://root.cern/root/html526/RooMultiVarGaussian.html,1,['cache'],['cache']
Performance,"oArgProxy& proxy); voidRooAbsArg::registerProxy(RooSetProxy& proxy); voidRooAbsArg::registerProxy(RooListProxy& proxy); voidRooAbsArg::setProxyNormSet(const RooArgSet* nset); voidRooAbsArg::setShapeDirty(const RooAbsArg* source) const; virtual voidsetTreeBranchStatus(TTree& t, Bool_t active); voidRooAbsArg::setValueDirty(const RooAbsArg* source) const; virtual voidsyncCache(const RooArgSet* nset = 0); const char*traceEval() const; virtual Bool_ttraceEvalHook(const char* value) const; voidRooAbsArg::unRegisterProxy(RooArgProxy& proxy); voidRooAbsArg::unRegisterProxy(RooSetProxy& proxy); voidRooAbsArg::unRegisterProxy(RooListProxy& proxy). Data Members; public:. enum RooAbsArg::ConstOpCode { Activate; DeActivate; ConfigChange; ValueChange; };; enum RooAbsArg::CacheMode { Always; NotAdvised; Never; };; enum RooAbsArg::OperMode { Auto; AClean; ADirty; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. public:. static map<RooAbsArg*,TRefArray*>RooAbsArg::_ioEvoListtemporary holding list for proxies needed in schema evolution ; static stack<RooAbsArg*>RooAbsArg::_ioReadStackreading stack ; static const UInt_tRooAbsArg::fnv1a32start; static const ULong64_tRooAbsArg::fnv1a64start. protected:. set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propaga",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsString.html:17895,Cache,CacheMode,17895,root/html534/RooAbsString.html,https://root.cern,https://root.cern/root/html534/RooAbsString.html,1,['Cache'],['CacheMode']
Performance,"oArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual RooAbsArg&operator=(const RooAbsReal& other); virtual RooAbsArg&operator=(Double_t newValue); virtual RooAbsArg&operator=(Int_t ival); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsRealLValue.html:22980,optimiz,optimizeCacheMode,22980,root/html534/RooAbsRealLValue.html,https://root.cern,https://root.cern/root/html534/RooAbsRealLValue.html,2,['optimiz'],['optimizeCacheMode']
Performance,"oArgSet* nset) const; virtual Double_tRooAbsPdf::expectedEvents(const RooArgSet& nset) const; RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual Double_tRooAbsPdf::extendedTerm(Double_t observedEvents, const RooArgSet* nset = 0) const; virtual RooAbsPdf::ExtendModeRooAbsPdf::extendMode() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); RooDataHist*RooAbsReal::fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual RooFitResult*RooAbsPdf::fitTo(RooAbsData& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsPdf::fitTo(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/Roo2DKeysPdf.html:11088,cache,cacheList,11088,root/html532/Roo2DKeysPdf.html,https://root.cern,https://root.cern/root/html532/Roo2DKeysPdf.html,518,['cache'],['cacheList']
Performance,"oArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; RooRealProxyalpha; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxym; RooRealProxym0; RooRealProxyn; RooRealProxysigma.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooCBShape.html:39661,cache,cache,39661,root/html530/RooCBShape.html,https://root.cern,https://root.cern/root/html530/RooCBShape.html,2,['cache'],['cache']
Performance,"oArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction1Ref<double,double>funcFunction pointer reference; RooRealProxyxArgument reference. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void RooCFunction1Ref<VO,VI> Streamer(TBuffer& ); Custom streamer for function pointer reference object",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooCFunction1Binding_double_double_.html:35174,cache,cache,35174,root/html534/RooCFunction1Binding_double_double_.html,https://root.cern,https://root.cern/root/html534/RooCFunction1Binding_double_double_.html,4,['cache'],['cache']
Performance,"oBuffer().clear();; 2154 ; 2155 fInterpreter->Initialize();; 2156}; 2157 ; 2158////////////////////////////////////////////////////////////////////////////////; 2159/// Helper function used by TClass::GetClass().; 2160/// This function attempts to load the dictionary for 'classname'; 2161/// either from the TClassTable or from the list of generator.; 2162/// If silent is 'true', do not warn about missing dictionary for the class.; 2163/// (typically used for class that are used only for transient members); 2164///; 2165/// The 'requestedname' is expected to be already normalized.; 2166 ; 2167TClass *TROOT::LoadClass(const char *requestedname, Bool_t silent) const; 2168{; 2169 return TClass::LoadClass(requestedname, silent);; 2170}; 2171 ; 2172////////////////////////////////////////////////////////////////////////////////; 2173/// Check if class ""classname"" is known to the interpreter (in fact,; 2174/// this check is not needed anymore, so classname is ignored). If; 2175/// not it will load library ""libname"". If the library couldn't be found with original; 2176/// libname and if the name was not prefixed with lib, try to prefix with ""lib"" and search again.; 2177/// If DynamicPathName still couldn't find the library, return -1.; 2178/// If check is true it will only check if libname exists and is; 2179/// readable.; 2180/// Returns 0 on successful loading, -1 in case libname does not; 2181/// exist or in case of error and -2 in case of version mismatch.; 2182 ; 2183Int_t TROOT::LoadClass(const char * /*classname*/, const char *libname,; 2184 Bool_t check); 2185{; 2186 TString lib(libname);; 2187 ; 2188 // Check if libname exists in path or not; 2189 if (char *path = gSystem->DynamicPathName(lib, kTRUE)) {; 2190 // If check == true, only check if it exists and if it's readable; 2191 if (check) {; 2192 delete [] path;; 2193 return 0;; 2194 }; 2195 ; 2196 // If check == false, try to load the library; 2197 else {; 2198 int err = gSystem->Load(path, nullptr, kTRUE);; 219",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8cxx_source.html:83168,load,load,83168,doc/master/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8cxx_source.html,2,['load'],['load']
Performance,"oCacheconst TList * GetStreamerInfoCache()Returns the cached list of StreamerInfos used in this file.Definition TFile.cxx:1366; TFile::GetReadStreamerInfostatic Bool_t GetReadStreamerInfo()If the streamerinfos are to be read at file opening.Definition TFile.cxx:3742; TFile::fArchiveTArchiveFile * fArchive!Archive file from which we read this fileDefinition TFile.h:97; TFile::SysSyncvirtual Int_t SysSync(Int_t fd)Interface to system fsync. All arguments like in POSIX fsync().Definition TFile.cxx:4552; TFile::Classstatic TClass * Class(); TFile::ReOpenvirtual Int_t ReOpen(Option_t *mode)Reopen a file with a different access mode.Definition TFile.cxx:2162; TFile::ReadStreamerInfovirtual void ReadStreamerInfo()Read the list of StreamerInfo from this file.Definition TFile.cxx:3605; TFile::Matchesvirtual Bool_t Matches(const char *name)Return kTRUE if 'url' matches the coordinates of this file.Definition TFile.cxx:4766; TFile::SetCacheReadvirtual void SetCacheRead(TFileCacheRead *cache, TObject *tree=nullptr, ECacheAction action=kDisconnect)Set a pointer to the read cache.Definition TFile.cxx:2365; TFile::fClassIndexTArrayC * fClassIndex!Index of TStreamerInfo classes written to this fileDefinition TFile.h:94; TFile::GetFileBytesWrittenstatic Long64_t GetFileBytesWritten()Static function returning the total number of bytes written to all files.Definition TFile.cxx:4583; TFile::GetStreamerInfoListImplvirtual InfoListRet GetStreamerInfoListImpl(bool lookupSICache)See documentation of GetStreamerInfoList for more details.Definition TFile.cxx:1376; TFile::kStartBigFile@ kStartBigFileDefinition TFile.h:200; TFile::SetReadStreamerInfostatic void SetReadStreamerInfo(Bool_t readinfo=kTRUE)Specify if the streamerinfos must be read at file opening.Definition TFile.cxx:3732; TFile::fNoAnchorInNameBool_t fNoAnchorInName!True if we don't want to force the anchor to be appended to the file nameDefinition TFile.h:103; TFile::SetFileBytesReadstatic void SetFileBytesRead(Long64_t bytes=0)D",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:213443,cache,cache,213443,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,2,['cache'],['cache']
Performance,"oCachedPdf & ; other, . const char * ; name = nullptr . ). Copy constructor. ; Definition at line 79 of file RooCachedPdf.cxx. Member Function Documentation. ◆ actualObservables(). RooFit::OwningPtr< RooArgSet > RooCachedPdf::actualObservables ; (; const RooArgSet & ; nset); const. overrideprotectedvirtual . If this pdf is operated with a fixed set of observables, return the subset of the fixed observables that are actual dependents of the external input p.d.f. ; If this p.d.f is operated without a fixed set of cache observables, return the actual observables of the external input p.d.f given the choice of observables defined in nset ; Implements RooAbsCachedPdf.; Definition at line 129 of file RooCachedPdf.cxx. ◆ actualParameters(). RooFit::OwningPtr< RooArgSet > RooCachedPdf::actualParameters ; (; const RooArgSet & ; nset); const. overrideprotectedvirtual . If this p.d.f is operated with a fixed set of observables, return all variables of the external input p.d.f that are not one of the cache observables. ; If this p.d.f is operated in automatic mode, return the parameters of the external input p.d.f ; Implements RooAbsCachedPdf.; Definition at line 146 of file RooCachedPdf.cxx. ◆ Class(). static TClass * RooCachedPdf::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooCachedPdf::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooCachedPdf::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 51 of file RooCachedPdf.h. ◆ clone(). TObject * RooCachedPdf::clone ; (; const char * ; newname); const. inlineoverridevirtual . Implements RooAbsArg.; Definition at line 26 of file RooCachedPdf.h. ◆ DeclFileName(). static const char * RooCachedPdf::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 51 of file RooCachedPdf.h. ◆ evaluate(). double RooCachedPdf::evaluate ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCachedPdf.html:79794,cache,cache,79794,doc/master/classRooCachedPdf.html,https://root.cern,https://root.cern/doc/master/classRooCachedPdf.html,1,['cache'],['cache']
Performance,"oChi2Var(const char* name, const char* title, RooAbsReal& func, RooDataHist& data, const RooArgSet& projDeps, RooChi2Var::FuncMode funcMode, const char* rangeName = 0, const char* addCoefRangeName = 0, Int_t nCPU = 1, RooFit::MPSplit interleave = RooFit::BulkPartition, Bool_t verbose = kTRUE, Bool_t splitCutRange = kTRUE, RooAbsData::ErrorType = RooDataHist::SumW2); Constructor of a chi2 for given p.d.f. with respect given binned; dataset taking the observables specified in projDeps as projected; observables. If cutRange is specified the calculation of the chi2; is restricted to that named range. If addCoefRange is specified,; the interpretation of fractions for all component RooAddPdfs that; do not have a frozen range interpretation is set to chosen range; name. If nCPU is greater than one the chi^2 calculation is; paralellized over the specified number of processors. If; interleave is true the partitioning of event over processors; follows a (i % n == i_set) strategy rather than a bulk; partitioning strategy which may result in unequal load balancing; in binned datasets with many (adjacent) zero bins. If; splitCutRange is true the cutRange is used to construct an; individual cutRange for each RooSimultaneous index category state; name cutRange_{indexStateName}. RooChi2Var(const RooChi2Var& other, const char* name = 0); Copy constructor. ~RooChi2Var(); Destructor. Double_t evaluatePartition(Int_t firstEvent, Int_t lastEvent, Int_t stepSize) const; Calculate chi^2 in partition from firstEvent to lastEvent using given stepSize. TObject* clone(const char* newname) const; { return new RooChi2Var(*this,newname); }. RooAbsTestStatistic* create(const char* name, const char* title, RooAbsReal& pdf, RooAbsData& dhist, const RooArgSet& projDeps, const char* rangeName = 0, const char* addCoefRangeName = 0, Int_t nCPU = 1, RooFit::MPSplit interleave = RooFit::BulkPartition, Bool_t verbose = kTRUE, Bool_t splitCutRange = kTRUE, Bool_t = kFALSE); Virtual constructor. Double_t def",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooChi2Var.html:47377,load,load,47377,root/html534/RooChi2Var.html,https://root.cern,https://root.cern/root/html534/RooChi2Var.html,2,['load'],['load']
Performance,"oDefinition;; 163 ; 164 VarTransformHandler* handler = new VarTransformHandler(this);; 165 // variance threshold variable transformation; 166 if (trName == ""VT"") {; 167 ; 168 // find threshold value from given input; 169 Double_t threshold = 0.0;; 170 if (!trOptions.IsFloat()){; 171 Log() << kFATAL << "" VT transformation must be passed a floating threshold value"" << Endl;; 172 delete handler;; 173 return this;; 174 }; 175 else; 176 threshold = trOptions.Atof();; 177 TMVA::DataLoader *transformedLoader = handler->VarianceThreshold(threshold);; 178 delete handler;; 179 return transformedLoader;; 180 }; 181 else {; 182 delete handler;; 183 Log() << kFATAL << ""Incorrect transformation string provided, please check"" << Endl;; 184 }; 185 Log() << kINFO << ""No transformation applied, returning original loader"" << Endl;; 186 return this;; 187}; 188 ; 189////////////////////////////////////////////////////////////////////////////////; 190// the next functions are to assign events directly; 191 ; 192////////////////////////////////////////////////////////////////////////////////; 193/// create the data assignment tree (for event-wise data assignment by user); 194 ; 195TTree* TMVA::DataLoader::CreateEventAssignTrees( const TString& name ); 196{; 197 TTree * assignTree = new TTree( name, name );; 198 assignTree->SetDirectory(nullptr);; 199 assignTree->Branch( ""type"", &fATreeType, ""ATreeType/I"" );; 200 assignTree->Branch( ""weight"", &fATreeWeight, ""ATreeWeight/F"" );; 201 ; 202 std::vector<VariableInfo>& vars = DefaultDataSetInfo().GetVariableInfos();; 203 std::vector<VariableInfo>& tgts = DefaultDataSetInfo().GetTargetInfos();; 204 std::vector<VariableInfo>& spec = DefaultDataSetInfo().GetSpectatorInfos();; 205 ; 206 if (fATreeEvent.size()==0) fATreeEvent.resize(vars.size()+tgts.size()+spec.size());; 207 // add variables; 208 for (UInt_t ivar=0; ivar<vars.size(); ivar++) {; 209 TString vname = vars[ivar].GetExpression();; 210 assignTree->Branch( vname, &fATreeEvent[ivar], vname + ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/DataLoader_8cxx_source.html:6654,load,loader,6654,doc/master/DataLoader_8cxx_source.html,https://root.cern,https://root.cern/doc/master/DataLoader_8cxx_source.html,1,['load'],['loader']
Performance,"oFit Tutorials. Detailed Description; Organization and simultaneous fits: working with named parameter sets and parameter snapshots in workspaces . ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooGaussian.h""; #include ""RooChebychev.h""; #include ""RooAddPdf.h""; #include ""RooWorkspace.h""; #include ""RooPlot.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""TFile.h""; #include ""TH1.h""; ; using namespace RooFit;; ; void fillWorkspace(RooWorkspace &w);; ; void rf510_wsnamedsets(); {; // C r e a t e m o d e l a n d d a t a s e t; // -----------------------------------------------; ; RooWorkspace *w = new RooWorkspace(""w"");; fillWorkspace(*w);; ; // Exploit convention encoded in named set ""parameters"" and ""observables""; // to use workspace contents w/o need for introspected; RooAbsPdf *model = w->pdf(""model"");; ; // Generate data from pdf in given observables; std::unique_ptr<RooDataSet> data{model->generate(*w->set(""observables""), 1000)};; ; // Fit model to data; model->fitTo(*data, PrintLevel(-1));; ; // Plot fitted model and data on frame of first (only) observable; RooPlot *frame = ((RooRealVar *)w->set(""observables"")->first())->frame();; data->plotOn(frame);; model->plotOn(frame);; ; // Overlay plot with model with reference parameters as stored in snapshots; w->loadSnapshot(""reference_fit"");; model->plotOn(frame, LineColor(kRed));; w->loadSnapshot(""reference_fit_bkgonly"");; model->plotOn(frame, LineColor(kRed), LineStyle(kDashed));; ; // Draw the frame on the canvas; new TCanvas(""rf510_wsnamedsets"", ""rf503_wsnamedsets"", 600, 600);; gPad->SetLeftMargin(0.15);; frame->GetYaxis()->SetTitleOffset(1.4);; frame->Draw();; ; // Print workspace contents; w->Print();; ; // Workspace will remain in memory after macro finishes; gDirectory->Add(w);; }; ; void fillWorkspace(RooWorkspace &w); {; // C r e a t e m o d e l; // -----------------------; ; // Declare observable x; RooRealVar x(""x"", ""x"", 0, 10);; ; // Create two Gaussian PDFs g1(x,mean1,sigma) anf g2(x,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf510__wsnamedsets_8C.html:1491,load,loadSnapshot,1491,doc/master/rf510__wsnamedsets_8C.html,https://root.cern,https://root.cern/doc/master/rf510__wsnamedsets_8C.html,2,['load'],['loadSnapshot']
Performance,"oFlush. This is used when doing a fast cloning (by TTreeCloner).; See also fAutoFlush and fAutoSave if needed. void KeepCircular(); Keep a maximum of fMaxEntries in memory. Int_t LoadBaskets(Long64_t maxmemory = 2000000000); Read in memory all baskets from all branches up to the limit of maxmemory bytes. If maxmemory is non null and positive SetMaxVirtualSize is called; with this value. Default for maxmemory is 2000000000 (2 Gigabytes).; The function returns the total number of baskets read into memory; if negative an error occurred while loading the branches.; This method may be called to force branch baskets in memory; when random access to branch entries is required.; If random access to only a few branches is required, you should; call directly TBranch::LoadBaskets. Long64_t LoadTree(Long64_t entry); Set current entry. Returns -2 if entry does not exist (just as TChain::LoadTree()). Note: This function is overloaded in TChain. Long64_t LoadTreeFriend(Long64_t entry, TTree* T); Load entry on behalf of our master tree, we may use an index. Called by LoadTree() when the masterTree looks for the entry; number in a friend tree (us) corresponding to the passed entry; number in the masterTree. If we have no index, our entry number and the masterTree entry; number are the same. If we *do* have an index, we must find the (major, minor) value pair; in masterTree to locate our corresponding entry. Int_t MakeClass(const char* classname = 0, Option_t* option = """"); Generate a skeleton analysis class for this tree. The following files are produced: classname.h and classname.C.; If classname is 0, classname will be called ""nameoftree"". The generated code in classname.h includes the following:; - Identification of the original tree and the input file name.; - Definition of an analysis class (data members and member functions).; - The following member functions:; - constructor (by default opening the tree file),; - GetEntry(Long64_t entry),; - Init(TTree* tree) to initialize a ne",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTree.html:100851,Load,LoadTreeFriend,100851,root/html532/TTree.html,https://root.cern,https://root.cern/root/html532/TTree.html,8,['Load'],"['Load', 'LoadTreeFriend']"
Performance,"oIdentityDefinition TGeoMatrix.h:537; The objects referencing a volume and a transformation are called NODES and their creation is fully handled by the modeller. They represent the link elements in the hierarchy of volumes. Nodes are unique and distinct geometrical objects ONLY from their container point of view. Since volumes can be replicated in the geometry, the same node may be found on different branches.; In order to provide navigation features, volumes have to be able to find the proper container of any point defined in the local reference frame. This can be the volume itself, one of its positioned daughter volumes or none if the point is actually outside. On the other hand, volumes have to provide also other navigation methods such as finding the distances to its shape boundaries or which daughter will be crossed first. The implementation of these features is done at shape level, but the local mother-daughters management is handled by volumes. These build additional optimization structures upon geometry closure. In order to have navigation features properly working one has to follow some rules for building a valid geometry. The daughter volume(s) must not extrude the mother shape. They are allowed however to have a common boundaries.; The volumes positioned in the same container must not overlap with each other. They may touch on one boundaries or shape vertex. The daughter nodes of a volume can be also removed or replaced with other nodes:; void RemoveNode(TGeoNode* node); TGeoNode*ReplaceNode(TGeoNode* nodeorig, TGeoShape* newshape = 0,; TGeoMatrix* newpos = 0, TGeoMedium* newmed = 0); TGeoNodeA node represent a volume positioned inside another.They store links to both volumes and to the TGeoM...Definition TGeoNode.h:39; TGeoShapeBase abstract class for all shapes.Definition TGeoShape.h:25; The last method allows replacing an existing daughter of a volume with another one. Providing only the node to be replaced will just create a new volume for the node bu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:29927,optimiz,optimization,29927,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['optimiz'],['optimization']
Performance,"oLagrangianMorphFunc.h:86; RooLagrangianMorphFunc::Config::fileNamestd::string fileNameDefinition RooLagrangianMorphFunc.h:88; RooLagrangianMorphFunc::Config::folderNamesstd::vector< std::string > folderNamesDefinition RooLagrangianMorphFunc.h:91; ; [#0] PROGRESS:InputArguments -- initializing physics inputs from file /home/sftnight/build/workspace/root-makedoc-master/rootspi/rdoc/src/master.build/tutorials/roofit/input_histos_rf_lagrangianmorph.root with object name(s) 'pTV'; [#0] PROGRESS:Caching -- creating cache from getCache function for 0x7ffd3a48dc68; [#0] PROGRESS:Caching -- current storage has size 10; [#0] PROGRESS:ObjectHandling -- observable: pTV; [#0] PROGRESS:ObjectHandling -- binWidth: binWidth_pTV; [#1] INFO:DataHandling -- RooDataHist::adjustBinning(pseudo_dh): fit range of variable pTV expanded to nearest bin boundaries: [10,600] --> [0,600]; [#0] PROGRESS:Caching -- creating cache from getCache function for 0x5559dfeef700; [#0] PROGRESS:Caching -- current storage has size 10; [#0] PROGRESS:ObjectHandling -- observable: pTV; [#0] PROGRESS:ObjectHandling -- binWidth: binWidth_pTV; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(wrap_pdf_over_wrap_pdf_Int[pTV]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_wrap_pdf_over_wrap_pdf_Int[pTV]_pseudo_dh) Summation contains a RooNLLVar, using its error level; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=0 cHl3=0 cHq3=-0.0202918; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.0376648, denominator=wrap_pdf_Int[pTV]=10358.6; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.0376648,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf712__lagrangianmorphfit_8C.html:7295,cache,cache,7295,doc/master/rf712__lagrangianmorphfit_8C.html,https://root.cern,https://root.cern/doc/master/rf712__lagrangianmorphfit_8C.html,2,['cache'],['cache']
Performance,"oLegoGL(); virtual~TEveCaloLegoGL(); voidTGLLogicalShape::AddRef(TGLPhysicalShape* phys) const; virtual Bool_tAlwaysSecondarySelect() const; const TGLBoundingBox&TGLLogicalShape::BoundingBox() const; static TClass*Class(); voidTGLLogicalShape::DestroyPhysicals(); virtual voidDirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidDLCacheDrop(); virtual voidDLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidDrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* ps, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*TGLObject::GetGLRenderer(TClass* isa); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tTGLObject::KeepDuringSmartRefresh() const; virtual voidProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; UInt_tTGLLogicalShape::Ref() const; virtual voidSetBBox(); Bool_tTGLLogicalShape::SetDLCache(Bool_t cached); virtual Bool_tSetModel(TObject* obj, Option_t* opt = 0); virtual Bool_tTGLObject::ShouldDLCache(const TGLRnrCtx& rnrCtx) const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidTGLLogicalShape::StrongRef(Bool_t strong) const; voidTGLLogicalShape::SubRef(TGLPhysicalShape* phys) const; virtual TGLLogicalShape::ELODAxesTGLLogicalShape::SupportedLODAxes() const; virtual Bool_tSupportsSecondarySelect() const; UInt_tTGLLogicalShape::UnrefFirstPhysical(); virtual voidTGLObject::UpdateBoundingBox(); voidTGLLogicalShape::UpdateBoundingBoxesOfPhysicals().",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEveCaloLegoGL.html:1759,cache,cached,1759,root/html528/TEveCaloLegoGL.html,https://root.cern,https://root.cern/root/html528/TEveCaloLegoGL.html,4,['cache'],['cached']
Performance,"oLoading is currently enabled. ; Definition at line 7554 of file TCling.cxx. ◆ IsErrorMessagesEnabled(). Bool_t TCling::IsErrorMessagesEnabled ; (; ); const. finalvirtual . If error messages are disabled, the interpreter should suppress its failures and warning messages from stdout. ; Implements TInterpreter.; Definition at line 7342 of file TCling.cxx. ◆ IsFloatingType(). bool TCling::IsFloatingType ; (; const void * ; QualTypePtr); const. virtual . Reimplemented from TInterpreter.; Definition at line 9571 of file TCling.cxx. ◆ IsIntegerType(). bool TCling::IsIntegerType ; (; const void * ; QualTypePtr); const. virtual . Reimplemented from TInterpreter.; Definition at line 9547 of file TCling.cxx. ◆ IsLibraryLoaded(). Bool_t TCling::IsLibraryLoaded ; (; const char * ; libname); const. finalvirtual . Implements TInterpreter.; Definition at line 3138 of file TCling.cxx. ◆ IsLoaded(). Bool_t TCling::IsLoaded ; (; const char * ; filename); const. finalvirtual . Return true if the file has already been loaded by cint. ; We will try in this order: actual filename filename as a path relative to the include path the shared library path ; Implements TInterpreter.; Definition at line 3172 of file TCling.cxx. ◆ IsPointerType(). bool TCling::IsPointerType ; (; const void * ; QualTypePtr); const. virtual . Reimplemented from TInterpreter.; Definition at line 9579 of file TCling.cxx. ◆ IsProcessLineLocked(). Bool_t TCling::IsProcessLineLocked ; (; ); const. inlinefinalvirtual . Implements TInterpreter.; Definition at line 317 of file TCling.h. ◆ IsSameType(). bool TCling::IsSameType ; (; const void * ; QualTypePtr1, . const void * ; QualTypePtr2 . ); const. virtual . Reimplemented from TInterpreter.; Definition at line 9538 of file TCling.cxx. ◆ IsSignedIntegerType(). bool TCling::IsSignedIntegerType ; (; const void * ; QualTypePtr); const. virtual . Reimplemented from TInterpreter.; Definition at line 9555 of file TCling.cxx. ◆ IsUnsignedIntegerType(). bool TCling::IsUnsignedInt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTCling.html:110540,load,loaded,110540,doc/master/classTCling.html,https://root.cern,https://root.cern/doc/master/classTCling.html,1,['load'],['loaded']
Performance,"oMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); Int_tminDimNormValueCaching() const; virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tmustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const char*normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsPdf.html:24817,optimiz,optimizeCacheMode,24817,root/html528/RooAbsPdf.html,https://root.cern,https://root.cern/root/html528/RooAbsPdf.html,2,['optimiz'],['optimizeCacheMode']
Performance,"oNormSetCache&); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; protected:. ULong_t_max!; RooNameSet_name1!; RooNameSet_name2!; ULong_t_next!; RooNormSetCache::PairIdxMapType_pairToIdx!; RooNormSetCache::PairVectType_pairs!; TNamed*_set2RangeName!. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooNormSetCache(ULong_t max = 32). ~RooNormSetCache(); Destructor. void clear(); Clear contents. void add(const RooArgSet* set1, const RooArgSet* set2 = 0); Add given pair of RooArgSet pointers to our store. Bool_t autoCache(const RooAbsArg* self, const RooArgSet* set1, const RooArgSet* set2 = 0, const TNamed* set2RangeName = 0, Bool_t autoRefill = kTRUE); If RooArgSets set1 and set2 or sets with similar contents have; been seen by this cache manager before return kFALSE If not,; return kTRUE. If sets have not been seen and doRefill is true,; update cache reference to current input sets. RooNormSetCache(ULong_t max = 32). Int_t index(const RooArgSet* set1, const RooArgSet* set2 = 0, const TNamed* set2RangeName = 0); Match range name first. Bool_t contains(const RooArgSet* set1, const RooArgSet* set2 = 0, const TNamed* set2RangeName = 0); { return (index(set1,set2,set2RangeName) >= 0); }. Bool_t containsSet1(const RooArgSet* set1). const RooArgSet* lastSet1() const; { return _pairs.empty()?0:_pairs.back().first; }. const RooArgSet* lastSet2() const; { return _pairs.empty()?0:_pairs.back().second; }. const RooNameSet& nameSet1() const; { return _name1; }. const RooNameSet& nameSet2() const; { return _name2; }. Int_t entries() const; { return _pairs.size(); }. void initialize(const RooNormSetCache& other); { clear(); *this = other; }. » Last changed: Tue Jun 2 15:32:35 2015 » Last generated: 2015-06-02 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in gener",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooNormSetCache.html:2923,cache,cache,2923,root/html604/RooNormSetCache.html,https://root.cern,https://root.cern/root/html604/RooNormSetCache.html,2,['cache'],['cache']
Performance,"oNormSetCache&); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; protected:. ULong_t_max!; RooNameSet_name1!; RooNameSet_name2!; ULong_t_next!; RooNormSetCache::PairIdxMapType_pairToIdx!; RooNormSetCache::PairVectType_pairs!; TNamed*_set2RangeName!. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooNormSetCache(ULong_t max = 32). ~RooNormSetCache(); Destructor. void clear(); Clear contents. void add(const RooArgSet* set1, const RooArgSet* set2 = 0); Add given pair of RooArgSet pointers to our store. Bool_t autoCache(const RooAbsArg* self, const RooArgSet* set1, const RooArgSet* set2 = 0, const TNamed* set2RangeName = 0, Bool_t autoRefill = kTRUE); If RooArgSets set1 and set2 or sets with similar contents have; been seen by this cache manager before return kFALSE If not,; return kTRUE. If sets have not been seen and doRefill is true,; update cache reference to current input sets. RooNormSetCache(ULong_t max = 32). Int_t index(const RooArgSet* set1, const RooArgSet* set2 = 0, const TNamed* set2RangeName = 0); Match range name first. Bool_t contains(const RooArgSet* set1, const RooArgSet* set2 = 0, const TNamed* set2RangeName = 0); { return (index(set1,set2,set2RangeName) >= 0); }. Bool_t containsSet1(const RooArgSet* set1). const RooArgSet* lastSet1() const; { return _pairs.empty()?0:_pairs.back().first; }. const RooArgSet* lastSet2() const; { return _pairs.empty()?0:_pairs.back().second; }. const RooNameSet& nameSet1() const; { return _name1; }. const RooNameSet& nameSet2() const; { return _name2; }. Int_t entries() const; { return _pairs.size(); }. void initialize(const RooNormSetCache& other); { clear(); *this = other; }. » Last changed: Tue Jun 30 14:34:28 2015 » Last generated: 2015-06-30 14:34; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in gene",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooNormSetCache.html:2923,cache,cache,2923,root/html602/RooNormSetCache.html,https://root.cern,https://root.cern/root/html602/RooNormSetCache.html,2,['cache'],['cache']
Performance,"oObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_t_relParam; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooHistConstraint.html:42589,cache,cache,42589,root/html534/RooHistConstraint.html,https://root.cern,https://root.cern/root/html534/RooHistConstraint.html,2,['cache'],['cache']
Performance,"oPainter.h:49; TGeoPainter::Lockvoid Lock(Bool_t flag=kTRUE)Definition TGeoPainter.h:142; TGeoPainter::SetNsegmentsvoid SetNsegments(Int_t nseg=20) overrideSet number of segments to approximate circles.Definition TGeoPainter.cxx:1992; TGeoPainter::CheckBoundaryReferencevoid CheckBoundaryReference(Int_t icheck=-1) overrideCheck the boundary errors reference file created by CheckBoundaryErrors method.Definition TGeoPainter.cxx:210; TGeoPainter::AddTrackPointvoid AddTrackPoint(Double_t *point, Double_t *box, Bool_t reset=kFALSE) overrideAverage center of view of all painted tracklets and compute view box.Definition TGeoPainter.cxx:138; TGeoPainter::GrabFocusvoid GrabFocus(Int_t nfr=0, Double_t dlong=0, Double_t dlat=0, Double_t dpsi=0) overrideMove focus to current volume.Definition TGeoPainter.cxx:1206; TGeoPainter::DrawOverlapvoid DrawOverlap(void *ovlp, Option_t *option="""") overrideDraw an overlap.Definition TGeoPainter.cxx:913; TGeoPainter::SetVisLevelvoid SetVisLevel(Int_t level=3) overrideSet default level down to which visualization is performed.Definition TGeoPainter.cxx:2024; TGeoPainter::AddSize3Dvoid AddSize3D(Int_t numpoints, Int_t numsegs, Int_t numpolys) overrideAdd numpoints, numsegs, numpolys to the global 3D size.Definition TGeoPainter.cxx:121; TGeoPainter::fCheckedNodeTGeoNode * fCheckedNodeDefinition TGeoPainter.h:59; TGeoPainter::PaintPhysicalNodevoid PaintPhysicalNode(TGeoPhysicalNode *node, Option_t *option="""")Paints a physical node associated with a path.Definition TGeoPainter.cxx:1609; TGeoPainter::fNVisNodesInt_t fNVisNodesDefinition TGeoPainter.h:48; TGeoPainter::fExplodedViewInt_t fExplodedViewDefinition TGeoPainter.h:51; TGeoPainter::GetVolumeInfoconst char * GetVolumeInfo(const TGeoVolume *volume, Int_t px, Int_t py) const overrideGet some info about the current selected volume.Definition TGeoPainter.cxx:1151; TGeoPainter::SetClippingShapevoid SetClippingShape(TGeoShape *shape) overrideDefinition TGeoPainter.h:160; TGeoPainter::DrawCurrentP",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoPainter_8h_source.html:24029,perform,performed,24029,doc/master/TGeoPainter_8h_source.html,https://root.cern,https://root.cern/doc/master/TGeoPainter_8h_source.html,1,['perform'],['performed']
Performance,"oPrintable::kTreeStructure; static RooPrintable::ContentsOptionRooPrintable::kValue; static RooPrintable::StyleOptionRooPrintable::kVerbose; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. RooArgSet_actual! Set of actual dependents; Bool_t_compiledFlag set if formula is compiled; Bool_t_isOKIs internal state OK?; RooLinkedList_labelListList of label names for category objects; static Int_tRooPrintable::_nameLength; RooArgSet*_nset; RooLinkedList_origList! Original list of dependents; vector<Bool_t>_useIsCat! Is given slot in _useList a category?; RooLinkedList_useList! List of actual dependents; TBitsTFormula::fAlreadyFound! cache for information; Double_t*TFormula::fConst[fNconst] Array of fNconst formula constants; TString*TFormula::fExpr[fNoper] List of expressions; TString*TFormula::fExprOptimized![fNOperOptimized] List of expressions; TObjArrayTFormula::fFunctionsArray of function calls to make; TObjArrayTFormula::fLinearPartsLinear parts if the formula is linear (contains '|' or ""++""); Int_tTFormula::fNOperOptimized!Number of operators after optimization; TStringTNamed::fNameobject identifier; TString*TFormula::fNames[fNpar] Array of parameter names; Int_tTFormula::fNconstNumber of constants; Int_tTFormula::fNdimDimension of function (1=1-Dim, 2=2-Dim,etc); Int_tTFormula::fNoperNumber of operators; Int_tTFormula::fNparNumber of parameters; Int_tTFormula::fNstringNumber of different constants character strings; Int_tTFormula::fNumberformula number identifier; Int_tTFormula::fNvalNumber of different variables in expression; TOperOffset*TFormula::fOperOffset![fNOperOptimized] Offsets of operrands; Int_t*TFormula::fOperOptimized![fNOperOptimized] List of operators. (See documentation for changes made at version 7); TFormula::TFuncGTFormula::fOptimal!pointer to optimal function; Double_t*TFormula::fParams[fNpar] Array of fNpar parameters; TFormulaPrimitive**TFormula::fPredefined![fNPar] predefined function; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooFormula.html:12980,cache,cache,12980,root/html602/RooFormula.html,https://root.cern,https://root.cern/root/html602/RooFormula.html,4,"['cache', 'optimiz']","['cache', 'optimization']"
Performance,"oPrintable; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static std::ostream & defaultPrintStream (std::ostream *os=nullptr);  Return a reference to the current default stream to use in Print(). ;  ; static void nameFieldLength (Int_t newLen);  Set length of field reserved from printing name of RooAbsArgs in multi-line collection printing to given amount. ;  . Protected Member Functions; void findShape (const std::vector< double > &x) const;  ; CacheElem * getCache (const RooArgSet *nset) const;  ; void initialize ();  ; int sij (const int &i, const int &j) const;  ; RooAbsReal * sumFunc (const RooArgSet *nset);  ;  Protected Member Functions inherited from RooAbsReal; void attachToTree (TTree &t, Int_t bufSize=32000) override;  Attach object to a branch of given TTree. ;  ; void attachToVStore (RooVectorDataStore &vstore) override;  ; void copyCache (const RooAbsArg *source, bool valueOnly=false, bool setValDirty=true) override;  Copy the cached value of another RooAbsArg to our cache. ;  ; RooFit::OwningPtr< RooAbsReal > createIntObj (const RooArgSet &iset, const RooArgSet *nset, const RooNumIntConfig *cfg, const char *rangeName) const;  Internal utility function for createIntegral() that creates the actual integral object. ;  ; void fillTreeBranch (TTree &t) override;  Fill the tree branch that associated with this object with its current value. ;  ; void findInnerMostIntegration (const RooArgSet &allObs, RooArgSet &innerObs, const char *rangeName) const;  Utility function for createIntObj() that aids in the construct of recursive integrals over functions with multiple observables with parameterized ranges. ;  ; TString integralNameSuffix (const RooArgSet &iset, const RooArgSet *nset=nullptr, const char *rangeName=nullptr, bool omitEmpty=false) const;  Construct string with unique suffix name to give to integral object that encodes integrated observables, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooMomentMorphFuncND.html:50813,cache,cached,50813,doc/master/classRooMomentMorphFuncND.html,https://root.cern,https://root.cern/doc/master/classRooMomentMorphFuncND.html,2,['cache'],"['cache', 'cached']"
Performance,"oProdPdf, RooProfileLL, RooFormulaVar, RooGenericPdf, RooNumConvolution, RooRealIntegral, RooResolutionModel, RooAbsOptTestStatistic, RooAbsTestStatistic, RooAbsPdf, RooAbsReal, and RooProjectedPdf.; Definition at line 1313 of file RooAbsArg.cxx. ◆ registerCache(). void RooAbsArg::registerCache ; (; RooAbsCache & ; cache). Register RooAbsCache with this object. ; This function is called by RooAbsCache constructors for objects that are a datamember of this RooAbsArg. By registering itself the RooAbsArg is aware of all its cache data members and will forward server change and cache mode change calls to the cache objects, which in turn can forward them their contents ; Definition at line 2117 of file RooAbsArg.cxx. ◆ registerProxy() [1/3]. void RooAbsArg::registerProxy ; (; RooArgProxy & ; proxy). protected . Register an RooArgProxy in the proxy list. ; This function is called by owned proxies upon creation. After registration, this arg will forward pointer changes from serverRedirects and updates in cached normalization sets to the proxies immediately after they occur. The proxied argument is also added as value and/or shape server ; Definition at line 1329 of file RooAbsArg.cxx. ◆ registerProxy() [2/3]. void RooAbsArg::registerProxy ; (; RooListProxy & ; proxy). protected . Register an RooListProxy in the proxy list. ; This function is called by owned proxies upon creation. After registration, this arg will forward pointer changes from serverRedirects and updates in cached normalization sets to the proxies immediately after they occur. ; Definition at line 1408 of file RooAbsArg.cxx. ◆ registerProxy() [3/3]. void RooAbsArg::registerProxy ; (; RooSetProxy & ; proxy). protected . Register an RooSetProxy in the proxy list. ; This function is called by owned proxies upon creation. After registration, this arg will forward pointer changes from serverRedirects and updates in cached normalization sets to the proxies immediately after they occur. ; Definition at line 1373 of ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsArg.html:92628,cache,cached,92628,doc/master/classRooAbsArg.html,https://root.cern,https://root.cern/doc/master/classRooAbsArg.html,1,['cache'],['cached']
Performance,"oRealProxy_nllInput -log(L) function; RooSetProxy_obsParameters of profile likelihood; RooArgSet_obsAbsMinObservable values at absolute minimum; TIterator*_oiter! Iterator of profile likelihood output parameter(s); RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooSetProxy_parMarginialized parameters of likelihood; RooArgSet_paramAbsMinParameter values at absolute minimum; map<std::string,bool>_paramFixedParameter constant status at last time of use; TIterator*_piter! Iterator over profile likelihood parameters to be minimized ; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; Bool_t_startFromMinAlways start minimization for global minimum?; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooProfileLL.html:34215,cache,cache,34215,root/html532/RooProfileLL.html,https://root.cern,https://root.cern/root/html532/RooProfileLL.html,2,['cache'],['cache']
Performance,"oRealVar * _cvPdf {nullptr};  Convolution variable in PDFxTruth event. ;  ; std::unique_ptr< RooArgSet > _modelCloneSet;  Owner of resModel clone. ;  ; std::unique_ptr< RooAbsGenContext > _modelGen;  Resolution model generator context. ;  ; std::unique_ptr< RooArgSet > _modelVars;  Holder of resModel event. ;  ; std::unique_ptr< RooArgSet > _modelVarsOwned;  Owning version of modelVars ;. ;  ; std::unique_ptr< RooArgSet > _pdfCloneSet;  Owner of PDF clone. ;  ; std::unique_ptr< RooAbsGenContext > _pdfGen;  Physics model generator context. ;  ; std::unique_ptr< RooArgSet > _pdfVars;  Holder of PDF x truth event. ;  ; std::unique_ptr< RooArgSet > _pdfVarsOwned;  Owning version of pdfVars ;. ;  ;  Protected Attributes inherited from RooAbsGenContext; UInt_t _expectedEvents;  Number of expected events from extended p.d.f. ;  ; RooAbsPdf::ExtendMode _extendMode;  Extended mode capabilities of p.d.f. ;  ; RooDataSet * _genData = nullptr;  ! Data being generated ;  ; bool _isValid;  Is context in valid state? ;  ; Int_t _nextProtoIndex;  Next prototype event to load according to LUT. ;  ; TString _normRange;  Normalization range of pdf. ;  ; std::vector< Int_t > _protoOrder;  LUT with traversal order of prototype data. ;  ; const RooDataSet * _prototype;  Pointer to prototype dataset. ;  ; RooArgSet _protoVars;  Prototype observables. ;  ; RooArgSet _theEvent;  Pointer to observable event being generated. ;  ; bool _verbose;  Verbose messaging? ;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Additional Inherited Members;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 ))",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooConvGenContext.html:16776,load,load,16776,doc/master/classRooConvGenContext.html,https://root.cern,https://root.cern/doc/master/classRooConvGenContext.html,1,['load'],['load']
Performance,"oRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual voidRooResolutionModel::normLeafServerList(RooArgSet& list) const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAddModel.html:24711,optimiz,optimizeCacheMode,24711,root/html534/RooAddModel.html,https://root.cern,https://root.cern/root/html534/RooAddModel.html,16,['optimiz'],['optimizeCacheMode']
Performance,"oRealVar::a1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::bkgfrac; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooAddPdf::sig; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooGaussian::sig1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::mean; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sigma1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sig1frac; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooGaussian::sig2; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sigma2; ; RooWorkspace(w) w contents; ; variables; ---------; (a0,a1,bkgfrac,mean,sig1frac,sigma1,sigma2,x); ; p.d.f.s; -------; RooChebychev::bkg[ x=x coefList=(a0,a1) ] = 1; RooAddPdf::model[ bkgfrac * bkg + [%] * sig ] = 1/1; RooAddPdf::sig[ sig1frac * sig1 + [%] * sig2 ] = 1/1; RooGaussian::sig1[ x=x mean=mean sigma=sigma1 ] = 1; RooGaussian::sig2[ x=x mean=mean sigma=sigma2 ] = 1; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) directly selected PDF components: (bkg); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) indirectly selected PDF components: (); DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C++ version) ; Definition in file rf509_wsinteractive.py. tutorialsroofitrf509_wsinteractive.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf509__wsinteractive_8py.html:5376,optimiz,optimization,5376,doc/master/rf509__wsinteractive_8py.html,https://root.cern,https://root.cern/doc/master/rf509__wsinteractive_8py.html,2,['optimiz'],['optimization']
Performance,oRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooRealProxy_funcInput function; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; RooRealProxy_ifInt(F(x))dx ;; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; RooRealProxy_ixfInt(X*F(X))dx ;; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; RooRealProxy_meanMean (if calculated for central moment); static Int_tRooPrintable::_nameLength; RooSetProxy_nsetNormalization set (optional); RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Int_t_orderMoment order; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooMoment.html:31026,cache,cache,31026,root/html526/RooMoment.html,https://root.cern,https://root.cern/root/html526/RooMoment.html,2,['cache'],['cache']
Performance,oRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooRealProxy_funcInput function; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; RooRealProxy_ifInt(F(x))dx ;; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; RooRealProxy_ixfInt(X*F(X))dx ;; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; RooRealProxy_meanMean (if calculated for central moment); static Int_tRooPrintable::_nameLength; RooSetProxy_nsetNormalization set (optional); RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Int_t_orderMoment order; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_sha,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooMoment.html:31693,cache,cache,31693,root/html530/RooMoment.html,https://root.cern,https://root.cern/root/html530/RooMoment.html,1,['cache'],['cache']
Performance,oRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooRealProxy_funcInput function; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; RooRealProxy_ifInt(F(x))dx ;; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; RooRealProxy_ixfInt(X*F(X))dx ;; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; RooRealProxy_meanMean (if calculated for central moment); static Int_tRooPrintable::_nameLength; RooSetProxy_nsetNormalization set (optional); RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Int_t_orderMoment order; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooMoment.html:32068,cache,cache,32068,root/html532/RooMoment.html,https://root.cern,https://root.cern/root/html532/RooMoment.html,2,['cache'],['cache']
Performance,"oRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; RooSetProxy_facListSet of observables on which function does not depends, which are integrated nevertheless; TIterator*_facListIter! Iterator over factorizing observables; RooArgSet_facListOwnedOwned components in _facList; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooArgSet*_funcNormSetOptional normalization set passed to function; RooRealProxy_functionFunction being integration; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; RooNumIntConfig*_iconfig; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; RooSetProxy_intListSet of continuous observables over which is integrated numerically; RooRealIntegral::IntOperMode_intOperModeintegration operation mode; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; RooSetProxy_jacListSet of lvalue observables over which is analytically integration that have a non-unit Jacobian; TIterator*_jacListIter! Iterator over lvalue observables with Jacobian; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_t_mode; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooRealIntegral.html:33007,cache,cache,33007,root/html532/RooRealIntegral.html,https://root.cern,https://root.cern/root/html532/RooRealIntegral.html,2,['cache'],['cache']
Performance,"oStats::ModelConfig&); voidSetNBins(Int_t bins); virtual voidSetNuisanceParameters(const RooArgSet&); voidSetParameterPointsToTest(RooAbsData& pointsToTest); virtual voidSetParameters(const RooArgSet&); virtual voidSetPdf(RooAbsPdf&); voidSetPOIPointsToTest(RooAbsData& poiToTest); virtual voidSetTestSize(Double_t size); virtual voidShowMembers(TMemberInspector& insp); virtual Double_tSize() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidUseAdaptiveSampling(bool flag = true). private:. voidCreateParameterPoints() const; voidCreateTestStatSampler() const. Data Members; private:. Bool_tfAdaptiveSamplingcontrols use of adaptive sampling algorithm; Double_tfAdditionalNToysFactorgive user ability to ask for more toys; RooStats::ConfidenceBelt*fConfBelt; Bool_tfCreateBeltcontrols use if ConfidenceBelt should be saved to a TFile; RooAbsData&fDatadata set ; Bool_tfDoProfileConstructioninstead of full construction over nuisance parametrs, do profile; Bool_tfFluctuateDatatell ToyMCSampler to fluctuate number of entries in dataset; RooStats::ModelConfig&fModel; Int_tfNbinsnumber of samples per variable; RooAbsData*fPOIToTestvalue of POI points to perform the construction; RooAbsData*fPointsToTestpoints to perform the construction; Bool_tfSaveBeltToFilecontrols use if ConfidenceBelt should be saved to a TFile; Double_tfSizesize of the test (eg. specified rate of Type I error); RooStats::ToyMCSampler*fTestStatSamplerthe test statistic sampler. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; FeldmanCousins(RooAbsData& data, RooStats::ModelConfig& model); standard constructor. ~FeldmanCousins(); destructor; if(fOwnsWorkspace && fWS) delete fWS;. void SetModel(const RooStats::ModelConfig& ); set the model. TestStatSampler* GetTestStatSampler() const. void CreateTestStatSampler() const; specify the Test Statistic and create a ToyMC test statistic sampler. void CreateParameterPoints() const; specify the paramet",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooStats__FeldmanCousins.html:3693,perform,perform,3693,root/html530/RooStats__FeldmanCousins.html,https://root.cern,https://root.cern/root/html530/RooStats__FeldmanCousins.html,6,['perform'],['perform']
Performance,"oTextTText * fHostInfoTextGraphics Text object with the fHostInfo data.Definition TTreePerfStats.h:74; TTreePerfStats::SetMissedvoid SetMissed(TBranch *b, size_t basketNumber) overrideDefinition TTreePerfStats.h:149; TTreePerfStats::fBytesReadExtraLong64_t fBytesReadExtraNumber of bytes (overhead) of the read-ahead cache.Definition TTreePerfStats.h:56; TTreePerfStats::UnzipEventvoid UnzipEvent(TObject *tree, Long64_t pos, Double_t start, Int_t complen, Int_t objlen) overrideRecord TTree unzip event.Definition TTreePerfStats.cxx:312; TTreePerfStats::SetCpuTimevirtual void SetCpuTime(Double_t cptime)Definition TTreePerfStats.h:131; TTreePerfStats::TTreePerfStatsTTreePerfStats()default constructor (used when reading an object only)Definition TTreePerfStats.cxx:107; TTreePerfStats::SetHostInfovirtual void SetHostInfo(const char *info)Definition TTreePerfStats.h:134; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; TVirtualPerfStatsProvides the interface for the PROOF internal performance measurement and event tracing.Definition TVirtualPerfStats.h:32; TVirtualPerfStats::EEventTypeEEventTypeDefinition TVirtualPerfStats.h:42; double; int; unsigned int; grTGraphErrors * grDefinition legend1.C:25; TTreePerfStats::BasketInfoDefinition TTreePerfStats.h:41; TTreePerfStats::BasketInfo::fMissedUInt_t fMissedNumber of times the basket was read directly from the file.Definition TTreePerfStats.h:45; TTreePerfStats::BasketInfo::fLoadedUInt_t fLoadedNumber of times the basket was put in the primary TTreeCache.Definition TTreePerfStats.h:43; TTreePerfStats::BasketInfo::fLoadedMissUInt_t fLoadedMissNumber of times the basket was put in the secondary cache.Definition TTreePerfStats.h:44; TTreePerfStats::BasketInfo::fUsedUInt_t fUsedNumber of times the basket was requested from the disk.Definition TTreePerfStats.h:42; Drawth1 Draw(). treetreeplayerincTTreePerfStats.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:05 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTreePerfStats_8h_source.html:22599,cache,cache,22599,doc/master/TTreePerfStats_8h_source.html,https://root.cern,https://root.cern/doc/master/TTreePerfStats_8h_source.html,1,['cache'],['cache']
Performance,"oTreeDataStore.cxx. ◆ weightError() [2/2]. double RooTreeDataStore::weightError ; (; RooAbsData::ErrorType ; etype = RooAbsData::Poisson); const. overridevirtual . Implements RooAbsDataStore.; Definition at line 615 of file RooTreeDataStore.cxx. ◆ weightVar(). RooRealVar * RooTreeDataStore::weightVar ; (; const RooArgSet & ; allVars, . const char * ; wgtName = nullptr . ). private . Utility function for constructors Return pointer to weight variable if it is defined. ; Definition at line 213 of file RooTreeDataStore.cxx. Friends And Related Symbol Documentation. ◆ RooVectorDataStore. friend class RooVectorDataStore. friend . Definition at line 143 of file RooTreeDataStore.h. Member Data Documentation. ◆ _attachedBuffers. RooArgSet RooTreeDataStore::_attachedBuffers. private . ! Currently attached buffers (if different from _varsww) ; Definition at line 179 of file RooTreeDataStore.h. ◆ _cacheOwner. const RooAbsArg* RooTreeDataStore::_cacheOwner = nullptr. private . TTree holding the cached function values. ; Definition at line 162 of file RooTreeDataStore.h. ◆ _cacheTree. TTree* RooTreeDataStore::_cacheTree = nullptr. private . Definition at line 161 of file RooTreeDataStore.h. ◆ _curWgt. double RooTreeDataStore::_curWgt = 1.0. mutableprivate . Buffer for weights in case a batch of values is requested. ; Weight of current event ; Definition at line 174 of file RooTreeDataStore.h. ◆ _curWgtErr. double RooTreeDataStore::_curWgtErr = 0.0. mutableprivate . Weight of current event. ; Definition at line 177 of file RooTreeDataStore.h. ◆ _curWgtErrHi. double RooTreeDataStore::_curWgtErrHi = 0.0. mutableprivate . Weight of current event. ; Definition at line 176 of file RooTreeDataStore.h. ◆ _curWgtErrLo. double RooTreeDataStore::_curWgtErrLo = 0.0. mutableprivate . Weight of current event. ; Definition at line 175 of file RooTreeDataStore.h. ◆ _defCtor. bool RooTreeDataStore::_defCtor = false. mutableprivate . Object owning cache contents. ; Definition at line 163 of file ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooTreeDataStore.html:40244,cache,cached,40244,doc/master/classRooTreeDataStore.html,https://root.cern,https://root.cern/doc/master/classRooTreeDataStore.html,1,['cache'],['cached']
Performance,"oad=kTRUE)Get pointer to the base class TClass.Definition TBaseClass.cxx:63; TBrowserUsing a TBrowser one can browse all ROOT objects.Definition TBrowser.h:37; TBufferBuffer base class used for serializing objects.Definition TBuffer.h:43; TBuildRealDataDefinition TClass.cxx:751; TBuildRealData::Inspectvoid Inspect(TClass *cl, const char *parent, const char *name, const void *addr, Bool_t isTransient) overrideThis method is called from ShowMembers() via BuildRealdata().Definition TClass.cxx:771; TBuildRealData::fRealDataClassTClass * fRealDataClassDefinition TClass.cxx:755; TBuildRealData::fRealDataObjectvoid * fRealDataObjectDefinition TClass.cxx:754; TBuildRealData::TBuildRealDataTBuildRealData(void *obj, TClass *cl)Definition TClass.cxx:758; TClassGeneratorObjects following this interface can be passed onto the TROOT object to implement a user customized w...Definition TClassGenerator.h:28; TClassGenerator::GetClassvirtual TClass * GetClass(const char *classname, Bool_t load)=0; TClassMenuItemDescribes one element of the context menu associated to a class The menu item may describe.Definition TClassMenuItem.h:31; TClassMenuItem::SetTogglevirtual void SetToggle(Bool_t toggle=kTRUE)Definition TClassMenuItem.h:75; TClassMenuItem::kIsSelf@ kIsSelfDefinition TClassMenuItem.h:37; TClassMenuItem::kPopupStandardList@ kPopupStandardListDefinition TClassMenuItem.h:35; TClassMenuItem::kPopupSeparator@ kPopupSeparatorDefinition TClassMenuItem.h:35; TClassMenuItem::kPopupUserFunction@ kPopupUserFunctionDefinition TClassMenuItem.h:35; TClassRefTClassRef is used to implement a permanent reference to a TClass object.Definition TClassRef.h:28; TClassStreamerDefinition TClassStreamer.h:26; TClassStreamer::Streamvirtual void Stream(TBuffer &b, void *objp, const TClass *onfileClass)Definition TClassStreamer.h:51; TClassStreamer::Generatevirtual TClassStreamer * Generate() constDefinition TClassStreamer.h:38; TClassTable::GetDictstatic DictFuncPtr_t GetDict(const char *cname)Given the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:305100,load,load,305100,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['load'],['load']
Performance,"oad=kTRUE)Get pointer to the base class TClass.Definition TBaseClass.cxx:63; TBrowserUsing a TBrowser one can browse all ROOT objects.Definition TBrowser.h:37; TBufferBuffer base class used for serializing objects.Definition TBuffer.h:43; TBuildRealDataDefinition TClass.cxx:818; TBuildRealData::Inspectvoid Inspect(TClass *cl, const char *parent, const char *name, const void *addr, Bool_t isTransient) overrideThis method is called from ShowMembers() via BuildRealdata().Definition TClass.cxx:838; TBuildRealData::fRealDataClassTClass * fRealDataClassDefinition TClass.cxx:822; TBuildRealData::fRealDataObjectvoid * fRealDataObjectDefinition TClass.cxx:821; TBuildRealData::TBuildRealDataTBuildRealData(void *obj, TClass *cl)Definition TClass.cxx:825; TClassGeneratorObjects following this interface can be passed onto the TROOT object to implement a user customized w...Definition TClassGenerator.h:28; TClassGenerator::GetClassvirtual TClass * GetClass(const char *classname, Bool_t load)=0; TClassMenuItemDescribes one element of the context menu associated to a class The menu item may describe.Definition TClassMenuItem.h:31; TClassMenuItem::SetTogglevirtual void SetToggle(Bool_t toggle=kTRUE)Definition TClassMenuItem.h:75; TClassMenuItem::kIsSelf@ kIsSelfDefinition TClassMenuItem.h:37; TClassMenuItem::kPopupStandardList@ kPopupStandardListDefinition TClassMenuItem.h:35; TClassMenuItem::kPopupSeparator@ kPopupSeparatorDefinition TClassMenuItem.h:35; TClassMenuItem::kPopupUserFunction@ kPopupUserFunctionDefinition TClassMenuItem.h:35; TClassRefTClassRef is used to implement a permanent reference to a TClass object.Definition TClassRef.h:28; TClassStreamerDefinition TClassStreamer.h:26; TClassStreamer::Streamvirtual void Stream(TBuffer &b, void *objp, const TClass *onfileClass)Definition TClassStreamer.h:51; TClassStreamer::Generatevirtual TClassStreamer * Generate() constDefinition TClassStreamer.h:38; TClassTable::GetDictstatic DictFuncPtr_t GetDict(const char *cname)Given the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:307738,load,load,307738,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['load'],['load']
Performance,"oadEnums ; (; TListOfEnums & ; cl); const. finalvirtual . Create list of pointers to enums for TClass cl. ; Implements TInterpreter.; Definition at line 4395 of file TCling.cxx. ◆ LoadFile(). int TCling::LoadFile ; (; const char * ; path); const. finalvirtual . Load a source file or library called path into the interpreter. ; Reimplemented from TInterpreter.; Definition at line 7500 of file TCling.cxx. ◆ LoadFunctionTemplates(). void TCling::LoadFunctionTemplates ; (; TClass * ; cl); const. finalvirtual . Create list of pointers to function templates for TClass cl. ; Implements TInterpreter.; Definition at line 4442 of file TCling.cxx. ◆ LoadLibraryMap(). Int_t TCling::LoadLibraryMap ; (; const char * ; rootmapfile = nullptr). finalvirtual . Load map between class and library. ; If rootmapfile is specified a specific rootmap file can be added (typically used by ACLiC). In case of error -1 is returned, 0 otherwise. The interpreter uses this information to automatically load the shared library for a class (autoload mechanism), see the AutoLoad() methods below. ; Implements TInterpreter.; Definition at line 5741 of file TCling.cxx. ◆ LoadMacro(). void TCling::LoadMacro ; (; const char * ; filename, . EErrorCode * ; error = nullptr . ). finalvirtual . Load a macro file in cling's memory. ; Implements TInterpreter.; Definition at line 3552 of file TCling.cxx. ◆ LoadPCM(). void TCling::LoadPCM ; (; std::string ; pcmFileNameFullPath). private . Tries to load a rdict PCM, issues diagnostics if it fails. ; Definition at line 1811 of file TCling.cxx. ◆ LoadPCMImpl(). void TCling::LoadPCMImpl ; (; TFile & ; pcmFile). private . Tries to load a PCM from TFile; returns true on success. ; Definition at line 1696 of file TCling.cxx. ◆ LoadText(). Bool_t TCling::LoadText ; (; const char * ; text); const. finalvirtual . Load the declarations from text into the interpreter. ; Note that this cannot be (top level) statements; text must contain top level declarations. Returns true on succ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTCling.html:113918,load,load,113918,doc/master/classTCling.html,https://root.cern,https://root.cern/doc/master/classTCling.html,1,['load'],['load']
Performance,oaded at fStart ; Definition at line 71 of file TQueryResult.h. ◆ fLogFile. TMacro* TQueryResult::fLogFile. protected . file with log messages from the query ; Definition at line 68 of file TQueryResult.h. ◆ fMergeTime. Float_t TQueryResult::fMergeTime. protected . Merging time (seconds) (millisec precision) ; Definition at line 80 of file TQueryResult.h. ◆ fNumMergers. Int_t TQueryResult::fNumMergers. protected . Number of submergers. ; Definition at line 84 of file TQueryResult.h. ◆ fNumWrks. Int_t TQueryResult::fNumWrks. protected . Number of workers at start. ; Definition at line 83 of file TQueryResult.h. ◆ fOptions. TString TQueryResult::fOptions. protected . processing options + aclic mode (< opt >#< aclic_mode >) ; Definition at line 63 of file TQueryResult.h. ◆ fOutputList. TList* TQueryResult::fOutputList. protected . output list ; Definition at line 73 of file TQueryResult.h. ◆ fParList. TString TQueryResult::fParList. protected . colon-separated list of PAR loaded at fStart ; Definition at line 72 of file TQueryResult.h. ◆ fPrepTime. Float_t TQueryResult::fPrepTime. protected . Prepare time (seconds) (millisec precision) ; Definition at line 77 of file TQueryResult.h. ◆ fProcTime. Float_t TQueryResult::fProcTime. protected . Processing time (seconds) (millisec precision) ; Definition at line 79 of file TQueryResult.h. ◆ fRecvTime. Float_t TQueryResult::fRecvTime. protected . Transfer-to-client time (seconds) (millisec precision) ; Definition at line 81 of file TQueryResult.h. ◆ fResultFile. TString TQueryResult::fResultFile. protected . URL of the file where results have been archived. ; Definition at line 76 of file TQueryResult.h. ◆ fSelecHdr. TMacro* TQueryResult::fSelecHdr. protected . selector header file ; Definition at line 69 of file TQueryResult.h. ◆ fSelecImp. TMacro* TQueryResult::fSelecImp. protected . selector implementation file ; Definition at line 70 of file TQueryResult.h. ◆ fSeqNum. Int_t TQueryResult::fSeqNum. protected . query unique s,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQueryResult.html:28208,load,loaded,28208,doc/master/classTQueryResult.html,https://root.cern,https://root.cern/doc/master/classTQueryResult.html,1,['load'],['loaded']
Performance,"oaded. ; After the unload, the data member can no longer be found directly, until the decl can be found again in the interpreter (in which the func object will be reused. ; Definition at line 564 of file TListOfDataMembers.cxx. ◆ UnmapObject(). void TListOfDataMembers::UnmapObject ; (; TObject * ; obj). private . Remove a pair<id, object> from the map of data members and their ids. ; Definition at line 322 of file TListOfDataMembers.cxx. ◆ Update(). void TListOfDataMembers::Update ; (; TDictionary * ; member). Move the member or data member to the expect set of list. ; Definition at line 497 of file TListOfDataMembers.cxx. Member Data Documentation. ◆ fClass. TClass* TListOfDataMembers::fClass = nullptr. private . Definition at line 35 of file TListOfDataMembers.h. ◆ fIds. TExMap* TListOfDataMembers::fIds = nullptr. private . Context of this list. Not owned. ; Definition at line 37 of file TListOfDataMembers.h. ◆ fIsLoaded. std::atomic<bool> TListOfDataMembers::fIsLoaded {kFALSE}. private . Represent interpreter state when we last did a full load. ; Definition at line 40 of file TListOfDataMembers.h. ◆ fLastLoadMarker. ULong64_t TListOfDataMembers::fLastLoadMarker = 0. private . Holder of TDataMember for unloaded DataMembers. ; Definition at line 39 of file TListOfDataMembers.h. ◆ fSelection. TDictionary::EMemberSelection TListOfDataMembers::fSelection = TDictionary::EMemberSelection::kNoUsingDecls. private . Mark whether Load was executed. ; Definition at line 42 of file TListOfDataMembers.h. ◆ fUnloaded. THashList* TListOfDataMembers::fUnloaded = nullptr. private . Map from DeclId_t to TDataMember*. ; Definition at line 38 of file TListOfDataMembers.h. Libraries for TListOfDataMembers:. [legend]; The documentation for this class was generated from the following files:; core/meta/inc/TListOfDataMembers.h; core/meta/src/TListOfDataMembers.cxx. TListOfDataMembers. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:43:56 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTListOfDataMembers.html:34353,load,load,34353,doc/master/classTListOfDataMembers.html,https://root.cern,https://root.cern/doc/master/classTListOfDataMembers.html,1,['load'],['load']
Performance,"oat>& vec, float alpha = 1.); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TMatrixTSub<float>(); TMatrixTSub<float>(const TMatrixTSub<float>& ms); TMatrixTSub<float>(TMatrixT<float>& matrix, Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb); TMatrixTSub<float>(TMatrixTSym<float>& matrix, Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb). Data Members; public:. static TMatrixTSub<float>::(anonymous)kWorkMax. protected:. Int_tTMatrixTSub_const<float>::fColOff; TMatrixTBase<float>*TMatrixTSub_const<float>::fMatrixthe matrix I am a submatrix of; Int_tTMatrixTSub_const<float>::fNcolsSub; Int_tTMatrixTSub_const<float>::fNrowsSub; Int_tTMatrixTSub_const<float>::fRowOff. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void TMatrixTSub<Element> Rank1Update(const TVectorT<float>& vec, float alpha = 1.); Perform a rank 1 operation on the matrix:; A += alpha * v * v^T. void TMatrixTSub<Element> operator=(Element val); Assign val to every element of the sub matrix. void TMatrixTSub<Element> operator+=(Element val); Add val to every element of the sub matrix. void TMatrixTSub<Element> operator*=(Element val); Multiply every element of the sub matrix by val . void TMatrixTSub<Element> operator=(const TMatrixTSub_const<Element> &ms); Assignment operator. void TMatrixTSub<Element> operator=(const TMatrixTBase<Element> &m); Assignment operator. void TMatrixTSub<Element> operator+=(const TMatrixTSub_const<Element> &ms); Add to every element of the submatrix the corresponding element of submatrix ms. void TMatrixTSub<Element> operator*=(const TMatrixTSub_const<Element> &ms); Multiply submatrix with submatrix ms. void TMatrixTSub<Element> operator+=(const TMatrixTBase<Element> &mt); Add to every element of the submatrix the corresponding element of matrix mt. void TMatrixTSub<Element> operator*=(const TMatrixT<Element> &sourc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMatrixTSub_float_.html:2707,Perform,Perform,2707,root/html602/TMatrixTSub_float_.html,https://root.cern,https://root.cern/root/html602/TMatrixTSub_float_.html,2,['Perform'],['Perform']
Performance,"oat_t Int_t Int_t UInt_t UInt_t Rectangle_t resultDefinition TGWin32VirtualXProxy.cxx:174; TInterpreter.h; gClingR__EXTERN TInterpreter * gClingDefinition TInterpreter.h:574; TROOT.h; gROOT#define gROOTDefinition TROOT.h:406; TSelector.h; TSystem.h; gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:561; TTree.h; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClass::Newvoid * New(ENewType defConstructor=kClassNew, Bool_t quiet=kFALSE) constReturn a pointer to a newly allocated object of this class.Definition TClass.cxx:5045; TClass::InheritsFromBool_t InheritsFrom(const char *cl) const overrideReturn kTRUE if this class inherits from a class with name ""classname"".Definition TClass.cxx:4941; TClass::GetBaseClassOffsetInt_t GetBaseClassOffset(const TClass *toBase, void *address=nullptr, bool isDerivedObject=true)Definition TClass.cxx:2858; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:3035; TCollection::SetOwnervirtual void SetOwner(Bool_t enable=kTRUE)Set whether this collection is the owner (enable==true) of its content.Definition TCollection.cxx:746; THashList::Deletevoid Delete(Option_t *option="""") overrideRemove all objects from the list AND delete all heap based objects.Definition THashList.cxx:207; TInterpreter::ClassInfo_Newvirtual void * ClassInfo_New(ClassInfo_t *) constDefinition TInterpreter.h:425; TInterpreter::ClassInfo_IsValidvirtual Bool_t ClassInfo_IsValid(ClassInfo_t *) constDefinition TInterpreter.h:421; TInterpreter::ClassInfo_Deletevirtual void ClassInfo_Delete(ClassInfo_t *) constDefinition TInterpreter.h:401; TInterpreter::ClassInfo_IsBasevirtual Bool_t ClassInfo_IsBase(ClassInfo_t *, const char *) constDefinition TInterpreter.h:416; TInterpreter::ClassInfo_FullNamevirtual const char * ClassInfo_FullName(ClassInfo_t *) constDefinition",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSelector_8cxx_source.html:17182,load,load,17182,doc/master/TSelector_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSelector_8cxx_source.html,1,['load'],['load']
Performance,"oating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; RooRealProxy_meas; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; RooRealProxy_true; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooPullVar.html:32757,cache,cache,32757,root/html530/RooPullVar.html,https://root.cern,https://root.cern/root/html530/RooPullVar.html,1,['cache'],['cache']
Performance,"oating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_t_valueConstant value of self; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooConstVar.html:32338,cache,cache,32338,root/html530/RooConstVar.html,https://root.cern,https://root.cern/root/html530/RooConstVar.html,1,['cache'],['cache']
Performance,"obal instance of string that matches object named; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; Bool_t_nlo; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_tRooResolutionModel::_ownBasisFlag indicating ownership of _basis; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooGExpModel.html:47588,cache,cache,47588,root/html602/RooGExpModel.html,https://root.cern,https://root.cern/root/html602/RooGExpModel.html,4,['cache'],['cache']
Performance,"obal matrices. ;  ; Bool_t cd (const char *path="""");  Browse the tree of nodes starting from top node according to pathname. ;  ; void CdDown (Int_t index);  Make a daughter of current node current. ;  ; void CdDown (TGeoNode *node);  Make a daughter of current node current. ;  ; void CdNext ();  Do a cd to the node found next by FindNextBoundary. ;  ; void CdNode (Int_t nodeid);  Change current path to point to the node having this id. ;  ; void CdTop ();  Make top level node the current node. ;  ; void CdUp ();  Go one level up in geometry. ;  ; Bool_t CheckPath (const char *path) const;  Check if a geometry path is valid without changing the state of the navigator. ;  ; TGeoNode * CrossBoundaryAndLocate (Bool_t downwards, TGeoNode *skipnode);  Cross next boundary and locate within current node The current point must be on the boundary of fCurrentNode. ;  ; void DoBackupState ();  Backup the current state without affecting the cache stack. ;  ; void DoRestoreState ();  Restore a backed-up state without affecting the cache stack. ;  ; TGeoNode * FindNextBoundary (Double_t stepmax=TGeoShape::Big(), const char *path="""", Bool_t frombdr=kFALSE);  Find distance to next boundary and store it in fStep. ;  ; TGeoNode * FindNextBoundaryAndStep (Double_t stepmax=TGeoShape::Big(), Bool_t compsafe=kFALSE);  Compute distance to next boundary within STEPMAX. ;  ; TGeoNode * FindNextDaughterBoundary (Double_t *point, Double_t *dir, Int_t &idaughter, Bool_t compmatrix=kFALSE);  Computes as fStep the distance to next daughter of the current volume. ;  ; TGeoNode * FindNode (Bool_t safe_start=kTRUE);  Returns deepest node containing current point. ;  ; TGeoNode * FindNode (Double_t x, Double_t y, Double_t z);  Returns deepest node containing current point. ;  ; Double_t * FindNormal (Bool_t forward=kTRUE);  Computes normal vector to the next surface that will be or was already crossed when propagating on a straight line from a given point/direction. ;  ; Double_t * FindNormalFast ();",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoNavigator.html:2834,cache,cache,2834,doc/master/classTGeoNavigator.html,https://root.cern,https://root.cern/doc/master/classTGeoNavigator.html,1,['cache'],['cache']
Performance,"obalDir () const;  Returns true when sniffer allowed to scan global directories. ;  ; virtual Bool_t IsStreamerInfoItem (const char *);  ; Bool_t Produce (const std::string &path, const std::string &file, const std::string &options, std::string &res);  Method produce different kind of data out of object. ;  ; Bool_t RegisterCommand (const char *cmdname, const char *method, const char *icon);  Register command which can be executed from web interface. ;  ; Bool_t RegisterObject (const char *subfolder, TObject *obj);  Register object in subfolder structure. ;  ; void Restrict (const char *path, const char *options);  Restrict access to the specified location. ;  ; void ScanHierarchy (const char *topname, const char *path, TRootSnifferStore *store, Bool_t only_fields=kFALSE);  Method scans normal objects, registered in ROOT. ;  ; void SetAutoLoad (const char *scripts="""");  When specified, _autoload attribute will be always add to top element of h.json/h.hml requests Used to instruct browser automatically load special code. ;  ; THttpCallArg * SetCurrentCallArg (THttpCallArg *arg);  set current http arguments, which then used in different process methods For instance, if user authorized with some user name, depending from restrictions some objects will be invisible or user get full access to the element Returns previous argument which was set before ;  ; Bool_t SetItemField (const char *fullname, const char *name, const char *value);  Set field for specified item. ;  ; void SetReadOnly (Bool_t on=kTRUE);  When readonly on (default), sniffer is not allowed to change ROOT structures For instance, it is not allowed to read new objects from files. ;  ; void SetScanGlobalDir (Bool_t on=kTRUE);  When enabled (default), sniffer scans gROOT for files, canvases, histograms. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; Bool_t UnregisterObject (TObject *obj);  Unregister (remove) ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTRootSniffer.html:3757,load,load,3757,doc/master/classTRootSniffer.html,https://root.cern,https://root.cern/doc/master/classTRootSniffer.html,1,['load'],['load']
Performance,"obalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction3Ref<double,double,double,bool>funcFunction pointer reference; RooRealProxyxArgument reference; RooRealProxyyArgument reference; RooRealProxyzArgument reference.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooCFunction3Binding_double_double_double_bool_.html:33710,cache,cache,33710,root/html532/RooCFunction3Binding_double_double_double_bool_.html,https://root.cern,https://root.cern/root/html532/RooCFunction3Binding_double_double_double_bool_.html,1,['cache'],['cache']
Performance,obalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Int_tRooAbsCachedPdf::_ipOrderInterpolation order for cache histograms ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooSetProxy_paramsEffective parameters of this p.d.f.; RooRealProxy_pdf1First input p.d.f; RooRealProxy_pdf2Second input p.d.f; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooFFTConvPdf.html:48018,cache,cache,48018,root/html534/RooFFTConvPdf.html,https://root.cern,https://root.cern/root/html534/RooFFTConvPdf.html,2,['cache'],['cache']
Performance,"obj); virtual TObject*TDirectory::Remove(TObject*); virtual Int_tReOpen(Option_t* mode); voidTObject::ResetBit(UInt_t f); virtual voidTFile::ResetErrno() const; virtual voidTDirectoryFile::rmdir(const char* name); virtual voidTDirectoryFile::Save(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tTDirectoryFile::SaveObjectAs(const TObject* obj, const char* filename = """", Option_t* option = """") const; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); virtual voidTDirectoryFile::SaveSelf(Bool_t force = kFALSE); virtual voidSeek(Long64_t offset, TFile::ERelativeTo pos = kBeg); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTDirectoryFile::SetBufferSize(Int_t bufsize); static Bool_tTFile::SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); virtual voidTFile::SetCacheRead(TFileCacheRead* cache); virtual voidTFile::SetCacheWrite(TFileCacheWrite* cache); virtual voidTFile::SetCompressionLevel(Int_t level = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTFile::SetEND(Long64_t last); static voidTFile::SetFileBytesRead(Long64_t bytes = 0); static voidTFile::SetFileBytesWritten(Long64_t bytes = 0); static voidTFile::SetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTFile::SetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); static Bool_tTFile::SetOnlyStaged(Bool_t onlystaged); static UInt_tTFile::SetOpenTimeout(UInt_t timeout); virtual voidTFile::SetOption(Option_t* option = "">""); static voidSetProxy(const char* url); static voidTFi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TWebFile.html:11497,cache,cache,11497,root/html528/TWebFile.html,https://root.cern,https://root.cern/root/html528/TWebFile.html,1,['cache'],['cache']
Performance,"obj); virtual TObject*TDirectory::Remove(TObject*); virtual Int_tReOpen(Option_t* mode); voidTObject::ResetBit(UInt_t f); virtual voidTFile::ResetErrno() const; virtual voidTDirectoryFile::rmdir(const char* name); virtual voidTDirectoryFile::Save(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tTDirectoryFile::SaveObjectAs(const TObject* obj, const char* filename = """", Option_t* option = """") const; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); virtual voidTDirectoryFile::SaveSelf(Bool_t force = kFALSE); virtual voidSeek(Long64_t offset, TFile::ERelativeTo pos = kBeg); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTDirectoryFile::SetBufferSize(Int_t bufsize); static Bool_tTFile::SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); virtual voidTFile::SetCacheRead(TFileCacheRead* cache); virtual voidTFile::SetCacheWrite(TFileCacheWrite* cache); virtual voidTFile::SetCompressionLevel(Int_t level = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTFile::SetEND(Long64_t last); static voidTFile::SetFileBytesRead(Long64_t bytes = 0); static voidTFile::SetFileBytesWritten(Long64_t bytes = 0); static voidTFile::SetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTFile::SetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); static Bool_tTFile::SetOnlyStaged(Bool_t onlystaged); static UInt_tTFile::SetOpenTimeout(UInt_t timeout); virtual voidTFile::SetOption(Option_t* option = "">""); static voidTFile::SetReadaheadSize(Int_t bufsize = 2",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TNetFile.html:13256,cache,cache,13256,root/html528/TNetFile.html,https://root.cern,https://root.cern/root/html528/TNetFile.html,1,['cache'],['cache']
Performance,"obj, Option_t* opt, TVirtualPad* pad); static TGLPlot3D*TGLPlot3D::CreatePlot(TObject* obj, Option_t* opt, Bool_t logx, Bool_t logy, Bool_t logz); voidTGLLogicalShape::DestroyPhysicals(); virtual voidDirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*TGLObject::GetGLRenderer(TClass* isa); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tKeepDuringSmartRefresh() const; virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; UInt_tTGLLogicalShape::Ref() const; virtual voidSetBBox(); Bool_tTGLLogicalShape::SetDLCache(Bool_t cached); virtual Bool_tSetModel(TObject* obj, Option_t* opt = 0); virtual Bool_tTGLObject::ShouldDLCache(const TGLRnrCtx& rnrCtx) const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidTGLLogicalShape::StrongRef(Bool_t strong) const; voidTGLLogicalShape::SubRef(TGLPhysicalShape* phys) const; virtual TGLLogicalShape::ELODAxesTGLLogicalShape::SupportedLODAxes() const; virtual Bool_tTGLLogicalShape::SupportsSecondarySelect() const; UInt_tTGLLogicalShape::UnrefFirstPhysical(); virtual voidTGLObject::UpdateBoundingBox(); voidTGLLogicalShape::UpdateBoundingBoxesOfPhysicals().",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TF2GL.html:2001,cache,cached,2001,root/html528/TF2GL.html,https://root.cern,https://root.cern/root/html528/TF2GL.html,8,['cache'],['cached']
Performance,"object after in the list. void AddBefore(const TObject* before, TObject* obj); Insert object before object before in the list. void AddBefore(TObjLink* before, TObject* obj); Insert object before object before in the list. void Clear(Option_t* option); Remove all objects from the list. Does not delete the objects unless; the THashList is the owner (set via SetOwner()). void Delete(Option_t* option = """"); Delete all TDataMember object files. TObject * FindObject(const char* name) const; Specialize FindObject to do search for the; a data member just by name or create it if its not already in the list. TDictionary * Get(TListOfDataMembers::DeclId_t id); Return (after creating it if necessary) the TDataMember; describing the data member corresponding to the Decl 'id'. TDictionary * Get(DataMemberInfo_t* info, bool skipChecks = false); Return (after creating it if necessary) the TDataMember; describing the data member corresponding to the Decl 'id'.; The skipChecks flag controls the consistency checks performed inspecting; the AST. In some cases, we explicitely alter the datamembers in the; typesystem with respect to the AST and therefore we must not enforce; consistency. void UnmapObject(TObject* obj); Remove a pair<id, object> from the map of data members and their ids. void RecursiveRemove(TObject* obj); Remove object from this collection and recursively remove the object; from all other objects (and collections).; This function overrides TCollection::RecursiveRemove that calls; the Remove function. THashList::Remove cannot be called because; it uses the hash value of the hash table. This hash value; is not available anymore when RecursiveRemove is called from; the TObject destructor. TObject* Remove(TObject* obj); Remove object from the list. TObject* Remove(TObjLink* lnk); Remove object via its objlink from the list. void Load(); Load all the DataMembers known to the intepreter for the scope 'fClass'; into this collection. void Streamer(TBuffer& ); Stream an object ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TListOfDataMembers.html:13893,perform,performed,13893,root/html602/TListOfDataMembers.html,https://root.cern,https://root.cern/root/html602/TListOfDataMembers.html,2,['perform'],['performed']
Performance,"object if processing object (vs. TTree) ;  ; TString fOption;  Option given to TTree::Process. ;  ; TSelectorList * fOutput;  ! List of objects created during processing ;  ; Long64_t fStatus;  Selector status. ;  . #include <TSelHandleDataSet.h>. Inheritance diagram for TSelHandleDataSet:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TSelHandleDataSet(). TSelHandleDataSet::TSelHandleDataSet ; (; ). inline . Definition at line 42 of file TSelHandleDataSet.h. ◆ ~TSelHandleDataSet(). TSelHandleDataSet::~TSelHandleDataSet ; (; ). inlineoverride . Definition at line 43 of file TSelHandleDataSet.h. Member Function Documentation. ◆ Begin(). void TSelHandleDataSet::Begin ; (; TTree * ; ). inlineoverridevirtual . Reimplemented from TSelector.; Definition at line 45 of file TSelHandleDataSet.h. ◆ CheckCache(). void TSelHandleDataSet::CheckCache ; (; const char * ; fn). private . Check the memory cache associated with file 'fn'. ; Definition at line 99 of file TSelHandleDataSet.cxx. ◆ Class(). static TClass * TSelHandleDataSet::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TSelHandleDataSet::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TSelHandleDataSet::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 57 of file TSelHandleDataSet.h. ◆ CopyFile(). void TSelHandleDataSet::CopyFile ; (; const char * ; fn). private . Copy file 'fn' to fDestDir. ; Definition at line 132 of file TSelHandleDataSet.cxx. ◆ DeclFileName(). static const char * TSelHandleDataSet::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 57 of file TSelHandleDataSet.h. ◆ GetOutputList(). TList * TSelHandleDataSet::GetOutputList ; (; ); const. inlineoverridevirtual . Reimplemented from TSelector.; Definitio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSelHandleDataSet.html:13729,cache,cache,13729,doc/master/classTSelHandleDataSet.html,https://root.cern,https://root.cern/doc/master/classTSelHandleDataSet.html,1,['cache'],['cache']
Performance,"object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooRealProxy_origModelOriginal resolution model; RooRealProxy_origPdfOriginal input PDF; RooRealProxy_origVarOriginal convolution variable; RooArgSet_ownedClonedModelSetOwning set of cloned model components; RooArgSet_ownedClonedPdfSetOwning set of cloned PDF components; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Bool_t_useWindowSwitch to activate window convolution; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; Int_t_verboseThreshCall count threshold for verbose printing; RooListProxy_windowParamHolder for optional convolution integration window scaling parameter; Double_t_windowScaleScale factor for window parameter; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooNumConvolution.html:38589,cache,cache,38589,root/html534/RooNumConvolution.html,https://root.cern,https://root.cern/root/html534/RooNumConvolution.html,2,['cache'],['cache']
Performance,object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void TChainElement::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 82 of file TChainElement.h. Member Data Documentation. ◆ fBaddress. void* TChainElement::fBaddress. protected . ! branch address when used as a branch ; Definition at line 40 of file TChainElement.h. ◆ fBaddressClassName. TString TChainElement::fBaddressClassName. protected . ! Name of the class pointed to by fBaddress ; Definition at line 41 of file TChainElement.h. ◆ fBaddressIsPtr. bool TChainElement::fBaddressIsPtr. protected . ! True if the address is a pointer to an address ; Definition at line 43 of file TChainElement.h. ◆ fBaddressType. UInt_t TChainElement::fBaddressType. protected . ! Type of the value pointed to by fBaddress ; Definition at line 42 of file TChainElement.h. ◆ fBranchPtr. TBranch** TChainElement::fBranchPtr. protected . ! Address of user branch pointer (to updated upon loading a file) ; Definition at line 47 of file TChainElement.h. ◆ fCheckedType. bool TChainElement::fCheckedType. protected . ! True if the branch type and the address type have been checked. ; Definition at line 45 of file TChainElement.h. ◆ fDecomposedObj. bool TChainElement::fDecomposedObj. protected . ! True if the address needs the branch in MakeClass/DecomposedObj mode. ; Definition at line 44 of file TChainElement.h. ◆ fEntries. Long64_t TChainElement::fEntries. protected . Number of entries in the tree of this chain element. ; Definition at line 36 of file TChainElement.h. ◆ fLoadResult. Int_t TChainElement::fLoadResult. protected . ! Return value of TChain::LoadTree(); 0 means success ; Definition at line 48 of file TChainElement.h. ◆ fNPackets. Int_t TChainElement::fNPackets. protected . Number of packets. ; Definition at line 37 of file TChainElement.h. ◆ fPackets. char* TChainElement::fPackets. protected . ! Packet descriptor string ; Definition at line 46 of file TChainElement.,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTChainElement.html:20445,load,loading,20445,doc/master/classTChainElement.html,https://root.cern,https://root.cern/doc/master/classTChainElement.html,1,['load'],['loading']
Performance,"object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void TPluginManager::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 286 of file TPluginManager.h. ◆ WritePluginMacros(). Int_t TPluginManager::WritePluginMacros ; (; const char * ; dir, . const char * ; plugin = nullptr . ); const. Write in the specified directory the plugin macros. ; If plugin is specified and if it is a base class all macros for that base will be written. If it is a plugin class name, only that one macro will be written. If plugin is 0 all macros are written. Returns -1 if dir does not exist, 0 otherwise. ; Definition at line 665 of file TPluginManager.cxx. ◆ WritePluginRecords(). Int_t TPluginManager::WritePluginRecords ; (; const char * ; envFile, . const char * ; plugin = nullptr . ); const. Write in the specified environment config file the plugin records. ; If plugin is specified and if it is a base class all records for that base will be written. If it is a plugin class name, only that one record will be written. If plugin is 0 all macros are written. If envFile is 0 or """" the records are written to stdout. Returns -1 if envFile cannot be created or opened, 0 otherwise. ; Definition at line 747 of file TPluginManager.cxx. Member Data Documentation. ◆ fBasesLoaded. THashTable* TPluginManager::fBasesLoaded. private . Definition at line 262 of file TPluginManager.h. ◆ fHandlers. TList* TPluginManager::fHandlers. private . Definition at line 261 of file TPluginManager.h. ◆ fReadingDirs. Bool_t TPluginManager::fReadingDirs. private . table of base classes already checked or loaded ; Definition at line 263 of file TPluginManager.h. Libraries for TPluginManager:. [legend]; The documentation for this class was generated from the following files:; core/base/inc/TPluginManager.h; core/base/src/TPluginManager.cxx. TPluginManager. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:44:09 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPluginManager.html:21718,load,loaded,21718,doc/master/classTPluginManager.html,https://root.cern,https://root.cern/doc/master/classTPluginManager.html,1,['load'],['loaded']
Performance,"object pointing to this TDirectory. ;  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TFile; virtual Long64_t DirCreateEntry (TDirectory *);  ; virtual Int_t DirReadKeys (TDirectory *);  ; virtual void DirWriteHeader (TDirectory *);  ; virtual void DirWriteKeys (TDirectory *);  ; Bool_t FlushWriteCache ();  Flush the write cache if active. ;  ; virtual EAsyncOpenStatus GetAsyncOpenStatus ();  ; virtual InfoListRet GetStreamerInfoListImpl (bool lookupSICache);  See documentation of GetStreamerInfoList for more details. ;  ; virtual void Init (Bool_t create);  Initialize a TFile object. ;  ; Int_t MakeProjectParMake (const char *packname, const char *filename);  Create makefile at 'filemake' for PAR package 'pack'. ;  ; Int_t MakeProjectParProofInf (const char *packname, const char *proofinfdir);  Create BUILD.sh and SETUP.C under 'proofinf' for PAR package 'pack'. ;  ; Int_t ReadBufferViaCache (char *buf, Int_t len);  Read buffer via cache. ;  ; Int_t WriteBufferViaCache (const char *buf, Int_t len);  Write buffer via cache. ;  ;  Protected Member Functions inherited from TDirectoryFile; void BuildDirectoryFile (TFile *motherFile, TDirectory *motherDir);  Initialise directory to defaults. ;  ; void CleanTargets ();  Clean the pointers to this object (gDirectory, TContext, etc.) ;  ; void InitDirectoryFile (TClass *cl=nullptr);  Initialize the key associated with this directory (and the related data members. ;  ;  Protected Member Functions inherited from TDirectory;  TDirectory (const TDirectory &directory)=delete;  ; void BuildDirectory (TFile *motherFile, TDirectory *motherDir);  Initialise directory to defaults. ;  ; Bool_t cd1 (const char *path);  flag to add histograms, graphs,etc to the directory ;  ; void CleanTargets ();  Clean the pointers to this object (gDirectory, TContext, etc.). ;  ; void FillFullPath (TString &buf) const;  Recursive method to fill full path for direct",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDCacheFile.html:34533,cache,cache,34533,doc/master/classTDCacheFile.html,https://root.cern,https://root.cern/doc/master/classTDCacheFile.html,1,['cache'],['cache']
Performance,"object, but will be completely distinct: WIRE_CO_1 and WIRE_CO_2. We will want now to place symmetrically 1000 chambers on a pad, following a pattern of 20 rows and 50 columns. One way to do this will be to replicate our chamber by positioning it 1000 times in different positions of the pad. Unfortunately, this is far from being the optimal way of doing what we want. Imagine that we would like to find out which of the 1000 chambers is containing a (x,y,z) point defined in the pad reference. You will never have to do that, since the modeller will take care of it for you, but let's guess what it has to do. The most simple algorithm will just loop over all daughters, convert the point from mother to local reference and check if the current chamber contains the point or not. This might be efficient for pads with few chambers, but definitely not for 1000. Fortunately the modeller is smarter than that and creates for each volume some optimization structures called voxels to minimize the penalty having too many daughters, but if you have 100 pads like this in your geometry you will anyway lose a lot in your tracking performance. The way out when volumes can be arranged according to simple patterns is the usage of divisions. We will describe them in detail later on. Let's think now at a different situation: instead of 1000 chambers of the same type, we may have several types of chambers. Let's say all chambers are cylindrical and have a wire inside, but their dimensions are different. However, we would like all to be represented by a single volume family, since they have the same properties.; Volume Families; A volume family is represented by the class TGeoVolumeMulti. It represents a class of volumes having the same shape type and each member will be identified by the same name and volume ID. Any operation applied to a TGeoVolumeMulti equally affects all volumes in that family. The creation of a family is generally not a user task, but can be forced in particular cases:; TG",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:42187,optimiz,optimization,42187,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,2,"['optimiz', 'perform']","['optimization', 'performance']"
Performance,"object, but will be completely distinct: WIRE_CO_1 and WIRE_CO_2. We will want now to place symmetrically 1000 chambers on a pad, following a pattern of 20 rows and 50 columns. One way to do this will be to replicate our chamber by positioning it 1000 times in different positions of the pad. Unfortunately, this is far from being the optimal way of doing what we want. Imagine that we would like to find out which of the 1000 chambers is containing a (x,y,z) point defined in the pad reference. You will never have to do that, since the modeller will take care of it for you, but let’s guess what it has to do. The most simple algorithm will just loop over all daughters, convert the point from mother to local reference and check if the current chamber contains the point or not. This might be efficient for pads with few chambers, but definitely not for 1000. Fortunately the modeller is smarter than that and creates for each volume some optimization structures called voxels to minimize the penalty having too many daughters, but if you have 100 pads like this in your geometry you will anyway lose a lot in your tracking performance. The way out when volumes can be arranged according to simple patterns is the usage of divisions. We will describe them in detail later on. Let’s think now at a different situation: instead of 1000 chambers of the same type, we may have several types of chambers. Let’s say all chambers are cylindrical and have a wire inside, but their dimensions are different. However, we would like all to be represented by a single volume family, since they have the same properties.; 18.4.2.8 Volume Families; A volume family is represented by the class TGeoVolumeMulti. It represents a class of volumes having the same shape type and each member will be identified by the same name and volume ID. Any operation applied to a TGeoVolumeMulti equally affects all volumes in that family. The creation of a family is generally not a user task, but can be forced in particular c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:950926,optimiz,optimization,950926,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,4,"['optimiz', 'perform']","['optimization', 'performance']"
Performance,"object; and the parent object supporting this referenced object. The parent object is typically a branch of a TTree. For each object; referenced in a TTree entry, the corresponding entry in the TTree's; TBranchRef::fRefTable contains the index of the branch that; needs to be loaded to bring the object into memory. Persistency of a TRefTable is split into two parts:; * entry specific information is stored (read) by FillBuffer; (ReadBuffer). For each referenced object the object's fUniqueID; and the referencing TRef::fPID is stored (to allow the TRefTable; to autoload references created by different processes).; * non-entry specific, i.e. global information is stored (read) by; the Streamer function. This comprises all members marked as; persistent. As TObject::fUniqueID is only unique for a given TProcessID, a table; of unique IDs is kept for each used TProcessID. There is no natural; order of TProcessIDs, so TRefTable stores a vector of the TGUID of; all known TProcessIDs in fProcessGUIDs; the index of a TProcessID in; this vector defines the index of the auto-loading info in fParentIDs; for that TProcessID. The mapping of TProcessID* to index is cached; for quick non-persistent lookup. Function Members (Methods); public:. TRefTable(); TRefTable(const TRefTable&); TRefTable(TObject* owner, Int_t size); virtual~TRefTable(); voidTObject::AbstractMethod(const char* method) const; virtual Int_tAdd(Int_t uid, TProcessID* context = 0); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); vir",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TRefTable.html:1424,load,loading,1424,root/html528/TRefTable.html,https://root.cern,https://root.cern/root/html528/TRefTable.html,6,['load'],['loading']
Performance,"object; and the parent object supporting this referenced object. The parent object is typically a branch of a TTree. For each object; referenced in a TTree entry, the corresponding entry in the TTree's; TBranchRef::fRefTable contains the index of the branch that; needs to be loaded to bring the object into memory. Persistency of a TRefTable is split into two parts:; * entry specific information is stored (read) by FillBuffer; (ReadBuffer). For each referenced object the object's fUniqueID; and the referencing TRef::fPID is stored (to allow the TRefTable; to autoload references created by different processes).; * non-entry specific, i.e. global information is stored (read) by; the Streamer function. This comprises all members marked as; persistent. As TObject::fUniqueID is only unique for a given TProcessID, a table; of unique IDs is kept for each used TProcessID. There is no natural; order of TProcessIDs, so TRefTable stores a vector of the TGUID of; all known TProcessIDs in fProcessGUIDs; the index of a TProcessID in; this vector defines the index of the auto-loading info in fParentIDs; for that TProcessID. The mapping of TProcessID* to index is cached; for quick non-persistent lookup. Function Members (Methods); public:. virtual~TRefTable(); voidTObject::AbstractMethod(const char* method) const; virtual Int_tAdd(Int_t uid, TProcessID* context = 0); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Opti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TRefTable.html:1448,load,loading,1448,root/html602/TRefTable.html,https://root.cern,https://root.cern/root/html602/TRefTable.html,4,['load'],['loading']
Performance,"objects that are both in the cached set 1 with a given index and an input argSet. ;  ; RooArgSet selectFromSet2 (RooArgSet const &argSet, int index) const;  Create RooArgSet containing the objects that are both in the cached set 2 with a given index and an input argSet. ;  ; Int_t setObj (const RooArgSet *nset, const RooArgSet *iset, RooAbsCacheElement *obj, const TNamed *isetRangeName=nullptr);  Insert payload object 'obj' in cache indexed on nset,iset and isetRangeName. ;  ; Int_t setObj (const RooArgSet *nset, RooAbsCacheElement *obj, const TNamed *isetRangeName=nullptr);  Setter function without integration set. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void wireCache () override;  ;  Public Member Functions inherited from RooAbsCache;  RooAbsCache (const RooAbsCache &, RooAbsArg *owner=nullptr);  Copy constructor. Takes owner as argument and registers cache with owne. ;  ;  RooAbsCache (RooAbsArg *owner=nullptr);  Constructor. Takes owner as argument and register cache with owner. ;  ; virtual ~RooAbsCache ();  Destructor. Unregisters cache with owner. ;  ; void setOwner (RooAbsArg *owner);  Reset the owner, triggering the owner to register this cache in its list of caches. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static bool clearObsList ();  ; static const char * DeclFileName ();  ; static void doClearObsList (bool flag);  ;  Static Public Member Functions inherited from RooCacheManager< RooAbsCacheElement >; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from RooAbsCache; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFil",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooObjCacheManager.html:4841,cache,cache,4841,doc/master/classRooObjCacheManager.html,https://root.cern,https://root.cern/doc/master/classRooObjCacheManager.html,1,['cache'],['cache']
Performance,"objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Bool_t_disableCacheFlag to run object in passthrough (= non-caching mode). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsCachedPdf(); Destructor. Double_t getVal(const RooArgSet* set = 0) const; Implementation of getVal() overriding default implementation; of RooAbsPdf. Return normalized value stored in cache p.d.f; rather than return value of evaluate() which is undefined; for RooAbsCachedPdf. RooAbsPdf* getCachePdf(const RooArgSet* nset = 0) const; Return pointer to RooHistPdf cache pdf for given choice of observables. RooDataHist* getCacheHist(const RooArgSet* nset = 0) const; Return pointer to RooDataHist cache histogram for given choice of observables. void clearCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; Mark all bins of given cache as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct string with unique suffix for cache objects based on; observable names that define cache configuration. void setInterpolationOrder(Int_t order); Change the interpolation order that is used in RooHistPdf cache; representation smoothing the RooDataHist shapes. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force RooRealIntegral to offer all our actual observable for internal; integration. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertises internal (analytical) integration capabilities. Call; is forwarded to",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsCachedPdf.html:42121,cache,cache,42121,root/html528/RooAbsCachedPdf.html,https://root.cern,https://root.cern/root/html528/RooAbsCachedPdf.html,2,['cache'],['cache']
Performance,"objects); If maxfiles > 0, select for processing a maximum of 'filesmax' files (but if fopt is 1 or 2 all files marked as 'staged' are still open or touched); Return code 1 dataset was not changed 2 dataset was changed; The number of touched, opened and disappeared files are returned in the respective variables, if these are defined. ; Definition at line 1224 of file TDataSetManager.cxx. ◆ ScanFile(). Int_t TDataSetManager::ScanFile ; (; TFileInfo * ; fileinfo, . Bool_t ; dbg . ). static . Open the file described by 'fileinfo' to extract the relevant meta-information. ; Return 0 if OK, -2 if the file cannot be open, -1 if it is corrupted ; Definition at line 1654 of file TDataSetManager.cxx. ◆ SetScanCounters(). void TDataSetManager::SetScanCounters ; (; Int_t ; t = -1, . Int_t ; o = -1, . Int_t ; d = -1 . ). Update scan counters. ; Definition at line 1981 of file TDataSetManager.cxx. ◆ ShowCache(). Int_t TDataSetManager::ShowCache ; (; const char * ; uri). virtual . Show cached information matching uri. ; Reimplemented in TDataSetManagerFile.; Definition at line 795 of file TDataSetManager.cxx. ◆ ShowDataSets(). void TDataSetManager::ShowDataSets ; (; const char * ; uri = ""*"", . const char * ; opt = """" . ). virtual . Prints formatted information about the dataset 'uri'. ; The type and format of output is driven by 'opt':. opt = ""server:srv1[,srv2[,srv3[,...]]]"" Print info about the subsets of 'uri' on servers srv1, srv2, ...; opt = ""servers[:exclude:srv1[,srv2[,srv3[,...]]]]"" Print info about the subsets of 'uri' on all servers, except the ones in the exclude list srv1, srv2, ...; opt = <any> Print info about all datasets matching 'uri'. If 'opt' contains 'full:' the list of files in the datasets are also printed. In case 3. this is enabled only if 'uri' matches a single dataset.; In case 3, if 'opt' contains 'full:' the list of files in the datasets are also printed. 'forcescan:' the dataset are open to get the information; otherwise the pre-processed information ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDataSetManager.html:36578,cache,cached,36578,doc/master/classTDataSetManager.html,https://root.cern,https://root.cern/doc/master/classTDataSetManager.html,1,['cache'],['cached']
Performance,"observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooRangeBoolean&operator=(const RooRangeBoolean&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*plotSamplingHint(RooAbsRealLValue& obs, Double_t xlo, Double_t xhi) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooRangeBoolean.html:19225,optimiz,optimizeCacheMode,19225,root/html602/RooRangeBoolean.html,https://root.cern,https://root.cern/root/html602/RooRangeBoolean.html,4,['optimiz'],['optimizeCacheMode']
Performance,"observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooRealIntegral&operator=(const RooRealIntegral&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*plotSamplingHint(RooAbsRealLValue& obs, Double_t xlo, Double_t xhi) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooRealIntegral.html:19140,optimiz,optimizeCacheMode,19140,root/html602/RooRealIntegral.html,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html,4,['optimiz'],['optimizeCacheMode']
Performance,"observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooSecondMoment&operator=(const RooSecondMoment&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Int_tRooAbsMoment::order() const; Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sli",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooSecondMoment.html:19373,optimiz,optimizeCacheMode,19373,root/html602/RooSecondMoment.html,https://root.cern,https://root.cern/root/html602/RooSecondMoment.html,4,['optimiz'],['optimizeCacheMode']
Performance,"observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooStepFunction&operator=(const RooStepFunction&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooStepFunction.html:19707,optimiz,optimizeCacheMode,19707,root/html602/RooStepFunction.html,https://root.cern,https://root.cern/root/html602/RooStepFunction.html,4,['optimiz'],['optimizeCacheMode']
Performance,"observables; RooRefArrayRooAbsArg::_proxyListlist of proxies; string_rangeNameName of range in which to calculate test statistic; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Int_t_setNumPartition number of this instance in parallel calculation mode; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; Int_t_simCountTotal number of component p.d.f.s in RooSimultaneous (if any); RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; Bool_t_splitRangeSplit rangeName in RooSimultaneous index labels if true; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; Bool_t_verboseVerbose messaging if true; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsTestStatistic(); Default constructor. RooAbsTestStatistic(const char* name, const char* title, RooAbsReal& real, RooAbsData& data, const RooArgSet& projDeps, const char* rangeName = 0, const char* addCoefRangeName = 0, Int_t nCPU = 1, RooFit::MPSplit interleave = RooFit::BulkPartition, Bool_t verbose = kTRUE, Bool_t splitCutRange = kTRUE); Constructor taking function (real), a dataset (data), a set of projected observables (projSet). If; rangeName is not null, only events in the d",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsTestStatistic.html:40552,cache,cache,40552,root/html602/RooAbsTestStatistic.html,https://root.cern,https://root.cern/root/html602/RooAbsTestStatistic.html,4,['cache'],['cache']
Performance,"ocess this tree executing the TSelector code in the specified filename. ; The return value is -1 in case of error and TSelector::GetStatus() in in case of success.; The code in filename is loaded (interpreted or compiled, see below), filename must contain a valid class implementation derived from TSelector, where TSelector has the following member functions:. Begin(): called every time a loop on the tree starts, a convenient place to create your histograms.; SlaveBegin(): called after Begin(), when on PROOF called only on the slave servers.; Process(): called for each event, in this function you decide what to read and fill your histograms.; SlaveTerminate: called at the end of the loop on the tree, when on PROOF called only on the slave servers.; Terminate(): called at the end of the loop on the tree, a convenient place to draw/fit your histograms. If filename is of the form file.C, the file will be interpreted.; If filename is of the form file.C++, the file file.C will be compiled and dynamically loaded.; If filename is of the form file.C+, the file file.C will be compiled and dynamically loaded. At next call, if file.C is older than file.o and file.so, the file.C is not compiled, only file.so is loaded. NOTE1; It may be more interesting to invoke directly the other Process function accepting a TSelector* as argument.eg MySelector *selector = (MySelector*)TSelector::GetSelector(filename);; selector->CallSomeFunction(..);; mytree.Process(selector,..);; filenameOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTree.html:188218,load,loaded,188218,doc/v632/classTTree.html,https://root.cern,https://root.cern/doc/v632/classTTree.html,2,['load'],['loaded']
Performance,"ocessCleanups(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TKey*TDirectory::FindKey(const char*) const; virtual TKey*TDirectory::FindKeyAny(const char*) const; virtual TObject*FindObject(const char* name) const; virtual TObject*FindObject(const TObject* obj) const; virtual TObject*FindObjectAny(const char* name) const; virtual TObject*FindObjectAnyFile(const char* name) const; const char*FindObjectClassName(const char* name) const; const char*FindObjectPathName(const TObject* obj) const; TObject*FindSpecialObject(const char* name, void*& where); TClass*FindSTLClass(const char* name, Bool_t load, Bool_t silent = kFALSE) const; voidForceStyle(Bool_t force = kTRUE); Bool_tFromPopUp() const; virtual TObject*TDirectory::Get(const char* namecycle); TApplication*GetApplication() const; virtual Int_tTDirectory::GetBufferSize() const; Int_tGetBuiltDate() const; Int_tGetBuiltTime() const; TClass*GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE) const; TClass*GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE) const; TSeqCollection*GetClipboard() const; TColor*GetColor(Int_t color) const; const char*GetConfigFeatures() const; const char*GetConfigOptions() const; const char*GetCutClassName() const; const char*GetDefCanvasName() const; virtual TDirectory*TDirectory::GetDirectory(const char* namecycle, Bool_t printError = false, const char* funcname = ""GetDirectory""); static Int_tGetDirLevel(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Bool_tGetEditHistograms() const; Int_tGetEditorMode() const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TROOT.html:4706,load,load,4706,root/html602/TROOT.html,https://root.cern,https://root.cern/root/html602/TROOT.html,4,['load'],['load']
Performance,"ocessOptions(); the option string is decoded, for available options see ""DeclareOptions"". void Init( void ); common initialisation with defaults for the BDT-Method. void Reset( void ); reset the method, as if it had just been instantiated (forget all training etc.). ~MethodBDT( void ); destructor. void InitEventSample( void ); Write all Events from the Tree into a vector of Events, that are; more easily manipulated. This method should never be called without; existing trainingTree, as it the vector of events from the ROOT training tree. void PreProcessNegativeEventWeights(); o.k. you know there are events with negative event weights. This routine will remove; them by pairing them with the closest event(s) of the same event class with positive; weights; A first attempt is ""brute force"", I dont' try to be clever using search trees etc,; just quick and dirty to see if the result is any good. std::map<TString,Double_t> OptimizeTuningParameters(TString fomType = ""ROCIntegral"", TString fitType = ""FitGA""); call the Optimzier with the set of paremeters and ranges that; are meant to be tuned. void SetTuneParameters(map<TString,Double_t> tuneParameters); set the tuning parameters accoding to the argument. void Train(); BDT training. void GetRandomSubSample(); fills fEventSample with fSampleFraction*NEvents random training events. Double_t GetGradBoostMVA(TMVA::Event& e, UInt_t nTrees); returns MVA value: -1 for background, 1 for signal. void UpdateTargets(vector<TMVA::Event*> , UInt_t cls = 0); Calculate residua for all events;. void UpdateTargetsRegression(vector<TMVA::Event*> , Bool_t first = kFALSE); Calculate current residuals for all events and update targets for next iteration. Double_t GetWeightedQuantile(vector<std::pair<Double_t,Double_t> > vec, const Double_t quantile, const Double_t SumOfWeights = 0.0); calculates the quantile of the distribution of the first pair entries weighted with the values in the second pair entries. Double_t GradBoost(vector<TMVA::Event*> , ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__MethodBDT.html:29485,tune,tuned,29485,root/html530/TMVA__MethodBDT.html,https://root.cern,https://root.cern/root/html530/TMVA__MethodBDT.html,4,"['Optimiz', 'tune']","['OptimizeTuningParameters', 'tuned']"
Performance,"ocessingvoid EnableParBranchProcessing()Globally enables the parallel branch processing, which is a case of implicit multi-threading (IMT) in...Definition TROOT.cxx:420; ROOT::Internal::IsParBranchProcessingEnabledBool_t IsParBranchProcessingEnabled()Returns true if parallel branch processing is enabled.Definition TROOT.cxx:447; ROOT::Internal::GetROOT2TROOT * GetROOT2()Definition TROOT.cxx:387; ROOT::Internal::GetROOT1TROOT * GetROOT1()Definition TROOT.cxx:380; ROOT::Internal::ReleaseDefaultErrorHandlervoid ReleaseDefaultErrorHandler()Destructs resources that are taken by using the default error handler.Definition TErrorDefaultHandler.cxx:47; ROOT::Minuit2::GradientParameterSpace::Internal@ Internal; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; ROOT::GetMacroPathTString & GetMacroPath()Definition TROOT.cxx:476; ROOT::EnableImplicitMTvoid EnableImplicitMT(UInt_t numthreads=0)Enable ROOT's implicit multi-threading for all objects and methods that provide an internal paralleli...Definition TROOT.cxx:539; ROOT::IsImplicitMTEnabledBool_t IsImplicitMTEnabled()Returns true if the implicit multi-threading in ROOT is enabled.Definition TROOT.cxx:570; ROOT::GetThreadPoolSizeUInt_t GetThreadPoolSize()Returns the size of ROOT's thread pool.Definition TROOT.cxx:577; ROOT::gCoreMutexR__EXTERN TVirtualRWMutex * gCoreMutexDefinition TVirtualRWMutex.h:37; ROOT::EnableThreadSafetyvoid EnableThreadSafety()Enable support for multi-threading within the ROOT code in particular, enables the global mutex to ma...Definition TROOT.cxx:501; ROOT::GetROOTTROOT * GetROOT()Definition TROOT.cxx:472; ROOT::DisableImplicitMTvoid DisableImplicitMT()Disables the implicit multi-threading in ROOT (see EnableImplicitMT).Definition TROOT.cxx:556; TClassEdit::GetNormalizedNamevoid GetNormalizedName(std::string &norm_name, std::string_view name)Return the normalized name.Definition TClassEdit.cxx:854; v@ vDefi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8cxx_source.html:173015,multi-thread,multi-threading,173015,doc/master/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8cxx_source.html,2,['multi-thread'],['multi-threading']
Performance,"ock(); default c-tor. TEntryListBlock(const TEntryListBlock& eblock); copy c-tor. ~TEntryListBlock(); destructor. TEntryListBlock & operator=(const TEntryListBlock& rhs). Bool_t Enter(Int_t entry); If the block has already been optimized and the entries; are stored as a list and not as bits, trying to enter a new entry; will make the block switch to bits representation. Bool_t Remove(Int_t entry); Remove entry #entry; If the block has already been optimized and the entries; are stored as a list and not as bits, trying to remove a new entry; will make the block switch to bits representation. Int_t Contains(Int_t entry); true if the block contains entry #entry. Int_t Merge(TEntryListBlock* block); Merge with the other block; Returns the resulting number of entries in the block. Int_t GetNPassed(); Returns the number of entries, passing the selection.; In case, when the block stores entries that pass (fPassing=1) returns fNPassed. Int_t GetEntry(Int_t entry); Return entry #entry; See also Next(). Int_t Next(); Return the next non-zero entry; Faster than GetEntry() function. void Print(Option_t* option = """") const; Print the entries in this block. void PrintWithShift(Int_t shift) const; print the indices of this block + shift (used from TEntryList::Print()) to; print the corrent values. void OptimizeStorage(); if there are < kBlockSize or >kBlockSize*15 entries, change to an array representation. void Transform(Bool_t dir, UShort_t* indexnew); Transform the existing fIndices; dir=0 - transform from bits to a list; dir=1 - tranform from a list to bits. void ResetIndices(); {fLastIndexQueried = -1, fLastIndexReturned = -1;}. Int_t GetType(); { return fType; }. » Author: Anna Kreshuk 27/10/2006 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id$ » Last generated: 2015-03-13 19:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TEntryListBlock.html:16396,Optimiz,OptimizeStorage,16396,root/html534/TEntryListBlock.html,https://root.cern,https://root.cern/root/html534/TEntryListBlock.html,1,['Optimiz'],['OptimizeStorage']
Performance,"ocket object for a named service. Set reuse; to true to force reuse of the server socket (i.e. do not wait for the; time out to pass). Using backlog one can set the desirable queue length; for pending connections.; Use tcpwindowsize to specify the size of the receive buffer, it has; to be specified here to make sure the window scale option is set (for; tcpwindowsize > 65KB and for platforms supporting window scaling).; Use IsValid() to check the validity of the; server socket. In case server socket is not valid use GetErrorCode(); to obtain the specific error value. These values are:; 0 = no error (socket is valid); -1 = low level socket() call failed; -2 = low level bind() call failed; -3 = low level listen() call failed; Every valid server socket is added to the TROOT sockets list which; will make sure that any open sockets are properly closed on; program termination. TSocket * Accept(UChar_t Opt = kSrvNoAuth); Accept a connection on a parallel server socket. Returns a full-duplex; parallel communication TPSocket object. If no pending connections are; present on the queue and nonblocking mode has not been enabled; with SetOption(kNoBlock,1) the call blocks until a connection is; present. The returned socket must be deleted by the user. The socket; is also added to the TROOT sockets list which will make sure that; any open sockets are properly closed on program termination.; In case of error 0 is returned and in case non-blocking I/O is; enabled and no connections are available -1 is returned. TPServerSocket(const TPServerSocket& ). void operator=(const TPServerSocket& ). virtual ~TPServerSocket(); { }. » Author: Fons Rademakers 19/1/2001 » Copyright (C) 1995-2001, Rene Brun and Fons Rademakers. *; » Last changed: root/net:$Id: TPServerSocket.h 23091 2008-04-09 15:04:27Z rdm $ » Last generated: 2010-09-23 20:18; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TPServerSocket.html:12648,queue,queue,12648,root/html528/TPServerSocket.html,https://root.cern,https://root.cern/root/html528/TPServerSocket.html,1,['queue'],['queue']
Performance,"ocket object for a named service. Set reuse; to true to force reuse of the server socket (i.e. do not wait for the; time out to pass). Using backlog one can set the desirable queue length; for pending connections.; Use tcpwindowsize to specify the size of the receive buffer, it has; to be specified here to make sure the window scale option is set (for; tcpwindowsize > 65KB and for platforms supporting window scaling).; Use IsValid() to check the validity of the; server socket. In case server socket is not valid use GetErrorCode(); to obtain the specific error value. These values are:; 0 = no error (socket is valid); -1 = low level socket() call failed; -2 = low level bind() call failed; -3 = low level listen() call failed; Every valid server socket is added to the TROOT sockets list which; will make sure that any open sockets are properly closed on; program termination. TSocket * Accept(UChar_t Opt = kSrvNoAuth); Accept a connection on a parallel server socket. Returns a full-duplex; parallel communication TPSocket object. If no pending connections are; present on the queue and nonblocking mode has not been enabled; with SetOption(kNoBlock,1) the call blocks until a connection is; present. The returned socket must be deleted by the user. The socket; is also added to the TROOT sockets list which will make sure that; any open sockets are properly closed on program termination.; In case of error 0 is returned and in case non-blocking I/O is; enabled and no connections are available -1 is returned. TPServerSocket(const TPServerSocket& ). void operator=(const TPServerSocket& ). virtual ~TPServerSocket(); { }. » Author: Fons Rademakers 19/1/2001 » Copyright (C) 1995-2001, Rene Brun and Fons Rademakers. *; » Last changed: root/net:$Id: TPServerSocket.h 23091 2008-04-09 15:04:27Z rdm $ » Last generated: 2011-07-04 15:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TPServerSocket.html:12961,queue,queue,12961,root/html530/TPServerSocket.html,https://root.cern,https://root.cern/root/html530/TPServerSocket.html,1,['queue'],['queue']
Performance,"ocket object for a named service. Set reuse; to true to force reuse of the server socket (i.e. do not wait for the; time out to pass). Using backlog one can set the desirable queue length; for pending connections.; Use tcpwindowsize to specify the size of the receive buffer, it has; to be specified here to make sure the window scale option is set (for; tcpwindowsize > 65KB and for platforms supporting window scaling).; Use IsValid() to check the validity of the; server socket. In case server socket is not valid use GetErrorCode(); to obtain the specific error value. These values are:; 0 = no error (socket is valid); -1 = low level socket() call failed; -2 = low level bind() call failed; -3 = low level listen() call failed; Every valid server socket is added to the TROOT sockets list which; will make sure that any open sockets are properly closed on; program termination. TSocket * Accept(UChar_t Opt = kSrvNoAuth); Accept a connection on a parallel server socket. Returns a full-duplex; parallel communication TPSocket object. If no pending connections are; present on the queue and nonblocking mode has not been enabled; with SetOption(kNoBlock,1) the call blocks until a connection is; present. The returned socket must be deleted by the user. The socket; is also added to the TROOT sockets list which will make sure that; any open sockets are properly closed on program termination.; In case of error 0 is returned and in case non-blocking I/O is; enabled and no connections are available -1 is returned. TPServerSocket(const TPServerSocket& ). void operator=(const TPServerSocket& ). virtual ~TPServerSocket(); { }. » Author: Fons Rademakers 19/1/2001 » Copyright (C) 1995-2001, Rene Brun and Fons Rademakers. *; » Last changed: root/net:$Id: TPServerSocket.h 23091 2008-04-09 15:04:27Z rdm $ » Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TPServerSocket.html:12961,queue,queue,12961,root/html532/TPServerSocket.html,https://root.cern,https://root.cern/root/html532/TPServerSocket.html,2,['queue'],['queue']
Performance,"ocket(TSocket* s = 0). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TKSocket::EEncodingkNone; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TKSocket::EEncodingkPriv; static TKSocket::EEncodingkSafe; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. krb5_auth_contextfAuthContextper connection kerberos authentication context; krb5_principalfServerserver principal; TSocket*fSocketunderlying socket; static krb5_ccachefgCCDefshared default credential cache; static krb5_principalfgClientclient principal; static krb5_contextfgContextshared kerberos context. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TKSocket(TSocket* s = 0); Constructor. ~TKSocket(); Destructor. TKSocket * Connect(const char* server, Int_t port); Connect to 'server' on 'port'. Int_t BlockRead(char*& buf, TKSocket::EEncoding& type); Read block on information from server. The result is stored in buf.; The number of read bytes is returned; -1 is returned in case of error. Int_t BlockWrite(const char* buf, Int_t len, TKSocket::EEncoding type); Block-send 'length' bytes to server from 'buf'. TKSocket(TSocket* s = 0). » Last changed: root/krb5auth:$Id$ » Last generated: 2015-06-02 16:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TKSocket.html:6035,cache,cache,6035,root/html604/TKSocket.html,https://root.cern,https://root.cern/root/html604/TKSocket.html,2,['cache'],['cache']
Performance,"ocket(TSocket* s = 0). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TKSocket::EEncodingkNone; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TKSocket::EEncodingkPriv; static TKSocket::EEncodingkSafe; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. krb5_auth_contextfAuthContextper connection kerberos authentication context; krb5_principalfServerserver principal; TSocket*fSocketunderlying socket; static krb5_ccachefgCCDefshared default credential cache; static krb5_principalfgClientclient principal; static krb5_contextfgContextshared kerberos context. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TKSocket(TSocket* s = 0); Constructor. ~TKSocket(); Destructor. TKSocket * Connect(const char* server, Int_t port); Connect to 'server' on 'port'. Int_t BlockRead(char*& buf, TKSocket::EEncoding& type); Read block on information from server. The result is stored in buf.; The number of read bytes is returned; -1 is returned in case of error. Int_t BlockWrite(const char* buf, Int_t len, TKSocket::EEncoding type); Block-send 'length' bytes to server from 'buf'. TKSocket(TSocket* s = 0). » Last changed: root/krb5auth:$Id$ » Last generated: 2015-06-30 15:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TKSocket.html:6035,cache,cache,6035,root/html602/TKSocket.html,https://root.cern,https://root.cern/root/html602/TKSocket.html,2,['cache'],['cache']
Performance,ocol; TChain A chain of TTrees; TChainElement A chain element; TChainIndex A Tree Index with majorname and minorname.; TChainIndex::TChainIndexEntry ; TChair A base class to provide a user custom interface to TTable class objects; TCint Interface to CINT C/C++ interpreter; TClass Dictionary containing class information; TClassDocInfo info cache for class documentation; TClassDocOutput generates documentation web pages for a class; TClassEdit ; TClassGenerator interface for TClass generators; TClassMenuItem One element of the class context menu; TClassRef ; TClassStreamer ; TClassTable Table of known classes; TClassTree Manager class to draw classes inheritance tree and relations; TClonesArray An array of clone objects; TCollection Collection abstract base class; TCollectionClassStreamer ; TCollectionMemberStreamer ; TCollectionMethodBrowsable Helper object to browse a collection's methods; TCollectionPropertyBrowsable Helper object to add browsable collection properties; TCollectionProxyFactory ; TCollectionStreamer ; TColor Color defined by RGB or HLS; TColorWheel The ROOT Color Wheel; TColumnView Helper to represent one TTable column; TComplex Complex Class; TCondition Condition variable class; TConditionImp Condition variable implementation ABC; TCondor Interface to the Condor System; TCondorSlave Describes a claimed slave; TConfidenceLevel output for TLimit functions; TContextMenu Context sensitive popup menu; TContextMenuImp Context sensitive popup menu implementation; TControlBar Control bar; TControlBarButton The Control bar button; TControlBarImp GUI independent controlbar abc; TCrown A crown or segment of crown; TCurlyArc A curly arc; TCurlyArcEditor GUI for editing arrow attributes; TCurlyLine A curly polyline; TCurlyLineEditor GUI for editing arrow attributes; TCut A specialized string object used for TTree selections; TCutG A Graphical cut.; TDCacheFile A ROOT file that reads/writes via a dCache server; TDCacheSystem Directory handler for DCache; TDNDData,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html524/ClassIndex.html:49858,cache,cache,49858,root/html524/ClassIndex.html,https://root.cern,https://root.cern/root/html524/ClassIndex.html,3,['cache'],['cache']
Performance,"oc . Definition at line 34 of file TGeoBranchArray.h. Constructor & Destructor Documentation. ◆ TGeoBranchArray() [1/3]. TGeoBranchArray::TGeoBranchArray ; (; Int_t ; level). private . Constructor. Allocates the array with a size given by level. ; Definition at line 41 of file TGeoBranchArray.cxx. ◆ TGeoBranchArray() [2/3]. TGeoBranchArray::TGeoBranchArray ; (; const TGeoBranchArray & ; other). private . Copy constructor. Not callable anymore. Use TGeoBranchArray::MakeCopy instead. ; Definition at line 156 of file TGeoBranchArray.cxx. ◆ TGeoBranchArray() [3/3]. TGeoBranchArray::TGeoBranchArray ; (; TRootIOCtor * ; ). inline . Definition at line 39 of file TGeoBranchArray.h. ◆ ~TGeoBranchArray(). TGeoBranchArray::~TGeoBranchArray ; (; ). inlineoverride . Definition at line 88 of file TGeoBranchArray.h. Member Function Documentation. ◆ AddLevel(). void TGeoBranchArray::AddLevel ; (; Int_t ; dindex). Add and extra daughter to the current path array. No validity check performed ! ; Definition at line 183 of file TGeoBranchArray.cxx. ◆ BinarySearch(). Long64_t TGeoBranchArray::BinarySearch ; (; Long64_t ; n, . const TGeoBranchArray ** ; array, . TGeoBranchArray * ; value . ). static . Binary search in an array of n pointers to branch arrays, to locate value. ; Returns element index or index of nearest element smaller than value ; Definition at line 275 of file TGeoBranchArray.cxx. ◆ Class(). static TClass * TGeoBranchArray::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TGeoBranchArray::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TGeoBranchArray::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 116 of file TGeoBranchArray.h. ◆ CleanMatrix(). void TGeoBranchArray::CleanMatrix ; (; ). Garbage collect the stored matrix. ; Definition at line 323 of file TGeoBranchArray.cxx. ◆ Compare(). Int_t TGeoBranchArray::Compare ; (; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoBranchArray.html:15245,perform,performed,15245,doc/master/classTGeoBranchArray.html,https://root.cern,https://root.cern/doc/master/classTGeoBranchArray.html,1,['perform'],['performed']
Performance,"od = methods->begin();; 332 for (; itrMethod != methods->end(); ++itrMethod) {; 333 Log() << kDEBUG << ""Delete method: "" << (*itrMethod)->GetName() << Endl;; 334 delete (*itrMethod);; 335 }; 336 methods->clear();; 337 delete methods;; 338 }; 339}; 340 ; 341////////////////////////////////////////////////////////////////////////////////; 342 ; 343void TMVA::Factory::SetVerbose(Bool_t v); 344{; 345 fVerbose = v;; 346}; 347 ; 348////////////////////////////////////////////////////////////////////////////////; 349/// Book a classifier or regression method.; 350 ; 351TMVA::MethodBase *; 352TMVA::Factory::BookMethod(TMVA::DataLoader *loader, TString theMethodName, TString methodTitle, TString theOption); 353{; 354 if (fModelPersistence); 355 gSystem->MakeDirectory(loader->GetName()); // creating directory for DataLoader output; 356 ; 357 TString datasetname = loader->GetName();; 358 ; 359 if (fAnalysisType == Types::kNoAnalysisType) {; 360 if (loader->GetDataSetInfo().GetNClasses() == 2 && loader->GetDataSetInfo().GetClassInfo(""Signal"") != NULL &&; 361 loader->GetDataSetInfo().GetClassInfo(""Background"") != NULL) {; 362 fAnalysisType = Types::kClassification; // default is classification; 363 } else if (loader->GetDataSetInfo().GetNClasses() >= 2) {; 364 fAnalysisType = Types::kMulticlass; // if two classes, but not named ""Signal"" and ""Background""; 365 } else; 366 Log() << kFATAL << ""No analysis type for "" << loader->GetDataSetInfo().GetNClasses() << "" classes and ""; 367 << loader->GetDataSetInfo().GetNTargets() << "" regression targets."" << Endl;; 368 }; 369 ; 370 // booking via name; the names are translated into enums and the; 371 // corresponding overloaded BookMethod is called; 372 ; 373 if (fMethodsMap.find(datasetname) != fMethodsMap.end()) {; 374 if (GetMethod(datasetname, methodTitle) != 0) {; 375 Log() << kFATAL << ""Booking failed since method with title <"" << methodTitle << ""> already exists ""; 376 << ""in with DataSet Name <"" << loader->GetName() << ""> "" << Endl;;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html:14131,load,loader,14131,doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,1,['load'],['loader']
Performance,"od) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidaddToRange(const char* rangeName, const char* stateNameList); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidclearRange(const char* name, Bool_t silent); voidRooAbsArg::clearShapeDirty() const; voidclearTypes(); voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Cop",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooCategory.html:1684,Cache,CacheModeRooAbsArg,1684,root/html534/RooCategory.html,https://root.cern,https://root.cern/root/html534/RooCategory.html,1,['Cache'],['CacheModeRooAbsArg']
Performance,"od) const; TDirectory*TMVA::MethodBase::MethodBaseDir() const; TMVA::MethodPDERSMethodPDERS(TMVA::DataSetInfo& theData, const TString& theWeightFile, TDirectory* theTargetDir = NULL); TMVA::MethodPDERSMethodPDERS(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption, TDirectory* theTargetDir = 0); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TMVA::IMethod&TMVA::IMethod::operator=(const TMVA::IMethod&); virtual map<TString,Double_t>TMVA::MethodBase::OptimizeTuningParameters(TString fomType = ""ROCIntegral"", TString fitType = ""FitGA""); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTMVA::Configurable::ParseOptions(); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual voidTMVA::MethodBase::PrintHelpMessage() const; voidTMVA::Configurable::PrintOptions() const; voidTMVA::MethodBase::ProcessSetup(); virtual Int_tTObject::Read(const char* name); voidTMVA::Configurable::ReadOptionsFromStream(istream& istr); voidTMVA::Configurable::ReadOptionsFromXML(void* node); voidTMVA::MethodBase::ReadStateFromFile(); voidTMVA::MethodBase::ReadStateFromStream(istream& tf); voidTMVA::MethodBase::ReadStateFromStream(TFile& rf); voidTMVA::MethodBase::ReadStateFromXMLString(const char* xmlstr); virtual voidReadWeightsFromStream(istream& istr); virtual voidReadWeightsFromStream(TFile& istr); virtual voidReadWeightsFromXML(void* wghtnode); virtual voidTObject::RecursiveRemove(TObject* obj); voidTMVA::MethodBase::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__MethodPDERS.html:10510,Optimiz,OptimizeTuningParameters,10510,root/html534/TMVA__MethodPDERS.html,https://root.cern,https://root.cern/root/html534/TMVA__MethodPDERS.html,1,['Optimiz'],['OptimizeTuningParameters']
Performance,"od) const; static voidRooPrintable::nameFieldLength(Int_t newLen); virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual TStringoperator TString(); virtual RooAbsArg&operator=(const char* newValue); Bool_tRooAbsString::operator==(const char*) const; virtual Bool_tRooAbsString::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidRooAbsArg::Print(Option_t* options = 0) const; virtual voidRooAbsArg::printAddress(ostream& os) const; virtual voidRooAbsArg::printArgs(ostream& os) const; virtual voidRooAbsArg::printClassName(ostream& os) const; voidRooAbsArg::printCompactTree(const char* indent = """", const char* fileName = 0, const char* namePat = 0, RooAbsArg* client = 0); voidRooAbsArg::printCompactTree(ostream& os, const char* indent = """", const char* namePat = 0, RooAbsArg* client = 0); virtual voidRooAbsArg::printCompactTreeHook(ostream& os, const char* ind = """"); voidRooAbsArg::printComponentTree(const char* indent = """", con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooStringVar.html:9269,optimiz,optimizeCacheMode,9269,root/html526/RooStringVar.html,https://root.cern,https://root.cern/root/html526/RooStringVar.html,2,['optimiz'],['optimizeCacheMode']
Performance,"od; will be used as the extension (instead of 'h') and the left side; will be used as the classname. ""macrofilename"" and optionally ""cutfilename"" are expected to point; to source file which will be included in by the generated skeletong.; Method of the same name as the file(minus the extension and path); will be called by the generated skeleton's Process method as follow:; [if (cutfilename())] htemp->Fill(macrofilename());. ""option"" can be used select some of the optional features during; the code generation. The possible options are:; nohist : indicates that the generated ProcessFill should not; fill the histogram. 'maxUnrolling' controls how deep in the class hierarchy does the; system 'unroll' class that are not split. 'unrolling' a class; will allow direct access to its data members a class (this; emulates the behavior of TTreeFormula). The main features of this skeleton are:. * on-demand loading of branches; * ability to use the 'branchname' as if it was a data member; * protection against array out-of-bound; * ability to use the branch data as object (when the user code is available). For example with Event.root, if; Double_t somepx = fTracks.fPx[2];; is executed by one of the method of the skeleton,; somepx will be updated with the current value of fPx of the 3rd track. Both macrofilename and the optional cutfilename are expected to be; the name of source files which contain at least a free standing; function with the signature:; x_t macrofilename(); // i.e function with the same name as the file; and; y_t cutfilename(); // i.e function with the same name as the file. x_t and y_t needs to be types that can convert respectively to a double; and a bool (because the skeleton uses:; if (cutfilename()) htemp->Fill(macrofilename());. This 2 functions are run in a context such that the branch names are; available as local variables of the correct (read-only) type. Note that if you use the same 'variable' twice, it is more efficient; to 'cache' the value. For example",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TTreePlayer.html:18144,load,loading,18144,root/html530/TTreePlayer.html,https://root.cern,https://root.cern/root/html530/TTreePlayer.html,9,['load'],['loading']
Performance,"od;; 71 class MethodBase;; 72 class DataInputHandler;; 73 class DataSetInfo;; 74 class DataSetManager;; 75 class DataLoader;; 76 class ROCCurve;; 77 class VariableTransformBase;; 78 ; 79 ; 80 class Factory : public Configurable {; 81 friend class CrossValidation;; 82 public:; 83 ; 84 typedef std::vector<IMethod*> MVector;; 85 std::map<TString,MVector*> fMethodsMap;//all methods for every dataset with the same name; 86 ; 87 // no default constructor; 88 Factory( TString theJobName, TFile* theTargetFile, TString theOption = """" );; 89 ; 90 // constructor to work without file; 91 Factory( TString theJobName, TString theOption = """" );; 92 ; 93 // default destructor; 94 virtual ~Factory();; 95 ; 96 // use TName::GetName and define correct name in constructor; 97 //virtual const char* GetName() const { return ""Factory""; }; 98 ; 99 ; 100 MethodBase* BookMethod( DataLoader *loader, TString theMethodName, TString methodTitle, TString theOption = """" );; 101 MethodBase* BookMethod( DataLoader *loader, Types::EMVA theMethod, TString methodTitle, TString theOption = """" );; 102 MethodBase* BookMethod( DataLoader *, TMVA::Types::EMVA /*theMethod*/,; 103 TString /*methodTitle*/,; 104 TString /*methodOption*/,; 105 TMVA::Types::EMVA /*theComposite*/,; 106 TString /*compositeOption = """"*/ ) { return nullptr; }; 107 ; 108 // optimize all booked methods (well, if desired by the method); 109 std::map<TString,Double_t> OptimizeAllMethods (TString fomType=""ROCIntegral"", TString fitType=""FitGA"");; 110 void OptimizeAllMethodsForClassification(TString fomType=""ROCIntegral"", TString fitType=""FitGA"") { OptimizeAllMethods(fomType,fitType); }; 111 void OptimizeAllMethodsForRegression (TString fomType=""ROCIntegral"", TString fitType=""FitGA"") { OptimizeAllMethods(fomType,fitType); }; 112 ; 113 // training for all booked methods; 114 void TrainAllMethods ();; 115 void TrainAllMethodsForClassification( void ) { TrainAllMethods(); }; 116 void TrainAllMethodsForRegression ( void ) { TrainAllMethods(); };",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva_2tmva_2inc_2TMVA_2Factory_8h_source.html:3734,load,loader,3734,doc/master/tmva_2tmva_2inc_2TMVA_2Factory_8h_source.html,https://root.cern,https://root.cern/doc/master/tmva_2tmva_2inc_2TMVA_2Factory_8h_source.html,1,['load'],['loader']
Performance,"odFisherMethodFisher(TMVA::DataSetInfo& dsi, const TString& theWeightFile, TDirectory* theTargetDir = NULL); TMVA::MethodFisherMethodFisher(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& dsi, const TString& theOption = ""Fisher"", TDirectory* theTargetDir = 0); virtual Bool_tTMVA::MethodBase::MonitorBoost(TMVA::MethodBoost*); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TMVA::IMethod&TMVA::IMethod::operator=(const TMVA::IMethod&); virtual map<TString,Double_t>TMVA::MethodBase::OptimizeTuningParameters(TString fomType = ""ROCIntegral"", TString fitType = ""FitGA""); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTMVA::Configurable::ParseOptions(); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual voidTMVA::MethodBase::PrintHelpMessage() const; voidTMVA::Configurable::PrintOptions() const; voidTMVA::MethodBase::ProcessSetup(); virtual Int_tTObject::Read(const char* name); voidTMVA::Configurable::ReadOptionsFromStream(istream& istr); voidTMVA::Configurable::ReadOptionsFromXML(void* node); voidTMVA::MethodBase::ReadStateFromFile(); voidTMVA::MethodBase::ReadStateFromStream(istream& tf); voidTMVA::MethodBase::ReadStateFromStream(TFile& rf); voidTMVA::MethodBase::ReadStateFromXMLString(const char* xmlstr); virtual voidReadWeightsFromStream(istream& i); virtual voidReadWeightsFromXML(void* wghtnode); virtual voidTObject::RecursiveRemove(TObject* obj); voidTMVA::MethodBase::RerouteTransformationHandler(TMVA::TransformationHa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMVA__MethodFisher.html:11221,Optimiz,OptimizeTuningParameters,11221,root/html532/TMVA__MethodFisher.html,https://root.cern,https://root.cern/root/html532/TMVA__MethodFisher.html,1,['Optimiz'],['OptimizeTuningParameters']
Performance,"odLikelihoodMethodLikelihood(const TMVA::MethodLikelihood&); TMVA::MethodLikelihoodMethodLikelihood(TMVA::DataSetInfo& theData, const TString& theWeightFile, TDirectory* theTargetDir = __null); TMVA::MethodLikelihoodMethodLikelihood(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = """", TDirectory* theTargetDir = 0); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TMVA::MethodLikelihood&operator=(const TMVA::MethodLikelihood&); virtual map<TString,Double_t>TMVA::MethodBase::OptimizeTuningParameters(TString fomType = ""ROCIntegral"", TString fitType = ""FitGA""); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTMVA::Configurable::ParseOptions(); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual voidTMVA::MethodBase::PrintHelpMessage() const; voidTMVA::Configurable::PrintOptions() const; voidTMVA::MethodBase::ProcessSetup(); virtual Int_tTObject::Read(const char* name); voidTMVA::Configurable::ReadOptionsFromStream(istream& istr); voidTMVA::Configurable::ReadOptionsFromXML(void* node); voidTMVA::MethodBase::ReadStateFromFile(); voidTMVA::MethodBase::ReadStateFromStream(istream& tf); voidTMVA::MethodBase::ReadStateFromStream(TFile& rf); voidTMVA::MethodBase::ReadStateFromXMLString(const char* xmlstr); virtual voidReadWeightsFromStream(istream& istr); virtual voidReadWeightsFromStream(TFile& istr); virtual voidReadWeightsFromXML(void* wghtnode); virtual voidTObject::RecursiveRemove(TObject* obj); voidTMVA::MethodBase::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__MethodLikelihood.html:12056,Optimiz,OptimizeTuningParameters,12056,root/html602/TMVA__MethodLikelihood.html,https://root.cern,https://root.cern/root/html602/TMVA__MethodLikelihood.html,2,['Optimiz'],['OptimizeTuningParameters']
Performance,odMLP. TMVA::MethodBDT. TMVA::MethodBase←. TMVA::MethodANNBase; ←. TMVA::MethodMLP. TMVA::MethodBDT. TMVA::MethodBayesClassifier. TMVA::MethodCFMlpANN. TMVA::MethodCompositeBase; ←. TMVA::MethodBoost. TMVA::MethodCategory. TMVA::MethodCuts. TMVA::MethodDT. TMVA::MethodFDA. TMVA::MethodFisher. TMVA::MethodHMatrix. TMVA::MethodKNN. TMVA::MethodLD. TMVA::MethodLikelihood. TMVA::MethodPDEFoam. TMVA::MethodPDERS. TMVA::MethodRuleFit. TMVA::MethodSVM. TMVA::MethodTMlpANN. TMVA::MethodBayesClassifier. TMVA::MethodBoost. TMVA::MethodCFMlpANN. TMVA::MethodCategory. TMVA::MethodCompositeBase←. TMVA::MethodBoost. TMVA::MethodCategory. TMVA::MethodCuts. TMVA::MethodDT. TMVA::MethodFDA. TMVA::MethodFisher. TMVA::MethodHMatrix. TMVA::MethodKNN. TMVA::MethodLD. TMVA::MethodLikelihood. TMVA::MethodMLP. TMVA::MethodPDEFoam. TMVA::MethodPDERS. TMVA::MethodRuleFit. TMVA::MethodSVM. TMVA::MethodTMlpANN. TMVA::MinuitFitter. TMVA::MinuitWrapper. TMVA::MisClassificationError. TMVA::MsgLogger. TMVA::OptimizeConfigParameters. TMVA::PDEFoam←. TMVA::PDEFoamDiscriminant; ←. TMVA::PDEFoamDecisionTree. TMVA::PDEFoamEvent; ←. TMVA::PDEFoamMultiTarget. TMVA::PDEFoamTarget. TMVA::PDEFoamCell. TMVA::PDEFoamDecisionTree. TMVA::PDEFoamDecisionTreeDensity. TMVA::PDEFoamDensityBase←. TMVA::PDEFoamDecisionTreeDensity. TMVA::PDEFoamDiscriminantDensity. TMVA::PDEFoamEventDensity. TMVA::PDEFoamTargetDensity. TMVA::PDEFoamDiscriminant←. TMVA::PDEFoamDecisionTree. TMVA::PDEFoamDiscriminantDensity. TMVA::PDEFoamEvent←. TMVA::PDEFoamMultiTarget. TMVA::PDEFoamEventDensity. TMVA::PDEFoamKernelBase←. TMVA::PDEFoamKernelGauss. TMVA::PDEFoamKernelLinN. TMVA::PDEFoamKernelTrivial. TMVA::PDEFoamKernelGauss. TMVA::PDEFoamKernelLinN. TMVA::PDEFoamKernelTrivial. TMVA::PDEFoamMultiTarget. TMVA::PDEFoamTarget. TMVA::PDEFoamTargetDensity. TMVA::PDEFoamVect. TMVA::PDF. TMVA::Reader. TMVA::RootFinder. TMVA::SdivSqrtSplusB. TMVA::SimulatedAnnealingFitter. TMVA::TActivationIdentity. TMVA::TActivationRadial. TMVA::TActivationSig,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ClassHierarchy.html:75900,Optimiz,OptimizeConfigParameters,75900,root/html534/ClassHierarchy.html,https://root.cern,https://root.cern/root/html534/ClassHierarchy.html,2,['Optimiz'],['OptimizeConfigParameters']
Performance,"ode == 1:; # Instruct model to precalculate normalization integral that integrate at least; # two dimensions numerically. In self specific case the integral value for; # all values of parameter 'a' are stored in a histogram and available for use; # in subsequent fitting and plotting operations (interpolation is; # applied); ; # w.pdf(""model"").setNormValueCaching(3); model = w[""model""]; model.setStringAttribute(""CACHEPARMINT"", ""x:y:z""); ; # Evaluate pdf once to trigger filling of cache; normSet = {w[""x""], w[""y""], w[""z""]}; model.getVal(normSet); w.writeToFile(""rf903_numintcache.root""); ; if mode == 2:; # Load preexisting workspace from file in mode==2; f = ROOT.TFile(""rf903_numintcache.root""); w = f.Get(""w""); ; # Return created or loaded workspace; return w; ; ; mode = 0; # Mode = 0 : Run plain fit (slow); # Mode = 1 : Generate workspace with precalculated integral and store it on file (prepare for accelerated running); # Mode = 2 : Run fit from previously stored workspace including cached; # integrals (fast, run in mode=1 first); ; # Create, save or load workspace with pdf; # -----------------------------------------------------------------------------------; ; # Make/load workspace, here in mode 1; w = getWorkspace(mode); if mode == 1:; # Show workspace that was created; w.Print(); ; # Show plot of cached integral values; hhcache = w.expensiveObjectCache().getObj(1); if hhcache:; ROOT.TCanvas(""rf903_numintcache"", ""rf903_numintcache"", 600, 600); hhcache.createHistogram(""a"").Draw(); else:; ROOT.RooFit.Error(""rf903_numintcache"", ""Cached histogram is not existing in workspace""); sys.exit(); ; # Use pdf from workspace for generation and fitting; # -----------------------------------------------------------------------------------; ; # ROOT.This is always slow (need to find maximum function value; # empirically in 3D space); model = w[""model""]; d = model.generate({w[""x""], w[""y""], w[""z""]}, 1000); ; # ROOT.This is slow in mode 0, fast in mode 1; model.fitTo(d, Verbose=True, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf903__numintcache_8py.html:1826,load,loaded,1826,doc/master/rf903__numintcache_8py.html,https://root.cern,https://root.cern/doc/master/rf903__numintcache_8py.html,4,"['cache', 'load']","['cached', 'load', 'loaded']"
Performance,"ode Return 0 on success, -1 on error. ;  ; Int_t RunDataSet (const char *dset=""BenchDataSet"", Int_t start=1, Int_t stop=-1, Int_t step=1);  Perform a test using dataset 'dset' Return 0 on success, -1 on error Open the file for the results. ;  ; Int_t RunDataSetx (const char *dset=""BenchDataSet"", Int_t start=1, Int_t stop=-1);  Perform a test using dataset 'dset' scanning over the number of workers per node. ;  ; void SetCPUPar (const char *par);  ; void SetCPUSel (const char *sel);  ; void SetDataGenPar (const char *par);  ; void SetDataGenSel (const char *sel);  ; void SetDataPar (const char *par);  ; void SetDataSel (const char *sel);  ; void SetDebug (Bool_t debug=kTRUE);  ; void SetHistType (TPBHistType *histtype);  ; void SetNFilesWrk (Int_t nf=0);  ; void SetNHist (Int_t nh);  ; void SetNTries (Int_t nt);  ; Int_t SetOutFile (const char *outfile, Bool_t verbose=kTRUE);  Set the output file Return 0 on success, -1 on error. ;  ; void SetProofDS (TProof *p);  Set the PROOF instance to be used for dataset operations, like releasing cache ... Use SetProofDS(0) to reset and using the default PROOF. ;  ; void SetReadType (TPBReadType *readtype);  ; void SetReleaseCache (Bool_t on=kTRUE);  ; void SetSelOption (const char *opt);  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofBench.html:2845,cache,cache,2845,doc/master/classTProofBench.html,https://root.cern,https://root.cern/doc/master/classTProofBench.html,1,['cache'],['cache']
Performance,ode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooAbsReal*RooAbsTestStatistic::_funcPointer to original input function; RooAbsReal*_funcClonePointer to internal clone of input function; RooArgSet*_funcCloneSetSet owning all components of internal clone of input function; RooArgSet*_funcObsSetList of observables in the pdf expression; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; pRooAbsTestStatistic*RooAbsTestStatistic::_gofArray! Array of sub-contexts representing part of the combined test statistic; RooAbsTestStatistic::GOFOpModeRooAbsTestStatistic::_gofOpModeOperation mode of test statistic instance; vector<RooFit::MPSplit>RooAbsTestStatistic::_gofSplitMode! GOF MP Split mode specified by component (when Auto is active); static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Bool_tRooAbsTestStatistic::_init! Is object initialized; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; pRooRealMPFE*RooAbsTestStatistic::_mpfeArray! Array of parallel execution frond ends; RooFit::MPSplitRooAbsTestStatistic::_mpinterlUse interleaving strategy rather than N-wise split for partioning of dataset for multiprocessor-split; Int_tRooAbsTestStatistic::_nCPUNumber of processors to use in parallel calculation mode; Int_tRooAbsTestStatistic::_nEventsTotal number of events in test statistic calculation; Int_tRooAbsTestStatistic::_nGofNumber of sub-contexts; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsOptTestStatistic.html:39834,cache,cache,39834,root/html602/RooAbsOptTestStatistic.html,https://root.cern,https://root.cern/root/html602/RooAbsOptTestStatistic.html,6,"['Cache', 'cache']","['Cached', 'cache']"
Performance,"ode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; virtual voidShowMembers(TMemberInspector& insp); RooMoment*RooAbsReal::sigma(RooRealVar& obs); RooMoment*RooAbsReal::sigma(RooRealVar& obs, const RooArgSet& nset); virtual Int_tTNamed::Sizeof() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig(Bool_t createOnTheFly); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); const map<std::string,std::string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; const set<std::string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidRooAbsHiddenReal::writeToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooUnblindCPAsymVar.html:24787,cache,cache,24787,root/html528/RooUnblindCPAsymVar.html,https://root.cern,https://root.cern/root/html528/RooUnblindCPAsymVar.html,8,['cache'],['cache']
Performance,"ode(). double RooStats::BayesianCalculator::GetMode ; (; ); const. return the mode (most probable value of the posterior function) ; Returns the value of the parameter for the point in parameter-space that is the most likely.; How do we do if there are points that are equi-probable? use approximate posterior t.b.d use real function to find the mode ; Definition at line 1183 of file BayesianCalculator.cxx. ◆ GetPosteriorFunction(). RooAbsReal * RooStats::BayesianCalculator::GetPosteriorFunction ; (; ); const. return posterior function (object is managed by the BayesianCalculator class) ; Build and return the posterior function (not normalized) as a RooAbsReal the posterior is obtained from the product of the likelihood function and the prior pdf which is then integrated in the nuisance parameters (if existing).; A prior function for the nuisance can be specified either in the prior pdf object or in the model itself. If no prior nuisance is specified, but prior parameters are then the integration is performed assuming a flat prior for the nuisance parameters.; NOTE: the return object is managed by the BayesianCalculator class, users do not need to delete it, but the object will be deleted when the BayesiabCalculator object is deleted ; Definition at line 769 of file BayesianCalculator.cxx. ◆ GetPosteriorHistogram(). TH1 * RooStats::BayesianCalculator::GetPosteriorHistogram ; (; ); const. return the approximate posterior as histogram (TH1 object). Note the object is managed by the BayesianCalculator class ; When am approximate posterior is computed binninig the parameter of interest (poi) range (see SetScanOfPosteriors) an histogram is created and can be returned to the user A nullptr is instead returned when the posterior is computed without binning the poi.; NOTE: the returned object is managed by the BayesianCalculator class, if the user wants to take ownership of the returned histogram, he needs to clone or copy the return object. ; Definition at line 991 of file Ba",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooStats_1_1BayesianCalculator.html:26737,perform,performed,26737,doc/master/classRooStats_1_1BayesianCalculator.html,https://root.cern,https://root.cern/doc/master/classRooStats_1_1BayesianCalculator.html,1,['perform'],['performed']
Performance,"ode, const char* rangeName = 0) const; virtual Double_tRooAbsCachedPdf::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); Double_tbufferFraction() const; RooFFTConvPdf::BufStratbufferStrategy() const; const RooArgSet&cacheObservables() const; virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooFFTConvPdf.html:6766,cache,cacheObservables,6766,root/html534/RooFFTConvPdf.html,https://root.cern,https://root.cern/root/html534/RooFFTConvPdf.html,2,['cache'],['cacheObservables']
Performance,"ode, const char* rangeName = 0) const; virtual Double_tanalyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attributes() const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tcoefAnalyticalIntegral(Int_t coef, Int_t code, const char* r",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsAnaConvPdf.html:3740,Cache,CacheModeRooAbsArg,3740,root/html602/RooAbsAnaConvPdf.html,https://root.cern,https://root.cern/root/html602/RooAbsAnaConvPdf.html,1,['Cache'],['CacheModeRooAbsArg']
Performance,"ode, const char* rangeName = 0) const; virtual Double_tanalyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attributes() const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRoo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsCachedPdf.html:2840,Cache,CacheModeRooAbsArg,2840,root/html602/RooAbsCachedPdf.html,https://root.cern,https://root.cern/root/html602/RooAbsCachedPdf.html,2,['Cache'],['CacheModeRooAbsArg']
Performance,"ode, const char* rangeName = 0) const; virtual Double_tanalyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attributes() const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooEffProd.html:2279,Cache,CacheModeRooAbsArg,2279,root/html602/RooEffProd.html,https://root.cern,https://root.cern/root/html602/RooEffProd.html,8,['Cache'],['CacheModeRooAbsArg']
Performance,"ode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction4Ref<double,double,double,double,double>funcFunction pointer reference; RooRealProxywArgument reference; RooRealProxyxArgument reference; RooRealProxyyArgument reference; RooRealProxyzArgument reference.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooCFunction4PdfBinding_double_double_double_double_double_.html:40528,cache,cache,40528,root/html532/RooCFunction4PdfBinding_double_double_double_double_double_.html,https://root.cern,https://root.cern/root/html532/RooCFunction4PdfBinding_double_double_double_double_double_.html,2,['cache'],['cache']
Performance,"odeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction3Ref<double,unsigned int,double,unsigned int>funcFunction pointer reference; RooRealProxyxArgument reference; RooRealProxyyArgument reference; RooRealProxyzArgument reference.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooCFunction3PdfBinding_double_unsigned_int_double_unsigned_int_.html:40544,cache,cache,40544,root/html532/RooCFunction3PdfBinding_double_unsigned_int_double_unsigned_int_.html,https://root.cern,https://root.cern/root/html532/RooCFunction3PdfBinding_double_unsigned_int_double_unsigned_int_.html,2,['cache'],['cache']
Performance,"odeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction3Ref<double,unsigned int,unsigned int,double>funcFunction pointer reference; RooRealProxyxArgument reference; RooRealProxyyArgument reference; RooRealProxyzArgument reference.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooCFunction3PdfBinding_double_unsigned_int_unsigned_int_double_.html:40544,cache,cache,40544,root/html532/RooCFunction3PdfBinding_double_unsigned_int_unsigned_int_double_.html,https://root.cern,https://root.cern/root/html532/RooCFunction3PdfBinding_double_unsigned_int_unsigned_int_double_.html,2,['cache'],['cache']
Performance,"odeHook(RooAbsArg::OperMode); virtual voidoptimizeCacheMode(const RooArgSet& obs, RooArgSet& optNodes, RooLinkedList& processedNodes); virtual voidprintCompactTreeHook(ostream&, const char*, Int_t curElem, Int_t totElem); virtual Bool_tredirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidsetOwner(RooAbsArg* owner); virtual voidShowMembers(TMemberInspector& insp, char* parent); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; public:. enum Action { OperModeChange; OptimizeCaching; FindConstantNodes; };. protected:. RooAbsArg*_owner! Pointer to owning RooAbsArg. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Interface for server redirect calls. void printCompactTreeHook(ostream& , const char* , Int_t curElem, Int_t totElem); Hook function to print cache guts in tree printing mode of RooAbsArgs. void operModeHook(RooAbsArg::OperMode ); Interface for operation mode change calls. void optimizeCacheMode(const RooArgSet& obs, RooArgSet& optNodes, RooLinkedList& processedNodes); Interface for cache optimization calls. The default implementation is to forward all these; calls to all contained RooAbsArg objects as publicized through containedArg(). void findConstantNodes(const RooArgSet& obs, RooArgSet& cacheList, RooLinkedList& processedNodes); Interface for constant term optimization calls. The default implementation is to forward all these; calls to all contained RooAbsArg objects as publicized through containedArg(). virtual ~RooAbsCacheElement(); Destructor. RooArgList containedArgs(RooAbsCacheElement::Action ). void setOwner(RooAbsArg* owner); Store pointer to owner. » Last changed: Mon Dec 7 13:45:32 2009 » Last generated: 2009-12-07 13:45; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsCacheElement.html:2140,optimiz,optimizeCacheMode,2140,root/html526/RooAbsCacheElement.html,https://root.cern,https://root.cern/root/html526/RooAbsCacheElement.html,5,"['cache', 'optimiz']","['cache', 'cacheList', 'optimization', 'optimizeCacheMode']"
Performance,"odel); // times a Gaussian function the reconstructed mass; w->factory(""PROD::sig( BMixDecay::sig_t( dt[-20,20], mixState[mixed=1,unmix=-1], tagFlav[B0=1,B0bar=-1], ""; ""tau[1.54], dm[0.472], w[0.05], dw[0],""; ""AddModel::gm({GaussModel(dt,biasC[-10,10],sigmaC[0.1,3],dterr[0.01,0.2]),""; ""GaussModel(dt,0,sigmaT[3,10]),""; ""GaussModel(dt,0,20)},{fracC[0,1],fracT[0,1]}),""; ""DoubleSided ),""; ""Gaussian::sig_m( mes[5.20,5.30], mB0[5.20,5.30], sigmB0[0.01,0.05] ))"");; ; // Make background component: A plain decay function in t times an Argus function in the reconstructed mass; w->factory(""PROD::bkg( Decay::bkg_t( dt, tau, gm, DoubleSided),""; ""ArgusBG::bkg_m( mes, 5.291, k[-100,-10]))"");; ; // Make composite model from the signal and background component; w->factory(""SUM::model( Nsig[5000,0,10000]*sig, NBkg[500,0,10000]*bkg )"");; ; // E x a m p l e o f R o o S i m W S T o o l i n t e r f a c e; // ------------------------------------------------------------------; ; // Introduce a flavour tagging category tagCat as observable with 4 states corresponding; // to 4 flavour tagging techniques with different performance that require different; // parameterizations of the fit model; //; // RooSimWSTool operation:; // - Make 4 clones of model (for each tagCat) state, that will gain an individual; // copy of parameters w,dw and biasC. The other parameters remain common; // - Make a simultaneous pdf of the 4 clones assigning each to the appropriate; // state of the tagCat index category; ; // RooSimWSTool is interfaced as meta-type SIMCLONE in the factory. The $SplitParam(); // argument maps to the SplitParam() named argument in the RooSimWSTool constructor; w->factory(""SIMCLONE::model_sim( model, $SplitParam({w,dw,biasC},tagCat[Lep,Kao,NT1,NT2]))"");; ; // E x a m p l e o f R o o C u s t o m i z e r i n t e r f a c e; // -------------------------------------------------------------------; //; // Class RooCustomizer makes clones of existing pdfs with certain prescribed; // modifications ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf513__wsfactory__tools_8C.html:2046,perform,performance,2046,doc/master/rf513__wsfactory__tools_8C.html,https://root.cern,https://root.cern/doc/master/rf513__wsfactory__tools_8C.html,1,['perform'],['performance']
Performance,"odel_modelData' created with bounds [10,20]; [#1] INFO:Fitting -- RooAbsPdf::fitTo(extmodel) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_extmodel_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; RooRealVar::N = 3395.66 +/- 58.2751 L(0 - 20000) ; [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'fit_nll_model_modelData_LEFT' created with bounds [10,20]; [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'fit_nll_model_modelData_RIGHT' created with bounds [60,100]; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model_over_model_Int[x|LEFT,RIGHT]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_over_model_Int[x|LEFT,RIGHT]_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; ; RooFitResult: minimized FCN value: 14265.9, estimated distance to minimum: 1.48012e-07; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; alpha -3.9974e-02 +/- 5.60e-04; ; [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) p.d.f was fitted in a subrange and no explicit Range() and NormRange() was specified. Plotting / normalising in fit range. To override, do one of the following; - Clear the automatic fit range attribute: <pdf>.removeStringAttribute(""fitrange"");; - Explicitly specify the plotting range: ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf204b__extendedLikelihood__rangedFit_8C.html:11749,optimiz,optimization,11749,doc/master/rf204b__extendedLikelihood__rangedFit_8C.html,https://root.cern,https://root.cern/doc/master/rf204b__extendedLikelihood__rangedFit_8C.html,4,['optimiz'],['optimization']
Performance,"odes with names matching the pattern will be printed.; The client argument is used in recursive calls to properly display the value or shape nature; of the client-server links. It should be zero in calls initiated by users. void printComponentTree(const char* indent = """", const char* namePat = 0); Print tree structure of expression tree on given ostream, only branch nodes are printed.; Lead nodes (variables) will not be shown. If namePat is not ""*"", only nodes with names matching the pattern will be printed. TString cleanBranchName() const; Construct a mangled name from the actual name that; is free of any math symbols that might be interpreted by TTree. UInt_t crc32(const char* data); Calculate crc32 checksum on given string. void printCompactTreeHook(ostream& os, const char* ind = """"); Hook function interface for object to insert additional information; when printed in the context of a tree structure. This default; implementation prints nothing. void registerCache(RooAbsCache& cache); Register RooAbsCache with this object. This function is called; by RooAbsCache constructors for objects that are a datamember; of this RooAbsArg. By registering itself the RooAbsArg is aware; of all its cache data members and will forward server change; and cache mode change calls to the cache objects, which in turn; can forward them their contents. void unRegisterCache(RooAbsCache& cache); Unregister a RooAbsCache. Called from the RooAbsCache destructor. Int_t numCaches() const; Return number of registered caches. RooAbsCache* getCache(Int_t index) const; Return registered cache object by index. RooArgSet* getVariables(Bool_t stripDisconnected = kTRUE) const; Return RooArgSet with all variables (tree leaf nodes of expresssion tree). RooLinkedList getCloningAncestors() const; Return ancestors in cloning chain of this RooAbsArg. NOTE: Returned pointers; are not guaranteed to be 'live', so do not dereference without proper caution. void graphVizTree(const char* fileName, const char* del",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsArg.html:32741,cache,cache,32741,root/html526/RooAbsArg.html,https://root.cern,https://root.cern/root/html526/RooAbsArg.html,1,['cache'],['cache']
Performance,"odes); virtual TClass*IsA() const; RooAbsCacheElement&operator=(const RooAbsCacheElement&); virtual voidoperModeHook(RooAbsArg::OperMode); virtual voidoptimizeCacheMode(const RooArgSet& obs, RooArgSet& optNodes, RooLinkedList& processedNodes); virtual voidprintCompactTreeHook(ostream&, const char*, Int_t curElem, Int_t totElem); virtual Bool_tredirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidsetOwner(RooAbsArg* owner); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; public:. enum Action { OperModeChange; OptimizeCaching; FindConstantNodes; };. protected:. RooAbsArg*_owner! Pointer to owning RooAbsArg. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Interface for server redirect calls. void printCompactTreeHook(ostream& , const char* , Int_t curElem, Int_t totElem); Hook function to print cache guts in tree printing mode of RooAbsArgs. void operModeHook(RooAbsArg::OperMode ); Interface for operation mode change calls. void optimizeCacheMode(const RooArgSet& obs, RooArgSet& optNodes, RooLinkedList& processedNodes); Interface for cache optimization calls. The default implementation is to forward all these; calls to all contained RooAbsArg objects as publicized through containedArg(). void findConstantNodes(const RooArgSet& obs, RooArgSet& cacheList, RooLinkedList& processedNodes); Interface for constant term optimization calls. The default implementation is to forward all these; calls to all contained RooAbsArg objects as publicized through containedArg(). virtual ~RooAbsCacheElement(); Destructor. RooArgList containedArgs(RooAbsCacheElement::Action ). void setOwner(RooAbsArg* owner); Store pointer to owner. » Last changed: Mon Jul 4 15:21:17 2011 » Last generated: 2011-07-04 15:21; This page has been automatically generated. For comments or s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooAbsCacheElement.html:1989,cache,cache,1989,root/html530/RooAbsCacheElement.html,https://root.cern,https://root.cern/root/html530/RooAbsCacheElement.html,1,['cache'],['cache']
Performance,"odes); virtual TClass*IsA() const; RooAbsCacheElement&operator=(const RooAbsCacheElement&); virtual voidoperModeHook(RooAbsArg::OperMode); virtual voidoptimizeCacheMode(const RooArgSet& obs, RooArgSet& optNodes, RooLinkedList& processedNodes); virtual voidprintCompactTreeHook(ostream&, const char*, Int_t curElem, Int_t totElem); virtual Bool_tredirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidsetOwner(RooAbsArg* owner); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; public:. enum Action { OperModeChange; OptimizeCaching; FindConstantNodes; };. protected:. RooAbsArg*_owner! Pointer to owning RooAbsArg. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Interface for server redirect calls. void printCompactTreeHook(ostream& , const char* , Int_t curElem, Int_t totElem); Hook function to print cache guts in tree printing mode of RooAbsArgs. void operModeHook(RooAbsArg::OperMode ); Interface for operation mode change calls. void optimizeCacheMode(const RooArgSet& obs, RooArgSet& optNodes, RooLinkedList& processedNodes); Interface for cache optimization calls. The default implementation is to forward all these; calls to all contained RooAbsArg objects as publicized through containedArg(). void findConstantNodes(const RooArgSet& obs, RooArgSet& cacheList, RooLinkedList& processedNodes); Interface for constant term optimization calls. The default implementation is to forward all these; calls to all contained RooAbsArg objects as publicized through containedArg(). virtual ~RooAbsCacheElement(); Destructor. RooArgList containedArgs(RooAbsCacheElement::Action ). void setOwner(RooAbsArg* owner); Store pointer to owner. » Last changed: Thu Nov 3 20:06:37 2011 » Last generated: 2011-11-03 20:06; This page has been automatically generated. For comments or s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsCacheElement.html:1989,cache,cache,1989,root/html532/RooAbsCacheElement.html,https://root.cern,https://root.cern/root/html532/RooAbsCacheElement.html,1,['cache'],['cache']
Performance,"odes); virtual TClass*IsA() const; RooAbsCacheElement&operator=(const RooAbsCacheElement&); virtual voidoperModeHook(RooAbsArg::OperMode); virtual voidoptimizeCacheMode(const RooArgSet& obs, RooArgSet& optNodes, RooLinkedList& processedNodes); virtual voidprintCompactTreeHook(ostream&, const char*, Int_t curElem, Int_t totElem); virtual Bool_tredirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidsetOwner(RooAbsArg* owner); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; public:. enum Action { OperModeChange; OptimizeCaching; FindConstantNodes; };. protected:. RooAbsArg*_owner! Pointer to owning RooAbsArg. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Interface for server redirect calls. void printCompactTreeHook(ostream& , const char* , Int_t curElem, Int_t totElem); Hook function to print cache guts in tree printing mode of RooAbsArgs. void operModeHook(RooAbsArg::OperMode ); Interface for operation mode change calls. void optimizeCacheMode(const RooArgSet& obs, RooArgSet& optNodes, RooLinkedList& processedNodes); Interface for cache optimization calls. The default implementation is to forward all these; calls to all contained RooAbsArg objects as publicized through containedArg(). void findConstantNodes(const RooArgSet& obs, RooArgSet& cacheList, RooLinkedList& processedNodes); Interface for constant term optimization calls. The default implementation is to forward all these; calls to all contained RooAbsArg objects as publicized through containedArg(). virtual ~RooAbsCacheElement(); Destructor. RooArgList containedArgs(RooAbsCacheElement::Action ). void setOwner(RooAbsArg* owner); Store pointer to owner. » Last changed: Thu Sep 23 19:58:05 2010 » Last generated: 2010-09-23 19:58; This page has been automatically generated. For comments or ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsCacheElement.html:1989,cache,cache,1989,root/html528/RooAbsCacheElement.html,https://root.cern,https://root.cern/root/html528/RooAbsCacheElement.html,1,['cache'],['cache']
Performance,"oding or design mistakes. As soon as the geometry is successfully closed, one should draw it starting from the top-level volume:; //... code for geometry building; root[] gGeoManager->CloseGeometry();; root[] gGeoManager->GetMasterVolume()->Draw();; TGeoManager::GetMasterVolumeTGeoVolume * GetMasterVolume() constDefinition TGeoManager.h:511; TGeoVolume::Drawvoid Draw(Option_t *option="""") overridedraw top volume according to optionDefinition TGeoVolume.cxx:1206; Doing this ensures that the original top-level volume of the geometry is drawn, even if another volume is currently the geometry root. OK, I suppose you already did that with your simple geometry and immediately noticed a new ROOT canvas popping-up and having some more or less strange picture inside. Here are few questions that might come:; Q: ""The picture is strangely rotated; where are the coordinate axes?""; A: If drawn in a new canvas, any view has some default viewpoint, center of view and size. One can then perform mouse/keyboard actions to change them:. Mouse left-click and drag will rotate the view;; Some keys can be pressed when the view canvas is selected: J/K zoom/un-zoom, U/I move up/down, L/H move left/right. The coordinate axes display as well as changing top or side viewpoints can be activated from the **TView** context menu: right-click on the picture when no object is selected;. Q: ""Every line is black! I cannot figure out what is what...""; A: Volumes can have different colors (those known by ROOT of course). Think at using them after each volume creation: myvolume->SetLineColor(Int_t color); otherwise everything is by default black.; Q: ""The top volume of my geometry is a box but I see only its content.""; A: By default the drawn volume is not displayed just because we do not want to hide its content when changing the view to HLR or solid mode. In order to see it in the default wire frame picture one has to call TGeoManager::SetTopVisible().; Q: ""I do not see all volumes in my tree but just som",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:107616,perform,perform,107616,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['perform'],['perform']
Performance,"ods); public:. TGLCylinder(const TBuffer3DTube& buffer); virtual~TGLCylinder(); voidTGLLogicalShape::AddRef(TGLPhysicalShape* phys) const; virtual Bool_tTGLLogicalShape::AlwaysSecondarySelect() const; const TGLBoundingBox&TGLLogicalShape::BoundingBox() const; static TClass*Class(); voidTGLLogicalShape::DestroyPhysicals(); virtual voidDirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tDLOffset(Short_t lod) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tTGLLogicalShape::KeepDuringSmartRefresh() const; virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tQuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; UInt_tTGLLogicalShape::Ref() const; Bool_tTGLLogicalShape::SetDLCache(Bool_t cached); virtual Bool_tTGLLogicalShape::ShouldDLCache(const TGLRnrCtx& rnrCtx) const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidTGLLogicalShape::StrongRef(Bool_t strong) const; voidTGLLogicalShape::SubRef(TGLPhysicalShape* phys) const; virtual TGLLogicalShape::ELODAxesSupportedLODAxes() const; virtual Bool_tTGLLogicalShape::SupportsSecondarySelect() const; UInt_tTGLLogicalShape::UnrefFirstPhysical(); virtual voidTGLLogicalShape::UpdateBoundingBox(); voidTGLLogicalShape::UpdateBoundingBoxesOfPhysicals(). protected:. v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGLCylinder.html:1813,cache,cached,1813,root/html528/TGLCylinder.html,https://root.cern,https://root.cern/root/html528/TGLCylinder.html,4,['cache'],['cached']
Performance,"oef1); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Bool_tselfNormalized() const; TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidsetCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidsetFloor(Bool_t flag); static voidsetFloorGlobal(Bool_t flag); voidRooAbsPdf::setGeneratorConfig(); voidRooAbsPdf::setGeneratorConfig(const RooNumGenConfig& config); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); voidRooAbsPdf::setNormRange(const char* rangeName); voidRooAbsPdf::setNormRangeOverride(const char* rangeName); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttrib",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooRealSumPdf.html:29518,cache,cache,29518,root/html602/RooRealSumPdf.html,https://root.cern,https://root.cern/root/html602/RooRealSumPdf.html,4,['cache'],['cache']
Performance,oefficient list; RooListProxy_coefListList of coefficients; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; Bool_t_doFloorIntroduce floor at zero in pdf; static Bool_t_doFloorGlobalGlobal flag for introducing floor at zero in pdf; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_t_extendedAllow use as extended p.d.f.; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; TIterator*_funcIter! Iterator over FUNC list; RooListProxy_funcListList of component FUNCs; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; Bool_t_haveLastCoef; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManager_normIntMgrThe integration cache manager; RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAb,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooRealSumPdf.html:42651,cache,cache,42651,root/html602/RooRealSumPdf.html,https://root.cern,https://root.cern/root/html602/RooRealSumPdf.html,10,"['Cache', 'cache']","['Cached', 'cache']"
Performance,of 10000 events: 0.072 sec ; Factory : Test method: KNN for Classification performance; : ; KNN : [dataset] : Evaluation of KNN on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.2 sec ; Factory : Test method: LD for Classification performance; : ; LD : [dataset] : Evaluation of LD on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00474 sec ; : Dataset[dataset] : Evaluation of LD on testing sample; Factory : Test method: FDA_GA for Classification performance; : ; FDA_GA : [dataset] : Evaluation of FDA_GA on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00327 sec ; Factory : Test method: MLPBNN for Classification performance; : ; MLPBNN : [dataset] : Evaluation of MLPBNN on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.0193 sec ; Factory : Test method: DNN_CPU for Classification performance; : ; : Evaluate deep neural network on CPU using batches with size = 1000; : ; TFHandler_DNN_CPU : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : myvar1: 0.12216 0.20255 [ -1.0614 1.0246 ]; : myvar2: -0.12333 0.30492 [ -1.2280 0.99911 ]; : var3: 0.097148 0.21347 [ -1.0158 0.99984 ]; : var4: 0.17495 0.23851 [ -1.2661 1.0694 ]; : -----------------------------------------------------------; DNN_CPU : [dataset] : Evaluation of DNN_CPU on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.333 sec ; Factory : Test method: SVM for Classification performance; : ; SVM : [dataset] : Evaluation of SVM on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.287 sec ; Factory : Test method: BDT for Classification performance; : ; BDT : [dataset] : Evaluation of BDT on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.571 sec ; Factory : Test method: RuleFit for Classification performance; : ; RuleFit : [dataset] : Evaluation of Ru,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAClassification_8C.html:67398,perform,performance,67398,doc/master/TMVAClassification_8C.html,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html,1,['perform'],['performance']
Performance,"of ROOT version (ex 1152); static Bool_tTDirectory::fgAddDirectory!flag to add histograms, graphs,etc to the directory. private:. Int_tfLineIsProcessingTo synchronize multi-threads; static Int_tfgDirLevelIndentation level for ls(); static Bool_tfgMemCheckTurn on memory leak checker; static Bool_tfgRootInitSingleton initialization flag. Class Charts. Inheritance Chart:. TObject. ←; TNamed. ←; TDirectory. ←; TROOT. Function documentation; TROOT(); Default ctor. TROOT(const char* name, const char* title, VoidFuncPtr_t* initfunc = 0); Initialize the ROOT system. The creation of the TROOT object initializes; the ROOT system. It must be the first ROOT related action that is; performed by a program. The TROOT object must be created on the stack; (can not be called via new since ""operator new"" is protected). The; TROOT object is either created as a global object (outside the main(); program), or it is one of the first objects created in main().; Make sure that the TROOT object stays in scope for as long as ROOT; related actions are performed. TROOT is a so called singleton so; only one instance of it can be created. The single TROOT object can; always be accessed via the global pointer gROOT.; The name and title arguments can be used to identify the running; application. The initfunc argument can contain an array of; function pointers (last element must be 0). These functions are; executed at the end of the constructor. This way one can easily; extend the ROOT system without adding permanent dependencies; (e.g. the graphics system is initialized via such a function). ~TROOT(); Clean up and free resources used by ROOT (files, network sockets,; shared memory segments, etc.). void AddClass(TClass* cl); Add a class to the list and map of classes.; This routine is deprecated, use TClass::AddClass directly. void AddClassGenerator(TClassGenerator* gen); Add a class generator. This generator will be called by TClass::GetClass; in case its does not find a loaded rootcint dictionary ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TROOT.html:21872,perform,performed,21872,root/html602/TROOT.html,https://root.cern,https://root.cern/root/html602/TROOT.html,4,['perform'],['performed']
Performance,"of THttpServer::ProcessRequests() method; The second method is preferable - one just inserts in the application regular calls of the THttpServer::ProcessRequests() method, like:; serv->ProcessRequests();; In such case, one can fully disable the timer of the server:; serv->SetTimer(0, kTRUE);; 1.7 Data access from command shell; The big advantage of the http protocol is that it is not only supported in web browsers, but also in many other applications. One could use http requests to directly access ROOT objects and data members from any kind of scripts.; If one starts a server and register an object like for example:; root [1] serv = new THttpServer(""http:8080"");; root [2] TNamed* n1 = new TNamed(""obj"", ""title"");; root [3] serv->Register(""subfolder"", n1);; One could request a JSON representation of such object with the command:; [shell] wget http://localhost:8080/Objects/subfolder/obj/root.json; Then, its representation will look like:; {; ""_typename"" : ""TNamed"",; ""fUniqueID"" : 0,; ""fBits"" : 50331656,; ""fName"" : ""obj"",; ""fTitle"" : ""title""; }; The following requests can be performed:. root.bin - binary data produced by object streaming with TBufferFile; root.json - ROOT JSON representation for object and objects members; root.xml - ROOT XML representation; root.png - PNG image (if object drawing implemented); root.gif - GIF image; root.jpeg - JPEG image; exe.json - method execution in the object; exe.bin - method execution, return result in binary form; cmd.json - command execution; item.json - item (object) properties, specified on the server; multi.json - perform several requests at once; multi.bin - perform several requests at once, return result in binary form. All data will be automatically zipped if ‘.gz’ extension is appended. Like:; [shell] wget http://localhost:8080/Objects/subfolder/obj/root.json.gz; If the access to the server is restricted with htdigest, it is recommended to use the curl program since only curl correctly implements such authentication metho",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/HttpServer/HttpServer.html:9967,perform,performed,9967,root/html534/guides/HttpServer/HttpServer.html,https://root.cern,https://root.cern/root/html534/guides/HttpServer/HttpServer.html,2,['perform'],['performed']
Performance,of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_t_isCopy; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; RooResolutionModel*_model! Original resolution model; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigN,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsAnaConvPdf.html:40203,cache,cache,40203,root/html526/RooAbsAnaConvPdf.html,https://root.cern,https://root.cern/root/html526/RooAbsAnaConvPdf.html,1,['cache'],['cache']
Performance,of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_t_isCopy; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; RooResolutionModel*_model! Original resolution model; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC genera,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsAnaConvPdf.html:40585,cache,cache,40585,root/html528/RooAbsAnaConvPdf.html,https://root.cern,https://root.cern/root/html528/RooAbsAnaConvPdf.html,1,['cache'],['cache']
Performance,of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_t_isCopy; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; RooResolutionModel*_model! Original resolution model; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculatin,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooAbsAnaConvPdf.html:41054,cache,cache,41054,root/html530/RooAbsAnaConvPdf.html,https://root.cern,https://root.cern/root/html530/RooAbsAnaConvPdf.html,1,['cache'],['cache']
Performance,"of all ROOT objects.Definition TObject.h:41; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; NoteTo add all the files of a another TChain to this one, use TChain::Add(TChain* chain). ; Definition at line 365 of file TChain.cxx. ◆ Add() [2/2]. Int_t TChain::Add ; (; TChain * ; chain). virtual . Add all files referenced by the passed chain to this chain. ; The function returns the total number of files connected. ; Definition at line 219 of file TChain.cxx. ◆ AddFile(). Int_t TChain::AddFile ; (; const char * ; name, . Long64_t ; nentries = TTree::kMaxEntries, . const char * ; tname = """" . ). virtual . Add a new file to this chain. ; Filename formats are similar to TChain::Add. Wildcards are not applied. urls may also contain query and fragment identifiers where the tree name can be specified in the url fragment.; eg. root://machine/path/file_name[?query[#tree_name]]; root://machine/path/file_name.root[.oext]/tree_name[?query]; If tree_name is given as a part of the file name it is used to as the name of the tree to load from the file. Otherwise if tname argument is specified the chain will load the tree named tname from the file, otherwise the original treename specified in the TChain constructor will be used. Tagging the tree_name with a slash [/tree_name] is only supported for backward compatibility; it requires the file name ot contain the string '.root' and its use is deprecated.; A. If nentries <= 0, the file is opened and the tree header read into memory to get the number of entries.; B. If nentries > 0, the file is not opened, and nentries is assumed to be the number of entries in the file. In this case, no check is made that the file exists nor that the tree exists in the file, nor that the real TTree entries match with the input argument. This second mode is interesting in case the number of entries in the file is already stored in a run database for example. WarningIf you pass nentries > tree_entries, this may lead to silent data corruptio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTChain.html:61521,load,load,61521,doc/master/classTChain.html,https://root.cern,https://root.cern/doc/master/classTChain.html,1,['load'],['load']
Performance,"of all ROOT objects.Definition TObject.h:41; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; NoteTo add all the files of a another TChain to this one, use TChain::Add(TChain* chain). ; Definition at line 365 of file TChain.cxx. ◆ Add() [2/2]. Int_t TChain::Add ; (; TChain * ; chain). virtual . Add all files referenced by the passed chain to this chain. ; The function returns the total number of files connected. ; Definition at line 219 of file TChain.cxx. ◆ AddFile(). Int_t TChain::AddFile ; (; const char * ; name, . Long64_t ; nentries = TTree::kMaxEntries, . const char * ; tname = """" . ). virtual . Add a new file to this chain. ; Filename formats are similar to TChain::Add. Wildcards are not applied. urls may also contain query and fragment identifiers where the tree name can be specified in the url fragment.; eg. root://machine/path/file_name[?query[#tree_name]]; root://machine/path/file_name.root[.oext]/tree_name[?query]; If tree_name is given as a part of the file name it is used to as the name of the tree to load from the file. Otherwise if tname argument is specified the chain will load the tree named tname from the file, otherwise the original treename specified in the TChain constructor will be used. Tagging the tree_name with a slash [/tree_name] is only supported for backward compatibility; it requires the file name ot contain the string '.root' and its use is deprecated.; A. If nentries <= 0, the file is opened and the tree header read into memory to get the number of entries.; B. If nentries > 0, the file is not opened, and nentries is assumed to be the number of entries in the file. In this case, no check is made that the file exists nor that the tree exists in the file. This second mode is interesting in case the number of entries in the file is already stored in a run database for example.; C. If nentries == TTree::kMaxEntries (default), the file is not opened. The number of entries in each file will be read only when the file is op",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTChain.html:61348,load,load,61348,doc/v632/classTChain.html,https://root.cern,https://root.cern/doc/v632/classTChain.html,1,['load'],['load']
Performance,"of all classes in the workspace that have a class name; that matches pattern 'pat' and which are not found to be part of; the standard ROOT distribution. If doReplace is true any existing; class code saved in the workspace is replaced. Bool_t saveSnapshot(const char* name, const char* paramNames); Save snapshot of values and attributes (including ""Constant"") of parameters 'params'; If importValues is FALSE, the present values from the object in the workspace are; saved. If importValues is TRUE, the values of the objects passed in the 'params'; argument are saved. Bool_t saveSnapshot(const char* name, const RooArgSet& params, Bool_t importValues = kFALSE); Save snapshot of values and attributes (including ""Constant"") of parameters 'params'; If importValues is FALSE, the present values from the object in the workspace are; saved. If importValues is TRUE, the values of the objects passed in the 'params'; argument are saved. Bool_t loadSnapshot(const char* name); Load the values and attributes of the parameters in the snapshot saved with; the given name. RooAbsPdf* pdf(const char* name) const; Retrieve p.d.f (RooAbsPdf) with given name. A null pointer is returned if not found. RooAbsReal* function(const char* name) const; Retrieve function (RooAbsReal) with given name. Note that all RooAbsPdfs are also RooAbsReals. A null pointer is returned if not found. RooRealVar* var(const char* name) const; Retrieve real-valued variable (RooRealVar) with given name. A null pointer is returned if not found. RooCategory* cat(const char* name) const; Retrieve discrete variable (RooCategory) with given name. A null pointer is returned if not found. RooAbsCategory* catfunc(const char* name) const; Retrieve discrete function (RooAbsCategory) with given name. A null pointer is returned if not found. RooAbsArg* arg(const char* name) const; Return RooAbsArg with given name. A null pointer is returned if none is found. RooArgSet argSet(const char* nameList) const; Return set of RooAbsArgs ma",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooWorkspace.html:17322,load,loadSnapshot,17322,root/html526/RooWorkspace.html,https://root.cern,https://root.cern/root/html526/RooWorkspace.html,6,"['Load', 'load']","['Load', 'loadSnapshot']"
Performance,"of all classes in the workspace that have a class name; that matches pattern 'pat' and which are not found to be part of; the standard ROOT distribution. If doReplace is true any existing; class code saved in the workspace is replaced. Bool_t saveSnapshot(const char* name, const char* paramNames); Save snapshot of values and attributes (including ""Constant"") of parameters 'params'; If importValues is FALSE, the present values from the object in the workspace are; saved. If importValues is TRUE, the values of the objects passed in the 'params'; argument are saved. Bool_t saveSnapshot(const char* name, const RooArgSet& params, Bool_t importValues = kFALSE); Save snapshot of values and attributes (including ""Constant"") of parameters 'params'; If importValues is FALSE, the present values from the object in the workspace are; saved. If importValues is TRUE, the values of the objects passed in the 'params'; argument are saved. Bool_t loadSnapshot(const char* name); Load the values and attributes of the parameters in the snapshot saved with; the given name. const RooArgSet* getSnapshot(const char* name) const; Return the RooArgSet containgin a snapshot of variables contained in the workspace. Note that the variables of the objects in the snapshots are _copies_ of the; variables in the workspace. To load the values of a snapshot in the workspace; variables use loadSnapshot() instead. RooAbsPdf* pdf(const char* name) const; Retrieve p.d.f (RooAbsPdf) with given name. A null pointer is returned if not found. RooAbsReal* function(const char* name) const; Retrieve function (RooAbsReal) with given name. Note that all RooAbsPdfs are also RooAbsReals. A null pointer is returned if not found. RooRealVar* var(const char* name) const; Retrieve real-valued variable (RooRealVar) with given name. A null pointer is returned if not found. RooCategory* cat(const char* name) const; Retrieve discrete variable (RooCategory) with given name. A null pointer is returned if not found. RooAbsCateg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooWorkspace.html:19837,load,loadSnapshot,19837,root/html534/RooWorkspace.html,https://root.cern,https://root.cern/root/html534/RooWorkspace.html,9,"['Load', 'load']","['Load', 'loadSnapshot']"
Performance,"of all members ; TStreamerInfo::TCompInfo Class Reference. . Definition at line 41 of file TStreamerInfo.h. Public Member Functions;  TCompInfo ();  ;  ~TCompInfo ();  ; void Update (const TClass *oldcl, TClass *newcl);  Update the TClass pointer cached in this object. ;  . Public Attributes; TClass * fClass;  Not Owned. ;  ; TString fClassName;  ; TStreamerElement * fElem;  Not Owned. ;  ; Int_t fLength;  ; ULongptr_t fMethod;  ; TClass * fNewClass;  Not Owned. ;  ; Int_t fNewType;  ; Int_t fOffset;  ; TMemberStreamer * fStreamer;  Not Owned. ;  ; Int_t fType;  . Constructor & Destructor Documentation. ◆ TCompInfo(). TStreamerInfo::TCompInfo::TCompInfo ; (; ). inline . Definition at line 57 of file TStreamerInfo.h. ◆ ~TCompInfo(). TStreamerInfo::TCompInfo::~TCompInfo ; (; ). inline . Definition at line 59 of file TStreamerInfo.h. Member Function Documentation. ◆ Update(). void TStreamerInfo::TCompInfo::Update ; (; const TClass * ; oldcl, . TClass * ; newcl . ). Update the TClass pointer cached in this object. ; Definition at line 5644 of file TStreamerInfo.cxx. Member Data Documentation. ◆ fClass. TClass* TStreamerInfo::TCompInfo::fClass. Not Owned. ; Definition at line 53 of file TStreamerInfo.h. ◆ fClassName. TString TStreamerInfo::TCompInfo::fClassName. Definition at line 55 of file TStreamerInfo.h. ◆ fElem. TStreamerElement* TStreamerInfo::TCompInfo::fElem. Not Owned. ; Definition at line 51 of file TStreamerInfo.h. ◆ fLength. Int_t TStreamerInfo::TCompInfo::fLength. Definition at line 50 of file TStreamerInfo.h. ◆ fMethod. ULongptr_t TStreamerInfo::TCompInfo::fMethod. Definition at line 52 of file TStreamerInfo.h. ◆ fNewClass. TClass* TStreamerInfo::TCompInfo::fNewClass. Not Owned. ; Definition at line 54 of file TStreamerInfo.h. ◆ fNewType. Int_t TStreamerInfo::TCompInfo::fNewType. Definition at line 48 of file TStreamerInfo.h. ◆ fOffset. Int_t TStreamerInfo::TCompInfo::fOffset. Definition at line 49 of file TStreamerInfo.h. ◆ fStreamer. TMemberStreamer* TStre",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTStreamerInfo_1_1TCompInfo.html:1210,cache,cached,1210,doc/master/classTStreamerInfo_1_1TCompInfo.html,https://root.cern,https://root.cern/doc/master/classTStreamerInfo_1_1TCompInfo.html,1,['cache'],['cached']
Performance,"of blocks in the cache is printed; see also class TTreePerfStats. Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos.; If pos is in the list of prefetched blocks read from fBuffer.; Otherwise try to fill the cache from the list of selected branches,; and recheck if pos is now in the list.; Returns; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache.; This function overloads TFileCacheRead::ReadBuffer. void ResetCache(); This will simply clear the cache. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void SetLearnEntries(Int_t n = 10); Static function to set the number of entries to be used in learning mode; The default value for n is 10. n must be >= 1. void StartLearningPhase(); The name should be enough to explain the method.; The only additional comments is that the cache is cleaned before; the new learning phase. void StopLearningPhase(); This is the counterpart of StartLearningPhase() and can be used to stop; the learning phase. It's useful when the user knows exactly what branches; he is going to use.; For the moment it's just a call to FillBuffer() since that method; will create the buffer lists from the specified branches. void UpdateBranches(TTree* tree, Bool_t owner = kFALSE); Update pointer to current Tree and recompute pointers to the branches in the cache. TTreeCache(const TTreeCache& ). TTreeCache& operator=(const TTreeCache& ). Bool_t IsLearning() const; {return fIsLearning;}. » Author: Rene Brun 04/06/2006 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id: TTreeCache.h 34935 2010-08-23 09:13:37Z brun $ » Last generated: 2010-09-23 20:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreeCache.html:20483,cache,cache,20483,root/html528/TTreeCache.html,https://root.cern,https://root.cern/root/html528/TTreeCache.html,2,['cache'],['cache']
Performance,"of bytes in all branches after compression; static Int_tfgBranchStyleOld/New branch style; static Long64_tfgMaxTreeSizeMaximum size of a file containg a Tree. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTree(); Default constructor and I/O constructor. Note: We do *not* insert ourself into the current directory. TTree(const char* name, const char* title, Int_t splitlevel = 99); Normal tree constructor. The tree is created in the current directory.; Use the various functions Branch below to add branches to this tree. If the first character of title is a ""/"", the function assumes a folder name.; In this case, it creates automatically branches following the folder hierarchy.; splitlevel may be used in this case to control the split level. ~TTree(); Destructor. TBuffer* GetTransientBuffer(Int_t size); Returns the transient buffer currently used by this TTree for reading/writing baskets. void AddBranchToCache(const char* bname, Bool_t subbranches = kFALSE); Add branch with name bname to the Tree cache.; If bname=""*"" all branches are added to the cache.; if subbranches is true all the branches of the subbranches are; also put to the cache. void AddBranchToCache(TBranch* branch, Bool_t subbranches = kFALSE); Add branch b to the Tree cache.; if subbranches is true all the branches of the subbranches are; also put to the cache. void AddClone(TTree* ); Add a cloned tree to our list of trees to be notified whenever we change; our branch addresses or when we are deleted. TFriendElement* AddFriend(const char* treename, const char* filename = """"); Add a TFriendElement to the list of friends. This function:; -opens a file if filename is specified; -reads a Tree with name treename from the file (current directory); -adds the Tree to the list of friends; see other AddFriend functions. A TFriendElement TF describes a TTree object TF in a file.; When a TFriendElement TF is added to the the list of friends of an; existing TTree T, any varia",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TTree.html:34526,cache,cache,34526,root/html530/TTree.html,https://root.cern,https://root.cern/root/html530/TTree.html,1,['cache'],['cache']
Performance,"of bytes in all branches after compression; static Int_tfgBranchStyleOld/New branch style; static Long64_tfgMaxTreeSizeMaximum size of a file containg a Tree. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTree(); Default constructor and I/O constructor. Note: We do *not* insert ourself into the current directory. TTree(const char* name, const char* title, Int_t splitlevel = 99); Normal tree constructor. The tree is created in the current directory.; Use the various functions Branch below to add branches to this tree. If the first character of title is a ""/"", the function assumes a folder name.; In this case, it creates automatically branches following the folder hierarchy.; splitlevel may be used in this case to control the split level. ~TTree(); Destructor. TBuffer* GetTransientBuffer(Int_t size); Returns the transient buffer currently used by this TTree for reading/writing baskets. void AddBranchToCache(const char* bname, Bool_t subbranches = kFALSE); Add branch with name bname to the Tree cache.; If bname=""*"" all branches are added to the cache.; if subbranches is true all the branches of the subbranches are; also put to the cache. void AddBranchToCache(TBranch* branch, Bool_t subbranches = kFALSE); Add branch b to the Tree cache.; if subbranches is true all the branches of the subbranches are; also put to the cache. void DropBranchFromCache(const char* bname, Bool_t subbranches = kFALSE); Add branch with name bname to the Tree cache.; If bname=""*"" all branches are added to the cache.; if subbranches is true all the branches of the subbranches are; also put to the cache. void DropBranchFromCache(TBranch* branch, Bool_t subbranches = kFALSE); Add branch b to the Tree cache.; if subbranches is true all the branches of the subbranches are; also put to the cache. void AddClone(TTree* ); Add a cloned tree to our list of trees to be notified whenever we change; our branch addresses or when we are deleted. TFriendElement* Add",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTree.html:35012,cache,cache,35012,root/html532/TTree.html,https://root.cern,https://root.cern/root/html532/TTree.html,2,['cache'],['cache']
Performance,"of bytes in all branches after compression; static Int_tfgBranchStyleOld/New branch style; static Long64_tfgMaxTreeSizeMaximum size of a file containg a Tree. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTree(); Default constructor and I/O constructor. Note: We do *not* insert ourself into the current directory. TTree(const char* name, const char* title, Int_t splitlevel = 99); Normal tree constructor. The tree is created in the current directory.; Use the various functions Branch below to add branches to this tree. If the first character of title is a ""/"", the function assumes a folder name.; In this case, it creates automatically branches following the folder hierarchy.; splitlevel may be used in this case to control the split level. ~TTree(); Destructor. TBuffer* GetTransientBuffer(Int_t size); Returns the transient buffer currently used by this TTree for reading/writing baskets. void AddBranchToCache(const char* bname, Bool_t subbranches = kFALSE); Add branch with name bname to the Tree cache.; If bname=""*"" all branches are added to the cache.; if subbranches is true all the branches of the subbranches are; also put to the cache. void AddBranchToCache(TBranch* branch, Bool_t subbranches = kFALSE); Add branch b to the Tree cache.; if subbranches is true all the branches of the subbranches are; also put to the cache. void DropBranchFromCache(const char* bname, Bool_t subbranches = kFALSE); Remove the branch with name 'bname' from the Tree cache.; If bname=""*"" all branches are removed from the cache.; if subbranches is true all the branches of the subbranches are; also removed from the cache. void DropBranchFromCache(TBranch* branch, Bool_t subbranches = kFALSE); Remove the branch b from the Tree cache.; if subbranches is true all the branches of the subbranches are; also removed from the cache. void AddClone(TTree* ); Add a cloned tree to our list of trees to be notified whenever we change; our branch addresses or when",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTree.html:36258,cache,cache,36258,root/html534/TTree.html,https://root.cern,https://root.cern/root/html534/TTree.html,2,['cache'],['cache']
Performance,"of dataset: attach variables of cache ArgSet to the corresponding TTree branches. ;  ; void createTree (RooStringView name, RooStringView title);  Create TTree object that lives in memory, independent of current location of gDirectory. ;  ; Int_t getBranchBufferSize () const;  ; void initialize ();  One-time initialization common to all constructor forms. ;  ; std::string makeTreeName () const;  Generate a name for the storage tree from the name and title of this instance. ;  ; void setBranchBufferSize (Int_t size);  ; RooArgSet varsNoWeight (const RooArgSet &allVars, const char *wgtName=nullptr);  Utility function for constructors Return RooArgSet that is copy of allVars minus variable matching wgtName if specified. ;  ; RooRealVar * weightVar (const RooArgSet &allVars, const char *wgtName=nullptr);  Utility function for constructors Return pointer to weight variable if it is defined. ;  . Private Attributes; RooArgSet _attachedBuffers;  ! Currently attached buffers (if different from _varsww) ;  ; const RooAbsArg * _cacheOwner = nullptr;  TTree holding the cached function values. ;  ; TTree * _cacheTree = nullptr;  ; double _curWgt = 1.0;  Buffer for weights in case a batch of values is requested. ;  ; double _curWgtErr = 0.0;  Weight of current event. ;  ; double _curWgtErrHi = 0.0;  Weight of current event. ;  ; double _curWgtErrLo = 0.0;  Weight of current event. ;  ; bool _defCtor = false;  Object owning cache contents. ;  ; const double * _extSumW2Array {nullptr};  ! External sum of weights array ;  ; const double * _extWgtArray {nullptr};  ! External weight array ;  ; const double * _extWgtErrHiArray {nullptr};  ! External weight array - high error ;  ; const double * _extWgtErrLoArray {nullptr};  ! External weight array - low error ;  ; TTree * _tree = nullptr;  ; RooArgSet _varsww;  Was object constructed with default ctor? ;  ; std::unique_ptr< std::vector< double > > _weightBuffer;  ; RooRealVar * _wgtVar = nullptr;  . Static Private Attributes; static In",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooTreeDataStore.html:20969,cache,cached,20969,doc/master/classRooTreeDataStore.html,https://root.cern,https://root.cern/doc/master/classRooTreeDataStore.html,1,['cache'],['cached']
Performance,"of dimension ndim implemented in TFitter and TLinearFitter ;  ; virtual void GetConfidenceIntervals (TObject *obj, Double_t cl=0.95);  return confidence intervals in TObject obj implemented in TFitter and TLinearFitter ;  ; virtual Double_t * GetCovarianceMatrix () const =0;  ; virtual Double_t GetCovarianceMatrixElement (Int_t i, Int_t j) const =0;  ; virtual Int_t GetErrors (Int_t ipar, Double_t &eplus, Double_t &eminus, Double_t &eparab, Double_t &globcc) const =0;  ; virtual FCNFunc_t GetFCN ();  ; virtual Foption_t GetFitOption () const;  ; TMethodCall * GetMethodCall () const;  ; virtual Int_t GetNumberFreeParameters () const =0;  ; virtual Int_t GetNumberTotalParameters () const =0;  ; virtual TObject * GetObjectFit () const;  ; virtual Double_t GetParameter (Int_t ipar) const =0;  ; virtual Int_t GetParameter (Int_t ipar, char *name, Double_t &value, Double_t &verr, Double_t &vlow, Double_t &vhigh) const =0;  ; virtual Double_t GetParError (Int_t ipar) const =0;  ; virtual const char * GetParName (Int_t ipar) const =0;  ; virtual Int_t GetStats (Double_t &amin, Double_t &edm, Double_t &errdef, Int_t &nvpar, Int_t &nparx) const =0;  ; virtual Double_t GetSumLog (Int_t i)=0;  ; virtual TObject * GetUserFunc () const;  ; virtual Int_t GetXfirst () const;  ; virtual Int_t GetXlast () const;  ; virtual Int_t GetYfirst () const;  ; virtual Int_t GetYlast () const;  ; virtual Int_t GetZfirst () const;  ; virtual Int_t GetZlast () const;  ; TClass * IsA () const override;  ; virtual Bool_t IsFixed (Int_t ipar) const =0;  ; virtual void PrintResults (Int_t level, Double_t amin) const =0;  ; virtual void ReleaseParameter (Int_t ipar)=0;  ; virtual Double_t * SetCache (Int_t npoints, Int_t psize);  Initialize the cache array npoints is the number of points to be stored (or already stored) in the cache psize is the number of elements per point. ;  ; virtual void SetFCN (void(*fcn)(Int_t &, Double_t *, Double_t &f, Double_t *, Int_t));  To set the address of the minimizat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTVirtualFitter.html:3505,cache,cache,3505,doc/master/classTVirtualFitter.html,https://root.cern,https://root.cern/doc/master/classTVirtualFitter.html,2,['cache'],['cache']
Performance,"of fSeek ;  ; Int_t * fSeekLen;  [fNseek] Length of buffers to be prefetched ;  ; Int_t * fSeekPos;  [fNseek] Position of sorted blocks in fBuffer ;  ; Int_t fSeekSize;  Allocated size of fSeek. ;  ; Long64_t * fSeekSort;  [fNseek] Position on file of buffers to be prefetched (sorted) ;  ; Int_t * fSeekSortLen;  [fNseek] Length of buffers to be prefetched (sorted) ;  . Static Protected Attributes; static Int_t fgLearnEntries = 100;  number of entries used for learning mode ;  . Private Member Functions;  TTreeCache (const TTreeCache &)=delete;  this class cannot be copied ;  ; bool CalculateMissCache ();  Calculate the appropriate miss cache to fetch; helper function for FillMissCache. ;  ; TBranch * CalculateMissEntries (Long64_t, int, bool);  Given an file read, try to determine the corresponding branch. ;  ; bool CheckMissCache (char *buf, Long64_t pos, int len);  Check the miss cache for a particular buffer, fetching if deemed necessary. ;  ; bool FillMissCache ();  Fill the miss cache from the current set of active branches. ;  ; IOPos FindBranchBasketPos (TBranch &, Long64_t entry);  Given a branch and an entry, determine the file location (offset / size) of the corresponding basket. ;  ; TTreeCache & operator= (const TTreeCache &)=delete;  ; bool ProcessMiss (Long64_t pos, int len);  ! Given a file read not in the miss cache, handle (possibly) loading the data. ;  . Additional Inherited Members;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TFileCacheRead; void SetEnablePrefetchingImpl (Bool_t setPrefetching=kFALSE);  TFileCacheRead implementation of SetEnablePrefetching. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . #include <TTreeCache.h>. Inheritance diagram for TTreeCache:. This browser is not able to sho",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCache.html:32700,cache,cache,32700,doc/v632/classTTreeCache.html,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html,2,['cache'],['cache']
Performance,"of false the fit can be unbinned; 431 or is not defined (like in case of fitting through a ROOT::Fit::Fitter::FitFCN); 432 */; 433 bool IsBinFit() const { return fBinFit; }; 434 ; 435 /**; 436 return pointer to last used minimizer; 437 (is NULL in case fit is not yet done); 438 This pointer is guaranteed to be valid as far as the fitter class is valid and a new fit is not redone.; 439 To be used only after fitting.; 440 The pointer should not be stored and will be invalided after performing a new fitting.; 441 In this case a new instance of ROOT::Math::Minimizer will be re-created and can be; 442 obtained calling again GetMinimizer(); 443 */; 444 ROOT::Math::Minimizer * GetMinimizer() const { return fMinimizer.get(); }; 445 ; 446 /**; 447 return pointer to last used objective function; 448 (is NULL in case fit is not yet done); 449 This pointer will be valid as far as the fitter class; 450 has not been deleted. To be used after the fitting.; 451 The pointer should not be stored and will be invalided after performing a new fitting.; 452 In this case a new instance of the function pointer will be re-created and can be; 453 obtained calling again GetFCN(); 454 */; 455 ROOT::Math::IMultiGenFunction * GetFCN() const {; 456 return fObjFunction.get();; 457 }; 458 ; 459 ; 460 /**; 461 apply correction in the error matrix for the weights for likelihood fits; 462 This method can be called only after a fit. The; 463 passed function (loglw2) is a log-likelihood function implemented using the; 464 sum of weight squared; 465 When using FitConfig.SetWeightCorrection() this correction is applied; 466 automatically when doing a likelihood fit (binned or unbinned); 467 */; 468 bool ApplyWeightCorrection(const ROOT::Math::IMultiGenFunction & loglw2, bool minimizeW2L=false);; 469 ; 470 /// Set number of fit points when using an external FCN function; 471 /// This function can be called after Fit to set the correct number of Ndf in FitResult; 472 void SetNumberOfFitPoints(unsigned int n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Fitter_8h_source.html:18271,perform,performing,18271,doc/master/Fitter_8h_source.html,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html,1,['perform'],['performing']
Performance,"of file TArchiveFile.cxx. ◆ GetMemberIndex(). Int_t TArchiveFile::GetMemberIndex ; (; ); const. inline . Definition at line 57 of file TArchiveFile.h. ◆ GetMemberName(). const char * TArchiveFile::GetMemberName ; (; ); const. inline . Definition at line 56 of file TArchiveFile.h. ◆ GetMembers(). TObjArray * TArchiveFile::GetMembers ; (; ); const. inline . Definition at line 52 of file TArchiveFile.h. ◆ GetNumberOfMembers(). Int_t TArchiveFile::GetNumberOfMembers ; (; ); const. Returns number of members in archive. ; Definition at line 79 of file TArchiveFile.cxx. ◆ IsA(). TClass * TArchiveFile::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Reimplemented in TZIPFile.; Definition at line 61 of file TArchiveFile.h. ◆ Open(). TArchiveFile * TArchiveFile::Open ; (; const char * ; url, . TFile * ; file . ). static . Return proper archive file handler depending on passed url. ; The handler is loaded via the plugin manager and is triggered by the extension of the archive file. In case no handler is found 0 is returned. The file argument is used to access the archive. The archive should be specified as url with the member name as the anchor, e.g. ""root://pcsalo.cern.ch/alice/event_1.zip#tpc.root"", where tpc.root is the file in the archive to be opened. Alternatively the sub-file can be specified via its index number, e.g. ""root://pcsalo.cern.ch/alice/event_1.zip#3"". This function is normally only called via TFile::Open(). ; Definition at line 121 of file TArchiveFile.cxx. ◆ OpenArchive(). virtual Int_t TArchiveFile::OpenArchive ; (; ). pure virtual . Implemented in TZIPFile. ◆ operator=(). TArchiveFile & TArchiveFile::operator= ; (; const TArchiveFile & ; ). privatedelete . Not implemented because TArchiveFile can not be copied. . ◆ ParseUrl(). Bool_t TArchiveFile::ParseUrl ; (; const char * ; url, . TString & ; archive, . TString & ; member, . TString & ; type . ). staticprotected . Try to determine if url ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTArchiveFile.html:14813,load,loaded,14813,doc/master/classTArchiveFile.html,https://root.cern,https://root.cern/doc/master/classTArchiveFile.html,1,['load'],['loaded']
Performance,"of file TClass.cxx. ◆ NewObjectArray() [2/2]. TClass::ObjectPtr TClass::NewObjectArray ; (; Long_t ; nElements, . void * ; arena, . ENewType ; defConstructor = kClassNew . ); const. Return a pointer to a newly allocated object of this class. ; The class must have a default constructor. For meaning of defConstructor, see TClass::IsCallingNew(). ; Definition at line 5310 of file TClass.cxx. ◆ operator=(). TClass & TClass::operator= ; (; const TClass & ; ). privatedelete . ◆ PostLoadCheck(). void TClass::PostLoadCheck ; (; ). virtual . Do the initialization that can only be done after the CINT dictionary has been fully populated and can not be delayed efficiently. ; Definition at line 5959 of file TClass.cxx. ◆ Property(). Long_t TClass::Property ; (; ); const. overridevirtual . Returns the properties of the TClass as a bit field stored as a Long_t value. ; The bit values used for the return value are defined in the enum EProperty (in TDictionary.h); Also sets TObject::fBits and fStreamerType to cache information about the class. The bits stored in TObject::fBits are kIsTObject : the class inherits from TObject; kStartWithTObject: TObject is the left-most class in the inheritance tree; kIsForeign : the class doe not have a Streamer method; a#define a(i)Definition RSha256.hxx:99; TClass::Streamervoid Streamer(void *obj, TBuffer &b, const TClass *onfile_class=nullptr) constDefinition TClass.h:607; TClass::kStartWithTObject@ kStartWithTObjectDefinition TClass.h:103; TClass::kIsTObject@ kIsTObjectDefinition TClass.h:100; TClass::kIsForeign@ kIsForeignDefinition TClass.h:101; The value of fStreamerType are kTObject : the class inherits from TObject; kForeign : the class does not have a Streamer method; kInstrumented: the class does have a Streamer method; kExternal: the class has a free standing way of streaming itself; kEmulatedStreamer: the class is missing its shared library.; free#define freeDefinition civetweb.c:1539; TClass::kEmulatedStreamer@ kEmulatedStreamerDefinit",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTClass.html:109091,cache,cache,109091,doc/v632/classTClass.html,https://root.cern,https://root.cern/doc/v632/classTClass.html,1,['cache'],['cache']
Performance,"of file TClass.cxx. ◆ NewObjectArray() [2/2]. TClass::ObjectPtr TClass::NewObjectArray ; (; Long_t ; nElements, . void * ; arena, . ENewType ; defConstructor = kClassNew . ); const. Return a pointer to a newly allocated object of this class. ; The class must have a default constructor. For meaning of defConstructor, see TClass::IsCallingNew(). ; Definition at line 5377 of file TClass.cxx. ◆ operator=(). TClass & TClass::operator= ; (; const TClass & ; ). privatedelete . ◆ PostLoadCheck(). void TClass::PostLoadCheck ; (; ). virtual . Do the initialization that can only be done after the CINT dictionary has been fully populated and can not be delayed efficiently. ; Definition at line 6026 of file TClass.cxx. ◆ Property(). Long_t TClass::Property ; (; ); const. overridevirtual . Returns the properties of the TClass as a bit field stored as a Long_t value. ; The bit values used for the return value are defined in the enum EProperty (in TDictionary.h); Also sets TObject::fBits and fStreamerType to cache information about the class. The bits stored in TObject::fBits are kIsTObject : the class inherits from TObject; kStartWithTObject: TObject is the left-most class in the inheritance tree; kIsForeign : the class doe not have a Streamer method; a#define a(i)Definition RSha256.hxx:99; TClass::Streamervoid Streamer(void *obj, TBuffer &b, const TClass *onfile_class=nullptr) constDefinition TClass.h:607; TClass::kStartWithTObject@ kStartWithTObjectDefinition TClass.h:103; TClass::kIsTObject@ kIsTObjectDefinition TClass.h:100; TClass::kIsForeign@ kIsForeignDefinition TClass.h:101; The value of fStreamerType are kTObject : the class inherits from TObject; kForeign : the class does not have a Streamer method; kInstrumented: the class does have a Streamer method; kExternal: the class has a free standing way of streaming itself; kEmulatedStreamer: the class is missing its shared library.; free#define freeDefinition civetweb.c:1539; TClass::kEmulatedStreamer@ kEmulatedStreamerDefinit",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClass.html:109092,cache,cache,109092,doc/master/classTClass.html,https://root.cern,https://root.cern/doc/master/classTClass.html,1,['cache'],['cache']
Performance,"of file TGHtmlDraw.cxx. ◆ ButtonClicked(). void TGHtml::ButtonClicked ; (; const char * ; name, . const char * ; val . ). virtual . Emit ButtonClicked() signal. ; Definition at line 1286 of file TGHtml.cxx. ◆ CellSpacing(). int TGHtml::CellSpacing ; (; TGHtmlElement * ; pTable). Return the appropriate cell spacing for the given table. ; Definition at line 53 of file TGHtmlTable.cxx. ◆ CheckToggled(). void TGHtml::CheckToggled ; (; const char * ; name, . Bool_t ; on, . const char * ; val . ). virtual . Emit CheckToggled() signal. ; Definition at line 1299 of file TGHtml.cxx. ◆ ClassDefOverride(). TGHtml::ClassDefOverride ; (; TGHtml ; , . 0 ;  . ). protected . ◆ Clear(). void TGHtml::Clear ; (; Option_t * ; = """"). overridevirtual . Erase all HTML from this widget and clear the screen. ; This is typically done before loading a new document. ; Reimplemented from TObject.; Definition at line 310 of file TGHtml.cxx. ◆ ClearGcCache(). void TGHtml::ClearGcCache ; (; ). protected . Clear the cache of GCs. ; Definition at line 516 of file TGHtml.cxx. ◆ ColorDistance(). float TGHtml::ColorDistance ; (; ColorStruct_t * ; pA, . ColorStruct_t * ; pB . ). protected . Compute the squared distance between two colors. ; Definition at line 1613 of file TGHtml.cxx. ◆ ComputeVirtualSize(). void TGHtml::ComputeVirtualSize ; (; ). protected . Computes virtual size of html area. ; Definition at line 508 of file TGHtml.cxx. ◆ ControlSize(). int TGHtml::ControlSize ; (; TGHtmlInput * ; pElem). protected . This routine implements the Sizer() function for <INPUT>, <SELECT> and <TEXTAREA> markup. ; A side effect of sizing these markups is that widgets are created to represent the corresponding input controls.; The function normally returns 0. But if it is dealing with a <SELECT> or <TEXTAREA> that is incomplete, 1 is returned. In that case, the sizer will be called again at some point in the future when more information is available. ; Definition at line 357 of file TGHtmlForm.cxx. ◆ DecodeBas",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGHtml.html:57351,cache,cache,57351,doc/master/classTGHtml.html,https://root.cern,https://root.cern/doc/master/classTGHtml.html,1,['cache'],['cache']
Performance,"of one or multiple parent dataframe(s), delaying the creation of the columns to the actual usage of the daughter data frame ;  df016_vecOps.C This tutorial shows the potential of the VecOps approach for treating collections stored in datasets, a situation very common in HEP data analysis ;  df016_vecOps.py This tutorial shows the potential of the VecOps approach for treating collections stored in datasets, a situation very common in HEP data analysis ;  df017_vecOpsHEP.C This tutorial shows how VecOps can be used to slim down the programming model typically adopted in HEP for analysis ;  df017_vecOpsHEP.py This tutorial shows how VecOps can be used to slim down the programming model typically adopted in HEP for analysis ;  df018_customActions.C This tutorial shows how to implement a custom action ;  df019_Cache.C This tutorial shows how the content of a data frame can be cached in memory in form of a data frame ;  df019_Cache.py This tutorial shows how the content of a data frame can be cached in memory in form of a data frame ;  df020_helpers.C This tutorial shows usage of the RDF helper tools, contained in ROOT/RDFHelpers.hxx ;  df021_createTGraph.C This tutorial shows how to fill a TGraph using the Dataframe ;  df021_createTGraph.py This tutorial shows how to fill a TGraph using the Dataframe ;  df022_useKahan.C This tutorial shows how to implement a Kahan summation custom action ;  df023_aggregate.C This tutorial shows how to use the Aggregate action to evaluate the product of all the elements of a column ;  df024_Display.C This tutorial shows how to use the Display action ;  df024_Display.py This tutorial shows how to use the Display action ;  df025_RNode.C RNode is a generic type which represents any transformation node in the computation graph ;  df101_h1Analysis.C This tutorial illustrates how to express the H1 analysis with a RDataFrame ;  df102_NanoAODDimuonAnalysis.C This tutorial illustrates how NanoAOD files can be processed with ROOT dataframes ;  df10",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/files.html:101681,cache,cached,101681,doc/v616/files.html,https://root.cern,https://root.cern/doc/v616/files.html,1,['cache'],['cached']
Performance,"of packet requests; FILE*fLogFilelog file; Int_tfLogFileDeslog file descriptor; Long64_tfLogFileMaxSizemax size for log files (enabled if > 0); Int_tfLogLeveldebug logging level; Bool_tfMasterServtrue if we are a master server; Long64_tfMaxBoxSizeMax size of the sandbox; Int_tfMaxQueriesMax number of queries fully kept; Int_tfMergedWorkersNumber of workers merged; TMonitor*fMergingMonitorMonitor for merging sockets; TServerSocket*fMergingSocketSocket used for merging outputs if submerger; Long64_tfMsgSizeHWMHigh-Water-Mark on the size of messages with results; Int_tfNcmdcommand history number; TStringfOrdinalslave ordinal number; TStringfPackageDirdirectory containing packages and user libs; TProofLockPath*fPackageLockpackage dir locker; TVirtualProofPlayer*fPlayeractual player; TStringfPrefixPrefix identifying the node; TProof*fProofPROOF talking to slave servers; Int_tfProtocolprotocol version number; TQueryResultManager*fQMgrQuery-result manager; TMutex*fQMtxTo protect async msg queue; TStringfQueryDirdirectory containing query results and status; TProofLockPath*fQueryLockquery dir locker; Int_tfQuerySeqNumsequential number of the current or last query; TList*fQueuedMsglist of messages waiting to be processed; Float_tfRealTimereal time spent executing commands; Bool_tfRealTimeLogTRUE if log messages should be send back in real-time; TReaperTimer*fReaperTimerTimer used to control children state; Bool_tfSendLogToMasterOn workers, controls logs sending to master; TStringfServiceservice we are running, either ""proofserv"" or ""proofslave""; TStringfSessionDirdirectory containing session dependent files; TStringfSessionTagtag for the server session; TShutdownTimer*fShutdownTimerTimer used to shutdown out-of-control sessions; TSocket*fSocketsocket connection to client; TStringfTopSessionTagtag for the global session; Int_tfTotSessionsTotal number of PROOF sessions on the cluster ; TStringfUseruser as which we run; TList*fWaitingQuerieslist of TProofQueryResult waiting to ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TProofServ.html:19047,queue,queue,19047,root/html530/TProofServ.html,https://root.cern,https://root.cern/root/html530/TProofServ.html,3,['queue'],['queue']
Performance,"of security contexts (TSecContext); TVirtualPad*fSelectPadCurrently selected pad; TSeqCollection*fSocketsList of network sockets; TSeqCollection*fSpecialsList of special objects; TSeqCollection*fStreamerInfoList of active StreamerInfo classes; TSeqCollection*fStylesList of styles; TSeqCollection*fTasksList of tasks; Int_tfTimerTimer flag; TStringTNamed::fTitleobject title; TCollection*fTypesList of data types definition; TUUIDTDirectory::fUUIDUnique identifier; TProcessUUID*fUUIDsPointer to TProcessID managing TUUIDs; TStringfVersionROOT version (from CMZ VERSQQ) ex 0.05/01; Int_tfVersionCodeROOT version code as used in RVersion.h; Int_tfVersionDateDate of ROOT version (ex 951226); Int_tfVersionIntROOT version in integer format (501); Int_tfVersionTimeTime of ROOT version (ex 1152); static Bool_tTDirectory::fgAddDirectory!flag to add histograms, graphs,etc to the directory. private:. Int_tfLineIsProcessingTo synchronize multi-threads; static Int_tfgDirLevelIndentation level for ls(); static Bool_tfgMemCheckTurn on memory leak checker; static Bool_tfgRootInitSingleton initialization flag. Class Charts. Inheritance Chart:. TObject. ←; TNamed. ←; TDirectory. ←; TROOT. Function documentation; TROOT(); Default ctor. TROOT(const char* name, const char* title, VoidFuncPtr_t* initfunc = 0); Initialize the ROOT system. The creation of the TROOT object initializes; the ROOT system. It must be the first ROOT related action that is; performed by a program. The TROOT object must be created on the stack; (can not be called via new since ""operator new"" is protected). The; TROOT object is either created as a global object (outside the main(); program), or it is one of the first objects created in main().; Make sure that the TROOT object stays in scope for as long as ROOT; related actions are performed. TROOT is a so called singleton so; only one instance of it can be created. The single TROOT object can; always be accessed via the global pointer gROOT.; The name and title arguments",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TROOT.html:20999,multi-thread,multi-threads,20999,root/html602/TROOT.html,https://root.cern,https://root.cern/root/html602/TROOT.html,4,['multi-thread'],['multi-threads']
Performance,"of the TMVA multiclass classification ;  TMVAMulticlassApplication.C This macro provides a simple example on how to use the trained multiclass classifiers within an analysis module ;  TMVAMultipleBackgroundExample.C This example shows the training of signal with three different backgrounds Then in the application a tree is created with all signal and background events where the true class ID and the three classifier outputs are added finally with the application tree, the significance is maximized with the help of the TMVA genetic algrorithm ;  TMVARegression.C This macro provides examples for the training and testing of the TMVA classifiers ;  TMVARegressionApplication.C This macro provides a simple example on how to use the trained regression MVAs within an analysis module ;  ► tree;  basic.C Read data from an ascii file and create a root file with an histogram and an ntuple ;  basic2.C Create can ntuple reading data from an ascii file ;  bill.C Benchmark comparing row-wise and column-wise storage performance ;  cernbuild.C Read data (CERN staff) from an ascii file and create a root file with a Tree ;  cernstaff.C Playing with a Tree containing variables of type character ;  circular.C Example of a circular Tree ;  clonesA_Event.CExample to write & read a Tree built with a complex class inheritance tree ;  clonesA_Event.cxx;  clonesA_Event.h;  copytree.C Copy a subset of a Tree to a new Tree ;  copytree2.C Copy a subset of a Tree to a new Tree, one branch in a separate file ;  copytree3.C Example of Root macro to copy a subset of a Tree to a new Tree, selecting entries ;  drawsparse.C Convert a THnSparse to a TTree using efficient iteration through the THnSparse and draw a THnSparse using TParallelCoord ;  h1analysis.C Example of analysis class for the H1 data ;  h1analysis.h;  h1analysisProxy.CExample of analysis class for the H1 data using code generated by MakeProxy ;  h1analysisProxy.h;  h1analysisProxyCut.C;  h1analysisTreeReader.C H1 analysis example express",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/files.html:167082,perform,performance,167082,doc/v616/files.html,https://root.cern,https://root.cern/doc/v616/files.html,1,['perform'],['performance']
Performance,"of the TMVA multiclass classification ;  TMVAMulticlassApplication.C This macro provides a simple example on how to use the trained multiclass classifiers within an analysis module ;  TMVAMultipleBackgroundExample.C This example shows the training of signal with three different backgrounds Then in the application a tree is created with all signal and background events where the true class ID and the three classifier outputs are added finally with the application tree, the significance is maximized with the help of the TMVA genetic algrorithm ;  TMVARegression.C This macro provides examples for the training and testing of the TMVA classifiers ;  TMVARegressionApplication.C This macro provides a simple example on how to use the trained regression MVAs within an analysis module ;  ► tree;  basic.C Read data from an ascii file and create a root file with an histogram and an ntuple ;  basic2.C Create can ntuple reading data from an ascii file ;  bill.C Benchmark comparing row-wise and column-wise storage performance ;  cernbuild.C Read data (CERN staff) from an ascii file and create a root file with a Tree ;  cernstaff.C Playing with a Tree containing variables of type character ;  circular.C Example of a circular Tree ;  clonesA_Event.CExample to write & read a Tree built with a complex class inheritance tree ;  clonesA_Event.cxx;  clonesA_Event.h;  copytree.C Copy a subset of a Tree to a new Tree ;  copytree2.C Copy a subset of a Tree to a new Tree, one branch in a separate file ;  copytree3.C Example of Root macro to copy a subset of a Tree to a new Tree, selecting entries ;  drawsparse.C Convert a THnSparse to a TTree using efficient iteration through the THnSparse and draw a THnSparse using TParallelCoord ;  h1analysis.C Example of analysis class for the H1 data ;  h1analysis.h;  h1analysisProxy.CExample of analysis class for the H1 data using code generated by MakeProxy ;  h1analysisProxy.h;  h1analysisProxyCut.C;  h1analysisTreeReader.C;  h1analysisTreeReader.h;  ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/files.html:154879,perform,performance,154879,doc/v608/files.html,https://root.cern,https://root.cern/doc/v608/files.html,4,['perform'],['performance']
Performance,"of the geometry, or it may simply happen that they really represent a single object, too complex to be described by a primitive shape.; Usually handling structures like these can be easily done by positioning all components in the same container volume, then positioning the container itself. However, there are many practical cases when defining such a container is not straightforward or even possible without generating overlaps with the rest of the geometry. There are few ways out of this:. Defining the container for the structure as “overlapping” (see also "" Overlapping Volumes ""); Representing the container as a composite shape - the Boolean union of all components (see also "" Composite Shapes ""); Using an assembly volume - this will be described in the following. The first two approaches have the disadvantage of penalizing the navigation performance with a factor increasing more than linear of the number of components in the structure. The best solution is the third one because it uses all volume-related navigation optimizations. The class TGeoVolumeAssembly represents an assembly volume. Its shape is represented by TGeoShapeAssembly class that is the union of all components. It uses volume voxelization to perform navigation tasks.; An assembly volume creates a hierarchical level and it geometrically insulates the structure from the rest (as a normal volume). Physically, a point that is INSIDE a TGeoShapeAssembly is always inside one of the components, so a TGeoVolumeAssembly does not need to have a medium. Due to the self-containment of assemblies, they are very practical to use when a container is hard to define due to possible overlaps during positioning. For instance, it is very easy creating honeycomb structures. A very useful example for creating and using assemblies can be found at: http://root.cern.ch/root/html/examples/assembly.C.html.; Creation of an assembly is very easy: one has just to create a TGeoVolumeAssembly object and position the components in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:959233,optimiz,optimizations,959233,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['optimiz'],['optimizations']
Performance,"of the last miss. ; Definition at line 74 of file TTreeCache.h. ◆ fLearnPrefilling. bool TTreeCache::fLearnPrefilling {false}. protected . ! true if we are in the process of executing LearnPrefill ; Definition at line 68 of file TTreeCache.h. ◆ fMissCache. std::unique_ptr<MissCache> TTreeCache::fMissCache. protected . ! Cache contents for misses ; Definition at line 105 of file TTreeCache.h. ◆ fNbranches. Int_t TTreeCache::fNbranches {0}. protected . ! Number of branches in the cache ; Definition at line 44 of file TTreeCache.h. ◆ fNextClusterStart. Long64_t TTreeCache::fNextClusterStart {-1}. protected . ! End+1 of the cluster(s) where the current content was picked out ; Definition at line 43 of file TTreeCache.h. ◆ fNMissReadMiss. Int_t TTreeCache::fNMissReadMiss {0}. protected . Number of blocks read and not found in either cache. ; Definition at line 48 of file TTreeCache.h. ◆ fNMissReadOk. Int_t TTreeCache::fNMissReadOk {0}. protected . Number of blocks read, not found in the primary cache, and found in the secondary cache. ; Definition at line 46 of file TTreeCache.h. ◆ fNMissReadPref. Int_t TTreeCache::fNMissReadPref {0}. protected . Number of blocks read into the secondary (""miss"") cache. ; Definition at line 50 of file TTreeCache.h. ◆ fNReadMiss. Int_t TTreeCache::fNReadMiss {0}. protected . Number of blocks read and not found in the cache. ; Definition at line 47 of file TTreeCache.h. ◆ fNReadOk. Int_t TTreeCache::fNReadOk {0}. protected . Number of blocks read and found in the cache. ; Definition at line 45 of file TTreeCache.h. ◆ fNReadPref. Int_t TTreeCache::fNReadPref {0}. protected . Number of blocks that were prefetched. ; Definition at line 49 of file TTreeCache.h. ◆ fOneTime. bool TTreeCache::fOneTime {false}. protected . ! used in the learning phase ; Definition at line 57 of file TTreeCache.h. ◆ fOptimizeMisses. bool TTreeCache::fOptimizeMisses {false}. protected . ! true if we should optimize cache misses. ; Definition at line 72 of file TTreeCa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCache.html:55528,cache,cache,55528,doc/v632/classTTreeCache.html,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html,4,['cache'],['cache']
Performance,"of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooCachedReal.h>. Inheritance diagram for RooCachedReal:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RooCachedReal() [1/4]. RooCachedReal::RooCachedReal ; (; ). inline . Definition at line 22 of file RooCachedReal.h. ◆ RooCachedReal() [2/4]. RooCachedReal::RooCachedReal ; (; const char * ; name, . const char * ; title, . RooAbsReal & ; _func, . const RooArgSet & ; cacheObs . ). Constructor taking name, title and function to be cached and fixed choice of variable to cache. ; To control granularity of the binning of the cache histogram set the desired properties in the binning named ""cache"" in the observables of the function. If the fixed set of cache observables does not match the observables defined in the use context of the p.d.f the cache is still filled completely. Ee.g. when it is specified to cache x and p and only x is a observable in the given use context the cache histogram will store sampled values for all values of observable x and parameter p. In such a mode of operation the cache will also not be recalculated if the observable p changes ; Definition at line 68 of file RooCachedReal.cxx. ◆ RooCachedReal() [3/4]. RooCachedReal::RooCachedReal ; (; const char * ; name, . const char * ; title, . RooAbsReal & ; _func . ). Constructor taking name, title and function to be cached. ; To control granularity of the binning of the cache histogram set the desired properties in the binning named ""cache"" in the observables of the function ; Definition at line 42 of file RooCachedReal.cxx. ◆ RooCachedReal() [4/4]. RooCachedReal::RooCachedReal ; (; const RooCachedReal & ; other, . const char * ; name = nullptr . ). Copy constructor. ; Definition at line 87 of file RooCachedReal.cxx. Member Function Documentation. ◆ actualObservables()",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCachedReal.html:63923,cache,cache,63923,doc/master/classRooCachedReal.html,https://root.cern,https://root.cern/doc/master/classRooCachedReal.html,1,['cache'],['cache']
Performance,"of the member class and uses a more efficient internal mechanism to write the members to the file. You can override the default and specify that the member class Streameris used by setting the TClonesArray::BypassStreamer bit to false:; TClonesArray *fTracks;; fTracks->BypassStreamer(kFALSE); // use the member Streamer; When the kBypassStreamer bit is set, the automatically generated Streamercan call directly the method TClass::WriteBuffer. Bypassing the Streamer improves the performance when writing/reading the objects in the TClonesArray. However, the drawback is when a TClonesArray is written with split=0 bypassing the Streamer, the StreamerInfoof the class in the array being optimized, one cannot later use the TClonesArray with split > 0. For example, there is a problem with the following scenario: a class Foo has a TClonesArray of Bar objects the Foo object is written with split=0 to Tree T1. In this case the StreamerInfo for the class Bar is created in optimized mode in such a way that data members of the same type are written as an array improving the I/O performance. In a new program, T1 is read and a new Tree T2 is created with the object Foo in split > 1.; When the T2branch is created, the StreamerInfo for the class Bar is created with no optimization (mandatory for the split mode). The optimized Bar StreamerInfo is going to be used to read the TClonesArray in T1. The result will be Bar objects with data member values not in the right sequence. The solution to this problem is to call BypassStreamer(kFALSE) for the TClonesArray. In this case, the normal Bar::Streamer function will be called. The Bar::Streamer function works OK independently if the Bar StreamerInfohad been generated in optimized mode or not.; 11.4 Pointers and References in Persistency; An object pointer as a data member presents a challenge to the streaming software. If the object pointed to is saved every time, it could create circular dependencies and consume a large amount of disk space. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:477434,optimiz,optimized,477434,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,4,"['optimiz', 'perform']","['optimized', 'performance']"
Performance,"of the node #inode, one can do, for example:; Index *indices = kdtree->GetPointsIndexes();; Int_t first1, last1, first2, last2;; kdtree->GetPointsIndexes(inode, first1, last1, first2, last2);; for (Int_t ipoint=first1; ipoint<=last1; ipoint++){; point = indices[ipoint];; //do something with point;; }; for (Int_t ipoint=first2; ipoint<=last2; ipoint++){; point = indices[ipoint];; //do something with point;; }. Index TKDTree<Index, Value> GetNPointsNode(Int_t node) const; Get number of points in this node; for all the terminal nodes except last, the size is fBucketSize; for the last node it's fOffset%fBucketSize, or if fOffset%fBucketSize==0, it's also fBucketSize. void TKDTree<Index, Value> SetData(int npoints, int ndim, UInt_t bsize, float** data); Set the data array. See the constructor function comments for details. Int_t TKDTree<Index, Value> SetData(int idim, float* data); Set the coordinate #ndim of all points (the column #ndim of the data matrix); After setting all the data columns, proceed by calling Build() function; Note, that calling this function after Build() is not possible; Note also, that no checks on the array sizes is performed anywhere. void TKDTree<Index, Value> Spread(int ntotal, float* a, int* index, float& min, float& max) const; Calculate spread of the array a. Value TKDTree<Index, Value> KOrdStat(int ntotal, float* a, int k, int* index) const. copy of the TMath::KOrdStat because I need an Index work array. void TKDTree<Index, Value> MakeBoundaries(float* range = 0); Build boundaries for each node. Note, that the boundaries here are built; based on the splitting planes of the kd-tree, and don't necessarily pass; through the points of the original dataset. For the latter functionality; see function MakeBoundariesExact(); Boundaries can be retrieved by calling GetBoundary(inode) function that would; return an array of boundaries for the specified node, or GetBoundaries() function; that would return the complete array. void TKDTree<Index, Value> C",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TKDTree_int_float_.html:22175,perform,performed,22175,root/html602/TKDTree_int_float_.html,https://root.cern,https://root.cern/root/html602/TKDTree_int_float_.html,4,['perform'],['performed']
Performance,"of the node #inode, one can do, for example:; Index *indices = kdtree->GetPointsIndexes();; Int_t first1, last1, first2, last2;; kdtree->GetPointsIndexes(inode, first1, last1, first2, last2);; for (Int_t ipoint=first1; ipoint<=last1; ipoint++){; point = indices[ipoint];; //do something with point;; }; for (Int_t ipoint=first2; ipoint<=last2; ipoint++){; point = indices[ipoint];; //do something with point;; }. Index TKDTree<Index, Value> GetNPointsNode(Int_t node) const; Get number of points in this node; for all the terminal nodes except last, the size is fBucketSize; for the last node it's fOffset%fBucketSize, or if fOffset%fBucketSize==0, it's also fBucketSize. void TKDTree<Index, Value> SetData(int npoints, int ndim, UInt_t bsize, float** data); Set the data array. See the constructor function comments for details. Int_t TKDTree<Index, Value> SetData(int idim, float* data); Set the coordinate #ndim of all points (the column #ndim of the data matrix); After setting all the data columns, proceed by calling Build() function; Note, that calling this function after Build() is not possible; Note also, that no checks on the array sizes is performed anywhere. void TKDTree<Index, Value> Spread(int ntotal, float* a, int* index, float& min, float& max) const; Calculate spread of the array a. Value TKDTree<Index, Value> KOrdStat(int ntotal, float* a, int k, int* index) const. copy of the TMath::KOrdStat because I need an Index work array. void TKDTree<Index, Value> MakeBoundaries(float* range = 0x0); Build boundaries for each node. Note, that the boundaries here are built; based on the splitting planes of the kd-tree, and don't necessarily pass; through the points of the original dataset. For the latter functionality; see function MakeBoundariesExact(); Boundaries can be retrieved by calling GetBoundary(inode) function that would; return an array of boundaries for the specified node, or GetBoundaries() function; that would return the complete array. void TKDTree<Index, Value>",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TKDTree_int_float_.html:21463,perform,performed,21463,root/html528/TKDTree_int_float_.html,https://root.cern,https://root.cern/root/html528/TKDTree_int_float_.html,6,['perform'],['performed']
Performance,"of the pool used for implicit multi-threading. ; Definition at line 578 of file TROOT.cxx. ◆ GetMacroPath(). TString & ROOT::GetMacroPath ; (; ). Definition at line 469 of file TROOT.cxx. ◆ GetROOT(). TROOT * ROOT::GetROOT ; (; ). Definition at line 465 of file TROOT.cxx. ◆ GetRuleIncludes(). void ROOT::GetRuleIncludes ; (; std::list< std::string > & ; result). Get the list of includes specified in the shema rules. ; Definition at line 841 of file RConversionRuleParser.cxx. ◆ GetThreadPoolSize(). UInt_t ROOT::GetThreadPoolSize ; (; ). Returns the size of ROOT's thread pool. ; Definition at line 563 of file TROOT.cxx. ◆ HasValidDataMembers(). Bool_t ROOT::HasValidDataMembers ; (; SchemaRuleMap_t & ; rule, . MembersTypeMap_t & ; members, . std::string & ; error_string . ). Check if given rule contains references to valid data members. ; Definition at line 447 of file RConversionRuleParser.cxx. ◆ IsImplicitMTEnabled(). bool ROOT::IsImplicitMTEnabled ; (; ). Returns true if the implicit multi-threading in ROOT is enabled. ; Definition at line 556 of file TROOT.cxx. ◆ MakeSeq() [1/2]. template<class T > . TSeq< T > ROOT::MakeSeq ; (; T ; begin, . T ; end, . T ; step = 1 . ). Definition at line 206 of file TSeq.hxx. ◆ MakeSeq() [2/2]. template<class T > . TSeq< T > ROOT::MakeSeq ; (; T ; end). Definition at line 200 of file TSeq.hxx. ◆ ParseRule(). Bool_t ROOT::ParseRule ; (; std::string ; rule, . ROOT::Internal::MembersMap_t & ; result, . std::string & ; error_string . ). Parse the schema rule as specified in the LinkDef file. ; Definition at line 103 of file RConversionRuleParser.cxx. ◆ ProcessReadPragma(). void ROOT::ProcessReadPragma ; (; const char * ; args, . std::string & ; error_string . ). I am being called when a read pragma is encountered. ; Definition at line 885 of file RConversionRuleParser.cxx. ◆ ProcessReadRawPragma(). void ROOT::ProcessReadRawPragma ; (; const char * ; args, . std::string & ; error_string . ). I am being called then a readraw pragma is enc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v624/namespaceROOT.html:25656,multi-thread,multi-threading,25656,doc/v624/namespaceROOT.html,https://root.cern,https://root.cern/doc/v624/namespaceROOT.html,1,['multi-thread'],['multi-threading']
Performance,"of the pool used for implicit multi-threading. ; Definition at line 579 of file TROOT.cxx. ◆ GetMacroPath(). TString & ROOT::GetMacroPath ; (; ). Definition at line 470 of file TROOT.cxx. ◆ GetROOT(). TROOT * ROOT::GetROOT ; (; ). Definition at line 466 of file TROOT.cxx. ◆ GetRuleIncludes(). void ROOT::GetRuleIncludes ; (; std::list< std::string > & ; result). Get the list of includes specified in the shema rules. ; Definition at line 841 of file RConversionRuleParser.cxx. ◆ GetThreadPoolSize(). UInt_t ROOT::GetThreadPoolSize ; (; ). Returns the size of ROOT's thread pool. ; Definition at line 564 of file TROOT.cxx. ◆ HasValidDataMembers(). Bool_t ROOT::HasValidDataMembers ; (; SchemaRuleMap_t & ; rule, . MembersTypeMap_t & ; members, . std::string & ; error_string . ). Check if given rule contains references to valid data members. ; Definition at line 447 of file RConversionRuleParser.cxx. ◆ IsImplicitMTEnabled(). bool ROOT::IsImplicitMTEnabled ; (; ). Returns true if the implicit multi-threading in ROOT is enabled. ; Definition at line 557 of file TROOT.cxx. ◆ MakeSeq() [1/2]. template<class T > . TSeq< T > ROOT::MakeSeq ; (; T ; begin, . T ; end, . T ; step = 1 . ). Definition at line 206 of file TSeq.hxx. ◆ MakeSeq() [2/2]. template<class T > . TSeq< T > ROOT::MakeSeq ; (; T ; end). Definition at line 200 of file TSeq.hxx. ◆ ParseRule(). Bool_t ROOT::ParseRule ; (; std::string ; rule, . ROOT::Internal::MembersMap_t & ; result, . std::string & ; error_string . ). Parse the schema rule as specified in the LinkDef file. ; Definition at line 103 of file RConversionRuleParser.cxx. ◆ ProcessReadPragma(). void ROOT::ProcessReadPragma ; (; const char * ; args, . std::string & ; error_string . ). I am being called when a read pragma is encountered. ; Definition at line 885 of file RConversionRuleParser.cxx. ◆ ProcessReadRawPragma(). void ROOT::ProcessReadRawPragma ; (; const char * ; args, . std::string & ; error_string . ). I am being called then a readraw pragma is enc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v622/namespaceROOT.html:25617,multi-thread,multi-threading,25617,doc/v622/namespaceROOT.html,https://root.cern,https://root.cern/doc/v622/namespaceROOT.html,1,['multi-thread'],['multi-threading']
Performance,"of the pool used for implicit multi-threading. ; Definition at line 580 of file TROOT.cxx. ◆ GetMacroPath(). TString & ROOT::GetMacroPath ; (; ). Definition at line 468 of file TROOT.cxx. ◆ GetROOT(). TROOT * ROOT::GetROOT ; (; ). Definition at line 464 of file TROOT.cxx. ◆ GetRuleIncludes(). void ROOT::GetRuleIncludes ; (; std::list< std::string > & ; result). Get the list of includes specified in the shema rules. ; Definition at line 841 of file RConversionRuleParser.cxx. ◆ GetThreadPoolSize(). UInt_t ROOT::GetThreadPoolSize ; (; ). Returns the size of ROOT's thread pool. ; Definition at line 565 of file TROOT.cxx. ◆ HasValidDataMembers(). Bool_t ROOT::HasValidDataMembers ; (; SchemaRuleMap_t & ; rule, . MembersTypeMap_t & ; members, . std::string & ; error_string . ). Check if given rule contains references to valid data members. ; Definition at line 447 of file RConversionRuleParser.cxx. ◆ IsImplicitMTEnabled(). bool ROOT::IsImplicitMTEnabled ; (; ). Returns true if the implicit multi-threading in ROOT is enabled. ; Definition at line 558 of file TROOT.cxx. ◆ MakeSeq() [1/2]. template<class T > . TSeq< T > ROOT::MakeSeq ; (; T ; begin, . T ; end, . T ; step = 1 . ). Definition at line 213 of file TSeq.hxx. ◆ MakeSeq() [2/2]. template<class T > . TSeq< T > ROOT::MakeSeq ; (; T ; end). Definition at line 207 of file TSeq.hxx. ◆ ParseRule(). Bool_t ROOT::ParseRule ; (; std::string ; rule, . ROOT::Internal::MembersMap_t & ; result, . std::string & ; error_string . ). Parse the schema rule as specified in the LinkDef file. ; Definition at line 103 of file RConversionRuleParser.cxx. ◆ ProcessReadPragma(). void ROOT::ProcessReadPragma ; (; const char * ; args, . std::string & ; error_string . ). I am being called when a read pragma is encountered. ; Definition at line 885 of file RConversionRuleParser.cxx. ◆ ProcessReadRawPragma(). void ROOT::ProcessReadRawPragma ; (; const char * ; args, . std::string & ; error_string . ). I am being called then a readraw pragma is enc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v626/namespaceROOT.html:28856,multi-thread,multi-threading,28856,doc/v626/namespaceROOT.html,https://root.cern,https://root.cern/doc/v626/namespaceROOT.html,1,['multi-thread'],['multi-threading']
Performance,"of the shape in [length^3]. void ComputeBBox(); compute bounding box for a polygone; Check if the sections are in increasing Z order. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this shape; check total z range. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the polygone; first find out in which Z section the point is in. void LocatePhi(Double_t* point, Int_t& ipsec) const; Locates index IPSEC of the phi sector containing POINT. Int_t GetPhiCrossList(Double_t* point, Double_t* dir, Int_t istart, Double_t* sphi, Int_t* iphi, Double_t stepmax = TGeoShape::Big()) const; Returns lists of PGON phi crossings for a ray starting from POINT. Bool_t SliceCrossingInZ(Double_t* point, Double_t* dir, Int_t nphi, Int_t* iphi, Double_t* sphi, Double_t& snext, Double_t stepmax) const; Performs ray propagation between Z segments. Bool_t SliceCrossingZ(Double_t* point, Double_t* dir, Int_t nphi, Int_t* iphi, Double_t* sphi, Double_t& snext, Double_t stepmax) const; Performs ray propagation between Z segments. Bool_t SliceCrossingIn(Double_t* point, Double_t* dir, Int_t ipl, Int_t nphi, Int_t* iphi, Double_t* sphi, Double_t& snext, Double_t stepmax) const; Check boundary crossing inside phi slices. Return distance snext to first crossing; if smaller than stepmax.; Protection in case point is in phi gap or close to phi boundaries and exiting. Bool_t SliceCrossing(Double_t* point, Double_t* dir, Int_t nphi, Int_t* iphi, Double_t* sphi, Double_t& snext, Double_t stepmax) const; Check boundary crossing inside phi slices. Return distance snext to first crossing; if smaller than stepmax. Bool_t IsCrossingSlice(Double_t* point, Double_t* dir, Int_t iphi, Double_t sstart, Int_t& ipl, Double_t& snext, Double_t stepmax) const; Chec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoPgon.html:15396,Perform,Performs,15396,root/html532/TGeoPgon.html,https://root.cern,https://root.cern/root/html532/TGeoPgon.html,1,['Perform'],['Performs']
Performance,"of the tree next time.; 1626 fTreeNumber = -1;; 1627 ; 1628 element->SetLoadResult(returnCode);; 1629 return returnCode;; 1630 }; 1631 // ----- End of modifications by MvL; 1632 ; 1633 // Copy the chain's clone list into the new tree's; 1634 // clone list so that branch addresses stay synchronized.; 1635 if (fClones) {; 1636 for (TObjLink* lnk = fClones->FirstLink(); lnk; lnk = lnk->Next()) {; 1637 TTree* clone = (TTree*) lnk->GetObject();; 1638 ((TChain*) fTree)->TTree::AddClone(clone);; 1639 }; 1640 }; 1641 ; 1642 // Since some of the friends of this chain might simple trees; 1643 // (i.e., not really chains at all), we need to execute this; 1644 // before calling LoadTree(entry) on the friends (so that; 1645 // they use the correct read entry number).; 1646 ; 1647 // Change the new current tree to the new entry.; 1648 Long64_t loadResult = fTree->LoadTree(treeReadEntry);; 1649 if (loadResult == treeReadEntry) {; 1650 element->SetLoadResult(0);; 1651 } else {; 1652 // This is likely to be an internal error, if treeReadEntry was not in range; 1653 // (or intentionally -2 for TChain::GetEntries) then something happened; 1654 // that is very odd/surprising.; 1655 element->SetLoadResult(-5);; 1656 }; 1657 ; 1658 ; 1659 // Change the chain friends to the new entry.; 1660 if (fFriends) {; 1661 // An alternative would move this code to each of the function; 1662 // calling LoadTree (and to overload a few more).; 1663 TIter next(fFriends);; 1664 TFriendLock lock(this, kLoadTree);; 1665 TFriendElement* fe = nullptr;; 1666 while ((fe = (TFriendElement*) next())) {; 1667 TTree* t = fe->GetTree();; 1668 if (!t) continue;; 1669 if (t->GetTreeIndex()) {; 1670 t->GetTreeIndex()->UpdateFormulaLeaves(nullptr);; 1671 }; 1672 if (t->GetTree() && t->GetTree()->GetTreeIndex()) {; 1673 t->GetTree()->GetTreeIndex()->UpdateFormulaLeaves(GetTree());; 1674 }; 1675 if (treeReadEntry == -2) {; 1676 // an entry after the end of the chain was requested (it usually happens when GetEntries is ca",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TChain_8cxx_source.html:59367,load,loadResult,59367,doc/master/TChain_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TChain_8cxx_source.html,2,['load'],['loadResult']
Performance,"of this function. RooDerivative* derivative(RooRealVar& obs, const RooArgSet& normSet, Int_t order, Double_t eps = 0.001); Return function representing first, second or third order derivative of this function. RooAbsMoment* moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); Return function representing moment of function of given order. If central is; true, the central moment is given <(x-<x>)^2>. RooAbsMoment* moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Return function representing moment of p.d.f (normalized w.r.t given observables) of given order. If central is; true, the central moment is given <(x-<x>)^2>. If intNormObs is true, the moment of the function integrated over; all normalization observables is returned. Double_t findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval). Return value of x (in range xmin,xmax) at which function equals yval.; (Calculation is performed with Brent root finding algorithm). RooGenFunction* iGenFunction(RooRealVar& x, const RooArgSet& nset = RooArgSet()). RooMultiGenFunction* iGenFunction(const RooArgSet& observables, const RooArgSet& nset = RooArgSet()). RooFitResult* chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Perform a chi^2 fit to given histogram By default the fit is executed through the MINUIT; commands MIGRAD, HESSE in succession. The following named arguments are supported. Options to control construction of -log(L). Range(const char* name) -- Fit only data inside range with given name; Range(Double_t lo, Double_t hi) -- Fit only data inside given range. A range named ""fit"" is created on the f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsReal.html:73734,perform,performed,73734,root/html534/RooAbsReal.html,https://root.cern,https://root.cern/root/html534/RooAbsReal.html,6,['perform'],['performed']
Performance,"of() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual const TTree*RooAbsDataStore::tree() const; virtual voidTObject::UseCurrentStyle(); virtual Bool_tvalid() const; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Double_tweight() const; virtual Double_tweight(Int_t index) const; virtual Double_tweightError(RooAbsData::ErrorType etype = RooAbsData::Poisson) const; virtual voidweightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = RooAbsData::Poisson) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidattachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. TIterator*RooAbsDataStore::_cacheIter! Iterator over cached variables; RooArgSetRooAbsDataStore::_cachedVars; Int_t_curIndex! Index associated with current event; RooAbsDataStore*_curStore! Datastore associated with current event; map<std::string,RooAbsDataStore*>_dataMap; Bool_tRooAbsDataStore::_doDirtyPropSwitch do (de)activate dirty state propagation when loading a data point; RooCatego",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooCompositeDataStore.html:7830,cache,cachedVars,7830,root/html526/RooCompositeDataStore.html,https://root.cern,https://root.cern/root/html526/RooCompositeDataStore.html,3,['cache'],['cachedVars']
Performance,"off tracking of objects in the TObjectTable. ;  . Protected Member Functions;  TGeoManager (const TGeoManager &)=delete;  Default units in GDML if not explicit in some tags. ;  ; TGeoManager & operator= (const TGeoManager &)=delete;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Static Protected Attributes; static EDefaultUnits fgDefaultUnits = TGeoManager::kRootUnits;  Precision to be used in ASCII exports. ;  ; static UInt_t fgExportPrecision = 17;  Maximum number of Xtru vertices. ;  ; static Bool_t fgLock = kFALSE;  mutex for navigator booking in MT mode ;  ; static Int_t fgMaxDaughters = 1;  Maximum level in geometry. ;  ; static Int_t fgMaxLevel = 1;  Verbosity level for Info messages (no IO). ;  ; static Int_t fgMaxXtruVert = 1;  Maximum number of daughters. ;  ; static std::mutex fgMutex;  ; static Int_t fgVerboseLevel = 1;  Lock preventing a second geometry to be loaded. ;  . Private Types; typedef std::map< std::string, Double_t > ConstPropMap_t;  ; typedef std::map< std::thread::id, TGeoNavigatorArray * > NavigatorsMap_t;  bits used for voxelization ;  ; typedef NavigatorsMap_t::iterator NavigatorsMapIt_t;  ; typedef std::map< std::thread::id, Int_t > ThreadsMap_t;  ; typedef ThreadsMap_t::const_iterator ThreadsMapIt_t;  . Private Member Functions; void Init ();  Initialize manager class. ;  ; Bool_t InitArrayPNE () const;  Initialize PNE array for fast access via index and unique-id. ;  ; Bool_t InsertPNEId (Int_t uid, Int_t ientry);  Insert a PN entry in the sorted array of indexes. ;  ; Bool_t IsLoopingVolumes () const;  ; void SetLoopVolumes (Bool_t flag=kTRUE);  ; void UpdateElements ();  Update element flags when geometry is loaded from a file. ;  ; void Voxelize (Option_t *option=nullptr);  Voxelize all non-divided volumes. ;  . Private Attributes; Bool_t fActivity;  flag for GL reflec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoManager.html:62599,load,loaded,62599,doc/master/classTGeoManager.html,https://root.cern,https://root.cern/doc/master/classTGeoManager.html,1,['load'],['loaded']
Performance,"ofile3D::GetBinError). Int_t BufferEmpty(Int_t action = 0); Fill histogram with all entries in the buffer.; action = -1 histogram is reset and refilled from the buffer (called by THistPainter::Paint); action = 0 histogram is filled from the buffer; action = 1 histogram is filled and buffer is deleted; The buffer is automatically deleted when the number of entries; in the buffer is greater than the number of entries in the histogram. Int_t BufferFill(Double_t x, Double_t y, Double_t z, Double_t t, Double_t w); accumulate arguments in buffer. When buffer is full, empty the buffer; fBuffer[0] = number of entries in buffer; fBuffer[1] = w of first entry; fBuffer[2] = x of first entry; fBuffer[3] = y of first entry; fBuffer[4] = z of first entry; fBuffer[5] = t of first entry. void Copy(TObject& hnew) const; -*-*-*-*Copy a Profile3D histogram to a new profile2D histogram; *-* =======================================================. Bool_t Divide(TF1* h1, Double_t c1 = 1); Performs the operation: this = this/(c1*f1); This function is not implemented. Bool_t Divide(const TH1* h1); Divide this profile2D by h1*-*-; *-* ===========================. this = this/h1. This function return kFALSE if the divide operation failed. Bool_t Divide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """"); -*-*Replace contents of this profile2D by the division of h1 by h2; *-* ==============================================================. this = c1*h1/(c2*h2). This function return kFALSE if the divide operation failed. Int_t Fill(Double_t x, Double_t y, Double_t z, Double_t t); -*-*-*Fill a Profile3D histogram (no weights); *-* =======================================. Int_t Fill(Double_t x, Double_t y, Double_t z, Double_t t, Double_t w); -*-*-*Fill a Profile3D histogram with weights; *-* =======================================. Double_t GetBinContent(Int_t bin) const; Return bin content of a Profile3D histogram*-*-; *-* =====================================",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProfile3D.html:36273,Perform,Performs,36273,root/html602/TProfile3D.html,https://root.cern,https://root.cern/root/html602/TProfile3D.html,2,['Perform'],['Performs']
Performance,"ofile3D::GetBinError). Int_t BufferEmpty(Int_t action = 0); Fill histogram with all entries in the buffer.; action = -1 histogram is reset and refilled from the buffer (called by THistPainter::Paint); action = 0 histogram is filled from the buffer; action = 1 histogram is filled and buffer is deleted; The buffer is automatically deleted when the number of entries; in the buffer is greater than the number of entries in the histogram. Int_t BufferFill(Double_t x, Double_t y, Double_t z, Double_t t, Double_t w); accumulate arguments in buffer. When buffer is full, empty the buffer; fBuffer[0] = number of entries in buffer; fBuffer[1] = w of first entry; fBuffer[2] = x of first entry; fBuffer[3] = y of first entry; fBuffer[4] = z of first entry; fBuffer[5] = t of first entry. void Copy(TObject& hnew) const; -*-*-*-*Copy a Profile3D histogram to a new profile2D histogram; *-* =======================================================. Bool_t Divide(TF1* h1, Double_t c1 = 1); Performs the operation: this = this/(c1*f1); This function is not implemented. Bool_t Divide(const TH1* h1); Divide this profile2D by h1*-*-; *-* ===========================. this = this/h1. This function return kFALSE if the divide operation failed. Bool_t Divide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """"); -*-*Replace contents of this profile2D by the division of h1 by h2; *-* ==============================================================. this = c1*h1/(c2*h2). This function return kFALSE if the divide operation failed. TH1 * DrawCopy(Option_t* option = """") const; Draw a copy of this profile3D histogram*-*-*-; *-* =======================================. Int_t Fill(Double_t x, Double_t y, Double_t z, Double_t t); -*-*-*Fill a Profile3D histogram (no weights); *-* =======================================. Int_t Fill(Double_t x, Double_t y, Double_t z, Double_t t, Double_t w); -*-*-*Fill a Profile3D histogram with weights; *-* ===================================",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProfile3D.html:34563,Perform,Performs,34563,root/html534/TProfile3D.html,https://root.cern,https://root.cern/root/html534/TProfile3D.html,1,['Perform'],['Performs']
Performance,"ogicalShape::DestroyPhysicals(); virtual voidDirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; voidEnforceTriangles(); static Bool_tGetEnforceTriangles(); TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; UInt_tGetNbPols(); vector<Double_t>&GetNormals(); vector<Int_t>&GetPolyDesc(); TGLScene*TGLLogicalShape::GetScene() const; vector<Double_t>&GetVertices(); TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tTGLLogicalShape::KeepDuringSmartRefresh() const; virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; UInt_tTGLLogicalShape::Ref() const; Bool_tTGLLogicalShape::SetDLCache(Bool_t cached); static voidSetEnforceTriangles(Bool_t e); voidSetFromMesh(const RootCsg::TBaseMesh* m); virtual Bool_tTGLLogicalShape::ShouldDLCache(const TGLRnrCtx& rnrCtx) const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidTGLLogicalShape::StrongRef(Bool_t strong) const; voidTGLLogicalShape::SubRef(TGLPhysicalShape* phys) const; virtual TGLLogicalShape::ELODAxesTGLLogicalShape::SupportedLODAxes() const; virtual Bool_tTGLLogicalShape::SupportsSecondarySelect() const; UInt_tTGLLogicalShape::UnrefFirstPhysical(); virtual voidTGLLogicalShape::UpdateBoundingBox(); voidTGLLogicalShape::UpdateBoundingBoxesOfPhysicals().",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGLFaceSet.html:2010,cache,cached,2010,root/html528/TGLFaceSet.html,https://root.cern,https://root.cern/root/html528/TGLFaceSet.html,4,['cache'],['cached']
Performance,"ogram classes in ROOT.Definition TH1.h:59; TH1::GetZaxisTAxis * GetZaxis()Definition TH1.h:326; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf315_projectpdfDefinition rf315_projectpdf.py:1; ; [#0] WARNING:InputArguments -- The parameter 'sigmax' with range [-inf, inf] of the RooGaussian 'gaussx' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:NumericIntegration -- RooRealIntegral::init([gaussy_NORM[y]_X_gaussx_NORM[x]]_Int[y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:Fitting -- RooAbsPdf::fitTo(model_Int[y]_Norm[x,y]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_Int[y]_Norm[x,y]_genData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for a1: using 0.4; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for y: using 0.4; [#1] INFO:NumericIntegration -- RooRealIntegral::init([gaussy_NORM[y]_X_gaussx_NORM[x]]_Int[y]) using numeric integrator RooIntegrator1D to calculate Int(y); ; prevFCN = 12037.78496 a1=-1.469, ; prevFCN = 1900.132597 a1=-1.531, ; prevFCN = 1901.591671 a1=-1.497, ; prevFCN = 1900.088181 a1=-1.503, ; prevFCN = 1900.238998 a1=-1.5, y=0.03051, ; prevFCN = 1900.156536 y=-0.03051, ; prevFCN = 1900.156536 y=0.003051, ; prevFCN = 1900.156536 y=-0.003051, ; prevFCN = 1900.156536 a1=-1.497, y=0, ; prevFCN = 19",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf315__projectpdf_8C.html:7486,optimiz,optimization,7486,doc/master/rf315__projectpdf_8C.html,https://root.cern,https://root.cern/doc/master/rf315__projectpdf_8C.html,1,['optimiz'],['optimization']
Performance,"ogram of the frame's variable and append it to the frame. ;  ; RooPlot * plotOn (RooPlot *frame, PlotOpt o) const override;  Back end function to plotting functionality. ;  ; void printArgs (std::ostream &os) const override;  Print argument of dataset, i.e. the observable names. ;  ; void printDataHistogram (std::ostream &os, RooRealVar *obs) const;  ; void printMultiline (std::ostream &os, Int_t content, bool verbose=false, TString indent="""") const override;  Print the details on the dataset contents. ;  ; void printValue (std::ostream &os) const override;  Print value of the dataset, i.e. the sum of weights contained in the dataset. ;  ; void removeSelfFromDir ();  ; void reset () override;  Reset all bin weights to zero. ;  ; void set (const RooArgSet &row, double weight, double wgtErr=-1.);  Set a bin content. ;  ; void set (const RooArgSet &row, double weight, double wgtErrLo, double wgtErrHi);  Set a bin content. ;  ; void set (std::size_t binNumber, double weight, double wgtErr);  Set bin content of bin that was last loaded with get(std::size_t). ;  ; void SetName (const char *name) override;  Change the name of the RooDataHist. ;  ; void SetNameTitle (const char *name, const char *title) override;  Change the title of this RooDataHist. ;  ; TIterator * sliceIterator (RooAbsArg &sliceArg, const RooArgSet &otherArgs);  Create an iterator over all bins in a slice defined by the subset of observables listed in sliceArg. ;  ; void Streamer (TBuffer &) override;  Stream an object of class RooDataHist. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; double sum (bool correctForBinSize, bool inverseCorr=false) const;  Return the sum of the weights of all bins in the histogram. ;  ; double sum (const RooArgSet &sumSet, const RooArgSet &sliceSet, bool correctForBinSize, bool inverseCorr, const std::map< const RooAbsArg *, std::pair< double, double > > &ranges, std::function< double(int)> getBinScale=[](int){ return 1.0;});  Return the sum of the we",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooDataHist.html:8429,load,loaded,8429,doc/master/classRooDataHist.html,https://root.cern,https://root.cern/doc/master/classRooDataHist.html,1,['load'],['loaded']
Performance,"ograms,”; 4031/// Nucl. Instrum. Meth. 221 (1984) 437.; 4032///; 4033/// \f[; 4034/// NLL = \sum_{i}{( f(x(i) | p ) + y(i)\log(y(i)/ f(x(i) | p )) - y(i)) }; 4035/// \f]; 4036/// By using this formulation, `2*NLL` can be interpreted as the chi-square resulting from the fit.; 4037///; 4038/// This method should be always used when the bin content represents counts (i.e. errors are sqrt(N) ).; 4039/// The likelihood method has the advantage of treating correctly bins with low statistics. In case of high; 4040/// statistics/bin the distribution of the bin content becomes a normal distribution and the likelihood and the chi2 fit; 4041/// give the same result.; 4042///; 4043/// The likelihood method, although a bit slower, it is therefore the recommended method,; 4044/// when the histogram represent counts (Poisson statistics), where the chi-square methods may; 4045/// give incorrect results, especially in case of low statistics.; 4046/// In case of a weighted histogram, it is possible to perform also a likelihood fit by using the; 4047/// option ""WL"". Note a weighted histogram is a histogram which has been filled with weights and it; 4048/// has the information on the sum of the weight square for each bin ( TH1::Sumw2() has been called).; 4049/// The bin error for a weighted histogram is the square root of the sum of the weight square.; 4050///; 4051/// \anchor HFitRes; 4052/// ### Fit Result; 4053///; 4054/// The function returns a TFitResultPtr which can hold a pointer to a TFitResult object.; 4055/// By default the TFitResultPtr contains only the status of the fit which is return by an; 4056/// automatic conversion of the TFitResultPtr to an integer. One can write in this case directly:; 4057///; 4058/// ~~~ {.cpp}; 4059/// Int_t fitStatus = h->Fit(myFunc);; 4060/// ~~~; 4061///; 4062/// If the option ""S"" is instead used, TFitResultPtr behaves as a smart; 4063/// pointer to the TFitResult object. This is useful for retrieving the full result information from the fit, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:165054,perform,perform,165054,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,1,['perform'],['perform']
Performance,"oid ); destructor. void CreateMLPOptions(TString ); translates options from option string into TMlpANN language. void DeclareOptions(); define the options (their key words) that can be set in the option string; know options:; NCycles <integer> Number of training cycles (too many cycles could overtrain the network); HiddenLayers <string> Layout of the hidden layers (nodes per layer); * specifiactions for each hidden layer are separated by commata; * for each layer the number of nodes can be either absolut (simply a number); or relative to the number of input nodes to the neural net (N); * there is always a single node in the output layer; example: a net with 6 input nodes and ""Hiddenlayers=N-1,N-2"" has 6,5,4,1 nodes in the; layers 1,2,3,4, repectively. void ProcessOptions(); builds the neural network as specified by the user. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); calculate the value of the neural net for the current event. void Train( void ); performs TMlpANN training; available learning methods:. TMultiLayerPerceptron::kStochastic; TMultiLayerPerceptron::kBatch; TMultiLayerPerceptron::kSteepestDescent; TMultiLayerPerceptron::kRibierePolak; TMultiLayerPerceptron::kFletcherReeves; TMultiLayerPerceptron::kBFGS. TMultiLayerPerceptron wants test and training tree at once; so merge the training and testing trees from the MVA factory first:. void AddWeightsXMLTo(void* parent) const; write weights to xml file. void ReadWeightsFromXML(void* wghtnode); rebuild temporary textfile from xml weightfile and load this; file into MLP. void ReadWeightsFromStream(istream& istr); read weights from stream; since the MLP can not read from the stream, we; 1st: write the weights to temporary file. void MakeClass(const TString& classFileName = TString("""")) const; create reader class for classifier -> overwrites base class function; create specific class for TMultiLayerPerceptron. void MakeClassSpecific(ostream& , const TString& ) const; write specific classifier r",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MethodTMlpANN.html:17781,perform,performs,17781,root/html528/TMVA__MethodTMlpANN.html,https://root.cern,https://root.cern/root/html528/TMVA__MethodTMlpANN.html,10,['perform'],['performs']
Performance,"oid *end);; 1719/// If the sizeof iterator is greater than fgIteratorArenaSize, call delete on the addresses,; 1720/// Otherwise just call the iterator's destructor.; 1721 ; 1722TVirtualCollectionProxy::DeleteTwoIterators_t TGenCollectionProxy::GetFunctionDeleteTwoIterators(Bool_t read); 1723{; 1724 if (read) {; 1725 if ( !fValue.load(std::memory_order_relaxed) ) InitializeEx(kFALSE);; 1726 if ( (fProperties & kIsAssociative) && read); 1727 return TGenCollectionProxy__StagingDeleteTwoIterators;; 1728 }; 1729 ; 1730 if ( fFunctionDeleteTwoIterators ) return fFunctionDeleteTwoIterators;; 1731 ; 1732 if ( !fValue.load(std::memory_order_relaxed) ) InitializeEx(kFALSE);; 1733 ; 1734 // TODO could RVec use something faster than SlowCopyIterator?; 1735 if (fSTL_type==ROOT::kSTLvector || (fProperties & kIsEmulated)); 1736 return fFunctionDeleteTwoIterators = TGenCollectionProxy__VectorDeleteTwoIterators;; 1737 else if ( (fProperties & kIsAssociative) && read); 1738 return TGenCollectionProxy__StagingDeleteTwoIterators;; 1739 else; 1740 return fFunctionDeleteTwoIterators = TGenCollectionProxy__SlowDeleteTwoIterators;; 1741}; 1742 ; 1743////////////////////////////////////////////////////////////////////////////////; 1744/// Return the set of action necessary to stream in this collection member-wise coming from; 1745/// the old value class layout refered to by 'version'.; 1746 ; 1747TStreamerInfoActions::TActionSequence *TGenCollectionProxy::GetConversionReadMemberWiseActions(TClass *oldClass, Int_t version); 1748{; 1749 if (oldClass == 0) {; 1750 return 0;; 1751 }; 1752 TObjArray* arr = 0;; 1753 TStreamerInfoActions::TActionSequence *result = 0;; 1754 if (fConversionReadMemberWise) {; 1755 std::map<std::string, TObjArray*>::iterator it;; 1756 ; 1757 it = fConversionReadMemberWise->find( oldClass->GetName() );; 1758 ; 1759 if( it != fConversionReadMemberWise->end() ) {; 1760 arr = it->second;; 1761 }; 1762 ; 1763 if (arr) {; 1764 result = (TStreamerInfoActions::TActionSequence",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:58169,load,load,58169,doc/master/TGenCollectionProxy_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html,1,['load'],['load']
Performance,"oid *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Member Functions; void UpdateCache () const;  largest box diagonal seen in OfInterest() - used when bootstrapping interest box ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; Bool_t fCacheDirty;  ; TGLMatrix fCamBase;  ; TGLMatrix fCamTrans;  ; TGLVector3 * fCenter;  ; TGLMatrix fClipM;  modelView matrix (cached) ;  ; TGLVector3 fDefCenter;  ; Double_t fDollyDefault;  last applied far-clip ;  ; Double_t fDollyDistance;  ; TGLVector3 fExtCenter;  ; Bool_t fExternalCenter;  ; Double_t fFarClip;  last applied near-clip ;  ; TGLVector3 fFDCenter;  ; Bool_t fFixDefCenter;  ; TGLPlane fFrustumPlanes [kPlanesPerFrustum];  object space clip matrix (cached) ;  ; TGLBoundingBox fInterestBox;  viewport (GL coords - origin bottom left) ;  ; Double_t fLargestSeen;  the interest box - created in UpdateInterest() ;  ; TGLMatrix fLastNoPickProjM;  timestamp ;  ; TGLMatrix fModVM;  projection matrix (cached) ;  ; Double_t fNearClip;  current camera center ;  ; TGLMatrix fProjM;  no-pick projection matrix (cached) ;  ; UInt_t fTimeStamp;  cached items dirty? ;  ; Float_t fVAxisMinAngle;  ; TGLRect fViewport;  frustum planes (cached) ;  ; Bool_t fWasArcBalled;  . Static Protected Attributes; static UInt_t fgDollyDeltaSens = 500;  . Private Member Functions;  TGLCamera (const TGLCamera &)=delete;  ; TGLBoundingBox Frustum (Bool_t asBox=kTRUE) const;  expansion c.f. aligned current frustum box ;  ; TGLCamera & operator= (const TGLCamera &)=delete;  . Private Attributes; TGLBoundingBox fInterestFrustum;  previous interest box (DEBUG) ;  ; TGLBoundingBox fInterestFrustumAsBox;  frustum basis of current interest box - NOT a true BB! (DEBUG) ;  ; TGLBoun",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGLCamera.html:17962,cache,cached,17962,doc/master/classTGLCamera.html,https://root.cern,https://root.cern/doc/master/classTGLCamera.html,6,['cache'],['cached']
Performance,"oid *obj, Bool_t up=kTRUE);  Cast obj of this class type up to baseclass cl if up is true. ;  ; char * EscapeChars (const char *text) const;  Introduce an escape character (@) in front of a special chars. ;  ; TVirtualStreamerInfo * FindConversionStreamerInfo (const char *onfile_classname, UInt_t checksum) const;  Return a Conversion StreamerInfo from the class 'classname' for the layout represented by 'checksum' to this class, if any. ;  ; TVirtualStreamerInfo * FindConversionStreamerInfo (const TClass *onfile_cl, UInt_t checksum) const;  Return a Conversion StreamerInfo from the class represented by cl for the layout represented by 'checksum' to this class, if any. ;  ; TVirtualStreamerInfo * FindStreamerInfo (UInt_t checksum, Bool_t isTransient=kFALSE) const;  Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. ;  ; TVirtualStreamerInfo * FindStreamerInfoAbstractEmulated (UInt_t checksum) const;  For the case where the requestor class is emulated and this class is abstract, returns a pointer to the TVirtualStreamerInfo object for version with an emulated representation whether or not the class is loaded. ;  ; void ForceReload (TClass *oldcl);  we found at least one equivalent. ;  ; TClass * GetActualClass (const void *object) const;  Return a pointer to the real class of the object. ;  ; TClass * GetBaseClass (const char *classname);  Return pointer to the base class ""classname"". ;  ; TClass * GetBaseClass (const TClass *base);  Return pointer to the base class ""cl"". ;  ; Int_t GetBaseClassOffset (const TClass *toBase, void *address=nullptr, bool isDerivedObject=true);  ; TClass * GetBaseDataMember (const char *datamember);  Return pointer to (base) class that contains datamember. ;  ; UInt_t GetCheckSum (Bool_t &isvalid) const;  Return GetCheckSum(kCurrentCheckSum,isvalid);. ;  ; UInt_t GetCheckSum (ECheckSum code, Bool_t &isvalid) const;  Compute and/or return the class check sum. ;  ; UInt_t GetCheckSum (ECheckSum code=kCurrentCheckSum",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTClass.html:9444,load,loaded,9444,doc/v632/classTClass.html,https://root.cern,https://root.cern/doc/v632/classTClass.html,3,['load'],['loaded']
Performance,"oid ;  CTTRD1A trapezoid with the x dimension varying along z ;  CTTRD2A trapezoid with both x and y dimensions varying along z ;  ►CTTreeA TTree object has a header with a name and a title ;  CTClusterIteratorHelper class to iterate over cluster of baskets ;  CTFriendLockHelper class to prevent infinite recursion in the usage of TTree Friends ;  CTTreeCacheA specialized TFileCacheRead object for a TTree ;  CTTreeCacheUnzipSpecialization of TTreeCache for parallel Unzipping ;  ►CTTreeClonerClass implementing or helping the various TTree cloning method ;  CCompareEntry;  CCompareSeek;  CTTreeDrawArgsParserA class that parses all parameters for TTree::Draw() ;  CTTreeFormulaUsed to pass a selection expression to the Tree drawing routine ;  CTTreeFormulaManagerUsed to coordinate one or more TTreeFormula objects ;  CTTreeFriendLeafIterIterator on all the leaves in a TTree and its friend ;  CTTreeIndexA Tree Index with majorname and minorname ;  CTTreeInput;  CTTreePerfStatsTTree I/O performance measurement ;  CTTreePlayerImplement some of the functionality of the class TTree requiring access to extra libraries (Histogram, display, etc) ;  ►CTTreeReaderTTreeReader is a simple, robust and fast interface to read values from a TTree, TChain or TNtuple ;  CIterator_t;  ►CTTreeReaderArrayExtracts array data from a TTree ;  CIterator_t;  CTTreeReaderValueExtracts data from a TTree ;  CTTreeResultClass defining interface to a TTree query result with the same interface as for SQL databases ;  CTTreeRowClass defining interface to a row of a TTree query result ;  CTTreeSQLImplement TTree for a SQL backend ;  CTTreeTableInterfaceTTreeTableInterface is used to interface to data that is stored in a TTree ;  CTTreeViewerA graphic user interface designed to handle ROOT trees and to take advantage of TTree class features ;  CTTUBEA tube ;  CTTUBSA segment of a tube ;  CTTVLVContainerThis class represent the list view container for the ;  CTTVLVEntryThis class represent entries that goes",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html606/annotated.html:159644,perform,performance,159644,root/html606/annotated.html,https://root.cern,https://root.cern/root/html606/annotated.html,2,['perform'],['performance']
Performance,"oid RooRealSumPdf::printMetaArgs ; (; std::ostream & ; os); const. overridevirtual . Customized printing of arguments of a RooRealSumPdf to more intuitively reflect the contents of the product operator construction. ; Reimplemented from RooAbsArg.; Definition at line 700 of file RooRealSumPdf.cxx. ◆ selfNormalized(). bool RooRealSumPdf::selfNormalized ; (; ); const. inlineoverridevirtual . Shows if a PDF is self-normalized, which means that no attempt is made to add a normalization term. ; Always returns false, unless a PDF overrides this function. ; Reimplemented from RooAbsPdf.; Definition at line 53 of file RooRealSumPdf.h. ◆ setCacheAndTrackHints() [1/2]. void RooRealSumPdf::setCacheAndTrackHints ; (; RooArgList const & ; funcList, . RooArgSet & ; trackNodes . ). staticprivate . Definition at line 686 of file RooRealSumPdf.cxx. ◆ setCacheAndTrackHints() [2/2]. void RooRealSumPdf::setCacheAndTrackHints ; (; RooArgSet & ; trackNodes). overridevirtual . Label OK'ed components of a RooRealSumPdf with cache-and-track. ; Reimplemented from RooAbsArg.; Definition at line 680 of file RooRealSumPdf.cxx. ◆ setExtended(). void RooRealSumPdf::setExtended ; (; bool ; extended). inlineprivate . Definition at line 136 of file RooRealSumPdf.h. ◆ setFloor(). void RooRealSumPdf::setFloor ; (; bool ; flag). inline . Definition at line 62 of file RooRealSumPdf.h. ◆ setFloorGlobal(). static void RooRealSumPdf::setFloorGlobal ; (; bool ; flag). inlinestatic . Definition at line 64 of file RooRealSumPdf.h. ◆ Streamer(). void RooRealSumPdf::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from RooAbsPdf. ◆ StreamerNVirtual(). void RooRealSumPdf::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 138 of file RooRealSumPdf.h. ◆ translate(). void RooRealSumPdf::translate ; (; RooFit::Detail::CodeSquashContext & ; ctx); const. overridevirtual . This function defines a translation for each RooAbsRe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooRealSumPdf.html:89984,cache,cache-and-track,89984,doc/master/classRooRealSumPdf.html,https://root.cern,https://root.cern/doc/master/classRooRealSumPdf.html,1,['cache'],['cache-and-track']
Performance,"oid RooRealSumPdf::printMetaArgs ; (; std::ostream & ; os); const. overridevirtual . Customized printing of arguments of a RooRealSumPdf to more intuitively reflect the contents of the product operator construction. ; Reimplemented from RooAbsArg.; Definition at line 708 of file RooRealSumPdf.cxx. ◆ selfNormalized(). bool RooRealSumPdf::selfNormalized ; (; ); const. inlineoverridevirtual . Shows if a PDF is self-normalized, which means that no attempt is made to add a normalization term. ; Always returns false, unless a PDF overrides this function. ; Reimplemented from RooAbsPdf.; Definition at line 53 of file RooRealSumPdf.h. ◆ setCacheAndTrackHints() [1/2]. void RooRealSumPdf::setCacheAndTrackHints ; (; RooArgList const & ; funcList, . RooArgSet & ; trackNodes . ). staticprivate . Definition at line 693 of file RooRealSumPdf.cxx. ◆ setCacheAndTrackHints() [2/2]. void RooRealSumPdf::setCacheAndTrackHints ; (; RooArgSet & ; trackNodes). overridevirtual . Label OK'ed components of a RooRealSumPdf with cache-and-track. ; Reimplemented from RooAbsArg.; Definition at line 687 of file RooRealSumPdf.cxx. ◆ setExtended(). void RooRealSumPdf::setExtended ; (; bool ; extended). inlineprivate . Definition at line 136 of file RooRealSumPdf.h. ◆ setFloor(). void RooRealSumPdf::setFloor ; (; bool ; flag). inline . Definition at line 62 of file RooRealSumPdf.h. ◆ setFloorGlobal(). static void RooRealSumPdf::setFloorGlobal ; (; bool ; flag). inlinestatic . Definition at line 64 of file RooRealSumPdf.h. ◆ Streamer(). void RooRealSumPdf::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from RooAbsPdf. ◆ StreamerNVirtual(). void RooRealSumPdf::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 138 of file RooRealSumPdf.h. ◆ translate(). void RooRealSumPdf::translate ; (; RooFit::Detail::CodeSquashContext & ; ctx); const. overridevirtual . This function defines a translation for each RooAbsRe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooRealSumPdf.html:91105,cache,cache-and-track,91105,doc/v632/classRooRealSumPdf.html,https://root.cern,https://root.cern/doc/v632/classRooRealSumPdf.html,1,['cache'],['cache-and-track']
Performance,"oid SetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); Set position from where to start reading. void Seek(Long64_t offset, TFile::ERelativeTo pos = kBeg); Seek to a specific position in the file. Pos it either kBeg, kCur or kEnd. void SetCompressionLevel(Int_t level = 1); Set level of compression for this file:; level = 0 objects written to this file will not be compressed.; level = 1 minimal compression level but fast. level = 9 maximal compression level but slow. Note that the compression level may be changed at any time.; The new compression level will only apply to newly written objects.; The function TFile::Map shows the compression factor; for each object written to this file.; The function TFile::GetCompressionFactor returns the global; compression factor for this file. void SetCacheRead(TFileCacheRead* cache); Set a pointer to the read cache.; NOTE: This relinquish ownership of the previous cache, so if you do not; already have a pointer to the previous cache (and there was a previous; cache), you ought to retrieve (and delete it if needed) using:; TFileCacheRead *older = myfile->GetCacheRead();. void SetCacheWrite(TFileCacheWrite* cache); Set a pointer to the write cache.; If file is null the existing write cache is deleted. Int_t Sizeof() const; Return the size in bytes of the file header. void Streamer(TBuffer& b); Stream a TFile object. void SumBuffer(Int_t bufsize); Increment statistics for buffer sizes of objects in this file. void UseCache(Int_t maxCacheSize = 10, Int_t pageSize = 0); Dummy function kept for backward compatibility.; The read cache is now managed by TFileCacheRead; The write cache is now managed by TFileCacheWrite; Both caches are created automatically by the system. Int_t Write(const char* name = 0, Int_t opt = 0, Int_t bufsiz = 0); Write memory objects to this file.; Loop on all objects in memory (including subdirectories).; A new key is created in the KEYS linked list for each object.; The list of keys is then saved on the f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFile.html:37310,cache,cache,37310,root/html528/TFile.html,https://root.cern,https://root.cern/root/html528/TFile.html,3,['cache'],['cache']
Performance,"oid TASImage::PolyPoint ; (; UInt_t ; npt, . TPoint * ; ppt, . const char * ; col = ""#000000"", . TImage::ECoordMode ; mode = kCoordModeOrigin . ). overridevirtual . Draw a poly point. ; Reimplemented from TImage.; Definition at line 4724 of file TASImage.cxx. ◆ PutPixel(). void TASImage::PutPixel ; (; Int_t ; x, . Int_t ; y, . const char * ; col = ""#000000"" . ). overridevirtual . Draw a point at the specified position. ; Reimplemented from TImage.; Definition at line 4689 of file TASImage.cxx. ◆ ReadImage(). void TASImage::ReadImage ; (; const char * ; filename, . EImageFileTypes ; type = TImage::kUnknown . ). overridevirtual . Read specified image file. ; The file type is determined by the file extension (the type argument is ignored). It will attempt to append .gz and then .Z to the filename and find such a file. If the filename ends with extension consisting of digits only, it will attempt to find the file with this extension stripped off. On success this extension will be used to load subimage from the file with that number. Subimage is supported for GIF files (ICO, BMP, CUR, TIFF, XCF to be supported in future). For example, i1 = TImage::Open(""anim.gif.0""); // read the first subimage; i4 = TImage::Open(""anim.gif.3""); // read the forth subimage; TImage::Openstatic TImage * Open(const char *file, EImageFileTypes type=kUnknown)Open a specified image file.Definition TImage.cxx:118; It is also possible to put XPM raw string (see also SetImageBuffer) as the first input parameter (""filename""), such string is returned by GetImageBuffer method. ; Reimplemented from TImage.; Definition at line 487 of file TASImage.cxx. ◆ SavePrimitive(). void TASImage::SavePrimitive ; (; std::ostream & ; out, . Option_t * ; option = """" . ). overridevirtual . Save a primitive as a C++ statement(s) on output stream ""out"". ; Reimplemented from TObject.; Definition at line 6740 of file TASImage.cxx. ◆ Scale(). void TASImage::Scale ; (; UInt_t ; toWidth, . UInt_t ; toHeight . ). overridevirtu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTASImage.html:70616,load,load,70616,doc/master/classTASImage.html,https://root.cern,https://root.cern/doc/master/classTASImage.html,1,['load'],['load']
Performance,"oid TF allocates all GPU memory; }; }; ; if (usePyTorchCNN) {; ; Info(""TMVA_CNN_Classification"", ""Using Convolutional PyTorch Model"");; TString pyTorchFileName = gROOT->GetTutorialDir() + TString(""/tmva/PyTorch_Generate_CNN_Model.py"");; // check that pytorch can be imported and file defining the model and used later when booking the method is; // existing; if (gSystem->Exec(python_exe + "" -c 'import torch'"") || gSystem->AccessPathName(pyTorchFileName)) {; Warning(""TMVA_CNN_Classification"", ""PyTorch is not installed or model building file is not existing - skip using PyTorch"");; } else {; // book PyTorch method only if PyTorch model could be created; Info(""TMVA_CNN_Classification"", ""Booking PyTorch CNN model"");; TString methodOpt = ""H:!V:VarTransform=None:FilenameModel=PyTorchModelCNN.pt:""; ""FilenameTrainedModel=PyTorchTrainedModelCNN.pt:NumEpochs=10:BatchSize=100"";; methodOpt += TString("":UserCode="") + pyTorchFileName;; factory.BookMethod(&loader, TMVA::Types::kPyTorch, ""PyTorch"", methodOpt);; }; }; #endif; ; //// ## Train Methods; ; factory.TrainAllMethods();; ; /// ## Test and Evaluate Methods; ; factory.TestAllMethods();; ; factory.EvaluateAllMethods();; ; /// ## Plot ROC Curve; ; auto c1 = factory.GetROCCurve(&loader);; c1->Draw();; ; // close outputfile to save output file; outputFile->Close();; }; f#define f(i)Definition RSha256.hxx:104; Double_tdouble Double_tDefinition RtypesCore.h:59; Infovoid Info(const char *location, const char *msgfmt,...)Use this function for informational messages.Definition TError.cxx:218; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; Warningvoid Warning(const char *location, const char *msgfmt,...)Use this function in warning situations.Definition TError.cxx:229; x2Option_t Option_t TPoint TPoint const char x2Definition TGWin32VirtualXProxy.cxx:70; x1Option_t Option_t TPoint TPoint const char x1Definition TGWin32VirtualXProxy.cxx:70; gROOT#define g",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html:61224,load,loader,61224,doc/master/TMVA__CNN__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html,1,['load'],['loader']
Performance,"oid TGeoMixture::DefineElement(Int_t iel, TGeoElement *elem,; Double_t weight);; void TGeoMixture::DefineElement(Int_t iel, Int_t z, Int_t natoms);; or:; void AddElement(TGeoMaterial* mat, Double_t weight);; void AddElement(TGeoElement* elem, Double_t weight);; void AddElement(TGeoElement* elem, Int_t natoms);; void AddElement(Double_t a, Double_t z, Double_t weight). iel: index of the element[0,nel-1]; a and z: the atomic mass and charge; weight: proportion by mass of the elements; natoms: number of atoms of the element in the molecule making the mixture. The radiation length is automatically computed when all elements are defined. Since tracking MC provide several other ways to create materials/mixtures, the materials classes are likely to evolve as the interfaces to these engines are being developed. Generally in the process of tracking material properties are not enough and more specific media properties have to be defined. These highly depend on the MC performing tracking and sometimes allow the definition of different media properties (e.g. energy or range cuts) for the same material.; 18.2.2 Radionuclides; A new class TGeoElementRN was introduced in this version to provide support for radioactive nuclides and their decays. A database of 3162 radionuclides can be loaded on demand via the table of elements (TGeoElementTable class). One can make then materials/mixtures based on these radionuclides and use them in a geometry; root[] TGeoManager *geom = new TGeoManager(""geom"",""radionuclides"");; root[] TGeoElementTable *table = geom->GetElementTable();; root[] TGeoElementRN *c14 = table->GetElementRN(14,6); // A,Z; root[] c14->Print();; 6-C-014 ENDF=60140; A=14; Z=6; Iso=0; Level=0[MeV]; Dmass=3.0199[MeV];; Hlife=1.81e+11[s] J/P=0+; Abund=0; Htox=5.8e-10; Itox=5.8e-10; Stat=0; Decay modes:; BetaMinus Diso: 0 BR: 100.000% Qval: 0.1565; One can make materials or mixtures from radionuclides:; root[] TGeoMaterial *mat = new TGeoMaterial(""C14"", c14, 2.0);; The following ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:891116,perform,performing,891116,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['perform'],['performing']
Performance,"oid TMVA::Factory::EvaluateAllMethods ; (; void ; ). Iterates over all MVAs that have been booked, and calls their evaluation methods. ; Definition at line 1376 of file Factory.cxx. ◆ EvaluateAllVariables(). void TMVA::Factory::EvaluateAllVariables ; (; DataLoader * ; loader, . TString ; options = """" . ). Iterates over all MVA input variables and evaluates them. ; Definition at line 1360 of file Factory.cxx. ◆ EvaluateImportance(). TH1F * TMVA::Factory::EvaluateImportance ; (; DataLoader * ; loader, . VIType ; vitype, . Types::EMVA ; theMethod, . TString ; methodTitle, . const char * ; theOption = """" . ). Evaluate Variable Importance. ; Definition at line 2217 of file Factory.cxx. ◆ EvaluateImportanceAll(). TH1F * TMVA::Factory::EvaluateImportanceAll ; (; DataLoader * ; loader, . Types::EMVA ; theMethod, . TString ; methodTitle, . const char * ; theOption = """" . ). private . Definition at line 2246 of file Factory.cxx. ◆ EvaluateImportanceRandom(). TH1F * TMVA::Factory::EvaluateImportanceRandom ; (; DataLoader * ; loader, . UInt_t ; nseeds, . Types::EMVA ; theMethod, . TString ; methodTitle, . const char * ; theOption = """" . ). private . Definition at line 2473 of file Factory.cxx. ◆ EvaluateImportanceShort(). TH1F * TMVA::Factory::EvaluateImportanceShort ; (; DataLoader * ; loader, . Types::EMVA ; theMethod, . TString ; methodTitle, . const char * ; theOption = """" . ). private . Definition at line 2358 of file Factory.cxx. ◆ GetImportance(). TH1F * TMVA::Factory::GetImportance ; (; const int ; nbits, . std::vector< Double_t > ; importances, . std::vector< TString > ; varNames . ). private . Definition at line 2591 of file Factory.cxx. ◆ GetMethod(). TMVA::IMethod * TMVA::Factory::GetMethod ; (; const TString & ; datasetname, . const TString & ; title . ); const. Returns pointer to MVA that corresponds to given method title. ; Definition at line 566 of file Factory.cxx. ◆ GetROC() [1/2]. TMVA::ROCCurve * TMVA::Factory::GetROC ; (; TMVA::DataLoader * ; loader, . TStri",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1Factory.html:24623,load,loader,24623,doc/master/classTMVA_1_1Factory.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1Factory.html,1,['load'],['loader']
Performance,"oid TProof::SetPlayer ; (; TVirtualProofPlayer * ; player). protected . Set a new PROOF player. ; Definition at line 10199 of file TProof.cxx. ◆ SetPrintProgress(). void TProof::SetPrintProgress ; (; PrintProgress_t ; pp). inline . Definition at line 1046 of file TProof.h. ◆ SetProgressDialog(). void TProof::SetProgressDialog ; (; Bool_t ; on = kTRUE). Enable/Disable the graphic progress dialog. ; By default the dialog is enabled ; Definition at line 12509 of file TProof.cxx. ◆ SetQueryMode(). void TProof::SetQueryMode ; (; EQueryMode ; mode). Change query running mode to the one specified by 'mode'. ; Definition at line 6107 of file TProof.cxx. ◆ SetRealTimeLog(). void TProof::SetRealTimeLog ; (; Bool_t ; on = kTRUE). Switch ON/OFF the real-time logging facility. ; When this option is ON, log messages from processing are sent back as they come, instead of being sent back at the end in one go. This may help debugging or monitoring in some cases, but, depending on the amount of log, it may have significant consequencies on the load over the network, so it must be used with care. ; Definition at line 7096 of file TProof.cxx. ◆ SetRunStatus(). void TProof::SetRunStatus ; (; ERunStatus ; rst). inlineprivate . Definition at line 672 of file TProof.h. ◆ SetupWorkersEnv(). void TProof::SetupWorkersEnv ; (; TList * ; wrks, . Bool_t ; increasingpool = kFALSE . ). protected . Set up packages, loaded macros, include and lib paths ... ; Definition at line 1528 of file TProof.cxx. ◆ ShowCache(). void TProof::ShowCache ; (; Bool_t ; all = kFALSE). virtual . List contents of file cache. ; If all is true show all caches also on slaves. If everything is ok all caches are to be the same. ; Reimplemented in TProofLite.; Definition at line 7691 of file TProof.cxx. ◆ ShowData(). void TProof::ShowData ; (; ). virtual . List contents of the data directory in the sandbox. ; This is the place where files produced by the client queries are kept ; Reimplemented in TProofLite.; Definition at l",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProof.html:147375,load,load,147375,doc/master/classTProof.html,https://root.cern,https://root.cern/doc/master/classTProof.html,1,['load'],['load']
Performance,"oid Terminate(); - void SlaveTerminate(). The class selector derives from TSelector.; The generated code in selector.C includes empty functions defined above. To use this function:; - connect your Tree file (eg: TFile f(""myfile.root"");); - T->MakeSelector(""myselect"");; where T is the name of the Tree in file myfile.root; and myselect.h, myselect.C the name of the files created by this function.; In a ROOT session, you can do:; root > T->Process(""myselect.C""). Bool_t MemoryFull(Int_t nbytes); Check if adding nbytes to memory we are still below MaxVirtualsize. TTree* MergeTrees(TList* list, Option_t* option = """"); Static function merging the trees in the TList into a new tree. Trees in the list can be memory or disk-resident trees.; The new tree is created in the current directory (memory if gROOT). Long64_t Merge(TCollection* list, Option_t* option = """"); Merge the trees in the TList into this tree. Returns the total number of entries in the merged tree. Bool_t Notify(); Function called when loading a new class library. void OptimizeBaskets(ULong64_t maxMemory = 10000000, Float_t minComp = 1.1, Option_t* option = """"); This function may be called after having filled some entries in a Tree; Using the information in the existing branch buffers, it will reassign; new branch buffer sizes to optimize time and memory. The function computes the best values for branch buffer sizes such that; the total buffer sizes is less than maxMemory and nearby entries written; at the same time.; In case the branch compression factor for the data written so far is less; than compMin, the compression is disabled. if option =""d"" an analysis report is printed. TPrincipal* Principal(const char* varexp = """", const char* selection = """", Option_t* option = ""np"", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Interface to the Principal Components Analysis class. Create an instance of TPrincipal; Fill it with the selected variables; if option ""n"" is specified, the TPrincipal object is fil",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTree.html:104375,load,loading,104375,root/html528/TTree.html,https://root.cern,https://root.cern/root/html528/TTree.html,1,['load'],['loading']
Performance,"oid UpdateListOfProofs(); Update list of existing Proof sessions. void UpdateListOfSessions(); Update list of existing Proof sessions. void WriteConfiguration(const char* filename = 0); Save actual configuration in config file ""filename"". void Build(); Build main session viewer frame and subframes. ~TSessionViewer(); Destructor. void OnListTreeClicked(TGListTreeItem* entry, Int_t btn, Int_t x, Int_t y); Handle mouse clicks in list tree. void OnListTreeDoubleClicked(TGListTreeItem* entry, Int_t btn); Handle mouse double clicks in list tree (connect to server). void Terminate(); Terminate Session : save configuration, clean temporary files and close; Proof connections. void CloseWindow(); Close main Session Viewer window. void ChangeRightLogo(const char* name); Change the right logo (used for animation). void EnableTimer(); Enable animation timer. void DisableTimer(); Disable animation timer. Bool_t HandleTimer(TTimer* ); Handle animation timer. void LogMessage(const char* msg, Bool_t all); Load/append a log msg in the log frame. void QueryResultReady(char* query); Handle signal ""query result ready"" coming from Proof session. void CleanupSession(); Clean-up Proof session. void ResetSession(); Reset Proof session. void DeleteQuery(); Delete query from list tree and ask user if he wants do delete it also; from server. void EditQuery(); Edit currently selected query. void StartViewer(); Start TreeViewer from selected TChain. void ShowPackages(); Query the list of uploaded packages from proof and display it; into a new text window. void UpdateListOfPackages(); Update the list of packages. void ShowEnabledPackages(); Query list of enabled packages from proof and display it; into a new text window. void ShowLog(const char* queryref); Display the content of the temporary log file for queryref; into a new text window. void ShowInfo(const char* txt); Display text in status bar. void ShowStatus(); Retrieve and display Proof status. void StartupMessage(char* msg, Bool_t stat, In",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TSessionViewer.html:26955,Load,Load,26955,root/html532/TSessionViewer.html,https://root.cern,https://root.cern/root/html532/TSessionViewer.html,2,['Load'],['Load']
Performance,"oid UpdateListOfProofs(); Update list of existing Proof sessions. void UpdateListOfSessions(); Update list of existing Proof sessions. void WriteConfiguration(const char* filename = 0); Save actual configuration in config file ""filename"". void Build(); Build main session viewer frame and subframes. ~TSessionViewer(); Destructor. void OnListTreeClicked(TGListTreeItem* entry, Int_t btn, Int_t x, Int_t y); Handle mouse clicks in list tree. void OnListTreeDoubleClicked(TGListTreeItem* entry, Int_t btn); Handle mouse double clicks in list tree (connect to server). void Terminate(); Terminate Session : save configuration, clean temporary files and close; Proof connections. void CloseWindow(); Close main Session Viewer window. void ChangeRightLogo(const char* name); Change the right logo (used for animation). void EnableTimer(); Enable animation timer. void DisableTimer(); Disable animation timer. Bool_t HandleTimer(TTimer* ); Handle animation timer. void LogMessage(const char* msg, Bool_t all); Load/append a log msg in the log frame. void QueryResultReady(char* query); Handle signal ""query result ready"" coming from Proof session. void CleanupSession(); Clean-up Proof session. void ResetSession(); Reset Proof session. void DeleteQuery(); Delete query from list tree and ask user if they want to delete it also; from server. void EditQuery(); Edit currently selected query. void StartViewer(); Start TreeViewer from selected TChain. void ShowPackages(); Query the list of uploaded packages from proof and display it; into a new text window. void UpdateListOfPackages(); Update the list of packages. void ShowEnabledPackages(); Query list of enabled packages from proof and display it; into a new text window. void ShowLog(const char* queryref); Display the content of the temporary log file for queryref; into a new text window. void ShowInfo(const char* txt); Display text in status bar. void ShowStatus(); Retrieve and display Proof status. void StartupMessage(char* msg, Bool_t stat, I",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSessionViewer.html:27965,Load,Load,27965,root/html602/TSessionViewer.html,https://root.cern,https://root.cern/root/html602/TSessionViewer.html,2,['Load'],['Load']
Performance,"oid weightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = RooAbsData::Poisson) const. Double_t weight(Int_t index) const. Bool_t isWeighted() const. Bool_t changeObservableName(const char* from, const char* to); Change observable name. RooAbsArg* addColumn(RooAbsArg& var, Bool_t adjustRange = kTRUE); Add one or more columns. RooArgSet* addColumns(const RooArgList& varList). RooAbsDataStore* merge(const RooArgSet& allvars, list<RooAbsDataStore*> dstoreList); Merge column-wise. void append(RooAbsDataStore& other); Add rows. Int_t numEntries() const. Double_t sumEntries() const; { return 0 ; }. void reset(). void attachBuffers(const RooArgSet& extObs); Buffer redirection routines used in inside RooAbsOptTestStatistics. void resetBuffers(). void setExternalWeightArray(Double_t* , Double_t* , Double_t* , Double_t* ); {}. void Print(Option_t* options = 0) const; Printing interface (human readable). void cacheArgs(const RooAbsArg* cacheOwner, RooArgSet& varSet, const RooArgSet* nset = 0, Bool_t skipZeroWeights = kFALSE); Constant term optimizer interface. const RooAbsArg* cacheOwner(). void attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars). void setArgStatus(const RooArgSet& set, Bool_t active). const RooArgSet& cachedVars() const; { return _cachedVars ; }. void resetCache(). void recalculateCache(const RooArgSet* , Int_t , Int_t , Int_t , Bool_t ); {}. void setDirtyProp(Bool_t flag); { _doDirtyProp = flag ; }. Bool_t dirtyProp() const; { return _doDirtyProp ; }. void checkInit() const; {}. Bool_t hasFilledCache() const; { return kFALSE ; }. const TTree* tree() const; { return 0 ; }. void dump(); {}. void loadValues(const RooAbsDataStore* tds, const RooFormulaVar* select = 0, const char* rangeName = 0, Int_t nStart = 0, Int_t nStop = 2000000000). void forceCacheUpdate(); {}. » Last changed: Tue Jun 2 15:27:04 2015 » Last generated: 2015-06-02 15:27; This page has been automatically generated. For comments or suggestions regarding the docume",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooAbsDataStore.html:12819,cache,cacheArgs,12819,root/html604/RooAbsDataStore.html,https://root.cern,https://root.cern/root/html604/RooAbsDataStore.html,6,"['cache', 'optimiz']","['cacheArgs', 'cacheOwner', 'optimizer']"
Performance,"oid weightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = RooAbsData::Poisson) const. Double_t weight(Int_t index) const. Bool_t isWeighted() const. Bool_t changeObservableName(const char* from, const char* to); Change observable name. RooAbsArg* addColumn(RooAbsArg& var, Bool_t adjustRange = kTRUE); Add one or more columns. RooArgSet* addColumns(const RooArgList& varList). RooAbsDataStore* merge(const RooArgSet& allvars, list<RooAbsDataStore*> dstoreList); Merge column-wise. void append(RooAbsDataStore& other); Add rows. Int_t numEntries() const. Double_t sumEntries() const; { return 0 ; }. void reset(). void attachBuffers(const RooArgSet& extObs); Buffer redirection routines used in inside RooAbsOptTestStatistics. void resetBuffers(). void setExternalWeightArray(Double_t* , Double_t* , Double_t* , Double_t* ); {}. void Print(Option_t* options = 0) const; Printing interface (human readable). void cacheArgs(const RooAbsArg* cacheOwner, RooArgSet& varSet, const RooArgSet* nset = 0, Bool_t skipZeroWeights = kFALSE); Constant term optimizer interface. const RooAbsArg* cacheOwner(). void attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars). void setArgStatus(const RooArgSet& set, Bool_t active). const RooArgSet& cachedVars() const; { return _cachedVars ; }. void resetCache(). void recalculateCache(const RooArgSet* , Int_t , Int_t , Int_t , Bool_t ); {}. void setDirtyProp(Bool_t flag); { _doDirtyProp = flag ; }. Bool_t dirtyProp() const; { return _doDirtyProp ; }. void checkInit() const; {}. Bool_t hasFilledCache() const; { return kFALSE ; }. const TTree* tree() const; { return 0 ; }. void dump(); {}. void loadValues(const RooAbsDataStore* tds, const RooFormulaVar* select = 0, const char* rangeName = 0, Int_t nStart = 0, Int_t nStop = 2000000000). void forceCacheUpdate(); {}. » Last changed: Tue Jun 30 14:30:06 2015 » Last generated: 2015-06-30 14:30; This page has been automatically generated. For comments or suggestions regarding the docum",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsDataStore.html:12819,cache,cacheArgs,12819,root/html602/RooAbsDataStore.html,https://root.cern,https://root.cern/root/html602/RooAbsDataStore.html,6,"['cache', 'optimiz']","['cacheArgs', 'cacheOwner', 'optimizer']"
Performance,"oid weightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = RooAbsData::Poisson) const. Double_t weight(Int_t index) const. Bool_t isWeighted() const. Bool_t changeObservableName(const char* from, const char* to); Change observable name. RooAbsArg* addColumn(RooAbsArg& var, Bool_t adjustRange = kTRUE); Add one or more columns. RooArgSet* addColumns(const RooArgList& varList). RooAbsDataStore* merge(const RooArgSet& allvars, list<RooAbsDataStore*> dstoreList); Merge column-wise. void append(RooAbsDataStore& other); Add rows. Int_t numEntries() const. Double_t sumEntries() const; { return 0 ; }. void reset(). void attachBuffers(const RooArgSet& extObs); Buffer redirection routines used in inside RooAbsOptTestStatistics. void resetBuffers(). void setExternalWeightArray(Double_t* , Double_t* , Double_t* , Double_t* ); {}. void Print(Option_t* options = 0) const; Printing interface (human readable). void cacheArgs(const RooAbsArg* cacheOwner, RooArgSet& varSet, const RooArgSet* nset = 0, Bool_t skipZeroWeights = kFALSE); Constant term optimizer interface. const RooAbsArg* cacheOwner(). void attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars). void setArgStatus(const RooArgSet& set, Bool_t active). const RooArgSet& cachedVars() const; { return _cachedVars ; }. void resetCache(). void recalculateCache(const RooArgSet* , Int_t , Int_t , Int_t , Bool_t ); {}. void setDirtyProp(Bool_t flag); { _doDirtyProp = flag ; }. Bool_t dirtyProp() const; { return _doDirtyProp ; }. void checkInit() const; {}. Bool_t hasFilledCache() const; { return kFALSE ; }. const TTree* tree() const; { return 0 ; }. void dump(); {}. void loadValues(const RooAbsDataStore* tds, const RooFormulaVar* select = 0, const char* rangeName = 0, Int_t nStart = 0, Int_t nStop = 2000000000). void forceCacheUpdate(); {}. » Last changed: Tue Mar 10 17:13:58 2015 » Last generated: 2015-03-10 17:13; This page has been automatically generated. For comments or suggestions regarding the docum",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsDataStore.html:11245,cache,cacheArgs,11245,root/html534/RooAbsDataStore.html,https://root.cern,https://root.cern/root/html534/RooAbsDataStore.html,6,"['cache', 'optimiz']","['cacheArgs', 'cacheOwner', 'optimizer']"
Performance,"oid);  Initialization. ;  ; void MakeKNN (void);  create kNN ;  ; Double_t PolnKernel (Double_t value) const;  polynomial kernel ;  ; void ProcessOptions ();  process the options specified by the user ;  . Private Attributes; Int_t fBalanceDepth;  number of binary tree levels used for balancing tree ;  ; kNN::EventVec fEvent;  ! (untouched) events used for learning ;  ; TString fKernel;  =""Gaus"",""Poln"" - kernel type for smoothing ;  ; LDA fLDA;  ! Experimental feature for local knn analysis ;  ; kNN::ModulekNN * fModule;  ! module where all work is done ;  ; Int_t fnkNN;  number of k-nearest neighbors ;  ; Float_t fScaleFrac;  fraction of events used to compute variable width ;  ; Float_t fSigmaFact;  scale factor for Gaussian sigma in Gaus. kernel ;  ; Double_t fSumOfWeightsB;  sum-of-weights for background training events ;  ; Double_t fSumOfWeightsS;  sum-of-weights for signal training events ;  ; Int_t fTreeOptDepth;  number of binary tree levels used for optimization ;  ; Bool_t fTrim;  set equal number of signal and background events ;  ; Bool_t fUseKernel;  use polynomial kernel weight function ;  ; Bool_t fUseLDA;  use local linear discriminant analysis to compute MVA ;  ; Bool_t fUseWeight;  use weights to count kNN ;  . Additional Inherited Members;  Public Types inherited from TMVA::MethodBase; enum  EWeightFileType { kROOT =0; , kTEXT; };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << (",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodKNN.html:27026,optimiz,optimization,27026,doc/master/classTMVA_1_1MethodKNN.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodKNN.html,1,['optimiz'],['optimization']
Performance,oid* TGeoParallelWorld::fBoundingBoxes = nullptr. protected . stores bounding boxes serving a quick safety candidates (to be used with the VoxelGrid and SafetyVoxelInfo) ; Definition at line 54 of file TGeoParallelWorld.h. ◆ fBVH. void* TGeoParallelWorld::fBVH = nullptr. protected . array of physical nodes ; Definition at line 49 of file TGeoParallelWorld.h. ◆ fGeoManager. TGeoManager* TGeoParallelWorld::fGeoManager. protected . Definition at line 41 of file TGeoParallelWorld.h. ◆ fIsClosed. Bool_t TGeoParallelWorld::fIsClosed. protected . Definition at line 44 of file TGeoParallelWorld.h. ◆ fLastState. TGeoPhysicalNode* TGeoParallelWorld::fLastState. protected . helper volume ; Definition at line 46 of file TGeoParallelWorld.h. ◆ fPaths. TObjArray* TGeoParallelWorld::fPaths. protected . Definition at line 42 of file TGeoParallelWorld.h. ◆ fPhysical. TObjArray* TGeoParallelWorld::fPhysical. protected . Last PN touched. ; Definition at line 47 of file TGeoParallelWorld.h. ◆ fSafetyCandidateStore. std::vector<unsigned int> TGeoParallelWorld::fSafetyCandidateStore {}. protected . A regular 3D cache layer for fast point-based safety lookups. ; Definition at line 52 of file TGeoParallelWorld.h. ◆ fSafetyVoxelCache. TGeoVoxelGrid<SafetyVoxelInfo>* TGeoParallelWorld::fSafetyVoxelCache. protected . Initial value:=; nullptr. BVH helper structure for safety and navigation. ; Definition at line 50 of file TGeoParallelWorld.h. ◆ fUseOverlaps. Bool_t TGeoParallelWorld::fUseOverlaps. protected . Definition at line 43 of file TGeoParallelWorld.h. ◆ fVolume. TGeoVolume* TGeoParallelWorld::fVolume. protected . Closed flag. ; Definition at line 45 of file TGeoParallelWorld.h. Libraries for TGeoParallelWorld:. [legend]; The documentation for this class was generated from the following files:; geom/geom/inc/TGeoParallelWorld.h; geom/geom/src/TGeoParallelWorld.cxx. TGeoParallelWorld. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:43:07 (GVA Time) using Doxygen 1.9.8   ; . ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoParallelWorld.html:29136,cache,cache,29136,doc/master/classTGeoParallelWorld.html,https://root.cern,https://root.cern/doc/master/classTGeoParallelWorld.html,1,['cache'],['cache']
Performance,"oid* options = 0, int numOptions = 0, Bool_t noLogo = kFALSE); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; const char*TApplication::WorkingDirectory() const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. static Int_tTQObject::CheckConnectArgs(TQObject* sender, TClass* sender_class, const char* signal, TClass* receiver_class, const char* slot); static voidTApplication::Close(TApplication* app); static TStringTQObject::CompressName(const char* method_name); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual void*TQObject::GetSender(); virtual const char*TQObject::GetSenderClassName() const; virtual voidTApplication::Help(const char* line); virtual voidTApplication::LoadGraphicsLibs(); virtual voidTApplication::MakeBatch(); voidTObject::MakeZombie(); static TApplication*TApplication::Open(const char* url, Int_t debug, const char* script); static Int_tTApplication::ParseRemoteLine(const char* ln, TString& hostdir, TString& user, Int_t& dbg, TString& script); voidTApplication::SetSignalHandler(TSignalHandler* sh). private:. voidExecLogon(); TRint&operator=(const TRint&); Long_tProcessLineNr(const char* filestem, const char* line, Int_t* error = 0); virtual Long_tProcessRemote(const char* line, Int_t* error = 0); TRint(const TRint&). Data Members; public:. static TApplication::EExitOnExceptionTApplication::kAbort; static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatus",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TRint.html:10840,Load,LoadGraphicsLibs,10840,root/html602/TRint.html,https://root.cern,https://root.cern/root/html602/TRint.html,2,['Load'],['LoadGraphicsLibs']
Performance,"oidLongestLine(); TGText&operator=(const TGText&); Bool_tSetCurrentRow(Long_t row). Data Members; protected:. Long_tfColCountnumber of columns in current line; TGTextLine*fCurrentcurrent line; Long_tfCurrentRowcurrent row number; TStringfFilenamename of opened file ("""" if open buffer); TGTextLine*fFirstfirst line of text; Bool_tfIsSavedfalse if text needs to be saved; Long_tfLongestLinelength of longest line; Long_tfRowCountnumber of rows. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGText(const TGText& ); copy constructor. TGText& operator=(const TGText& ); assignment operator. void Init(); Common initialization method. TGText(); Create default (empty) text buffer. TGText(TGText* text); Create text buffer and initialize with other text buffer. TGText(const char* string); Create text buffer and initialize with single line string. ~TGText(); Destroy text buffer. void Clear(); Clear text buffer. Bool_t Load(const char* fn, Long_t startpos = 0, Long_t length = -1); Load text from file fn. Startpos is the begin from where to; load the file and length is the number of characters to read; from the file. Bool_t LoadBuffer(const char* txtbuf); Load a 0 terminated buffer. Lines will be split at '\n'. Bool_t Save(const char* fn); Save text buffer to file fn. Bool_t Append(const char* fn); Append buffer to file fn. Bool_t DelChar(TGLongPosition pos); Delete character at specified position pos. Bool_t InsChar(TGLongPosition pos, char c); Insert character c at the specified position pos. char GetChar(TGLongPosition pos); Get character a position pos. If charcater not valid return -1. Bool_t DelText(TGLongPosition start, TGLongPosition end); Delete text between start and end positions. Returns false in; case of failure (start and end not being within bounds). Bool_t InsText(TGLongPosition ins_pos, TGText* src, TGLongPosition start_src, TGLongPosition end_src); Insert src text from start_src to end_src into text at position ins_pos.; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGText.html:2962,Load,Load,2962,root/html532/TGText.html,https://root.cern,https://root.cern/root/html532/TGText.html,4,['Load'],['Load']
Performance,"oidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); virtual voidsetVal(Double_t value); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMemberInspector& insp) const; RooAbsMoment*RooAbsReal::sigma(RooRealVar& obs); RooAbsMoment*RooAbsReal::sigma(RooRealVar& obs, const RooArgSet& nset); virtual Int_tTNamed::Sizeof() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig(Bool_t createOnTheFly); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); const map<string,string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; const set<string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; RooFIterRooAbsArg::valueClientMIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); virtual Double_tRooAbsRealLValue::volume(const char* rangeName) const; virtual Double_tRooAbsRealLValue::volume(const RooAbsBinning& binning) const; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; voidRooAbsArg::wireAllCaches(); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidwriteToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooErrorVar.html:30809,cache,cache,30809,root/html602/RooErrorVar.html,https://root.cern,https://root.cern/root/html602/RooErrorVar.html,12,['cache'],['cache']
Performance,"oidRooAbsReal::attachToVStore(RooVectorDataStore& vstore); virtual const char*RooAbsCachedReal::binningName() const; TStringRooAbsCachedReal::cacheNameSuffix(const RooArgSet& nset) const; RooFitResult*RooAbsReal::chi2FitDriver(RooAbsReal& fcn, RooLinkedList& cmdList); TStringRooAbsArg::cleanBranchName() const; voidRooAbsCachedReal::clearCacheObject(RooAbsCachedReal::FuncCacheElem& cache) const; virtual voidRooAbsReal::copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE, Bool_t setValDirty = kTRUE); virtual RooAbsCachedReal::FuncCacheElem*RooAbsCachedReal::createCache(const RooArgSet* nset) const; RooAbsReal*RooAbsReal::createIntObj(const RooArgSet& iset, const RooArgSet* nset, const RooNumIntConfig* cfg, const char* rangeName) const; voidRooAbsCachedReal::disableCache(Bool_t flag); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual Double_tevaluate() const; virtual voidfillCacheObject(RooAbsCachedReal::FuncCacheElem& cacheFunc) const; virtual voidRooAbsReal::fillTreeBranch(TTree& t); voidRooAbsReal::findInnerMostIntegration(const RooArgSet& allObs, RooArgSet& innerObs, const char* rangeName) const; static Bool_tRooAbsArg::flipAClean(); RooAbsCachedReal::FuncCacheElem*RooAbsCachedReal::getCache(const RooArgSet* nset) const; virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; static voidRooAbsReal::globalSelectComp(Bool_t flag); voidRooAbsArg::graphVizAddConnections(set<std::pair<RooAbsArg*,RooAbsArg*> >&); static Bool_tRooAbsArg::inhibitDirty(); virtual const char*inputBaseName() const; TStringRooAbsReal::integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset = 0, const char* rangeName = 0, Bool_t omitEmpty = kFALSE) const; Bool_tRooAbsReal::isSelectedComp() const; virtual Bool_tRooAbsReal::isValid() const; virtual Bool_tRooAbsReal::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooCachedReal.html:26831,cache,cacheFunc,26831,root/html532/RooCachedReal.html,https://root.cern,https://root.cern/root/html532/RooCachedReal.html,1,['cache'],['cacheFunc']
Performance,"oidRooAbsReal::setTreeBranchStatus(TTree& t, Bool_t active); voidRooAbsArg::setValueDirty(const RooAbsArg* source) const; virtual voidRooAbsReal::syncCache(const RooArgSet* set = 0); virtual Bool_tRooAbsPdf::syncNormalization(const RooArgSet* dset, Bool_t adjustProxies = kTRUE) const; Double_tRooAbsReal::traceEval(const RooArgSet* set) const; voidRooAbsArg::unRegisterProxy(RooArgProxy& proxy); voidRooAbsArg::unRegisterProxy(RooSetProxy& proxy); voidRooAbsArg::unRegisterProxy(RooListProxy& proxy). Data Members; public:. enum BufStrat { Extend; Mirror; Flat; };; enum RooAbsPdf::ExtendMode { CanNotBeExtended; CanBeExtended; MustBeExtended; };; enum RooAbsReal::ScaleType { Raw; Relative; NumEvent; RelativeExpected; };; enum RooAbsReal::ErrorLoggingMode { PrintErrors; CollectErrors; CountErrors; Ignore; };; enum RooAbsArg::ConstOpCode { Activate; DeActivate; ConfigChange; ValueChange; };; enum RooAbsArg::CacheMode { Always; NotAdvised; Never; };; enum RooAbsArg::OperMode { Auto; AClean; ADirty; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. public:. static map<RooAbsArg*,TRefArray*>RooAbsArg::_ioEvoListtemporary holding list for proxies needed in schema evolution ; static stack<RooAbsArg*>RooAbsArg::_ioReadStackreading stack ; static const UInt_tRooAbsArg::fnv1a32start; static const ULong64_tRooAbsArg::fnv1a64start. protected:. map<Int_t,AnaIntConfig>RooAbsCachedPdf::_anaIntMap! Map for analytical integration codes; RooAICRegistryRooAbsCachedPdf::_anaReg! Registry for analytical integration codes; set<std::string>RooAbsArg::_boolAttribBoolean attributes;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooFFTConvPdf.html:44333,Cache,CacheMode,44333,root/html534/RooFFTConvPdf.html,https://root.cern,https://root.cern/root/html534/RooFFTConvPdf.html,1,['Cache'],['CacheMode']
Performance,"oidTApplication::SetSignalHandler(TSignalHandler* sh). Data Members; public:. enum TApplication::EStatusBits { kProcessRemotely; kDefaultApplication; };; enum TApplication::EExitOnException { kDontExit; kExit; kAbort; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TApplication*TApplication::fAppRemoteCurrent remote application, if defined; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static TList*TApplication::fgApplicationsList of available applications. private:. TGClient*fClientpointer to the client environment; char*fDisplaydisplay server to connect to. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGApplication(const char* appClassName, Int_t* argc, char** argv, void* options = 0, Int_t numOptions = 0); Create a GUI application environment. Use this class if you only; want to use the ROOT GUI and no other services. In all other cases; use either TApplication or TRint. ~TGApplication(); TGApplication dtor. void LoadGraphicsLibs(); Load shared libs necessary for GUI. void GetOptions(Int_t* argc, char** argv); Handle command line arguments. Arguments handled are removed from the; argument array. Currently only option ""-display xserver"" is considered. TGApplication(); { }. » Author: Guy Barrand 30/05/2001 » Copyright (C) 2001, Guy Barrand. *; » Last changed: root/gui:$Id$ » Last generated: 2015-03-13 19:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGApplication.html:12644,Load,LoadGraphicsLibs,12644,root/html534/TGApplication.html,https://root.cern,https://root.cern/root/html534/TGApplication.html,2,['Load'],"['Load', 'LoadGraphicsLibs']"
Performance,"oidTGLLogicalShape::DestroyPhysicals(); virtual voidDirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidDrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* ps, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*TGLObject::GetGLRenderer(TClass* isa); static Bool_tTGLLogicalShape::GetIgnoreSizeForCameraInterest(); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tTGLObject::KeepDuringSmartRefresh() const; virtual voidProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; UInt_tTGLLogicalShape::Ref() const; virtual voidSetBBox(); Bool_tTGLLogicalShape::SetDLCache(Bool_t cached); static voidTGLLogicalShape::SetIgnoreSizeForCameraInterest(Bool_t isfci); virtual Bool_tSetModel(TObject* obj, const Option_t* opt = 0); virtual Bool_tTGLObject::ShouldDLCache(const TGLRnrCtx& rnrCtx) const; virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidTGLLogicalShape::StrongRef(Bool_t strong) const; voidTGLLogicalShape::SubRef(TGLPhysicalShape* phys) const; virtual TGLLogicalShape::ELODAxesTGLLogicalShape::SupportedLODAxes() const; virtual Bool_tSupportsSecondarySelect() const; TEveCalo2DGL(); UInt_tTGLLogicalShape::UnrefFirstPhysical(); virtual voidTGLObject::UpdateBoundingBox(); voidTGLLogicalShape::UpdateBoundingBoxesOfPhysicals().",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEveCalo2DGL.html:1829,cache,cached,1829,root/html602/TEveCalo2DGL.html,https://root.cern,https://root.cern/root/html602/TEveCalo2DGL.html,4,['cache'],['cached']
Performance,"oidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTMVA::MethodBase::SetCurrentEvent(Long64_t ievt) const; virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTMVA::MethodBase::SetMethodBaseDir(TDirectory* methodDir); voidTMVA::MethodBase::SetMethodDir(TDirectory* methodDir); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidTMVA::MethodBase::SetSignalReferenceCut(Double_t cut); voidTMVA::MethodBase::SetSignalReferenceCutOrientation(Double_t cutOrientation); voidSetTestSignalEfficiency(Double_t effS); voidTMVA::MethodBase::SetTestTime(Double_t testTime); voidTMVA::MethodBase::SetTestvarName(const TString& v = """"); voidTMVA::MethodBase::SetTrainTime(Double_t trainTime); virtual voidTMVA::MethodBase::SetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::MethodBase::SetupMethod(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTestClassification(); virtual voidTMVA::MethodBase::TestMulticlass(); virtual voidTMVA::MethodBase::TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); virtual voidTrain(); voidTMVA::MethodBase::TrainMethod(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__MethodCuts.html:13828,tune,tuneParameters,13828,root/html530/TMVA__MethodCuts.html,https://root.cern,https://root.cern/root/html530/TMVA__MethodCuts.html,3,['tune'],['tuneParameters']
Performance,"oidTNamed::FillBuffer(char*& buffer); TVirtualStreamerInfo*FindConversionStreamerInfo(const char* onfile_classname, UInt_t checksum) const; TVirtualStreamerInfo*FindConversionStreamerInfo(const TClass* onfile_cl, UInt_t checksum) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TVirtualStreamerInfo*FindStreamerInfo(UInt_t checksum) const; TVirtualStreamerInfo*FindStreamerInfoAbstractEmulated(UInt_t checksum) const; TClass*GetActualClass(const void* object) const; TDictAttributeMap*TDictionary::GetAttributeMap() const; TClass*GetBaseClass(const char* classname); TClass*GetBaseClass(const TClass* base); Int_tGetBaseClassOffset(const TClass* base); TClass*GetBaseDataMember(const char* datamember); UInt_tGetCheckSum(TClass::ECheckSum code = kCurrentCheckSum) const; static TClass*GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE); static TClass*GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE); ClassInfo_t*GetClassInfo() const; Int_tGetClassSize() const; Version_tGetClassVersion() const; TVirtualCollectionProxy*GetCollectionProxy() const; const char*GetContextMenuTitle() const; TVirtualStreamerInfo*GetConversionStreamerInfo(const char* onfile_classname, Int_t version) const; TVirtualStreamerInfo*GetConversionStreamerInfo(const TClass* onfile_cl, Int_t version) const; TVirtualStreamerInfo*GetCurrentStreamerInfo(); TDataMember*GetDataMember(const char* datamember) const; Long_tGetDataMemberOffset(const char* membername) const; Short_tGetDeclFileLine() const; const char*GetDeclFileName() const; ROOT::DelFunc_tGetDelete() const; ROOT::DelArrFunc_tGetDeleteArray() const; ROOT::DesFunc_tGetDestructor() const; static VoidFuncPtr_tGetDict(const char* cname); static VoidFuncPtr_tGetDict(const type_info& info); static TDictionary*TDictionary::GetDictionary(const char* name); static TDictionary*TDictionary::GetDictionary(const type_info& typeinfo); RO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TClass.html:4492,load,load,4492,root/html534/TClass.html,https://root.cern,https://root.cern/root/html534/TClass.html,2,['load'],['load']
Performance,"oidTObject::MakeZombie(); Int_tSetParameters(). private:. voidBuildHistos(Int_t start, Int_t stop, Int_t step, Bool_t nx). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTProofBenchRun::fParListList of PARs to be loaded; TProof*TProofBenchRun::fProofProof; TStringTProofBenchRun::fSelNameName of the selector to be run. private:. TCanvas*fCanvascanvas for performance plots; Int_tfDebugdebug switch; TDirectory*fDirProofBenchdirectory for proof outputs; Int_tfDrawdraw switch; TPBHistType*fHistTypehistogram type; TH2*fHist_perfstat_event; TList*fListPerfPlotslist of performance plots; Long64_tfNEventsnumber of events to generate; Int_tfNHistsnumber of histograms; Int_tfNTriesnumber of tries ; TStringfNamename of CPU run; TProofNodes*fNodesnode information; TLegend*fNormLegendLegend for norms; TProfile*fNorm_perfstat_evtmax; TProfile*fNorm_queryresult_event; TLegend*fProfLegendLegend for profiles; TProfile*fProfile_cpu_eff; TProfile*fProfile_perfstat_event; TProfile*fProfile_perfstat_evtmax; TProfile*fProfile_queryresult_event; Int_tfStartstart number of workers to scan; Int_tfSteptest to be performed every fStep workers; Int_tfStopstop number of workers to scan. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofBenchRunCPU(TPBHistType* histtype = 0, Int_t nhists = 16, TDirectory* dirproofbench = 0, TProof* proof = 0, TProofNodes* nodes = 0, Long64_t nevents = 1000000, Int_t ntries = 2, Int_t start = 1, Int_t stop = -1, Int_t step = 1, Int_t draw = 0, Int_t debug = 0); Default constructor. ~TProofBenchRunCPU(); Destructor. void BuildHistos(Int_t start, Int_t stop, Int_t step, Bool_t nx); Build histograms, profiles and graphs needed for this run. void Run(Long64_t nevents, Int_t star",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofBenchRunCPU.html:6954,perform,performance,6954,root/html534/TProofBenchRunCPU.html,https://root.cern,https://root.cern/root/html534/TProofBenchRunCPU.html,6,['perform'],"['performance', 'performed']"
Performance,"oidTObject::ResetBit(UInt_t f); virtual voidresetErrorCounters(Int_t resetValue = 10); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); virtual Bool_tselfNormalized() const; TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsPdf::setGeneratorConfig(); voidRooAbsPdf::setGeneratorConfig(const RooNumGenConfig& config); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); voidRooAbsPdf::setNormRange(const char* rangeName); voidRooAbsPdf::setNormRangeOverride(const char* rangeName); voidRooAbsPdf::setNormValueCaching(Int_t minNumIntDim, Int_t ipOrder = 2); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsPdf::setTraceCounter(Int_t value, Bool_t allNodes = kFALS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAddModel.html:28443,cache,cache,28443,root/html528/RooAddModel.html,https://root.cern,https://root.cern/root/html528/RooAddModel.html,2,['cache'],['cache']
Performance,"oidTObject::ResetBit(UInt_t f); virtual voidresetErrorCounters(Int_t resetValue = 10); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); virtual Bool_tselfNormalized() const; TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidsetGeneratorConfig(); voidsetGeneratorConfig(const RooNumGenConfig& config); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); voidsetNormRange(const char* rangeName); voidsetNormRangeOverride(const char* rangeName); voidsetNormValueCaching(Int_t minNumIntDim, Int_t ipOrder = 2); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidsetTraceCounter(Int_t value, Bool_t allNodes = kFALSE); voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsPdf.html:30308,cache,cache,30308,root/html528/RooAbsPdf.html,https://root.cern,https://root.cern/root/html528/RooAbsPdf.html,1,['cache'],['cache']
Performance,"oidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Bool_tRooAbsCachedPdf::selfNormalized() const; TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidsetBufferFraction(Double_t frac); voidsetBufferStrategy(RooFFTConvPdf::BufStrat bs); static voidRooAbsReal::setCacheCheck(Bool_t flag); voidsetCacheObservables(const RooArgSet& obs); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsPdf::setGeneratorConfig(); voidRooAbsPdf::setGeneratorConfig(const RooNumGenConfig& config); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsCachedPdf::setInterpolationOrder(Int_t order); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); voidRooAbsPdf::setNormRange(const char* rangeName); voidRooAbsPdf::setNormRangeOverride(const char* rangeName); voidRooAbsPdf::setNormValueCaching(Int_t minNumIntDim, Int_t ipOrder = 2); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidsetShift(Double_t val1, Double_t val2); voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooFFTConvPdf.html:32417,cache,cache,32417,root/html530/RooFFTConvPdf.html,https://root.cern,https://root.cern/root/html530/RooFFTConvPdf.html,1,['cache'],['cache']
Performance,"oidTObject::SetDtorOnly(void* obj); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidsetVal(const char* newVal); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); const map<std::string,std::string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; const set<std::string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidwriteToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooStringVar.html:14291,cache,cache,14291,root/html528/RooStringVar.html,https://root.cern,https://root.cern/root/html528/RooStringVar.html,2,['cache'],['cache']
Performance,"oidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; const char*TApplication::WorkingDirectory() const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. static Int_tTQObject::CheckConnectArgs(TQObject* sender, TClass* sender_class, const char* signal, TClass* receiver_class, const char* slot); static voidTApplication::Close(TApplication* app); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; static voidErrorHandler(Int_t level, Bool_t abort, const char* location, const char* msg); virtual void*TQObject::GetSender(); virtual const char*TQObject::GetSenderClassName() const; voidHandleCheckFile(TMessage* mess); virtual voidTApplication::Help(const char* line); virtual voidTApplication::LoadGraphicsLibs(); virtual voidTApplication::MakeBatch(); voidTObject::MakeZombie(); static TApplication*TApplication::Open(const char* url, Int_t debug, const char* script); static Int_tTApplication::ParseRemoteLine(const char* ln, TString& hostdir, TString& user, Int_t& dbg, TString& script); virtual Long_tTApplication::ProcessRemote(const char* line, Int_t* error = 0); voidTApplication::SetSignalHandler(TSignalHandler* sh). private:. voidExecLogon(); Int_tSendCanvases(); Int_tSetup(). Data Members; public:. enum TApplication::EStatusBits { kProcessRemotely; kDefaultApplication; };; enum TApplication::EExitOnException { kDontExit; kExit; kAbort; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TApplicationServer.html:11403,Load,LoadGraphicsLibs,11403,root/html532/TApplicationServer.html,https://root.cern,https://root.cern/root/html532/TApplicationServer.html,2,['Load'],['LoadGraphicsLibs']
Performance,"oidTQObject::HighPriority(const char* signal_name, const char* slot_name = 0); voidTClass::IgnoreTObjectStreamer(Bool_t ignore = kTRUE); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTClass::InheritsFrom(const char* cl) const; virtual Bool_tTClass::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTClass::InterpretedShowMembers(void* obj, TMemberInspector& insp); voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; static TClass::ENewTypeTClass::IsCallingNew(); virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTClass::IsFolder() const; Bool_tTClass::IsFolder(void* obj) const; Bool_tTClass::IsForeign() const; Bool_tTClass::IsLoaded() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTClass::IsStartingWithTObject() const; Bool_tTClass::IsTObject() const; Bool_tTClass::IsVersioned() const; Bool_tTObject::IsZombie() const; static TClass*TClass::Load(TBuffer& b); static voidTQObject::LoadRQ_OBJECT(); virtual voidTQObject::LowPriority(const char* signal_name, const char* slot_name = 0); virtual voidTClass::ls(Option_t* opt = """") const; voidTClass::MakeCustomMenuList(); Bool_tTClass::MatchLegacyCheckSum(UInt_t checksum) const; voidTObject::MayNotUse(const char* method) const; virtual voidTQObject::Message(const char* msg)SIGNAL ; voidTClass::Move(void* arenaFrom, void* arenaTo) const; void*TClass::New(TClass::ENewType defConstructor = kClassNew) const; void*TClass::New(void* arena, TClass::ENewType defConstructor = kClassNew) const; void*TClass::NewArray(Long_t nElements, TClass::ENewType defConstructor = kClassNew) const; void*TClass::NewArray(Long_t nElements, void* arena, TClass::ENewType defConstructor = kClassNew) const; virtual Bool_tTObject::Notify(); virtual Int_tTQObject::NumberOfConnections() const; virtual Int_tTQObject::NumberOfSignals() const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TQClass.html:12018,Load,Load,12018,root/html534/TQClass.html,https://root.cern,https://root.cern/root/html534/TQClass.html,1,['Load'],['Load']
Performance,"oid Print (Option_t *option="""") const override;  Print an overview of the hbook ntuple. ;  ; Long64_t SetEntries (Long64_t n=-1) override;  Set the number of entries in the tree header and its branches. ;  ; virtual void SetHbookFile (THbookFile *file);  ; virtual void SetType (Int_t atype);  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TTree;  TTree ();  Default constructor and I/O constructor. ;  ;  TTree (const char *name, const char *title, Int_t splitlevel=99, TDirectory *dir=(::ROOT::Internal::TDirectoryAtomicAdapter{}));  Normal tree constructor. ;  ;  TTree (const TTree &tt)=delete;  ;  ~TTree () override;  Destructor. ;  ; void AddAllocationCount (UInt_t count);  ; virtual Int_t AddBranchToCache (const char *bname, bool subbranches=false);  Add branch with name bname to the Tree cache. ;  ; virtual Int_t AddBranchToCache (TBranch *branch, bool subbranches=false);  Add branch b to the Tree cache. ;  ; void AddClone (TTree *);  Add a cloned tree to our list of trees to be notified whenever we change our branch addresses or when we are deleted. ;  ; virtual TFriendElement * AddFriend (const char *treename, const char *filename="""");  Add a TFriendElement to the list of friends. ;  ; virtual TFriendElement * AddFriend (const char *treename, TFile *file);  Add a TFriendElement to the list of friends. ;  ; virtual TFriendElement * AddFriend (TTree *tree, const char *alias="""", bool warn=false);  Add a TFriendElement to the list of friends. ;  ; virtual void AddTotBytes (Int_t tot);  ; virtual void AddZipBytes (Int_t zip);  ; virtual Long64_t AutoSave (Option_t *option="""");  AutoSave tree header every fAutoSave bytes. ;  ; virtual Int_t Branch (const char *folder, Int_t bufsize=32000, Int_t splitlevel=99);  Create one branch for each element in the folder. ;  ; TBranch * Branch (const char *name, char *address, const char *leafli",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHbookTree.html:2902,cache,cache,2902,doc/master/classTHbookTree.html,https://root.cern,https://root.cern/doc/master/classTHbookTree.html,1,['cache'],['cache']
Performance,"oid SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Types; enum  { kNullTag = 0; };  ;  Protected Types inherited from TBuffer; typedef std::vector< TVirtualArray * > CacheList_t;  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  . Protected Member Functions;  TBufferIO ();  ;  TBufferIO (TBuffer::EMode mode);  constructor ;  ;  TBufferIO (TBuffer::EMode mode, Int_t bufsiz);  constructor ;  ;  TBufferIO (TBuffer::EMode mode, Int_t bufsiz, void *buf, Bool_t adopt=kTRUE, ReAllocCharFun_t reallocfunc=nullptr);  constructor ;  ; virtual void CheckCount (UInt_t);  ; Long64_t GetObjectTag (const void *obj);  Returns tag for specified object from objects map (if exists) Returns 0 if object not included into objects map. ;  ; virtual void WriteObjectClass (const void *actualObjStart, const TClass *actualClass, Bool_t cacheReuse)=0;  ;  Protected Member Functions inherited from TBuffer;  TBuffer ();  ;  TBuffer (const TBuffer &)=delete;  ; void operator= (const TBuffer &)=delete;  ; Int_t Read (const char *name) override;  Read contents of object with specified name from the current directory. ;  ; Int_t Write (const char *name, Int_t opt, Int_t bufs) const override;  Write this object to the current directory. ;  ; Int_t Write (const char *name, Int_t opt, Int_t bufs) override;  Write this object to the current directory. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Static Protected Member Functions; static R__ALWAYS_INLINE ULong_t Void_Hash (const void *ptr);  Return hash value for provided object. ;  . Protected Attributes; TExMap * fClassMap {nullptr};  Map containing object,class pairs for reading. ;  ; Int_t fDisplacement {0};  Value to be added to the map offsets. ;  ; TExMap * fMap {nullptr};  Map containing obje",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBufferIO.html:27493,cache,cacheReuse,27493,doc/master/classTBufferIO.html,https://root.cern,https://root.cern/doc/master/classTBufferIO.html,1,['cache'],['cacheReuse']
Performance,"oid WriteFastArray (const Long_t *l, Long64_t n)=0;  ; virtual void WriteFastArray (const Short_t *h, Long64_t n)=0;  ; virtual void WriteFastArray (const UChar_t *c, Long64_t n)=0;  ; virtual void WriteFastArray (const UInt_t *i, Long64_t n)=0;  ; virtual void WriteFastArray (const ULong64_t *l, Long64_t n)=0;  ; virtual void WriteFastArray (const ULong_t *l, Long64_t n)=0;  ; virtual void WriteFastArray (const UShort_t *h, Long64_t n)=0;  ; virtual Int_t WriteFastArray (void **startp, const TClass *cl, Long64_t n=1, Bool_t isPreAlloc=kFALSE, TMemberStreamer *s=nullptr)=0;  ; virtual void WriteFastArray (void *start, const TClass *cl, Long64_t n=1, TMemberStreamer *s=nullptr)=0;  ; virtual void WriteFastArrayDouble32 (const Double_t *d, Long64_t n, TStreamerElement *ele=nullptr)=0;  ; virtual void WriteFastArrayFloat16 (const Float_t *f, Long64_t n, TStreamerElement *ele=nullptr)=0;  ; virtual void WriteFastArrayString (const Char_t *c, Long64_t n)=0;  ; virtual void WriteFloat (Float_t f)=0;  ; virtual void WriteFloat16 (Float_t *f, TStreamerElement *ele=nullptr)=0;  ; virtual void WriteInt (Int_t i)=0;  ; virtual void WriteLong (Long_t l)=0;  ; virtual void WriteLong64 (Long64_t l)=0;  ; template<class T > ; Int_t WriteObject (const T *objptr, Bool_t cacheReuse=kTRUE);  ; virtual void WriteShort (Short_t s)=0;  ; virtual void WriteStdString (const std::string *s)=0;  ; virtual void WriteStdString (std::string &s);  ; virtual void WriteString (const char *s)=0;  ; virtual void WriteTString (const TString &s)=0;  ; virtual void WriteUChar (UChar_t c)=0;  ; virtual void WriteUInt (UInt_t i)=0;  ; virtual void WriteULong (ULong_t l)=0;  ; virtual void WriteULong64 (ULong64_t l)=0;  ; virtual void WriteUShort (UShort_t s)=0;  ; virtual UInt_t WriteVersion (const TClass *cl, Bool_t useBcnt=kFALSE)=0;  ; virtual UInt_t WriteVersionMemberWise (const TClass *cl, Bool_t useBcnt=kFALSE)=0;  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBufferIO.html:17338,cache,cacheReuse,17338,doc/master/classTBufferIO.html,https://root.cern,https://root.cern/doc/master/classTBufferIO.html,1,['cache'],['cacheReuse']
Performance,"oint values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; vector<Double_t>_realRefReference values for reals; RooListProxy_realSetList of reals to track ; TIterator*_realSetIter! do not persist; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooChangeTracker.html:32641,cache,cache,32641,root/html526/RooChangeTracker.html,https://root.cern,https://root.cern/root/html526/RooChangeTracker.html,2,['cache'],['cache']
Performance,"ointer to global instance of string that matches object named; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_tRooResolutionModel::_ownBasisFlag indicating ownership of _basis; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooGaussModel.html:46692,cache,cache,46692,root/html602/RooGaussModel.html,https://root.cern,https://root.cern/root/html602/RooGaussModel.html,8,['cache'],['cache']
Performance,"ointer to the TChain being processed,; use fChain->GetTree()->GetEntry(entry);. void ProcessFill(Long64_t ); This method is called for all selected entries. User fills histograms; in this function. This method is obsolete, use Process(). WARNING when a selector is used with a TChain:; in the Process, ProcessCut, ProcessFill function, you must use; the pointer to the current Tree to call GetEntry(entry).; entry is always the local entry number in the current tree.; Assuming that fChain is the pointer to the TChain being processed,; use fChain->GetTree()->GetEntry(entry);. Bool_t Process(Long64_t ); The Process() function is called for each entry in the tree (or possibly; keyed object in the case of PROOF) to be processed. The entry argument; specifies which entry in the currently loaded tree is to be processed.; It can be passed to either t01::GetEntry() or TBranch::GetEntry(); to read either all or the required parts of the data. When processing; keyed objects with PROOF, the object is already loaded and is available; via the fObject pointer. This function should contain the ""body"" of the analysis. It can contain; simple or elaborate selection criteria, run algorithms on the data; of the event and typically fill histograms. The processing can be stopped by calling Abort(). Use fStatus to set the return value of TTree::Process(). The return value is currently not used. TSelector(const TSelector& ). TSelector& operator=(const TSelector& ). int Version() const; { return 0; }. void Init(TTree* ); { }. void Begin(TTree* ); { }. void SlaveBegin(TTree* ); { }. Bool_t Notify(); { return kTRUE; }. const char * GetOption() const; { return fOption; }. Long64_t GetStatus() const; { return fStatus; }. Int_t GetEntry(Long64_t , Int_t = 0); { return 0; }. void SetOption(const char* option); { fOption = option; }. void SetObject(TObject* obj); { fObject = obj; }. void SetInputList(TList* input); { fInput = input; }. void SetStatus(Long64_t status); { fStatus = status; }. TList * Get",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TSelector.html:12062,load,loaded,12062,root/html534/TSelector.html,https://root.cern,https://root.cern/root/html534/TSelector.html,6,['load'],['loaded']
Performance,"oissonian statistics should be used, which modifies the significance criterion.; The rectangular cut of a volume in the variable space is performed using a binary tree to sort the training events. This provides a significant reduction in computing time (up to several orders of magnitudes, depending on the complexity of the problem at hand).; Technically, optimisation is achieved in TMVA by two methods:. Monte Carlo generation using uniform priors for the lower cut value, and the cut width, thrown within the variable ranges.; A Genetic Algorithm (GA) searches for the optimal (""fittest"") cut sample. The GA is configurable by many external settings through the option string. For difficult cases (such as many variables), some tuning may be necessary to achieve satisfying results. Attempts to use Minuit fits (Simplex ot Migrad) instead have not shown superior results, and often failed due to convergence at local minima.; The tests we have performed so far showed that in generic applications, the GA is superior to MC sampling, and hence GA is the default method. It is worthwhile trying both anyway.; Decorrelated (or ""diagonalized"") Cuts**; See class description for Method Likelihood for a detailed explanation. ; Definition at line 61 of file MethodCuts.h. Public Member Functions;  MethodCuts (const TString &jobName, const TString &methodTitle, DataSetInfo &theData, const TString &theOption=""MC:150:10000:"");  standard constructor ;  ;  MethodCuts (DataSetInfo &theData, const TString &theWeightFile);  construction from weight file ;  ; virtual ~MethodCuts (void);  destructor ;  ; void AddWeightsXMLTo (void *parent) const;  create XML description for LD classification and regression (for arbitrary number of output classes/targets) ;  ; void CheckSetup ();  check may be overridden by derived class (sometimes, eg, fitters are used which can only be implemented during training phase) ;  ; Double_t ComputeEstimator (std::vector< Double_t > &);  returns estimator for ""cut fitness",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodCuts.html:2108,perform,performed,2108,doc/master/classTMVA_1_1MethodCuts.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodCuts.html,1,['perform'],['performed']
Performance,"ojList_iEndProjecteds(); virtual Bool_tHasProjecteds() const; virtual TClass*IsA() const; virtual TClass*ProjectedClass(const TEveProjection* p) const; virtual voidPropagateMainColor(Color_t color, Color_t old_color); virtual voidPropagateMainTransparency(Char_t t, Char_t old_t); virtual voidPropagateRenderState(Bool_t rnr_self, Bool_t rnr_children); virtual voidPropagateVizParams(TEveElement* el = 0); virtual voidRemoveProjected(TEveProjected* p); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). private:. TEveProjectable&operator=(const TEveProjectable&). Data Members; protected:. list<TEveProjected*>fProjectedListreferences to projected instances. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TEveProjectable(); Destructor.; Force projected replicas to unreference *this, then destroy them. void AnnihilateProjecteds(); Optimized destroy of projected elements with condition; there is only one parent for projected element. Method is; called from TEveElement::Annihilate(). void ClearProjectedList(). void AddProjectedsToSet(set<TEveElement*>& set); Add the projected elements to the set, dyn-casting them to; TEveElement. void PropagateVizParams(TEveElement* el = 0); Set visualization parameters of projecteds.; Use element el as model. If el == 0 (default), this casted to; TEveElement is used. void PropagateRenderState(Bool_t rnr_self, Bool_t rnr_children); Set render state of projecteds. void PropagateMainColor(Color_t color, Color_t old_color); Set main color of projecteds if their color is the same as old_color. void PropagateMainTransparency(Char_t t, Char_t old_t); Set main transparency of projecteds if their transparecy is the; same as the old one. TEveProjectable& operator=(const TEveProjectable& ). TClass* ProjectedClass(const TEveProjection* p) const. Bool_t HasProjecteds() const; { return ! fProjectedList.empty(); }. ProjList_i Begi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TEveProjectable.html:2064,Optimiz,Optimized,2064,root/html534/TEveProjectable.html,https://root.cern,https://root.cern/root/html534/TEveProjectable.html,1,['Optimiz'],['Optimized']
Performance,"ol subgbranches=false) override;  Add a branch discovered by actual usage to the list of branches to be stored in the cache this function is called by TBranch::GetBasket If we are not longer in the training phase this is an error. ;  ; virtual void LearnPrefill ();  Perform an initial prefetch, attempting to read as much of the learning phase baskets for all branches at once. ;  ; void Print (Option_t *option="""") const override;  Print cache statistics. ;  ; Int_t ReadBuffer (char *buf, Long64_t pos, Int_t len) override;  Read buffer at position pos if the request is in the list of prefetched blocks read from fBuffer. ;  ; virtual Int_t ReadBufferNormal (char *buf, Long64_t pos, Int_t len);  Old method ReadBuffer before the addition of the prefetch mechanism. ;  ; virtual Int_t ReadBufferPrefetch (char *buf, Long64_t pos, Int_t len);  Used to read a chunk from a block previously fetched. ;  ; virtual void ResetCache ();  This will simply clear the cache. ;  ; void ResetMissCache ();  Reset all the miss cache training. ;  ; void SetAutoCreated (bool val);  ; Int_t SetBufferSize (Int_t buffersize) override;  Change the underlying buffer size of the cache. ;  ; virtual void SetEntryRange (Long64_t emin, Long64_t emax);  Set the minimum and maximum entry number to be processed this information helps to optimize the number of baskets to read when prefetching the branch buffers. ;  ; void SetFile (TFile *file, TFile::ECacheAction action=TFile::kDisconnect) override;  Change the file that is being cached. ;  ; virtual void SetLearnPrefill (EPrefillType type=kNoPrefill);  Set whether the learning period is started with a prefilling of the cache and which type of prefilling is used. ;  ; void SetOptimizeMisses (bool opt);  Start of methods for the miss cache. ;  ; void StartLearningPhase ();  The name should be enough to explain the method. ;  ; virtual void StopLearningPhase ();  This is the counterpart of StartLearningPhase() and can be used to stop the learning phase. ;  ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCache.html:15297,cache,cache,15297,doc/v632/classTTreeCache.html,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html,1,['cache'],['cache']
Performance,"ol subgbranches=false) override;  Add a branch discovered by actual usage to the list of branches to be stored in the cache this function is called by TBranch::GetBasket If we are not longer in the training phase this is an error. ;  ; virtual void LearnPrefill ();  Perform an initial prefetch, attempting to read as much of the learning phase baskets for all branches at once. ;  ; void Print (Option_t *option="""") const override;  Print cache statistics. ;  ; Int_t ReadBuffer (char *buf, Long64_t pos, Int_t len) override;  Read buffer at position pos if the request is in the list of prefetched blocks read from fBuffer. ;  ; virtual Int_t ReadBufferNormal (char *buf, Long64_t pos, Int_t len);  Old method ReadBuffer before the addition of the prefetch mechanism. ;  ; virtual Int_t ReadBufferPrefetch (char *buf, Long64_t pos, Int_t len);  Used to read a chunk from a block previously fetched. ;  ; virtual void ResetCache ();  This will simply clear the cache. ;  ; void ResetMissCache ();  Reset all the miss cache training. ;  ; void SetAutoCreated (bool val);  ; Int_t SetBufferSize (Long64_t buffersize) override;  Change the underlying buffer size of the cache. ;  ; virtual void SetEntryRange (Long64_t emin, Long64_t emax);  Set the minimum and maximum entry number to be processed this information helps to optimize the number of baskets to read when prefetching the branch buffers. ;  ; void SetFile (TFile *file, TFile::ECacheAction action=TFile::kDisconnect) override;  Change the file that is being cached. ;  ; virtual void SetLearnPrefill (EPrefillType type=kNoPrefill);  Set whether the learning period is started with a prefilling of the cache and which type of prefilling is used. ;  ; void SetOptimizeMisses (bool opt);  Start of methods for the miss cache. ;  ; void StartLearningPhase ();  The name should be enough to explain the method. ;  ; virtual void StopLearningPhase ();  This is the counterpart of StartLearningPhase() and can be used to stop the learning phase. ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeCache.html:15298,cache,cache,15298,doc/master/classTTreeCache.html,https://root.cern,https://root.cern/doc/master/classTTreeCache.html,1,['cache'],['cache']
Performance,"ol the bar width (default is the bin width) TH1::SetBarWidth() should be used.; To control the bar offset (default is 0) TH1::SetBarOffset() should be used.; These two parameters are useful when several histograms are plotted using the option SAME. They allow to plot the histograms next to each other. The SCATter plot option (legacy draw option); AttentionUse of option SCAT has been deprecated. It was the default drawing option for 2D and 3D histograms. The new default option is COL (heat-map).; For each cell (i,j) a number of points proportional to the cell content is drawn. A maximum of kNMAX points per cell is drawn. If the maximum is above kNMAX contents are normalized to kNMAX (kNMAX=2000). If option is of the form scat=ff, (eg scat=1.8, scat=1e-3), then ff is used as a scale factor to compute the number of dots. scat=1 is the default.; By default the scatter plot is painted with a ""dot marker"" which not scalable (see the TAttMarker documentation). To change the marker size, a scalable marker type should be used. For instance a circle (marker style 20).; {; auto c1 = new TCanvas(""c1"",""c1"",600,400);; auto hscat = new TH2F(""hscat"",""Option SCATter example (default for 2D histograms) "",40,-4,4,40,-20,20);; float px, py;; for (Int_t i = 0; i < 25000; i++) {; gRandom->Rannor(px,py);; hscat->Fill(px,5*py);; hscat->Fill(3+0.5*px,2*py-10.);; }; hscat->Draw(""scat=0.5""); // This a legacy draw option. Please consider using TScatter; }. The ARRow option; Shows gradient between adjacent cells. For each cell (i,j) an arrow is drawn The orientation of the arrow follows the cell gradient.; {; auto c1 = new TCanvas(""c1"",""c1"",600,400);; auto harr = new TH2F(""harr"",""Option ARRow example"",20,-4,4,20,-20,20);; harr->SetLineColor(kRed);; float px, py;; for (Int_t i = 0; i < 25000; i++) {; gRandom->Rannor(px,py);; harr->Fill(px,5*py);; harr->Fill(3+0.5*px,2*py-10.,0.1);; }; harr->Draw(""ARR"");; }. SinceROOT version 6.17/01; The option ARR can be combined with the option COL or COLZ.; {",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHistPainter.html:38158,scalab,scalable,38158,doc/master/classTHistPainter.html,https://root.cern,https://root.cern/doc/master/classTHistPainter.html,1,['scalab'],['scalable']
Performance,"ol) const; virtual doubleROOT::Minuit2::FCNBase::operator()(const vector<double>& x) const; ROOT::Minuit2::FCNBase&ROOT::Minuit2::FCNBase::operator=(const ROOT::Minuit2::FCNBase&); virtual voidROOT::Minuit2::FCNBase::SetErrorDef(double); virtual doubleROOT::Minuit2::FCNBase::Up() const; virtual doubleValue() const. protected:. vector<double>&Gradient(); vector<double>&Hessian(); virtual voidInitAndReset(unsigned int npar); voidSetFCNValue(double value). Data Members; private:. vector<double>fGradient; vector<double>fHessian; const ROOT::Minuit2::ParametricFunction*fModelFunction; unsigned intfNumberOfParameters; doublefValue. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~FumiliFCNBase(); FumiliFCNBase(const ParametricFunction& modelFCN) { fModelFunction = &modelFCN; }. {}. void EvaluateAll(const vector<double>& par). Evaluate function Value, Gradient and Hessian using Fumili approximation, for values of parameters p; The resul is cached inside and is return from the FumiliFCNBase::Value , FumiliFCNBase::Gradient and; FumiliFCNBase::Hessian methods. @param par vector of parameters. double Value() const. Return cached Value of objective function estimated previously using the FumiliFCNBase::EvaluateAll method. { return fValue; }. const std::vector<double> & Gradient(). Return cached Value of function Gradient estimated previously using the FumiliFCNBase::EvaluateAll method. { return fGradient; }. double Hessian(unsigned int row, unsigned int col) const. Return Value of the i-th j-th element of the Hessian matrix estimated previously using the FumiliFCNBase::EvaluateAll method; @param row row Index of the matrix; @param col col Index of the matrix. unsigned int Dimension(). return number of function variable (parameters) , i.e. function dimension. { return fNumberOfParameters; }. void InitAndReset(unsigned int npar). initialize and reset values of gradien and Hessian. void SetFCNValue(double value); methods to be us",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Minuit2__FumiliFCNBase.html:2524,cache,cached,2524,root/html526/ROOT__Minuit2__FumiliFCNBase.html,https://root.cern,https://root.cern/root/html526/ROOT__Minuit2__FumiliFCNBase.html,1,['cache'],['cached']
Performance,"olAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooCategoryProxy_catAccept/reject categort; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooRealProxy_effFuncEfficiency modeling function; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCoun",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooEfficiency.html:36633,cache,cache,36633,root/html526/RooEfficiency.html,https://root.cern,https://root.cern/root/html526/RooEfficiency.html,5,['cache'],['cache']
Performance,"olAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; TString_formExprFormula expression string; RooFormula*_formula! Formula engine; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooFormulaVar.html:35757,cache,cache,35757,root/html602/RooFormulaVar.html,https://root.cern,https://root.cern/root/html602/RooFormulaVar.html,10,"['Cache', 'cache']","['Cached', 'cache']"
Performance,"ol_t &IsImplicitMTEnabledImpl(); 464 {; 465 static Bool_t isImplicitMTEnabled = kFALSE;; 466 return isImplicitMTEnabled;; 467 }; 468 ; 469} // end of Internal sub namespace; 470// back to ROOT namespace; 471 ; 472 TROOT *GetROOT() {; 473 return (*Internal::gGetROOT)();; 474 }; 475 ; 476 TString &GetMacroPath() {; 477 static TString macroPath;; 478 return macroPath;; 479 }; 480 ; 481 // clang-format off; 482 ////////////////////////////////////////////////////////////////////////////////; 483 /// Enables the global mutex to make ROOT thread safe/aware.; 484 ///; 485 /// The following becomes safe:; 486 /// - concurrent construction and destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); 487 /// - concurrent usage of _different_ ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); 488 /// - concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; 489 /// - concurrent calls to the interpreter through gInterpreter; 490 /// - concurrent loading of ROOT plug-ins; 491 ///; 492 /// In addition, gDirectory, gFile and gPad become a thread-local variable.; 493 /// In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents.; 494 /// gFile and gPad default to nullptr, as it is for single-thread programs.; 495 ///; 496 /// The ROOT graphics subsystem is not made thread-safe by this method. In particular drawing or printing different; 497 /// canvases from different threads (and analogous operations such as invoking `Draw` on a `TObject`) is not thread-safe.; 498 ///; 499 /// Note that there is no `DisableThreadSafety()`. ROOT's thread-safety features cannot be disabled once activated.; 500 // clang-format on; 501 void EnableThreadSafety(); 502 {; 503 static void (*sym)() = (void(*)())Internal::GetSymInLibImt(""ROOT_TThread_In",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8cxx_source.html:17296,concurren,concurrent,17296,doc/master/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8cxx_source.html,2,['concurren'],['concurrent']
Performance,"ol_t IsaPointer() const; Return true if data member is a pointer. int IsSTLContainer(); The return type is defined in TDictionary (kVector, kList, etc.). Bool_t IsValid(); Return true if this data member object is pointing to a currently; loaded data member. If a function is unloaded after the TDataMember; is created, the TDataMember will be set to be invalid. Long_t Property() const; Get property description word. For meaning of bits see EProperty. TList * GetOptions() const; Returns list of options - list of TOptionListItems. TMethodCall * GetterMethod(TClass* cl = 0); Return a TMethodCall method responsible for getting the value; of data member. The cl argument specifies the class of the object; which will be used to call this method (in case of multiple; inheritance TMethodCall needs to know this to calculate the proper; offset). TMethodCall * SetterMethod(TClass* cl); Return a TMethodCall method responsible for setting the value; of data member. The cl argument specifies the class of the object; which will be used to call this method (in case of multiple; inheritance TMethodCall needs to know this to calculate the proper; offset). Bool_t Update(DataMemberInfo_t* info); Update the TFunction to reflect the new info. This can be used to implement unloading (info == 0) and then reloading; (info being the 'new' decl address). void Streamer(TBuffer& ); Stream an object of TDataMember. Forces calculation of all cached; (and persistent) values. TClass * GetClass() const; { return fClass; }. TDataType * GetDataType() const; { return fDataType; }. Bool_t IsPersistent() const; { return TestBit(kObjIsPersistent); }. void SetClass(TClass* cl); { fClass = cl; }. » Author: Fons Rademakers 04/02/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/meta:$Id$ » Last generated: 2015-06-02 15:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TDataMember.html:16799,cache,cached,16799,root/html604/TDataMember.html,https://root.cern,https://root.cern/root/html604/TDataMember.html,2,['cache'],['cached']
Performance,"ol_t IsaPointer() const; Return true if data member is a pointer. int IsSTLContainer(); The return type is defined in TDictionary (kVector, kList, etc.). Bool_t IsValid(); Return true if this data member object is pointing to a currently; loaded data member. If a function is unloaded after the TDataMember; is created, the TDataMember will be set to be invalid. Long_t Property() const; Get property description word. For meaning of bits see EProperty. TList * GetOptions() const; Returns list of options - list of TOptionListItems. TMethodCall * GetterMethod(TClass* cl = 0); Return a TMethodCall method responsible for getting the value; of data member. The cl argument specifies the class of the object; which will be used to call this method (in case of multiple; inheritance TMethodCall needs to know this to calculate the proper; offset). TMethodCall * SetterMethod(TClass* cl); Return a TMethodCall method responsible for setting the value; of data member. The cl argument specifies the class of the object; which will be used to call this method (in case of multiple; inheritance TMethodCall needs to know this to calculate the proper; offset). Bool_t Update(DataMemberInfo_t* info); Update the TFunction to reflect the new info. This can be used to implement unloading (info == 0) and then reloading; (info being the 'new' decl address). void Streamer(TBuffer& ); Stream an object of TDataMember. Forces calculation of all cached; (and persistent) values. TClass * GetClass() const; { return fClass; }. TDataType * GetDataType() const; { return fDataType; }. Bool_t IsPersistent() const; { return TestBit(kObjIsPersistent); }. void SetClass(TClass* cl); { fClass = cl; }. » Author: Fons Rademakers 04/02/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/meta:$Id$ » Last generated: 2015-06-30 14:42; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TDataMember.html:16510,cache,cached,16510,root/html602/TDataMember.html,https://root.cern,https://root.cern/root/html602/TDataMember.html,2,['cache'],['cached']
Performance,"ol_t TGenCollectionProxy::HasPointers() const; 1023{; 1024 // Initialize proxy in case it hasn't been initialized yet; 1025 if( !fValue.load(std::memory_order_relaxed) ); 1026 Initialize(kFALSE);; 1027 ; 1028 // The content of a map and multimap is always a 'pair' and hence; 1029 // fPointers means ""Flag to indicate if containee has pointers (key or value)""; 1030 // so we need to ignore its value for map and multimap;; 1031 return fPointers && !(fSTL_type == ROOT::kSTLmap || fSTL_type == ROOT::kSTLmultimap ||; 1032 fSTL_type == ROOT::kSTLunorderedmap || fSTL_type == ROOT::kSTLunorderedmultimap);; 1033}; 1034 ; 1035////////////////////////////////////////////////////////////////////////////////; 1036/// Return a pointer to the TClass representing the content.; 1037 ; 1038TClass *TGenCollectionProxy::GetValueClass() const; 1039{; 1040 auto value = fValue.load(std::memory_order_relaxed);; 1041 if (!value) {; 1042 Initialize(kFALSE);; 1043 value = fValue.load(std::memory_order_relaxed);; 1044 }; 1045 return value ? (*value).fType.GetClass() : 0;; 1046}; 1047 ; 1048////////////////////////////////////////////////////////////////////////////////; 1049/// If the content is a simple numerical value, return its type (see TDataType); 1050 ; 1051EDataType TGenCollectionProxy::GetType() const; 1052{; 1053 auto value = fValue.load(std::memory_order_relaxed);; 1054 if (!value) {; 1055 Initialize(kFALSE);; 1056 value = fValue.load(std::memory_order_relaxed);; 1057 }; 1058 return value ? (*value).fKind : kNoType_t;; 1059}; 1060 ; 1061////////////////////////////////////////////////////////////////////////////////; 1062/// Return the address of the value at index 'idx'; 1063 ; 1064void* TGenCollectionProxy::At(UInt_t idx); 1065{; 1066 if ( fEnv && fEnv->fObject ) {; 1067 switch (fSTL_type) {; 1068 case ROOT::kSTLvector:; 1069 if ((*fValue).fKind == kBool_t) {; 1070 auto vec = (std::vector<bool> *)(fEnv->fObject);; 1071 fEnv->fLastValueVecBool = (*vec)[idx];; 1072 fEnv->fIdx = idx;; 1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:33977,load,load,33977,doc/master/TGenCollectionProxy_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html,1,['load'],['load']
Performance,"ol_t adjustProxies = kTRUE) const; Double_tRooAbsReal::traceEval(const RooArgSet* set) const; virtual Bool_tRooResolutionModel::traceEvalHook(Double_t value) const; voidRooAbsArg::unRegisterProxy(RooArgProxy& proxy); voidRooAbsArg::unRegisterProxy(RooSetProxy& proxy); voidRooAbsArg::unRegisterProxy(RooListProxy& proxy). Data Members; public:. enum RooGExpBasis { noBasis; expBasisMinus; expBasisSum; expBasisPlus; sinBasisMinus; sinBasisSum; sinBasisPlus; cosBasisMinus; cosBasisSum; cosBasisPlus; sinhBasisMinus; sinhBasisSum; sinhBasisPlus; coshBasisMinus; coshBasisSum; coshBasisPlus; };; enum BasisType { none; expBasis; sinBasis; cosBasis; sinhBasis; coshBasis; };; enum BasisSign { Both; Plus; Minus; };; enum Type { Normal; Flipped; };; enum RooAbsPdf::ExtendMode { CanNotBeExtended; CanBeExtended; MustBeExtended; };; enum RooAbsReal::ScaleType { Raw; Relative; NumEvent; RelativeExpected; };; enum RooAbsReal::ErrorLoggingMode { PrintErrors; CollectErrors; CountErrors; Ignore; };; enum RooAbsArg::ConstOpCode { Activate; DeActivate; ConfigChange; ValueChange; };; enum RooAbsArg::CacheMode { Always; NotAdvised; Never; };; enum RooAbsArg::OperMode { Auto; AClean; ADirty; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. public:. static map<RooAbsArg*,TRefArray*>RooAbsArg::_ioEvoListtemporary holding list for proxies needed in schema evolution ; static stack<RooAbsArg*>RooAbsArg::_ioReadStackreading stack ; static const UInt_tRooAbsArg::fnv1a32start; static const ULong64_tRooAbsArg::fnv1a64start. protected:. Bool_t_asympIntadded FMV,07/24/03; RooFormulaVar*R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooGExpModel.html:40896,Cache,CacheMode,40896,root/html534/RooGExpModel.html,https://root.cern,https://root.cern/root/html534/RooGExpModel.html,1,['Cache'],['CacheMode']
Performance,"ol_t flag); Global switch controlling the activation of the selectComp() functionality. RooAbsFunc * bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; Create an interface adaptor f(vars) that binds us to the specified variables; (in arbitrary order). For example, calling bindVars({x1,x3}) on an object; F(x1,x2,x3,x4) returns an object f(x1,x3) that is evaluated using the; current values of x2 and x4. The caller takes ownership of the returned adaptor. void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE, Bool_t setValDirty = kTRUE); Copy the cached value of another RooAbsArg to our cache.; Warning: This function copies the cached values of source,; it is the callers responsibility to make sure the cache is clean. void attachToVStore(RooVectorDataStore& vstore). void attachToTree(TTree& t, Int_t bufSize = 32000); Attach object to a branch of given TTree. By default it will; register the internal value cache RooAbsReal::_value as branch; buffer for a Double_t tree branch with the same name as this; object. If no Double_t branch is found with the name of this; object, this method looks for a Float_t Int_t, UChar_t and UInt_t; branch in that order. If any of these are found the buffer for; that branch is set to a correctly typed conversion buffer in this; RooRealVar. A flag is set that will cause copyCache to copy the; object value from the appropriate conversion buffer instead of; the _value buffer. void fillTreeBranch(TTree& t); Fill the tree branch that associated with this object with its current value. void setTreeBranchStatus(TTree& t, Bool_t active); (De)Activate associated tree branch. RooAbsArg * createFundamental(const char* newname = 0) const; Create a RooRealVar fundamental object with our properties. The new; object will be created without any fit limits. Bool_t matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Utility function for use in getAnalyticalIntegral(). If",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsReal.html:57510,cache,cache,57510,root/html532/RooAbsReal.html,https://root.cern,https://root.cern/root/html532/RooAbsReal.html,7,['cache'],['cache']
Performance,"ol_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMemberInspector& insp) const; RooAbsMoment*RooAbsReal::sigma(RooRealVar& obs); RooAbsMoment*RooAbsReal::sigma(RooRealVar& obs, const RooArgSet& nset); virtual Int_tTNamed::Sizeof() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig(Bool_t createOnTheFly); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); const map<string,string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; const set<string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; RooFIterRooAbsArg::valueClientMIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; voidRooAbsArg::wireAllCaches(); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidwriteToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsHiddenReal.html:26684,cache,cache,26684,root/html602/RooAbsHiddenReal.html,https://root.cern,https://root.cern/root/html602/RooAbsHiddenReal.html,12,['cache'],['cache']
Performance,"ol_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidsetAlwaysStartFromMin(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; virtual voidShowMembers(TMemberInspector& insp, char* parent); RooMoment*RooAbsReal::sigma(RooRealVa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooProfileLL.html:22649,cache,cache,22649,root/html526/RooProfileLL.html,https://root.cern,https://root.cern/root/html526/RooProfileLL.html,1,['cache'],['cache']
Performance,"ol_t readinfo=kTRUE)Specify if the streamerinfos must be read at file opening.Definition TFile.cxx:3732; TFile::fNoAnchorInNameBool_t fNoAnchorInName!True if we don't want to force the anchor to be appended to the file nameDefinition TFile.h:103; TFile::SetFileBytesReadstatic void SetFileBytesRead(Long64_t bytes=0)Definition TFile.cxx:4608; TFile::fSeekInfoLong64_t fSeekInfoLocation on disk of StreamerInfo record.Definition TFile.h:81; TFile::Paintvoid Paint(Option_t *option="""") overridePaint all objects in the file.Definition TFile.cxx:1698; TFile::GetBestBufferInt_t GetBestBuffer() constReturn the best buffer size of objects on this file.Definition TFile.cxx:1183; TFile::fOpenPhasesTList * fOpenPhases!Time info about open phasesDefinition TFile.h:113; TFile::SetCompressionLevelvirtual void SetCompressionLevel(Int_t level=ROOT::RCompressionSetting::ELevel::kUseMin)See comments for function SetCompressionSettings.Definition TFile.cxx:2319; TFile::GetCacheWriteTFileCacheWrite * GetCacheWrite() constReturn a pointer to the current write cache.Definition TFile.cxx:1279; TFile::SetFileReadCallsstatic void SetFileReadCalls(Int_t readcalls=0)Definition TFile.cxx:4614; TFile::fgCacheFileDirstatic TString fgCacheFileDirDirectory where to locally stage files.Definition TFile.h:124; TFile::SysReadvirtual Int_t SysRead(Int_t fd, void *buf, Int_t len)Interface to system read. All arguments like in POSIX read().Definition TFile.cxx:4506; TFile::fVersionInt_t fVersionFile format version.Definition TFile.h:83; TFile::Printvoid Print(Option_t *option="""") const overridePrint all objects in the file.Definition TFile.cxx:1706; TFile::fgFileCounterstatic std::atomic< Long64_t > fgFileCounterCounter for all opened files.Definition TFile.h:132; TFile::GetAsyncOpenStatusvirtual EAsyncOpenStatus GetAsyncOpenStatus()Definition TFile.h:137; TFile::Streamervoid Streamer(TBuffer &) overrideStream a TFile object.Definition TFile.cxx:2405; TFile::GetOpenTimeoutstatic UInt_t GetOpenTimeout()Return",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:215189,cache,cache,215189,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,1,['cache'],['cache']
Performance,"ol_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  ;  Static Public Member Functions inherited from RooPrintable; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static std::ostream & defaultPrintStream (std::ostream *os=nullptr);  Return a reference to the current default stream to use in Print(). ;  ; static void nameFieldLength (Int_t newLen);  Set length of field reserved from printing name of RooAbsArgs in multi-line collection printing to given amount. ;  . Protected Member Functions; double evaluate () const override;  Calculate and return value of \( a_n * \prod_{i=0}^{n-1} (1 - a_i) \). ;  ;  Protected Member Functions inherited from RooAbsReal; void attachToTree (TTree &t, Int_t bufSize=32000) override;  Attach object to a branch of given TTree. ;  ; void attachToVStore (RooVectorDataStore &vstore) override;  ; void copyCache (const RooAbsArg *source, bool valueOnly=false, bool setValDirty=true) override;  Copy the cached value of another RooAbsArg to our cache. ;  ; RooFit::OwningPtr< RooAbsReal > createIntObj (const RooArgSet &iset, const RooArgSet *nset, const RooNumIntConfig *cfg, const char *rangeName) const;  Internal utility function for createIntegral() that creates the actual integral object. ;  ; void fillTreeBranch (TTree &t) override;  Fill the tree branch that associated with this object with its current value. ;  ; void findInnerMostIntegration (const RooArgSet &allObs, RooArgSet &innerObs, const char *rangeName) const;  Utility function for createIntObj() that aids in the construct of recursive integrals over functions with multiple observables with parameterized ranges. ;  ; TString integralNameSuffix (const RooArgSet &iset, const RooArgSet *nset=nullptr, const char *rangeName=nullptr, bool omitEmpty=false) const;  Construct string with unique suffix name to give to integral object that encodes integrated observables, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooRecursiveFraction.html:48263,cache,cached,48263,doc/master/classRooRecursiveFraction.html,https://root.cern,https://root.cern/doc/master/classRooRecursiveFraction.html,2,['cache'],"['cache', 'cached']"
Performance,"ol_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tnumEvalErrorItems(); static Int_tnumEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_toperator==(Double_t value) const; virtual Bool_toperator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t scaleFactor = 1.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsReal.html:17063,optimiz,optimizeCacheMode,17063,root/html526/RooAbsReal.html,https://root.cern,https://root.cern/root/html526/RooAbsReal.html,4,['optimiz'],['optimizeCacheMode']
Performance,"ol_t valueOnly = kFALSE, Bool_t setValueDirty = kTRUE); const RooCatType*RooAbsCategory::defineType(const char* label); const RooCatType*RooAbsCategory::defineType(const char* label, Int_t index); const RooCatType*RooAbsCategory::defineTypeUnchecked(const char* label, Int_t index); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual RooCatTypeevaluate() const; virtual voidRooAbsCategory::fillTreeBranch(TTree& t); virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; const RooCatType*RooAbsCategory::getOrdinal(UInt_t n, const char* rangeName = 0) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; voidRooAbsArg::graphVizAddConnections(set<std::pair<RooAbsArg*,RooAbsArg*> >&); Bool_tRooAbsArg::inhibitDirty() const; voidinitialize(const char* catTypeName = 0); virtual Bool_tRooAbsCategory::isValid() const; virtual Bool_tRooAbsCategory::isValid(const RooCatType& value) const; voidTObject::MakeZombie(); Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); voidRooAbsArg::printAttribList(ostream& os) const; voidRooAbsArg::registerProxy(RooArgProxy& proxy); voidRooAbsArg::registerProxy(RooSetProxy& proxy); voidRooAbsArg::registerProxy(RooListProxy& proxy); voidRooAbsArg::setProxyNormSet(const RooArgSet* nset); voidRooAbsArg::setShapeDirty(const RooAbsArg* source) const; virtual voidRooAbsCategory::setTreeBranchStatus(TTree& t, Bool_t active); voidRooAbsArg::setValueDirty(const RooAbsArg* source) const; virtual voidRooAbsCategory::syncCache(const RooArgSet* set = 0); RooCatTypeRooAbsCategory::traceEval() const; virtual Bool_tRooAbsCategory::traceEvalHook(RooCatType) const; voidRooAbsArg::unRegisterProxy(RooArgProxy& proxy); voidRooAbsArg::unRegisterProxy(RooSetProxy& proxy); voidRooAbsArg::unRegisterProxy(RooListProxy& proxy).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooBinningCategory.html:18621,optimiz,optimizeDirtyHook,18621,root/html534/RooBinningCategory.html,https://root.cern,https://root.cern/root/html534/RooBinningCategory.html,2,['optimiz'],['optimizeDirtyHook']
Performance,"ol_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tcentral() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooMoment.html:2316,cache,cacheUniqueSuffix,2316,root/html528/RooMoment.html,https://root.cern,https://root.cern/root/html528/RooMoment.html,4,['cache'],['cacheUniqueSuffix']
Performance,"ol_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, RooCmdArg arg1 = RooCmdArg::none(), RooCmdArg arg2 = RooCmdArg::none(), RooCmdArg arg3 = RooCmdArg::none(), RooCmdArg arg4 = RooCmdArg::none(), RooCmdArg arg5 = RooCmdArg::none(), RooCmdArg arg6 = RooCmdArg::none(), RooCmdArg arg7 = RooCmdArg::none(), RooCmdArg arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, RooCmdArg arg1 = RooCmdArg::none(), RooCmdArg arg2 = RooCmdArg::none(), RooCmdArg arg3 = RooCmdArg::none(), RooCmdArg arg4 = RooCmdArg::none(), RooCmdArg arg5 = R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsHiddenReal.html:2205,cache,cacheUniqueSuffix,2205,root/html528/RooAbsHiddenReal.html,https://root.cern,https://root.cern/root/html528/RooAbsHiddenReal.html,40,['cache'],['cacheUniqueSuffix']
Performance,"ol_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/PiecewiseInterpolation.html:2128,cache,cacheUniqueSuffix,2128,root/html528/PiecewiseInterpolation.html,https://root.cern,https://root.cern/root/html528/PiecewiseInterpolation.html,111,['cache'],['cacheUniqueSuffix']
Performance,"ol_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; voidcalculate() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooRealMPFE.html:2862,cache,cacheUniqueSuffix,2862,root/html528/RooRealMPFE.html,https://root.cern,https://root.cern/root/html528/RooRealMPFE.html,2,['cache'],['cacheUniqueSuffix']
Performance,"ol_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidsetEps(Double_t e); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; virtual voidShowMembers(TMemberInspector& insp); RooMoment*RooAbsReal::sigma(RooRealVar& obs); RooMo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooDerivative.html:23030,cache,cache,23030,root/html530/RooDerivative.html,https://root.cern,https://root.cern/root/html530/RooDerivative.html,1,['cache'],['cache']
Performance,"ol_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidsetVal(const char* newVal); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); const map<std::string,std::string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooStringVar.html:12978,cache,cache,12978,root/html530/RooStringVar.html,https://root.cern,https://root.cern/root/html530/RooStringVar.html,1,['cache'],['cache']
Performance,"ol_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); const map<std::string,std::string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooAbsCategory.html:13888,cache,cache,13888,root/html530/RooAbsCategory.html,https://root.cern,https://root.cern/root/html530/RooAbsCategory.html,7,['cache'],['cache']
Performance,"ol_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction3Ref<double,double,double,double>funcFunction pointer reference; RooRealProxyxArgument reference; RooRealProxyyArgument reference; RooRealProxyzArgument reference. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void RooCFunction3Ref<VO,VI1,VI2,VI3> Streamer(TBuffer& ); Custom str",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCFunction3Binding_double_double_double_double_.html:36826,cache,cache,36826,root/html602/RooCFunction3Binding_double_double_double_double_.html,https://root.cern,https://root.cern/root/html602/RooCFunction3Binding_double_double_double_double_.html,8,['cache'],['cache']
Performance,"ol_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_toffset() const; virtual Double_toffsetCarry() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooAbsTestStatistic&operator=(const RooAbsTestStatistic&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsTestStatistic.html:20481,optimiz,optimizeCacheMode,20481,root/html602/RooAbsTestStatistic.html,https://root.cern,https://root.cern/root/html602/RooAbsTestStatistic.html,4,['optimiz'],['optimizeCacheMode']
Performance,"ol_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooCFunction4Binding<double,double,double,double,bool>&operator=(const RooCFunction4Binding<double,double,double,double,bool>&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCFunction4Binding_double_double_double_double_bool_.html:19952,optimiz,optimizeCacheMode,19952,root/html602/RooCFunction4Binding_double_double_double_double_bool_.html,https://root.cern,https://root.cern/root/html602/RooCFunction4Binding_double_double_double_double_bool_.html,4,['optimiz'],['optimizeCacheMode']
Performance,ol_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Bool_t_disableCacheFlag to run object in passthrough (= non-caching mode). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsCachedPdf(); Destructor. Double_t getValV(const RooArgSet* set = 0) const; Implementation of getVal() overriding default implementation; of RooAbsPdf. Return normalized value stored in cache p.d.f; rather than return value of evaluate() which is undefined; for RooAbsCachedPdf. RooAbsPdf* getCachePdf(const RooArgSet* nset = 0) const; Return pointer to RooHistPdf cache pdf for given choice of observables. RooDataHist* getCacheHist(const RooArgSet* nset = 0) const; Return pointer to RooDataHist cache histogram for given choice of observables. void clearCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; Mark all bins of given cache as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct string with unique suffix for cache objects based on; observable names that define cache configuration. void setInterpolationOrder(Int_t order); Change the interpolation order that is used in RooHistPdf cache; representation smoothing the RooDataHist shapes. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force RooRealIntegral to offer all our actual observable for internal; integration. Int_t getAnalyticalIntegralWN(RooArgSet& ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsCachedPdf.html:43758,cache,cache,43758,root/html532/RooAbsCachedPdf.html,https://root.cern,https://root.cern/root/html532/RooAbsCachedPdf.html,1,['cache'],['cache']
Performance,"ol_tfIsMacroplugin is a macro and not a library; TFunction*fMethod!ctor method or global function; TStringfOriginorigin of plugin handler definition; TStringfPluginplugin library which should contain fClass; TStringfRegexpregular expression which must be matched in URI. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPluginHandler(const char* base, const char* regexp, const char* className, const char* pluginName, const char* ctor, const char* origin); Create a plugin handler. Called by TPluginManager. ~TPluginHandler(); Cleanup plugin handler object. Bool_t CanHandle(const char* base, const char* uri); Check if regular expression appears in the URI, if so return kTRUE.; If URI = 0 always return kTRUE. void SetupCallEnv(); Setup ctor or static method call environment. Int_t CheckPlugin() const; Check if the plugin library for this handler exits. Returns 0; when it exists and -1 in case the plugin does not exist. Int_t LoadPlugin(); Load the plugin library for this handler. Returns 0 on successful loading; and -1 in case the library does not exist or in case of error. Bool_t CheckForExecPlugin(Int_t nargs); Check that we can properly run ExecPlugin. void Print(Option_t* opt = """") const; Print info about the plugin handler. If option is ""a"" print; also the ctor's that will be used. TPluginHandler(); { }. TPluginHandler(const char* base, const char* regexp, const char* className, const char* pluginName, const char* ctor, const char* origin). TPluginHandler& operator=(const TPluginHandler& ). const char * GetBase() const; { return fBase; }. const char * GetRegexp() const; { return fRegexp; }. const char * GetPlugin() const; { return fPlugin; }. const char * GetCtor() const; { return fCtor; }. const char * GetOrigin() const; { return fOrigin; }. const char * GetClass() const; { return fClass; }. » Author: Fons Rademakers 26/1/2002 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TPluginHandler.html:10560,Load,LoadPlugin,10560,root/html602/TPluginHandler.html,https://root.cern,https://root.cern/root/html602/TPluginHandler.html,4,['Load'],"['Load', 'LoadPlugin']"
Performance,"ol_t ProcessEvents ();  Process pending events (GUI, timers, sockets). ;  ; const char * pwd ();  ; void RemoveOnExit (TObject *obj);  Objects that should be deleted on exit of the OS interface. ;  ; virtual TStdExceptionHandler * RemoveStdExceptionHandler (TStdExceptionHandler *eh);  Remove an exception handler from list of exception handlers. ;  ; virtual void Run ();  System event loop. ;  ; virtual void SetAclicMode (EAclicMode mode);  AclicMode indicates whether the library should be built in debug mode or optimized. ;  ; virtual void SetBuildDir (const char *build_dir, Bool_t isflat=kFALSE);  Set the location where ACLiC will create libraries and use as a scratch area. ;  ; void SetErrorStr (const char *errstr);  Set the system error string. ;  ; virtual void SetFlagsDebug (const char *);  FlagsDebug should contain the options to pass to the C++ compiler in order to compile the library in debug mode. ;  ; virtual void SetFlagsOpt (const char *);  FlagsOpt should contain the options to pass to the C++ compiler in order to compile the library in optimized mode. ;  ; virtual void SetIncludePath (const char *includePath);  IncludePath should contain the list of compiler flags to indicate where to find user defined header files. ;  ; virtual void SetLinkdefSuffix (const char *suffix);  The 'suffix' will be appended to the name of a script loaded by ACLiC and used to locate any eventual additional linkdef information that ACLiC should used to produce the dictionary. ;  ; virtual void SetLinkedLibs (const char *linkedLibs);  LinkedLibs should contain the library directory and list of libraries needed to recreate the current executable. ;  ; virtual void SetMakeExe (const char *directives);  Directives has the same syntax as the argument of SetMakeSharedLib but is used to create an executable. ;  ; virtual void SetMakeSharedLib (const char *directives);  Directives should contain the description on how to compile and link a shared lib. ;  ; virtual void SetObjExt (con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMacOSXSystem.html:19038,optimiz,optimized,19038,doc/master/classTMacOSXSystem.html,https://root.cern,https://root.cern/doc/master/classTMacOSXSystem.html,2,['optimiz'],['optimized']
Performance,"olation between pdf shapes using the 'Alex Read' algorithm . ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooGaussian.h""; #include ""RooPolynomial.h""; #include ""RooIntegralMorph.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""RooPlot.h""; #include ""TH1.h""; using namespace RooFit;; ; void rf705_linearmorph(); {; // C r e a t e e n d p o i n t p d f s h a p e s; // ------------------------------------------------------; ; // Observable; RooRealVar x(""x"", ""x"", -20, 20);; ; // Lower end point shape: a Gaussian; RooRealVar g1mean(""g1mean"", ""g1mean"", -10);; RooGaussian g1(""g1"", ""g1"", x, g1mean, 2.0);; ; // Upper end point shape: a Polynomial; RooPolynomial g2(""g2"", ""g2"", x, RooArgSet(-0.03, -0.001));; ; // C r e a t e i n t e r p o l a t i n g p d f; // -----------------------------------------------; ; // Create interpolation variable; RooRealVar alpha(""alpha"", ""alpha"", 0, 1.0);; ; // Specify sampling density on observable and interpolation variable; x.setBins(1000, ""cache"");; alpha.setBins(50, ""cache"");; ; // Construct interpolating pdf in (x,a) represent g1(x) at a=a_min; // and g2(x) at a=a_max; RooIntegralMorph lmorph(""lmorph"", ""lmorph"", g1, g2, x, alpha);; ; // P l o t i n t e r p o l a t i n g p d f a t v a r i o u s a l p h a; // -----------------------------------------------------------------------------; ; // Show end points as blue curves; RooPlot *frame1 = x.frame();; g1.plotOn(frame1);; g2.plotOn(frame1);; ; // Show interpolated shapes in red; alpha.setVal(0.125);; lmorph.plotOn(frame1, LineColor(kRed));; alpha.setVal(0.25);; lmorph.plotOn(frame1, LineColor(kRed));; alpha.setVal(0.375);; lmorph.plotOn(frame1, LineColor(kRed));; alpha.setVal(0.50);; lmorph.plotOn(frame1, LineColor(kRed));; alpha.setVal(0.625);; lmorph.plotOn(frame1, LineColor(kRed));; alpha.setVal(0.75);; lmorph.plotOn(frame1, LineColor(kRed));; alpha.setVal(0.875);; lmorph.plotOn(frame1, LineColor(kRed));; alpha.setVal(0.95);; lmorph.plotOn(frame1, LineColor(kRed));; ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf705__linearmorph_8C.html:1256,cache,cache,1256,doc/master/rf705__linearmorph_8C.html,https://root.cern,https://root.cern/doc/master/rf705__linearmorph_8C.html,1,['cache'],['cache']
Performance,"old value which the user must set (TMultiDimFit::SetMinAngle). Figure 1: (a) angle \f$\theta\f$ between \f$\textbf{w}_l\f$ and \f$\textbf{f}_L\f$, (b) angle \f$ \phi \f$ between \f$\textbf{w}_L\f$ and \f$\textbf{D}\f$. Test 2; Let \(\textbf{D}\) be the data vector to be fitted. As illustrated in figure 1, the \(L^{\mbox{th}}\) function \(\textbf{w}_L\) will contribute significantly to the reduction of \( S\), if the angle \(\phi^\prime\) between \(\textbf{w}_L\) and \(\textbf{D}\) is smaller than an upper limit \( \phi \), defined by the user (MultiDimFit::SetMaxAngle); However, the method automatically readjusts the value of this angle while fitting is in progress, in order to make the selection criteria less and less difficult to be fulfilled. The result is that the functions contributing most to the reduction of \( S\) are chosen first (TMultiDimFit::TestFunction).; In case \( \phi \) isn't defined, an alternative method of performing this second test is used: The \(L^{\mbox{th}}\) function \(\textbf{f}_L\) is accepted if (refer also to equation (13)) ; \[; \Delta S_L > \frac{S_{L-1}}{L_{max}-L}; \]. where \( S_{L-1}\) is the sum of the \( L-1\) first residuals from the \( L-1\) functions previously accepted; and \( L_{max}\) is the total number of functions allowed in the final expression of the fit (defined by user).; From this we see, that by restricting \( L_{max}\) – the number of terms in the final model – the fit is more difficult to perform, since the above selection criteria is more limiting.; The more coefficients we evaluate, the more the sum of squares of residuals \( S\) will be reduced. We can evaluate \( S\) before inverting \(\mathsf{B}\) as shown below. Coefficients and Coefficient Errors; Having found a parameterization, that is the \( F_l\)'s and \( L\), that minimizes \( S\), we still need to determine the coefficients \( c_l\). However, it's a feature of how we choose the significant functions, that the evaluation of the \( c_l\)'s becomes tr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMultiDimFit.html:11046,perform,performing,11046,doc/master/classTMultiDimFit.html,https://root.cern,https://root.cern/doc/master/classTMultiDimFit.html,1,['perform'],['performing']
Performance,"olicy:; ROOT.SetMemoryPolicy( ROOT.kMemoryHeuristics ); Care must be taken in the case of graphic objects: when drawn on the current pad, a reference to the graphics is kept that PyROOT isn’t currently aware of, and it is up to the developer to keep at lease one Python reference alive. See $ROOTSYS/tutorials/pyroot/zdemo.py (available in the latest release) for an example. Alternatively, one can tell python to give up ownership for individual instances:; o = ROOT.TObject(); ROOT.SetOwnership( o, False ) # True to own, False to release; 19.1.6.2 Memory Management by Hand; If needed, you can explicitly destroy a ROOT object that you own through its associated TClass:; myobject.IsA().Destructor(myobject); which will send out the deletion notification to the system (thus you do not need to care anymore at this point about Python reference counting, the object will go, even if it’s reference count it non-zero), and free the memory.; 19.1.7 Performance; The performance of PyROOT when programming with ROOT in Python is similar to that of Cling. Differences occur mainly because of differences in the respective languages: C++ is much harder to parse, but once parsed, it is much easier to optimize. Consequently, individual calls to ROOT are typically faster from PyROOT, whereas loops are typically slower.; When programming in Python, the modus operandi is to consider performance generally “good enough” on the outset, and when it turns out that, it is not good enough; the performance critical part is converted into C/C++ in an extension module. The school of thought where pre-mature optimization is the root of all evil should find this way of working very satisfying. In addition, if you look at their history, you will see that many of the standard Python modules have followed this path.; Your code should always make maximum use of ROOT facilities; such that most of the time is spending in compiled code. This goes even for very simple things: e.g. do not compute invariant masse",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1062764,perform,performance,1062764,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,3,"['Perform', 'perform']","['Performance', 'performance']"
Performance,"ollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. Int_t_arrSizeSize of the weight array; Bool_t*_binValid! Valid bins with current range definition; Double_t*_binv[_arrSize] Bin volume array ; TIterator*RooAbsData::_cacheIter! Iterator over cached variables; RooArgSetRooAbsData::_cachedVars! External variables cached with this data set; Int_t_curIndexCurrent index; Double_t_curSumW2Current sum of weights^2; Double_t_curVolumeVolume of bin enclosing current coordinate; Double_t_curWeightWeight associated with the current coordinate; Double_t_curWgtErrHiError on weight associated with the current coordinate; Double_t_curWgtErrLoError on weight associated with the current coordinate; TDirectory*RooDirItem::_dir! Associated directory; RooAbsDataStore*RooAbsData::_dstoreData storage implementation; Double_t*_errHi[_arrSize] High-side error on weight array; Double_t*_errLo[_arrSize] Low-side error on weight array; vector<Int_t>_idxMultMultiplier jump table for index calculation; TIterator*RooAbsData::_iterator! Iterator over dimension variables; list<const RooAbsBinning*>_lvbins! List of used binnings associated with lvalues; list<RooAbsLValue*>_lvvars! List of observables casted as RooAbsLValue; static Int_tRooPrintable::_nameLength; map<std::string,RooAbsData*>RooAbsData::_ownedComponentsOwned external components; vector<Double_t>*_pbinv! Partial bin volume array; RooCacheManager<std::vector<Double_t> >_pbinvCacheMgr! Cache manager for arrays of partial bin volumes; TIterator*_realIter! Iterator over realVars; RooArgSet_realVarsReal dimensions of the dataset ; Double_t*_sumw2[_arrSize] Sum of weights^2; RooArgSetRooAbsData::_varsDimensions of this data set; Double_t*_wgt[_arrSize] Weight array; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooDataHist(); Default constructor. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooDataHist.html:17211,cache,cached,17211,root/html530/RooDataHist.html,https://root.cern,https://root.cern/root/html530/RooDataHist.html,2,['cache'],['cached']
Performance,"ollectionProxy::kIsAssociative) {; 5825 fFillLeaves = (FillLeaves_t)&TBranchElement::FillLeavesAssociativeCollectionMember;; 5826 } else {; 5827 fFillLeaves = (FillLeaves_t)&TBranchElement::FillLeavesCollectionMember;; 5828 }; 5829 } else if (fType == 3) {; 5830 fFillLeaves = (FillLeaves_t)&TBranchElement::FillLeavesClones;; 5831 } else if (fType == 31) {; 5832 fFillLeaves = (FillLeaves_t)&TBranchElement::FillLeavesClonesMember;; 5833 } else if (fType < 0) {; 5834 fFillLeaves = (FillLeaves_t)&TBranchElement::FillLeavesCustomStreamer;; 5835 } else if (fType <=2) {; 5836 //split-class branch, base class branch, data member branch, or top-level branch.; 5837 if (fBranchCount) {; 5838 fFillLeaves = (FillLeaves_t)&TBranchElement::FillLeavesMemberBranchCount;; 5839 } else if (fStreamerType == TVirtualStreamerInfo::kCounter) {; 5840 fFillLeaves = (FillLeaves_t)&TBranchElement::FillLeavesMemberCounter;; 5841 } else {; 5842 fFillLeaves = (FillLeaves_t)&TBranchElement::FillLeavesMember;; 5843 }; 5844 } else {; 5845 Fatal(""SetFillLeavePtr"",""Unexpected branch type %d for %s"",fType,GetName());; 5846 }; 5847 ; 5848 SetFillActionSequence();; 5849}; 5850 ; 5851////////////////////////////////////////////////////////////////////////////////; 5852/// Set the name of the class of the in-memory object into which the data will; 5853/// loaded.; 5854 ; 5855void TBranchElement::SetTargetClass(const char *name); 5856{; 5857 if (name == nullptr) return;; 5858 ; 5859 if (strcmp(fTargetClass.GetClassName(),name) != 0 ); 5860 {; 5861 // We are changing target class, let's reset the meta information and; 5862 // the sub-branches.; 5863 ; 5864 ResetInitInfo(/*recurse=*/ false);; 5865 ; 5866 Int_t nbranches = fBranches.GetEntriesFast();; 5867 for (Int_t i = 0; i < nbranches; ++i) {; 5868 TBranchElement *sub = (TBranchElement*) fBranches[i];; 5869 ; 5870 if (sub->fTargetClass == fTargetClass ) {; 5871 sub->SetTargetClass(name);; 5872 } else {; 5873 // Since the top level changes, the StreamerInfo (",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBranchElement_8cxx_source.html:219478,load,loaded,219478,doc/master/TBranchElement_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html,1,['load'],['loaded']
Performance,"ollectionProxy__StagingCreateIterators;; 1632 else; 1633 return fFunctionCreateIterators = TGenCollectionProxy__SlowCreateIterators;; 1634}; 1635 ; 1636////////////////////////////////////////////////////////////////////////////////; 1637/// See typedef void (*CopyIterator_t)(void *&dest, const void *source);; 1638/// Copy the iterator source, into dest. dest should contain should contain the location of memory arena of size fgIteratorSize.; 1639/// If the collection iterator are of that size or less, the iterator will be constructed in place in this location (new with placement); 1640/// Otherwise the iterator will be allocated via a regular new and its address returned by modifying the value of dest.; 1641 ; 1642TVirtualCollectionProxy::CopyIterator_t TGenCollectionProxy::GetFunctionCopyIterator(Bool_t read); 1643{; 1644 if (read) {; 1645 if ( !fValue.load(std::memory_order_relaxed) ) InitializeEx(kFALSE);; 1646 if ( (fProperties & kIsAssociative) && read); 1647 return TGenCollectionProxy__StagingCopyIterator;; 1648 }; 1649 ; 1650 if ( fFunctionCopyIterator ) return fFunctionCopyIterator;; 1651 ; 1652 if ( !fValue.load(std::memory_order_relaxed) ) InitializeEx(kFALSE);; 1653 ; 1654 // TODO can we do better than the default for RVec?; 1655 if (fSTL_type==ROOT::kSTLvector || (fProperties & kIsEmulated)); 1656 return fFunctionCopyIterator = TGenCollectionProxy__VectorCopyIterator;; 1657 else if ( (fProperties & kIsAssociative) && read); 1658 return TGenCollectionProxy__StagingCopyIterator;; 1659 else; 1660 return fFunctionCopyIterator = TGenCollectionProxy__SlowCopyIterator;; 1661}; 1662 ; 1663////////////////////////////////////////////////////////////////////////////////; 1664/// See typedef void* (*Next_t)(void *iter, void *end);; 1665/// iter and end should be pointer to respectively an iterator to be incremented and the result of colleciton.end(); 1666/// 'Next' will increment the iterator 'iter' and return 0 if the iterator reached the end.; 1667/// If the end ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:53991,load,load,53991,doc/master/TGenCollectionProxy_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html,1,['load'],['load']
Performance,"olling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; static RooRealVarSharedProperties_nullPropNull property; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; static Bool_t_printScientific; static Int_t_printSigDigits; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooRealVarSharedProperties*_sharedProp! Shared properties associated with this instance; static RooSharedPropertiesList_sharedPropListList of properties shared among clone sets ; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooRealVar.html:38826,cache,cache,38826,root/html530/RooRealVar.html,https://root.cern,https://root.cern/root/html530/RooRealVar.html,1,['cache'],['cache']
Performance,"ollowing info; 1805/// - 1D : bc,e,xc,xw (bin content, error, x of center of bin, x bin width of bin); 1806/// - 2D : bc,e,xc,xw,yc,yw; 1807/// - 3D : bc,e,xc,xw,yc,yw,zc,zw; 1808 ; 1809void TFumili::FitChisquareI(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag); 1810{; 1811 Double_t cu,eu,fu,fsum;; 1812 Double_t x[3];; 1813 Double_t *zik=nullptr;; 1814 Double_t *pl0=nullptr;; 1815 ; 1816 TH1 *hfit = (TH1*)GetObjectFit();; 1817 TF1 *f1 = (TF1*)GetUserFunc();; 1818 Int_t nd = hfit->GetDimension();; 1819 Int_t j;; 1820 ; 1821 f1->InitArgs(x,u);; 1822 npar = f1->GetNpar();; 1823 SetParNumber(npar);; 1824 if(flag == 9) return;; 1825 zik = GetZ();; 1826 pl0 = GetPL0();; 1827 ; 1828 Double_t *df=new Double_t[npar];; 1829 f = 0;; 1830 ; 1831 Int_t npfit = 0;; 1832 Double_t *cache = fCache;; 1833 for (Int_t i=0;i<fNpoints;i++) {; 1834 cu = cache[0];; 1835 TF1::RejectPoint(kFALSE);; 1836 f1->SetParameters(u);; 1837 if (nd < 2) {; 1838 fu = f1->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3])/cache[3];; 1839 } else if (nd < 3) {; 1840 fu = ((TF2*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5])/(cache[3]*cache[5]);; 1841 } else {; 1842 fu = ((TF3*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5],cache[6] - 0.5*cache[7],cache[6] + 0.5*cache[7])/(cache[3]*cache[5]*cache[7]);; 1843 }; 1844 if (TF1::RejectedPoint()) {cache += fPointSize; continue;}; 1845 eu = cache[1];; 1846 Derivatives(df,x);; 1847 Int_t n = 0;; 1848 fsum = (fu-cu)/eu;; 1849 if (flag!=1) {; 1850 for (j=0;j<npar;j++) {; 1851 if (pl0[j]>0){; 1852 df[n] = df[j]/eu;; 1853 // left only non-fixed param derivatives / by Sigma; 1854 gin[j] += df[n]*fsum;; 1855 n++;; 1856 }; 1857 }; 1858 Int_t l = 0;; 1859 for (j=0;j<n;j++); 1860 for (Int_t k=0;k<=j;k++); 1861 zik[l++] += df[j]*df[k];; 1862 }; 1863 f += .5*fsum*fsum;; 1864 npfit++;; 1865 cache += fPointSize;; 1866 }; 1867 f1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFumili_8cxx_source.html:52592,cache,cache,52592,doc/master/TFumili_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html,2,['cache'],['cache']
Performance,"olorStruct_t * ; p). protected . Check to see if the given color is too light to be easily distinguished from white. ; Definition at line 1725 of file TGHtml.cxx. ◆ IsVisited(). virtual int TGHtml::IsVisited ; (; const char * ; ). inlinevirtual . Definition at line 924 of file TGHtml.h. ◆ ItemLayout(). Bool_t TGHtml::ItemLayout ; (; ). overridevirtual . Layout html widget. ; Reimplemented from TGView.; Definition at line 834 of file TGHtml.cxx. ◆ LayoutDoc(). void TGHtml::LayoutDoc ; (; ). protected . Advance the layout as far as possible. ; Definition at line 1178 of file TGHtmlLayout.cxx. ◆ ListTokens(). TGString * TGHtml::ListTokens ; (; TGHtmlElement * ; p, . TGHtmlElement * ; pEnd . ). Return all tokens between the two elements as a string list. ; Definition at line 1454 of file TGHtmlParse.cxx. ◆ LoadImage(). TImage * TGHtml::LoadImage ; (; const char * ; url, . int ; w = 0, . int ; h = 0 . ). virtual . This is the default LoadImage() procedure. ; It just tries to load the image from a file in the local filesystem. ; Definition at line 292 of file TGHtmlImage.cxx. ◆ LostSelection(). void TGHtml::LostSelection ; (; ). protected . Clear selection. ; Definition at line 2027 of file TGHtml.cxx. ◆ MakeInvisible(). void TGHtml::MakeInvisible ; (; TGHtmlElement * ; p_first, . TGHtmlElement * ; p_last . ). protected . Add the STY_Invisible style to every token between p_first and p_last. ; Definition at line 144 of file TGHtmlSizer.cxx. ◆ MakeMarkupEntry(). TGHtmlMarkupElement * TGHtml::MakeMarkupEntry ; (; int ; objType, . int ; type, . int ; argc, . int ; arglen[], . char * ; argv[] . ). protected . Make one markup entry. ; Definition at line 1006 of file TGHtmlParse.cxx. ◆ MapControls(). int TGHtml::MapControls ; (; ). protected . Map any control that should be visible according to the current scroll position. ; At the same time, if any controls that should not be visible are mapped, unmap them. After this routine finishes, all <INPUT> controls should be in their pr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGHtml.html:76430,load,load,76430,doc/master/classTGHtml.html,https://root.cern,https://root.cern/doc/master/classTGHtml.html,1,['load'],['load']
Performance,"ols which can produce both RooStats HypoTestResults and ConfIntervals ;  CConfidenceBeltConfidenceBelt is a concrete implementation of the ConfInterval interface ;  CConfIntervalConfInterval is an interface class for a generic interval in the RooStats framework ;  CDebuggingSampler;  CDebuggingTestStat;  CDetailedOutputAggregator;  CFeldmanCousins(like the Feldman-Cousins technique) is essentially a specific configuration of the more general NeymanConstruction ;  CFrequentistCalculatorHypothesis Test Calculator using a full frequentist procedure for sampling the test statistic distribution ;  CHeavisideRepresents the Heaviside function ;  CHLFactoryHLFactory is an High Level model Factory allows you to describe your models in a configuration file (datacards) acting as an interface with the RooFactoryWSTool ;  CHybridCalculatorThis class implements the Hypothesis test calculation using an hybrid (frequentist/bayesian) procedure ;  CHybridCalculatorOriginalHybridCalculatorOriginal class ;  CHybridPlotThis class provides the plots for the result of a study performed with the HybridCalculatorOriginal class ;  CHybridResult;  CHypoTestCalculatorHypoTestCalculator is an interface class for a tools which produce RooStats HypoTestResults ;  CHypoTestCalculatorGenericCommon base class for the Hypothesis Test Calculators ;  CHypoTestInverterHypoTestInverter class for performing an hypothesis test inversion by scanning the hypothesis test results of an HypoTestCalculator for various values of the parameter of interest ;  CHypoTestInverterOriginalThis class is now depratcated and to be replaced by the HypoTestInverter ;  CHypoTestInverterPlotClass to plot an HypoTestInverterResult, result of the HypoTestInverter calculator ;  CHypoTestInverterResultHypoTestInverterResult class: holds the array of hypothesis test results and compute a confidence interval ;  CHypoTestPlotThis class provides the plots for the result of a study performed with any of the HypoTestCalculatorGeneric (e.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/annotated.html:4823,perform,performed,4823,doc/v608/annotated.html,https://root.cern,https://root.cern/doc/v608/annotated.html,9,['perform'],"['performed', 'performing']"
Performance,"olumn as array of collection sizes.Definition RNTupleUtil.hxx:32; These projections are meta-data only operations and don't involve duplicating the data. Current limitations of the importer:; No support for trees containing TClonesArray collections; Due to RNTuple currently storing data fully split, ""don't split"" markers are ignored; Some types are not available in RNTuple. Please refer to the RNTuple specification for an overview of all types currently supported. . Definition at line 103 of file RNTupleImporter.hxx. Classes; struct  RCStringTransformation;  Transform a NULL terminated C string branch into an std::string field. More...;  ; struct  RImportBranch;  ; struct  RImportField;  ; struct  RImportGuard;  When the schema is set up and the import started, it needs to be reset before the next Import() call can start. More...;  ; struct  RImportLeafCountCollection;  Leaf count arrays require special treatment. More...;  ; struct  RImportTransformation;  Base class to perform data transformations from TTree branches to RNTuple fields if necessary. More...;  ; class  RProgressCallback;  Used to report every ~100 MB (compressed), and at the end about the status of the import. More...;  . Public Types; using FieldModifier_t = std::function< void(RFieldBase &)>;  Used to make adjustments to the fields of the output model. ;  . Public Member Functions;  RNTupleImporter (const RNTupleImporter &other)=delete;  ;  RNTupleImporter (RNTupleImporter &&other)=delete;  ;  ~RNTupleImporter ()=default;  ; RNTupleWriteOptions GetWriteOptions () const;  ; void Import ();  Import works in two steps: ;  ; RNTupleImporter & operator= (const RNTupleImporter &other)=delete;  ; RNTupleImporter & operator= (RNTupleImporter &&other)=delete;  ; void SetConvertDotsInBranchNames (bool value);  Whereas branch names may contain dots, RNTuple field names may not. ;  ; void SetFieldModifier (FieldModifier_t modifier);  Add custom method to adjust column representations. ;  ; void SetIsQuiet (boo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RNTupleImporter.html:3972,perform,perform,3972,doc/master/classROOT_1_1Experimental_1_1RNTupleImporter.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RNTupleImporter.html,1,['perform'],['perform']
Performance,"olumn(). virtual RooAbsArg * RooAbsDataStore::addColumn ; (; RooAbsArg & ; var, . bool ; adjustRange = true . ). pure virtual . Implemented in RooCompositeDataStore, RooTreeDataStore, and RooVectorDataStore. ◆ addColumns(). RooArgSet * RooAbsDataStore::addColumns ; (; const RooArgList & ; varList). Definition at line 60 of file RooAbsDataStore.cxx. ◆ append(). virtual void RooAbsDataStore::append ; (; RooAbsDataStore & ; other). pure virtual . Implemented in RooCompositeDataStore, RooTreeDataStore, and RooVectorDataStore. ◆ attachBuffers(). virtual void RooAbsDataStore::attachBuffers ; (; const RooArgSet & ; extObs). pure virtual . Implemented in RooCompositeDataStore, RooTreeDataStore, and RooVectorDataStore. ◆ attachCache(). virtual void RooAbsDataStore::attachCache ; (; const RooAbsArg * ; newOwner, . const RooArgSet & ; cachedVars . ). pure virtual . Implemented in RooCompositeDataStore, RooTreeDataStore, and RooVectorDataStore. ◆ cacheArgs(). virtual void RooAbsDataStore::cacheArgs ; (; const RooAbsArg * ; cacheOwner, . RooArgSet & ; varSet, . const RooArgSet * ; nset = nullptr, . bool ; skipZeroWeights = false . ). pure virtual . Implemented in RooCompositeDataStore, RooTreeDataStore, and RooVectorDataStore. ◆ cachedVars(). const RooArgSet & RooAbsDataStore::cachedVars ; (; ); const. inline . Definition at line 130 of file RooAbsDataStore.h. ◆ cacheOwner(). virtual const RooAbsArg * RooAbsDataStore::cacheOwner ; (; ). pure virtual . Implemented in RooCompositeDataStore, RooTreeDataStore, and RooVectorDataStore. ◆ changeObservableName(). virtual bool RooAbsDataStore::changeObservableName ; (; const char * ; from, . const char * ; to . ). pure virtual . Implemented in RooCompositeDataStore, RooTreeDataStore, and RooVectorDataStore. ◆ checkInit(). virtual void RooAbsDataStore::checkInit ; (; ); const. inlinevirtual . Reimplemented in RooTreeDataStore.; Definition at line 137 of file RooAbsDataStore.h. ◆ Class(). static TClass * RooAbsDataStore::Class ; (; ). stati",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsDataStore.html:18973,cache,cacheArgs,18973,doc/master/classRooAbsDataStore.html,https://root.cern,https://root.cern/doc/master/classRooAbsDataStore.html,2,['cache'],"['cacheArgs', 'cacheOwner']"
Performance,"olumnNames() | Get the names of all the defined columns. |; 162| GetFilterNames() | Return the names of all filters in the computation graph. |; 163| GetNRuns() | Return the number of event loops run by this RDataFrame instance so far. |; 164| GetNSlots() | Return the number of processing slots that RDataFrame will use during the event loop (i.e. the concurrency level). |; 165| SaveGraph() | Store the computation graph of an RDataFrame in [DOT format (graphviz)](https://en.wikipedia.org/wiki/DOT_(graph_description_language)) for easy inspection. See the [relevant section](\ref representgraph) for details. |; 166 ; 167\anchor introduction; 168## Introduction; 169Users define their analysis as a sequence of operations to be performed on the dataframe object; the framework; 170takes care of the management of the loop over entries as well as low-level details such as I/O and parallelization.; 171RDataFrame provides methods to perform most common operations required by ROOT analyses;; 172at the same time, users can just as easily specify custom code that will be executed in the event loop.; 173 ; 174RDataFrame is built with a *modular* and *flexible* workflow in mind, summarised as follows:; 175 ; 1761. Construct a dataframe object by specifying a dataset. RDataFrame supports TTree as well as TChain, [CSV files](https://root.cern/doc/master/df014__CSVDataSource_8C.html), [SQLite files](https://root.cern/doc/master/df027__SQliteDependencyOverVersion_8C.html), [RNTuples](https://root.cern/doc/master/structROOT_1_1Experimental_1_1RNTuple.html), and it can be extended to custom data formats. From Python, [NumPy arrays can be imported into RDataFrame](https://root.cern/doc/master/df032__MakeNumpyDataFrame_8py.html) as well.; 177 ; 1782. Transform the dataframe by:; 179 ; 180 - [Applying filters](https://root.cern/doc/master/classROOT_1_1RDataFrame.html#transformations). This selects only specific rows of the dataset.; 181 ; 182 - [Creating custom columns](https://root.cern/doc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RDataFrame_8cxx_source.html:12979,perform,perform,12979,doc/v632/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/RDataFrame_8cxx_source.html,1,['perform'],['perform']
Performance,"olumnNames() | Get the names of all the defined columns. |; 166| GetFilterNames() | Return the names of all filters in the computation graph. |; 167| GetNRuns() | Return the number of event loops run by this RDataFrame instance so far. |; 168| GetNSlots() | Return the number of processing slots that RDataFrame will use during the event loop (i.e. the concurrency level). |; 169| SaveGraph() | Store the computation graph of an RDataFrame in [DOT format (graphviz)](https://en.wikipedia.org/wiki/DOT_(graph_description_language)) for easy inspection. See the [relevant section](\ref representgraph) for details. |; 170 ; 171\anchor introduction; 172## Introduction; 173Users define their analysis as a sequence of operations to be performed on the dataframe object; the framework; 174takes care of the management of the loop over entries as well as low-level details such as I/O and parallelization.; 175RDataFrame provides methods to perform most common operations required by ROOT analyses;; 176at the same time, users can just as easily specify custom code that will be executed in the event loop.; 177 ; 178RDataFrame is built with a *modular* and *flexible* workflow in mind, summarised as follows:; 179 ; 1801. Construct a dataframe object by specifying a dataset. RDataFrame supports TTree as well as TChain, [CSV files](https://root.cern/doc/master/df014__CSVDataSource_8C.html), [SQLite files](https://root.cern/doc/master/df027__SQliteDependencyOverVersion_8C.html), [RNTuples](https://root.cern/doc/master/structROOT_1_1Experimental_1_1RNTuple.html), and it can be extended to custom data formats. From Python, [NumPy arrays can be imported into RDataFrame](https://root.cern/doc/master/df032__MakeNumpyDataFrame_8py.html) as well.; 181 ; 1822. Transform the dataframe by:; 183 ; 184 - [Applying filters](https://root.cern/doc/master/classROOT_1_1RDataFrame.html#transformations). This selects only specific rows of the dataset.; 185 ; 186 - [Creating custom columns](https://root.cern/doc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDataFrame_8cxx_source.html:13421,perform,perform,13421,doc/master/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RDataFrame_8cxx_source.html,1,['perform'],['perform']
Performance,"olutionModel.; Definition at line 419 of file RooAbsPdf.cxx. ◆ getNormIntegral(). const RooAbsReal * RooAbsPdf::getNormIntegral ; (; const RooArgSet & ; nset); const. inline . Definition at line 255 of file RooAbsPdf.h. ◆ getNormObj(). const RooAbsReal * RooAbsPdf::getNormObj ; (; const RooArgSet * ; set, . const RooArgSet * ; iset, . const TNamed * ; rangeName = nullptr . ); const. virtual . Return pointer to RooAbsReal object that implements calculation of integral over observables iset in range rangeName, optionally taking the integrand normalized over observables nset. ; Definition at line 443 of file RooAbsPdf.cxx. ◆ getValV(). double RooAbsPdf::getValV ; (; const RooArgSet * ; nset = nullptr); const. overridevirtual . Return current value, normalized by integrating over the observables in nset. ; If nset is 0, the unnormalized value is returned. All elements of nset must be lvalues.; Unnormalized values are not cached. Doing so would be complicated as _norm->getVal() could spoil the cache and interfere with returning the cached return value. Since unnormalized calls are typically done in integration calls, there is no performance hit. ; Reimplemented from RooAbsReal.; Reimplemented in RooNormalizedPdf, RooResolutionModel, RooMomentMorph, and RooAddPdf.; Definition at line 319 of file RooAbsPdf.cxx. ◆ initGenerator(). void RooAbsPdf::initGenerator ; (; Int_t ; code). virtual . Interface for one-time initialization to setup the generator for the specified code. ; Reimplemented in RooBCPEffDecay, RooBCPGenDecay, RooBMixDecay, RooNonCPEigenDecay, RooBinSamplingPdf, RooMultiVarGaussian, RooProdPdf, and RooProjectedPdf.; Definition at line 1532 of file RooAbsPdf.cxx. ◆ IsA(). TClass * RooAbsPdf::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Reimplemented in RooArgusBG, RooBCPEffDecay, RooBCPGenDecay, RooBDecay, RooBernstein, RooBifurGauss, RooBMixDecay, RooBreitWigner, RooBukinPdf, RooCBShape, RooCFu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsPdf.html:130121,cache,cache,130121,doc/master/classRooAbsPdf.html,https://root.cern,https://root.cern/doc/master/classRooAbsPdf.html,2,['cache'],"['cache', 'cached']"
Performance,"om RooAbsData; RooArgSet _cachedVars;  ! External variables cached with this data set ;  ; std::unique_ptr< RooAbsDataStore > _dstore;  Data storage implementation. ;  ; std::unique_ptr< RooArgSet > _globalObservables;  Snapshot of global observables. ;  ; const TNamed * _namePtr = nullptr;  ! De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; std::map< std::string, RooAbsData * > _ownedComponents;  Owned external components. ;  ; RooArgSet _vars;  Dimensions of this data set. ;  ; StorageType storageType;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Protected Attributes inherited from RooDirItem; TDirectory * _dir {nullptr};  ! Associated directory ;  . Private Member Functions; void _adjustBinning (RooRealVar &theirVar, const TAxis &axis, RooRealVar *ourVar, Int_t *offset);  Helper doing the actual work of adjustBinning(). ;  ; VarInfo const & getVarInfo ();  Return reference to VarInfo struct with cached histogram variable information that is frequently used for histogram weights retrieval. ;  ; void initializeAsymErrArrays () const;  ; void interpolateLinear (double *output, std::span< const double > xVals, bool correctForBinSize, bool cdfBoundaries);  A vectorized version of interpolateDim for boundary safe linear interpolation of one dimensional histograms. ;  ; void interpolateQuadratic (double *output, std::span< const double > xVals, bool correctForBinSize, bool cdfBoundaries);  A vectorized version of interpolateDim for boundary safe quadratic interpolation of one dimensional histograms. ;  ; void registerWeightArraysToDataStore () const;  Hand over pointers to our weight arrays to the data store implementation. ;  ; double weightInterpolated (const RooArgSet &bin, int intOrder, bool correctForBinSize, bool cdfBoundaries);  Return the weight at given coordinates with interpolation. ;  . Static Private Member Functions; static std::unique_ptr< RooAbsDataStore > makeDefaultDataStor",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooDataHist.html:40337,cache,cached,40337,doc/master/classRooDataHist.html,https://root.cern,https://root.cern/doc/master/classRooDataHist.html,1,['cache'],['cached']
Performance,"om RooAbsPdf. ◆ StreamerNVirtual(). void RooAddPdf::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 153 of file RooAddPdf.h. ◆ translate(). void RooAddPdf::translate ; (; RooFit::Detail::CodeSquashContext & ; ctx); const. overridevirtual . This function defines a translation for each RooAbsReal based object that can be used to express the class as simple C++ code. ; The function adds the code represented by each class as an std::string (that is later concatenated with code strings from translate calls) to form the C++ code that AD tools can understand. Any class that wants to support AD, has to implement this function.; Parameters. [in]ctxAn object to manage auxiliary information for code-squashing. Also takes the code string that this class outputs into the squashed code through the 'addToCodeBody' function. . Reimplemented from RooAbsArg.; Definition at line 548 of file RooAddPdf.cxx. ◆ updateCoefficients(). void RooAddPdf::updateCoefficients ; (; AddCacheElem & ; cache, . const RooArgSet * ; nset, . bool ; syncCoefValues = true . ); const. protected . Update the coefficient values in the given cache element: calculate new remainder fraction, normalize fractions obtained from extended ML terms to unity, and multiply the various range and dimensional corrections needed in the current use context. ; param[in] cache The cache element for the given normalization set that stores the supplementary normalization values and projection-related objects. param[in] nset The set of variables to normalize over. param[in] syncCoefValues If the initial values of the coefficients still need to be copied from the _coefList elements to the _coefCache. True by default. ; Definition at line 442 of file RooAddPdf.cxx. Friends And Related Symbol Documentation. ◆ RooAddGenContext. friend class RooAddGenContext. friend . Definition at line 115 of file RooAddPdf.h. ◆ RooAddModel. friend class RooAddModel. friend . Definition at line 116 of file R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAddPdf.html:95343,cache,cache,95343,doc/v632/classRooAddPdf.html,https://root.cern,https://root.cern/doc/v632/classRooAddPdf.html,2,['cache'],['cache']
Performance,"om RooPrintable; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static std::ostream & defaultPrintStream (std::ostream *os=nullptr);  Return a reference to the current default stream to use in Print(). ;  ; static void nameFieldLength (Int_t newLen);  Set length of field reserved from printing name of RooAbsArgs in multi-line collection printing to given amount. ;  . Protected Member Functions; RooAbsCategory & dummyBlindState () const;  Return reference to internal dummy RooCategory implementation blinding state switch. ;  ; double getValV (const RooArgSet *nset=nullptr) const override;  Return value of object. ;  ;  Protected Member Functions inherited from RooAbsReal; void attachToTree (TTree &t, Int_t bufSize=32000) override;  Attach object to a branch of given TTree. ;  ; void attachToVStore (RooVectorDataStore &vstore) override;  ; void copyCache (const RooAbsArg *source, bool valueOnly=false, bool setValDirty=true) override;  Copy the cached value of another RooAbsArg to our cache. ;  ; RooFit::OwningPtr< RooAbsReal > createIntObj (const RooArgSet &iset, const RooArgSet *nset, const RooNumIntConfig *cfg, const char *rangeName) const;  Internal utility function for createIntegral() that creates the actual integral object. ;  ; virtual double evaluate () const =0;  Evaluate this PDF / function / constant. Needs to be overridden by all derived classes. ;  ; void fillTreeBranch (TTree &t) override;  Fill the tree branch that associated with this object with its current value. ;  ; void findInnerMostIntegration (const RooArgSet &allObs, RooArgSet &innerObs, const char *rangeName) const;  Utility function for createIntObj() that aids in the construct of recursive integrals over functions with multiple observables with parameterized ranges. ;  ; TString integralNameSuffix (const RooArgSet &iset, const RooArgSet *nset=nullptr, const char *rangeName=nullptr, bool",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsHiddenReal.html:49020,cache,cached,49020,doc/master/classRooAbsHiddenReal.html,https://root.cern,https://root.cern/doc/master/classRooAbsHiddenReal.html,2,['cache'],"['cache', 'cached']"
Performance,"om TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . #include <TRInterface.h>. Inheritance diagram for ROOT::R::TRInterface:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TRInterface(). TRInterface::TRInterface ; (; const Int_t ; argc = 0, . const Char_t * ; argv[] = NULL, . const Bool_t ; loadRcpp = true, . const Bool_t ; verbose = false, . const Bool_t ; interactive = true . ). private . The command line arguments are by default argc=0 and argv=NULL, The verbose mode is by default disabled but you can enable it to show procedures information in stdout/stderr. ; Notesome time can produce so much noise in the output ; Parameters. argcdefault 0 ; argvdefault null ; loadRcppdefault true ; verbosedefault false ; interactivedefault true . Definition at line 33 of file TRInterface.cxx. ◆ ~TRInterface(). TRInterface::~TRInterface ; (; ). Definition at line 71 of file TRInterface.cxx. Member Function Documentation. ◆ Assign() [1/3]. template<typename T > . void ROOT::R::TRInterface::Assign ; (; const T & ; var, . const TString & ; name . ). inline . Template method to assign C++ variables into R environment. ; Parameters. varany R wrappable datatype ; namename of the variable in R's environment . Definition at line 258 of file TRInterface.h. ◆ Assign() [2/3]. void TRInterface::Assign ; (; const TRDataFrame & ; df, . const TString & ; name . ). Method to assign TRDataFrame in R's environment. ; Parameters. dfTRDataFrame ; namename of the variable in R's environment . Definition at line 154 of file TRInterface.cxx. ◆ Assign() [3/3]. void TRInterface::Assign ; (; const TRFunctionExport & ; fun, . const TString & ; name . ). Method to assign TRFunctionExport in R's environm",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1R_1_1TRInterface.html:18797,load,loadRcppdefault,18797,doc/master/classROOT_1_1R_1_1TRInterface.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1R_1_1TRInterface.html,1,['load'],['loadRcppdefault']
Performance,"om other thread Normally should be invoked before Show() method is called. ; Definition at line 1645 of file RWebWindow.cxx. ◆ CanSend(). bool RWebWindow::CanSend ; (; unsigned ; connid, . bool ; direct = true . ); const. Returns true if sending via specified connection can be performed. ; Parameters. connidconnection id, when 0 - all existing connections are checked ; directwhen true, checks if direct sending (without queuing) is possible . Definition at line 1484 of file RWebWindow.cxx. ◆ CheckDataToSend() [1/2]. void RWebWindow::CheckDataToSend ; (; bool ; only_once = false). private . Checks if new data can be send (internal use only) If necessary, provide credits to the client. ; Parameters. only_onceif true, data sending performed once or until there is no data to send . Definition at line 1216 of file RWebWindow.cxx. ◆ CheckDataToSend() [2/2]. bool RWebWindow::CheckDataToSend ; (; std::shared_ptr< WebConn > & ; conn). private . Checks if one should send data for specified connection Returns true when send operation was performed. ; Definition at line 1158 of file RWebWindow.cxx. ◆ CheckInactiveConnections(). void RWebWindow::CheckInactiveConnections ; (; ). private . Check if there are connection which are inactive for longer time For instance, batch browser will be stopped if no activity for 30 sec is there. ; Definition at line 658 of file RWebWindow.cxx. ◆ CheckPendingConnections(). void RWebWindow::CheckPendingConnections ; (; ). private . Check if started process(es) establish connection. ; After timeout such processed will be killed Method invoked from http server thread, therefore appropriate mutex must be used on all relevant data ; Definition at line 624 of file RWebWindow.cxx. ◆ CloseConnection(). void RWebWindow::CloseConnection ; (; unsigned ; connid). Close specified connection. ; Parameters. connidconnection id, when 0 - all connections will be closed . Definition at line 1447 of file RWebWindow.cxx. ◆ CloseConnections(). void RWebWindow::CloseC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RWebWindow.html:26102,perform,performed,26102,doc/v632/classROOT_1_1RWebWindow.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RWebWindow.html,1,['perform'],['performed']
Performance,"om other thread Normally should be invoked before Show() method is called. ; Definition at line 1687 of file RWebWindow.cxx. ◆ CanSend(). bool RWebWindow::CanSend ; (; unsigned ; connid, . bool ; direct = true . ); const. Returns true if sending via specified connection can be performed. ; Parameters. connidconnection id, when 0 - all existing connections are checked ; directwhen true, checks if direct sending (without queuing) is possible . Definition at line 1526 of file RWebWindow.cxx. ◆ CheckDataToSend() [1/2]. void RWebWindow::CheckDataToSend ; (; bool ; only_once = false). private . Checks if new data can be send (internal use only) If necessary, provide credits to the client. ; Parameters. only_onceif true, data sending performed once or until there is no data to send . Definition at line 1249 of file RWebWindow.cxx. ◆ CheckDataToSend() [2/2]. bool RWebWindow::CheckDataToSend ; (; std::shared_ptr< WebConn > & ; conn). private . Checks if one should send data for specified connection Returns true when send operation was performed. ; Definition at line 1191 of file RWebWindow.cxx. ◆ CheckInactiveConnections(). void RWebWindow::CheckInactiveConnections ; (; ). private . Check if there are connection which are inactive for longer time For instance, batch browser will be stopped if no activity for 30 sec is there. ; Definition at line 659 of file RWebWindow.cxx. ◆ CheckPendingConnections(). void RWebWindow::CheckPendingConnections ; (; ). private . Check if started process(es) establish connection. ; After timeout such processed will be killed Method invoked from http server thread, therefore appropriate mutex must be used on all relevant data ; Definition at line 625 of file RWebWindow.cxx. ◆ CloseConnection(). void RWebWindow::CloseConnection ; (; unsigned ; connid). Close specified connection. ; Parameters. connidconnection id, when 0 - all connections will be closed . Definition at line 1489 of file RWebWindow.cxx. ◆ CloseConnections(). void RWebWindow::CloseC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RWebWindow.html:25705,perform,performed,25705,doc/master/classROOT_1_1RWebWindow.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RWebWindow.html,1,['perform'],['performed']
Performance,"om possible filter and put the result in 'dst'. TFITSHDU(const char* filepath_with_filter); TFITSHDU constructor from file path with HDU selection filter.; Please refer to CFITSIO manual for more information about; HDU selection filters.; Examples:; - TFITSHDU(""/path/to/myfile.fits""): just open the PRIMARY HDU; - TFITSHDU(""/path/to/myfile.fits[1]""): open HDU #1; - TFITSHDU(""/path/to/myfile.fits[PICS]""): open HDU called 'PICS'; - TFITSHDU(""/path/to/myfile.fits[ACQ][EXPOSURE > 5]""): open the (table) HDU called 'ACQ' and; selects the rows that have column 'EXPOSURE'; greater than 5. TFITSHDU(const char* filepath, Int_t extension_number); TFITSHDU constructor from filepath and extension number. TFITSHDU(const char* filepath, const char* extension_name); TFITSHDU constructor from filepath and extension name. ~TFITSHDU(); TFITSHDU destructor. void _release_resources(); Release internal resources. void _initialize_me(); Do some initializations. Bool_t LoadHDU(TString& filepath_filter); Load HDU from fits file satisfying the specified filter.; Returns kTRUE if success. Otherwise kFALSE.; If filter == """" then the primary array is selected. TString& GetKeywordValue(const char* keyword); Get the value of a given keyword. Return """" if not found. void PrintHDUMetadata(Option_t* opt = """") const; Print records. void PrintFileMetadata(Option_t* opt = """") const; Print HDU's parent file's metadata. void PrintColumnInfo(Option_t* ) const; Print column information. void PrintFullTable(Option_t* ) const; Print full table contents. void Print(Option_t* opt = """") const; Print metadata.; Currently supported options:; """" : print HDU record data; ""F"" : print FITS file's extension names, numbers and types; ""F+"": print FITS file's extension names and types and their record data; ""T"" : print column information when HDU is a table; ""T+"" : print full table (columns header and rows). TImage * ReadAsImage(Int_t layer = 0, TImagePalette* pal = 0); Read image HDU as a displayable image. Return 0 if co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TFITSHDU.html:9128,Load,LoadHDU,9128,root/html532/TFITSHDU.html,https://root.cern,https://root.cern/root/html532/TFITSHDU.html,4,['Load'],"['Load', 'LoadHDU']"
Performance,"om possible filter and put the result in 'dst'. TFITSHDU(const char* filepath_with_filter); TFITSHDU constructor from file path with HDU selection filter.; Please refer to CFITSIO manual for more information about; HDU selection filters.; Examples:; - TFITSHDU(""/path/to/myfile.fits""): just open the PRIMARY HDU; - TFITSHDU(""/path/to/myfile.fits[1]""): open HDU #1; - TFITSHDU(""/path/to/myfile.fits[PICS]""): open HDU called 'PICS'; - TFITSHDU(""/path/to/myfile.fits[ACQ][EXPOSURE > 5]""): open the (table) HDU called 'ACQ' and; selects the rows that have column 'EXPOSURE'; greater than 5. TFITSHDU(const char* filepath, Int_t extension_number); TFITSHDU constructor from filepath and extension number. TFITSHDU(const char* filepath, const char* extension_name); TFITSHDU constructor from filepath and extension name. ~TFITSHDU(); TFITSHDU destructor. void _release_resources(); Release internal resources. void _initialize_me(); Do some initializations. Bool_t LoadHDU(TString& filepath_filter); Load HDU from fits file satisfying the specified filter.; Returns kTRUE if success. Otherwise kFALSE.; If filter == """" then the primary array is selected. TString& GetKeywordValue(const char* keyword); Get the value of a given keyword. Return """" if not found. void PrintHDUMetadata(const Option_t* opt = """") const; Print records. void PrintFileMetadata(const Option_t* opt = """") const; Print HDU's parent file's metadata. void PrintColumnInfo(const Option_t* ) const; Print column information. void PrintFullTable(const Option_t* ) const; Print full table contents. void Print(const Option_t* opt = """") const; Print metadata.; Currently supported options:; """" : print HDU record data; ""F"" : print FITS file's extension names, numbers and types; ""F+"": print FITS file's extension names and types and their record data; ""T"" : print column information when HDU is a table; ""T+"" : print full table (columns header and rows). TImage * ReadAsImage(Int_t layer = 0, TImagePalette* pal = 0); Read image HDU as a dis",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TFITSHDU.html:9522,Load,LoadHDU,9522,root/html602/TFITSHDU.html,https://root.cern,https://root.cern/root/html602/TFITSHDU.html,4,['Load'],"['Load', 'LoadHDU']"
Performance,"om proxy list. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Static Protected Member Functions inherited from RooAbsReal; static void globalSelectComp (bool flag);  Global switch controlling the activation of the selectComp() functionality. ;  ;  Static Protected Member Functions inherited from RooAbsArg; static void ioStreamerPass2Finalize ();  Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ;  ;  Static Protected Attributes inherited from RooAbsPdf; static TString _normRangeOverride;  ; static Int_t _verboseEval = 0;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooBCPEffDecay.h>. Inheritance diagram for RooBCPEffDecay:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Enumeration Documentation. ◆ DecayType. enum RooBCPEffDecay::DecayType. EnumeratorSingleSided ; DoubleSided ; Flipped . Definition at line 26 of file RooBCPEffDecay.h. Constructor & Destructor Documentation. ◆ RooBCPEffDecay() [1/3]. RooBCPEffDecay::RooBCPEffDecay ; (; ). inline . Definition at line 29 of file RooBCPEffDecay.h. ◆ RooBCPEffDecay() [2/3]. RooBCPEffDecay::RooBCPEffDecay ; (; const char * ; name, . const char * ; title, . RooRealVar & ; t, . RooAbsCategory & ; tag, . RooAbsReal & ; tau, . RooAbsReal & ; dm, . RooAbsReal & ; avgMistag, . RooAbsReal & ; CPeigenval, . RooAbsReal & ; absLambda, . RooAbsReal & ; argLambda, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooBCPEffDecay.html:77266,cache,cache,77266,doc/master/classRooBCPEffDecay.html,https://root.cern,https://root.cern/doc/master/classRooBCPEffDecay.html,1,['cache'],['cache']
Performance,"om proxy list. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Static Protected Member Functions inherited from RooAbsReal; static void globalSelectComp (bool flag);  Global switch controlling the activation of the selectComp() functionality. ;  ;  Static Protected Member Functions inherited from RooAbsArg; static void ioStreamerPass2Finalize ();  Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ;  ;  Static Protected Attributes inherited from RooAbsPdf; static TString _normRangeOverride;  ; static Int_t _verboseEval = 0;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooBCPGenDecay.h>. Inheritance diagram for RooBCPGenDecay:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Enumeration Documentation. ◆ DecayType. enum RooBCPGenDecay::DecayType. EnumeratorSingleSided ; DoubleSided ; Flipped . Definition at line 26 of file RooBCPGenDecay.h. Constructor & Destructor Documentation. ◆ RooBCPGenDecay() [1/3]. RooBCPGenDecay::RooBCPGenDecay ; (; ). inline . Definition at line 29 of file RooBCPGenDecay.h. ◆ RooBCPGenDecay() [2/3]. RooBCPGenDecay::RooBCPGenDecay ; (; const char * ; name, . const char * ; title, . RooRealVar & ; t, . RooAbsCategory & ; tag, . RooAbsReal & ; tau, . RooAbsReal & ; dm, . RooAbsReal & ; avgMistag, . RooAbsReal & ; avgC, . RooAbsReal & ; avgS, . RooAbsReal & ; delMistag, . RooAbsRea",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooBCPGenDecay.html:77140,cache,cache,77140,doc/master/classRooBCPGenDecay.html,https://root.cern,https://root.cern/doc/master/classRooBCPGenDecay.html,1,['cache'],['cache']
Performance,"om proxy list. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Static Protected Member Functions inherited from RooAbsReal; static void globalSelectComp (bool flag);  Global switch controlling the activation of the selectComp() functionality. ;  ;  Static Protected Member Functions inherited from RooAbsArg; static void ioStreamerPass2Finalize ();  Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ;  ;  Static Protected Attributes inherited from RooAbsPdf; static TString _normRangeOverride;  ; static Int_t _verboseEval = 0;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooBDecay.h>. Inheritance diagram for RooBDecay:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Enumeration Documentation. ◆ DecayType. enum RooBDecay::DecayType. EnumeratorSingleSided ; DoubleSided ; Flipped . Definition at line 29 of file RooBDecay.h. Constructor & Destructor Documentation. ◆ RooBDecay() [1/3]. RooBDecay::RooBDecay ; (; ). inline . Definition at line 32 of file RooBDecay.h. ◆ RooBDecay() [2/3]. RooBDecay::RooBDecay ; (; const char * ; name, . const char * ; title, . RooRealVar & ; t, . RooAbsReal & ; tau, . RooAbsReal & ; dgamma, . RooAbsReal & ; f0, . RooAbsReal & ; f1, . RooAbsReal & ; f2, . RooAbsReal & ; f3, . RooAbsReal & ; dm, . const RooResolutionModel & ; model, . DecayType ; type . ). Constructor for RooBDec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooBDecay.html:77150,cache,cache,77150,doc/master/classRooBDecay.html,https://root.cern,https://root.cern/doc/master/classRooBDecay.html,1,['cache'],['cache']
Performance,"om proxy list. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Static Protected Member Functions inherited from RooAbsReal; static void globalSelectComp (bool flag);  Global switch controlling the activation of the selectComp() functionality. ;  ;  Static Protected Member Functions inherited from RooAbsArg; static void ioStreamerPass2Finalize ();  Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ;  ;  Static Protected Attributes inherited from RooAbsPdf; static TString _normRangeOverride;  ; static Int_t _verboseEval = 0;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooBMixDecay.h>. Inheritance diagram for RooBMixDecay:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Enumeration Documentation. ◆ DecayType. enum RooBMixDecay::DecayType. EnumeratorSingleSided ; DoubleSided ; Flipped . Definition at line 26 of file RooBMixDecay.h. Constructor & Destructor Documentation. ◆ RooBMixDecay() [1/3]. RooBMixDecay::RooBMixDecay ; (; ). inline . Definition at line 29 of file RooBMixDecay.h. ◆ RooBMixDecay() [2/3]. RooBMixDecay::RooBMixDecay ; (; const char * ; name, . const char * ; title, . RooRealVar & ; t, . RooAbsCategory & ; mixState, . RooAbsCategory & ; tagFlav, . RooAbsReal & ; tau, . RooAbsReal & ; dm, . RooAbsReal & ; mistag, . RooAbsReal & ; delMistag, . const RooResolutionModel & ; model, . DecayTy",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooBMixDecay.html:77244,cache,cache,77244,doc/master/classRooBMixDecay.html,https://root.cern,https://root.cern/doc/master/classRooBMixDecay.html,1,['cache'],['cache']
Performance,"om proxy list. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Static Protected Member Functions inherited from RooAbsReal; static void globalSelectComp (bool flag);  Global switch controlling the activation of the selectComp() functionality. ;  ;  Static Protected Member Functions inherited from RooAbsArg; static void ioStreamerPass2Finalize ();  Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ;  ;  Static Protected Attributes inherited from RooAbsPdf; static TString _normRangeOverride;  ; static Int_t _verboseEval = 0;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooDecay.h>. Inheritance diagram for RooDecay:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Enumeration Documentation. ◆ DecayType. enum RooDecay::DecayType. EnumeratorSingleSided ; DoubleSided ; Flipped . Definition at line 25 of file RooDecay.h. Constructor & Destructor Documentation. ◆ RooDecay() [1/3]. RooDecay::RooDecay ; (; ). inline . Definition at line 28 of file RooDecay.h. ◆ RooDecay() [2/3]. RooDecay::RooDecay ; (; const char * ; name, . const char * ; title, . RooRealVar & ; t, . RooAbsReal & ; tau, . const RooResolutionModel & ; model, . DecayType ; type . ). Create a new RooDecay. ; Parameters. [in]nameName of this object. ; [in]titleTitle (for e.g. plotting) ; [in]tConvolution variable (e.g. time). ; [in]tauDecay const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooDecay.html:77589,cache,cache,77589,doc/master/classRooDecay.html,https://root.cern,https://root.cern/doc/master/classRooDecay.html,1,['cache'],['cache']
Performance,"om proxy list. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Static Protected Member Functions inherited from RooAbsReal; static void globalSelectComp (bool flag);  Global switch controlling the activation of the selectComp() functionality. ;  ;  Static Protected Member Functions inherited from RooAbsArg; static void ioStreamerPass2Finalize ();  Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ;  ;  Static Protected Attributes inherited from RooAbsPdf; static TString _normRangeOverride;  ; static Int_t _verboseEval = 0;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooExtendPdf.h>. Inheritance diagram for RooExtendPdf:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RooExtendPdf() [1/4]. RooExtendPdf::RooExtendPdf ; (; ). default . ◆ RooExtendPdf() [2/4]. RooExtendPdf::RooExtendPdf ; (; const char * ; name, . const char * ; title, . RooAbsPdf & ; pdf, . RooAbsReal & ; norm, . const char * ; rangeName = nullptr . ). Definition at line 56 of file RooExtendPdf.cxx. ◆ RooExtendPdf() [3/4]. RooExtendPdf::RooExtendPdf ; (; const char * ; name, . const char * ; title, . RooAbsPdf & ; pdf, . RooAbsReal::Ref ; norm, . const char * ; rangeName = nullptr . ). Constructor. ; The ExtendPdf behaves identical to the supplied input pdf, but adds an extended likelihood term. expe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooExtendPdf.html:73881,cache,cache,73881,doc/master/classRooExtendPdf.html,https://root.cern,https://root.cern/doc/master/classRooExtendPdf.html,1,['cache'],['cache']
Performance,"om proxy list. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Static Protected Member Functions inherited from RooAbsReal; static void globalSelectComp (bool flag);  Global switch controlling the activation of the selectComp() functionality. ;  ;  Static Protected Member Functions inherited from RooAbsArg; static void ioStreamerPass2Finalize ();  Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ;  ;  Static Protected Attributes inherited from RooAbsPdf; static TString _normRangeOverride;  ; static Int_t _verboseEval = 0;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooExtendedTerm.h>. Inheritance diagram for RooExtendedTerm:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RooExtendedTerm() [1/3]. RooExtendedTerm::RooExtendedTerm ; (; ). default . ◆ RooExtendedTerm() [2/3]. RooExtendedTerm::RooExtendedTerm ; (; const char * ; name, . const char * ; title, . const RooAbsReal & ; n . ). Constructor. ; An ExtendedTerm has no observables, it only introduces an extended ML term with the given number of expected events when an extended ML is constructed from this p.d.f. ; Definition at line 38 of file RooExtendedTerm.cxx. ◆ RooExtendedTerm() [3/3]. RooExtendedTerm::RooExtendedTerm ; (; const RooExtendedTerm & ; other, . const char * ; name = nullptr . ). Copy constructo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooExtendedTerm.html:73090,cache,cache,73090,doc/master/classRooExtendedTerm.html,https://root.cern,https://root.cern/doc/master/classRooExtendedTerm.html,1,['cache'],['cache']
Performance,"om proxy list. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Static Protected Member Functions inherited from RooAbsReal; static void globalSelectComp (bool flag);  Global switch controlling the activation of the selectComp() functionality. ;  ;  Static Protected Member Functions inherited from RooAbsArg; static void ioStreamerPass2Finalize ();  Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ;  ;  Static Protected Attributes inherited from RooAbsPdf; static TString _normRangeOverride;  ; static Int_t _verboseEval = 0;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooNonCPEigenDecay.h>. Inheritance diagram for RooNonCPEigenDecay:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Enumeration Documentation. ◆ DecayType. enum RooNonCPEigenDecay::DecayType. EnumeratorSingleSided ; DoubleSided ; Flipped . Definition at line 37 of file RooNonCPEigenDecay.h. Constructor & Destructor Documentation. ◆ RooNonCPEigenDecay() [1/4]. RooNonCPEigenDecay::RooNonCPEigenDecay ; (; void ; ). inline . Definition at line 40 of file RooNonCPEigenDecay.h. ◆ RooNonCPEigenDecay() [2/4]. RooNonCPEigenDecay::RooNonCPEigenDecay ; (; const char * ; name, . const char * ; title, . RooRealVar & ; t, . RooAbsCategory & ; tag, . RooAbsReal & ; tau, . RooAbsReal & ; dm, . RooAbsReal & ; avgW, . RooAbsReal & ; delW, . RooAbsCategory",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooNonCPEigenDecay.html:78253,cache,cache,78253,doc/master/classRooNonCPEigenDecay.html,https://root.cern,https://root.cern/doc/master/classRooNonCPEigenDecay.html,1,['cache'],['cache']
Performance,"om the sources are the following:. Clone the repository:. $ git clone https://github.com/root-project/root.git. Make a directory for building. $ mkdir build; $ cd build. Run cmake and make. $ cmake ../root; $ make -j8. Setup and run ROOT. $ source bin/thisroot.sh; $ root; 28.5.0.1 Staying up-to-date; To keep your local ROOT source up-to-date with the GitHub repository you should regularly run the command:; % git pull; 28.6 File system.rootrc; ROOT Environment settings are handled via the class TEnv. gEnv->Print()shows which values are active. Any settings can be obtained by TEnv::GetValue methods that return an integer, double or character value for a named resource. If the resource is not found, the default value (given as the second parameter) is returned.; fShowEventStatus = gEnv->GetValue(""Canvas.ShowEventStatus"",kFALSE);; Via the method TEnv::SetValue allows you can set the value of a resource or create a new resource:; gEnv->SetValue(""Root.ObjectStat"",1);; Path used by dynamic loader to find shared libraries and macros. Paths are different for Unix and Windows. The example shows the defaults for all ROOT applications for either Unix or Windows:; Unix.*.Root.DynamicPath: .:$(ROOTSYS)/lib; Unix.*.Root.MacroPath: .:$(ROOTSYS)/macros; WinNT.*.Root.DynamicPath: .;$(ROOTSYS)/bin;$(PATH); WinNT.*.Root.MacroPath: .;$(ROOTSYS)/macros; Path where to look for TrueType fonts:; Unix.*.Root.UseTTFonts: true; *.*.Root.TTFontPath: $(ROOTSYS)/fonts; Use Net* API functions:; WinNT.UseNetAPI: true; Use thread library (if exists).; Unix.*.Root.UseThreads: false; Select the compression algorithm (0=old zlib, 1=new zlib). Setting this to `0’ may be a security vulnerability.; Root.ZipMode: 1; Show where item is found in the specified path:; Root.ShowPath: false; Activate memory statistics.; Root.ObjectStat: 0; Global debug mode. When >0 turns on progressively more details debugging.; Root.Debug: 0; Root.Stacktrace: yes; Settings for X11 behaviour.; X11.Sync: no; X11.FindBestVisual: y",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1254706,load,loader,1254706,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['load'],['loader']
Performance,"om this branch. ;  ; void SetAddress (void *addobj) override;  Point this branch at an object. ;  ; void SetBasketSize (Int_t buffsize) override;  Reset the basket size for all sub-branches of this branch element. ;  ; virtual void SetBranchFolder ();  ; virtual void SetClassName (const char *name);  ; bool SetMakeClass (bool decomposeObj=true) override;  Set the branch in a mode where the object are decomposed (Also known as MakeClass mode). ;  ; virtual void SetMissing ();  Set offset of the object (to which the data member represented by this branch belongs) inside its containing object (if any) to mark it as missing. ;  ; void SetObject (void *objadd) override;  Set object this branch is pointing to. ;  ; void SetOffset (Int_t offset) override;  Set offset of the object (to which the data member represented by this branch belongs) inside its containing object (if any). ;  ; void SetParentClass (TClass *clparent);  ; virtual void SetParentName (const char *name);  ; virtual void SetTargetClass (const char *name);  Set the name of the class of the in-memory object into which the data will loaded. ;  ; virtual void SetType (Int_t btype);  ; void SetupAddresses () override;  If the branch address is not set, we set all addresses starting with the top level parent branch. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TBranchElement. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void Unroll (const char *name, TClass *cl, TStreamerInfo *sinfo, char *objptr, Int_t bufsize, Int_t splitlevel);  Split class cl into sub-branches of this branch. ;  ; void UpdateFile () override;  Refresh the value of fDirectory (i.e. ;  ;  Public Member Functions inherited from TBranch;  TBranch ();  Default constructor. Used for I/O by default. ;  ;  TBranch (TBranch *parent, const char *name, void *address, const char *leaflist, Int_t basketsize=32000, Int_t compress=ROOT::RCompressionSetting::EAlgorithm::kInherit);  Create a Branch as a child ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBranchElement.html:7629,load,loaded,7629,doc/master/classTBranchElement.html,https://root.cern,https://root.cern/doc/master/classTBranchElement.html,1,['load'],['loaded']
Performance,"om tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; RooListProxy_list; TIterator*_listIter! do not persist; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooRecursiveFraction.html:32568,cache,cache,32568,root/html532/RooRecursiveFraction.html,https://root.cern,https://root.cern/root/html532/RooRecursiveFraction.html,4,['cache'],['cache']
Performance,"om(). TH1F * TMVA::Factory::EvaluateImportanceRandom ; (; DataLoader * ; loader, . UInt_t ; nseeds, . Types::EMVA ; theMethod, . TString ; methodTitle, . const char * ; theOption = """" . ). private . Definition at line 2473 of file Factory.cxx. ◆ EvaluateImportanceShort(). TH1F * TMVA::Factory::EvaluateImportanceShort ; (; DataLoader * ; loader, . Types::EMVA ; theMethod, . TString ; methodTitle, . const char * ; theOption = """" . ). private . Definition at line 2358 of file Factory.cxx. ◆ GetImportance(). TH1F * TMVA::Factory::GetImportance ; (; const int ; nbits, . std::vector< Double_t > ; importances, . std::vector< TString > ; varNames . ). private . Definition at line 2591 of file Factory.cxx. ◆ GetMethod(). TMVA::IMethod * TMVA::Factory::GetMethod ; (; const TString & ; datasetname, . const TString & ; title . ); const. Returns pointer to MVA that corresponds to given method title. ; Definition at line 566 of file Factory.cxx. ◆ GetROC() [1/2]. TMVA::ROCCurve * TMVA::Factory::GetROC ; (; TMVA::DataLoader * ; loader, . TString ; theMethodName, . UInt_t ; iClass = 0, . Types::ETreeType ; type = Types::kTesting . ). private . Private method to generate a ROCCurve instance for a given method. ; Handles the conversion from TMVA ResultSet to a format the ROCCurve class understands.; NoteYou own the retured pointer. ; Definition at line 749 of file Factory.cxx. ◆ GetROC() [2/2]. TMVA::ROCCurve * TMVA::Factory::GetROC ; (; TString ; datasetname, . TString ; theMethodName, . UInt_t ; iClass = 0, . Types::ETreeType ; type = Types::kTesting . ). private . Private method to generate a ROCCurve instance for a given method. ; Handles the conversion from TMVA ResultSet to a format the ROCCurve class understands.; NoteYou own the retured pointer. ; Definition at line 762 of file Factory.cxx. ◆ GetROCCurve() [1/4]. TGraph * TMVA::Factory::GetROCCurve ; (; DataLoader * ; loader, . TString ; theMethodName, . Bool_t ; setTitles = kTRUE, . UInt_t ; iClass = 0, . Types::ETreeType ; t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1Factory.html:25579,load,loader,25579,doc/master/classTMVA_1_1Factory.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1Factory.html,1,['load'],['loader']
Performance,"om->Rannor(px,py);; 1174 hcol1->Fill(px,py);; 1175 }; 1176 hcol1->Draw(""COLZPOL"");; 1177}; 1178End_Macro; 1179 ; 1180\since **ROOT version 6.07/03:**; 1181 ; 1182A second rendering technique is also available with the COL2 and COLZ2 options.; 1183 ; 1184These options provide potential performance improvements compared to the standard; 1185COL option. The performance comparison of the COL2 to the COL option depends on; 1186the histogram and the size of the rendering region in the current pad. In general,; 1187a small (approx. less than 100 bins per axis), sparsely populated TH2 will render; 1188faster with the COL option.; 1189 ; 1190However, for larger histograms (approx. more than 100 bins per axis); 1191that are not sparse, the COL2 option will provide up to 20 times performance improvements.; 1192For example, a 1000x1000 bin TH2 that is not sparse will render an order of magnitude; 1193faster with the COL2 option.; 1194 ; 1195The COL2 option will also scale its performance based on the size of the; 1196pixmap the histogram image is being rendered into. It also is much better optimized for; 1197sessions where the user is forwarding X11 windows through an `ssh` connection.; 1198 ; 1199For the most part, the COL2 and COLZ2 options are a drop in replacement to the COL; 1200and COLZ options. There is one major difference and that concerns the treatment of; 1201bins with zero content. The COL2 and COLZ2 options color these bins the color of zero.; 1202 ; 1203COL2 option renders the histogram as a bitmap. Therefore it cannot be saved in vector; 1204graphics file format like PostScript or PDF (an empty image will be generated). It can; 1205be saved only in bitmap files like PNG format for instance.; 1206 ; 1207 ; 1208\anchor HP140; 1209### The CANDLE and VIOLIN options; 1210 ; 1211The mechanism behind Candle plots and Violin plots is very similar. Because of this they are; 1212implemented in the same class TCandle. The keywords CANDLE or VIOLIN will initiate the drawing o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THistPainter_8cxx_source.html:48335,perform,performance,48335,doc/master/THistPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html,1,['perform'],['performance']
Performance,"omatically. 2- with TTree::Process and TSelectors. You must enable the cache and tell the system which branches to cache; and also specify the entry range. It is important to specify the entry range; in case you process only a subset of the events, otherwise you run the risk; to store in the cache entries that you do not need. --example 2a; --; TTree *T = (TTree*)f->Get(""mytree"");; Long64_t nentries = T->GetEntries();; Int_t cachesize = 10000000; //10 MBytes; T->SetCacheSize(cachesize); //<<<; T->AddBranch(""*"",kTRUE); //<<< add all branches to the cache; T->Process('myselector.C+"");; //in the TSelector::Process function we read all branches; T->GetEntry(i);; -- ... here you process your entry. --example 2b; in the Process function we read a subset of the branches.; Only the branches used in the first entry will be put in the cache; --; TTree *T = (TTree*)f->Get(""mytree"");; //we want to process only the 200 first entries; Long64_t nentries=200;; int efirst= 0;; int elast = efirst+nentries;; Int_t cachesize = 10000000; //10 MBytes; TTreeCache::SetLearnEntries(1); //<<< we can take the decision after 1 entry; T->SetCacheSize(cachesize); //<<<; T->SetCacheEntryRange(efirst,elast); //<<<; T->Process('myselector.C+"","""",nentries,efirst);; // in the TSelector::Process we read only 2 branches; TBranch *b1 = T->GetBranch(""branch1"");; b1->GetEntry(i);; if (somecondition) return;; TBranch *b2 = T->GetBranch(""branch2"");; b2->GetEntry(i);; ... here you process your entry; --. 3- with your own event loop. --example 3a; in your analysis loop, you always use 2 branches. You want to prefetch; the branch buffers for these 2 branches only.; --; TTree *T = (TTree*)f->Get(""mytree"");; TBranch *b1 = T->GetBranch(""branch1"");; TBranch *b2 = T->GetBranch(""branch2"");; Long64_t nentries = T->GetEntries();; Int_t cachesize = 10000000; //10 MBytes; T->SetCacheSize(cachesize); //<<<; T->AddBranchToCache(b1,kTRUE); //<<<add branch1 and branch2 to the cache; T->AddBranchToCache(b2,kTRUE); //<<<; T->",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreeCache.html:5509,cache,cache,5509,root/html528/TTreeCache.html,https://root.cern,https://root.cern/root/html528/TTreeCache.html,6,['cache'],"['cache', 'cachesize']"
Performance,"oment when library is loaded It supposed to be a thread where gApplication->Run() will be called If application runs in separate thread, one have to call this method to let RWebWindowsManager correctly recognize such situation. ;  ; static void ClearServerLocations ();  Clear all server locations Does not change configuration of already running HTTP server. ;  ; static std::map< std::string, std::string > GetServerLocations ();  Returns server locations as <std::string, std::string> Key is location name (with slash at the end) and value is file path. ;  ; static std::shared_ptr< RWebWindowsManager > & Instance ();  Returns default window manager Used to display all standard ROOT elements like TCanvas or TFitPanel. ;  ; static bool IsLoopbackMode ();  Returns true if loopback mode used by THttpServer for web widgets. ;  ; static bool IsMainThrd ();  Returns true when called from main process Main process recognized at the moment when library is loaded It supposed to be a thread where gApplication->Run() will be called If application runs in separate thread, one have to use AssignMainThrd() method to let RWebWindowsManager correctly recognize such situation. ;  ; static void SetLoopbackMode (bool on=true);  Set loopback mode for THttpServer used for web widgets By default is on. ;  ; static void SetUseConnectionKey (bool on=true);  Enable or disable usage of connection key (default on) If enabled, each connection (and reconnection) to widget requires unique key Connection key used together with session key to calculate hash sum of each packet send to or from server This protects ROOT http server from anauthorized usage. ;  ; static void SetUseSessionKey (bool on=true);  Enable or disable usage of session key (default on) If enabled, secrete session key used to calculate hash sum of each packet send to or from server This protects ROOT http server from anauthorized usage. ;  . Private Member Functions; bool CreateServer (bool with_http=false);  Creates http server, if r",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RWebWindowsManager.html:3028,load,loaded,3028,doc/master/classROOT_1_1RWebWindowsManager.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RWebWindowsManager.html,1,['load'],['loaded']
Performance,"oment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooCFunction3PdfBinding<double,double,double,bool>&operator=(const RooCFunction3PdfBinding<double,double,double,bool>&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCFunction3PdfBinding_double_double_double_bool_.html:23572,optimiz,optimizeCacheMode,23572,root/html602/RooCFunction3PdfBinding_double_double_double_bool_.html,https://root.cern,https://root.cern/root/html602/RooCFunction3PdfBinding_double_double_double_bool_.html,8,['optimiz'],['optimizeCacheMode']
Performance,"ommon (const RooAbsCollection &refColl) const;  Create a subset of the current collection, consisting only of those elements that are contained as well in the given reference collection. ;  ; bool selectCommon (const RooAbsCollection &refColl, RooAbsCollection &outColl) const;  Create a subset of the current collection, consisting only of those elements that are contained as well in the given reference collection. ;  ; void setAttribAll (const Text_t *name, bool value=true);  Set given attribute in each element of the collection by calling each elements setAttribute() function. ;  ; bool setCatIndex (const char *name, Int_t newVal=0, bool verbose=false);  Set index value of a RooAbsCategoryLValue stored in set with given name to newVal. ;  ; bool setCatLabel (const char *name, const char *newVal="""", bool verbose=false);  Set state name of a RooAbsCategoryLValue stored in set with given name to newVal. ;  ; void setHashTableSize (Int_t number);  Set the size at which the collection will automatically start using an extra lookup table instead of performing a linear search. ;  ; void setName (const char *name);  ; bool setRealValue (const char *name, double newVal=0.0, bool verbose=false);  Set value of a RooAbsRealLValue stored in set with given name to newVal No error messages are printed unless the verbose flag is set. ;  ; bool setStringValue (const char *name, const char *newVal="""", bool verbose=false);  Set string value of a RooStringVar stored in set with given name to newVal. ;  ; Storage_t::size_type size () const;  ; RooAbsCollection * snapshot (bool deepCopy=true) const;  Take a snap shot of current collection contents. ;  ; bool snapshot (RooAbsCollection &output, bool deepCopy=true) const;  Take a snap shot of current collection contents: A collection that owns its elements is returned containing clones of. ;  ; void sort (bool reverse=false);  Sort collection using std::sort and name comparison. ;  ; void sortTopologically ();  Sort collection topologicall",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAbsCollection.html:13587,perform,performing,13587,doc/v632/classRooAbsCollection.html,https://root.cern,https://root.cern/doc/v632/classRooAbsCollection.html,4,['perform'],['performing']
Performance,"ompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_t_intOrderInterpolation order; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Double_t_totVolume! Total volume of space (product of ranges of observables); Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Bool_t_unitNorm! Assume contents is unit normalized (for use as pdf cache); Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooHistFunc.html:33241,cache,cache,33241,root/html530/RooHistFunc.html,https://root.cern,https://root.cern/root/html530/RooHistFunc.html,2,['cache'],['cache']
Performance,"ompare object. void SetBitNumber(UInt_t bitnumber, Bool_t value = kTRUE); Set bit number 'bitnumber' to be value. Bool_t TestBitNumber(UInt_t bitnumber) const; Return the current value of the bit. void ResetBitNumber(UInt_t bitnumber). Bool_t operator[](UInt_t bitnumber) const. Bool_t operator~(); Flips the bit. TBits::TReference operator[](UInt_t bitnumber); ----- Accessors and operator. { return TReference(*this,bitnumber); }. TBits& operator&=(const TBits& rhs); { DoAndEqual(rhs); return *this; }. TBits& operator|=(const TBits& rhs); { DoOrEqual(rhs); return *this; }. TBits& operator^=(const TBits& rhs); { DoXorEqual(rhs); return *this; }. TBits& operator<<=(UInt_t rhs); { DoLeftShift(rhs); return *this; }. TBits& operator>>=(UInt_t rhs); { DoRightShift(rhs); return *this; }. TBits operator<<(UInt_t rhs); { return TBits(*this)<<= rhs; }. TBits operator>>(UInt_t rhs); { return TBits(*this)>>= rhs; }. void Set(UInt_t nbits, const Char_t* array); ----- Optimized setters; Each of these will replace the contents of the receiver with the bitvector; in the parameter array. The number of bits is changed to nbits. If nbits; is smaller than fNbits, the receiver will NOT be compacted. void Get(Char_t* array) const; ----- Optimized getters; Each of these will replace the contents of the parameter array with the; bits in the receiver. The parameter array must be large enough to hold; all of the bits in the receiver.; Note on semantics: any bits in the parameter array that go beyond the; number of the bits in the receiver will have an unspecified value. For; example, if you call Get(Int*) with an array of one integer and the TBits; object has less than 32 bits, then the remaining bits in the integer will; have an unspecified value. UInt_t GetNbits() const; { return fNbits; }. UInt_t GetNbytes() const; { return fNbytes; }. Bool_t operator!=(const TBits& other) const; { return !(*this==other); }. » Author: Philippe Canal 05/02/01 » Copyright (C) 1995-2000, Rene Brun and Fons Rad",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TBits.html:10874,Optimiz,Optimized,10874,root/html532/TBits.html,https://root.cern,https://root.cern/root/html532/TBits.html,4,['Optimiz'],['Optimized']
Performance,"ompare(TObjLink* l1, TObjLink* l2); voidTObject::MakeZombie(); virtual TObjLink*TList::NewLink(TObject* obj, TObjLink* prev = NULL); virtual TObjLink*TList::NewOptLink(TObject* obj, Option_t* opt, TObjLink* prev = NULL); virtual voidTCollection::PrintCollectionEntry(TObject* entry, Option_t* option, Int_t recurse) const; virtual voidTCollection::PrintCollectionHeader(Option_t* option) const. Data Members; public:. enum TCollection::[unnamed] { kIsOwner; kInitCapacity; kInitHashTableCapacity; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_tTList::fAscending! sorting order (when calling Sort() or for TSortedList); TObjLink*TList::fCache! cache to speedup sequential calling of Before() and After() functions; TObjLink*TList::fFirst! pointer to first entry in linked list; TObjLink*TList::fLast! pointer to last entry in linked list; TStringTCollection::fNamename of the collection; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGridResult(); { SetOwner(kTRUE); }. virtual ~TGridResult(); { }. const char * GetFileName(UInt_t ) const; { MayNotUse(""GetFileName""); return 0; }. const char * GetFileNamePath(UInt_t ) const; { MayNotUse(""GetFileNamePath""); return 0; }. const char * GetPath(UInt_t ) const; { MayNotUse(""GetPath""); return 0; }. const TEntryList * GetEntryList(UInt_t ) const; { MayNotUse(""GetEntryList""); return 0; }. const char * GetKey(UInt_t , const char* ) const; { MayNotUse(""GetKey""); return 0; }. Bool_t SetKey(UInt_t , const char* , const char* ); { MayNotUse(""SetKey""); return 0; }. TList * GetFileInfoList() const; { MayNotUse(""GetFileInfoList""); return 0; }. » Author: Fons Rade",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGridResult.html:9819,cache,cache,9819,root/html528/TGridResult.html,https://root.cern,https://root.cern/root/html528/TGridResult.html,6,['cache'],['cache']
Performance,"ompare(TObjLink* l1, TObjLink* l2); voidTObject::MakeZombie(); virtual TObjLink*TList::NewLink(TObject* obj, TObjLink* prev = NULL); virtual TObjLink*TList::NewOptLink(TObject* obj, Option_t* opt, TObjLink* prev = NULL); virtual voidTCollection::PrintCollectionEntry(TObject* entry, Option_t* option, Int_t recurse) const; virtual voidTCollection::PrintCollectionHeader(Option_t* option) const. Data Members; public:. enum TCollection::[unnamed] { kIsOwner; kInitCapacity; kInitHashTableCapacity; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_tTList::fAscending! sorting order (when calling Sort() or for TSortedList); TObjLink*TList::fCache! cache to speedup sequential calling of Before() and After() functions; TObjLink*TList::fFirst! pointer to first entry in linked list; TObjLink*TList::fLast! pointer to last entry in linked list; TStringTCollection::fNamename of the collection; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TObjOptLink * findLink(const char* name, const char* caller = 0) const; Find the link corresponding to the named object in this list.; Return 0 if the object is not found or does not have an Option_t; string associated with its link. Also print a warning message; if caller is non-zero. Bool_t moveBefore(const char* before, const char* target, const char* caller = 0); Move the target object immediately before the specified object,; preserving any Option_t associated with the target link. Bool_t moveAfter(const char* after, const char* target, const char* caller = 0); Move the target object immediately after the specified object,; preserving any Option_t associated w",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooList.html:9618,cache,cache,9618,root/html526/RooList.html,https://root.cern,https://root.cern/root/html526/RooList.html,7,['cache'],['cache']
Performance,"ompare(TObjLink* l1, TObjLink* l2); voidTObject::MakeZombie(); virtual TObjLink*TList::NewLink(TObject* obj, TObjLink* prev = NULL); virtual TObjLink*TList::NewOptLink(TObject* obj, Option_t* opt, TObjLink* prev = NULL); virtual voidTCollection::PrintCollectionEntry(TObject* entry, Option_t* option, Int_t recurse) const; virtual voidTCollection::PrintCollectionHeader(Option_t* option) const. Data Members; public:. enum TCollection::[unnamed] { kIsOwner; kInitCapacity; kInitHashTableCapacity; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_tTList::fAscending! sorting order (when calling Sort() or for TSortedList); TObjLink*TList::fCache! cache to speedup sequential calling of Before() and After() functions; TObjLink*TList::fFirst! pointer to first entry in linked list; TObjLink*TList::fLast! pointer to last entry in linked list; TStringTCollection::fNamename of the collection; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Add(TObject* obj); Add object in sorted list. Uses object Compare() member to find right; position. void Add(TObject* obj, Option_t* opt); Add object in sorted list. Uses object Compare() member to find right; position and also store option. See TList::Add for explanation of; usage of option. TSortedList(Bool_t order = kSortAscending); { fAscending = order; }. Bool_t IsSorted() const; { return kTRUE; }. void AddFirst(TObject* obj); ---- the following methods are overridden to preserve sorting order. { Add(obj); }. void AddFirst(TObject* obj, Option_t* opt); { Add(obj, opt); }. void AddLast(TObject* obj); { Add(obj); }. void AddLast(TObject* obj, Option_t* opt)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSortedList.html:9326,cache,cache,9326,root/html528/TSortedList.html,https://root.cern,https://root.cern/root/html528/TSortedList.html,6,['cache'],['cache']
Performance,"ompare(TObjLink* l1, TObjLink* l2); voidTObject::MakeZombie(); virtual TObjLink*TList::NewLink(TObject* obj, TObjLink* prev = NULL); virtual TObjLink*TList::NewOptLink(TObject* obj, Option_t* opt, TObjLink* prev = NULL); virtual voidTCollection::PrintCollectionEntry(TObject* entry, Option_t* option, Int_t recurse) const; virtual voidTCollection::PrintCollectionHeader(Option_t* option) const. Data Members; public:. enum TCollection::[unnamed] { kIsOwner; kInitCapacity; kInitHashTableCapacity; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_tTList::fAscending! sorting order (when calling Sort() or for TSortedList); TObjLink*TList::fCache! cache to speedup sequential calling of Before() and After() functions; TObjLink*TList::fFirst! pointer to first entry in linked list; TObjLink*TList::fLast! pointer to last entry in linked list; TStringTCollection::fNamename of the collection; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted. private:. TList*fDontShowlist of reg expression defining what should not be shown. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofOutputList(const char* dontshow = ""PROOF_*""); Constructor. ~TProofOutputList(); Destructor. void AttachList(TList* alist); Attach to list 'alist'. void ls(Option_t* option = """") const; List the content of the list. void Print(Option_t* option = """") const; Print the content of the list. TProofOutputList(const char* dontshow = ""PROOF_*""). void Print(Option_t* option = """") const. void Print(Option_t* option, Int_t recurse) const; { TCollection::Print(option, recurse); }. void Print(Option_t* option, const char* wildcard, Int_t recurse = 1) const; { TCollection::Print(option, wildc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TProofOutputList.html:9651,cache,cache,9651,root/html530/TProofOutputList.html,https://root.cern,https://root.cern/root/html530/TProofOutputList.html,5,['cache'],['cache']
Performance,"ompilation of ROOT was necessary, setting the required compiler flags.; Now, RooFit comes with dedicated computation libraries, each compiled for a specific CPU architecture. When RooFit is loaded for the first time, ROOT inspects the CPU capabilities, and loads the fastest supported version of this computation library. This means that RooFit can now use vector extensions such as AVX2 without being recompiled, which enables a speed up of up to 4x for certain computations. Combined with better data access patterns (~3x speed up, ROOT 6.20), computations with optimised PDFs speed up between 4x and 16x.; The fast BatchMode now also works in combination with multi processing (NumCPU) and with binned data (RooDataHist).; See Demo notebook in SWAN, EPJ Web Conf. 245 (2020) 06007, arxiv:2012.02746.; RooBatchCompute Library; The library that contains the optimised computation functions is called RooBatchCompute. The PDFs contained in this library are highly optimized, and there is currently work in progress for further optimization using CUDA and multi-threaded computations. If you use PDFs that are not part of the official RooFit, you are very well invited to add them to RooFit by submitting a ticket or a pull request.; Benefiting from batch computations by overriding evaluateSpan(); For PDFs that are not part of RooFit, it is possible to benefit from batch computations without vector extensions. To do so, consult the RooBatchCompute readme.; Migrating PDFs that override the deprecated evaluateBatch(); In case you have created a custom PDF which overrides evaluateBatch(), please follow these steps to update your code to the newest version:. Change the signature of the function both in the source and header file:. - RooSpan<double> RooGaussian::evaluateBatch(std::size_t begin, std::size_t batchSize) const; + RooSpan<double> evaluateSpan(RooBatchCompute::RunContext& evalData, const RooArgSet* normSet) const. Include RunContext.h and BracketAdapter.h.; Use getValues() instead",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v624/release-notes.html:18610,optimiz,optimized,18610,doc/v624/release-notes.html,https://root.cern,https://root.cern/doc/v624/release-notes.html,3,"['multi-thread', 'optimiz']","['multi-threaded', 'optimization', 'optimized']"
Performance,"ompiledCollectionProxy; kMismatch; kClassMismatch; kMatch; kMatchConversion; kMatchConversionCollection; kMakeClass; kVoidPtr; kNoCheck; };; enum TTree::[unnamed] { kForceRead; kCircular; kSplitCollectionOfPointers; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TList*TTree::fAliasesList of aliases for expressions based on the tree branches.; Long64_tTTree::fAutoFlushAutoflush tree when fAutoFlush entries written or -fAutoFlush (compressed) bytes produced; Long64_tTTree::fAutoSaveAutosave tree when fAutoSave entries written or -fAutoSave (compressed) bytes produced; TBranchRef*TTree::fBranchRefBranch supporting the TRefTable (if any); TObjArrayTTree::fBranchesList of Branches; Bool_tTTree::fCacheDoAutoInit! true if cache auto creation or resize check is needed; Long64_tTTree::fCacheSize! Maximum size of file buffers; Bool_tTTree::fCacheUserSet! true if the cache setting was explicitly given by user; Bool_tfCanDeleteRefs! If true, TProcessIDs are deleted when closing a file; Long64_tTTree::fChainOffset! Offset of 1st entry of this Tree in a TChain; TList*TTree::fClones! List of cloned trees which share our addresses; Long64_t*TTree::fClusterRangeEnd[fNClusterRange] Last entry of a cluster range.; Long64_t*TTree::fClusterSize[fNClusterRange] Number of entries in each cluster for a given range.; Int_tTTree::fDebug! Debug level; Long64_tTTree::fDebugMax! Last entry number to debug; Long64_tTTree::fDebugMin! First entry number to debug; Int_tTTree::fDefaultEntryOffsetLenInitial Length of fEntryOffset table in the basket buffers; TDirectory*TTree::fDirectory! Pointer to directory holding this tree; Long64_tTTree::fEntriesNumber of entries; TEntryList*TTree::fEntryList! Pointer to event selection list (if one); Long64_tTTree::fEstimateNumber of entries to",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TChain.html:23304,cache,cache,23304,root/html534/TChain.html,https://root.cern,https://root.cern/root/html534/TChain.html,4,['cache'],['cache']
Performance,"ompletely different from TTreeCache::ResetCache(),; in that method we were cleaning the prefetching buffer while here we; delete the information about the unzipped buffers. Int_t GetUnzipBuffer(char** buf, Long64_t pos, Int_t len, Bool_t* free); We try to read a buffer that has already been unzipped; Returns -1 in case of read failure, 0 in case it's not in the; cache and n>0 in case read from cache (number of bytes copied).; pos and len are the original values as were passed to ReadBuffer; but instead we will return the inflated buffer.; Note!! : If *buf == 0 we will allocate the buffer and it will be the; responsability of the caller to free it... it is useful for example; to pass it to the creator of TBuffer. void SetUnzipRelBufferSize(Float_t relbufferSize); static function: Sets the unzip relatibe buffer size; FABRIZIO: PLEASE DOCUMENT and also in TTree::Set... void SetUnzipBufferSize(Long64_t bufferSize); Sets the size for the unzipping cache... by default it should be; two times the size of the prefetching cache. Int_t UnzipBuffer(char** dest, char* src); UNzips a ROOT specific buffer... by reading the header at the beginning.; returns the size of the inflated buffer or -1 if error; Note!! : If *dest == 0 we will allocate the buffer and it will be the; responsability of the caller to free it... it is useful for example; to pass it to the creator of TBuffer; src is the original buffer with the record (header+compressed data); *dest is the inflated buffer (including the header). Int_t UnzipCache(Int_t& startindex, Int_t& locbuffsz, char*& locbuff); This inflates all the buffers in the cache.. passing the data to a new; buffer that will only wait there to be read...; We can not inflate all the buffers in the cache so we will try to do; it until the cache gets full... there is a member called fUnzipBufferSize which will; tell us the max size we can allocate for this cache. note that we will unzip in the order they were put into the cache not; the order of the tra",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreeCacheUnzip.html:17303,cache,cache,17303,root/html528/TTreeCacheUnzip.html,https://root.cern,https://root.cern/root/html528/TTreeCacheUnzip.html,10,['cache'],['cache']
Performance,"omplexErrFuncIm(const RooComplex& z, Int_t nOrder); static Double_tITPComplexErrFuncRe(const RooComplex& z, Int_t nOrder); RooMath&operator=(const RooMath&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. static const char*cacheFileName(); static voidinitFastCERF(Int_t reBins = 800, Double_t reMin = -4.0, Double_t reMax = 4.0, Int_t imBins = 1000, Double_t imMin = -4.0, Double_t imMax = 6.0); static Bool_tloadCache(); static voidstoreCache(). Data Members; private:. static Bool_t_cacheTableSwitch activating use of file cache for CERF-LUT; static Int_t_imBinsNumber of grid points in imaginary dimension of CERF-LUT ; static double**_imCerfArrayLookup table for Im part of complex error function; static Double_t_imMaxHigh edge of imaginary dimension of CERF-LUT; static Double_t_imMinLow edge of imaginary dimension of CERF-LUT; static Double_t_imRangeRange in imaginary dimension of CERF-LUT; static Double_t_imStepGrid spacing in imaginary dimension of CERF-LUT; static Int_t_reBinsNumber of grid points in real dimension of CERF-LUT; static double**_reCerfArrayLookup table for Re part of complex error function; static Double_t_reMaxHigh edge of real dimension of CERF-LUT; static Double_t_reMinLow edge of real dimension of CERF-LUT; static Double_t_reRangeRange in real dimension of CERF-LUT; static Double_t_reStepGrid spacing in real dimension of CERF-LUT. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooComplex FastComplexErrFunc(const RooComplex& z). Double_t FastComplexErrFuncRe(const RooComplex& z). Double_t FastComplexErrFuncIm(const RooComplex& z). void cacheCERF(Bool_t flag = kTRUE). RooComplex ComplexErrFunc(Double_t re, Double_t im = 0); Return CERNlib complex error function for Z(re,im). RooComplex ComplexErrFunc(const RooComplex& z); Return CERNlib complex error function. This code is translated from the fortran version in the CERN mathlib.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooMath.html:1680,cache,cache,1680,root/html528/RooMath.html,https://root.cern,https://root.cern/root/html528/RooMath.html,4,['cache'],['cache']
Performance,"omponents inside as for any volume:; TGeoVolume *vol = new TGeoVolumeAssembly(name);; vol->AddNode(vdaughter1, cpy1, matrix1);; vol->AddNode(vdaughter2, cpy2, matrix2);; namechar name[80]Definition TGX11.cxx:110; TGeoVolumeAssemblyVolume assemblies.Definition TGeoVolume.h:316; Note that components cannot be declared as ""overlapping"" and that a component can be an assembly volume. For existing flat volume structures, one can define assemblies to force a hierarchical structure therefore optimizing the performance. Usage of assemblies does NOT imply penalties in performance, but in some cases, it can be observed that it is not as performing as bounding the structure in a container volume with a simple shape. Choosing a normal container is therefore recommended whenever possible. Assemblies of volumes. Geometrical Transformations; All geometrical transformations handled by the modeller are provided as a built-in package. This was designed to minimize memory requirements and optimize performance of point/vector master-to-local and local-to-master computation. We need to have in mind that a transformation in **TGeo** has two major use-cases. The first one is for defining the placement of a volume with respect to its container reference frame. This frame will be called 'master' and the frame of the positioned volume - 'local'. If T is a transformation used for positioning volume daughters, then: MASTER = T * LOCAL; Therefore Tis used to perform a local to master conversion, while T-1 for a master to local conversion. The second use case is the computation of the global transformation of a given object in the geometry. Since the geometry is built as 'volumes-inside-volumes', the global transformation represents the pile-up of all local transformations in the corresponding branch. Once a given object in the hierarchy becomes the current one, the conversion from master to local coordinates or the other way around can be done from the manager class.; A general homogenous trans",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:53414,optimiz,optimize,53414,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,2,"['optimiz', 'perform']","['optimize', 'performance']"
Performance,"ompression level but slower and might use more memory.; (For the currently supported algorithms, the maximum level is 9); If compress is negative it indicates the compression level is not set yet. The enumeration ROOT::ECompressionAlgorithm associates each; algorithm with a number. There is a utility function to help; to set the value of the argument. For example,; ROOT::CompressionSettings(ROOT::kLZMA, 1); will build an integer which will set the compression to use; the LZMA algorithm and compression level 1. These are defined; in the header file Compression.h. Note that the compression settings may be changed at any time.; The new compression settings will only apply to branches created; or attached after the setting is changed and other objects written; after the setting is changed. void SetCacheRead(TFileCacheRead* cache); Set a pointer to the read cache.; NOTE: This relinquish ownership of the previous cache, so if you do not; already have a pointer to the previous cache (and there was a previous; cache), you ought to retrieve (and delete it if needed) using:; TFileCacheRead *older = myfile->GetCacheRead();. void SetCacheWrite(TFileCacheWrite* cache); Set a pointer to the write cache.; If file is null the existing write cache is deleted. Int_t Sizeof() const; Return the size in bytes of the file header. void Streamer(TBuffer& b); Stream a TFile object. void SumBuffer(Int_t bufsize); Increment statistics for buffer sizes of objects in this file. void UseCache(Int_t maxCacheSize = 10, Int_t pageSize = 0); Dummy function kept for backward compatibility.; The read cache is now managed by TFileCacheRead; The write cache is now managed by TFileCacheWrite; Both caches are created automatically by the system. Int_t Write(const char* name = 0, Int_t opt = 0, Int_t bufsiz = 0); Write memory objects to this file.; Loop on all objects in memory (including subdirectories).; A new key is created in the KEYS linked list for each object.; The list of keys is then saved on the f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TFile.html:38740,cache,cache,38740,root/html530/TFile.html,https://root.cern,https://root.cern/root/html530/TFile.html,9,['cache'],['cache']
Performance,"omputes the closest distance to any boundary. Random points; A method to check the validity of a given geometry is shooting random points. This can be called with the method TGeoVolume::RandomPoints() and it draws a volume with the current visualization settings. Random points are generated in the bounding box of the drawn volume. The points are drawn with the color of their deepest container. Only points inside visible nodes are drawn. Random rays; A ray tracing method can be called TGeoVolume::RandomRays(). This shoots rays from a given point in the local reference frame with random directions. The intersections with displayed nodes appear as segments having the color of the touched node. The Drawing Package. The modeller provides a powerful drawing package, supporting several different options of visualization. A library separated from the main one provides all functionality being linked with the underlying ROOT visualization system. This library is dynamically loaded by the plug-in manager only when drawing features are requested. The geometrical structures that can be visualized are volumes and volume hierarchies.; The main component of the visualization system is volume primitive painting in a ROOT pad. Starting from this one, several specific options or subsystems are available, like: X3D viewing using hidden line and surface removal algorithms, OpenGL viewing* or ray tracing.; The method TGeoManager::GetGeomPainter() loads the painting library in memory.; This is generally not needed since it is called automatically by TGeoVolume::Draw() as well as by few other methods setting visualization attributes. Drawing Volumes and Hierarchies of Volumes; The first thing one would like to do after building some geometry is to visualize the volume tree. This provides the fastest validation check for most common coding or design mistakes. As soon as the geometry is successfully closed, one should draw it starting from the top-level volume:; //... code for geometry build",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:105770,load,loaded,105770,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['load'],['loaded']
Performance,"on & RooNumConvPdf::conv ; (; ); const. inlineprotected . Definition at line 63 of file RooNumConvPdf.h. ◆ convIntConfig(). RooNumIntConfig & RooNumConvPdf::convIntConfig ; (; ). inline . Definition at line 42 of file RooNumConvPdf.h. ◆ DeclFileName(). static const char * RooNumConvPdf::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 78 of file RooNumConvPdf.h. ◆ evaluate(). double RooNumConvPdf::evaluate ; (; ); const. overridevirtual . Calculate and return value of p.d.f. ; Implements RooAbsReal.; Definition at line 136 of file RooNumConvPdf.cxx. ◆ genContext(). RooAbsGenContext * RooNumConvPdf::genContext ; (; const RooArgSet & ; vars, . const RooDataSet * ; prototype = nullptr, . const RooArgSet * ; auxProto = nullptr, . bool ; verbose = false . ); const. overrideprotectedvirtual . Return appropriate generator context for this convolved p.d.f. ; If both pdf and resolution model support internal generation return and optimization convolution generation context that uses a smearing algorithm. Otherwise return a standard accept/reject sampling context on the convoluted shape. ; Reimplemented from RooAbsPdf.; Definition at line 168 of file RooNumConvPdf.cxx. ◆ initialize(). void RooNumConvPdf::initialize ; (; ); const. protected . One-time initialization of object. ; Definition at line 148 of file RooNumConvPdf.cxx. ◆ IsA(). TClass * RooNumConvPdf::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from RooAbsPdf.; Definition at line 78 of file RooNumConvPdf.h. ◆ model(). RooAbsReal & RooNumConvPdf::model ; (; ); const. inline . Definition at line 54 of file RooNumConvPdf.h. ◆ pdf(). RooAbsReal & RooNumConvPdf::pdf ; (; ); const. inline . Definition at line 53 of file RooNumConvPdf.h. ◆ printMetaArgs(). void RooNumConvPdf::printMetaArgs ; (; std::ostream & ; os); const. overridevirtual . Customized printing of arguments of a RooNumConvPdf to more intuiti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooNumConvPdf.html:78998,optimiz,optimization,78998,doc/master/classRooNumConvPdf.html,https://root.cern,https://root.cern/doc/master/classRooNumConvPdf.html,1,['optimiz'],['optimization']
Performance,"on * TROOT::GetGlobalFunction ; (; const char * ; function, . const char * ; params = nullptr, . Bool_t ; load = kFALSE . ). Return pointer to global function by name. ; If params != 0 it will also resolve overloading other it returns the first name match. If params == 0 and load is true force reading of all currently defined global functions from Cling. The param string must be of the form: ""3189,\""aap\"",1.3"". ; Definition at line 1685 of file TROOT.cxx. ◆ GetGlobalFunctions(). TListOfFunctions * TROOT::GetGlobalFunctions ; (; ). protected . Internal routine returning, and creating if necessary, the list of global function. ; Definition at line 1663 of file TROOT.cxx. ◆ GetGlobalFunctionWithPrototype(). TFunction * TROOT::GetGlobalFunctionWithPrototype ; (; const char * ; function, . const char * ; proto = nullptr, . Bool_t ; load = kFALSE . ). Return pointer to global function by name. ; If proto != 0 it will also resolve overloading. If load is true force reading of all currently defined global functions from CINT (more expensive). The proto string must be of the form: ""int, char*, float"". ; Definition at line 1718 of file TROOT.cxx. ◆ GetIconPath(). const TString & TROOT::GetIconPath ; (; ). static . Get the icon path in the installation. Static utility function. ; Definition at line 3168 of file TROOT.cxx. ◆ GetIncludeDir(). const TString & TROOT::GetIncludeDir ; (; ). static . Get the include directory in the installation. Static utility function. ; Definition at line 3042 of file TROOT.cxx. ◆ GetInterpreter(). TInterpreter * TROOT::GetInterpreter ; (; ); const. inline . Definition at line 210 of file TROOT.h. ◆ GetLibDir(). const TString & TROOT::GetLibDir ; (; ). static . Get the library directory in the installation. Static utility function. ; Definition at line 3010 of file TROOT.cxx. ◆ GetListOfBrowsables(). TList * TROOT::GetListOfBrowsables ; (; ); const. inline . Definition at line 258 of file TROOT.h. ◆ GetListOfBrowsers(). TSeqCollection * TROOT::Get",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTROOT.html:53737,load,load,53737,doc/v632/classTROOT.html,https://root.cern,https://root.cern/doc/v632/classTROOT.html,1,['load'],['load']
Performance,"on * TROOT::GetGlobalFunction ; (; const char * ; function, . const char * ; params = nullptr, . Bool_t ; load = kFALSE . ). Return pointer to global function by name. ; If params != 0 it will also resolve overloading other it returns the first name match. If params == 0 and load is true force reading of all currently defined global functions from Cling. The param string must be of the form: ""3189,\""aap\"",1.3"". ; Definition at line 1685 of file TROOT.cxx. ◆ GetGlobalFunctions(). TListOfFunctions * TROOT::GetGlobalFunctions ; (; ). protected . Internal routine returning, and creating if necessary, the list of global function. ; Definition at line 1663 of file TROOT.cxx. ◆ GetGlobalFunctionWithPrototype(). TFunction * TROOT::GetGlobalFunctionWithPrototype ; (; const char * ; function, . const char * ; proto = nullptr, . Bool_t ; load = kFALSE . ). Return pointer to global function by name. ; If proto != 0 it will also resolve overloading. If load is true force reading of all currently defined global functions from CINT (more expensive). The proto string must be of the form: ""int, char*, float"". ; Definition at line 1718 of file TROOT.cxx. ◆ GetIconPath(). const TString & TROOT::GetIconPath ; (; ). static . Get the icon path in the installation. Static utility function. ; Definition at line 3172 of file TROOT.cxx. ◆ GetIncludeDir(). const TString & TROOT::GetIncludeDir ; (; ). static . Get the include directory in the installation. Static utility function. ; Definition at line 3046 of file TROOT.cxx. ◆ GetInterpreter(). TInterpreter * TROOT::GetInterpreter ; (; ); const. inline . Definition at line 210 of file TROOT.h. ◆ GetLibDir(). const TString & TROOT::GetLibDir ; (; ). static . Get the library directory in the installation. Static utility function. ; Definition at line 3014 of file TROOT.cxx. ◆ GetListOfBrowsables(). TList * TROOT::GetListOfBrowsables ; (; ); const. inline . Definition at line 258 of file TROOT.h. ◆ GetListOfBrowsers(). TSeqCollection * TROOT::Get",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTROOT.html:53706,load,load,53706,doc/master/classTROOT.html,https://root.cern,https://root.cern/doc/master/classTROOT.html,1,['load'],['load']
Performance,"on * fStylesList of styles.Definition TROOT.h:150; TROOT::GetListOfProofsTSeqCollection * GetListOfProofs() constDefinition TROOT.h:253; TROOT::GetEditHistogramsBool_t GetEditHistograms() constDefinition TROOT.h:218; TROOT::fVersionDateInt_t fVersionDateDate of ROOT version (ex 951226)Definition TROOT.h:116; TROOT::GetListOfColorsTSeqCollection * GetListOfColors() constDefinition TROOT.h:232; TROOT::MacroLongptr_t Macro(const char *filename, Int_t *error=nullptr, Bool_t padUpdate=kTRUE)Execute a macro in the interpreter.Definition TROOT.cxx:2316; TROOT::fBuiltTimeInt_t fBuiltTimeTime of ROOT built.Definition TROOT.h:119; TROOT::AddExtraInterpreterArgsstatic const std::vector< std::string > & AddExtraInterpreterArgs(const std::vector< std::string > &args)Provide command line arguments to the interpreter construction.Definition TROOT.cxx:2952; TROOT::SetLineHasBeenProcessedvoid SetLineHasBeenProcessed()Definition TROOT.h:329; TROOT::GetClassTClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE) constReturn pointer to class with name. Obsolete, use TClass::GetClass directly.Definition TROOT.cxx:1518; TROOT::fSelectPadTVirtualPad * fSelectPadCurrently selected pad.Definition TROOT.h:139; TROOT::fFilesTSeqCollection * fFilesList of files.Definition TROOT.h:146; TROOT::Browsevoid Browse(TBrowser *b) overrideAdd browsable objects to TBrowser.Definition TROOT.cxx:1056; TROOT::GetRootSysstatic const TString & GetRootSys()Get the rootsys directory in the installation. Static utility function.Definition TROOT.cxx:2979; TROOT::GetGlobalFunctionsTListOfFunctions * GetGlobalFunctions()Internal routine returning, and creating if necessary, the list of global function.Definition TROOT.cxx:1663; TROOT::fInterruptBool_t fInterruptTrue if macro should be interrupted.Definition TROOT.h:134; TROOT::fMustCleanBool_t fMustCleanTrue if object destructor scans canvases.Definition TROOT.h:132; TROOT::LoadClassInt_t LoadClass(const char *classname, const char *libname, B",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TROOT_8h_source.html:42228,load,load,42228,doc/v632/TROOT_8h_source.html,https://root.cern,https://root.cern/doc/v632/TROOT_8h_source.html,1,['load'],['load']
Performance,"on * fStylesList of styles.Definition TROOT.h:150; TROOT::GetListOfProofsTSeqCollection * GetListOfProofs() constDefinition TROOT.h:253; TROOT::GetEditHistogramsBool_t GetEditHistograms() constDefinition TROOT.h:218; TROOT::fVersionDateInt_t fVersionDateDate of ROOT version (ex 951226)Definition TROOT.h:116; TROOT::GetListOfColorsTSeqCollection * GetListOfColors() constDefinition TROOT.h:232; TROOT::MacroLongptr_t Macro(const char *filename, Int_t *error=nullptr, Bool_t padUpdate=kTRUE)Execute a macro in the interpreter.Definition TROOT.cxx:2316; TROOT::fBuiltTimeInt_t fBuiltTimeTime of ROOT built.Definition TROOT.h:119; TROOT::AddExtraInterpreterArgsstatic const std::vector< std::string > & AddExtraInterpreterArgs(const std::vector< std::string > &args)Provide command line arguments to the interpreter construction.Definition TROOT.cxx:2956; TROOT::SetLineHasBeenProcessedvoid SetLineHasBeenProcessed()Definition TROOT.h:329; TROOT::GetClassTClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE) constReturn pointer to class with name. Obsolete, use TClass::GetClass directly.Definition TROOT.cxx:1518; TROOT::fSelectPadTVirtualPad * fSelectPadCurrently selected pad.Definition TROOT.h:139; TROOT::fFilesTSeqCollection * fFilesList of files.Definition TROOT.h:146; TROOT::Browsevoid Browse(TBrowser *b) overrideAdd browsable objects to TBrowser.Definition TROOT.cxx:1056; TROOT::GetRootSysstatic const TString & GetRootSys()Get the rootsys directory in the installation. Static utility function.Definition TROOT.cxx:2983; TROOT::GetGlobalFunctionsTListOfFunctions * GetGlobalFunctions()Internal routine returning, and creating if necessary, the list of global function.Definition TROOT.cxx:1663; TROOT::fInterruptBool_t fInterruptTrue if macro should be interrupted.Definition TROOT.h:134; TROOT::fMustCleanBool_t fMustCleanTrue if object destructor scans canvases.Definition TROOT.h:132; TROOT::LoadClassInt_t LoadClass(const char *classname, const char *libname, B",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8h_source.html:42227,load,load,42227,doc/master/TROOT_8h_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8h_source.html,1,['load'],['load']
Performance,"on = """")MENU ; virtual voidTNamed::ls(Option_t* option = """") const; static TGeoVolumeAssembly*MakeAssemblyFromVolume(TGeoVolume* vol); voidTGeoVolume::MakeCopyNodes(const TGeoVolume* other); virtual TGeoVolume*TGeoVolume::MakeCopyVolume(TGeoShape* newshape); TGeoVolume*TGeoVolume::MakeReflectedVolume(const char* newname = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTAttLine::Modify(); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoVolumeAssembly&operator=(const TGeoVolumeAssembly&); Bool_tTGeoVolume::OptimizeVoxels()MENU ; virtual voidTGeoVolume::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTGeoVolume::Print(Option_t* option = """") constMENU ; voidTGeoVolume::PrintNodes() const; voidTGeoVolume::PrintVoxels() constMENU ; voidTGeoVolume::RandomPoints(Int_t npoints = 1000000, Option_t* option = """")MENU ; voidTGeoVolume::RandomRays(Int_t nrays = 10000, Double_t startx = 0, Double_t starty = 0, Double_t startz = 0, const char* target_vol = 0, Bool_t check_norm = kFALSE)MENU ; voidTGeoVolume::Raytrace(Bool_t flag = kTRUE)TOGGLE GETTER ; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTGeoVolume::RegisterYourself(Option_t* option = """"); voidTGeoVolume::Release(); voidTGeoVolume::RemoveNode(TGeoNode* node); TGeoNode*TGeoVolume::ReplaceNode(TGeoNode* nodeorig, TGeoShape* newshape = 0, TGeoMatrix* newpos = 0, TGeoMedium* newmed = 0); voidTGeoVolume::ReplayCreation(const TGeoVolume* other); voidTGeoAtt::ResetAttBit(UInt_t f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoVolumeAssembly.html:25842,Optimiz,OptimizeVoxels,25842,root/html602/TGeoVolumeAssembly.html,https://root.cern,https://root.cern/root/html602/TGeoVolumeAssembly.html,2,['Optimiz'],['OptimizeVoxels']
Performance,"on Members (Methods); public:. RooObjCacheManager(const RooObjCacheManager& other, RooAbsArg* owner = 0); RooObjCacheManager(RooAbsArg* owner = 0, Int_t maxSize = 10, Bool_t clearCacheOnServerRedirect = kTRUE); virtual~RooObjCacheManager(); Int_tRooCacheManager<RooAbsCacheElement>::cacheSize() const; static TClass*Class(); static Bool_tclearObsList(); static voiddoClearObsList(Bool_t flag); virtual voidfindConstantNodes(const RooArgSet&, RooArgSet&, RooLinkedList&); RooAbsCacheElement*RooCacheManager<RooAbsCacheElement>::getObj(const RooArgSet* nset, Int_t* sterileIndex = 0, const TNamed* isetRangeName = 0); RooAbsCacheElement*RooCacheManager<RooAbsCacheElement>::getObj(const RooArgSet* nset, const RooArgSet* iset, Int_t* sterileIdx = 0, const TNamed* isetRangeName = 0); RooAbsCacheElement*RooCacheManager<RooAbsCacheElement>::getObjByIndex(Int_t index) const; virtual voidinsertObjectHook(RooAbsCacheElement&); virtual TClass*IsA() const; Int_tRooCacheManager<RooAbsCacheElement>::lastIndex() const; const RooNameSet*RooCacheManager<RooAbsCacheElement>::nameSet1ByIndex(Int_t index) const; const RooNameSet*RooCacheManager<RooAbsCacheElement>::nameSet2ByIndex(Int_t index) const; RooObjCacheManager&operator=(const RooObjCacheManager&); virtual voidoperModeHook(); virtual voidoptimizeCacheMode(const RooArgSet&, RooArgSet&, RooLinkedList&); virtual voidprintCompactTreeHook(ostream&, const char*); virtual Bool_tredirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooCacheManager<RooAbsCacheElement>::reset(); Int_tRooCacheManager<RooAbsCacheElement>::setObj(const RooArgSet* nset, RooAbsCacheElement* obj, const TNamed* isetRangeName = 0); Int_tRooCacheManager<RooAbsCacheElement>::setObj(const RooArgSet* nset, const RooArgSet* iset, RooAbsCacheElement* obj, const TNamed* isetRangeName = 0); virtual voidShowMembers(TMemberInspector& insp); virtual voidsterilize(); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; protected:. sta",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooObjCacheManager.html:1167,cache,cacheSize,1167,root/html530/RooObjCacheManager.html,https://root.cern,https://root.cern/root/html530/RooObjCacheManager.html,1,['cache'],['cacheSize']
Performance,"on REveElement.cxx:855; ROOT::Experimental::REveGeoTopNodeDataDefinition REveGeoTopNode.hxx:17; ROOT::Experimental::REveGeoTopNodeVizDefinition REveGeoTopNode.hxx:40; ROOT::Experimental::REveManager::GetEventSceneREveScene * GetEventScene() constDefinition REveManager.hxx:184; ROOT::Experimental::REveManager::SpawnNewSceneREveScene * SpawnNewScene(const char *name, const char *title="""")Create a new scene.Definition REveManager.cxx:239; ROOT::Experimental::REveManager::SpawnNewViewerREveViewer * SpawnNewViewer(const char *name, const char *title="""")Create a new GL viewer.Definition REveManager.cxx:229; ROOT::Experimental::REveManager::Showvoid Show(const RWebDisplayArgs &args="""")Show eve manager in specified browser.Definition REveManager.cxx:1169; ROOT::Experimental::REveViewer::AddScenevirtual void AddScene(REveScene *scene)Add 'scene' to the list of scenes.Definition REveViewer.cxx:58; R; TFile::SetCacheFileDirstatic Bool_t SetCacheFileDir(std::string_view cacheDir, Bool_t operateDisconnected=kTRUE, Bool_t forceCacheread=kFALSE)Sets the directory where to locally stage/cache remote files.Definition TFile.cxx:4626; TGeoArb8Definition TGeoArb8.h:17; TGeoArb8::SetVertexvirtual void SetVertex(Int_t vnum, Double_t x, Double_t y); TGeoCombiTransClass describing rotation + translation.Definition TGeoMatrix.h:317; TGeoManagerThe manager class for any TGeo geometry.Definition TGeoManager.h:44; TGeoManager::MakeArb8TGeoVolume * MakeArb8(const char *name, TGeoMedium *medium, Double_t dz, Double_t *vertices=nullptr)Make an TGeoArb8 volume.Definition TGeoManager.cxx:3161; TGeoManager::Importstatic TGeoManager * Import(const char *filename, const char *name="""", Option_t *option="""")static function Import a geometry from a gdml or ROOT fileDefinition TGeoManager.cxx:4096; TGeoManager::CloseGeometryvoid CloseGeometry(Option_t *option=""d"")Closing geometry implies checking the geometry validity, fixing shapes with negative parameters (run-...Definition TGeoManager.cxx:1480; TGeoMana",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/eveGeoBrowser_8C_source.html:9430,cache,cacheDir,9430,doc/master/eveGeoBrowser_8C_source.html,https://root.cern,https://root.cern/doc/master/eveGeoBrowser_8C_source.html,2,['cache'],"['cache', 'cacheDir']"
Performance,"on RooAbsArg.cxx:2154; RooAbsArg::printMultilinevoid printMultiline(std::ostream &os, Int_t contents, bool verbose=false, TString indent="""") const overrideImplement multi-line detailed printing.Definition RooAbsArg.cxx:1589; RooAbsArg::cloneTreevirtual RooAbsArg * cloneTree(const char *newname=nullptr) constClone tree expression of objects.Definition RooAbsArg.cxx:2293; RooAbsArg::cleanBranchNameTString cleanBranchName() constConstruct a mangled name from the actual name that is free of any math symbols that might be interpre...Definition RooAbsArg.cxx:2075; RooAbsArg::numProxiesInt_t numProxies() constReturn the number of registered proxies.Definition RooAbsArg.cxx:1457; RooAbsArg::_inhibitDirtystatic bool _inhibitDirtyDefinition RooAbsArg.h:668; RooAbsArg::setAttributevoid setAttribute(const Text_t *name, bool value=true)Set (default) or clear a named boolean attribute of this object.Definition RooAbsArg.cxx:222; RooAbsArg::setProxyNormSetvoid setProxyNormSet(const RooArgSet *nset)Forward a change in the cached normalization argset to all the registered proxies.Definition RooAbsArg.cxx:1468; RooAbsArg::branchNodeServerListvoid branchNodeServerList(RooAbsCollection *list, const RooAbsArg *arg=nullptr, bool recurseNonDerived=false) constFill supplied list with all branch nodes of the arg tree starting with ourself as top node.Definition RooAbsArg.cxx:483; RooAbsArg::getProxyRooAbsProxy * getProxy(Int_t index) constReturn the nth proxy from the proxy list.Definition RooAbsArg.cxx:1444; RooAbsArg::CloneTObject * Clone(const char *newname=nullptr) const overrideMake a clone of an object using the Streamer facility.Definition RooAbsArg.h:91; RooAbsArg::_serverListRefCountList_t _serverListDefinition RooAbsArg.h:606; RooAbsArg::leafNodeServerListvoid leafNodeServerList(RooAbsCollection *list, const RooAbsArg *arg=nullptr, bool recurseNonDerived=false) constFill supplied list with all leaf nodes of the arg tree, starting with ourself as top node.Definition RooAbsArg.cxx:4",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8cxx_source.html:206372,cache,cached,206372,doc/master/RooAbsReal_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html,1,['cache'],['cached']
Performance,"on RooDataSet.h:33; RooExtendPdfRooExtendPdf is a wrapper around an existing PDF that adds a parameteric extended likelihood term to ...Definition RooExtendPdf.h:22; RooFitResultRooFitResult is a container class to hold the input and output of a PDF fit to a dataset.Definition RooFitResult.h:40; RooFit::Detail::CompileContextDefinition NormalizationHelpers.h:29; RooLinkedListCollection class for internal use, storing a collection of RooAbsArg pointers in a doubly linked list...Definition RooLinkedList.h:44; RooMCStudyHelper class to facilitate Monte Carlo studies such as 'goodness-of-fit' studies, that involve fittin...Definition RooMCStudy.h:32; RooMinimizerWrapper class around ROOT::Math::Minimizer that provides a seamless interface between the minimizer f...Definition RooMinimizer.h:48; RooNumGenConfigHolds the configuration parameters of the various numeric integrators used by RooRealIntegral.Definition RooNumGenConfig.h:25; RooObjCacheManagerImplementation of a RooCacheManager<RooAbsCacheElement> that specializes in the storage of cache elem...Definition RooObjCacheManager.h:29; RooPlotPlot frame and a container for graphics objects within that frame.Definition RooPlot.h:45; RooRealIntegralPerforms hybrid numerical/analytical integrals of RooAbsReal objects.Definition RooRealIntegral.h:29; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TH2F2-D histogram with a float per channel (see TH1 documentation)Definition TH2.h:307; TListA doubly linked list.Definition TList.h:38; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TPaveTextA Pave (see TPave) with text, lines or/and boxes inside.Definition TPaveText.h:21; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::Dataconst char * Data() constDefinition TString.h:376; int; RooFit::NumEventsRooCmdArg NumEvents(Int_t numEvents)Definition RooGlobalFunc.cxx:816; RooFi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsPdf_8h_source.html:36189,cache,cache,36189,doc/master/RooAbsPdf_8h_source.html,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8h_source.html,1,['cache'],['cache']
Performance,"on RooGlobalFunc.cxx:547; RooFit::PrintLevelRooCmdArg PrintLevel(Int_t code)Definition RooGlobalFunc.cxx:657; RooFit::NumCPURooCmdArg NumCPU(Int_t nCPU, Int_t interleave=0)Definition RooGlobalFunc.cxx:474; RooFit::ProjWDataRooCmdArg ProjWData(const RooAbsData &projData, bool binData=false)Definition RooGlobalFunc.cxx:179; RooFit::CutRooCmdArg Cut(const char *cutSpec)Definition RooGlobalFunc.cxx:320; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf603_multicpuDefinition rf603_multicpu.py:1; xmlio::Titleconst char * TitleDefinition TXMLSetup.cxx:68; TimerDefinition histspeedtest.cxx:54; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- Command timer: Real time 0:00:00, CP time 0.140; [#1] INFO:Minimization -- Session timer: Real time 0:00:00, CP time 0.140; [#1] INFO:Minimization -- Command timer: Real time 0:00:00, CP time 0.010; [#1] INFO:Minimization -- Session timer: Real time 0:00:00, CP time 0.150, 2 slices; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsReal::plotOn(model) plot on x averages using data variables (y,z); [#1] INFO:Plotting -- RooAbsReal::plotOn(model) only the following components of the projection data will be used: (y,z); DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf603_multicpu.C. tutorialsroofitrf603_multicpu.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Do",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf603__multicpu_8C.html:6600,optimiz,optimization,6600,doc/master/rf603__multicpu_8C.html,https://root.cern,https://root.cern/doc/master/rf603__multicpu_8C.html,1,['optimiz'],['optimization']
Performance,"on TGeoManager.h:97; TGeoManager::fPaintVolumeTGeoVolume * fPaintVolumeDefinition TGeoManager.h:134; TGeoManager::PopPointBool_t PopPoint(Int_t index)Definition TGeoManager.h:596; TGeoManager::GetSkinSurfaceTGeoSkinSurface * GetSkinSurface(const char *name) constGet skin surface with a given name;.Definition TGeoManager.cxx:2041; TGeoManager::UpdateElementsvoid UpdateElements()Update element flags when geometry is loaded from a file.Definition TGeoManager.cxx:4167; TGeoManager::TGeoManagerTGeoManager()Default constructor.Definition TGeoManager.cxx:311; TGeoManager::fPropertiesConstPropMap_t fPropertiesDefinition TGeoManager.h:149; TGeoManager::MakeTubeTGeoVolume * MakeTube(const char *name, TGeoMedium *medium, Double_t rmin, Double_t rmax, Double_t dz)Make in one step a volume pointing to a tube shape with given medium.Definition TGeoManager.cxx:3204; TGeoManager::CdUpvoid CdUp()Go one level up in geometry.Definition TGeoManager.cxx:1681; TGeoManager::DoBackupStatevoid DoBackupState()Backup the current state without affecting the cache stack.Definition TGeoManager.cxx:1098; TGeoManager::fMaterialsTList * fMaterialsDefinition TGeoManager.h:105; TGeoManager::GetNmanyInt_t GetNmany() constDefinition TGeoManager.h:195; TGeoManager::CheckBoundaryErrorsvoid CheckBoundaryErrors(Int_t ntracks=1000000, Double_t radius=-1.)Check pushes and pulls needed to cross the next boundary with respect to the position given by FindNe...Definition TGeoManager.cxx:3752; TGeoManager::GetGLMatrixTGeoHMatrix * GetGLMatrix() constDefinition TGeoManager.h:497; TGeoManager::fVolumesTObjArray * fVolumesDefinition TGeoManager.h:95; TGeoManager::GetListOfVolumesTObjArray * GetListOfVolumes() constDefinition TGeoManager.h:473; TGeoManager::fValuePNEIdInt_t * fValuePNEIdDefinition TGeoManager.h:143; TGeoManager::GetNextNodeTGeoNode * GetNextNode() constDefinition TGeoManager.h:492; TGeoManager::GetAlignableEntryByUIDTGeoPNEntry * GetAlignableEntryByUID(Int_t uid) constRetrieves an existing alignable ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoManager_8h_source.html:46772,cache,cache,46772,doc/master/TGeoManager_8h_source.html,https://root.cern,https://root.cern/doc/master/TGeoManager_8h_source.html,1,['cache'],['cache']
Performance,"on TGeoPainter.h:60; TGeoPainter::CheckGeometryvoid CheckGeometry(Int_t nrays, Double_t startx, Double_t starty, Double_t startz) const overrideGeometry checking method (see TGeoChecker).Definition TGeoPainter.cxx:226; TGeoPainter::fBombYDouble_t fBombYDefinition TGeoPainter.h:42; TGeoPainter::fPaintingOverlapsBool_t fPaintingOverlapsDefinition TGeoPainter.h:54; TGeoPainter::CheckOverlapsvoid CheckOverlaps(const TGeoVolume *vol, Double_t ovlp=0.1, Option_t *option="""") const overrideCheck overlaps for the top volume of the geometry, within a limit OVLP.Definition TGeoPainter.cxx:234; TGeoPainter::SetBombFactorsvoid SetBombFactors(Double_t bombx=1.3, Double_t bomby=1.3, Double_t bombz=1.3, Double_t bombr=1.3) overrideSet cartesian and radial bomb factors for translations.Definition TGeoPainter.cxx:1949; TGeoPainter::DefaultColorsvoid DefaultColors() overrideSet default volume colors according to tracking media.Definition TGeoPainter.cxx:570; TGeoPainter::CheckEditvoid CheckEdit()Check if Ged library is loaded and load geometry editor classe.Definition TGeoPainter.cxx:682; TGeoPainter::CheckBoundaryErrorsvoid CheckBoundaryErrors(Int_t ntracks=1000000, Double_t radius=-1.) overrideCheck pushes and pulls needed to cross the next boundary with respect to the position given by FindNe...Definition TGeoPainter.cxx:200; TGeoPainter::ClearVisibleVolumesvoid ClearVisibleVolumes()Clear the list of visible volumes reset the kVisOnScreen bit for volumes previously in the list.Definition TGeoPainter.cxx:263; TGeoPainter::GetColorInt_t GetColor(Int_t base, Float_t light) const overrideGet index of a base color with given light intensity (0,1)Definition TGeoPainter.cxx:292; TGeoPainter::LocalToMasterVectvoid LocalToMasterVect(const Double_t *local, Double_t *master) constConvert a local vector according view rotation matrix.Definition TGeoPainter.cxx:1249; TGeoPainter::DrawVolumevoid DrawVolume(TGeoVolume *vol, Option_t *option="""") overrideDraw method.Definition TGeoPainter.cxx:820; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoPainter_8cxx_source.html:101384,load,loaded,101384,doc/master/TGeoPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoPainter_8cxx_source.html,2,['load'],"['load', 'loaded']"
Performance,"on TGeoPainter.h:60; TGeoPainter::CheckGeometryvoid CheckGeometry(Int_t nrays, Double_t startx, Double_t starty, Double_t startz) const overrideGeometry checking method (see TGeoChecker).Definition TGeoPainter.cxx:226; TGeoPainter::fBombYDouble_t fBombYDefinition TGeoPainter.h:42; TGeoPainter::fPaintingOverlapsBool_t fPaintingOverlapsDefinition TGeoPainter.h:54; TGeoPainter::CheckOverlapsvoid CheckOverlaps(const TGeoVolume *vol, Double_t ovlp=0.1, Option_t *option="""") const overrideCheck overlaps for the top volume of the geometry, within a limit OVLP.Definition TGeoPainter.cxx:234; TGeoPainter::SetBombFactorsvoid SetBombFactors(Double_t bombx=1.3, Double_t bomby=1.3, Double_t bombz=1.3, Double_t bombr=1.3) overrideSet cartesian and radial bomb factors for translations.Definition TGeoPainter.cxx:1949; TGeoPainter::DefaultColorsvoid DefaultColors() overrideSet default volume colors according to tracking media.Definition TGeoPainter.cxx:570; TGeoPainter::CheckEditvoid CheckEdit()Check if Ged library is loaded and load geometry editor classe.Definition TGeoPainter.cxx:682; TGeoPainter::GetVisLevelInt_t GetVisLevel() const overrideDefinition TGeoPainter.h:130; TGeoPainter::CheckBoundaryErrorsvoid CheckBoundaryErrors(Int_t ntracks=1000000, Double_t radius=-1.) overrideCheck pushes and pulls needed to cross the next boundary with respect to the position given by FindNe...Definition TGeoPainter.cxx:200; TGeoPainter::ClearVisibleVolumesvoid ClearVisibleVolumes()Clear the list of visible volumes reset the kVisOnScreen bit for volumes previously in the list.Definition TGeoPainter.cxx:263; TGeoPainter::GetColorInt_t GetColor(Int_t base, Float_t light) const overrideGet index of a base color with given light intensity (0,1)Definition TGeoPainter.cxx:292; TGeoPainter::LocalToMasterVectvoid LocalToMasterVect(const Double_t *local, Double_t *master) constConvert a local vector according view rotation matrix.Definition TGeoPainter.cxx:1249; TGeoPainter::DrawVolumevoid DrawVolume(TG",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoPainter_8h_source.html:20197,load,loaded,20197,doc/master/TGeoPainter_8h_source.html,https://root.cern,https://root.cern/doc/master/TGeoPainter_8h_source.html,2,['load'],"['load', 'loaded']"
Performance,"on TROOT.h:284; TROOT::GetGlobalTGlobal * GetGlobal(const char *name, Bool_t load=kFALSE) constReturn pointer to global variable by name.Definition TROOT.cxx:1631; TROOT::FindSTLClassTClass * FindSTLClass(const char *name, Bool_t load, Bool_t silent=kFALSE) constreturn a TClass object corresponding to 'name' assuming it is an STL container.Definition TROOT.cxx:1484; TROOT::fStreamerInfoTSeqCollection * fStreamerInfoList of active StreamerInfo classes.Definition TROOT.h:159; TROOT::Appendvoid Append(TObject *obj, Bool_t replace=kFALSE) overrideAppend object to this directory.Definition TROOT.cxx:1047; TROOT::GetIconPathstatic const TString & GetIconPath()Get the icon path in the installation. Static utility function.Definition TROOT.cxx:3168; TROOT::GetListOfCanvasesTSeqCollection * GetListOfCanvases() constDefinition TROOT.h:240; TROOT::AListOfEnums_tstd::atomic< TListOfEnums * > AListOfEnums_tDefinition TROOT.h:109; TROOT::GetListOfGlobalFunctionsTCollection * GetListOfGlobalFunctions(Bool_t load=kFALSE)Return list containing the TFunctions currently defined.Definition TROOT.cxx:1826; TROOT::fGitDateTString fGitDateDate and time when make was run.Definition TROOT.h:122; TROOT::fSpecialsTSeqCollection * fSpecialsList of special objects.Definition TROOT.h:156; TROOT::GetListOfFunctionTemplatesTCollection * GetListOfFunctionTemplates()Definition TROOT.cxx:1771; TROOT::SetExecutingMacrovoid SetExecutingMacro(Bool_t flag=kTRUE)Definition TROOT.h:324; TROOT::RegisterModulestatic void RegisterModule(const char *modulename, const char **headers, const char **includePaths, const char *payLoadCode, const char *fwdDeclCode, void(*triggerFunc)(), const FwdDeclArgsToKeepCollection_t &fwdDeclsArgToSkip, const char **classesHeaders, bool hasCxxModule=false)Called by static dictionary initialization to register clang modules for headers.Definition TROOT.cxx:2535; TROOT::FindObjectTObject * FindObject(const char *name) const overrideReturns address of a ROOT object if it exists.Def",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TROOT_8h_source.html:34935,load,load,34935,doc/v632/TROOT_8h_source.html,https://root.cern,https://root.cern/doc/v632/TROOT_8h_source.html,1,['load'],['load']
Performance,"on TROOT.h:284; TROOT::GetGlobalTGlobal * GetGlobal(const char *name, Bool_t load=kFALSE) constReturn pointer to global variable by name.Definition TROOT.cxx:1631; TROOT::FindSTLClassTClass * FindSTLClass(const char *name, Bool_t load, Bool_t silent=kFALSE) constreturn a TClass object corresponding to 'name' assuming it is an STL container.Definition TROOT.cxx:1484; TROOT::fStreamerInfoTSeqCollection * fStreamerInfoList of active StreamerInfo classes.Definition TROOT.h:159; TROOT::Appendvoid Append(TObject *obj, Bool_t replace=kFALSE) overrideAppend object to this directory.Definition TROOT.cxx:1047; TROOT::GetIconPathstatic const TString & GetIconPath()Get the icon path in the installation. Static utility function.Definition TROOT.cxx:3172; TROOT::GetListOfCanvasesTSeqCollection * GetListOfCanvases() constDefinition TROOT.h:240; TROOT::AListOfEnums_tstd::atomic< TListOfEnums * > AListOfEnums_tDefinition TROOT.h:109; TROOT::GetListOfGlobalFunctionsTCollection * GetListOfGlobalFunctions(Bool_t load=kFALSE)Return list containing the TFunctions currently defined.Definition TROOT.cxx:1826; TROOT::fGitDateTString fGitDateDate and time when make was run.Definition TROOT.h:122; TROOT::fSpecialsTSeqCollection * fSpecialsList of special objects.Definition TROOT.h:156; TROOT::GetListOfFunctionTemplatesTCollection * GetListOfFunctionTemplates()Definition TROOT.cxx:1771; TROOT::SetExecutingMacrovoid SetExecutingMacro(Bool_t flag=kTRUE)Definition TROOT.h:324; TROOT::RegisterModulestatic void RegisterModule(const char *modulename, const char **headers, const char **includePaths, const char *payLoadCode, const char *fwdDeclCode, void(*triggerFunc)(), const FwdDeclArgsToKeepCollection_t &fwdDeclsArgToSkip, const char **classesHeaders, bool hasCxxModule=false)Called by static dictionary initialization to register clang modules for headers.Definition TROOT.cxx:2535; TROOT::FindObjectTObject * FindObject(const char *name) const overrideReturns address of a ROOT object if it exists.Def",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8h_source.html:34934,load,load,34934,doc/master/TROOT_8h_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8h_source.html,1,['load'],['load']
Performance,"on TVirtualMutex.h:95; ROOT::v5::TFormulaThe FORMULA class (ROOT version 5)Definition TFormula.h:65; ROOT::v5::TFormula::GetParametersvirtual Double_t * GetParameters() constDefinition TFormula.h:243; ROOT::v5::TFormula::GetExpFormulavirtual TString GetExpFormula(Option_t *option="""") constReconstruct the formula expression from the internal TFormula member variables.Definition TFormula_v5.cxx:3022; ROOT::v5::TFormula::Streamervoid Streamer(TBuffer &b, const TClass *onfile_class)Stream a class object.Definition TFormula_v5.cxx:3460; TBufferBuffer base class used for serializing objects.Definition TBuffer.h:43; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClass::GetListOfAllPublicMethodsconst TList * GetListOfAllPublicMethods(Bool_t load=kTRUE)Returns a list of all public methods of this class and its base classes.Definition TClass.cxx:3912; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:3035; TF11-Dim function classDefinition TF1.h:233; TF1::GetFormulavirtual TFormula * GetFormula()Definition TF1.h:481; TFormulaFunctionHelper class for TFormula.Definition TFormula.h:32; TFormulaFunction::fFoundBool_t fFoundDefinition TFormula.h:37; TFormulaFunction::GetNameconst char * GetName() constDefinition TFormula.h:39; TFormulaFunction::GetNargsInt_t GetNargs() constDefinition TFormula.h:41; TFormulaFunction::fNameTString fNameDefinition TFormula.h:34; TFormulaFunction::IsFuncCallBool_t IsFuncCall() constDefinition TFormula.h:42; TFormulaVariableAnother helper class for TFormula.Definition TFormula.h:65; TFormulaVariable::fNameTString fNameDefinition TFormula.h:67; TFormulaVariable::fArrayPosInt_t fArrayPosDefinition TFormula.h:69; TFormulaVariable::fValueDouble_t fValueDefinition TFormula.h:68; TFormulaThe Formula class.Definition TFormula.h:89; TFormula::fHessFuncPtr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFormula_8cxx_source.html:151544,load,load,151544,doc/master/TFormula_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html,1,['load'],['load']
Performance,on Trees ... patience please; : Elapsed time for training with 1000 events: 0.386 sec ; <HEADER> BDT : [dataset] : Evaluation of BDT on training sample (1000 events); : Elapsed time for evaluation of 1000 events: 0.0729 sec ; : Creating xml weight file: dataset/weights/_BDT.weights.xml; : Creating standalone class: dataset/weights/_BDT.class.C; : out.root:/dataset/Method_BDT/BDT; <HEADER> Factory : Training finished; : ; : Ranking input variables (method specific)...; <HEADER> BDT : Ranking result (top variable is best ranked); : -----------------------------------; : Rank : Variable : Variable Importance; : -----------------------------------; : 1 : y : 5.011e-01; : 2 : x : 4.989e-01; : -----------------------------------; <HEADER> Factory : === Destroy and recreate all methods via weight files for testing ===; : ; : Reading weight file: dataset/weights/_BDT.weights.xml; <HEADER> Factory : Test all methods; <HEADER> Factory : Test method: BDT for Classification performance; : ; <HEADER> BDT : [dataset] : Evaluation of BDT on testing sample (1000 events); : Elapsed time for evaluation of 1000 events: 0.0581 sec ; <HEADER> Factory : Evaluate all methods; <HEADER> Factory : Evaluate classifier: BDT; : ; <HEADER> BDT : [dataset] : Loop over test events and fill histograms with classifier response...; : ; <HEADER> TFHandler_BDT : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : x: 1.0136 0.57754 [ 0.0011208 1.9999 ]; : y: 1.4938 0.75135 [ 0.0054384 2.9981 ]; : -----------------------------------------------------------; : ; : Evaluation results ranked by best signal efficiency and purity (area); : -------------------------------------------------------------------------------------------------------------------; : DataSet MVA ; : Name: Method: ROC-integ; : dataset BDT : 0.870; : -------------------------------------------------------------------------------------------------------------------; : ; : Testing efficiency compa,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAMinimalClassification_8C.html:4843,perform,performance,4843,doc/master/TMVAMinimalClassification_8C.html,https://root.cern,https://root.cern/doc/master/TMVAMinimalClassification_8C.html,1,['perform'],['performance']
Performance,"on WrappedMultiTF1.h:114; ROOT::Math::WrappedMultiTF1Templ::CloneIMultiGenFunctionTempl< T > * Clone() const overrideClone the wrapper but not the original function.Definition WrappedMultiTF1.h:86; ROOT::Math::WrappedMultiTF1Templ::SetParametersvoid SetParameters(const double *p) overrideset parameter values (only the cached one in this class,leave unchanges those of TF1)Definition WrappedMultiTF1.h:107; ROOT::Math::WrappedMultiTF1Templ::ParameterGradientvoid ParameterGradient(const T *x, const double *par, T *grad) const overrideEvaluate the all the derivatives (gradient vector) of the function with respect to the parameters at ...Definition WrappedMultiTF1.h:286; ROOT::Math::WrappedMultiTF1Templ::fOwnFuncbool fOwnFuncDefinition WrappedMultiTF1.h:186; ROOT::Math::WrappedMultiTF1Templ::BaseFuncROOT::Math::IParametricFunctionMultiDimTempl< T >::BaseFunc BaseFuncDefinition WrappedMultiTF1.h:53; ROOT::Math::WrappedMultiTF1Templ::DoEvalVecT DoEvalVec(const T *x) constevaluate function using the cached parameter values (of TF1) re-implement for better efficiencyDefinition WrappedMultiTF1.h:165; ROOT::Math::WrappedMultiTF1Templ::fPolynomialbool fPolynomialDefinition WrappedMultiTF1.h:185; ROOT::Math::WrappedMultiTF1Templ::DoEvalParT DoEvalPar(const T *x, const double *p) const overrideevaluate function passing coordinates x and vector of parametersDefinition WrappedMultiTF1.h:158; ROOT::Math::WrappedMultiTF1Templ::WrappedMultiTF1TemplWrappedMultiTF1Templ(TF1 &f, unsigned int dim=0)constructor from a function pointer to a TF1 If dim = 0 dimension is taken from TF1::GetNdim().Definition WrappedMultiTF1.h:227; ROOT::Math::WrappedMultiTF1Templ::ParameterHessianbool ParameterHessian(const T *x, const double *par, T *h) const overrideEvaluate the all the Hessian (second derivatives matrix) of the function with respect to the paramete...Definition WrappedMultiTF1.h:347; TF11-Dim function classDefinition TF1.h:233; TF1::GetNumbervirtual Int_t GetNumber() constDefinition TF1.h:526",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/WrappedMultiTF1_8h_source.html:19522,cache,cached,19522,doc/master/WrappedMultiTF1_8h_source.html,https://root.cern,https://root.cern/doc/master/WrappedMultiTF1_8h_source.html,1,['cache'],['cached']
Performance,"on a range, first set this range via the SetRange function; If a vector x of coordinate is passed it will be used as starting point for the minimum.; In addition on exit x will contain the coordinate values at the minimuma; If x is NULL or x is inifinity or NaN, first, a grid search is performed to find the initial estimate of the; minimum location. The range of the function is divided into fNpx and fNpy; sub-ranges. If the function is ""good"" (or ""bad""), these values can be changed; by SetNpx and SetNpy functions; Then, a minimization is used with starting values found by the grid search; The minimizer algorithm used (by default Minuit) can be changed by callinga; ROOT::Math::Minimizer::SetDefaultMinimizerType(""..""); Other option for the minimizer can be set using the static method of the MinimizerOptions class. Double_t GetMinimumXY(Double_t& x, Double_t& y) const; Compute the X and Y values corresponding to the minimum value of the function; Return the minimum value of the function; To find the minimum on a range, first set this range via the SetRange function; Method:; First, a grid search is performed to find the initial estimate of the; minimum location. The range of the function is divided into fNpx and fNpy; sub-ranges. If the function is ""good"" (or ""bad""), these values can be changed; by SetNpx and SetNpy functions; Then, a minimization is used with starting values found by the grid search; The minimizer algorithm used (by default Minuit) can be changed by callinga; ROOT::Math::Minimizer::SetDefaultMinimizerType(""..""); Other option for the minimizer can be set using the static method of the MinimizerOptions class. Note that this method will always do first a grid search in contrast to GetMinimum. Double_t GetMaximumXY(Double_t& x, Double_t& y) const; Compute the X and Y values corresponding to the maximum value of the function; Return the maximum value of the function; See TF2::GetMinimumXY. Double_t GetMinimum(Double_t* x) const; return minimum/maximum valu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TF2.html:32953,perform,performed,32953,root/html602/TF2.html,https://root.cern,https://root.cern/root/html602/TF2.html,4,['perform'],['performed']
Performance,"on at line 1023 of file TGeoManager.cxx. ◆ BuildDefaultMaterials(). void TGeoManager::BuildDefaultMaterials ; (; ). Now just a shortcut for GetElementTable. ; Definition at line 3615 of file TGeoManager.cxx. ◆ cd(). Bool_t TGeoManager::cd ; (; const char * ; path = """"). virtual . Browse the tree of nodes starting from fTopNode according to pathname. ; Changes the path accordingly. ; Definition at line 1707 of file TGeoManager.cxx. ◆ CdDown(). void TGeoManager::CdDown ; (; Int_t ; index). Make a daughter of current node current. ; Can be called only with a valid daughter index (no check). Updates cache accordingly. ; Definition at line 1690 of file TGeoManager.cxx. ◆ CdNext(). void TGeoManager::CdNext ; (; ). Do a cd to the node found next by FindNextBoundary. ; Definition at line 1698 of file TGeoManager.cxx. ◆ CdNode(). void TGeoManager::CdNode ; (; Int_t ; nodeid). Change current path to point to the node having this id. ; Node id has to be in range : 0 to fNNodes-1 (no check for performance reasons) ; Definition at line 1655 of file TGeoManager.cxx. ◆ CdTop(). void TGeoManager::CdTop ; (; ). Make top level node the current node. ; Updates the cache accordingly. Determine the overlapping state of current node. ; Definition at line 1672 of file TGeoManager.cxx. ◆ CdUp(). void TGeoManager::CdUp ; (; ). Go one level up in geometry. ; Updates cache accordingly. Determine the overlapping state of current node. ; Definition at line 1681 of file TGeoManager.cxx. ◆ CheckBoundaryErrors(). void TGeoManager::CheckBoundaryErrors ; (; Int_t ; ntracks = 1000000, . Double_t ; radius = -1. . ). Check pushes and pulls needed to cross the next boundary with respect to the position given by FindNextBoundary. ; If radius is not mentioned the full bounding box will be sampled. ; Definition at line 3752 of file TGeoManager.cxx. ◆ CheckBoundaryReference(). void TGeoManager::CheckBoundaryReference ; (; Int_t ; icheck = -1). Check the boundary errors reference file created by CheckBoundar",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoManager.html:73130,perform,performance,73130,doc/master/classTGeoManager.html,https://root.cern,https://root.cern/doc/master/classTGeoManager.html,1,['perform'],['performance']
Performance,"on at line 206 of file GSLNLSMinimizer.cxx. ◆ ~GSLNLSMinimizer(). ROOT::Math::GSLNLSMinimizer::~GSLNLSMinimizer ; (; ). override . Destructor (no operations) ; Definition at line 228 of file GSLNLSMinimizer.cxx. Member Function Documentation. ◆ CovMatrix(). double ROOT::Math::GSLNLSMinimizer::CovMatrix ; (; unsigned int ; i, . unsigned int ; j . ); const. overridevirtual . return covariance matrices elements if the variable is fixed the matrix is zero The ordering of the variables is the same as in errors ; Reimplemented from ROOT::Math::Minimizer.; Definition at line 456 of file GSLNLSMinimizer.cxx. ◆ CovMatrixStatus(). int ROOT::Math::GSLNLSMinimizer::CovMatrixStatus ; (; ); const. overridevirtual . return covariance matrix status ; Reimplemented from ROOT::Math::Minimizer.; Definition at line 464 of file GSLNLSMinimizer.cxx. ◆ DoMinimize(). template<class Func > . bool ROOT::Math::GSLNLSMinimizer::DoMinimize ; (; const Func & ; f). protected . Internal method to perform minimization template on the type of method function. ; Definition at line 268 of file GSLNLSMinimizer.cxx. ◆ Edm(). double ROOT::Math::GSLNLSMinimizer::Edm ; (; ); const. inlineoverridevirtual . return expected distance reached from the minimum ; Reimplemented from ROOT::Math::Minimizer.; Definition at line 82 of file GSLNLSMinimizer.h. ◆ Errors(). const double * ROOT::Math::GSLNLSMinimizer::Errors ; (; ); const. inlineoverridevirtual . return errors at the minimum ; Reimplemented from ROOT::Math::Minimizer.; Definition at line 99 of file GSLNLSMinimizer.h. ◆ MinGradient(). const double * ROOT::Math::GSLNLSMinimizer::MinGradient ; (; ); const. overridevirtual . return pointer to gradient values at the minimum ; Reimplemented from ROOT::Math::Minimizer.; Definition at line 450 of file GSLNLSMinimizer.cxx. ◆ Minimize(). bool ROOT::Math::GSLNLSMinimizer::Minimize ; (; ). overridevirtual . method to perform the minimization ; Reimplemented from ROOT::Math::BasicMinimizer.; Definition at line 247 of fi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1GSLNLSMinimizer.html:12674,perform,perform,12674,doc/master/classROOT_1_1Math_1_1GSLNLSMinimizer.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1GSLNLSMinimizer.html,1,['perform'],['perform']
Performance,"on at line 3099 of file RooAbsReal.cxx. ◆ findInnerMostIntegration(). void RooAbsReal::findInnerMostIntegration ; (; const RooArgSet & ; allObs, . RooArgSet & ; innerObs, . const char * ; rangeName . ); const. protected . Utility function for createIntObj() that aids in the construct of recursive integrals over functions with multiple observables with parameterized ranges. ; This function finds in a given set allObs over which integration is requested the largeset subset of observables that can be integrated simultaneously. This subset consists of observables with fixed ranges and observables with parameterized ranges whose parameterization does not depend on any observable that is also integrated. ; Definition at line 701 of file RooAbsReal.cxx. ◆ findRoot(). double RooAbsReal::findRoot ; (; RooRealVar & ; x, . double ; xmin, . double ; xmax, . double ; yval . ). Return value of x (in range xmin,xmax) at which function equals yval. ; (Calculation is performed with Brent root finding algorithm) ; Definition at line 4051 of file RooAbsReal.cxx. ◆ fixAddCoefNormalization(). void RooAbsReal::fixAddCoefNormalization ; (; const RooArgSet & ; addNormSet = RooArgSet(), . bool ; force = true . ). virtual . Fix the interpretation of the coefficient of any RooAddPdf component in the expression tree headed by this object to the given set of observables. ; If the force flag is false, the normalization choice is only fixed for those RooAddPdf components that have the default 'automatic' interpretation of coefficients (i.e. the interpretation is defined by the observables passed to getVal()). If force is true, also RooAddPdf that already have a fixed interpretation are changed to a new fixed interpretation. ; Definition at line 3650 of file RooAbsReal.cxx. ◆ fixAddCoefRange(). void RooAbsReal::fixAddCoefRange ; (; const char * ; rangeName = nullptr, . bool ; force = true . ). virtual . Fix the interpretation of the coefficient of any RooAddPdf component in the expression tree head",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsReal.html:104867,perform,performed,104867,doc/master/classRooAbsReal.html,https://root.cern,https://root.cern/doc/master/classRooAbsReal.html,1,['perform'],['performed']
Performance,"on at line 3181 of file RooAbsReal.cxx. ◆ findInnerMostIntegration(). void RooAbsReal::findInnerMostIntegration ; (; const RooArgSet & ; allObs, . RooArgSet & ; innerObs, . const char * ; rangeName . ); const. protected . Utility function for createIntObj() that aids in the construct of recursive integrals over functions with multiple observables with parameterized ranges. ; This function finds in a given set allObs over which integration is requested the largeset subset of observables that can be integrated simultaneously. This subset consists of observables with fixed ranges and observables with parameterized ranges whose parameterization does not depend on any observable that is also integrated. ; Definition at line 699 of file RooAbsReal.cxx. ◆ findRoot(). double RooAbsReal::findRoot ; (; RooRealVar & ; x, . double ; xmin, . double ; xmax, . double ; yval . ). Return value of x (in range xmin,xmax) at which function equals yval. ; (Calculation is performed with Brent root finding algorithm) ; Definition at line 4127 of file RooAbsReal.cxx. ◆ fixAddCoefNormalization(). void RooAbsReal::fixAddCoefNormalization ; (; const RooArgSet & ; addNormSet = RooArgSet(), . bool ; force = true . ). virtual . Fix the interpretation of the coefficient of any RooAddPdf component in the expression tree headed by this object to the given set of observables. ; If the force flag is false, the normalization choice is only fixed for those RooAddPdf components that have the default 'automatic' interpretation of coefficients (i.e. the interpretation is defined by the observables passed to getVal()). If force is true, also RooAddPdf that already have a fixed interpretation are changed to a new fixed interpretation. ; Definition at line 3726 of file RooAbsReal.cxx. ◆ fixAddCoefRange(). void RooAbsReal::fixAddCoefRange ; (; const char * ; rangeName = nullptr, . bool ; force = true . ). virtual . Fix the interpretation of the coefficient of any RooAddPdf component in the expression tree head",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAbsReal.html:106126,perform,performed,106126,doc/v632/classRooAbsReal.html,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html,1,['perform'],['performed']
Performance,"on at line 76 of file TContextMenu.cxx. Member Function Documentation. ◆ Action() [1/5]. void TContextMenu::Action ; (; TClassMenuItem * ; menuitem). virtual . Action to be performed when this menu item is selected. ; If the selected method requires arguments we popup an automatically generated dialog, otherwise the method is directly executed. ; Definition at line 116 of file TContextMenu.cxx. ◆ Action() [2/5]. void TContextMenu::Action ; (; TMethod * ; method). inline . Definition at line 74 of file TContextMenu.h. ◆ Action() [3/5]. void TContextMenu::Action ; (; TObject * ; object, . TMethod * ; method . ). virtual . Action to be performed when this menu item is selected. ; If the selected method requires arguments we popup an automatically generated dialog, otherwise the method is directly executed. ; Definition at line 93 of file TContextMenu.cxx. ◆ Action() [4/5]. void TContextMenu::Action ; (; TObject * ; object, . TToggle * ; toggle . ). virtual . Action to be performed when this toggle menu item is selected. ; Definition at line 211 of file TContextMenu.cxx. ◆ Action() [5/5]. void TContextMenu::Action ; (; TToggle * ; toggle). inline . Definition at line 75 of file TContextMenu.h. ◆ Class(). static TClass * TContextMenu::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TContextMenu::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TContextMenu::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 104 of file TContextMenu.h. ◆ CreateArgumentTitle(). const char * TContextMenu::CreateArgumentTitle ; (; TMethodArg * ; argument). virtual . Create string describing argument (for use in dialog box). ; Definition at line 248 of file TContextMenu.cxx. ◆ CreateDialogTitle(). const char * TContextMenu::CreateDialogTitle ; (; TObject * ; object, . TFunction * ; method . ). virtual . Create title for dialog box retrieving argumen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTContextMenu.html:16229,perform,performed,16229,doc/master/classTContextMenu.html,https://root.cern,https://root.cern/doc/master/classTContextMenu.html,1,['perform'],['performed']
Performance,"on attempts to load the dictionary for 'classname'; either from the TClassTable or from the list of generator.; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members). The 'requestedname' is expected to be already normalized. Int_t LoadClass(const char* classname, const char* libname, Bool_t check = kFALSE); Check if class ""classname"" is known to the interpreter (in fact,; this check is not needed anymore, so classname is ignored). If; not it will load library ""libname"". If the library name does; not start with ""lib"", ""lib"" will be prepended and a search will; be made in the DynamicPath (see .rootrc). If not found a search; will be made on libname (without ""lib"" prepended) and if not found; a direct try of libname will be made (in case it contained an; absolute path).; If check is true it will only check if libname exists and is; readable.; Returns 0 on successful loading, -1 in case libname does not; exist or in case of error and -2 in case of version mismatch. Bool_t IsRootFile(const char* filename) const; Return true if the file is local and is (likely) to be a ROOT file. void ls(Option_t* option = """") const; To list all objects of the application.; Loop on all objects created in the ROOT linked lists.; Objects may be files and windows or any other object directly; attached to the ROOT linked list. Int_t LoadMacro(const char* filename, Int_t* error = 0, Bool_t check = kFALSE); Load a macro in the interpreter's memory. Equivalent to the command line; command "".L filename"". If the filename has ""+"" or ""++"" appended; the macro will be compiled by ACLiC. The filename must have the format:; [path/]macro.C[+|++[g|O]].; The possible error codes are defined by TInterpreter::EErrorCode.; If check is true it will only check if filename exists and is; readable.; Returns 0 on successful loading and -1 in case filename does not; exist or in case of error. Long_t Macro(const char* filename, In",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TROOT.html:31259,load,loading,31259,root/html602/TROOT.html,https://root.cern,https://root.cern/root/html602/TROOT.html,4,['load'],['loading']
Performance,"on can be used to select the events to be plotted.; The cut specification may refer to any variable contained in the data set. The drawOptions are passed to the TH1::Draw() method. Roo1DTable* table(const RooAbsCategory& cat, const char* cuts = """", const char* opts = """") const; Create and fill a 1-dimensional table for given category column; This functions is the equivalent of plotOn() for category dimensions. The optional cut string expression can be used to select the events to be tabulated; The cut specification may refer to any variable contained in the data set. The option string is currently not used. Bool_t getRange(RooRealVar& var, Double_t& lowest, Double_t& highest, Double_t marginFrac = 0, Bool_t symMode = kFALSE) const; Fill Doubles 'lowest' and 'highest' with the lowest and highest value of; observable 'var' in this dataset. If the return value is kTRUE and error; occurred. void optimizeReadingWithCaching(RooAbsArg& arg, const RooArgSet& cacheList, const RooArgSet& keepObsList); Prepare dataset for use with cached constant terms listed in; 'cacheList' of expression 'arg'. Deactivate tree branches; for any dataset observable that is either not used at all,; or is used exclusively by cached branch nodes. Bool_t allClientsCached(RooAbsArg* , const RooArgSet& ); Utility function that determines if all clients of object 'var'; appear in given list of cached nodes. Bool_t canSplitFast() const. RooAbsData* getSimData(const char* idxstate). void addOwnedComponent(const char* idxlabel, RooAbsData& data). void checkInit() const. void Draw(Option_t* option = """"); Forward draw command to data store. Bool_t hasFilledCache() const. const TTree* tree() const. RooAbsData* emptyClone(const char* newName = 0, const char* newTitle = 0, const RooArgSet* vars = 0) const. RooAbsDataStore* store(); { return _dstore ; }. const RooAbsDataStore* store() const; { return _dstore ; }. void add(const RooArgSet& row, Double_t weight = 1, Double_t weightError = 0); Add one ore more ro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooAbsData.html:34952,optimiz,optimizeReadingWithCaching,34952,root/html530/RooAbsData.html,https://root.cern,https://root.cern/root/html530/RooAbsData.html,4,"['cache', 'optimiz']","['cacheList', 'cached', 'optimizeReadingWithCaching']"
Performance,"on can be used to select the events to be plotted.; The cut specification may refer to any variable contained in the data set. The drawOptions are passed to the TH1::Draw() method. Roo1DTable* table(const RooAbsCategory& cat, const char* cuts = """", const char* opts = """") const; Create and fill a 1-dimensional table for given category column; This functions is the equivalent of plotOn() for category dimensions. The optional cut string expression can be used to select the events to be tabulated; The cut specification may refer to any variable contained in the data set. The option string is currently not used. Bool_t getRange(RooRealVar& var, Double_t& lowest, Double_t& highest, Double_t marginFrac = 0, Bool_t symMode = kFALSE) const; Fill Doubles 'lowest' and 'highest' with the lowest and highest value of; observable 'var' in this dataset. If the return value is kTRUE and error; occurred. void optimizeReadingWithCaching(RooAbsArg& arg, const RooArgSet& cacheList, const RooArgSet& keepObsList); Prepare dataset for use with cached constant terms listed in; 'cacheList' of expression 'arg'. Deactivate tree branches; for any dataset observable that is either not used at all,; or is used exclusively by cached branch nodes. Bool_t allClientsCached(RooAbsArg* , const RooArgSet& ); Utility function that determines if all clients of object 'var'; appear in given list of cached nodes. void attachBuffers(const RooArgSet& extObs). void resetBuffers(). Bool_t canSplitFast() const. RooAbsData* getSimData(const char* idxstate). void addOwnedComponent(const char* idxlabel, RooAbsData& data). void Streamer(TBuffer& ); Stream an object of class RooAbsData. void checkInit() const. void Draw(Option_t* option = """"); Forward draw command to data store. Bool_t hasFilledCache() const. const TTree* tree() const. RooAbsData* emptyClone(const char* newName = 0, const char* newTitle = 0, const RooArgSet* vars = 0, const char* wgtVarName = 0) const. RooAbsDataStore* store(); { return _dstore ; }. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsData.html:35529,optimiz,optimizeReadingWithCaching,35529,root/html534/RooAbsData.html,https://root.cern,https://root.cern/root/html534/RooAbsData.html,24,"['cache', 'optimiz']","['cacheList', 'cached', 'optimizeReadingWithCaching']"
Performance,"on can be used to select the events to be plotted.; The cut specification may refer to any variable contained in the data set. The drawOptions are passed to the TH1::Draw() method. Roo1DTable* table(const RooAbsCategory& cat, const char* cuts = """", const char* opts = """") const; Create and fill a 1-dimensional table for given category column; This functions is the equivalent of plotOn() for category dimensions. The optional cut string expression can be used to select the events to be tabulated; The cut specification may refer to any variable contained in the data set. The option string is currently not used. Bool_t getRange(RooRealVar& var, Double_t& lowest, Double_t& highest, Double_t marginFrac = 0, Bool_t symMode = kFALSE) const; Fill Doubles 'lowest' and 'highest' with the lowest and highest value of; observable 'var' in this dataset. If the return value is kTRUE and error; occurred. void optimizeReadingWithCaching(RooAbsArg& arg, const RooArgSet& cacheList, const RooArgSet& keepObsList); Prepare dataset for use with cached constant terms listed in; 'cacheList' of expression 'arg'. Deactivate tree branches; for any dataset observable that is either not used at all,; or is used exclusively by cached branch nodes. Bool_t allClientsCached(RooAbsArg* , const RooArgSet& ); Utility function that determines if all clients of object 'var'; appear in given list of cached nodes. void attachBuffers(const RooArgSet& extObs). void resetBuffers(). Bool_t canSplitFast() const. RooAbsData* getSimData(const char* idxstate). void addOwnedComponent(const char* idxlabel, RooAbsData& data). void Streamer(TBuffer& b); Stream an object of class RooAbsData. void checkInit() const. void Draw(Option_t* option = """"); Forward draw command to data store. Bool_t hasFilledCache() const. const TTree* tree() const. RooAbsData* emptyClone(const char* newName = 0, const char* newTitle = 0, const RooArgSet* vars = 0) const. RooAbsDataStore* store(); { return _dstore ; }. const RooAbsDataStore* stor",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsData.html:35321,optimiz,optimizeReadingWithCaching,35321,root/html532/RooAbsData.html,https://root.cern,https://root.cern/root/html532/RooAbsData.html,4,"['cache', 'optimiz']","['cacheList', 'cached', 'optimizeReadingWithCaching']"
Performance,"on can be used to select the events to be plotted.; The cut specification may refer to any variable contained in the data set. The drawOptions are passed to the TH1::Draw() method. Roo1DTable* table(const RooAbsCategory& cat, const char* cuts = """", const char* opts = """") const; Create and fill a 1-dimensional table for given category column; This functions is the equivalent of plotOn() for category dimensions. The optional cut string expression can be used to select the events to be tabulated; The cut specification may refer to any variable contained in the data set. The option string is currently not used. Bool_t getRange(RooRealVar& var, Double_t& lowest, Double_t& highest, Double_t marginFrac = 0, Bool_t symMode = kFALSE) const; Fill Doubles 'lowest' and 'highest' with the lowest and highest value of; observable 'var' in this dataset. If the return value is kTRUE and error; occurred. void optimizeReadingWithCaching(RooAbsArg& arg, const RooArgSet& cacheList, const RooArgSet& keepObsList); Prepare dataset for use with cached constant terms listed in; 'cacheList' of expression 'arg'. Deactivate tree branches; for any dataset observable that is either not used at all,; or is used exclusively by cached branch nodes. Bool_t allClientsCached(RooAbsArg* , const RooArgSet& ); Utility function that determines if all clients of object 'var'; appear in given list of cached nodes. void checkInit() const. void Draw(Option_t* option = """"); Forward draw command to data store. Bool_t hasFilledCache() const. const TTree* tree() const. RooAbsData* emptyClone(const char* newName = 0, const char* newTitle = 0, const RooArgSet* vars = 0) const. RooAbsDataStore* store(); { return _dstore ; }. const RooAbsDataStore* store() const; { return _dstore ; }. void add(const RooArgSet& row, Double_t weight = 1, Double_t weightError = 0); Add one ore more rows of data. const RooArgSet* get() const; Load a given row of data. Double_t weight() const. Bool_t valid() const; { return kTRUE ; }. Doub",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsData.html:34441,optimiz,optimizeReadingWithCaching,34441,root/html528/RooAbsData.html,https://root.cern,https://root.cern/root/html528/RooAbsData.html,4,"['cache', 'optimiz']","['cacheList', 'cached', 'optimizeReadingWithCaching']"
Performance,"on coordinates for placement of objects on regular grids.; TEveGridStepperEditor Editor for TEveGridStepper class.; TEveGridStepperSubEditor Sub-editor for TEveGridStepper class.; TEveHit Monte Carlo hit (also used in VSD).; TEveJetCone Short description.; TEveJetConeEditor GUI editor for TEveJetCone.; TEveJetConeGL GL renderer class for TEveJetCone.; TEveJetConeProjected Projection of TEveJetCone.; TEveJetConeProjectedGL GL renderer class for TEveJetCone.; TEveLegoEventHandler A GL event handler class. Swiches perspective or orthographic camera.; TEveLine An arbitrary polyline with fixed line and marker attributes.; TEveLineEditor Editor for TEveLine class.; TEveLineGL GL-renderer for TEveLine class.; TEveLineProjected Projected replica of a TEveLine.; TEveListTreeItem Special llist-tree-item for Eve.; TEveMCRecCrossRef Cross-reference of sim/rec data per particle (also used in VSD).; TEveMCTrack Monte Carlo track (also used in VSD).; TEveMacro TMacro wrapper (attempting to fix issues with different macro loading and execution schemes).; TEveMagField Abstract interface to magnetic field; TEveMagFieldConst Interface to constant magnetic field.; TEveMagFieldDuo Interface to magnetic field with two different values depending of radius.; TEveManager Eve application manager.; TEveManager::TExceptionHandler Exception handler for Eve exceptions.; TEveManager::TRedrawDisabler Exception-safe EVE redraw-disabler.; TEvePad Internal TEveUtil pad class (sub-class of TPad) overriding handling of updates and 3D-viewers.; TEvePadHolder Exception-safe wrapper for temporary setting of gPad variable.; TEveParamList Eve element to store generic configuration information.; TEveParamList::BoolConfig_t ; TEveParamList::FloatConfig_t ; TEveParamList::IntConfig_t ; TEveParamListEditor GUI editor for TEveParamList.; TEvePathMarkT<double> Template for a special point on a track: position/momentum reference, daughter creation or decay.; TEvePathMarkT<float> Template for a special point on a tr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ClassIndex.html:62664,load,loading,62664,root/html528/ClassIndex.html,https://root.cern,https://root.cern/root/html528/ClassIndex.html,3,['load'],['loading']
Performance,on coordinates for placement of objects on regular grids.; TEveGridStepperEditor Editor for TEveGridStepper class.; TEveGridStepperSubEditor Sub-editor for TEveGridStepper class.; TEveHit Monte Carlo hit (also used in VSD).; TEveJetCone Short description.; TEveJetConeEditor GUI editor for TEveJetCone.; TEveJetConeGL GL renderer class for TEveJetCone.; TEveJetConeProjected Projection of TEveJetCone.; TEveJetConeProjectedGL GL renderer class for TEveJetCone.; TEveLegoEventHandler A GL event handler class. Swiches perspective or orthographic camera.; TEveLine An arbitrary polyline with fixed line and marker attributes.; TEveLineEditor Editor for TEveLine class.; TEveLineGL GL-renderer for TEveLine class.; TEveLineProjected Projected replica of a TEveLine.; TEveListTreeItem Special llist-tree-item for Eve.; TEveMCRecCrossRef Cross-reference of sim/rec data per particle (also used in VSD).; TEveMCTrack Monte Carlo track (also used in VSD).; TEveMacro TMacro wrapper (attempting to fix issues with different macro loading and execution schemes).; TEveMagField Abstract interface to magnetic field; TEveMagFieldConst Interface to constant magnetic field.; TEveMagFieldDuo Interface to magnetic field with two different values depending on radius.; TEveManager Eve application manager.; TEveManager::TExceptionHandler Exception handler for Eve exceptions.; TEveManager::TRedrawDisabler Exception-safe EVE redraw-disabler.; TEvePad Internal TEveUtil pad class (sub-class of TPad) overriding handling of updates and 3D-viewers.; TEvePadHolder Exception-safe wrapper for temporary setting of gPad variable.; TEveParamList Eve element to store generic configuration information.; TEveParamList::BoolConfig_t ; TEveParamList::FloatConfig_t ; TEveParamList::IntConfig_t ; TEveParamListEditor GUI editor for TEveParamList.; TEvePathMarkT<double> ; TEvePathMarkT<float> ; TEvePlot3D Short description.; TEvePlot3DGL GL renderer class for TEvePlot3D.; TEvePointSelector TSelector for direct extraction of,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ClassIndex.html:63095,load,loading,63095,root/html602/ClassIndex.html,https://root.cern,https://root.cern/root/html602/ClassIndex.html,4,['load'],['loading']
Performance,"on coordinates for placement of objects on regular grids.; TEveGridStepperEditor Editor for TEveGridStepper class.; TEveGridStepperSubEditor Sub-editor for TEveGridStepper class.; TEveHit Monte Carlo hit (also used in VSD).; TEveJetCone Short description.; TEveJetConeEditor GUI editor for TEveJetCone.; TEveJetConeGL GL renderer class for TEveJetCone.; TEveJetConeProjected Projection of TEveJetCone.; TEveJetConeProjectedGL GL renderer class for TEveJetCone.; TEveLegoEventHandler A GL event handler class. Swiches perspective or orthographic camera.; TEveLine An arbitrary polyline with fixed line and marker attributes.; TEveLineEditor Editor for TEveLine class.; TEveLineGL GL-renderer for TEveLine class.; TEveLineProjected Projected replica of a TEveLine.; TEveListTreeItem Special llist-tree-item for Eve.; TEveMCRecCrossRef Cross-reference of sim/rec data per particle (also used in VSD).; TEveMCTrack Monte Carlo track (also used in VSD).; TEveMacro TMacro wrapper (attempting to fix issues with different macro loading and execution schemes).; TEveMagField Abstract interface to magnetic field; TEveMagFieldConst Interface to constant magnetic field.; TEveMagFieldDuo Interface to magnetic field with two different values depending on radius.; TEveManager Eve application manager.; TEveManager::TExceptionHandler Exception handler for Eve exceptions.; TEveManager::TRedrawDisabler Exception-safe EVE redraw-disabler.; TEvePad Internal TEveUtil pad class (sub-class of TPad) overriding handling of updates and 3D-viewers.; TEvePadHolder Exception-safe wrapper for temporary setting of gPad variable.; TEveParamList Eve element to store generic configuration information.; TEveParamList::BoolConfig_t ; TEveParamList::FloatConfig_t ; TEveParamList::IntConfig_t ; TEveParamListEditor GUI editor for TEveParamList.; TEvePathMarkT<double> Template for a special point on a track: position/momentum reference, daughter creation or decay.; TEvePathMarkT<float> Template for a special point on a tr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ClassIndex.html:66416,load,loading,66416,root/html534/ClassIndex.html,https://root.cern,https://root.cern/root/html534/ClassIndex.html,2,['load'],['loading']
Performance,"on derived from TSelector,; 7386/// where TSelector has the following member functions:; 7387///; 7388/// - `Begin()`: called every time a loop on the tree starts,; 7389/// a convenient place to create your histograms.; 7390/// - `SlaveBegin()`: called after Begin(), when on PROOF called only on the; 7391/// slave servers.; 7392/// - `Process()`: called for each event, in this function you decide what; 7393/// to read and fill your histograms.; 7394/// - `SlaveTerminate`: called at the end of the loop on the tree, when on PROOF; 7395/// called only on the slave servers.; 7396/// - `Terminate()`: called at the end of the loop on the tree,; 7397/// a convenient place to draw/fit your histograms.; 7398///; 7399/// If filename is of the form file.C, the file will be interpreted.; 7400///; 7401/// If filename is of the form file.C++, the file file.C will be compiled; 7402/// and dynamically loaded.; 7403///; 7404/// If filename is of the form file.C+, the file file.C will be compiled; 7405/// and dynamically loaded. At next call, if file.C is older than file.o; 7406/// and file.so, the file.C is not compiled, only file.so is loaded.; 7407///; 7408/// ## NOTE1; 7409///; 7410/// It may be more interesting to invoke directly the other Process function; 7411/// accepting a TSelector* as argument.eg; 7412/// ~~~ {.cpp}; 7413/// MySelector *selector = (MySelector*)TSelector::GetSelector(filename);; 7414/// selector->CallSomeFunction(..);; 7415/// mytree.Process(selector,..);; 7416/// ~~~; 7417/// ## NOTE2; 7418//; 7419/// One should not call this function twice with the same selector file; 7420/// in the same script. If this is required, proceed as indicated in NOTE1,; 7421/// by getting a pointer to the corresponding TSelector,eg; 7422///; 7423/// ### Workaround 1; 7424///; 7425/// ~~~ {.cpp}; 7426/// void stubs1() {; 7427/// TSelector *selector = TSelector::GetSelector(""h1test.C"");; 7428/// TFile *f1 = new TFile(""stubs_nood_le1.root"");; 7429/// TTree *h1 = (TTree*)f1->Get(""h1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:291240,load,loaded,291240,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['load'],['loaded']
Performance,"on estimate. Arguments:; grin: input graph. option: the kernel to be used: ""box"", ""normal""; bandwidth: the bandwidth. The kernels are scaled so that their quartiles; (viewed as probability densities) are at +/- 0.25*bandwidth.; nout: If xout is not specified, interpolation takes place at equally; spaced points spanning the interval [min(x), max(x)], where; nout = max(nout, number of input data).; xout: an optional set of values at which to evaluate the fit. void BDRksmooth(Double_t* x, Double_t* y, Int_t n, Double_t* xp, Double_t* yp, Int_t np, Int_t kernel, Double_t bw); Smooth data with specified kernel*-*-; *-* =================================. Based on R function ksmooth: Translated to C++ by C. Stratowa; (R source file: ksmooth.c by B.D.Ripley Copyright (C) 1998). -. TGraph * SmoothLowess(TGraph* grin, Option_t* option = """", Double_t span = 0.67000000000000004, Int_t iter = 3, Double_t delta = 0); Smooth data with Lowess smoother*-*-. This function performs the computations for the LOWESS smoother; (see the reference below). Lowess returns the output points; x and y which give the coordinates of the smooth. Arguments:; grin: Input graph. span: the smoother span. This gives the proportion of points in the plot; which influence the smooth at each value.; Larger values give more smoothness.; iter: the number of robustifying iterations which should be performed.; Using smaller values of iter will make lowess run faster.; delta: values of x which lie within delta of each other replaced by a; single value in the output from lowess.; For delta = 0, delta will be calculated. References:; Cleveland, W. S. (1979) Robust locally weighted regression and smoothing; scatterplots. J. Amer. Statist. Assoc. 74, 829-836.; Cleveland, W. S. (1981) LOWESS: A program for smoothing scatterplots; by robust locally weighted regression.; The American Statistician, 35, 54. void Lowess(Double_t* x, Double_t* y, Int_t n, Double_t* ys, Double_t span, Int_t iter, Double_t delta); Lowess reg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGraphSmooth.html:9474,perform,performs,9474,root/html602/TGraphSmooth.html,https://root.cern,https://root.cern/root/html602/TGraphSmooth.html,4,['perform'],['performs']
Performance,"on first parameter; 4085/// ~~~; 4086///; 4087/// ##### Associated functions; 4088///; 4089/// One or more object ( can be added to the list; 4090/// of functions (fFunctions) associated to each histogram.; 4091/// When TH1::Fit is invoked, the fitted function is added to the histogram list of functions (fFunctions).; 4092/// If the histogram is made persistent, the list of associated functions is also persistent.; 4093/// Given a histogram h, one can retrieve an associated function with:; 4094///; 4095/// ~~~ {.cpp}; 4096/// TF1 *myfunc = h->GetFunction(""myfunc"");; 4097/// ~~~; 4098/// or by quering directly the list obtained by calling `TH1::GetListOfFunctions`.; 4099///; 4100/// \anchor HFitStatus; 4101/// ### Fit status; 4102///; 4103/// The status of the fit is obtained converting the TFitResultPtr to an integer; 4104/// independently if the fit option ""S"" is used or not:; 4105///; 4106/// ~~~ {.cpp}; 4107/// TFitResultPtr r = h->Fit(myFunc,opt);; 4108/// Int_t fitStatus = r;; 4109/// ~~~; 4110///; 4111/// - `status = 0` : the fit has been performed successfully (i.e no error occurred).; 4112/// - `status < 0` : there is an error not connected with the minimization procedure, for example when a wrong function is used.; 4113/// - `status > 0` : return status from Minimizer, depends on used Minimizer. For example for TMinuit and Minuit2 we have:; 4114/// - `status = migradStatus + 10*minosStatus + 100*hesseStatus + 1000*improveStatus`.; 4115/// TMinuit returns 0 (for migrad, minos, hesse or improve) in case of success and 4 in case of error (see the documentation of TMinuit::mnexcm). For example, for an error; 4116/// only in Minos but not in Migrad a fitStatus of 40 will be returned.; 4117/// Minuit2 returns 0 in case of success and different values in migrad,minos or; 4118/// hesse depending on the error. See in this case the documentation of; 4119/// Minuit2Minimizer::Minimize for the migrad return status, Minuit2Minimizer::GetMinosError for the; 4120/// minos ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:168265,perform,performed,168265,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,1,['perform'],['performed']
Performance,"on h ~ eps |p|. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; WrappedMultiTF1(TF1& f, unsigned int dim = 0). constructor from a function pointer to a TF1; If dim = 0 dimension is taken from TF1::GetNdim().; IN case of multi-dimensional function created using directly TF1 object the dimension; returned by TF1::GetNdim is always 1. The user must then pass the correct value of dim. virtual ~WrappedMultiTF1(). Destructor (no operations). Function pointer is not owned. { if (fOwnFunc && fFunc) delete fFunc; }. WrappedMultiTF1(const ROOT::Math::WrappedMultiTF1& rhs). Copy constructor. IMultiGenFunction * Clone() const; @name interface inherited from IFunction . Clone the wrapper but not the original function. unsigned int NDim() const; function dimension. const double * Parameters() const; @name interface inherited from IParamFunction ; get the parameter values (return values from TF1). void SetParameters(const double* p); set parameter values (only the cached one in this class,leave unchanges those of TF1). unsigned int NPar() const; return number of parameters. std::string ParameterName(unsigned int i) const; return parameter name (from TF1). void ParameterGradient(const double* x, const double* par, double* grad) const; evaluate the derivative of the function with respect to the parameters. void SetDerivPrecision(double eps); precision value used for calculating the derivative step-size; h = eps * |x|. The default is 0.001, give a smaller in case function changes rapidly. double GetDerivPrecision(); get precision value used for calculating the derivative step-size. const TF1 * GetFunction() const; method to retrieve the internal function pointer. { return fFunc; }. void SetAndCopyFunction(const TF1* f = 0); method to set a new function pointer and copy it inside.; By calling this method the class manages now the passed TF1 pointer. double DoEvalPar(const double* x, const double* p) const; evaluate function passing coordinate",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/ROOT__Math__WrappedMultiTF1.html:4116,cache,cached,4116,root/html604/ROOT__Math__WrappedMultiTF1.html,https://root.cern,https://root.cern/root/html604/ROOT__Math__WrappedMultiTF1.html,2,['cache'],['cached']
Performance,"on if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction2Ref<double,int,int>funcFunction pointer reference; RooRealProxyxArgument reference; RooRealProxyyArgument reference.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooCFunction2Binding_double_int_int_.html:33582,cache,cache,33582,root/html532/RooCFunction2Binding_double_int_int_.html,https://root.cern,https://root.cern/root/html532/RooCFunction2Binding_double_int_int_.html,1,['cache'],['cache']
Performance,"on integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; RooRealProxyalpha; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxym; RooRealProxym0; RooRealProxyn; RooRealProxysigma.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooCBShape.html:38625,cache,cache,38625,root/html526/RooCBShape.html,https://root.cern,https://root.cern/root/html526/RooCBShape.html,2,['cache'],['cache']
Performance,"on is to read directly and only; the interesting branches. Example:; TBranch *brc = T.GetBranch(""c"");; TBranch *bre = T.GetBranch(""e"");; brc->GetEntry(i);; bre->GetEntry(i);. If found is not 0, the number of branch(es) found matching the regular; expression is returned in *found AND the error message 'unknown branch'; is suppressed. void SetBranchStyle(Int_t style = 1); Set the current branch style. (static function). style = 0 old Branch; style = 1 new Bronch. void SetCacheSize(Long64_t cachesize = -1); Set maximum size of the file cache .; if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing; the Tree (default is 30 MBytes). void SetCacheSizeAux(Bool_t autocache = kTRUE, Long64_t cacheSize = 0); Set the size of the file cache and create it if needed. If autocache is true:; this will be an automatically create cache, possibly replacing an; existing autocreated cache with a larger one. The size is calculated,; cacheSize is unused. If autocache is false:; cacheSize is used to size the cache. This cache should never be; automatically adjusted. void SetCacheEntryRange(Long64_t first, Long64_t last); interface to TTreeCache to set the cache entry range. void SetCacheLearnEntries(Int_t n = 10); interface to TTreeCache to set the number of entries for the learning phase. void SetCircular(Long64_t maxEntries); Enable/Disable circularity for this tree. if maxEntries > 0 a maximum of maxEntries is kept in one buffer/basket; per branch in memory.; Note that when this function is called (maxEntries>0) the Tree; must be empty or having only one basket per branch.; if maxEntries <= 0 the tree circularity is disabled. NOTE 1:; Circular Trees are interesting in online real time environments; to store the results of the last maxEntries events.; NOTE 2:; Calling SetCircular with maxEntries <= 0 is necessary before; merging circular Trees that have been saved on files.; NOTE 3:; SetCircular with maxEntries",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTree.html:132110,cache,cacheSize,132110,root/html534/TTree.html,https://root.cern,https://root.cern/root/html534/TTree.html,4,['cache'],['cacheSize']
Performance,"on management calls.; . Function Members (Methods); public:. RooAbsCache(RooAbsArg* owner = 0); RooAbsCache(const RooAbsCache&, RooAbsArg* owner = 0); virtual~RooAbsCache(); static TClass*Class(); virtual voidfindConstantNodes(const RooArgSet&, RooArgSet&, RooLinkedList&); virtual TClass*IsA() const; RooAbsCache&operator=(const RooAbsCache&); virtual voidoperModeHook(); virtual voidoptimizeCacheMode(const RooArgSet&, RooArgSet&, RooLinkedList&); virtual voidprintCompactTreeHook(ostream&, const char*); virtual Bool_tredirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidwireCache(). Data Members; protected:. RooAbsArg*_ownerPointer to owning RooAbsArg. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsCache(RooAbsArg* owner = 0); Constructor. Takes owner as argument and register cache with owner. RooAbsCache(const RooAbsCache& , RooAbsArg* owner = 0); Copy constructor. Takes owner as argument and registers cache with owne. ~RooAbsCache(); Destructor. Unregisters cache with owner. void optimizeCacheMode(const RooArgSet& , RooArgSet& , RooLinkedList& ); Interface for processing of cache mode optimization calls. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Interface for server redirect calls. void operModeHook(); Interface for operation mode changes. void findConstantNodes(const RooArgSet& , RooArgSet& , RooLinkedList& ); Interface for constant term node finding calls. void printCompactTreeHook(ostream& , const char* ); Interface for printing of cache guts in tree mode printing. void wireCache(); {}. » Last changed: Tue Mar 10 17:13:50 2015 » Last generated: 2015-03-10 17:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsCache.html:1737,cache,cache,1737,root/html534/RooAbsCache.html,https://root.cern,https://root.cern/root/html534/RooAbsCache.html,12,"['cache', 'optimiz']","['cache', 'optimization', 'optimizeCacheMode']"
Performance,"on mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction4Ref<double,double,double,double,double>funcFunction pointer reference; RooRealProxywArgument reference; RooRealProxyxArgument reference; RooRealProxyyArgument reference; RooRealProxyzArgument reference.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooCFunction4PdfBinding_double_double_double_double_double_.html:40121,cache,cache,40121,root/html530/RooCFunction4PdfBinding_double_double_double_double_double_.html,https://root.cern,https://root.cern/root/html530/RooCFunction4PdfBinding_double_double_double_double_double_.html,2,['cache'],['cache']
Performance,"on of FCN static function used internally by TMinuit.; Adapt IMultiGenFunction interface to TMinuit FCN static function. void FcnGrad(int& , double* g, double& f, double* , int ); implementation of FCN static function used internally by TMinuit.; Adapt IMultiGradFunction interface to TMinuit FCN static function in the case of user; provided gradient. bool SetVariable(unsigned int ivar, const string& name, double val, double step); set a free variable. bool SetLimitedVariable(unsigned int ivar, const string& name, double val, double step, double , double ); set a limited variable. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool SetVariableValue(unsigned int , double ); set the value of an existing variable; parameter must exist or return false. std::string VariableName(unsigned int ivar) const; return the variable name. int VariableIndex(const string& name) const; return variable index. bool Minimize(); perform the minimization using the algorithm chosen previously by the user; By default Migrad is used.; Return true if the found minimum is valid and update internal chached values of; minimum values, errors and covariance matrix.; Status of minimizer is set to:; migradResult + 10*minosResult + 100*hesseResult + 1000*improveResult. void RetrieveParams(); retrieve from TMinuit minimum parameter values; and errors. void RetrieveErrorMatrix(); get covariance error matrix from TMinuit; when some parameters are fixed filled the corresponding rows and column with zero's. unsigned int NCalls() const; return total number of function calls. double MinValue() const; return minimum function value. double Edm() const; return expected distance from the minimum. unsigned int NFree() const; return number of free parameters. bool GetCovMatrix(double* cov) const; get covariance matrix. bool GetHessianMatrix(double* h) const; get Hessian - inverse of covariance matrix; just invert it; but need to get the compact form to avoid the zero for the f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMinuitMinimizer.html:8298,perform,perform,8298,root/html530/TMinuitMinimizer.html,https://root.cern,https://root.cern/root/html530/TMinuitMinimizer.html,3,['perform'],['perform']
Performance,"on of FCN static function used internally by TMinuit.; Adapt IMultiGenFunction interface to TMinuit FCN static function. void FcnGrad(int& , double* g, double& f, double* , int ); implementation of FCN static function used internally by TMinuit.; Adapt IMultiGradFunction interface to TMinuit FCN static function in the case of user; provided gradient. bool SetVariable(unsigned int ivar, const string& name, double val, double step); set a free variable. bool SetLimitedVariable(unsigned int ivar, const string& name, double val, double step, double , double ); set a limited variable. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool SetVariableValue(unsigned int , double ); set the value of an existing variable; parameter must exist or return false. std::string VariableName(unsigned int ivar) const; return the variable name. int VariableIndex(const string& name) const; return variable index. bool Minimize(); perform the minimization using the algorithm chosen previously by the user; By default Migrad is used.; Return true if the found minimum is valid and update internal chached values of; minimum values, errors and covariance matrix.; Status of minimizer is set to:; migradResult + 10*minosResult + 100*hesseResult + 1000*improveResult. void RetrieveParams(); retrieve from TMinuit minimum parameter values; and errors. void RetrieveErrorMatrix(); get covariance error matrix from TMinuit; when some parameters are fixed filled the corresponding rows and column with zero's. unsigned int NCalls() const; return total number of function calls. double MinValue() const; return minimum function value. double Edm() const; return expected distance from the minimum. unsigned int NFree() const; return number of free parameters. int CovMatrixStatus() const; return status of covariance matrix; status: 0= not calculated at all; 1= approximation only, not accurate; 2= full matrix, but forced positive-definite; 3= full accurate covariance matrix. dou",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMinuitMinimizer.html:8206,perform,perform,8206,root/html528/TMinuitMinimizer.html,https://root.cern,https://root.cern/root/html528/TMinuitMinimizer.html,1,['perform'],['perform']
Performance,"on of an assembly is very easy: one has just to create a TGeoVolumeAssembly object and position the components inside as for any volume:; TGeoVolume *vol = new TGeoVolumeAssembly(name);; vol->AddNode(vdaughter1, cpy1, matrix1);; vol->AddNode(vdaughter2, cpy2, matrix2);; Note that components cannot be declared as “overlapping” and that a component can be an assembly volume. For existing flat volume structures, one can define assemblies to force a hierarchical structure therefore optimizing the performance. Usage of assemblies does NOT imply penalties in performance, but in some cases, it can be observed that it is not as performing as bounding the structure in a container volume with a simple shape. Choosing a normal container is therefore recommended whenever possible. Assemblies of volumes. 18.4.3 Geometrical Transformations; All geometrical transformations handled by the modeller are provided as a built-in package. This was designed to minimize memory requirements and optimize performance of point/vector master-to-local and local-to-master computation. We need to have in mind that a transformation in TGeo has two major use-cases. The first one is for defining the placement of a volume with respect to its container reference frame. This frame will be called ‘master’ and the frame of the positioned volume - ‘local’. If T is a transformation used for positioning volume daughters, then: MASTER = T * LOCAL; Therefore Tis used to perform a local to master conversion, while T-1 for a master to local conversion. The second use case is the computation of the global transformation of a given object in the geometry. Since the geometry is built as ‘volumes-inside-volumes’, the global transformation represents the pile-up of all local transformations in the corresponding branch. Once a given object in the hierarchy becomes the current one, the conversion from master to local coordinates or the other way around can be done from the manager class.; A general homogenous transform",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:961071,optimiz,optimize,961071,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,4,"['optimiz', 'perform']","['optimize', 'performance']"
Performance,"on of directory on file; Long64_tTFile::fSeekFreeLocation on disk of free segments structure; Long64_tTFile::fSeekInfoLocation on disk of StreamerInfo record; Long64_tTDirectoryFile::fSeekKeysLocation of Keys record on file; Long64_tTDirectoryFile::fSeekParentLocation of parent directory on file; TSocket*fSocketconnection to rootd server; Double_tTFile::fSum2BufferSum of squares of buffer sizes of objects written so far; Double_tTFile::fSumBufferSum of buffer sizes of objects written so far; TStringTNamed::fTitleobject title; TUUIDTDirectory::fUUIDUnique identifier; Char_tTFile::fUnitsNumber of bytes for file pointers; TUrlTFile::fUrl!URL of file; TStringfUserremote user name; Int_tTFile::fVersionFile format version; Bool_tTDirectoryFile::fWritabletrue if directory is writable; Int_tTFile::fWrittenNumber of objects written so far; static Bool_tTDirectory::fgAddDirectory!flag to add histograms, graphs,etc to the directory; static TList*TFile::fgAsyncOpenRequestsList of handles for pending open requests; static atomic<Long64_t>TFile::fgBytesReadNumber of bytes read by all TFile objects; static atomic<Long64_t>TFile::fgBytesWriteNumber of bytes written by all TFile objects; static TStringTFile::fgCacheFileDirDirectory where to locally stage files; static Bool_tTFile::fgCacheFileDisconnectedIndicates, we trust in the files in the cache dir without stat on the cached file; static Bool_tTFile::fgCacheFileForceIndicates, to force all READ to CACHEREAD; static atomic<Long64_t>TFile::fgFileCounterCounter for all opened files; static Bool_tTFile::fgOnlyStagedBefore the file is opened, it is checked, that the file is staged, if not, the open fails; static UInt_tTFile::fgOpenTimeoutTimeout for open operations in ms - 0 corresponds to blocking i/o; static atomic<Int_t>TFile::fgReadCallsNumber of bytes read from all TFile objects; static Bool_tTFile::fgReadInfoif true (default) ReadStreamerInfo is called when opening a file; static Int_tTFile::fgReadaheadSizeReadahead buffer size.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TNetFile.html:25280,cache,cache,25280,root/html602/TNetFile.html,https://root.cern,https://root.cern/root/html602/TNetFile.html,10,"['CACHE', 'cache']","['CACHEREAD', 'cache', 'cached']"
Performance,"on range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxypdfProxy to p.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooCachedPdf.html:41436,cache,cache,41436,root/html530/RooCachedPdf.html,https://root.cern,https://root.cern/root/html530/RooCachedPdf.html,2,['cache'],['cache']
Performance,"on same inode (but this is not unique on AFS so we need the next 2 test; 1840 && ( leftBuf.st_size == rightBuf.st_size ) // Files of same size; 1841 && ( leftBuf.st_mtime == rightBuf.st_mtime ) // Files modified at the same time; 1842 );; 1843#endif; 1844}; 1845 ; 1846 ; 1847////////////////////////////////////////////////////////////////////////////////; 1848/// Load a shared library. Returns 0 on successful loading, 1 in; 1849/// case lib was already loaded, -1 in case lib does not exist; 1850/// or in case of error and -2 in case of version mismatch.; 1851/// When entry is specified the loaded lib is; 1852/// searched for this entry point (return -1 when entry does not exist,; 1853/// 0 otherwise). When the system flag is kTRUE, the library is considered; 1854/// a permanent system library that should not be unloaded during the; 1855/// course of the session.; 1856 ; 1857int TSystem::Load(const char *module, const char *entry, Bool_t system); 1858{; 1859 // don't load libraries that have already been loaded; 1860 TString libs( GetLibraries() );; 1861 TString l(BaseName(module));; 1862 ; 1863 Ssiz_t idx = l.Last('.');; 1864 if (idx != kNPOS) {; 1865 l.Remove(idx+1);; 1866 }; 1867 for (idx = libs.Index(l); idx != kNPOS; idx = libs.Index(l,idx+1)) {; 1868 // The libs contains the sub-string 'l', let's make sure it is; 1869 // not just part of a larger name.; 1870 if (idx == 0 || libs[idx-1] == '/' || libs[idx-1] == '\\') {; 1871 Ssiz_t len = libs.Length();; 1872 idx += l.Length();; 1873 if (!l.EndsWith(""."") && libs[idx]=='.'); 1874 idx++;; 1875 // Skip the soversion.; 1876 while (idx < len && isdigit(libs[idx])) {; 1877 ++idx;; 1878 // No need to test for len here, at worse idx==len and lib[idx]=='\0'; 1879 if (libs[idx] == '.') {; 1880 ++idx;; 1881 }; 1882 }; 1883 while (idx < len && libs[idx] != '.') {; 1884 if (libs[idx] == ' ' || idx+1 == len) {; 1885 return 1;; 1886 }; 1887 ++idx;; 1888 }; 1889 }; 1890 }; 1891 if (l[l.Length()-1] == '.') {; 1892 l.Remove(l.Lengt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8cxx_source.html:60113,load,load,60113,doc/master/TSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html,2,['load'],"['load', 'loaded']"
Performance,"on scheme ;  testUnfold3.C Simple Test program for the class TUnfoldDensity ;  testUnfold4.C Test program for the class TUnfoldSys ;  testUnfold5a.C Test program for the classes TUnfoldDensity and TUnfoldBinning ;  testUnfold5b.C Test program for the classes TUnfoldDensity and TUnfoldBinning ;  testUnfold5c.C Test program for the classes TUnfoldDensity and TUnfoldBinning ;  testUnfold5d.C Test program for the classes TUnfoldDensity and TUnfoldBinning ;  testUnfold6.C Test program for the class TUnfoldBinning ;  testUnfold7a.C Test program for the classes TUnfoldDensity and TUnfoldBinning ;  testUnfold7b.C Test program for the classes TUnfoldDensity and TUnfoldBinning ;  testUnfold7c.C Test program for the classes TUnfoldDensity and TUnfoldBinning ;  ► unuran;  unuranDemo.CExample macro to show unuran capabilities The results are compared with what is obtained using TRandom or TF1::GetRandom The macro is divided in 3 parts: ;  unuranFoamTest.CThis program must be compiled and executed with Aclic as follows ;  ► v7;  concurrentfill.cxx;  draw.cxx;  draw_subpads.cxx;  draw_th1.cxxThis macro generates a small V7 TH1D, fills it and draw it in a V7 canvas ;  draw_v6.cxx;  fitpanel.cxx;  histops.cxx;  line.cxx;  lineStyle.cxx;  lineWidth.cxx;  markerStyle.cxx;  pad.cxx;  perf.cxx;  perfcomp.cxx;  simple.cxx;  text.cxx;  ► vecops;  vo001_AdoptOrOwnMemory.C In this tutorial we learn how the RVec class can be used to adopt existing memory or allocate some ;  vo001_AdoptOrOwnMemory.py In this tutorial we learn how the RVec class can be used to adopt existing memory or allocate some ;  vo002_VectorCalculations.C In this tutorial we learn how the RVec class can be used to express easily mathematical operations involving arrays and scalars ;  vo003_LogicalOperations.C In this tutorial we learn how the RVec class can be used to express logical operations ;  ► xml;  DOMParsePerson.C ROOT implementation of a XML DOM Parser ;  DOMRecursive.C ROOT implementation of a XML DOM Parser ;  ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v614/files.html:164780,concurren,concurrentfill,164780,doc/v614/files.html,https://root.cern,https://root.cern/doc/v614/files.html,1,['concurren'],['concurrentfill']
Performance,"on scheme ;  testUnfold3.C Simple Test program for the class TUnfoldDensity ;  testUnfold4.C Test program for the class TUnfoldSys ;  testUnfold5a.C Test program for the classes TUnfoldDensity and TUnfoldBinning ;  testUnfold5b.C Test program for the classes TUnfoldDensity and TUnfoldBinning ;  testUnfold5c.C Test program for the classes TUnfoldDensity and TUnfoldBinning ;  testUnfold5d.C Test program for the classes TUnfoldDensity and TUnfoldBinning ;  testUnfold6.C Test program for the class TUnfoldBinning ;  testUnfold7a.C Test program for the classes TUnfoldDensity and TUnfoldBinning ;  testUnfold7b.C Test program for the classes TUnfoldDensity and TUnfoldBinning ;  testUnfold7c.C Test program for the classes TUnfoldDensity and TUnfoldBinning ;  ► unuran;  unuranDemo.CExample macro to show unuran capabilities The results are compared with what is obtained using TRandom or TF1::GetRandom The macro is divided in 3 parts: ;  unuranFoamTest.CThis program must be compiled and executed with Aclic as follows ;  ► v7;  concurrentfill.cxx;  draw.cxx;  draw_th1.cxx;  draw_v6.cxx;  fitpanel.cxx;  histops.cxx;  perf.cxx;  perfcomp.cxx;  simple.cxx;  text.cxx;  ► xml;  DOMParsePerson.C ROOT implementation of a XML DOM Parser ;  DOMRecursive.C ROOT implementation of a XML DOM Parser ;  SAXHandler.C ROOT implementation of a simple SAX Handler ;  xmlnewfile.C Example to create a new xml file with the TXMLEngine class ;  xmlreadfile.C Example to read and parse any xml file, supported by TXMLEngine class The input file, produced by xmlnewfile.C macro is used If you need full xml syntax support, use TXMLParser instead ;  benchmarks.CThis macro run several tests and produces an benchmark report ;  demos.CThis macro shows a control bar to run some of the ROOT tutorials ;  demoshelp.CThis macro shows help on running the Demos ;  geant3tasks.CThis script is a representation using TTasks of the Geant3 simulation program This example uses directly TTask objects ;  hsimple.C This program ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/files.html:161561,concurren,concurrentfill,161561,doc/v612/files.html,https://root.cern,https://root.cern/doc/v612/files.html,1,['concurren'],['concurrentfill']
Performance,"on scheme ;  testUnfold3.C Simple Test program for the class TUnfoldDensity ;  testUnfold4.C Test program for the class TUnfoldSys ;  testUnfold5a.C Test program for the classes TUnfoldDensity and TUnfoldBinning ;  testUnfold5b.C Test program for the classes TUnfoldDensity and TUnfoldBinning ;  testUnfold5c.C Test program for the classes TUnfoldDensity and TUnfoldBinning ;  testUnfold5d.C Test program for the classes TUnfoldDensity and TUnfoldBinning ;  testUnfold6.C Test program for the class TUnfoldBinning ;  testUnfold7a.C Test program for the classes TUnfoldDensity and TUnfoldBinning ;  testUnfold7b.C Test program for the classes TUnfoldDensity and TUnfoldBinning ;  testUnfold7c.C Test program for the classes TUnfoldDensity and TUnfoldBinning ;  ► unuran;  unuranDemo.CExample macro to show unuran capabilities The results are compared with what is obtained using TRandom or TF1::GetRandom The macro is divided in 3 parts: ;  unuranFoamTest.CThis program must be compiled and executed with Aclic as follows ;  ► v7;  concurrentfill.cxx;  draw.cxx;  histops.cxx;  histspeedtest.cxx;  perf.cxx;  perfcomp.cxx;  simple.cxx;  ► xml;  DOMParsePerson.C ROOT implementation of a XML DOM Parser ;  DOMRecursive.C ROOT implementation of a XML DOM Parser ;  SAXHandler.C ROOT implementation of a simple SAX Handler ;  xmlnewfile.C Example to create a new xml file with the TXMLEngine class ;  xmlreadfile.C Example to read and parse any xml file, supported by TXMLEngine class The input file, produced by xmlnewfile.C macro is used If you need full xml syntax support, use TXMLParser instead ;  benchmarks.CThis macro run several tests and produces an benchmark report ;  demos.CThis macro shows a control bar to run some of the ROOT tutorials ;  demoshelp.CThis macro shows help on running the Demos ;  geant3tasks.CThis script is a representation using TTasks of the Geant3 simulation program This example uses directly TTask objects ;  hsimple.C This program creates : ;  htmlex.CThis file demo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v610/files.html:160735,concurren,concurrentfill,160735,doc/v610/files.html,https://root.cern,https://root.cern/doc/v610/files.html,1,['concurren'],['concurrentfill']
Performance,"on specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; RooRealProxy_x; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Bool_t_asymLeft; Bool_t_asymRight; Double_t_binWidth; Double_t*_dataPts[_nEvents]; Double_t_hi; Double_t_lo; Double_t_lookupTable[1001]; Bool_t_mirrorLeft; Bool_t_mirrorRight; Int_t_nEvents; Double_t_rho; Char_t_varName[128]; Double_t*_weights[_nEvents]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooKeysPdf(). RooKeysPdf(const char* name, const char* title, RooAbsReal& x, RooDataSet& data, RooKeysPdf::Mirror mirror = NoMirror, Double_t rho = 1); cache stuff about x. RooKeysPdf(const RooKeysPdf& other, const char* name = 0). ~RooKeysPdf(). LoadDataSet(RooDataSet& data). Double_t evaluate() const. Double_t evaluateFull(Double_t x) const. Double_t g(Double_t x, Double_t sigma) const. TObject* clone(const char* newname) const; {return new RooKeysPdf(*this,newname); }. » Last changed: Mon Dec 7 13:48:05 2009 » Last generated: 2009-12-07 13:48; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooKeysPdf.html:40715,cache,cache,40715,root/html526/RooKeysPdf.html,https://root.cern,https://root.cern/root/html526/RooKeysPdf.html,1,['cache'],['cache']
Performance,"on temporarily makes all RooRealIntegrals created during; 538 // that time always include all components.; 539 GlobalSelectComponentRAII selCompRAII(true);; 540 normInt = std::unique_ptr<RooAbsReal>{createIntegral(depList,*getIntegratorConfig(),nr)}.release();; 541 }; 542 static_cast<RooRealIntegral*>(normInt)->setAllowComponentSelection(false);; 543 normInt->getVal() ;; 544// cout << ""resulting normInt = "" << normInt->GetName() << endl ;; 545 ; 546 const char* cacheParamsStr = getStringAttribute(""CACHEPARAMINT"") ;; 547 if (cacheParamsStr && strlen(cacheParamsStr)) {; 548 ; 549 std::unique_ptr<RooArgSet> intParams{normInt->getVariables()} ;; 550 ; 551 RooArgSet cacheParams = RooHelpers::selectFromArgSet(*intParams, cacheParamsStr);; 552 ; 553 if (!cacheParams.empty()) {; 554 cxcoutD(Caching) << ""RooAbsReal::createIntObj("" << GetName() << "") INFO: constructing "" << cacheParams.size(); 555 << ""-dim value cache for integral over "" << depList << "" as a function of "" << cacheParams << "" in range "" << (nr?nr:""<default>"") << endl ;; 556 string name = Form(""%s_CACHE_[%s]"",normInt->GetName(),cacheParams.contentsString().c_str()) ;; 557 RooCachedReal* cachedIntegral = new RooCachedReal(name.c_str(),name.c_str(),*normInt,cacheParams) ;; 558 cachedIntegral->setInterpolationOrder(2) ;; 559 cachedIntegral->addOwnedComponents(*normInt) ;; 560 cachedIntegral->setCacheSource(true) ;; 561 if (normInt->operMode()==ADirty) {; 562 cachedIntegral->setOperMode(ADirty) ;; 563 }; 564 normInt= cachedIntegral ;; 565 }; 566 ; 567 }; 568 _norm = normInt ;; 569 }; 570 ; 571 // Register new normalization with manager (takes ownership); 572 cache = new CacheElem(*_norm) ;; 573 _normMgr.setObj(nset,cache) ;; 574 ; 575// cout << ""making new object "" << _norm->GetName() << endl ;; 576 ; 577 return true ;; 578}; 579 ; 580 ; 581 ; 582////////////////////////////////////////////////////////////////////////////////; 583/// Reset error counter to given value, limiting the number; 584/// of future error mes",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html:21503,cache,cache,21503,doc/master/RooAbsPdf_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html,3,['cache'],"['cache', 'cacheParams']"
Performance,"on to minimize. void SetFunction(const ROOT::Math::IMultiGradFunction & func); set gradient the function to minimize. bool SetVariable(unsigned int ivar, const string& name, double val, double step); set free variable. bool SetLowerLimitedVariable(unsigned int ivar, const string& name, double val, double step, double lower); set lower limited variable. bool SetUpperLimitedVariable(unsigned int ivar, const string& name, double val, double step, double upper); set upper limited variable. bool SetLimitedVariable(unsigned int ivar, const string& name, double val, double step, double lower, double upper); set upper/lower limited variable. bool SetFixedVariable(unsigned int ivar, const string& name, double val); set fixed variable. bool SetVariableValue(unsigned int ivar, double val); set the value of an existing variable. bool SetVariableValues(const double* x); set the values of all existing variables (array must be dimensioned to the size of existing parameters). bool Minimize(); method to perform the minimization. double MinValue() const; return minimum function value. { return fMinVal; }. double Edm() const; return expected distance reached from the minimum. const double * X() const; return pointer to X values at the minimum. { return &fValues.front(); }. const double * MinGradient() const; return pointer to gradient values at the minimum. unsigned int NCalls() const; number of function calls to reach the minimum. { return 0; }. unsigned int NFree() const; number of free variables (real dimension of the problem); this is <= Function().NDim() which is the total. { return fNFree; }. bool ProvidesError() const; minimizer provides error and error matrix. { return true; }. const double * Errors() const; return errors at the minimum. { return (fErrors.size() > 0) ? &fErrors.front() : 0; }. double CovMatrix(unsigned int , unsigned int ) const; {; static std::vector<double> err;; err.resize(fDim);; return &err.front();; }; return covariance matrices elements; if the variable ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__GSLNLSMinimizer.html:6962,perform,perform,6962,root/html526/ROOT__Math__GSLNLSMinimizer.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__GSLNLSMinimizer.html,1,['perform'],['perform']
